[
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_int#16",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_int(self)",
        "snippet": "    def test_loc_getitem_int(self):\n\n        # int label\n        self.check_result(\"loc\", 2, typs=[\"labels\"], fails=KeyError)",
        "begin_line": 16,
        "end_line": 19,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label#21",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label(self)",
        "snippet": "    def test_loc_getitem_label(self):\n\n        # label\n        self.check_result(\"loc\", \"c\", typs=[\"empty\"], fails=KeyError)",
        "begin_line": 21,
        "end_line": 24,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_out_of_range#26",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_out_of_range(self)",
        "snippet": "    def test_loc_getitem_label_out_of_range(self):\n\n        # out of range label\n        self.check_result(\n            \"loc\", \"f\", typs=[\"ints\", \"uints\", \"labels\", \"mixed\", \"ts\"], fails=KeyError,\n        )\n        self.check_result(\"loc\", \"f\", typs=[\"floats\"], fails=KeyError)\n        self.check_result(\"loc\", \"f\", typs=[\"floats\"], fails=KeyError)\n        self.check_result(\n            \"loc\", 20, typs=[\"ints\", \"uints\", \"mixed\"], fails=KeyError,\n        )\n        self.check_result(\"loc\", 20, typs=[\"labels\"], fails=KeyError)\n        self.check_result(\"loc\", 20, typs=[\"ts\"], axes=0, fails=TypeError)\n        self.check_result(\"loc\", 20, typs=[\"floats\"], axes=0, fails=KeyError)",
        "begin_line": 26,
        "end_line": 39,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_list#41",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_list(self)",
        "snippet": "    def test_loc_getitem_label_list(self):\n        # TODO: test something here?\n        # list of labels\n        pass",
        "begin_line": 41,
        "end_line": 44,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_list_with_missing#46",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_list_with_missing(self)",
        "snippet": "    def test_loc_getitem_label_list_with_missing(self):\n        self.check_result(\n            \"loc\", [0, 1, 2], typs=[\"empty\"], fails=KeyError,\n        )\n        self.check_result(\n            \"loc\", [0, 2, 10], typs=[\"ints\", \"uints\", \"floats\"], axes=0, fails=KeyError,\n        )\n\n        self.check_result(\n            \"loc\", [3, 6, 7], typs=[\"ints\", \"uints\", \"floats\"], axes=1, fails=KeyError,\n        )\n\n        # GH 17758 - MultiIndex and missing keys\n        self.check_result(\n            \"loc\", [(1, 3), (1, 4), (2, 5)], typs=[\"multi\"], axes=0, fails=KeyError,\n        )",
        "begin_line": 46,
        "end_line": 61,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_list_fails#63",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_list_fails(self)",
        "snippet": "    def test_loc_getitem_label_list_fails(self):\n        # fails\n        self.check_result(\n            \"loc\", [20, 30, 40], typs=[\"ints\", \"uints\"], axes=1, fails=KeyError,\n        )",
        "begin_line": 63,
        "end_line": 67,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_array_like#69",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_array_like(self)",
        "snippet": "    def test_loc_getitem_label_array_like(self):\n        # TODO: test something?\n        # array like\n        pass",
        "begin_line": 69,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_bool#74",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_bool(self)",
        "snippet": "    def test_loc_getitem_bool(self):\n        # boolean indexers\n        b = [True, False, True, False]\n\n        self.check_result(\"loc\", b, typs=[\"empty\"], fails=IndexError)",
        "begin_line": 74,
        "end_line": 78,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_slice#80",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_slice(self)",
        "snippet": "    def test_loc_getitem_label_slice(self):\n\n        # label slices (with ints)\n\n        # real label slices\n\n        # GH 14316\n\n        self.check_result(\n            \"loc\",\n            slice(1, 3),\n            typs=[\"labels\", \"mixed\", \"empty\", \"ts\", \"floats\"],\n            fails=TypeError,\n        )\n\n        self.check_result(\n            \"loc\", slice(\"20130102\", \"20130104\"), typs=[\"ts\"], axes=1, fails=TypeError,\n        )\n\n        self.check_result(\n            \"loc\", slice(2, 8), typs=[\"mixed\"], axes=0, fails=TypeError,\n        )\n        self.check_result(\n            \"loc\", slice(2, 8), typs=[\"mixed\"], axes=1, fails=KeyError,\n        )\n\n        self.check_result(\n            \"loc\", slice(2, 4, 2), typs=[\"mixed\"], axes=0, fails=TypeError,\n        )",
        "begin_line": 80,
        "end_line": 108,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_dups#114",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_dups(self)",
        "snippet": "    def test_loc_getitem_dups(self):\n        # GH 5678\n        # repeated getitems on a dup index returning a ndarray\n        df = DataFrame(\n            np.random.random_sample((20, 5)), index=[\"ABCDE\"[x % 5] for x in range(20)]\n        )\n        expected = df.loc[\"A\", 0]\n        result = df.loc[:, 0].loc[\"A\"]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 114,
        "end_line": 122,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_dups2#124",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_dups2(self)",
        "snippet": "    def test_loc_getitem_dups2(self):\n\n        # GH4726\n        # dup indexing with iloc/loc\n        df = DataFrame(\n            [[1, 2, \"foo\", \"bar\", Timestamp(\"20130101\")]],\n            columns=[\"a\", \"a\", \"a\", \"a\", \"a\"],\n            index=[1],\n        )\n        expected = Series(\n            [1, 2, \"foo\", \"bar\", Timestamp(\"20130101\")],\n            index=[\"a\", \"a\", \"a\", \"a\", \"a\"],\n            name=1,\n        )\n\n        result = df.iloc[0]\n        tm.assert_series_equal(result, expected)\n\n        result = df.loc[1]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 124,
        "end_line": 143,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_dups#145",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_dups(self)",
        "snippet": "    def test_loc_setitem_dups(self):\n\n        # GH 6541\n        df_orig = DataFrame(\n            {\n                \"me\": list(\"rttti\"),\n                \"foo\": list(\"aaade\"),\n                \"bar\": np.arange(5, dtype=\"float64\") * 1.34 + 2,\n                \"bar2\": np.arange(5, dtype=\"float64\") * -0.34 + 2,\n            }\n        ).set_index(\"me\")\n\n        indexer = tuple([\"r\", [\"bar\", \"bar2\"]])\n        df = df_orig.copy()\n        df.loc[indexer] *= 2.0\n        tm.assert_series_equal(df.loc[indexer], 2.0 * df_orig.loc[indexer])\n\n        indexer = tuple([\"r\", \"bar\"])\n        df = df_orig.copy()\n        df.loc[indexer] *= 2.0\n        assert df.loc[indexer] == 2.0 * df_orig.loc[indexer]\n\n        indexer = tuple([\"t\", [\"bar\", \"bar2\"]])\n        df = df_orig.copy()\n        df.loc[indexer] *= 2.0\n        tm.assert_frame_equal(df.loc[indexer], 2.0 * df_orig.loc[indexer])",
        "begin_line": 145,
        "end_line": 170,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_slice#172",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_slice(self)",
        "snippet": "    def test_loc_setitem_slice(self):\n        # GH10503\n\n        # assigning the same type should not change the type\n        df1 = DataFrame({\"a\": [0, 1, 1], \"b\": Series([100, 200, 300], dtype=\"uint32\")})\n        ix = df1[\"a\"] == 1\n        newb1 = df1.loc[ix, \"b\"] + 1\n        df1.loc[ix, \"b\"] = newb1\n        expected = DataFrame(\n            {\"a\": [0, 1, 1], \"b\": Series([100, 201, 301], dtype=\"uint32\")}\n        )\n        tm.assert_frame_equal(df1, expected)\n\n        # assigning a new type should get the inferred type\n        df2 = DataFrame({\"a\": [0, 1, 1], \"b\": [100, 200, 300]}, dtype=\"uint64\")\n        ix = df1[\"a\"] == 1\n        newb2 = df2.loc[ix, \"b\"]\n        df1.loc[ix, \"b\"] = newb2\n        expected = DataFrame({\"a\": [0, 1, 1], \"b\": [100, 200, 300]}, dtype=\"uint64\")\n        tm.assert_frame_equal(df2, expected)",
        "begin_line": 172,
        "end_line": 191,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_dtype#193",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_dtype(self)",
        "snippet": "    def test_loc_setitem_dtype(self):\n        # GH31340\n        df = DataFrame({\"id\": [\"A\"], \"a\": [1.2], \"b\": [0.0], \"c\": [-2.5]})\n        cols = [\"a\", \"b\", \"c\"]\n        df.loc[:, cols] = df.loc[:, cols].astype(\"float32\")\n\n        expected = DataFrame(\n            {\"id\": [\"A\"], \"a\": [1.2], \"b\": [0.0], \"c\": [-2.5]}, dtype=\"float32\"\n        )  # id is inferred as object\n\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 193,
        "end_line": 203,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_getitem_label_list_with_missing#205",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_getitem_label_list_with_missing(self)",
        "snippet": "    def test_getitem_label_list_with_missing(self):\n        s = Series(range(3), index=[\"a\", \"b\", \"c\"])\n\n        # consistency\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            s[[\"a\", \"d\"]]\n\n        s = Series(range(3))\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            s[[0, 3]]",
        "begin_line": 205,
        "end_line": 214,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_bool_diff_len#217",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_bool_diff_len(self, index)",
        "snippet": "    def test_loc_getitem_bool_diff_len(self, index):\n        # GH26658\n        s = Series([1, 2, 3])\n        msg = f\"Boolean index has wrong length: {len(index)} instead of {len(s)}\"\n        with pytest.raises(IndexError, match=msg):\n            _ = s.loc[index]",
        "begin_line": 217,
        "end_line": 222,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_int_slice#224",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_int_slice(self)",
        "snippet": "    def test_loc_getitem_int_slice(self):\n        # TODO: test something here?\n        pass",
        "begin_line": 224,
        "end_line": 226,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_to_fail#228",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_to_fail(self)",
        "snippet": "    def test_loc_to_fail(self):\n\n        # GH3449\n        df = DataFrame(\n            np.random.random((3, 3)), index=[\"a\", \"b\", \"c\"], columns=[\"e\", \"f\", \"g\"]\n        )\n\n        # raise a KeyError?\n        msg = (\n            r\"\\\"None of \\[Int64Index\\(\\[1, 2\\], dtype='int64'\\)\\] are \"\n            r\"in the \\[index\\]\\\"\"\n        )\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[1, 2], [1, 2]]\n\n        # GH  7496\n        # loc should not fallback\n\n        s = Series(dtype=object)\n        s.loc[1] = 1\n        s.loc[\"a\"] = 2\n\n        with pytest.raises(KeyError, match=r\"^-1$\"):\n            s.loc[-1]\n\n        msg = (\n            r\"\\\"None of \\[Int64Index\\(\\[-1, -2\\], dtype='int64'\\)\\] are \"\n            r\"in the \\[index\\]\\\"\"\n        )\n        with pytest.raises(KeyError, match=msg):\n            s.loc[[-1, -2]]\n\n        msg = r\"\\\"None of \\[Index\\(\\['4'\\], dtype='object'\\)\\] are in the \\[index\\]\\\"\"\n        with pytest.raises(KeyError, match=msg):\n            s.loc[[\"4\"]]\n\n        s.loc[-1] = 3\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            s.loc[[-1, -2]]\n\n        s[\"a\"] = 2\n        msg = (\n            r\"\\\"None of \\[Int64Index\\(\\[-2\\], dtype='int64'\\)\\] are \"\n            r\"in the \\[index\\]\\\"\"\n        )\n        with pytest.raises(KeyError, match=msg):\n            s.loc[[-2]]\n\n        del s[\"a\"]\n\n        with pytest.raises(KeyError, match=msg):\n            s.loc[[-2]] = 0\n\n        # inconsistency between .loc[values] and .loc[values,:]\n        # GH 7999\n        df = DataFrame([[\"a\"], [\"b\"]], index=[1, 2], columns=[\"value\"])\n\n        msg = (\n            r\"\\\"None of \\[Int64Index\\(\\[3\\], dtype='int64'\\)\\] are \"\n            r\"in the \\[index\\]\\\"\"\n        )\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[3], :]\n\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[3]]",
        "begin_line": 228,
        "end_line": 293,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_list_with_fail#295",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_list_with_fail(self)",
        "snippet": "    def test_loc_getitem_list_with_fail(self):\n        # 15747\n        # should KeyError if *any* missing labels\n\n        s = Series([1, 2, 3])\n\n        s.loc[[2]]\n\n        with pytest.raises(\n            KeyError,\n            match=re.escape(\n                \"\\\"None of [Int64Index([3], dtype='int64')] are in the [index]\\\"\"\n            ),\n        ):\n            s.loc[[3]]\n\n        # a non-match and a match\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            s.loc[[2, 3]]",
        "begin_line": 295,
        "end_line": 313,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_index#315",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_index(self)",
        "snippet": "    def test_loc_index(self):\n        # gh-17131\n        # a boolean index should index like a boolean numpy array\n\n        df = DataFrame(\n            np.random.random(size=(5, 10)),\n            index=[\"alpha_0\", \"alpha_1\", \"alpha_2\", \"beta_0\", \"beta_1\"],\n        )\n\n        mask = df.index.map(lambda x: \"alpha\" in x)\n        expected = df.loc[np.array(mask)]\n\n        result = df.loc[mask]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[mask.values]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[pd.array(mask, dtype=\"boolean\")]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 315,
        "end_line": 334,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_general#336",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_general(self)",
        "snippet": "    def test_loc_general(self):\n\n        df = DataFrame(\n            np.random.rand(4, 4),\n            columns=[\"A\", \"B\", \"C\", \"D\"],\n            index=[\"A\", \"B\", \"C\", \"D\"],\n        )\n\n        # want this to work\n        result = df.loc[:, \"A\":\"B\"].iloc[0:2, :]\n        assert (result.columns == [\"A\", \"B\"]).all()\n        assert (result.index == [\"A\", \"B\"]).all()\n\n        # mixed type\n        result = DataFrame({\"a\": [Timestamp(\"20130101\")], \"b\": [1]}).iloc[0]\n        expected = Series([Timestamp(\"20130101\"), 1], index=[\"a\", \"b\"], name=0)\n        tm.assert_series_equal(result, expected)\n        assert result.dtype == object",
        "begin_line": 336,
        "end_line": 353,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_consistency#355",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_consistency(self)",
        "snippet": "    def test_loc_setitem_consistency(self):\n        # GH 6149\n        # coerce similarly for setitem and loc when rows have a null-slice\n        expected = DataFrame(\n            {\n                \"date\": Series(0, index=range(5), dtype=np.int64),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n\n        df = DataFrame(\n            {\n                \"date\": date_range(\"2000-01-01\", \"2000-01-5\"),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df.loc[:, \"date\"] = 0\n        tm.assert_frame_equal(df, expected)\n\n        df = DataFrame(\n            {\n                \"date\": date_range(\"2000-01-01\", \"2000-01-5\"),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df.loc[:, \"date\"] = np.array(0, dtype=np.int64)\n        tm.assert_frame_equal(df, expected)\n\n        df = DataFrame(\n            {\n                \"date\": date_range(\"2000-01-01\", \"2000-01-5\"),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df.loc[:, \"date\"] = np.array([0, 0, 0, 0, 0], dtype=np.int64)\n        tm.assert_frame_equal(df, expected)\n\n        expected = DataFrame(\n            {\n                \"date\": Series(\"foo\", index=range(5)),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df = DataFrame(\n            {\n                \"date\": date_range(\"2000-01-01\", \"2000-01-5\"),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df.loc[:, \"date\"] = \"foo\"\n        tm.assert_frame_equal(df, expected)\n\n        expected = DataFrame(\n            {\n                \"date\": Series(1.0, index=range(5)),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df = DataFrame(\n            {\n                \"date\": date_range(\"2000-01-01\", \"2000-01-5\"),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df.loc[:, \"date\"] = 1.0\n        tm.assert_frame_equal(df, expected)\n\n        # GH 15494\n        # setting on frame with single row\n        df = DataFrame({\"date\": Series([Timestamp(\"20180101\")])})\n        df.loc[:, \"date\"] = \"string\"\n        expected = DataFrame({\"date\": Series([\"string\"])})\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 355,
        "end_line": 427,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_consistency_empty#429",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_consistency_empty(self)",
        "snippet": "    def test_loc_setitem_consistency_empty(self):\n        # empty (essentially noops)\n        expected = DataFrame(columns=[\"x\", \"y\"])\n        expected[\"x\"] = expected[\"x\"].astype(np.int64)\n        df = DataFrame(columns=[\"x\", \"y\"])\n        df.loc[:, \"x\"] = 1\n        tm.assert_frame_equal(df, expected)\n\n        df = DataFrame(columns=[\"x\", \"y\"])\n        df[\"x\"] = 1\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 429,
        "end_line": 439,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_consistency_slice_column_len#441",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_consistency_slice_column_len(self)",
        "snippet": "    def test_loc_setitem_consistency_slice_column_len(self):\n        # .loc[:,column] setting with slice == len of the column\n        # GH10408\n        data = \"\"\"Level_0,,,Respondent,Respondent,Respondent,OtherCat,OtherCat\nLevel_1,,,Something,StartDate,EndDate,Yes/No,SomethingElse\nRegion,Site,RespondentID,,,,,\nRegion_1,Site_1,3987227376,A,5/25/2015 10:59,5/25/2015 11:22,Yes,\nRegion_1,Site_1,3980680971,A,5/21/2015 9:40,5/21/2015 9:52,Yes,Yes\nRegion_1,Site_2,3977723249,A,5/20/2015 8:27,5/20/2015 8:41,Yes,\nRegion_1,Site_2,3977723089,A,5/20/2015 8:33,5/20/2015 9:09,Yes,No\"\"\"\n\n        df = pd.read_csv(StringIO(data), header=[0, 1], index_col=[0, 1, 2])\n        df.loc[:, (\"Respondent\", \"StartDate\")] = pd.to_datetime(\n            df.loc[:, (\"Respondent\", \"StartDate\")]\n        )\n        df.loc[:, (\"Respondent\", \"EndDate\")] = pd.to_datetime(\n            df.loc[:, (\"Respondent\", \"EndDate\")]\n        )\n        df.loc[:, (\"Respondent\", \"Duration\")] = (\n            df.loc[:, (\"Respondent\", \"EndDate\")]\n            - df.loc[:, (\"Respondent\", \"StartDate\")]\n        )\n\n        df.loc[:, (\"Respondent\", \"Duration\")] = df.loc[\n            :, (\"Respondent\", \"Duration\")\n        ].astype(\"timedelta64[s]\")\n        expected = Series(\n            [1380, 720, 840, 2160.0], index=df.index, name=(\"Respondent\", \"Duration\")\n        )\n        tm.assert_series_equal(df[(\"Respondent\", \"Duration\")], expected)",
        "begin_line": 441,
        "end_line": 470,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_assign_non_ns_datetime#473",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_assign_non_ns_datetime(self, unit)",
        "snippet": "    def test_loc_assign_non_ns_datetime(self, unit):\n        # GH 27395, non-ns dtype assignment via .loc should work\n        # and return the same result when using simple assignment\n        df = DataFrame(\n            {\n                \"timestamp\": [\n                    np.datetime64(\"2017-02-11 12:41:29\"),\n                    np.datetime64(\"1991-11-07 04:22:37\"),\n                ]\n            }\n        )\n\n        df.loc[:, unit] = df.loc[:, \"timestamp\"].values.astype(f\"datetime64[{unit}]\")\n        df[\"expected\"] = df.loc[:, \"timestamp\"].values.astype(f\"datetime64[{unit}]\")\n        expected = Series(df.loc[:, \"expected\"], name=unit)\n        tm.assert_series_equal(df.loc[:, unit], expected)",
        "begin_line": 473,
        "end_line": 488,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_modify_datetime#490",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_modify_datetime(self)",
        "snippet": "    def test_loc_modify_datetime(self):\n        # see gh-28837\n        df = DataFrame.from_dict(\n            {\"date\": [1485264372711, 1485265925110, 1540215845888, 1540282121025]}\n        )\n\n        df[\"date_dt\"] = pd.to_datetime(df[\"date\"], unit=\"ms\", cache=True)\n\n        df.loc[:, \"date_dt_cp\"] = df.loc[:, \"date_dt\"]\n        df.loc[[2, 3], \"date_dt_cp\"] = df.loc[[2, 3], \"date_dt\"]\n\n        expected = DataFrame(\n            [\n                [1485264372711, \"2017-01-24 13:26:12.711\", \"2017-01-24 13:26:12.711\"],\n                [1485265925110, \"2017-01-24 13:52:05.110\", \"2017-01-24 13:52:05.110\"],\n                [1540215845888, \"2018-10-22 13:44:05.888\", \"2018-10-22 13:44:05.888\"],\n                [1540282121025, \"2018-10-23 08:08:41.025\", \"2018-10-23 08:08:41.025\"],\n            ],\n            columns=[\"date\", \"date_dt\", \"date_dt_cp\"],\n        )\n\n        columns = [\"date_dt\", \"date_dt_cp\"]\n        expected[columns] = expected[columns].apply(pd.to_datetime)\n\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 490,
        "end_line": 514,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_frame#516",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_frame(self)",
        "snippet": "    def test_loc_setitem_frame(self):\n        df = DataFrame(np.random.randn(4, 4), index=list(\"abcd\"), columns=list(\"ABCD\"))\n\n        result = df.iloc[0, 0]\n\n        df.loc[\"a\", \"A\"] = 1\n        result = df.loc[\"a\", \"A\"]\n        assert result == 1\n\n        result = df.iloc[0, 0]\n        assert result == 1\n\n        df.loc[:, \"B\":\"D\"] = 0\n        expected = df.loc[:, \"B\":\"D\"]\n        result = df.iloc[:, 1:]\n        tm.assert_frame_equal(result, expected)\n\n        # GH 6254\n        # setting issue\n        df = DataFrame(index=[3, 5, 4], columns=[\"A\"])\n        df.loc[[4, 3, 5], \"A\"] = np.array([1, 2, 3], dtype=\"int64\")\n        expected = DataFrame(dict(A=Series([1, 2, 3], index=[4, 3, 5]))).reindex(\n            index=[3, 5, 4]\n        )\n        tm.assert_frame_equal(df, expected)\n\n        # GH 6252\n        # setting with an empty frame\n        keys1 = [\"@\" + str(i) for i in range(5)]\n        val1 = np.arange(5, dtype=\"int64\")\n\n        keys2 = [\"@\" + str(i) for i in range(4)]\n        val2 = np.arange(4, dtype=\"int64\")\n\n        index = list(set(keys1).union(keys2))\n        df = DataFrame(index=index)\n        df[\"A\"] = np.nan\n        df.loc[keys1, \"A\"] = val1\n\n        df[\"B\"] = np.nan\n        df.loc[keys2, \"B\"] = val2\n\n        expected = DataFrame(\n            dict(A=Series(val1, index=keys1), B=Series(val2, index=keys2))\n        ).reindex(index=index)\n        tm.assert_frame_equal(df, expected)\n\n        # GH 8669\n        # invalid coercion of nan -> int\n        df = DataFrame({\"A\": [1, 2, 3], \"B\": np.nan})\n        df.loc[df.B > df.A, \"B\"] = df.A\n        expected = DataFrame({\"A\": [1, 2, 3], \"B\": np.nan})\n        tm.assert_frame_equal(df, expected)\n\n        # GH 6546\n        # setting with mixed labels\n        df = DataFrame({1: [1, 2], 2: [3, 4], \"a\": [\"a\", \"b\"]})\n\n        result = df.loc[0, [1, 2]]\n        expected = Series([1, 3], index=[1, 2], dtype=object, name=0)\n        tm.assert_series_equal(result, expected)\n\n        expected = DataFrame({1: [5, 2], 2: [6, 4], \"a\": [\"a\", \"b\"]})\n        df.loc[0, [1, 2]] = [5, 6]\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 516,
        "end_line": 580,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_frame_multiples#582",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_frame_multiples(self)",
        "snippet": "    def test_loc_setitem_frame_multiples(self):\n        # multiple setting\n        df = DataFrame(\n            {\"A\": [\"foo\", \"bar\", \"baz\"], \"B\": Series(range(3), dtype=np.int64)}\n        )\n        rhs = df.loc[1:2]\n        rhs.index = df.index[0:2]\n        df.loc[0:1] = rhs\n        expected = DataFrame(\n            {\"A\": [\"bar\", \"baz\", \"baz\"], \"B\": Series([1, 2, 2], dtype=np.int64)}\n        )\n        tm.assert_frame_equal(df, expected)\n\n        # multiple setting with frame on rhs (with M8)\n        df = DataFrame(\n            {\n                \"date\": date_range(\"2000-01-01\", \"2000-01-5\"),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        expected = DataFrame(\n            {\n                \"date\": [\n                    Timestamp(\"20000101\"),\n                    Timestamp(\"20000102\"),\n                    Timestamp(\"20000101\"),\n                    Timestamp(\"20000102\"),\n                    Timestamp(\"20000103\"),\n                ],\n                \"val\": Series([0, 1, 0, 1, 2], dtype=np.int64),\n            }\n        )\n        rhs = df.loc[0:2]\n        rhs.index = df.index[2:5]\n        df.loc[2:4] = rhs\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 582,
        "end_line": 617,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_with_scalar_index#623",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_with_scalar_index(self, indexer, value)",
        "snippet": "    def test_loc_setitem_with_scalar_index(self, indexer, value):\n        # GH #19474\n        # assigning like \"df.loc[0, ['A']] = ['Z']\" should be evaluated\n        # elementwisely, not using \"setter('A', ['Z'])\".\n\n        df = pd.DataFrame([[1, 2], [3, 4]], columns=[\"A\", \"B\"])\n        df.loc[0, indexer] = value\n        result = df.loc[0, \"A\"]\n\n        assert is_scalar(result) and result == \"Z\"",
        "begin_line": 623,
        "end_line": 632,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_coercion#634",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_coercion(self)",
        "snippet": "    def test_loc_coercion(self):\n\n        # 12411\n        df = DataFrame({\"date\": [Timestamp(\"20130101\").tz_localize(\"UTC\"), pd.NaT]})\n        expected = df.dtypes\n\n        result = df.iloc[[0]]\n        tm.assert_series_equal(result.dtypes, expected)\n\n        result = df.iloc[[1]]\n        tm.assert_series_equal(result.dtypes, expected)\n\n        # 12045\n        import datetime\n\n        df = DataFrame(\n            {\"date\": [datetime.datetime(2012, 1, 1), datetime.datetime(1012, 1, 2)]}\n        )\n        expected = df.dtypes\n\n        result = df.iloc[[0]]\n        tm.assert_series_equal(result.dtypes, expected)\n\n        result = df.iloc[[1]]\n        tm.assert_series_equal(result.dtypes, expected)\n\n        # 11594\n        df = DataFrame({\"text\": [\"some words\"] + [None] * 9})\n        expected = df.dtypes\n\n        result = df.iloc[0:2]\n        tm.assert_series_equal(result.dtypes, expected)\n\n        result = df.iloc[3:]\n        tm.assert_series_equal(result.dtypes, expected)",
        "begin_line": 634,
        "end_line": 668,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_setitem_new_key_tz#670",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_setitem_new_key_tz(self)",
        "snippet": "    def test_setitem_new_key_tz(self):\n        # GH#12862 should not raise on assigning the second value\n        vals = [\n            pd.to_datetime(42).tz_localize(\"UTC\"),\n            pd.to_datetime(666).tz_localize(\"UTC\"),\n        ]\n        expected = pd.Series(vals, index=[\"foo\", \"bar\"])\n\n        ser = pd.Series(dtype=object)\n        ser[\"foo\"] = vals[0]\n        ser[\"bar\"] = vals[1]\n\n        tm.assert_series_equal(ser, expected)\n\n        ser = pd.Series(dtype=object)\n        ser.loc[\"foo\"] = vals[0]\n        ser.loc[\"bar\"] = vals[1]\n\n        tm.assert_series_equal(ser, expected)",
        "begin_line": 670,
        "end_line": 688,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_non_unique#690",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_non_unique(self)",
        "snippet": "    def test_loc_non_unique(self):\n        # GH3659\n        # non-unique indexer with loc slice\n        # https://groups.google.com/forum/?fromgroups#!topic/pydata/zTm2No0crYs\n\n        # these are going to raise because the we are non monotonic\n        df = DataFrame(\n            {\"A\": [1, 2, 3, 4, 5, 6], \"B\": [3, 4, 5, 6, 7, 8]}, index=[0, 1, 0, 1, 2, 3]\n        )\n        msg = \"'Cannot get left slice bound for non-unique label: 1'\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[1:]\n        msg = \"'Cannot get left slice bound for non-unique label: 0'\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[0:]\n        msg = \"'Cannot get left slice bound for non-unique label: 1'\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[1:2]\n\n        # monotonic are ok\n        df = DataFrame(\n            {\"A\": [1, 2, 3, 4, 5, 6], \"B\": [3, 4, 5, 6, 7, 8]}, index=[0, 1, 0, 1, 2, 3]\n        ).sort_index(axis=0)\n        result = df.loc[1:]\n        expected = DataFrame({\"A\": [2, 4, 5, 6], \"B\": [4, 6, 7, 8]}, index=[1, 1, 2, 3])\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[0:]\n        tm.assert_frame_equal(result, df)\n\n        result = df.loc[1:2]\n        expected = DataFrame({\"A\": [2, 4, 5], \"B\": [4, 6, 7]}, index=[1, 1, 2])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 690,
        "end_line": 722,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_non_unique_memory_error#724",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_non_unique_memory_error(self)",
        "snippet": "    def test_loc_non_unique_memory_error(self):\n\n        # GH 4280\n        # non_unique index with a large selection triggers a memory error\n\n        columns = list(\"ABCDEFG\")\n\n        def gen_test(l, l2):\n            return pd.concat(\n                [\n                    DataFrame(\n                        np.random.randn(l, len(columns)),\n                        index=np.arange(l),\n                        columns=columns,\n                    ),\n                    DataFrame(\n                        np.ones((l2, len(columns))), index=[0] * l2, columns=columns\n                    ),\n                ]\n            )\n\n        def gen_expected(df, mask):\n            len_mask = len(mask)\n            return pd.concat(\n                [\n                    df.take([0]),\n                    DataFrame(\n                        np.ones((len_mask, len(columns))),\n                        index=[0] * len_mask,\n                        columns=columns,\n                    ),\n                    df.take(mask[1:]),\n                ]\n            )\n\n        df = gen_test(900, 100)\n        assert df.index.is_unique is False\n\n        mask = np.arange(100)\n        result = df.loc[mask]\n        expected = gen_expected(df, mask)\n        tm.assert_frame_equal(result, expected)\n\n        df = gen_test(900000, 100000)\n        assert df.index.is_unique is False\n\n        mask = np.arange(100000)\n        result = df.loc[mask]\n        expected = gen_expected(df, mask)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 724,
        "end_line": 773,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.gen_test#731",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.gen_test(l, l2)",
        "snippet": "        def gen_test(l, l2):\n            return pd.concat(\n                [\n                    DataFrame(\n                        np.random.randn(l, len(columns)),\n                        index=np.arange(l),\n                        columns=columns,\n                    ),\n                    DataFrame(\n                        np.ones((l2, len(columns))), index=[0] * l2, columns=columns\n                    ),\n                ]\n            )",
        "begin_line": 731,
        "end_line": 743,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.gen_expected#745",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.gen_expected(df, mask)",
        "snippet": "        def gen_expected(df, mask):\n            len_mask = len(mask)\n            return pd.concat(\n                [\n                    df.take([0]),\n                    DataFrame(\n                        np.ones((len_mask, len(columns))),\n                        index=[0] * len_mask,\n                        columns=columns,\n                    ),\n                    df.take(mask[1:]),\n                ]\n            )",
        "begin_line": 745,
        "end_line": 757,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_name#775",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_name(self)",
        "snippet": "    def test_loc_name(self):\n        # GH 3880\n        df = DataFrame([[1, 1], [1, 1]])\n        df.index.name = \"index_name\"\n        result = df.iloc[[0, 1]].index.name\n        assert result == \"index_name\"\n\n        result = df.loc[[0, 1]].index.name\n        assert result == \"index_name\"",
        "begin_line": 775,
        "end_line": 783,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_empty_list_indexer_is_ok#785",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_empty_list_indexer_is_ok(self)",
        "snippet": "    def test_loc_empty_list_indexer_is_ok(self):\n\n        df = tm.makeCustomDataframe(5, 2)\n        # vertical empty\n        tm.assert_frame_equal(\n            df.loc[:, []], df.iloc[:, :0], check_index_type=True, check_column_type=True\n        )\n        # horizontal empty\n        tm.assert_frame_equal(\n            df.loc[[], :], df.iloc[:0, :], check_index_type=True, check_column_type=True\n        )\n        # horizontal empty\n        tm.assert_frame_equal(\n            df.loc[[]], df.iloc[:0, :], check_index_type=True, check_column_type=True\n        )",
        "begin_line": 785,
        "end_line": 799,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_identity_slice_returns_new_object#801",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_identity_slice_returns_new_object(self)",
        "snippet": "    def test_identity_slice_returns_new_object(self):\n        # GH13873\n        original_df = DataFrame({\"a\": [1, 2, 3]})\n        sliced_df = original_df.loc[:]\n        assert sliced_df is not original_df\n        assert original_df[:] is not original_df\n\n        # should be a shallow copy\n        original_df[\"a\"] = [4, 4, 4]\n        assert (sliced_df[\"a\"] == 4).all()\n\n        # These should not return copies\n        assert original_df is original_df.loc[:, :]\n        df = DataFrame(np.random.randn(10, 4))\n        assert df[0] is df.loc[:, 0]\n\n        # Same tests for Series\n        original_series = Series([1, 2, 3, 4, 5, 6])\n        sliced_series = original_series.loc[:]\n        assert sliced_series is not original_series\n        assert original_series[:] is not original_series\n\n        original_series[:3] = [7, 8, 9]\n        assert all(sliced_series[:3] == [7, 8, 9])",
        "begin_line": 801,
        "end_line": 824,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_uint64#826",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_uint64(self)",
        "snippet": "    def test_loc_uint64(self):\n        # GH20722\n        # Test whether loc accept uint64 max value as index.\n        s = pd.Series(\n            [1, 2], index=[np.iinfo(\"uint64\").max - 1, np.iinfo(\"uint64\").max]\n        )\n\n        result = s.loc[np.iinfo(\"uint64\").max - 1]\n        expected = s.iloc[0]\n        assert result == expected\n\n        result = s.loc[[np.iinfo(\"uint64\").max - 1]]\n        expected = s.iloc[[0]]\n        tm.assert_series_equal(result, expected)\n\n        result = s.loc[[np.iinfo(\"uint64\").max - 1, np.iinfo(\"uint64\").max]]\n        tm.assert_series_equal(result, s)",
        "begin_line": 826,
        "end_line": 842,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_empty_append#844",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_empty_append(self)",
        "snippet": "    def test_loc_setitem_empty_append(self):\n        # GH6173, various appends to an empty dataframe\n\n        data = [1, 2, 3]\n        expected = DataFrame({\"x\": data, \"y\": [None] * len(data)})\n\n        # appends to fit length of data\n        df = DataFrame(columns=[\"x\", \"y\"])\n        df.loc[:, \"x\"] = data\n        tm.assert_frame_equal(df, expected)\n\n        # only appends one value\n        expected = DataFrame({\"x\": [1.0], \"y\": [np.nan]})\n        df = DataFrame(columns=[\"x\", \"y\"], dtype=np.float)\n        df.loc[0, \"x\"] = expected.loc[0, \"x\"]\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 844,
        "end_line": 859,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_empty_append_raises#861",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_empty_append_raises(self)",
        "snippet": "    def test_loc_setitem_empty_append_raises(self):\n        # GH6173, various appends to an empty dataframe\n\n        data = [1, 2]\n        df = DataFrame(columns=[\"x\", \"y\"])\n        msg = (\n            r\"None of \\[Int64Index\\(\\[0, 1\\], dtype='int64'\\)\\] \"\n            r\"are in the \\[index\\]\"\n        )\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[0, 1], \"x\"] = data\n\n        msg = \"cannot copy sequence with size 2 to array axis with dimension 0\"\n        with pytest.raises(ValueError, match=msg):\n            df.loc[0:2, \"x\"] = data",
        "begin_line": 861,
        "end_line": 875,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_indexing_zerodim_np_array#877",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_indexing_zerodim_np_array(self)",
        "snippet": "    def test_indexing_zerodim_np_array(self):\n        # GH24924\n        df = DataFrame([[1, 2], [3, 4]])\n        result = df.loc[np.array(0)]\n        s = pd.Series([1, 2], name=0)\n        tm.assert_series_equal(result, s)",
        "begin_line": 877,
        "end_line": 882,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_series_indexing_zerodim_np_array#884",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_series_indexing_zerodim_np_array(self)",
        "snippet": "    def test_series_indexing_zerodim_np_array(self):\n        # GH24924\n        s = Series([1, 2])\n        result = s.loc[np.array(0)]\n        assert result == 1",
        "begin_line": 884,
        "end_line": 888,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_reverse_assignment#890",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_reverse_assignment(self)",
        "snippet": "    def test_loc_reverse_assignment(self):\n        # GH26939\n        data = [1, 2, 3, 4, 5, 6] + [None] * 4\n        expected = Series(data, index=range(2010, 2020))\n\n        result = pd.Series(index=range(2010, 2020), dtype=np.float64)\n        result.loc[2015:2010:-1] = [6, 5, 4, 3, 2, 1]\n\n        tm.assert_series_equal(result, expected)",
        "begin_line": 890,
        "end_line": 898,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_series_loc_getitem_label_list_missing_values#901",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_series_loc_getitem_label_list_missing_values()",
        "snippet": "def test_series_loc_getitem_label_list_missing_values():\n    # gh-11428\n    key = np.array(\n        [\"2001-01-04\", \"2001-01-02\", \"2001-01-04\", \"2001-01-14\"], dtype=\"datetime64\"\n    )\n    s = Series([2, 5, 8, 11], date_range(\"2001-01-01\", freq=\"D\", periods=4))\n    with pytest.raises(KeyError, match=\"with any missing labels\"):\n        s.loc[key]",
        "begin_line": 901,
        "end_line": 908,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_getitem_label_list_integer_labels#919",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_getitem_label_list_integer_labels(columns, column_key, expected_columns, check_column_type)",
        "snippet": "def test_loc_getitem_label_list_integer_labels(\n    columns, column_key, expected_columns, check_column_type\n):\n    # gh-14836\n    df = DataFrame(np.random.rand(3, 3), columns=columns, index=list(\"ABC\"))\n    expected = df.iloc[:, expected_columns]\n    result = df.loc[[\"A\", \"B\", \"C\"], column_key]\n    tm.assert_frame_equal(result, expected, check_column_type=check_column_type)",
        "begin_line": 919,
        "end_line": 926,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_setitem_float_intindex#929",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_setitem_float_intindex()",
        "snippet": "def test_loc_setitem_float_intindex():\n    # GH 8720\n    rand_data = np.random.randn(8, 4)\n    result = pd.DataFrame(rand_data)\n    result.loc[:, 0.5] = np.nan\n    expected_data = np.hstack((rand_data, np.array([np.nan] * 8).reshape(8, 1)))\n    expected = pd.DataFrame(expected_data, columns=[0.0, 1.0, 2.0, 3.0, 0.5])\n    tm.assert_frame_equal(result, expected)\n\n    result = pd.DataFrame(rand_data)\n    result.loc[:, 0.5] = np.nan\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 929,
        "end_line": 940,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_axis_1_slice#943",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_axis_1_slice()",
        "snippet": "def test_loc_axis_1_slice():\n    # GH 10586\n    cols = [(yr, m) for yr in [2014, 2015] for m in [7, 8, 9, 10]]\n    df = pd.DataFrame(\n        np.ones((10, 8)),\n        index=tuple(\"ABCDEFGHIJ\"),\n        columns=pd.MultiIndex.from_tuples(cols),\n    )\n    result = df.loc(axis=1)[(2014, 9):(2015, 8)]\n    expected = pd.DataFrame(\n        np.ones((10, 4)),\n        index=tuple(\"ABCDEFGHIJ\"),\n        columns=pd.MultiIndex.from_tuples(\n            [(2014, 9), (2014, 10), (2015, 7), (2015, 8)]\n        ),\n    )\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 943,
        "end_line": 959,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_set_dataframe_multiindex#962",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_set_dataframe_multiindex()",
        "snippet": "def test_loc_set_dataframe_multiindex():\n    # GH 14592\n    expected = pd.DataFrame(\n        \"a\", index=range(2), columns=pd.MultiIndex.from_product([range(2), range(2)])\n    )\n    result = expected.copy()\n    result.loc[0, [(0, 1)]] = result.loc[0, [(0, 1)]]\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 962,
        "end_line": 969,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_mixed_int_float#972",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_mixed_int_float()",
        "snippet": "def test_loc_mixed_int_float():\n    # GH#19456\n    ser = pd.Series(range(2), pd.Index([1, 2.0], dtype=object))\n\n    result = ser.loc[1]\n    assert result == 0",
        "begin_line": 972,
        "end_line": 977,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.setup_method#24",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n\n        self.df = DataFrame(\n            {\n                \"A\": np.arange(6, dtype=\"int64\"),\n                \"B\": Series(list(\"aabbca\")).astype(CDT(list(\"cab\"))),\n            }\n        ).set_index(\"B\")\n        self.df2 = DataFrame(\n            {\n                \"A\": np.arange(6, dtype=\"int64\"),\n                \"B\": Series(list(\"aabbca\")).astype(CDT(list(\"cabe\"))),\n            }\n        ).set_index(\"B\")\n        self.df3 = DataFrame(\n            {\n                \"A\": np.arange(6, dtype=\"int64\"),\n                \"B\": (Series([1, 1, 2, 1, 3, 2]).astype(CDT([3, 2, 1], ordered=True))),\n            }\n        ).set_index(\"B\")\n        self.df4 = DataFrame(\n            {\n                \"A\": np.arange(6, dtype=\"int64\"),\n                \"B\": (Series([1, 1, 2, 1, 3, 2]).astype(CDT([3, 2, 1], ordered=False))),\n            }\n        ).set_index(\"B\")",
        "begin_line": 24,
        "end_line": 49,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_scalar#51",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_scalar(self)",
        "snippet": "    def test_loc_scalar(self):\n        result = self.df.loc[\"a\"]\n        expected = DataFrame(\n            {\"A\": [0, 1, 5], \"B\": (Series(list(\"aaa\")).astype(CDT(list(\"cab\"))))}\n        ).set_index(\"B\")\n        tm.assert_frame_equal(result, expected)\n\n        df = self.df.copy()\n        df.loc[\"a\"] = 20\n        expected = DataFrame(\n            {\n                \"A\": [20, 20, 2, 3, 4, 20],\n                \"B\": (Series(list(\"aabbca\")).astype(CDT(list(\"cab\")))),\n            }\n        ).set_index(\"B\")\n        tm.assert_frame_equal(df, expected)\n\n        # value not in the categories\n        with pytest.raises(KeyError, match=r\"^'d'$\"):\n            df.loc[\"d\"]\n\n        msg = \"cannot append a non-category item to a CategoricalIndex\"\n        with pytest.raises(TypeError, match=msg):\n            df.loc[\"d\"] = 10\n\n        msg = (\n            \"cannot insert an item into a CategoricalIndex that is not \"\n            \"already an existing category\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            df.loc[\"d\", \"A\"] = 10\n        with pytest.raises(TypeError, match=msg):\n            df.loc[\"d\", \"C\"] = 10\n\n        with pytest.raises(KeyError, match=\"^1$\"):\n            df.loc[1]",
        "begin_line": 51,
        "end_line": 86,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_getitem_scalar#88",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_getitem_scalar(self)",
        "snippet": "    def test_getitem_scalar(self):\n\n        cats = Categorical([Timestamp(\"12-31-1999\"), Timestamp(\"12-31-2000\")])\n\n        s = Series([1, 2], index=cats)\n\n        expected = s.iloc[0]\n        result = s[cats[0]]\n        assert result == expected",
        "begin_line": 88,
        "end_line": 96,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing_directly#98",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing_directly(self)",
        "snippet": "    def test_slicing_directly(self):\n        cat = Categorical([\"a\", \"b\", \"c\", \"d\", \"a\", \"b\", \"c\"])\n        sliced = cat[3]\n        assert sliced == \"d\"\n        sliced = cat[3:5]\n        expected = Categorical([\"d\", \"a\"], categories=[\"a\", \"b\", \"c\", \"d\"])\n        tm.assert_numpy_array_equal(sliced._codes, expected._codes)\n        tm.assert_index_equal(sliced.categories, expected.categories)",
        "begin_line": 98,
        "end_line": 105,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing#107",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing(self)",
        "snippet": "    def test_slicing(self):\n        cat = Series(Categorical([1, 2, 3, 4]))\n        reversed = cat[::-1]\n        exp = np.array([4, 3, 2, 1], dtype=np.int64)\n        tm.assert_numpy_array_equal(reversed.__array__(), exp)\n\n        df = DataFrame({\"value\": (np.arange(100) + 1).astype(\"int64\")})\n        df[\"D\"] = pd.cut(df.value, bins=[0, 25, 50, 75, 100])\n\n        expected = Series([11, Interval(0, 25)], index=[\"value\", \"D\"], name=10)\n        result = df.iloc[10]\n        tm.assert_series_equal(result, expected)\n\n        expected = DataFrame(\n            {\"value\": np.arange(11, 21).astype(\"int64\")},\n            index=np.arange(10, 20).astype(\"int64\"),\n        )\n        expected[\"D\"] = pd.cut(expected.value, bins=[0, 25, 50, 75, 100])\n        result = df.iloc[10:20]\n        tm.assert_frame_equal(result, expected)\n\n        expected = Series([9, Interval(0, 25)], index=[\"value\", \"D\"], name=8)\n        result = df.loc[8]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 107,
        "end_line": 130,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing_and_getting_ops#132",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing_and_getting_ops(self)",
        "snippet": "    def test_slicing_and_getting_ops(self):\n\n        # systematically test the slicing operations:\n        #  for all slicing ops:\n        #   - returning a dataframe\n        #   - returning a column\n        #   - returning a row\n        #   - returning a single value\n\n        cats = Categorical(\n            [\"a\", \"c\", \"b\", \"c\", \"c\", \"c\", \"c\"], categories=[\"a\", \"b\", \"c\"]\n        )\n        idx = Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        values = [1, 2, 3, 4, 5, 6, 7]\n        df = DataFrame({\"cats\": cats, \"values\": values}, index=idx)\n\n        # the expected values\n        cats2 = Categorical([\"b\", \"c\"], categories=[\"a\", \"b\", \"c\"])\n        idx2 = Index([\"j\", \"k\"])\n        values2 = [3, 4]\n\n        # 2:4,: | \"j\":\"k\",:\n        exp_df = DataFrame({\"cats\": cats2, \"values\": values2}, index=idx2)\n\n        # :,\"cats\" | :,0\n        exp_col = Series(cats, index=idx, name=\"cats\")\n\n        # \"j\",: | 2,:\n        exp_row = Series([\"b\", 3], index=[\"cats\", \"values\"], dtype=\"object\", name=\"j\")\n\n        # \"j\",\"cats | 2,0\n        exp_val = \"b\"\n\n        # iloc\n        # frame\n        res_df = df.iloc[2:4, :]\n        tm.assert_frame_equal(res_df, exp_df)\n        assert is_categorical_dtype(res_df[\"cats\"])\n\n        # row\n        res_row = df.iloc[2, :]\n        tm.assert_series_equal(res_row, exp_row)\n        assert isinstance(res_row[\"cats\"], str)\n\n        # col\n        res_col = df.iloc[:, 0]\n        tm.assert_series_equal(res_col, exp_col)\n        assert is_categorical_dtype(res_col)\n\n        # single value\n        res_val = df.iloc[2, 0]\n        assert res_val == exp_val\n\n        # loc\n        # frame\n        res_df = df.loc[\"j\":\"k\", :]\n        tm.assert_frame_equal(res_df, exp_df)\n        assert is_categorical_dtype(res_df[\"cats\"])\n\n        # row\n        res_row = df.loc[\"j\", :]\n        tm.assert_series_equal(res_row, exp_row)\n        assert isinstance(res_row[\"cats\"], str)\n\n        # col\n        res_col = df.loc[:, \"cats\"]\n        tm.assert_series_equal(res_col, exp_col)\n        assert is_categorical_dtype(res_col)\n\n        # single value\n        res_val = df.loc[\"j\", \"cats\"]\n        assert res_val == exp_val\n\n        # ix\n        # frame\n        # res_df = df.loc[\"j\":\"k\",[0,1]] # doesn't work?\n        res_df = df.loc[\"j\":\"k\", :]\n        tm.assert_frame_equal(res_df, exp_df)\n        assert is_categorical_dtype(res_df[\"cats\"])\n\n        # row\n        res_row = df.loc[\"j\", :]\n        tm.assert_series_equal(res_row, exp_row)\n        assert isinstance(res_row[\"cats\"], str)\n\n        # col\n        res_col = df.loc[:, \"cats\"]\n        tm.assert_series_equal(res_col, exp_col)\n        assert is_categorical_dtype(res_col)\n\n        # single value\n        res_val = df.loc[\"j\", df.columns[0]]\n        assert res_val == exp_val\n\n        # iat\n        res_val = df.iat[2, 0]\n        assert res_val == exp_val\n\n        # at\n        res_val = df.at[\"j\", \"cats\"]\n        assert res_val == exp_val\n\n        # fancy indexing\n        exp_fancy = df.iloc[[2]]\n\n        res_fancy = df[df[\"cats\"] == \"b\"]\n        tm.assert_frame_equal(res_fancy, exp_fancy)\n        res_fancy = df[df[\"values\"] == 3]\n        tm.assert_frame_equal(res_fancy, exp_fancy)\n\n        # get_value\n        res_val = df.at[\"j\", \"cats\"]\n        assert res_val == exp_val\n\n        # i : int, slice, or sequence of integers\n        res_row = df.iloc[2]\n        tm.assert_series_equal(res_row, exp_row)\n        assert isinstance(res_row[\"cats\"], str)\n\n        res_df = df.iloc[slice(2, 4)]\n        tm.assert_frame_equal(res_df, exp_df)\n        assert is_categorical_dtype(res_df[\"cats\"])\n\n        res_df = df.iloc[[2, 3]]\n        tm.assert_frame_equal(res_df, exp_df)\n        assert is_categorical_dtype(res_df[\"cats\"])\n\n        res_col = df.iloc[:, 0]\n        tm.assert_series_equal(res_col, exp_col)\n        assert is_categorical_dtype(res_col)\n\n        res_df = df.iloc[:, slice(0, 2)]\n        tm.assert_frame_equal(res_df, df)\n        assert is_categorical_dtype(res_df[\"cats\"])\n\n        res_df = df.iloc[:, [0, 1]]\n        tm.assert_frame_equal(res_df, df)\n        assert is_categorical_dtype(res_df[\"cats\"])",
        "begin_line": 132,
        "end_line": 269,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing_doc_examples#271",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing_doc_examples(self)",
        "snippet": "    def test_slicing_doc_examples(self):\n\n        # GH 7918\n        cats = Categorical(\n            [\"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"], categories=[\"a\", \"b\", \"c\"]\n        )\n        idx = Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        values = [1, 2, 2, 2, 3, 4, 5]\n        df = DataFrame({\"cats\": cats, \"values\": values}, index=idx)\n\n        result = df.iloc[2:4, :]\n        expected = DataFrame(\n            {\n                \"cats\": Categorical([\"b\", \"b\"], categories=[\"a\", \"b\", \"c\"]),\n                \"values\": [2, 2],\n            },\n            index=[\"j\", \"k\"],\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[2:4, :].dtypes\n        expected = Series([\"category\", \"int64\"], [\"cats\", \"values\"])\n        tm.assert_series_equal(result, expected)\n\n        result = df.loc[\"h\":\"j\", \"cats\"]\n        expected = Series(\n            Categorical([\"a\", \"b\", \"b\"], categories=[\"a\", \"b\", \"c\"]),\n            index=[\"h\", \"i\", \"j\"],\n            name=\"cats\",\n        )\n        tm.assert_series_equal(result, expected)\n\n        result = df.loc[\"h\":\"j\", df.columns[0:1]]\n        expected = DataFrame(\n            {\"cats\": Categorical([\"a\", \"b\", \"b\"], categories=[\"a\", \"b\", \"c\"])},\n            index=[\"h\", \"i\", \"j\"],\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 271,
        "end_line": 308,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_getitem_category_type#310",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_getitem_category_type(self)",
        "snippet": "    def test_getitem_category_type(self):\n        # GH 14580\n        # test iloc() on Series with Categorical data\n\n        s = Series([1, 2, 3]).astype(\"category\")\n\n        # get slice\n        result = s.iloc[0:2]\n        expected = Series([1, 2]).astype(CategoricalDtype([1, 2, 3]))\n        tm.assert_series_equal(result, expected)\n\n        # get list of indexes\n        result = s.iloc[[0, 1]]\n        expected = Series([1, 2]).astype(CategoricalDtype([1, 2, 3]))\n        tm.assert_series_equal(result, expected)\n\n        # get boolean array\n        result = s.iloc[[True, False, False]]\n        expected = Series([1]).astype(CategoricalDtype([1, 2, 3]))\n        tm.assert_series_equal(result, expected)",
        "begin_line": 310,
        "end_line": 329,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_listlike#331",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_listlike(self)",
        "snippet": "    def test_loc_listlike(self):\n\n        # list of labels\n        result = self.df.loc[[\"c\", \"a\"]]\n        expected = self.df.iloc[[4, 0, 1, 5]]\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = self.df2.loc[[\"a\", \"b\", \"e\"]]\n        exp_index = CategoricalIndex(list(\"aaabbe\"), categories=list(\"cabe\"), name=\"B\")\n        expected = DataFrame({\"A\": [0, 1, 5, 2, 3, np.nan]}, index=exp_index)\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        # element in the categories but not in the values\n        with pytest.raises(KeyError, match=r\"^'e'$\"):\n            self.df2.loc[\"e\"]\n\n        # assign is ok\n        df = self.df2.copy()\n        df.loc[\"e\"] = 20\n        result = df.loc[[\"a\", \"b\", \"e\"]]\n        exp_index = CategoricalIndex(list(\"aaabbe\"), categories=list(\"cabe\"), name=\"B\")\n        expected = DataFrame({\"A\": [0, 1, 5, 2, 3, 20]}, index=exp_index)\n        tm.assert_frame_equal(result, expected)\n\n        df = self.df2.copy()\n        result = df.loc[[\"a\", \"b\", \"e\"]]\n        exp_index = CategoricalIndex(list(\"aaabbe\"), categories=list(\"cabe\"), name=\"B\")\n        expected = DataFrame({\"A\": [0, 1, 5, 2, 3, np.nan]}, index=exp_index)\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        # not all labels in the categories\n        with pytest.raises(\n            KeyError,\n            match=(\n                \"'a list-indexer must only include values that are in the categories'\"\n            ),\n        ):\n            self.df2.loc[[\"a\", \"d\"]]",
        "begin_line": 331,
        "end_line": 368,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_listlike_dtypes#370",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_listlike_dtypes(self)",
        "snippet": "    def test_loc_listlike_dtypes(self):\n        # GH 11586\n\n        # unique categories and codes\n        index = CategoricalIndex([\"a\", \"b\", \"c\"])\n        df = DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]}, index=index)\n\n        # unique slice\n        res = df.loc[[\"a\", \"b\"]]\n        exp_index = CategoricalIndex([\"a\", \"b\"], categories=index.categories)\n        exp = DataFrame({\"A\": [1, 2], \"B\": [4, 5]}, index=exp_index)\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        # duplicated slice\n        res = df.loc[[\"a\", \"a\", \"b\"]]\n\n        exp_index = CategoricalIndex([\"a\", \"a\", \"b\"], categories=index.categories)\n        exp = DataFrame({\"A\": [1, 1, 2], \"B\": [4, 4, 5]}, index=exp_index)\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        msg = \"a list-indexer must only include values that are in the categories\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[\"a\", \"x\"]]\n\n        # duplicated categories and codes\n        index = CategoricalIndex([\"a\", \"b\", \"a\"])\n        df = DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]}, index=index)\n\n        # unique slice\n        res = df.loc[[\"a\", \"b\"]]\n        exp = DataFrame(\n            {\"A\": [1, 3, 2], \"B\": [4, 6, 5]}, index=CategoricalIndex([\"a\", \"a\", \"b\"])\n        )\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        # duplicated slice\n        res = df.loc[[\"a\", \"a\", \"b\"]]\n        exp = DataFrame(\n            {\"A\": [1, 3, 1, 3, 2], \"B\": [4, 6, 4, 6, 5]},\n            index=CategoricalIndex([\"a\", \"a\", \"a\", \"a\", \"b\"]),\n        )\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        msg = \"a list-indexer must only include values that are in the categories\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[\"a\", \"x\"]]\n\n        # contains unused category\n        index = CategoricalIndex([\"a\", \"b\", \"a\", \"c\"], categories=list(\"abcde\"))\n        df = DataFrame({\"A\": [1, 2, 3, 4], \"B\": [5, 6, 7, 8]}, index=index)\n\n        res = df.loc[[\"a\", \"b\"]]\n        exp = DataFrame(\n            {\"A\": [1, 3, 2], \"B\": [5, 7, 6]},\n            index=CategoricalIndex([\"a\", \"a\", \"b\"], categories=list(\"abcde\")),\n        )\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        res = df.loc[[\"a\", \"e\"]]\n        exp = DataFrame(\n            {\"A\": [1, 3, np.nan], \"B\": [5, 7, np.nan]},\n            index=CategoricalIndex([\"a\", \"a\", \"e\"], categories=list(\"abcde\")),\n        )\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        # duplicated slice\n        res = df.loc[[\"a\", \"a\", \"b\"]]\n        exp = DataFrame(\n            {\"A\": [1, 3, 1, 3, 2], \"B\": [5, 7, 5, 7, 6]},\n            index=CategoricalIndex([\"a\", \"a\", \"a\", \"a\", \"b\"], categories=list(\"abcde\")),\n        )\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        msg = \"a list-indexer must only include values that are in the categories\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[\"a\", \"x\"]]",
        "begin_line": 370,
        "end_line": 445,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_get_indexer_array#447",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_get_indexer_array(self)",
        "snippet": "    def test_get_indexer_array(self):\n        arr = np.array(\n            [Timestamp(\"1999-12-31 00:00:00\"), Timestamp(\"2000-12-31 00:00:00\")],\n            dtype=object,\n        )\n        cats = [Timestamp(\"1999-12-31 00:00:00\"), Timestamp(\"2000-12-31 00:00:00\")]\n        ci = CategoricalIndex(cats, categories=cats, ordered=False, dtype=\"category\")\n        result = ci.get_indexer(arr)\n        expected = np.array([0, 1], dtype=\"intp\")\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 447,
        "end_line": 456,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_get_indexer_same_categories_same_order#458",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_get_indexer_same_categories_same_order(self)",
        "snippet": "    def test_get_indexer_same_categories_same_order(self):\n        ci = CategoricalIndex([\"a\", \"b\"], categories=[\"a\", \"b\"])\n\n        result = ci.get_indexer(CategoricalIndex([\"b\", \"b\"], categories=[\"a\", \"b\"]))\n        expected = np.array([1, 1], dtype=\"intp\")\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 458,
        "end_line": 463,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_get_indexer_same_categories_different_order#465",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_get_indexer_same_categories_different_order(self)",
        "snippet": "    def test_get_indexer_same_categories_different_order(self):\n        # https://github.com/pandas-dev/pandas/issues/19551\n        ci = CategoricalIndex([\"a\", \"b\"], categories=[\"a\", \"b\"])\n\n        result = ci.get_indexer(CategoricalIndex([\"b\", \"b\"], categories=[\"b\", \"a\"]))\n        expected = np.array([1, 1], dtype=\"intp\")\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 465,
        "end_line": 471,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_getitem_with_listlike#473",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_getitem_with_listlike(self)",
        "snippet": "    def test_getitem_with_listlike(self):\n        # GH 16115\n        cats = Categorical([Timestamp(\"12-31-1999\"), Timestamp(\"12-31-2000\")])\n\n        expected = DataFrame(\n            [[1, 0], [0, 1]], dtype=\"uint8\", index=[0, 1], columns=cats\n        )\n        dummies = pd.get_dummies(cats)\n        result = dummies[list(dummies.columns)]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 473,
        "end_line": 482,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_setitem_listlike#484",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_setitem_listlike(self)",
        "snippet": "    def test_setitem_listlike(self):\n\n        # GH 9469\n        # properly coerce the input indexers\n        np.random.seed(1)\n        c = Categorical(\n            np.random.randint(0, 5, size=150000).astype(np.int8)\n        ).add_categories([-1000])\n        indexer = np.array([100000]).astype(np.int64)\n        c[indexer] = -1000\n\n        # we are asserting the code result here\n        # which maps to the -1000 category\n        result = c.codes[np.array([100000]).astype(np.int64)]\n        tm.assert_numpy_array_equal(result, np.array([5], dtype=\"int8\"))",
        "begin_line": 484,
        "end_line": 498,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_ix_categorical_index#500",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_ix_categorical_index(self)",
        "snippet": "    def test_ix_categorical_index(self):\n        # GH 12531\n        df = DataFrame(np.random.randn(3, 3), index=list(\"ABC\"), columns=list(\"XYZ\"))\n        cdf = df.copy()\n        cdf.index = CategoricalIndex(df.index)\n        cdf.columns = CategoricalIndex(df.columns)\n\n        expect = Series(df.loc[\"A\", :], index=cdf.columns, name=\"A\")\n        tm.assert_series_equal(cdf.loc[\"A\", :], expect)\n\n        expect = Series(df.loc[:, \"X\"], index=cdf.index, name=\"X\")\n        tm.assert_series_equal(cdf.loc[:, \"X\"], expect)\n\n        exp_index = CategoricalIndex(list(\"AB\"), categories=[\"A\", \"B\", \"C\"])\n        expect = DataFrame(df.loc[[\"A\", \"B\"], :], columns=cdf.columns, index=exp_index)\n        tm.assert_frame_equal(cdf.loc[[\"A\", \"B\"], :], expect)\n\n        exp_columns = CategoricalIndex(list(\"XY\"), categories=[\"X\", \"Y\", \"Z\"])\n        expect = DataFrame(df.loc[:, [\"X\", \"Y\"]], index=cdf.index, columns=exp_columns)\n        tm.assert_frame_equal(cdf.loc[:, [\"X\", \"Y\"]], expect)\n\n        # non-unique\n        df = DataFrame(np.random.randn(3, 3), index=list(\"ABA\"), columns=list(\"XYX\"))\n        cdf = df.copy()\n        cdf.index = CategoricalIndex(df.index)\n        cdf.columns = CategoricalIndex(df.columns)\n\n        exp_index = CategoricalIndex(list(\"AA\"), categories=[\"A\", \"B\"])\n        expect = DataFrame(df.loc[\"A\", :], columns=cdf.columns, index=exp_index)\n        tm.assert_frame_equal(cdf.loc[\"A\", :], expect)\n\n        exp_columns = CategoricalIndex(list(\"XX\"), categories=[\"X\", \"Y\"])\n        expect = DataFrame(df.loc[:, \"X\"], index=cdf.index, columns=exp_columns)\n        tm.assert_frame_equal(cdf.loc[:, \"X\"], expect)\n\n        expect = DataFrame(\n            df.loc[[\"A\", \"B\"], :],\n            columns=cdf.columns,\n            index=CategoricalIndex(list(\"AAB\")),\n        )\n        tm.assert_frame_equal(cdf.loc[[\"A\", \"B\"], :], expect)\n\n        expect = DataFrame(\n            df.loc[:, [\"X\", \"Y\"]],\n            index=cdf.index,\n            columns=CategoricalIndex(list(\"XXY\")),\n        )\n        tm.assert_frame_equal(cdf.loc[:, [\"X\", \"Y\"]], expect)",
        "begin_line": 500,
        "end_line": 547,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_read_only_source#549",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_read_only_source(self)",
        "snippet": "    def test_read_only_source(self):\n        # GH 10043\n        rw_array = np.eye(10)\n        rw_df = DataFrame(rw_array)\n\n        ro_array = np.eye(10)\n        ro_array.setflags(write=False)\n        ro_df = DataFrame(ro_array)\n\n        tm.assert_frame_equal(rw_df.iloc[[1, 2, 3]], ro_df.iloc[[1, 2, 3]])\n        tm.assert_frame_equal(rw_df.iloc[[1]], ro_df.iloc[[1]])\n        tm.assert_series_equal(rw_df.iloc[1], ro_df.iloc[1])\n        tm.assert_frame_equal(rw_df.iloc[1:3], ro_df.iloc[1:3])\n\n        tm.assert_frame_equal(rw_df.loc[[1, 2, 3]], ro_df.loc[[1, 2, 3]])\n        tm.assert_frame_equal(rw_df.loc[[1]], ro_df.loc[[1]])\n        tm.assert_series_equal(rw_df.loc[1], ro_df.loc[1])\n        tm.assert_frame_equal(rw_df.loc[1:3], ro_df.loc[1:3])",
        "begin_line": 549,
        "end_line": 566,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_reindexing#568",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_reindexing(self)",
        "snippet": "    def test_reindexing(self):\n        df = DataFrame(\n            {\n                \"A\": np.arange(3, dtype=\"int64\"),\n                \"B\": Series(list(\"abc\")).astype(CDT(list(\"cabe\"))),\n            }\n        ).set_index(\"B\")\n\n        # reindexing\n        # convert to a regular index\n        result = df.reindex([\"a\", \"b\", \"e\"])\n        expected = DataFrame({\"A\": [0, 1, np.nan], \"B\": Series(list(\"abe\"))}).set_index(\n            \"B\"\n        )\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex([\"a\", \"b\"])\n        expected = DataFrame({\"A\": [0, 1], \"B\": Series(list(\"ab\"))}).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex([\"e\"])\n        expected = DataFrame({\"A\": [np.nan], \"B\": Series([\"e\"])}).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex([\"d\"])\n        expected = DataFrame({\"A\": [np.nan], \"B\": Series([\"d\"])}).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        # since we are actually reindexing with a Categorical\n        # then return a Categorical\n        cats = list(\"cabe\")\n\n        result = df.reindex(Categorical([\"a\", \"e\"], categories=cats))\n        expected = DataFrame(\n            {\"A\": [0, np.nan], \"B\": Series(list(\"ae\")).astype(CDT(cats))}\n        ).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex(Categorical([\"a\"], categories=cats))\n        expected = DataFrame(\n            {\"A\": [0], \"B\": Series(list(\"a\")).astype(CDT(cats))}\n        ).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex([\"a\", \"b\", \"e\"])\n        expected = DataFrame({\"A\": [0, 1, np.nan], \"B\": Series(list(\"abe\"))}).set_index(\n            \"B\"\n        )\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex([\"a\", \"b\"])\n        expected = DataFrame({\"A\": [0, 1], \"B\": Series(list(\"ab\"))}).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex([\"e\"])\n        expected = DataFrame({\"A\": [np.nan], \"B\": Series([\"e\"])}).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        # give back the type of categorical that we received\n        result = df.reindex(Categorical([\"a\", \"e\"], categories=cats, ordered=True))\n        expected = DataFrame(\n            {\"A\": [0, np.nan], \"B\": Series(list(\"ae\")).astype(CDT(cats, ordered=True))}\n        ).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex(Categorical([\"a\", \"d\"], categories=[\"a\", \"d\"]))\n        expected = DataFrame(\n            {\"A\": [0, np.nan], \"B\": Series(list(\"ad\")).astype(CDT([\"a\", \"d\"]))}\n        ).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        # passed duplicate indexers are not allowed\n        msg = \"cannot reindex from a duplicate axis\"\n        with pytest.raises(ValueError, match=msg):\n            self.df2.reindex([\"a\", \"b\"])\n\n        # args NotImplemented ATM\n        msg = r\"argument {} is not implemented for CategoricalIndex\\.reindex\"\n        with pytest.raises(NotImplementedError, match=msg.format(\"method\")):\n            df.reindex([\"a\"], method=\"ffill\")\n        with pytest.raises(NotImplementedError, match=msg.format(\"level\")):\n            df.reindex([\"a\"], level=1)\n        with pytest.raises(NotImplementedError, match=msg.format(\"limit\")):\n            df.reindex([\"a\"], limit=2)",
        "begin_line": 568,
        "end_line": 651,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_slice#653",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_slice(self)",
        "snippet": "    def test_loc_slice(self):\n        # GH9748\n        with pytest.raises(KeyError, match=\"1\"):\n            self.df.loc[1:5]\n\n        result = self.df.loc[\"b\":\"c\"]\n        expected = self.df.iloc[[2, 3, 4]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 653,
        "end_line": 660,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_and_at_with_categorical_index#662",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_and_at_with_categorical_index(self)",
        "snippet": "    def test_loc_and_at_with_categorical_index(self):\n        # GH 20629\n        s = Series([1, 2, 3], index=pd.CategoricalIndex([\"A\", \"B\", \"C\"]))\n        assert s.loc[\"A\"] == 1\n        assert s.at[\"A\"] == 1\n        df = DataFrame(\n            [[1, 2], [3, 4], [5, 6]], index=pd.CategoricalIndex([\"A\", \"B\", \"C\"])\n        )\n        assert df.loc[\"B\", 1] == 4\n        assert df.at[\"B\", 1] == 4",
        "begin_line": 662,
        "end_line": 671,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_boolean_selection#673",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_boolean_selection(self)",
        "snippet": "    def test_boolean_selection(self):\n\n        df3 = self.df3\n        df4 = self.df4\n\n        result = df3[df3.index == \"a\"]\n        expected = df3.iloc[[]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df4[df4.index == \"a\"]\n        expected = df4.iloc[[]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df3[df3.index == 1]\n        expected = df3.iloc[[0, 1, 3]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df4[df4.index == 1]\n        expected = df4.iloc[[0, 1, 3]]\n        tm.assert_frame_equal(result, expected)\n\n        # since we have an ordered categorical\n\n        # CategoricalIndex([1, 1, 2, 1, 3, 2],\n        #         categories=[3, 2, 1],\n        #         ordered=True,\n        #         name='B')\n        result = df3[df3.index < 2]\n        expected = df3.iloc[[4]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df3[df3.index > 1]\n        expected = df3.iloc[[]]\n        tm.assert_frame_equal(result, expected)\n\n        # unordered\n        # cannot be compared\n\n        # CategoricalIndex([1, 1, 2, 1, 3, 2],\n        #         categories=[3, 2, 1],\n        #         ordered=False,\n        #         name='B')\n        msg = \"Unordered Categoricals can only compare equality or not\"\n        with pytest.raises(TypeError, match=msg):\n            df4[df4.index < 2]\n        with pytest.raises(TypeError, match=msg):\n            df4[df4.index > 1]",
        "begin_line": 673,
        "end_line": 719,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_indexing_with_category#721",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_indexing_with_category(self)",
        "snippet": "    def test_indexing_with_category(self):\n\n        # https://github.com/pandas-dev/pandas/issues/12564\n        # consistent result if comparing as Dataframe\n\n        cat = DataFrame({\"A\": [\"foo\", \"bar\", \"baz\"]})\n        exp = DataFrame({\"A\": [True, False, False]})\n\n        res = cat[[\"A\"]] == \"foo\"\n        tm.assert_frame_equal(res, exp)\n\n        cat[\"A\"] = cat[\"A\"].astype(\"category\")\n\n        res = cat[[\"A\"]] == \"foo\"\n        tm.assert_frame_equal(res, exp)",
        "begin_line": 721,
        "end_line": 735,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_map_with_dict_or_series#737",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_map_with_dict_or_series(self)",
        "snippet": "    def test_map_with_dict_or_series(self):\n        orig_values = [\"a\", \"B\", 1, \"a\"]\n        new_values = [\"one\", 2, 3.0, \"one\"]\n        cur_index = pd.CategoricalIndex(orig_values, name=\"XXX\")\n        expected = pd.CategoricalIndex(\n            new_values, name=\"XXX\", categories=[3.0, 2, \"one\"]\n        )\n\n        mapper = pd.Series(new_values[:-1], index=orig_values[:-1])\n        output = cur_index.map(mapper)\n        # Order of categories in output can be different\n        tm.assert_index_equal(expected, output)\n\n        mapper = {o: n for o, n in zip(orig_values[:-1], new_values[:-1])}\n        output = cur_index.map(mapper)\n        # Order of categories in output can be different\n        tm.assert_index_equal(expected, output)",
        "begin_line": 737,
        "end_line": 753,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_with_non_string_categories#781",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_with_non_string_categories(self, idx_values, ordered_fixture)",
        "snippet": "    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):\n        # GH-17569\n        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)\n        df = DataFrame({\"A\": [\"foo\", \"bar\", \"baz\"]}, index=cat_idx)\n        sl = slice(idx_values[0], idx_values[1])\n\n        # scalar selection\n        result = df.loc[idx_values[0]]\n        expected = Series([\"foo\"], index=[\"A\"], name=idx_values[0])\n        tm.assert_series_equal(result, expected)\n\n        # list selection\n        result = df.loc[idx_values[:2]]\n        expected = DataFrame([\"foo\", \"bar\"], index=cat_idx[:2], columns=[\"A\"])\n        tm.assert_frame_equal(result, expected)\n\n        # slice selection\n        result = df.loc[sl]\n        expected = DataFrame([\"foo\", \"bar\"], index=cat_idx[:2], columns=[\"A\"])\n        tm.assert_frame_equal(result, expected)\n\n        # scalar assignment\n        result = df.copy()\n        result.loc[idx_values[0]] = \"qux\"\n        expected = DataFrame({\"A\": [\"qux\", \"bar\", \"baz\"]}, index=cat_idx)\n        tm.assert_frame_equal(result, expected)\n\n        # list assignment\n        result = df.copy()\n        result.loc[idx_values[:2], \"A\"] = [\"qux\", \"qux2\"]\n        expected = DataFrame({\"A\": [\"qux\", \"qux2\", \"baz\"]}, index=cat_idx)\n        tm.assert_frame_equal(result, expected)\n\n        # slice assignment\n        result = df.copy()\n        result.loc[sl, \"A\"] = [\"qux\", \"qux2\"]\n        expected = DataFrame({\"A\": [\"qux\", \"qux2\", \"baz\"]}, index=cat_idx)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 781,
        "end_line": 818,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.conftest.multiindex_dataframe_random_data#9",
        "src_path": "pandas/tests/indexing/multiindex/conftest.py",
        "class_name": "pandas.tests.indexing.multiindex.conftest",
        "signature": "pandas.tests.indexing.multiindex.conftest.multiindex_dataframe_random_data()",
        "snippet": "def multiindex_dataframe_random_data():\n    \"\"\"DataFrame with 2 level MultiIndex with random data\"\"\"\n    index = MultiIndex(\n        levels=[[\"foo\", \"bar\", \"baz\", \"qux\"], [\"one\", \"two\", \"three\"]],\n        codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],\n        names=[\"first\", \"second\"],\n    )\n    return DataFrame(\n        np.random.randn(10, 3), index=index, columns=Index([\"A\", \"B\", \"C\"], name=\"exp\")\n    )",
        "begin_line": 9,
        "end_line": 18,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.conftest.multiindex_year_month_day_dataframe_random_data#22",
        "src_path": "pandas/tests/indexing/multiindex/conftest.py",
        "class_name": "pandas.tests.indexing.multiindex.conftest",
        "signature": "pandas.tests.indexing.multiindex.conftest.multiindex_year_month_day_dataframe_random_data()",
        "snippet": "def multiindex_year_month_day_dataframe_random_data():\n    \"\"\"\n    DataFrame with 3 level MultiIndex (year, month, day) covering\n    first 100 business days from 2000-01-01 with random data\n    \"\"\"\n    tdf = tm.makeTimeDataFrame(100)\n    ymd = tdf.groupby([lambda x: x.year, lambda x: x.month, lambda x: x.day]).sum()\n    # use Int64Index, to make sure things work\n    ymd.index.set_levels([lev.astype(\"i8\") for lev in ymd.index.levels], inplace=True)\n    ymd.index.set_names([\"year\", \"month\", \"day\"], inplace=True)\n    return ymd",
        "begin_line": 22,
        "end_line": 32,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common._mklbl#10",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common",
        "signature": "pandas.tests.indexing.common._mklbl(prefix, n)",
        "snippet": "def _mklbl(prefix, n):\n    return [f\"{prefix}{i}\" for i in range(n)]",
        "begin_line": 10,
        "end_line": 11,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common._axify#14",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common",
        "signature": "pandas.tests.indexing.common._axify(obj, key, axis)",
        "snippet": "def _axify(obj, key, axis):\n    # create a tuple accessor\n    axes = [slice(None)] * obj.ndim\n    axes[axis] = key\n    return tuple(axes)",
        "begin_line": 14,
        "end_line": 18,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.setup_method#37",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n\n        self.series_ints = Series(np.random.rand(4), index=np.arange(0, 8, 2))\n        self.frame_ints = DataFrame(\n            np.random.randn(4, 4), index=np.arange(0, 8, 2), columns=np.arange(0, 12, 3)\n        )\n\n        self.series_uints = Series(\n            np.random.rand(4), index=UInt64Index(np.arange(0, 8, 2))\n        )\n        self.frame_uints = DataFrame(\n            np.random.randn(4, 4),\n            index=UInt64Index(range(0, 8, 2)),\n            columns=UInt64Index(range(0, 12, 3)),\n        )\n\n        self.series_floats = Series(\n            np.random.rand(4), index=Float64Index(range(0, 8, 2))\n        )\n        self.frame_floats = DataFrame(\n            np.random.randn(4, 4),\n            index=Float64Index(range(0, 8, 2)),\n            columns=Float64Index(range(0, 12, 3)),\n        )\n\n        m_idces = [\n            MultiIndex.from_product([[1, 2], [3, 4]]),\n            MultiIndex.from_product([[5, 6], [7, 8]]),\n            MultiIndex.from_product([[9, 10], [11, 12]]),\n        ]\n\n        self.series_multi = Series(np.random.rand(4), index=m_idces[0])\n        self.frame_multi = DataFrame(\n            np.random.randn(4, 4), index=m_idces[0], columns=m_idces[1]\n        )\n\n        self.series_labels = Series(np.random.randn(4), index=list(\"abcd\"))\n        self.frame_labels = DataFrame(\n            np.random.randn(4, 4), index=list(\"abcd\"), columns=list(\"ABCD\")\n        )\n\n        self.series_mixed = Series(np.random.randn(4), index=[2, 4, \"null\", 8])\n        self.frame_mixed = DataFrame(np.random.randn(4, 4), index=[2, 4, \"null\", 8])\n\n        self.series_ts = Series(\n            np.random.randn(4), index=date_range(\"20130101\", periods=4)\n        )\n        self.frame_ts = DataFrame(\n            np.random.randn(4, 4), index=date_range(\"20130101\", periods=4)\n        )\n\n        dates_rev = date_range(\"20130101\", periods=4).sort_values(ascending=False)\n        self.series_ts_rev = Series(np.random.randn(4), index=dates_rev)\n        self.frame_ts_rev = DataFrame(np.random.randn(4, 4), index=dates_rev)\n\n        self.frame_empty = DataFrame()\n        self.series_empty = Series(dtype=object)\n\n        # form agglomerates\n        for kind in self._kinds:\n            d = dict()\n            for typ in self._typs:\n                d[typ] = getattr(self, f\"{kind}_{typ}\")\n\n            setattr(self, kind, d)",
        "begin_line": 37,
        "end_line": 101,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.generate_indices#103",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.generate_indices(self, f, values=False)",
        "snippet": "    def generate_indices(self, f, values=False):\n        \"\"\"\n        generate the indices\n        if values is True , use the axis values\n        is False, use the range\n        \"\"\"\n        axes = f.axes\n        if values:\n            axes = (list(range(len(ax))) for ax in axes)\n\n        return itertools.product(*axes)",
        "begin_line": 103,
        "end_line": 113,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.get_value#115",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.get_value(self, name, f, i, values=False)",
        "snippet": "    def get_value(self, name, f, i, values=False):\n        \"\"\" return the value for the location i \"\"\"\n        # check against values\n        if values:\n            return f.values[i]\n\n        elif name == \"iat\":\n            return f.iloc[i]\n        else:\n            assert name == \"at\"\n            return f.loc[i]",
        "begin_line": 115,
        "end_line": 125,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.check_values#127",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.check_values(self, f, func, values=False)",
        "snippet": "    def check_values(self, f, func, values=False):\n\n        if f is None:\n            return\n        axes = f.axes\n        indicies = itertools.product(*axes)\n\n        for i in indicies:\n            result = getattr(f, func)[i]\n\n            # check against values\n            if values:\n                expected = f.values[i]\n            else:\n                expected = f\n                for a in reversed(i):\n                    expected = expected.__getitem__(a)\n\n            tm.assert_almost_equal(result, expected)",
        "begin_line": 127,
        "end_line": 145,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.check_result#147",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.check_result(self, method, key, typs=None, axes=None, fails=None)",
        "snippet": "    def check_result(\n        self, method, key, typs=None, axes=None, fails=None,\n    ):\n        def _eq(axis, obj, key):\n            \"\"\" compare equal for these 2 keys \"\"\"\n            axified = _axify(obj, key, axis)\n            try:\n                getattr(obj, method).__getitem__(axified)\n\n            except (IndexError, TypeError, KeyError) as detail:\n\n                # if we are in fails, the ok, otherwise raise it\n                if fails is not None:\n                    if isinstance(detail, fails):\n                        return\n                raise\n\n        if typs is None:\n            typs = self._typs\n\n        if axes is None:\n            axes = [0, 1]\n        else:\n            assert axes in [0, 1]\n            axes = [axes]\n\n        # check\n        for kind in self._kinds:\n\n            d = getattr(self, kind)\n            for ax in axes:\n                for typ in typs:\n                    assert typ in self._typs\n\n                    obj = d[typ]\n                    if ax < obj.ndim:\n                        _eq(axis=ax, obj=obj, key=key)",
        "begin_line": 147,
        "end_line": 183,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base._eq#150",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base._eq(axis, obj, key)",
        "snippet": "        def _eq(axis, obj, key):\n            \"\"\" compare equal for these 2 keys \"\"\"\n            axified = _axify(obj, key, axis)\n            try:\n                getattr(obj, method).__getitem__(axified)\n\n            except (IndexError, TypeError, KeyError) as detail:\n\n                # if we are in fails, the ok, otherwise raise it\n                if fails is not None:\n                    if isinstance(detail, fails):\n                        return\n                raise",
        "begin_line": 150,
        "end_line": 162,
        "comment": "",
        "is_bug": false
    }
]