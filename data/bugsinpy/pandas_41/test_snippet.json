[
    {
        "name": "pandas.tests.internals.test_internals.mgr#21",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals",
        "signature": "pandas.tests.internals.test_internals.mgr()",
        "snippet": "def mgr():\n    return create_mgr(\n        \"a: f8; b: object; c: f8; d: object; e: f8;\"\n        \"f: bool; g: i8; h: complex; i: datetime-1; j: datetime-2;\"\n        \"k: M8[ns, US/Eastern]; l: M8[ns, CET];\"\n    )",
        "begin_line": 21,
        "end_line": 26,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.assert_block_equal#29",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals",
        "signature": "pandas.tests.internals.test_internals.assert_block_equal(left, right)",
        "snippet": "def assert_block_equal(left, right):\n    tm.assert_numpy_array_equal(left.values, right.values)\n    assert left.dtype == right.dtype\n    assert isinstance(left.mgr_locs, BlockPlacement)\n    assert isinstance(right.mgr_locs, BlockPlacement)\n    tm.assert_numpy_array_equal(left.mgr_locs.as_array, right.mgr_locs.as_array)",
        "begin_line": 29,
        "end_line": 34,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.get_numeric_mat#37",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals",
        "signature": "pandas.tests.internals.test_internals.get_numeric_mat(shape)",
        "snippet": "def get_numeric_mat(shape):\n    arr = np.arange(shape[0])\n    return np.lib.stride_tricks.as_strided(\n        x=arr, shape=shape, strides=(arr.itemsize,) + (0,) * (len(shape) - 1)\n    ).copy()",
        "begin_line": 37,
        "end_line": 41,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.create_block#47",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals",
        "signature": "pandas.tests.internals.test_internals.create_block(typestr, placement, item_shape=None, num_offset=0)",
        "snippet": "def create_block(typestr, placement, item_shape=None, num_offset=0):\n    \"\"\"\n    Supported typestr:\n\n        * float, f8, f4, f2\n        * int, i8, i4, i2, i1\n        * uint, u8, u4, u2, u1\n        * complex, c16, c8\n        * bool\n        * object, string, O\n        * datetime, dt, M8[ns], M8[ns, tz]\n        * timedelta, td, m8[ns]\n        * sparse (SparseArray with fill_value=0.0)\n        * sparse_na (SparseArray with fill_value=np.nan)\n        * category, category2\n\n    \"\"\"\n    placement = BlockPlacement(placement)\n    num_items = len(placement)\n\n    if item_shape is None:\n        item_shape = (N,)\n\n    shape = (num_items,) + item_shape\n\n    mat = get_numeric_mat(shape)\n\n    if typestr in (\n        \"float\",\n        \"f8\",\n        \"f4\",\n        \"f2\",\n        \"int\",\n        \"i8\",\n        \"i4\",\n        \"i2\",\n        \"i1\",\n        \"uint\",\n        \"u8\",\n        \"u4\",\n        \"u2\",\n        \"u1\",\n    ):\n        values = mat.astype(typestr) + num_offset\n    elif typestr in (\"complex\", \"c16\", \"c8\"):\n        values = 1.0j * (mat.astype(typestr) + num_offset)\n    elif typestr in (\"object\", \"string\", \"O\"):\n        values = np.reshape([f\"A{i:d}\" for i in mat.ravel() + num_offset], shape)\n    elif typestr in (\"b\", \"bool\"):\n        values = np.ones(shape, dtype=np.bool_)\n    elif typestr in (\"datetime\", \"dt\", \"M8[ns]\"):\n        values = (mat * 1e9).astype(\"M8[ns]\")\n    elif typestr.startswith(\"M8[ns\"):\n        # datetime with tz\n        m = re.search(r\"M8\\[ns,\\s*(\\w+\\/?\\w*)\\]\", typestr)\n        assert m is not None, f\"incompatible typestr -> {typestr}\"\n        tz = m.groups()[0]\n        assert num_items == 1, \"must have only 1 num items for a tz-aware\"\n        values = DatetimeIndex(np.arange(N) * 1e9, tz=tz)\n    elif typestr in (\"timedelta\", \"td\", \"m8[ns]\"):\n        values = (mat * 1).astype(\"m8[ns]\")\n    elif typestr in (\"category\",):\n        values = Categorical([1, 1, 2, 2, 3, 3, 3, 3, 4, 4])\n    elif typestr in (\"category2\",):\n        values = Categorical([\"a\", \"a\", \"a\", \"a\", \"b\", \"b\", \"c\", \"c\", \"c\", \"d\"])\n    elif typestr in (\"sparse\", \"sparse_na\"):\n        # FIXME: doesn't support num_rows != 10\n        assert shape[-1] == 10\n        assert all(s == 1 for s in shape[:-1])\n        if typestr.endswith(\"_na\"):\n            fill_value = np.nan\n        else:\n            fill_value = 0.0\n        values = SparseArray(\n            [fill_value, fill_value, 1, 2, 3, fill_value, 4, 5, fill_value, 6],\n            fill_value=fill_value,\n        )\n        arr = values.sp_values.view()\n        arr += num_offset - 1\n    else:\n        raise ValueError(f'Unsupported typestr: \"{typestr}\"')\n\n    return make_block(values, placement=placement, ndim=len(shape))",
        "begin_line": 47,
        "end_line": 129,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.create_single_mgr#132",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals",
        "signature": "pandas.tests.internals.test_internals.create_single_mgr(typestr, num_rows=None)",
        "snippet": "def create_single_mgr(typestr, num_rows=None):\n    if num_rows is None:\n        num_rows = N\n\n    return SingleBlockManager(\n        create_block(typestr, placement=slice(0, num_rows), item_shape=()),\n        np.arange(num_rows),\n    )",
        "begin_line": 132,
        "end_line": 139,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.create_mgr#142",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals",
        "signature": "pandas.tests.internals.test_internals.create_mgr(descr, item_shape=None)",
        "snippet": "def create_mgr(descr, item_shape=None):\n    \"\"\"\n    Construct BlockManager from string description.\n\n    String description syntax looks similar to np.matrix initializer.  It looks\n    like this::\n\n        a,b,c: f8; d,e,f: i8\n\n    Rules are rather simple:\n\n    * see list of supported datatypes in `create_block` method\n    * components are semicolon-separated\n    * each component is `NAME,NAME,NAME: DTYPE_ID`\n    * whitespace around colons & semicolons are removed\n    * components with same DTYPE_ID are combined into single block\n    * to force multiple blocks with same dtype, use '-SUFFIX'::\n\n        'a:f8-1; b:f8-2; c:f8-foobar'\n\n    \"\"\"\n    if item_shape is None:\n        item_shape = (N,)\n\n    offset = 0\n    mgr_items = []\n    block_placements = OrderedDict()\n    for d in descr.split(\";\"):\n        d = d.strip()\n        if not len(d):\n            continue\n        names, blockstr = d.partition(\":\")[::2]\n        blockstr = blockstr.strip()\n        names = names.strip().split(\",\")\n\n        mgr_items.extend(names)\n        placement = list(np.arange(len(names)) + offset)\n        try:\n            block_placements[blockstr].extend(placement)\n        except KeyError:\n            block_placements[blockstr] = placement\n        offset += len(names)\n\n    mgr_items = Index(mgr_items)\n\n    blocks = []\n    num_offset = 0\n    for blockstr, placement in block_placements.items():\n        typestr = blockstr.split(\"-\")[0]\n        blocks.append(\n            create_block(\n                typestr, placement, item_shape=item_shape, num_offset=num_offset\n            )\n        )\n        num_offset += len(placement)\n\n    return BlockManager(\n        sorted(blocks, key=lambda b: b.mgr_locs[0]),\n        [mgr_items] + [np.arange(n) for n in item_shape],\n    )",
        "begin_line": 142,
        "end_line": 201,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlock.setup_method#205",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlock",
        "signature": "pandas.tests.internals.test_internals.TestBlock.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n        self.fblock = create_block(\"float\", [0, 2, 4])\n        self.cblock = create_block(\"complex\", [7])\n        self.oblock = create_block(\"object\", [1, 3])\n        self.bool_block = create_block(\"bool\", [5])",
        "begin_line": 205,
        "end_line": 209,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlock.test_constructor#211",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlock",
        "signature": "pandas.tests.internals.test_internals.TestBlock.test_constructor(self)",
        "snippet": "    def test_constructor(self):\n        int32block = create_block(\"i4\", [0])\n        assert int32block.dtype == np.int32",
        "begin_line": 211,
        "end_line": 213,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlock.test_pickle#215",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlock",
        "signature": "pandas.tests.internals.test_internals.TestBlock.test_pickle(self)",
        "snippet": "    def test_pickle(self):\n        def _check(blk):\n            assert_block_equal(tm.round_trip_pickle(blk), blk)\n\n        _check(self.fblock)\n        _check(self.cblock)\n        _check(self.oblock)\n        _check(self.bool_block)",
        "begin_line": 215,
        "end_line": 222,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlock._check#216",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlock",
        "signature": "pandas.tests.internals.test_internals.TestBlock._check(blk)",
        "snippet": "        def _check(blk):\n            assert_block_equal(tm.round_trip_pickle(blk), blk)",
        "begin_line": 216,
        "end_line": 217,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlock.test_mgr_locs#224",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlock",
        "signature": "pandas.tests.internals.test_internals.TestBlock.test_mgr_locs(self)",
        "snippet": "    def test_mgr_locs(self):\n        assert isinstance(self.fblock.mgr_locs, BlockPlacement)\n        tm.assert_numpy_array_equal(\n            self.fblock.mgr_locs.as_array, np.array([0, 2, 4], dtype=np.int64)\n        )",
        "begin_line": 224,
        "end_line": 228,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlock.test_attrs#230",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlock",
        "signature": "pandas.tests.internals.test_internals.TestBlock.test_attrs(self)",
        "snippet": "    def test_attrs(self):\n        assert self.fblock.shape == self.fblock.values.shape\n        assert self.fblock.dtype == self.fblock.values.dtype\n        assert len(self.fblock) == len(self.fblock.values)",
        "begin_line": 230,
        "end_line": 233,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlock.test_merge#235",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlock",
        "signature": "pandas.tests.internals.test_internals.TestBlock.test_merge(self)",
        "snippet": "    def test_merge(self):\n        avals = tm.randn(2, 10)\n        bvals = tm.randn(2, 10)\n\n        ref_cols = Index([\"e\", \"a\", \"b\", \"d\", \"f\"])\n\n        ablock = make_block(avals, ref_cols.get_indexer([\"e\", \"b\"]))\n        bblock = make_block(bvals, ref_cols.get_indexer([\"a\", \"d\"]))\n        merged = ablock.merge(bblock)\n        tm.assert_numpy_array_equal(\n            merged.mgr_locs.as_array, np.array([0, 1, 2, 3], dtype=np.int64)\n        )\n        tm.assert_numpy_array_equal(merged.values[[0, 2]], np.array(avals))\n        tm.assert_numpy_array_equal(merged.values[[1, 3]], np.array(bvals))",
        "begin_line": 235,
        "end_line": 248,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlock.test_copy#250",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlock",
        "signature": "pandas.tests.internals.test_internals.TestBlock.test_copy(self)",
        "snippet": "    def test_copy(self):\n        cop = self.fblock.copy()\n        assert cop is not self.fblock\n        assert_block_equal(self.fblock, cop)",
        "begin_line": 250,
        "end_line": 253,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlock.test_delete#255",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlock",
        "signature": "pandas.tests.internals.test_internals.TestBlock.test_delete(self)",
        "snippet": "    def test_delete(self):\n        newb = self.fblock.copy()\n        newb.delete(0)\n        assert isinstance(newb.mgr_locs, BlockPlacement)\n        tm.assert_numpy_array_equal(\n            newb.mgr_locs.as_array, np.array([2, 4], dtype=np.int64)\n        )\n        assert (newb.values[0] == 1).all()\n\n        newb = self.fblock.copy()\n        newb.delete(1)\n        assert isinstance(newb.mgr_locs, BlockPlacement)\n        tm.assert_numpy_array_equal(\n            newb.mgr_locs.as_array, np.array([0, 4], dtype=np.int64)\n        )\n        assert (newb.values[1] == 2).all()\n\n        newb = self.fblock.copy()\n        newb.delete(2)\n        tm.assert_numpy_array_equal(\n            newb.mgr_locs.as_array, np.array([0, 2], dtype=np.int64)\n        )\n        assert (newb.values[1] == 1).all()\n\n        newb = self.fblock.copy()\n\n        with pytest.raises(IndexError, match=None):\n            newb.delete(3)",
        "begin_line": 255,
        "end_line": 282,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_attrs#286",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_attrs(self)",
        "snippet": "    def test_attrs(self):\n        mgr = create_mgr(\"a,b,c: f8-1; d,e,f: f8-2\")\n        assert mgr.nblocks == 2\n        assert len(mgr) == 6",
        "begin_line": 286,
        "end_line": 289,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_is_mixed_dtype#291",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_is_mixed_dtype(self)",
        "snippet": "    def test_is_mixed_dtype(self):\n        assert not create_mgr(\"a,b:f8\").is_mixed_type\n        assert not create_mgr(\"a:f8-1; b:f8-2\").is_mixed_type\n\n        assert create_mgr(\"a,b:f8; c,d: f4\").is_mixed_type\n        assert create_mgr(\"a,b:f8; c,d: object\").is_mixed_type",
        "begin_line": 291,
        "end_line": 296,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_duplicate_ref_loc_failure#298",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_duplicate_ref_loc_failure(self)",
        "snippet": "    def test_duplicate_ref_loc_failure(self):\n        tmp_mgr = create_mgr(\"a:bool; a: f8\")\n\n        axes, blocks = tmp_mgr.axes, tmp_mgr.blocks\n\n        blocks[0].mgr_locs = np.array([0])\n        blocks[1].mgr_locs = np.array([0])\n\n        # test trying to create block manager with overlapping ref locs\n\n        msg = \"Gaps in blk ref_locs\"\n\n        with pytest.raises(AssertionError, match=msg):\n            mgr = BlockManager(blocks, axes)\n            mgr._rebuild_blknos_and_blklocs()\n\n        blocks[0].mgr_locs = np.array([0])\n        blocks[1].mgr_locs = np.array([1])\n        mgr = BlockManager(blocks, axes)\n        mgr.iget(1)",
        "begin_line": 298,
        "end_line": 317,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_contains#319",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_contains(self, mgr)",
        "snippet": "    def test_contains(self, mgr):\n        assert \"a\" in mgr\n        assert \"baz\" not in mgr",
        "begin_line": 319,
        "end_line": 321,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_pickle#323",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_pickle(self, mgr)",
        "snippet": "    def test_pickle(self, mgr):\n\n        mgr2 = tm.round_trip_pickle(mgr)\n        tm.assert_frame_equal(DataFrame(mgr), DataFrame(mgr2))\n\n        # GH2431\n        assert hasattr(mgr2, \"_is_consolidated\")\n        assert hasattr(mgr2, \"_known_consolidated\")\n\n        # reset to False on load\n        assert not mgr2._is_consolidated\n        assert not mgr2._known_consolidated",
        "begin_line": 323,
        "end_line": 334,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_non_unique_pickle#337",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_non_unique_pickle(self, mgr_string)",
        "snippet": "    def test_non_unique_pickle(self, mgr_string):\n        mgr = create_mgr(mgr_string)\n        mgr2 = tm.round_trip_pickle(mgr)\n        tm.assert_frame_equal(DataFrame(mgr), DataFrame(mgr2))",
        "begin_line": 337,
        "end_line": 340,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_categorical_block_pickle#342",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_categorical_block_pickle(self)",
        "snippet": "    def test_categorical_block_pickle(self):\n        mgr = create_mgr(\"a: category\")\n        mgr2 = tm.round_trip_pickle(mgr)\n        tm.assert_frame_equal(DataFrame(mgr), DataFrame(mgr2))\n\n        smgr = create_single_mgr(\"category\")\n        smgr2 = tm.round_trip_pickle(smgr)\n        tm.assert_series_equal(Series(smgr), Series(smgr2))",
        "begin_line": 342,
        "end_line": 349,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_get#351",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_get(self)",
        "snippet": "    def test_get(self):\n        cols = Index(list(\"abc\"))\n        values = np.random.rand(3, 3)\n        block = make_block(values=values.copy(), placement=np.arange(3))\n        mgr = BlockManager(blocks=[block], axes=[cols, np.arange(3)])\n\n        tm.assert_almost_equal(mgr.get(\"a\").internal_values(), values[0])\n        tm.assert_almost_equal(mgr.get(\"b\").internal_values(), values[1])\n        tm.assert_almost_equal(mgr.get(\"c\").internal_values(), values[2])",
        "begin_line": 351,
        "end_line": 359,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_set#361",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_set(self)",
        "snippet": "    def test_set(self):\n        mgr = create_mgr(\"a,b,c: int\", item_shape=(3,))\n\n        mgr.set(\"d\", np.array([\"foo\"] * 3))\n        mgr.set(\"b\", np.array([\"bar\"] * 3))\n        tm.assert_numpy_array_equal(mgr.get(\"a\").internal_values(), np.array([0] * 3))\n        tm.assert_numpy_array_equal(\n            mgr.get(\"b\").internal_values(), np.array([\"bar\"] * 3, dtype=np.object_)\n        )\n        tm.assert_numpy_array_equal(mgr.get(\"c\").internal_values(), np.array([2] * 3))\n        tm.assert_numpy_array_equal(\n            mgr.get(\"d\").internal_values(), np.array([\"foo\"] * 3, dtype=np.object_)\n        )",
        "begin_line": 361,
        "end_line": 373,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_set_change_dtype#375",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_set_change_dtype(self, mgr)",
        "snippet": "    def test_set_change_dtype(self, mgr):\n        mgr.set(\"baz\", np.zeros(N, dtype=bool))\n\n        mgr.set(\"baz\", np.repeat(\"foo\", N))\n        assert mgr.get(\"baz\").dtype == np.object_\n\n        mgr2 = mgr.consolidate()\n        mgr2.set(\"baz\", np.repeat(\"foo\", N))\n        assert mgr2.get(\"baz\").dtype == np.object_\n\n        mgr2.set(\"quux\", tm.randn(N).astype(int))\n        assert mgr2.get(\"quux\").dtype == np.int_\n\n        mgr2.set(\"quux\", tm.randn(N))\n        assert mgr2.get(\"quux\").dtype == np.float_",
        "begin_line": 375,
        "end_line": 389,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_copy#391",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_copy(self, mgr)",
        "snippet": "    def test_copy(self, mgr):\n        cp = mgr.copy(deep=False)\n        for blk, cp_blk in zip(mgr.blocks, cp.blocks):\n\n            # view assertion\n            assert cp_blk.equals(blk)\n            if isinstance(blk.values, np.ndarray):\n                assert cp_blk.values.base is blk.values.base\n            else:\n                # DatetimeTZBlock has DatetimeIndex values\n                assert cp_blk.values._data.base is blk.values._data.base\n\n        cp = mgr.copy(deep=True)\n        for blk, cp_blk in zip(mgr.blocks, cp.blocks):\n\n            # copy assertion we either have a None for a base or in case of\n            # some blocks it is an array (e.g. datetimetz), but was copied\n            assert cp_blk.equals(blk)\n            if not isinstance(cp_blk.values, np.ndarray):\n                assert cp_blk.values._data.base is not blk.values._data.base\n            else:\n                assert cp_blk.values.base is None and blk.values.base is None",
        "begin_line": 391,
        "end_line": 412,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_sparse#414",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_sparse(self)",
        "snippet": "    def test_sparse(self):\n        mgr = create_mgr(\"a: sparse-1; b: sparse-2\")\n        # what to test here?\n        assert mgr.as_array().dtype == np.float64",
        "begin_line": 414,
        "end_line": 417,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_sparse_mixed#419",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_sparse_mixed(self)",
        "snippet": "    def test_sparse_mixed(self):\n        mgr = create_mgr(\"a: sparse-1; b: sparse-2; c: f8\")\n        assert len(mgr.blocks) == 3\n        assert isinstance(mgr, BlockManager)",
        "begin_line": 419,
        "end_line": 422,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_as_array_float#430",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_as_array_float(self, mgr_string, dtype)",
        "snippet": "    def test_as_array_float(self, mgr_string, dtype):\n        mgr = create_mgr(mgr_string)\n        assert mgr.as_array().dtype == dtype",
        "begin_line": 430,
        "end_line": 432,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_as_array_int_bool#442",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_as_array_int_bool(self, mgr_string, dtype)",
        "snippet": "    def test_as_array_int_bool(self, mgr_string, dtype):\n        mgr = create_mgr(mgr_string)\n        assert mgr.as_array().dtype == dtype",
        "begin_line": 442,
        "end_line": 444,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_as_array_datetime#446",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_as_array_datetime(self)",
        "snippet": "    def test_as_array_datetime(self):\n        mgr = create_mgr(\"h: datetime-1; g: datetime-2\")\n        assert mgr.as_array().dtype == \"M8[ns]\"",
        "begin_line": 446,
        "end_line": 448,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_as_array_datetime_tz#450",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_as_array_datetime_tz(self)",
        "snippet": "    def test_as_array_datetime_tz(self):\n        mgr = create_mgr(\"h: M8[ns, US/Eastern]; g: M8[ns, CET]\")\n        assert mgr.get(\"h\").dtype == \"datetime64[ns, US/Eastern]\"\n        assert mgr.get(\"g\").dtype == \"datetime64[ns, CET]\"\n        assert mgr.as_array().dtype == \"object\"",
        "begin_line": 450,
        "end_line": 454,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_astype#457",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_astype(self, t)",
        "snippet": "    def test_astype(self, t):\n        # coerce all\n        mgr = create_mgr(\"c: f4; d: f2; e: f8\")\n\n        t = np.dtype(t)\n        tmgr = mgr.astype(t)\n        assert tmgr.get(\"c\").dtype.type == t\n        assert tmgr.get(\"d\").dtype.type == t\n        assert tmgr.get(\"e\").dtype.type == t\n\n        # mixed\n        mgr = create_mgr(\"a,b: object; c: bool; d: datetime; e: f4; f: f2; g: f8\")\n\n        t = np.dtype(t)\n        tmgr = mgr.astype(t, errors=\"ignore\")\n        assert tmgr.get(\"c\").dtype.type == t\n        assert tmgr.get(\"e\").dtype.type == t\n        assert tmgr.get(\"f\").dtype.type == t\n        assert tmgr.get(\"g\").dtype.type == t\n\n        assert tmgr.get(\"a\").dtype.type == np.object_\n        assert tmgr.get(\"b\").dtype.type == np.object_\n        if t != np.int64:\n            assert tmgr.get(\"d\").dtype.type == np.datetime64\n        else:\n            assert tmgr.get(\"d\").dtype.type == t",
        "begin_line": 457,
        "end_line": 482,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_convert#484",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_convert(self)",
        "snippet": "    def test_convert(self):\n        def _compare(old_mgr, new_mgr):\n            \"\"\" compare the blocks, numeric compare ==, object don't \"\"\"\n            old_blocks = set(old_mgr.blocks)\n            new_blocks = set(new_mgr.blocks)\n            assert len(old_blocks) == len(new_blocks)\n\n            # compare non-numeric\n            for b in old_blocks:\n                found = False\n                for nb in new_blocks:\n                    if (b.values == nb.values).all():\n                        found = True\n                        break\n                assert found\n\n            for b in new_blocks:\n                found = False\n                for ob in old_blocks:\n                    if (b.values == ob.values).all():\n                        found = True\n                        break\n                assert found\n\n        # noops\n        mgr = create_mgr(\"f: i8; g: f8\")\n        new_mgr = mgr.convert()\n        _compare(mgr, new_mgr)\n\n        # convert\n        mgr = create_mgr(\"a,b,foo: object; f: i8; g: f8\")\n        mgr.set(\"a\", np.array([\"1\"] * N, dtype=np.object_))\n        mgr.set(\"b\", np.array([\"2.\"] * N, dtype=np.object_))\n        mgr.set(\"foo\", np.array([\"foo.\"] * N, dtype=np.object_))\n        new_mgr = mgr.convert(numeric=True)\n        assert new_mgr.get(\"a\").dtype == np.int64\n        assert new_mgr.get(\"b\").dtype == np.float64\n        assert new_mgr.get(\"foo\").dtype == np.object_\n        assert new_mgr.get(\"f\").dtype == np.int64\n        assert new_mgr.get(\"g\").dtype == np.float64\n\n        mgr = create_mgr(\n            \"a,b,foo: object; f: i4; bool: bool; dt: datetime; i: i8; g: f8; h: f2\"\n        )\n        mgr.set(\"a\", np.array([\"1\"] * N, dtype=np.object_))\n        mgr.set(\"b\", np.array([\"2.\"] * N, dtype=np.object_))\n        mgr.set(\"foo\", np.array([\"foo.\"] * N, dtype=np.object_))\n        new_mgr = mgr.convert(numeric=True)\n        assert new_mgr.get(\"a\").dtype == np.int64\n        assert new_mgr.get(\"b\").dtype == np.float64\n        assert new_mgr.get(\"foo\").dtype == np.object_\n        assert new_mgr.get(\"f\").dtype == np.int32\n        assert new_mgr.get(\"bool\").dtype == np.bool_\n        assert new_mgr.get(\"dt\").dtype.type, np.datetime64\n        assert new_mgr.get(\"i\").dtype == np.int64\n        assert new_mgr.get(\"g\").dtype == np.float64\n        assert new_mgr.get(\"h\").dtype == np.float16",
        "begin_line": 484,
        "end_line": 540,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager._compare#485",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager._compare(old_mgr, new_mgr)",
        "snippet": "        def _compare(old_mgr, new_mgr):\n            \"\"\" compare the blocks, numeric compare ==, object don't \"\"\"\n            old_blocks = set(old_mgr.blocks)\n            new_blocks = set(new_mgr.blocks)\n            assert len(old_blocks) == len(new_blocks)\n\n            # compare non-numeric\n            for b in old_blocks:\n                found = False\n                for nb in new_blocks:\n                    if (b.values == nb.values).all():\n                        found = True\n                        break\n                assert found\n\n            for b in new_blocks:\n                found = False\n                for ob in old_blocks:\n                    if (b.values == ob.values).all():\n                        found = True\n                        break\n                assert found",
        "begin_line": 485,
        "end_line": 506,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_invalid_ea_block#542",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_invalid_ea_block(self)",
        "snippet": "    def test_invalid_ea_block(self):\n        with pytest.raises(AssertionError, match=\"block.size != values.size\"):\n            create_mgr(\"a: category; b: category\")\n\n        with pytest.raises(AssertionError, match=\"block.size != values.size\"):\n            create_mgr(\"a: category2; b: category2\")",
        "begin_line": 542,
        "end_line": 547,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_interleave#549",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_interleave(self)",
        "snippet": "    def test_interleave(self):\n        # self\n        for dtype in [\"f8\", \"i8\", \"object\", \"bool\", \"complex\", \"M8[ns]\", \"m8[ns]\"]:\n            mgr = create_mgr(f\"a: {dtype}\")\n            assert mgr.as_array().dtype == dtype\n            mgr = create_mgr(f\"a: {dtype}; b: {dtype}\")\n            assert mgr.as_array().dtype == dtype",
        "begin_line": 549,
        "end_line": 555,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_interleave_dtype#580",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_interleave_dtype(self, mgr_string, dtype)",
        "snippet": "    def test_interleave_dtype(self, mgr_string, dtype):\n        # will be converted according the actual dtype of the underlying\n        mgr = create_mgr(\"a: category\")\n        assert mgr.as_array().dtype == \"i8\"\n        mgr = create_mgr(\"a: category; b: category2\")\n        assert mgr.as_array().dtype == \"object\"\n        mgr = create_mgr(\"a: category2\")\n        assert mgr.as_array().dtype == \"object\"\n\n        # combinations\n        mgr = create_mgr(\"a: f8\")\n        assert mgr.as_array().dtype == \"f8\"\n        mgr = create_mgr(\"a: f8; b: i8\")\n        assert mgr.as_array().dtype == \"f8\"\n        mgr = create_mgr(\"a: f4; b: i8\")\n        assert mgr.as_array().dtype == \"f8\"\n        mgr = create_mgr(\"a: f4; b: i8; d: object\")\n        assert mgr.as_array().dtype == \"object\"\n        mgr = create_mgr(\"a: bool; b: i8\")\n        assert mgr.as_array().dtype == \"object\"\n        mgr = create_mgr(\"a: complex\")\n        assert mgr.as_array().dtype == \"complex\"\n        mgr = create_mgr(\"a: f8; b: category\")\n        assert mgr.as_array().dtype == \"object\"\n        mgr = create_mgr(\"a: M8[ns]; b: category\")\n        assert mgr.as_array().dtype == \"object\"\n        mgr = create_mgr(\"a: M8[ns]; b: bool\")\n        assert mgr.as_array().dtype == \"object\"\n        mgr = create_mgr(\"a: M8[ns]; b: i8\")\n        assert mgr.as_array().dtype == \"object\"\n        mgr = create_mgr(\"a: m8[ns]; b: bool\")\n        assert mgr.as_array().dtype == \"object\"\n        mgr = create_mgr(\"a: m8[ns]; b: i8\")\n        assert mgr.as_array().dtype == \"object\"\n        mgr = create_mgr(\"a: M8[ns]; b: m8[ns]\")\n        assert mgr.as_array().dtype == \"object\"",
        "begin_line": 580,
        "end_line": 615,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_consolidate_ordering_issues#617",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_consolidate_ordering_issues(self, mgr)",
        "snippet": "    def test_consolidate_ordering_issues(self, mgr):\n        mgr.set(\"f\", tm.randn(N))\n        mgr.set(\"d\", tm.randn(N))\n        mgr.set(\"b\", tm.randn(N))\n        mgr.set(\"g\", tm.randn(N))\n        mgr.set(\"h\", tm.randn(N))\n\n        # we have datetime/tz blocks in mgr\n        cons = mgr.consolidate()\n        assert cons.nblocks == 4\n        cons = mgr.consolidate().get_numeric_data()\n        assert cons.nblocks == 1\n        assert isinstance(cons.blocks[0].mgr_locs, BlockPlacement)\n        tm.assert_numpy_array_equal(\n            cons.blocks[0].mgr_locs.as_array, np.arange(len(cons.items), dtype=np.int64)\n        )",
        "begin_line": 617,
        "end_line": 632,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_reindex_items#634",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_reindex_items(self)",
        "snippet": "    def test_reindex_items(self):\n        # mgr is not consolidated, f8 & f8-2 blocks\n        mgr = create_mgr(\"a: f8; b: i8; c: f8; d: i8; e: f8; f: bool; g: f8-2\")\n\n        reindexed = mgr.reindex_axis([\"g\", \"c\", \"a\", \"d\"], axis=0)\n        assert reindexed.nblocks == 2\n        tm.assert_index_equal(reindexed.items, pd.Index([\"g\", \"c\", \"a\", \"d\"]))\n        tm.assert_almost_equal(\n            mgr.get(\"g\").internal_values(), reindexed.get(\"g\").internal_values()\n        )\n        tm.assert_almost_equal(\n            mgr.get(\"c\").internal_values(), reindexed.get(\"c\").internal_values()\n        )\n        tm.assert_almost_equal(\n            mgr.get(\"a\").internal_values(), reindexed.get(\"a\").internal_values()\n        )\n        tm.assert_almost_equal(\n            mgr.get(\"d\").internal_values(), reindexed.get(\"d\").internal_values()\n        )",
        "begin_line": 634,
        "end_line": 652,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_get_numeric_data#654",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_get_numeric_data(self)",
        "snippet": "    def test_get_numeric_data(self):\n        mgr = create_mgr(\n            \"int: int; float: float; complex: complex;\"\n            \"str: object; bool: bool; obj: object; dt: datetime\",\n            item_shape=(3,),\n        )\n        mgr.set(\"obj\", np.array([1, 2, 3], dtype=np.object_))\n\n        numeric = mgr.get_numeric_data()\n        tm.assert_index_equal(\n            numeric.items, pd.Index([\"int\", \"float\", \"complex\", \"bool\"])\n        )\n        tm.assert_almost_equal(\n            mgr.get(\"float\").internal_values(), numeric.get(\"float\").internal_values()\n        )\n\n        # Check sharing\n        numeric.set(\"float\", np.array([100.0, 200.0, 300.0]))\n        tm.assert_almost_equal(\n            mgr.get(\"float\").internal_values(), np.array([100.0, 200.0, 300.0])\n        )\n\n        numeric2 = mgr.get_numeric_data(copy=True)\n        tm.assert_index_equal(\n            numeric.items, pd.Index([\"int\", \"float\", \"complex\", \"bool\"])\n        )\n        numeric2.set(\"float\", np.array([1000.0, 2000.0, 3000.0]))\n        tm.assert_almost_equal(\n            mgr.get(\"float\").internal_values(), np.array([100.0, 200.0, 300.0])\n        )",
        "begin_line": 654,
        "end_line": 683,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_get_bool_data#685",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_get_bool_data(self)",
        "snippet": "    def test_get_bool_data(self):\n        mgr = create_mgr(\n            \"int: int; float: float; complex: complex;\"\n            \"str: object; bool: bool; obj: object; dt: datetime\",\n            item_shape=(3,),\n        )\n        mgr.set(\"obj\", np.array([True, False, True], dtype=np.object_))\n\n        bools = mgr.get_bool_data()\n        tm.assert_index_equal(bools.items, pd.Index([\"bool\"]))\n        tm.assert_almost_equal(\n            mgr.get(\"bool\").internal_values(), bools.get(\"bool\").internal_values()\n        )\n\n        bools.set(\"bool\", np.array([True, False, True]))\n        tm.assert_numpy_array_equal(\n            mgr.get(\"bool\").internal_values(), np.array([True, False, True])\n        )\n\n        # Check sharing\n        bools2 = mgr.get_bool_data(copy=True)\n        bools2.set(\"bool\", np.array([False, True, False]))\n        tm.assert_numpy_array_equal(\n            mgr.get(\"bool\").internal_values(), np.array([True, False, True])\n        )",
        "begin_line": 685,
        "end_line": 709,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_unicode_repr_doesnt_raise#711",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_unicode_repr_doesnt_raise(self)",
        "snippet": "    def test_unicode_repr_doesnt_raise(self):\n        repr(create_mgr(\"b,\\u05d0: object\"))",
        "begin_line": 711,
        "end_line": 712,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_equals#717",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_equals(self, mgr_string)",
        "snippet": "    def test_equals(self, mgr_string):\n        # unique items\n        bm1 = create_mgr(mgr_string)\n        bm2 = BlockManager(bm1.blocks[::-1], bm1.axes)\n        assert bm1.equals(bm2)",
        "begin_line": 717,
        "end_line": 721,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_equals_block_order_different_dtypes#733",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_equals_block_order_different_dtypes(self, mgr_string)",
        "snippet": "    def test_equals_block_order_different_dtypes(self, mgr_string):\n        # GH 9330\n        bm = create_mgr(mgr_string)\n        block_perms = itertools.permutations(bm.blocks)\n        for bm_perm in block_perms:\n            bm_this = BlockManager(bm_perm, bm.axes)\n            assert bm.equals(bm_this)\n            assert bm_this.equals(bm)",
        "begin_line": 733,
        "end_line": 740,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_single_mgr_ctor#742",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_single_mgr_ctor(self)",
        "snippet": "    def test_single_mgr_ctor(self):\n        mgr = create_single_mgr(\"f8\", num_rows=5)\n        assert mgr.as_array().tolist() == [0.0, 1.0, 2.0, 3.0, 4.0]",
        "begin_line": 742,
        "end_line": 744,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockManager.test_validate_bool_args#747",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockManager",
        "signature": "pandas.tests.internals.test_internals.TestBlockManager.test_validate_bool_args(self, value)",
        "snippet": "    def test_validate_bool_args(self, value):\n        bm1 = create_mgr(\"a,b,c: i8-1; d,e,f: i8-2\")\n\n        msg = (\n            'For argument \"inplace\" expected type bool, '\n            f\"received type {type(value).__name__}.\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            bm1.replace_list([1], [2], inplace=value)",
        "begin_line": 747,
        "end_line": 755,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestIndexing.test_get_slice#778",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestIndexing",
        "signature": "pandas.tests.internals.test_internals.TestIndexing.test_get_slice(self, mgr)",
        "snippet": "    def test_get_slice(self, mgr):\n        def assert_slice_ok(mgr, axis, slobj):\n            mat = mgr.as_array()\n\n            # we maybe using an ndarray to test slicing and\n            # might not be the full length of the axis\n            if isinstance(slobj, np.ndarray):\n                ax = mgr.axes[axis]\n                if len(ax) and len(slobj) and len(slobj) != len(ax):\n                    slobj = np.concatenate(\n                        [slobj, np.zeros(len(ax) - len(slobj), dtype=bool)]\n                    )\n            sliced = mgr.get_slice(slobj, axis=axis)\n            mat_slobj = (slice(None),) * axis + (slobj,)\n            tm.assert_numpy_array_equal(\n                mat[mat_slobj], sliced.as_array(), check_dtype=False\n            )\n            tm.assert_index_equal(mgr.axes[axis][slobj], sliced.axes[axis])\n\n        assert mgr.ndim <= 2, mgr.ndim\n        for ax in range(mgr.ndim):\n            # slice\n            assert_slice_ok(mgr, ax, slice(None))\n            assert_slice_ok(mgr, ax, slice(3))\n            assert_slice_ok(mgr, ax, slice(100))\n            assert_slice_ok(mgr, ax, slice(1, 4))\n            assert_slice_ok(mgr, ax, slice(3, 0, -2))\n\n            # boolean mask\n            assert_slice_ok(mgr, ax, np.array([], dtype=np.bool_))\n            assert_slice_ok(mgr, ax, np.ones(mgr.shape[ax], dtype=np.bool_))\n            assert_slice_ok(mgr, ax, np.zeros(mgr.shape[ax], dtype=np.bool_))\n\n            if mgr.shape[ax] >= 3:\n                assert_slice_ok(mgr, ax, np.arange(mgr.shape[ax]) % 3 == 0)\n                assert_slice_ok(mgr, ax, np.array([True, True, False], dtype=np.bool_))\n\n            # fancy indexer\n            assert_slice_ok(mgr, ax, [])\n            assert_slice_ok(mgr, ax, list(range(mgr.shape[ax])))\n\n            if mgr.shape[ax] >= 3:\n                assert_slice_ok(mgr, ax, [0, 1, 2])\n                assert_slice_ok(mgr, ax, [-1, -2, -3])",
        "begin_line": 778,
        "end_line": 821,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestIndexing.assert_slice_ok#779",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestIndexing",
        "signature": "pandas.tests.internals.test_internals.TestIndexing.assert_slice_ok(mgr, axis, slobj)",
        "snippet": "        def assert_slice_ok(mgr, axis, slobj):\n            mat = mgr.as_array()\n\n            # we maybe using an ndarray to test slicing and\n            # might not be the full length of the axis\n            if isinstance(slobj, np.ndarray):\n                ax = mgr.axes[axis]\n                if len(ax) and len(slobj) and len(slobj) != len(ax):\n                    slobj = np.concatenate(\n                        [slobj, np.zeros(len(ax) - len(slobj), dtype=bool)]\n                    )\n            sliced = mgr.get_slice(slobj, axis=axis)\n            mat_slobj = (slice(None),) * axis + (slobj,)\n            tm.assert_numpy_array_equal(\n                mat[mat_slobj], sliced.as_array(), check_dtype=False\n            )\n            tm.assert_index_equal(mgr.axes[axis][slobj], sliced.axes[axis])",
        "begin_line": 779,
        "end_line": 795,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestIndexing.test_take#824",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestIndexing",
        "signature": "pandas.tests.internals.test_internals.TestIndexing.test_take(self, mgr)",
        "snippet": "    def test_take(self, mgr):\n        def assert_take_ok(mgr, axis, indexer):\n            mat = mgr.as_array()\n            taken = mgr.take(indexer, axis)\n            tm.assert_numpy_array_equal(\n                np.take(mat, indexer, axis), taken.as_array(), check_dtype=False\n            )\n            tm.assert_index_equal(mgr.axes[axis].take(indexer), taken.axes[axis])\n\n        for ax in range(mgr.ndim):\n            # take/fancy indexer\n            assert_take_ok(mgr, ax, indexer=[])\n            assert_take_ok(mgr, ax, indexer=[0, 0, 0])\n            assert_take_ok(mgr, ax, indexer=list(range(mgr.shape[ax])))\n\n            if mgr.shape[ax] >= 3:\n                assert_take_ok(mgr, ax, indexer=[0, 1, 2])\n                assert_take_ok(mgr, ax, indexer=[-1, -2, -3])",
        "begin_line": 824,
        "end_line": 841,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestIndexing.assert_take_ok#825",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestIndexing",
        "signature": "pandas.tests.internals.test_internals.TestIndexing.assert_take_ok(mgr, axis, indexer)",
        "snippet": "        def assert_take_ok(mgr, axis, indexer):\n            mat = mgr.as_array()\n            taken = mgr.take(indexer, axis)\n            tm.assert_numpy_array_equal(\n                np.take(mat, indexer, axis), taken.as_array(), check_dtype=False\n            )\n            tm.assert_index_equal(mgr.axes[axis].take(indexer), taken.axes[axis])",
        "begin_line": 825,
        "end_line": 831,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestIndexing.test_reindex_axis#845",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestIndexing",
        "signature": "pandas.tests.internals.test_internals.TestIndexing.test_reindex_axis(self, fill_value, mgr)",
        "snippet": "    def test_reindex_axis(self, fill_value, mgr):\n        def assert_reindex_axis_is_ok(mgr, axis, new_labels, fill_value):\n            mat = mgr.as_array()\n            indexer = mgr.axes[axis].get_indexer_for(new_labels)\n\n            reindexed = mgr.reindex_axis(new_labels, axis, fill_value=fill_value)\n            tm.assert_numpy_array_equal(\n                algos.take_nd(mat, indexer, axis, fill_value=fill_value),\n                reindexed.as_array(),\n                check_dtype=False,\n            )\n            tm.assert_index_equal(reindexed.axes[axis], new_labels)\n\n        for ax in range(mgr.ndim):\n            assert_reindex_axis_is_ok(mgr, ax, pd.Index([]), fill_value)\n            assert_reindex_axis_is_ok(mgr, ax, mgr.axes[ax], fill_value)\n            assert_reindex_axis_is_ok(mgr, ax, mgr.axes[ax][[0, 0, 0]], fill_value)\n            assert_reindex_axis_is_ok(\n                mgr, ax, pd.Index([\"foo\", \"bar\", \"baz\"]), fill_value\n            )\n            assert_reindex_axis_is_ok(\n                mgr, ax, pd.Index([\"foo\", mgr.axes[ax][0], \"baz\"]), fill_value\n            )\n\n            if mgr.shape[ax] >= 3:\n                assert_reindex_axis_is_ok(mgr, ax, mgr.axes[ax][:-3], fill_value)\n                assert_reindex_axis_is_ok(mgr, ax, mgr.axes[ax][-3::-1], fill_value)\n                assert_reindex_axis_is_ok(\n                    mgr, ax, mgr.axes[ax][[0, 1, 2, 0, 1, 2]], fill_value\n                )",
        "begin_line": 845,
        "end_line": 874,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestIndexing.assert_reindex_axis_is_ok#846",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestIndexing",
        "signature": "pandas.tests.internals.test_internals.TestIndexing.assert_reindex_axis_is_ok(mgr, axis, new_labels, fill_value)",
        "snippet": "        def assert_reindex_axis_is_ok(mgr, axis, new_labels, fill_value):\n            mat = mgr.as_array()\n            indexer = mgr.axes[axis].get_indexer_for(new_labels)\n\n            reindexed = mgr.reindex_axis(new_labels, axis, fill_value=fill_value)\n            tm.assert_numpy_array_equal(\n                algos.take_nd(mat, indexer, axis, fill_value=fill_value),\n                reindexed.as_array(),\n                check_dtype=False,\n            )\n            tm.assert_index_equal(reindexed.axes[axis], new_labels)",
        "begin_line": 846,
        "end_line": 856,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestIndexing.test_reindex_indexer#878",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestIndexing",
        "signature": "pandas.tests.internals.test_internals.TestIndexing.test_reindex_indexer(self, fill_value, mgr)",
        "snippet": "    def test_reindex_indexer(self, fill_value, mgr):\n        def assert_reindex_indexer_is_ok(mgr, axis, new_labels, indexer, fill_value):\n            mat = mgr.as_array()\n            reindexed_mat = algos.take_nd(mat, indexer, axis, fill_value=fill_value)\n            reindexed = mgr.reindex_indexer(\n                new_labels, indexer, axis, fill_value=fill_value\n            )\n            tm.assert_numpy_array_equal(\n                reindexed_mat, reindexed.as_array(), check_dtype=False\n            )\n            tm.assert_index_equal(reindexed.axes[axis], new_labels)\n\n        for ax in range(mgr.ndim):\n            assert_reindex_indexer_is_ok(mgr, ax, pd.Index([]), [], fill_value)\n            assert_reindex_indexer_is_ok(\n                mgr, ax, mgr.axes[ax], np.arange(mgr.shape[ax]), fill_value\n            )\n            assert_reindex_indexer_is_ok(\n                mgr,\n                ax,\n                pd.Index([\"foo\"] * mgr.shape[ax]),\n                np.arange(mgr.shape[ax]),\n                fill_value,\n            )\n            assert_reindex_indexer_is_ok(\n                mgr, ax, mgr.axes[ax][::-1], np.arange(mgr.shape[ax]), fill_value,\n            )\n            assert_reindex_indexer_is_ok(\n                mgr, ax, mgr.axes[ax], np.arange(mgr.shape[ax])[::-1], fill_value,\n            )\n            assert_reindex_indexer_is_ok(\n                mgr, ax, pd.Index([\"foo\", \"bar\", \"baz\"]), [0, 0, 0], fill_value\n            )\n            assert_reindex_indexer_is_ok(\n                mgr, ax, pd.Index([\"foo\", \"bar\", \"baz\"]), [-1, 0, -1], fill_value,\n            )\n            assert_reindex_indexer_is_ok(\n                mgr,\n                ax,\n                pd.Index([\"foo\", mgr.axes[ax][0], \"baz\"]),\n                [-1, -1, -1],\n                fill_value,\n            )\n\n            if mgr.shape[ax] >= 3:\n                assert_reindex_indexer_is_ok(\n                    mgr, ax, pd.Index([\"foo\", \"bar\", \"baz\"]), [0, 1, 2], fill_value,\n                )",
        "begin_line": 878,
        "end_line": 925,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestIndexing.assert_reindex_indexer_is_ok#879",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestIndexing",
        "signature": "pandas.tests.internals.test_internals.TestIndexing.assert_reindex_indexer_is_ok(mgr, axis, new_labels, indexer, fill_value)",
        "snippet": "        def assert_reindex_indexer_is_ok(mgr, axis, new_labels, indexer, fill_value):\n            mat = mgr.as_array()\n            reindexed_mat = algos.take_nd(mat, indexer, axis, fill_value=fill_value)\n            reindexed = mgr.reindex_indexer(\n                new_labels, indexer, axis, fill_value=fill_value\n            )\n            tm.assert_numpy_array_equal(\n                reindexed_mat, reindexed.as_array(), check_dtype=False\n            )\n            tm.assert_index_equal(reindexed.axes[axis], new_labels)",
        "begin_line": 879,
        "end_line": 888,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockPlacement.test_slice_len#939",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockPlacement",
        "signature": "pandas.tests.internals.test_internals.TestBlockPlacement.test_slice_len(self, slc, expected)",
        "snippet": "    def test_slice_len(self, slc, expected):\n        assert len(BlockPlacement(slc)) == expected",
        "begin_line": 939,
        "end_line": 940,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockPlacement.test_zero_step_raises#943",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockPlacement",
        "signature": "pandas.tests.internals.test_internals.TestBlockPlacement.test_zero_step_raises(self, slc)",
        "snippet": "    def test_zero_step_raises(self, slc):\n        msg = \"slice step cannot be zero\"\n        with pytest.raises(ValueError, match=msg):\n            BlockPlacement(slc)",
        "begin_line": 943,
        "end_line": 946,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockPlacement.test_unbounded_slice_raises#965",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockPlacement",
        "signature": "pandas.tests.internals.test_internals.TestBlockPlacement.test_unbounded_slice_raises(self, slc)",
        "snippet": "    def test_unbounded_slice_raises(self, slc):\n        msg = \"unbounded slice\"\n        with pytest.raises(ValueError, match=msg):\n            BlockPlacement(slc)",
        "begin_line": 965,
        "end_line": 968,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockPlacement.test_not_slice_like_slices#980",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockPlacement",
        "signature": "pandas.tests.internals.test_internals.TestBlockPlacement.test_not_slice_like_slices(self, slc)",
        "snippet": "    def test_not_slice_like_slices(self, slc):\n        assert not BlockPlacement(slc).is_slice_like",
        "begin_line": 980,
        "end_line": 981,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockPlacement.test_array_to_slice_conversion#994",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockPlacement",
        "signature": "pandas.tests.internals.test_internals.TestBlockPlacement.test_array_to_slice_conversion(self, arr, slc)",
        "snippet": "    def test_array_to_slice_conversion(self, arr, slc):\n        assert BlockPlacement(arr).as_slice == slc",
        "begin_line": 994,
        "end_line": 995,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockPlacement.test_not_slice_like_arrays#1011",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockPlacement",
        "signature": "pandas.tests.internals.test_internals.TestBlockPlacement.test_not_slice_like_arrays(self, arr)",
        "snippet": "    def test_not_slice_like_arrays(self, arr):\n        assert not BlockPlacement(arr).is_slice_like",
        "begin_line": 1011,
        "end_line": 1012,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockPlacement.test_slice_iter#1018",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockPlacement",
        "signature": "pandas.tests.internals.test_internals.TestBlockPlacement.test_slice_iter(self, slc, expected)",
        "snippet": "    def test_slice_iter(self, slc, expected):\n        assert list(BlockPlacement(slc)) == expected",
        "begin_line": 1018,
        "end_line": 1019,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockPlacement.test_slice_to_array_conversion#1030",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockPlacement",
        "signature": "pandas.tests.internals.test_internals.TestBlockPlacement.test_slice_to_array_conversion(self, slc, arr)",
        "snippet": "    def test_slice_to_array_conversion(self, slc, arr):\n        tm.assert_numpy_array_equal(\n            BlockPlacement(slc).as_array, np.asarray(arr, dtype=np.int64)\n        )",
        "begin_line": 1030,
        "end_line": 1033,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockPlacement.test_blockplacement_add#1035",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockPlacement",
        "signature": "pandas.tests.internals.test_internals.TestBlockPlacement.test_blockplacement_add(self)",
        "snippet": "    def test_blockplacement_add(self):\n        bpl = BlockPlacement(slice(0, 5))\n        assert bpl.add(1).as_slice == slice(1, 6, 1)\n        assert bpl.add(np.arange(5)).as_slice == slice(0, 10, 2)\n        assert list(bpl.add(np.arange(5, 0, -1))) == [5, 5, 5, 5, 5]",
        "begin_line": 1035,
        "end_line": 1039,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockPlacement.test_blockplacement_add_int#1057",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockPlacement",
        "signature": "pandas.tests.internals.test_internals.TestBlockPlacement.test_blockplacement_add_int(self, val, inc, expected)",
        "snippet": "    def test_blockplacement_add_int(self, val, inc, expected):\n        assert list(BlockPlacement(val).add(inc)) == expected",
        "begin_line": 1057,
        "end_line": 1058,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestBlockPlacement.test_blockplacement_add_int_raises#1061",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestBlockPlacement",
        "signature": "pandas.tests.internals.test_internals.TestBlockPlacement.test_blockplacement_add_int_raises(self, val)",
        "snippet": "    def test_blockplacement_add_int_raises(self, val):\n        msg = \"iadd causes length change\"\n        with pytest.raises(ValueError, match=msg):\n            BlockPlacement(val).add(-10)",
        "begin_line": 1061,
        "end_line": 1064,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.DummyElement.__init__#1068",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.DummyElement",
        "signature": "pandas.tests.internals.test_internals.DummyElement.__init__(self, value, dtype)",
        "snippet": "    def __init__(self, value, dtype):\n        self.value = value\n        self.dtype = np.dtype(dtype)",
        "begin_line": 1068,
        "end_line": 1070,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.DummyElement.__array__#1072",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.DummyElement",
        "signature": "pandas.tests.internals.test_internals.DummyElement.__array__(self)",
        "snippet": "    def __array__(self):\n        return np.array(self.value, dtype=self.dtype)",
        "begin_line": 1072,
        "end_line": 1073,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.DummyElement.__str__#1075",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.DummyElement",
        "signature": "pandas.tests.internals.test_internals.DummyElement.__str__(self)",
        "snippet": "    def __str__(self) -> str:\n        return f\"DummyElement({self.value}, {self.dtype})\"",
        "begin_line": 1075,
        "end_line": 1076,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.DummyElement.__repr__#1078",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.DummyElement",
        "signature": "pandas.tests.internals.test_internals.DummyElement.__repr__(self)",
        "snippet": "    def __repr__(self) -> str:\n        return str(self)",
        "begin_line": 1078,
        "end_line": 1079,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.DummyElement.astype#1081",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.DummyElement",
        "signature": "pandas.tests.internals.test_internals.DummyElement.astype(self, dtype, copy=False)",
        "snippet": "    def astype(self, dtype, copy=False):\n        self.dtype = dtype\n        return self",
        "begin_line": 1081,
        "end_line": 1083,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.DummyElement.view#1085",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.DummyElement",
        "signature": "pandas.tests.internals.test_internals.DummyElement.view(self, dtype)",
        "snippet": "    def view(self, dtype):\n        return type(self)(self.value.view(dtype), dtype)",
        "begin_line": 1085,
        "end_line": 1086,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.DummyElement.any#1088",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.DummyElement",
        "signature": "pandas.tests.internals.test_internals.DummyElement.any(self, axis=None)",
        "snippet": "    def any(self, axis=None):\n        return bool(self.value)",
        "begin_line": 1088,
        "end_line": 1089,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestCanHoldElement.test_datetime_block_can_hold_element#1093",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestCanHoldElement",
        "signature": "pandas.tests.internals.test_internals.TestCanHoldElement.test_datetime_block_can_hold_element(self)",
        "snippet": "    def test_datetime_block_can_hold_element(self):\n        block = create_block(\"datetime\", [0])\n\n        # We will check that block._can_hold_element iff arr.__setitem__ works\n        arr = pd.array(block.values.ravel())\n\n        # coerce None\n        assert block._can_hold_element(None)\n        arr[0] = None\n        assert arr[0] is pd.NaT\n\n        # coerce different types of datetime objects\n        vals = [np.datetime64(\"2010-10-10\"), datetime(2010, 10, 10)]\n        for val in vals:\n            assert block._can_hold_element(val)\n            arr[0] = val\n\n        val = date(2010, 10, 10)\n        assert not block._can_hold_element(val)\n\n        msg = (\n            \"'value' should be a 'Timestamp', 'NaT', \"\n            \"or array of those. Got 'date' instead.\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            arr[0] = val",
        "begin_line": 1093,
        "end_line": 1118,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestCanHoldElement.test_binop_other#1145",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestCanHoldElement",
        "signature": "pandas.tests.internals.test_internals.TestCanHoldElement.test_binop_other(self, op, value, dtype)",
        "snippet": "    def test_binop_other(self, op, value, dtype):\n        skip = {\n            (operator.add, \"bool\"),\n            (operator.sub, \"bool\"),\n            (operator.mul, \"bool\"),\n            (operator.truediv, \"bool\"),\n            (operator.mod, \"i8\"),\n            (operator.mod, \"complex128\"),\n            (operator.pow, \"bool\"),\n        }\n        if (op, dtype) in skip:\n            pytest.skip(f\"Invalid combination {op},{dtype}\")\n\n        e = DummyElement(value, dtype)\n        s = pd.DataFrame({\"A\": [e.value, e.value]}, dtype=e.dtype)\n\n        invalid = {\n            (operator.pow, \"<M8[ns]\"),\n            (operator.mod, \"<M8[ns]\"),\n            (operator.truediv, \"<M8[ns]\"),\n            (operator.mul, \"<M8[ns]\"),\n            (operator.add, \"<M8[ns]\"),\n            (operator.pow, \"<m8[ns]\"),\n            (operator.mul, \"<m8[ns]\"),\n        }\n\n        if (op, dtype) in invalid:\n            msg = (\n                None\n                if (dtype == \"<M8[ns]\" and op == operator.add)\n                or (dtype == \"<m8[ns]\" and op == operator.mul)\n                else (\n                    f\"cannot perform __{op.__name__}__ with this \"\n                    \"index type: (DatetimeArray|TimedeltaArray)\"\n                )\n            )\n\n            with pytest.raises(TypeError, match=msg):\n                op(s, e.value)\n        else:\n            # FIXME: Since dispatching to Series, this test no longer\n            # asserts anything meaningful\n            result = op(s, e.value).dtypes\n            expected = op(s, value).dtypes\n            tm.assert_series_equal(result, expected)",
        "begin_line": 1145,
        "end_line": 1189,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.TestShouldStore.test_should_store_categorical#1193",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals.TestShouldStore",
        "signature": "pandas.tests.internals.test_internals.TestShouldStore.test_should_store_categorical(self)",
        "snippet": "    def test_should_store_categorical(self):\n        cat = pd.Categorical([\"A\", \"B\", \"C\"])\n        df = pd.DataFrame(cat)\n        blk = df._data.blocks[0]\n\n        # matching dtype\n        assert blk.should_store(cat)\n        assert blk.should_store(cat[:-1])\n\n        # different dtype\n        assert not blk.should_store(cat.as_ordered())\n\n        # ndarray instead of Categorical\n        assert not blk.should_store(np.asarray(cat))",
        "begin_line": 1193,
        "end_line": 1206,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.test_holder#1219",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals",
        "signature": "pandas.tests.internals.test_internals.test_holder(typestr, holder)",
        "snippet": "def test_holder(typestr, holder):\n    blk = create_block(typestr, [1])\n    assert blk._holder is holder",
        "begin_line": 1219,
        "end_line": 1221,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.test_validate_ndim#1224",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals",
        "signature": "pandas.tests.internals.test_internals.test_validate_ndim()",
        "snippet": "def test_validate_ndim():\n    values = np.array([1.0, 2.0])\n    placement = slice(2)\n    msg = r\"Wrong number of dimensions. values.ndim != ndim \\[1 != 2\\]\"\n\n    with pytest.raises(ValueError, match=msg):\n        make_block(values, placement, ndim=2)",
        "begin_line": 1224,
        "end_line": 1230,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.test_block_shape#1233",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals",
        "signature": "pandas.tests.internals.test_internals.test_block_shape()",
        "snippet": "def test_block_shape():\n    idx = pd.Index([0, 1, 2, 3, 4])\n    a = pd.Series([1, 2, 3]).reindex(idx)\n    b = pd.Series(pd.Categorical([1, 2, 3])).reindex(idx)\n\n    assert a._data.blocks[0].mgr_locs.indexer == b._data.blocks[0].mgr_locs.indexer",
        "begin_line": 1233,
        "end_line": 1238,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.test_make_block_no_pandas_array#1241",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals",
        "signature": "pandas.tests.internals.test_internals.test_make_block_no_pandas_array()",
        "snippet": "def test_make_block_no_pandas_array():\n    # https://github.com/pandas-dev/pandas/pull/24866\n    arr = pd.arrays.PandasArray(np.array([1, 2]))\n\n    # PandasArray, no dtype\n    result = make_block(arr, slice(len(arr)))\n    assert result.is_integer is True\n    assert result.is_extension is False\n\n    # PandasArray, PandasDtype\n    result = make_block(arr, slice(len(arr)), dtype=arr.dtype)\n    assert result.is_integer is True\n    assert result.is_extension is False\n\n    # ndarray, PandasDtype\n    result = make_block(arr.to_numpy(), slice(len(arr)), dtype=arr.dtype)\n    assert result.is_integer is True\n    assert result.is_extension is False",
        "begin_line": 1241,
        "end_line": 1258,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.test_dataframe_not_equal#1261",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals",
        "signature": "pandas.tests.internals.test_internals.test_dataframe_not_equal()",
        "snippet": "def test_dataframe_not_equal():\n    # see GH28839\n    df1 = pd.DataFrame({\"a\": [1, 2], \"b\": [\"s\", \"d\"]})\n    df2 = pd.DataFrame({\"a\": [\"s\", \"d\"], \"b\": [1, 2]})\n    assert df1.equals(df2) is False",
        "begin_line": 1261,
        "end_line": 1265,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.test_missing_unicode_key#1268",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals",
        "signature": "pandas.tests.internals.test_internals.test_missing_unicode_key()",
        "snippet": "def test_missing_unicode_key():\n    df = DataFrame({\"a\": [1]})\n    with pytest.raises(KeyError, match=\"\\u05d0\"):\n        df.loc[:, \"\\u05d0\"]  # should not raise UnicodeEncodeError",
        "begin_line": 1268,
        "end_line": 1271,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.test_set_change_dtype_slice#1274",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals",
        "signature": "pandas.tests.internals.test_internals.test_set_change_dtype_slice()",
        "snippet": "def test_set_change_dtype_slice():\n    # GH#8850\n    cols = MultiIndex.from_tuples([(\"1st\", \"a\"), (\"2nd\", \"b\"), (\"3rd\", \"c\")])\n    df = DataFrame([[1.0, 2, 3], [4.0, 5, 6]], columns=cols)\n    df[\"2nd\"] = df[\"2nd\"] * 2.0\n\n    blocks = df._to_dict_of_blocks()\n    assert sorted(blocks.keys()) == [\"float64\", \"int64\"]\n    tm.assert_frame_equal(\n        blocks[\"float64\"], DataFrame([[1.0, 4.0], [4.0, 10.0]], columns=cols[:2])\n    )\n    tm.assert_frame_equal(blocks[\"int64\"], DataFrame([[3], [6]], columns=cols[2:]))",
        "begin_line": 1274,
        "end_line": 1285,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.internals.test_internals.test_interleave_non_unique_cols#1288",
        "src_path": "pandas/tests/internals/test_internals.py",
        "class_name": "pandas.tests.internals.test_internals",
        "signature": "pandas.tests.internals.test_internals.test_interleave_non_unique_cols()",
        "snippet": "def test_interleave_non_unique_cols():\n    df = DataFrame(\n        [[pd.Timestamp(\"20130101\"), 3.5], [pd.Timestamp(\"20130102\"), 4.5]],\n        columns=[\"x\", \"x\"],\n        index=[1, 2],\n    )\n\n    df_unique = df.copy()\n    df_unique.columns = [\"x\", \"y\"]\n    assert df_unique.values.shape == df.values.shape\n    tm.assert_numpy_array_equal(df_unique.values[0], df.values[0])\n    tm.assert_numpy_array_equal(df_unique.values[1], df.values[1])",
        "begin_line": 1288,
        "end_line": 1299,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc.test_iloc_getitem_int#18",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc.test_iloc_getitem_int(self)",
        "snippet": "    def test_iloc_getitem_int(self):\n        # integer\n        self.check_result(\n            \"iloc\",\n            2,\n            typs=[\"labels\", \"mixed\", \"ts\", \"floats\", \"empty\"],\n            fails=IndexError,\n        )",
        "begin_line": 18,
        "end_line": 25,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc.test_iloc_getitem_neg_int#27",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc.test_iloc_getitem_neg_int(self)",
        "snippet": "    def test_iloc_getitem_neg_int(self):\n        # neg integer\n        self.check_result(\n            \"iloc\",\n            -1,\n            typs=[\"labels\", \"mixed\", \"ts\", \"floats\", \"empty\"],\n            fails=IndexError,\n        )",
        "begin_line": 27,
        "end_line": 34,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc.test_iloc_getitem_list_int#36",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc.test_iloc_getitem_list_int(self)",
        "snippet": "    def test_iloc_getitem_list_int(self):\n        self.check_result(\n            \"iloc\",\n            [0, 1, 2],\n            typs=[\"labels\", \"mixed\", \"ts\", \"floats\", \"empty\"],\n            fails=IndexError,\n        )",
        "begin_line": 36,
        "end_line": 42,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_is_scalar_access#51",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_is_scalar_access(self)",
        "snippet": "    def test_is_scalar_access(self):\n        # GH#32085 index with duplicates doesnt matter for _is_scalar_access\n        index = pd.Index([1, 2, 1])\n        ser = pd.Series(range(3), index=index)\n\n        assert ser.iloc._is_scalar_access((1,))\n\n        df = ser.to_frame()\n        assert df.iloc._is_scalar_access((1, 0,))",
        "begin_line": 51,
        "end_line": 59,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_exceeds_bounds#61",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_exceeds_bounds(self)",
        "snippet": "    def test_iloc_exceeds_bounds(self):\n\n        # GH6296\n        # iloc should allow indexers that exceed the bounds\n        df = DataFrame(np.random.random_sample((20, 5)), columns=list(\"ABCDE\"))\n\n        # lists of positions should raise IndexError!\n        msg = \"positional indexers are out-of-bounds\"\n        with pytest.raises(IndexError, match=msg):\n            df.iloc[:, [0, 1, 2, 3, 4, 5]]\n        with pytest.raises(IndexError, match=msg):\n            df.iloc[[1, 30]]\n        with pytest.raises(IndexError, match=msg):\n            df.iloc[[1, -30]]\n        with pytest.raises(IndexError, match=msg):\n            df.iloc[[100]]\n\n        s = df[\"A\"]\n        with pytest.raises(IndexError, match=msg):\n            s.iloc[[100]]\n        with pytest.raises(IndexError, match=msg):\n            s.iloc[[-100]]\n\n        # still raise on a single indexer\n        msg = \"single positional indexer is out-of-bounds\"\n        with pytest.raises(IndexError, match=msg):\n            df.iloc[30]\n        with pytest.raises(IndexError, match=msg):\n            df.iloc[-30]\n\n        # GH10779\n        # single positive/negative indexer exceeding Series bounds should raise\n        # an IndexError\n        with pytest.raises(IndexError, match=msg):\n            s.iloc[30]\n        with pytest.raises(IndexError, match=msg):\n            s.iloc[-30]\n\n        # slices are ok\n        result = df.iloc[:, 4:10]  # 0 < start < len < stop\n        expected = df.iloc[:, 4:]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[:, -4:-10]  # stop < 0 < start < len\n        expected = df.iloc[:, :0]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[:, 10:4:-1]  # 0 < stop < len < start (down)\n        expected = df.iloc[:, :4:-1]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[:, 4:-10:-1]  # stop < 0 < start < len (down)\n        expected = df.iloc[:, 4::-1]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[:, -10:4]  # start < 0 < stop < len\n        expected = df.iloc[:, :4]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[:, 10:4]  # 0 < stop < len < start\n        expected = df.iloc[:, :0]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[:, -10:-11:-1]  # stop < start < 0 < len (down)\n        expected = df.iloc[:, :0]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[:, 10:11]  # 0 < len < start < stop\n        expected = df.iloc[:, :0]\n        tm.assert_frame_equal(result, expected)\n\n        # slice bounds exceeding is ok\n        result = s.iloc[18:30]\n        expected = s.iloc[18:]\n        tm.assert_series_equal(result, expected)\n\n        result = s.iloc[30:]\n        expected = s.iloc[:0]\n        tm.assert_series_equal(result, expected)\n\n        result = s.iloc[30::-1]\n        expected = s.iloc[::-1]\n        tm.assert_series_equal(result, expected)\n\n        # doc example\n        def check(result, expected):\n            str(result)\n            result.dtypes\n            tm.assert_frame_equal(result, expected)\n\n        dfl = DataFrame(np.random.randn(5, 2), columns=list(\"AB\"))\n        check(dfl.iloc[:, 2:3], DataFrame(index=dfl.index))\n        check(dfl.iloc[:, 1:3], dfl.iloc[:, [1]])\n        check(dfl.iloc[4:6], dfl.iloc[[4]])\n\n        msg = \"positional indexers are out-of-bounds\"\n        with pytest.raises(IndexError, match=msg):\n            dfl.iloc[[4, 5, 6]]\n        msg = \"single positional indexer is out-of-bounds\"\n        with pytest.raises(IndexError, match=msg):\n            dfl.iloc[:, 4]",
        "begin_line": 61,
        "end_line": 161,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.check#146",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.check(result, expected)",
        "snippet": "        def check(result, expected):\n            str(result)\n            result.dtypes\n            tm.assert_frame_equal(result, expected)",
        "begin_line": 146,
        "end_line": 149,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_non_integer_raises#172",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_non_integer_raises(self, index, columns, index_vals, column_vals)",
        "snippet": "    def test_iloc_non_integer_raises(self, index, columns, index_vals, column_vals):\n        # GH 25753\n        df = DataFrame(\n            np.random.randn(len(index), len(columns)), index=index, columns=columns\n        )\n        msg = \".iloc requires numeric indexers, got\"\n        with pytest.raises(IndexError, match=msg):\n            df.iloc[index_vals, column_vals]",
        "begin_line": 172,
        "end_line": 179,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_invalid_scalar#182",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_invalid_scalar(self, dims)",
        "snippet": "    def test_iloc_getitem_invalid_scalar(self, dims):\n        # GH 21982\n\n        if dims == 1:\n            s = Series(np.arange(10))\n        else:\n            s = DataFrame(np.arange(100).reshape(10, 10))\n\n        with pytest.raises(TypeError, match=\"Cannot index by location index\"):\n            s.iloc[\"a\"]",
        "begin_line": 182,
        "end_line": 191,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_array_not_mutating_negative_indices#193",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_array_not_mutating_negative_indices(self)",
        "snippet": "    def test_iloc_array_not_mutating_negative_indices(self):\n\n        # GH 21867\n        array_with_neg_numbers = np.array([1, 2, -1])\n        array_copy = array_with_neg_numbers.copy()\n        df = pd.DataFrame(\n            {\"A\": [100, 101, 102], \"B\": [103, 104, 105], \"C\": [106, 107, 108]},\n            index=[1, 2, 3],\n        )\n        df.iloc[array_with_neg_numbers]\n        tm.assert_numpy_array_equal(array_with_neg_numbers, array_copy)\n        df.iloc[:, array_with_neg_numbers]\n        tm.assert_numpy_array_equal(array_with_neg_numbers, array_copy)",
        "begin_line": 193,
        "end_line": 205,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_neg_int_can_reach_first_index#207",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_neg_int_can_reach_first_index(self)",
        "snippet": "    def test_iloc_getitem_neg_int_can_reach_first_index(self):\n        # GH10547 and GH10779\n        # negative integers should be able to reach index 0\n        df = DataFrame({\"A\": [2, 3, 5], \"B\": [7, 11, 13]})\n        s = df[\"A\"]\n\n        expected = df.iloc[0]\n        result = df.iloc[-3]\n        tm.assert_series_equal(result, expected)\n\n        expected = df.iloc[[0]]\n        result = df.iloc[[-3]]\n        tm.assert_frame_equal(result, expected)\n\n        expected = s.iloc[0]\n        result = s.iloc[-3]\n        assert result == expected\n\n        expected = s.iloc[[0]]\n        result = s.iloc[[-3]]\n        tm.assert_series_equal(result, expected)\n\n        # check the length 1 Series case highlighted in GH10547\n        expected = Series([\"a\"], index=[\"A\"])\n        result = expected.iloc[[-1]]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 207,
        "end_line": 232,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_dups#234",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_dups(self)",
        "snippet": "    def test_iloc_getitem_dups(self):\n        # GH 6766\n        df1 = DataFrame([{\"A\": None, \"B\": 1}, {\"A\": 2, \"B\": 2}])\n        df2 = DataFrame([{\"A\": 3, \"B\": 3}, {\"A\": 4, \"B\": 4}])\n        df = concat([df1, df2], axis=1)\n\n        # cross-sectional indexing\n        result = df.iloc[0, 0]\n        assert isna(result)\n\n        result = df.iloc[0, :]\n        expected = Series([np.nan, 1, 3, 3], index=[\"A\", \"B\", \"A\", \"B\"], name=0)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 234,
        "end_line": 246,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_array#248",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_array(self)",
        "snippet": "    def test_iloc_getitem_array(self):\n        # TODO: test something here?\n        pass",
        "begin_line": 248,
        "end_line": 250,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_bool#252",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_bool(self)",
        "snippet": "    def test_iloc_getitem_bool(self):\n        # TODO: test something here?\n        pass",
        "begin_line": 252,
        "end_line": 254,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_bool_diff_len#257",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_bool_diff_len(self, index)",
        "snippet": "    def test_iloc_getitem_bool_diff_len(self, index):\n        # GH26658\n        s = Series([1, 2, 3])\n        msg = f\"Boolean index has wrong length: {len(index)} instead of {len(s)}\"\n        with pytest.raises(IndexError, match=msg):\n            _ = s.iloc[index]",
        "begin_line": 257,
        "end_line": 262,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_slice#264",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_slice(self)",
        "snippet": "    def test_iloc_getitem_slice(self):\n        # TODO: test something here?\n        pass",
        "begin_line": 264,
        "end_line": 266,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_slice_dups#268",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_slice_dups(self)",
        "snippet": "    def test_iloc_getitem_slice_dups(self):\n\n        df1 = DataFrame(np.random.randn(10, 4), columns=[\"A\", \"A\", \"B\", \"B\"])\n        df2 = DataFrame(\n            np.random.randint(0, 10, size=20).reshape(10, 2), columns=[\"A\", \"C\"]\n        )\n\n        # axis=1\n        df = concat([df1, df2], axis=1)\n        tm.assert_frame_equal(df.iloc[:, :4], df1)\n        tm.assert_frame_equal(df.iloc[:, 4:], df2)\n\n        df = concat([df2, df1], axis=1)\n        tm.assert_frame_equal(df.iloc[:, :2], df2)\n        tm.assert_frame_equal(df.iloc[:, 2:], df1)\n\n        exp = concat([df2, df1.iloc[:, [0]]], axis=1)\n        tm.assert_frame_equal(df.iloc[:, 0:3], exp)\n\n        # axis=0\n        df = concat([df, df], axis=0)\n        tm.assert_frame_equal(df.iloc[0:10, :2], df2)\n        tm.assert_frame_equal(df.iloc[0:10, 2:], df1)\n        tm.assert_frame_equal(df.iloc[10:, :2], df2)\n        tm.assert_frame_equal(df.iloc[10:, 2:], df1)",
        "begin_line": 268,
        "end_line": 292,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem#294",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem(self)",
        "snippet": "    def test_iloc_setitem(self):\n        df = DataFrame(\n            np.random.randn(4, 4), index=np.arange(0, 8, 2), columns=np.arange(0, 12, 3)\n        )\n\n        df.iloc[1, 1] = 1\n        result = df.iloc[1, 1]\n        assert result == 1\n\n        df.iloc[:, 2:3] = 0\n        expected = df.iloc[:, 2:3]\n        result = df.iloc[:, 2:3]\n        tm.assert_frame_equal(result, expected)\n\n        # GH5771\n        s = Series(0, index=[4, 5, 6])\n        s.iloc[1:2] += 1\n        expected = Series([0, 1, 0], index=[4, 5, 6])\n        tm.assert_series_equal(s, expected)",
        "begin_line": 294,
        "end_line": 312,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_list#314",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_list(self)",
        "snippet": "    def test_iloc_setitem_list(self):\n\n        # setitem with an iloc list\n        df = DataFrame(\n            np.arange(9).reshape((3, 3)), index=[\"A\", \"B\", \"C\"], columns=[\"A\", \"B\", \"C\"]\n        )\n        df.iloc[[0, 1], [1, 2]]\n        df.iloc[[0, 1], [1, 2]] += 100\n\n        expected = DataFrame(\n            np.array([0, 101, 102, 3, 104, 105, 6, 7, 8]).reshape((3, 3)),\n            index=[\"A\", \"B\", \"C\"],\n            columns=[\"A\", \"B\", \"C\"],\n        )\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 314,
        "end_line": 328,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_pandas_object#330",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_pandas_object(self)",
        "snippet": "    def test_iloc_setitem_pandas_object(self):\n        # GH 17193\n        s_orig = Series([0, 1, 2, 3])\n        expected = Series([0, -1, -2, 3])\n\n        s = s_orig.copy()\n        s.iloc[Series([1, 2])] = [-1, -2]\n        tm.assert_series_equal(s, expected)\n\n        s = s_orig.copy()\n        s.iloc[pd.Index([1, 2])] = [-1, -2]\n        tm.assert_series_equal(s, expected)",
        "begin_line": 330,
        "end_line": 341,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_dups#343",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_dups(self)",
        "snippet": "    def test_iloc_setitem_dups(self):\n\n        # GH 6766\n        # iloc with a mask aligning from another iloc\n        df1 = DataFrame([{\"A\": None, \"B\": 1}, {\"A\": 2, \"B\": 2}])\n        df2 = DataFrame([{\"A\": 3, \"B\": 3}, {\"A\": 4, \"B\": 4}])\n        df = concat([df1, df2], axis=1)\n\n        expected = df.fillna(3)\n        inds = np.isnan(df.iloc[:, 0])\n        mask = inds[inds].index\n        df.iloc[mask, 0] = df.iloc[mask, 2]\n        tm.assert_frame_equal(df, expected)\n\n        # del a dup column across blocks\n        expected = DataFrame({0: [1, 2], 1: [3, 4]})\n        expected.columns = [\"B\", \"B\"]\n        del df[\"A\"]\n        tm.assert_frame_equal(df, expected)\n\n        # assign back to self\n        df.iloc[[0, 1], [0, 1]] = df.iloc[[0, 1], [0, 1]]\n        tm.assert_frame_equal(df, expected)\n\n        # reversed x 2\n        df.iloc[[1, 0], [0, 1]] = df.iloc[[1, 0], [0, 1]].reset_index(drop=True)\n        df.iloc[[1, 0], [0, 1]] = df.iloc[[1, 0], [0, 1]].reset_index(drop=True)\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 343,
        "end_line": 370,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_frame#374",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_frame(self)",
        "snippet": "    def test_iloc_getitem_frame(self):\n        df = DataFrame(\n            np.random.randn(10, 4), index=range(0, 20, 2), columns=range(0, 8, 2)\n        )\n\n        result = df.iloc[2]\n        exp = df.loc[4]\n        tm.assert_series_equal(result, exp)\n\n        result = df.iloc[2, 2]\n        exp = df.loc[4, 4]\n        assert result == exp\n\n        # slice\n        result = df.iloc[4:8]\n        expected = df.loc[8:14]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[:, 2:3]\n        expected = df.loc[:, 4:5]\n        tm.assert_frame_equal(result, expected)\n\n        # list of integers\n        result = df.iloc[[0, 1, 3]]\n        expected = df.loc[[0, 2, 6]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[[0, 1, 3], [0, 1]]\n        expected = df.loc[[0, 2, 6], [0, 2]]\n        tm.assert_frame_equal(result, expected)\n\n        # neg indices\n        result = df.iloc[[-1, 1, 3], [-1, 1]]\n        expected = df.loc[[18, 2, 6], [6, 2]]\n        tm.assert_frame_equal(result, expected)\n\n        # dups indices\n        result = df.iloc[[-1, -1, 1, 3], [-1, 1]]\n        expected = df.loc[[18, 18, 2, 6], [6, 2]]\n        tm.assert_frame_equal(result, expected)\n\n        # with index-like\n        s = Series(index=range(1, 5), dtype=object)\n        result = df.iloc[s.index]\n        expected = df.loc[[2, 4, 6, 8]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 374,
        "end_line": 419,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_labelled_frame#421",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_labelled_frame(self)",
        "snippet": "    def test_iloc_getitem_labelled_frame(self):\n        # try with labelled frame\n        df = DataFrame(\n            np.random.randn(10, 4), index=list(\"abcdefghij\"), columns=list(\"ABCD\")\n        )\n\n        result = df.iloc[1, 1]\n        exp = df.loc[\"b\", \"B\"]\n        assert result == exp\n\n        result = df.iloc[:, 2:3]\n        expected = df.loc[:, [\"C\"]]\n        tm.assert_frame_equal(result, expected)\n\n        # negative indexing\n        result = df.iloc[-1, -1]\n        exp = df.loc[\"j\", \"D\"]\n        assert result == exp\n\n        # out-of-bounds exception\n        msg = \"single positional indexer is out-of-bounds\"\n        with pytest.raises(IndexError, match=msg):\n            df.iloc[10, 5]\n\n        # trying to use a label\n        msg = (\n            r\"Location based indexing can only have \\[integer, integer \"\n            r\"slice \\(START point is INCLUDED, END point is EXCLUDED\\), \"\n            r\"listlike of integers, boolean array\\] types\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            df.iloc[\"j\", \"D\"]",
        "begin_line": 421,
        "end_line": 452,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_doc_issue#454",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_doc_issue(self)",
        "snippet": "    def test_iloc_getitem_doc_issue(self):\n\n        # multi axis slicing issue with single block\n        # surfaced in GH 6059\n\n        arr = np.random.randn(6, 4)\n        index = date_range(\"20130101\", periods=6)\n        columns = list(\"ABCD\")\n        df = DataFrame(arr, index=index, columns=columns)\n\n        # defines ref_locs\n        df.describe()\n\n        result = df.iloc[3:5, 0:2]\n        str(result)\n        result.dtypes\n\n        expected = DataFrame(arr[3:5, 0:2], index=index[3:5], columns=columns[0:2])\n        tm.assert_frame_equal(result, expected)\n\n        # for dups\n        df.columns = list(\"aaaa\")\n        result = df.iloc[3:5, 0:2]\n        str(result)\n        result.dtypes\n\n        expected = DataFrame(arr[3:5, 0:2], index=index[3:5], columns=list(\"aa\"))\n        tm.assert_frame_equal(result, expected)\n\n        # related\n        arr = np.random.randn(6, 4)\n        index = list(range(0, 12, 2))\n        columns = list(range(0, 8, 2))\n        df = DataFrame(arr, index=index, columns=columns)\n\n        df._data.blocks[0].mgr_locs\n        result = df.iloc[1:5, 2:4]\n        str(result)\n        result.dtypes\n        expected = DataFrame(arr[1:5, 2:4], index=index[1:5], columns=columns[2:4])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 454,
        "end_line": 494,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_series#496",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_series(self)",
        "snippet": "    def test_iloc_setitem_series(self):\n        df = DataFrame(\n            np.random.randn(10, 4), index=list(\"abcdefghij\"), columns=list(\"ABCD\")\n        )\n\n        df.iloc[1, 1] = 1\n        result = df.iloc[1, 1]\n        assert result == 1\n\n        df.iloc[:, 2:3] = 0\n        expected = df.iloc[:, 2:3]\n        result = df.iloc[:, 2:3]\n        tm.assert_frame_equal(result, expected)\n\n        s = Series(np.random.randn(10), index=range(0, 20, 2))\n\n        s.iloc[1] = 1\n        result = s.iloc[1]\n        assert result == 1\n\n        s.iloc[:4] = 0\n        expected = s.iloc[:4]\n        result = s.iloc[:4]\n        tm.assert_series_equal(result, expected)\n\n        s = Series([-1] * 6)\n        s.iloc[0::2] = [0, 2, 4]\n        s.iloc[1::2] = [1, 3, 5]\n        result = s\n        expected = Series([0, 1, 2, 3, 4, 5])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 496,
        "end_line": 526,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_list_of_lists#528",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_list_of_lists(self)",
        "snippet": "    def test_iloc_setitem_list_of_lists(self):\n\n        # GH 7551\n        # list-of-list is set incorrectly in mixed vs. single dtyped frames\n        df = DataFrame(\n            dict(A=np.arange(5, dtype=\"int64\"), B=np.arange(5, 10, dtype=\"int64\"))\n        )\n        df.iloc[2:4] = [[10, 11], [12, 13]]\n        expected = DataFrame(dict(A=[0, 1, 10, 12, 4], B=[5, 6, 11, 13, 9]))\n        tm.assert_frame_equal(df, expected)\n\n        df = DataFrame(dict(A=list(\"abcde\"), B=np.arange(5, 10, dtype=\"int64\")))\n        df.iloc[2:4] = [[\"x\", 11], [\"y\", 13]]\n        expected = DataFrame(dict(A=[\"a\", \"b\", \"x\", \"y\", \"e\"], B=[5, 6, 11, 13, 9]))\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 528,
        "end_line": 542,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_with_scalar_index#546",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_with_scalar_index(self, indexer, value)",
        "snippet": "    def test_iloc_setitem_with_scalar_index(self, indexer, value):\n        # GH #19474\n        # assigning like \"df.iloc[0, [0]] = ['Z']\" should be evaluated\n        # elementwisely, not using \"setter('A', ['Z'])\".\n\n        df = pd.DataFrame([[1, 2], [3, 4]], columns=[\"A\", \"B\"])\n        df.iloc[0, indexer] = value\n        result = df.iloc[0, 0]\n\n        assert is_scalar(result) and result == \"Z\"",
        "begin_line": 546,
        "end_line": 555,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_mask#557",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_mask(self)",
        "snippet": "    def test_iloc_mask(self):\n\n        # GH 3631, iloc with a mask (of a series) should raise\n        df = DataFrame(list(range(5)), index=list(\"ABCDE\"), columns=[\"a\"])\n        mask = df.a % 2 == 0\n        msg = \"iLocation based boolean indexing cannot use an indexable as a mask\"\n        with pytest.raises(ValueError, match=msg):\n            df.iloc[mask]\n        mask.index = range(len(mask))\n        msg = \"iLocation based boolean indexing on an integer type is not available\"\n        with pytest.raises(NotImplementedError, match=msg):\n            df.iloc[mask]\n\n        # ndarray ok\n        result = df.iloc[np.array([True] * len(mask), dtype=bool)]\n        tm.assert_frame_equal(result, df)\n\n        # the possibilities\n        locs = np.arange(4)\n        nums = 2 ** locs\n        reps = [bin(num) for num in nums]\n        df = DataFrame({\"locs\": locs, \"nums\": nums}, reps)\n\n        expected = {\n            (None, \"\"): \"0b1100\",\n            (None, \".loc\"): \"0b1100\",\n            (None, \".iloc\"): \"0b1100\",\n            (\"index\", \"\"): \"0b11\",\n            (\"index\", \".loc\"): \"0b11\",\n            (\"index\", \".iloc\"): (\n                \"iLocation based boolean indexing cannot use an indexable as a mask\"\n            ),\n            (\"locs\", \"\"): \"Unalignable boolean Series provided as indexer \"\n            \"(index of the boolean Series and of the indexed \"\n            \"object do not match).\",\n            (\"locs\", \".loc\"): \"Unalignable boolean Series provided as indexer \"\n            \"(index of the boolean Series and of the \"\n            \"indexed object do not match).\",\n            (\"locs\", \".iloc\"): (\n                \"iLocation based boolean indexing on an \"\n                \"integer type is not available\"\n            ),\n        }\n\n        # UserWarnings from reindex of a boolean mask\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", UserWarning)\n            result = dict()\n            for idx in [None, \"index\", \"locs\"]:\n                mask = (df.nums > 2).values\n                if idx:\n                    mask = Series(mask, list(reversed(getattr(df, idx))))\n                for method in [\"\", \".loc\", \".iloc\"]:\n                    try:\n                        if method:\n                            accessor = getattr(df, method[1:])\n                        else:\n                            accessor = df\n                        ans = str(bin(accessor[mask][\"nums\"].sum()))\n                    except (ValueError, IndexingError, NotImplementedError) as e:\n                        ans = str(e)\n\n                    key = tuple([idx, method])\n                    r = expected.get(key)\n                    if r != ans:\n                        raise AssertionError(\n                            f\"[{key}] does not match [{ans}], received [{r}]\"\n                        )",
        "begin_line": 557,
        "end_line": 624,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_non_unique_indexing#626",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_non_unique_indexing(self)",
        "snippet": "    def test_iloc_non_unique_indexing(self):\n\n        # GH 4017, non-unique indexing (on the axis)\n        df = DataFrame({\"A\": [0.1] * 3000, \"B\": [1] * 3000})\n        idx = np.arange(30) * 99\n        expected = df.iloc[idx]\n\n        df3 = concat([df, 2 * df, 3 * df])\n        result = df3.iloc[idx]\n\n        tm.assert_frame_equal(result, expected)\n\n        df2 = DataFrame({\"A\": [0.1] * 1000, \"B\": [1] * 1000})\n        df2 = concat([df2, 2 * df2, 3 * df2])\n\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            df2.loc[idx]",
        "begin_line": 626,
        "end_line": 642,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_empty_list_indexer_is_ok#644",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_empty_list_indexer_is_ok(self)",
        "snippet": "    def test_iloc_empty_list_indexer_is_ok(self):\n\n        df = tm.makeCustomDataframe(5, 2)\n        # vertical empty\n        tm.assert_frame_equal(\n            df.iloc[:, []],\n            df.iloc[:, :0],\n            check_index_type=True,\n            check_column_type=True,\n        )\n        # horizontal empty\n        tm.assert_frame_equal(\n            df.iloc[[], :],\n            df.iloc[:0, :],\n            check_index_type=True,\n            check_column_type=True,\n        )\n        # horizontal empty\n        tm.assert_frame_equal(\n            df.iloc[[]], df.iloc[:0, :], check_index_type=True, check_column_type=True\n        )",
        "begin_line": 644,
        "end_line": 664,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_identity_slice_returns_new_object#666",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_identity_slice_returns_new_object(self)",
        "snippet": "    def test_identity_slice_returns_new_object(self):\n        # GH13873\n        original_df = DataFrame({\"a\": [1, 2, 3]})\n        sliced_df = original_df.iloc[:]\n        assert sliced_df is not original_df\n\n        # should be a shallow copy\n        original_df[\"a\"] = [4, 4, 4]\n        assert (sliced_df[\"a\"] == 4).all()\n\n        original_series = Series([1, 2, 3, 4, 5, 6])\n        sliced_series = original_series.iloc[:]\n        assert sliced_series is not original_series\n\n        # should also be a shallow copy\n        original_series[:3] = [7, 8, 9]\n        assert all(sliced_series[:3] == [7, 8, 9])",
        "begin_line": 666,
        "end_line": 682,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_indexing_zerodim_np_array#684",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_indexing_zerodim_np_array(self)",
        "snippet": "    def test_indexing_zerodim_np_array(self):\n        # GH24919\n        df = DataFrame([[1, 2], [3, 4]])\n        result = df.iloc[np.array(0)]\n        s = pd.Series([1, 2], name=0)\n        tm.assert_series_equal(result, s)",
        "begin_line": 684,
        "end_line": 689,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_series_indexing_zerodim_np_array#691",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_series_indexing_zerodim_np_array(self)",
        "snippet": "    def test_series_indexing_zerodim_np_array(self):\n        # GH24919\n        s = Series([1, 2])\n        result = s.iloc[np.array(0)]\n        assert result == 1",
        "begin_line": 691,
        "end_line": 695,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_categorical_updates_inplace#697",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_categorical_updates_inplace(self)",
        "snippet": "    def test_iloc_setitem_categorical_updates_inplace(self):\n        # Mixed dtype ensures we go through take_split_path in setitem_with_indexer\n        cat = pd.Categorical([\"A\", \"B\", \"C\"])\n        df = pd.DataFrame({1: cat, 2: [1, 2, 3]})\n\n        # This should modify our original values in-place\n        df.iloc[:, 0] = cat[::-1]\n\n        expected = pd.Categorical([\"C\", \"B\", \"A\"])\n        tm.assert_categorical_equal(cat, expected)",
        "begin_line": 697,
        "end_line": 706,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestILocSetItemDuplicateColumns.test_iloc_setitem_scalar_duplicate_columns#710",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestILocSetItemDuplicateColumns",
        "signature": "pandas.tests.indexing.test_iloc.TestILocSetItemDuplicateColumns.test_iloc_setitem_scalar_duplicate_columns(self)",
        "snippet": "    def test_iloc_setitem_scalar_duplicate_columns(self):\n        # GH#15686, duplicate columns and mixed dtype\n        df1 = pd.DataFrame([{\"A\": None, \"B\": 1}, {\"A\": 2, \"B\": 2}])\n        df2 = pd.DataFrame([{\"A\": 3, \"B\": 3}, {\"A\": 4, \"B\": 4}])\n        df = pd.concat([df1, df2], axis=1)\n        df.iloc[0, 0] = -1\n\n        assert df.iloc[0, 0] == -1\n        assert df.iloc[0, 2] == 3\n        assert df.dtypes.iloc[2] == np.int64",
        "begin_line": 710,
        "end_line": 719,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestILocSetItemDuplicateColumns.test_iloc_setitem_list_duplicate_columns#721",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestILocSetItemDuplicateColumns",
        "signature": "pandas.tests.indexing.test_iloc.TestILocSetItemDuplicateColumns.test_iloc_setitem_list_duplicate_columns(self)",
        "snippet": "    def test_iloc_setitem_list_duplicate_columns(self):\n        # GH#22036 setting with same-sized list\n        df = pd.DataFrame([[0, \"str\", \"str2\"]], columns=[\"a\", \"b\", \"b\"])\n\n        df.iloc[:, 2] = [\"str3\"]\n\n        expected = pd.DataFrame([[0, \"str\", \"str3\"]], columns=[\"a\", \"b\", \"b\"])\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 721,
        "end_line": 728,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestILocSetItemDuplicateColumns.test_iloc_setitem_series_duplicate_columns#730",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestILocSetItemDuplicateColumns",
        "signature": "pandas.tests.indexing.test_iloc.TestILocSetItemDuplicateColumns.test_iloc_setitem_series_duplicate_columns(self)",
        "snippet": "    def test_iloc_setitem_series_duplicate_columns(self):\n        df = pd.DataFrame(\n            np.arange(8, dtype=np.int64).reshape(2, 4), columns=[\"A\", \"B\", \"A\", \"B\"]\n        )\n        df.iloc[:, 0] = df.iloc[:, 0].astype(np.float64)\n        assert df.dtypes.iloc[2] == np.int64",
        "begin_line": 730,
        "end_line": 735,
        "comment": "",
        "is_bug": false
    }
]