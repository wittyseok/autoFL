[
    {
        "name": "lib.ansible.plugins.test.files.TestModule.tests#29",
        "src_path": "lib/ansible/plugins/test/files.py",
        "class_name": "lib.ansible.plugins.test.files.TestModule",
        "signature": "lib.ansible.plugins.test.files.TestModule.tests(self)",
        "snippet": "    def tests(self):\n        return {\n            # file testing\n            'is_dir': isdir,\n            'directory': isdir,\n            'is_file': isfile,\n            'file': isfile,\n            'is_link': islink,\n            'link': islink,\n            'exists': exists,\n            'link_exists': lexists,\n\n            # path testing\n            'is_abs': isabs,\n            'abs': isabs,\n            'is_same_file': samefile,\n            'same_file': samefile,\n            'is_mount': ismount,\n            'mount': ismount,\n        }",
        "begin_line": 29,
        "end_line": 48,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.vault_helper.TextVaultSecret.__init__#29",
        "src_path": "test/units/mock/vault_helper.py",
        "class_name": "test.units.mock.vault_helper.TextVaultSecret",
        "signature": "test.units.mock.vault_helper.TextVaultSecret.__init__(self, text, encoding=None, errors=None, _bytes=None)",
        "snippet": "    def __init__(self, text, encoding=None, errors=None, _bytes=None):\n        super(TextVaultSecret, self).__init__()\n        self.text = text\n        self.encoding = encoding or 'utf-8'\n        self._bytes = _bytes\n        self.errors = errors or 'strict'",
        "begin_line": 29,
        "end_line": 34,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.vault_helper.TextVaultSecret.bytes#37",
        "src_path": "test/units/mock/vault_helper.py",
        "class_name": "test.units.mock.vault_helper.TextVaultSecret",
        "signature": "test.units.mock.vault_helper.TextVaultSecret.bytes(self)",
        "snippet": "    def bytes(self):\n        '''The text encoded with encoding, unless we specifically set _bytes.'''\n        return self._bytes or to_bytes(self.text, encoding=self.encoding, errors=self.errors)",
        "begin_line": 37,
        "end_line": 39,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader.__init__#31",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader.__init__(self, file_mapping=None)",
        "snippet": "    def __init__(self, file_mapping=None):\n        file_mapping = {} if file_mapping is None else file_mapping\n        assert type(file_mapping) == dict\n\n        super(DictDataLoader, self).__init__()\n\n        self._file_mapping = file_mapping\n        self._build_known_directories()\n        self._vault_secrets = None",
        "begin_line": 31,
        "end_line": 39,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader.load_from_file#41",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader.load_from_file(self, path, cache=True, unsafe=False)",
        "snippet": "    def load_from_file(self, path, cache=True, unsafe=False):\n        path = to_text(path)\n        if path in self._file_mapping:\n            return self.load(self._file_mapping[path], path)\n        return None",
        "begin_line": 41,
        "end_line": 45,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader._get_file_contents#49",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader._get_file_contents(self, path)",
        "snippet": "    def _get_file_contents(self, path):\n        path = to_text(path)\n        if path in self._file_mapping:\n            return (to_bytes(self._file_mapping[path]), False)\n        else:\n            raise AnsibleParserError(\"file not found: %s\" % path)",
        "begin_line": 49,
        "end_line": 54,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader.path_exists#56",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader.path_exists(self, path)",
        "snippet": "    def path_exists(self, path):\n        path = to_text(path)\n        return path in self._file_mapping or path in self._known_directories",
        "begin_line": 56,
        "end_line": 58,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader.is_file#60",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader.is_file(self, path)",
        "snippet": "    def is_file(self, path):\n        path = to_text(path)\n        return path in self._file_mapping",
        "begin_line": 60,
        "end_line": 62,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader.is_directory#64",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader.is_directory(self, path)",
        "snippet": "    def is_directory(self, path):\n        path = to_text(path)\n        return path in self._known_directories",
        "begin_line": 64,
        "end_line": 66,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader.list_directory#68",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader.list_directory(self, path)",
        "snippet": "    def list_directory(self, path):\n        ret = []\n        path = to_text(path)\n        for x in (list(self._file_mapping.keys()) + self._known_directories):\n            if x.startswith(path):\n                if os.path.dirname(x) == path:\n                    ret.append(os.path.basename(x))\n        return ret",
        "begin_line": 68,
        "end_line": 75,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader.is_executable#77",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader.is_executable(self, path)",
        "snippet": "    def is_executable(self, path):\n        # FIXME: figure out a way to make paths return true for this\n        return False",
        "begin_line": 77,
        "end_line": 79,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader._add_known_directory#81",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader._add_known_directory(self, directory)",
        "snippet": "    def _add_known_directory(self, directory):\n        if directory not in self._known_directories:\n            self._known_directories.append(directory)",
        "begin_line": 81,
        "end_line": 83,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader._build_known_directories#85",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader._build_known_directories(self)",
        "snippet": "    def _build_known_directories(self):\n        self._known_directories = []\n        for path in self._file_mapping:\n            dirname = os.path.dirname(path)\n            while dirname not in ('/', ''):\n                self._add_known_directory(dirname)\n                dirname = os.path.dirname(dirname)",
        "begin_line": 85,
        "end_line": 91,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader.get_basedir#112",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader.get_basedir(self)",
        "snippet": "    def get_basedir(self):\n        return os.getcwd()",
        "begin_line": 112,
        "end_line": 113,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader.set_vault_secrets#115",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader.set_vault_secrets(self, vault_secrets)",
        "snippet": "    def set_vault_secrets(self, vault_secrets):\n        self._vault_secrets = vault_secrets",
        "begin_line": 115,
        "end_line": 116,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.test_distribution_version.test_distribution_version#1850",
        "src_path": "test/units/module_utils/test_distribution_version.py",
        "class_name": "test.units.module_utils.test_distribution_version",
        "signature": "test.units.module_utils.test_distribution_version.test_distribution_version(am, mocker, testcase)",
        "snippet": "def test_distribution_version(am, mocker, testcase):\n    \"\"\"tests the distribution parsing code of the Facts class\n\n    testsets have\n    * a name (for output/debugging only)\n    * input files that are faked\n      * those should be complete and also include \"irrelevant\" files that might be mistaken as coming from other distributions\n      * all files that are not listed here are assumed to not exist at all\n    * the output of ansible.module_utils.distro.linux_distribution() [called platform.dist() for historical reasons]\n    * results for the ansible variables distribution* and os_family\n\n    \"\"\"\n\n    # prepare some mock functions to get the testdata in\n    def mock_get_file_content(fname, default=None, strip=True):\n        \"\"\"give fake content if it exists, otherwise pretend the file is empty\"\"\"\n        data = default\n        if fname in testcase['input']:\n            # for debugging\n            print('faked %s for %s' % (fname, testcase['name']))\n            data = testcase['input'][fname].strip()\n        if strip and data is not None:\n            data = data.strip()\n        return data\n\n    def mock_get_uname(am, flags):\n        if '-v' in flags:\n            return testcase.get('uname_v', None)\n        elif '-r' in flags:\n            return testcase.get('uname_r', None)\n        else:\n            return None\n\n    def mock_file_exists(fname, allow_empty=False):\n        if fname not in testcase['input']:\n            return False\n\n        if allow_empty:\n            return True\n        return bool(len(testcase['input'][fname]))\n\n    def mock_platform_system():\n        return testcase.get('platform.system', 'Linux')\n\n    def mock_platform_release():\n        return testcase.get('platform.release', '')\n\n    def mock_platform_version():\n        return testcase.get('platform.version', '')\n\n    def mock_distro_name():\n        return testcase['distro']['name']\n\n    def mock_distro_id():\n        return testcase['distro']['id']\n\n    def mock_distro_version(best=False):\n        if best:\n            return testcase['distro']['version_best']\n        return testcase['distro']['version']\n\n    def mock_distro_codename():\n        return testcase['distro']['codename']\n\n    def mock_distro_os_release_info():\n        return testcase['distro']['os_release_info']\n\n    def mock_distro_lsb_release_info():\n        return testcase['distro']['lsb_release_info']\n\n    def mock_open(filename, mode='r'):\n        if filename in testcase['input']:\n            file_object = mocker.mock_open(read_data=testcase['input'][filename]).return_value\n            file_object.__iter__.return_value = testcase['input'][filename].splitlines(True)\n        else:\n            file_object = real_open(filename, mode)\n        return file_object\n\n    def mock_os_path_is_file(filename):\n        if filename in testcase['input']:\n            return True\n        return False\n\n    mocker.patch('ansible.module_utils.facts.system.distribution.get_file_content', mock_get_file_content)\n    mocker.patch('ansible.module_utils.facts.system.distribution.get_uname', mock_get_uname)\n    mocker.patch('ansible.module_utils.facts.system.distribution._file_exists', mock_file_exists)\n    mocker.patch('ansible.module_utils.distro.name', mock_distro_name)\n    mocker.patch('ansible.module_utils.distro.id', mock_distro_id)\n    mocker.patch('ansible.module_utils.distro.version', mock_distro_version)\n    mocker.patch('ansible.module_utils.distro.codename', mock_distro_codename)\n    mocker.patch(\n        'ansible.module_utils.common.sys_info.distro.os_release_info',\n        mock_distro_os_release_info)\n    mocker.patch(\n        'ansible.module_utils.common.sys_info.distro.lsb_release_info',\n        mock_distro_lsb_release_info)\n    mocker.patch('os.path.isfile', mock_os_path_is_file)\n    mocker.patch('platform.system', mock_platform_system)\n    mocker.patch('platform.release', mock_platform_release)\n    mocker.patch('platform.version', mock_platform_version)\n\n    real_open = builtins.open\n    mocker.patch.object(builtins, 'open', new=mock_open)\n\n    # run Facts()\n    distro_collector = DistributionFactCollector()\n    generated_facts = distro_collector.collect(am)\n\n    # compare with the expected output\n\n    # testcase['result'] has a list of variables and values it expects Facts() to set\n    for key, val in testcase['result'].items():\n        assert key in generated_facts\n        msg = 'Comparing value of %s on %s, should: %s, is: %s' %\\\n            (key, testcase['name'], val, generated_facts[key])\n        assert generated_facts[key] == val, msg",
        "begin_line": 1850,
        "end_line": 1965,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.test_distribution_version.mock_get_file_content#1864",
        "src_path": "test/units/module_utils/test_distribution_version.py",
        "class_name": "test.units.module_utils.test_distribution_version",
        "signature": "test.units.module_utils.test_distribution_version.mock_get_file_content(fname, default=None, strip=True)",
        "snippet": "    def mock_get_file_content(fname, default=None, strip=True):\n        \"\"\"give fake content if it exists, otherwise pretend the file is empty\"\"\"\n        data = default\n        if fname in testcase['input']:\n            # for debugging\n            print('faked %s for %s' % (fname, testcase['name']))\n            data = testcase['input'][fname].strip()\n        if strip and data is not None:\n            data = data.strip()\n        return data",
        "begin_line": 1864,
        "end_line": 1873,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.test_distribution_version.mock_get_uname#1875",
        "src_path": "test/units/module_utils/test_distribution_version.py",
        "class_name": "test.units.module_utils.test_distribution_version",
        "signature": "test.units.module_utils.test_distribution_version.mock_get_uname(am, flags)",
        "snippet": "    def mock_get_uname(am, flags):\n        if '-v' in flags:\n            return testcase.get('uname_v', None)\n        elif '-r' in flags:\n            return testcase.get('uname_r', None)\n        else:\n            return None",
        "begin_line": 1875,
        "end_line": 1881,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.test_distribution_version.mock_file_exists#1883",
        "src_path": "test/units/module_utils/test_distribution_version.py",
        "class_name": "test.units.module_utils.test_distribution_version",
        "signature": "test.units.module_utils.test_distribution_version.mock_file_exists(fname, allow_empty=False)",
        "snippet": "    def mock_file_exists(fname, allow_empty=False):\n        if fname not in testcase['input']:\n            return False\n\n        if allow_empty:\n            return True\n        return bool(len(testcase['input'][fname]))",
        "begin_line": 1883,
        "end_line": 1889,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.test_distribution_version.mock_platform_system#1891",
        "src_path": "test/units/module_utils/test_distribution_version.py",
        "class_name": "test.units.module_utils.test_distribution_version",
        "signature": "test.units.module_utils.test_distribution_version.mock_platform_system()",
        "snippet": "    def mock_platform_system():\n        return testcase.get('platform.system', 'Linux')",
        "begin_line": 1891,
        "end_line": 1892,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.test_distribution_version.mock_platform_release#1894",
        "src_path": "test/units/module_utils/test_distribution_version.py",
        "class_name": "test.units.module_utils.test_distribution_version",
        "signature": "test.units.module_utils.test_distribution_version.mock_platform_release()",
        "snippet": "    def mock_platform_release():\n        return testcase.get('platform.release', '')",
        "begin_line": 1894,
        "end_line": 1895,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.test_distribution_version.mock_platform_version#1897",
        "src_path": "test/units/module_utils/test_distribution_version.py",
        "class_name": "test.units.module_utils.test_distribution_version",
        "signature": "test.units.module_utils.test_distribution_version.mock_platform_version()",
        "snippet": "    def mock_platform_version():\n        return testcase.get('platform.version', '')",
        "begin_line": 1897,
        "end_line": 1898,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.test_distribution_version.mock_distro_name#1900",
        "src_path": "test/units/module_utils/test_distribution_version.py",
        "class_name": "test.units.module_utils.test_distribution_version",
        "signature": "test.units.module_utils.test_distribution_version.mock_distro_name()",
        "snippet": "    def mock_distro_name():\n        return testcase['distro']['name']",
        "begin_line": 1900,
        "end_line": 1901,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.test_distribution_version.mock_distro_id#1903",
        "src_path": "test/units/module_utils/test_distribution_version.py",
        "class_name": "test.units.module_utils.test_distribution_version",
        "signature": "test.units.module_utils.test_distribution_version.mock_distro_id()",
        "snippet": "    def mock_distro_id():\n        return testcase['distro']['id']",
        "begin_line": 1903,
        "end_line": 1904,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.test_distribution_version.mock_distro_version#1906",
        "src_path": "test/units/module_utils/test_distribution_version.py",
        "class_name": "test.units.module_utils.test_distribution_version",
        "signature": "test.units.module_utils.test_distribution_version.mock_distro_version(best=False)",
        "snippet": "    def mock_distro_version(best=False):\n        if best:\n            return testcase['distro']['version_best']\n        return testcase['distro']['version']",
        "begin_line": 1906,
        "end_line": 1909,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.test_distribution_version.mock_distro_codename#1911",
        "src_path": "test/units/module_utils/test_distribution_version.py",
        "class_name": "test.units.module_utils.test_distribution_version",
        "signature": "test.units.module_utils.test_distribution_version.mock_distro_codename()",
        "snippet": "    def mock_distro_codename():\n        return testcase['distro']['codename']",
        "begin_line": 1911,
        "end_line": 1912,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.test_distribution_version.mock_distro_os_release_info#1914",
        "src_path": "test/units/module_utils/test_distribution_version.py",
        "class_name": "test.units.module_utils.test_distribution_version",
        "signature": "test.units.module_utils.test_distribution_version.mock_distro_os_release_info()",
        "snippet": "    def mock_distro_os_release_info():\n        return testcase['distro']['os_release_info']",
        "begin_line": 1914,
        "end_line": 1915,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.test_distribution_version.mock_distro_lsb_release_info#1917",
        "src_path": "test/units/module_utils/test_distribution_version.py",
        "class_name": "test.units.module_utils.test_distribution_version",
        "signature": "test.units.module_utils.test_distribution_version.mock_distro_lsb_release_info()",
        "snippet": "    def mock_distro_lsb_release_info():\n        return testcase['distro']['lsb_release_info']",
        "begin_line": 1917,
        "end_line": 1918,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.test_distribution_version.mock_open#1920",
        "src_path": "test/units/module_utils/test_distribution_version.py",
        "class_name": "test.units.module_utils.test_distribution_version",
        "signature": "test.units.module_utils.test_distribution_version.mock_open(filename, mode='r')",
        "snippet": "    def mock_open(filename, mode='r'):\n        if filename in testcase['input']:\n            file_object = mocker.mock_open(read_data=testcase['input'][filename]).return_value\n            file_object.__iter__.return_value = testcase['input'][filename].splitlines(True)\n        else:\n            file_object = real_open(filename, mode)\n        return file_object",
        "begin_line": 1920,
        "end_line": 1926,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.test_distribution_version.mock_os_path_is_file#1928",
        "src_path": "test/units/module_utils/test_distribution_version.py",
        "class_name": "test.units.module_utils.test_distribution_version",
        "signature": "test.units.module_utils.test_distribution_version.mock_os_path_is_file(filename)",
        "snippet": "    def mock_os_path_is_file(filename):\n        if filename in testcase['input']:\n            return True\n        return False",
        "begin_line": 1928,
        "end_line": 1931,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.mathstuff.issubset#24",
        "src_path": "lib/ansible/plugins/test/mathstuff.py",
        "class_name": "lib.ansible.plugins.test.mathstuff",
        "signature": "lib.ansible.plugins.test.mathstuff.issubset(a, b)",
        "snippet": "def issubset(a, b):\n    return set(a) <= set(b)",
        "begin_line": 24,
        "end_line": 25,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.mathstuff.issuperset#28",
        "src_path": "lib/ansible/plugins/test/mathstuff.py",
        "class_name": "lib.ansible.plugins.test.mathstuff",
        "signature": "lib.ansible.plugins.test.mathstuff.issuperset(a, b)",
        "snippet": "def issuperset(a, b):\n    return set(a) >= set(b)",
        "begin_line": 28,
        "end_line": 29,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.mathstuff.isnotanumber#32",
        "src_path": "lib/ansible/plugins/test/mathstuff.py",
        "class_name": "lib.ansible.plugins.test.mathstuff",
        "signature": "lib.ansible.plugins.test.mathstuff.isnotanumber(x)",
        "snippet": "def isnotanumber(x):\n    try:\n        return math.isnan(x)\n    except TypeError:\n        return False",
        "begin_line": 32,
        "end_line": 36,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.mathstuff.contains#39",
        "src_path": "lib/ansible/plugins/test/mathstuff.py",
        "class_name": "lib.ansible.plugins.test.mathstuff",
        "signature": "lib.ansible.plugins.test.mathstuff.contains(seq, value)",
        "snippet": "def contains(seq, value):\n    '''Opposite of the ``in`` test, allowing use as a test in filters like ``selectattr``\n\n    .. versionadded:: 2.8\n    '''\n    return value in seq",
        "begin_line": 39,
        "end_line": 44,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.mathstuff.TestModule.tests#50",
        "src_path": "lib/ansible/plugins/test/mathstuff.py",
        "class_name": "lib.ansible.plugins.test.mathstuff.TestModule",
        "signature": "lib.ansible.plugins.test.mathstuff.TestModule.tests(self)",
        "snippet": "    def tests(self):\n        return {\n            # set theory\n            'issubset': issubset,\n            'subset': issubset,\n            'issuperset': issuperset,\n            'superset': issuperset,\n            'contains': contains,\n\n            # numbers\n            'isnan': isnotanumber,\n            'nan': isnotanumber,\n        }",
        "begin_line": 50,
        "end_line": 62,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.failed#35",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.failed(result)",
        "snippet": "def failed(result):\n    ''' Test if task result yields failed '''\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'failed' test expects a dictionary\")\n    return result.get('failed', False)",
        "begin_line": 35,
        "end_line": 39,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.success#42",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.success(result)",
        "snippet": "def success(result):\n    ''' Test if task result yields success '''\n    return not failed(result)",
        "begin_line": 42,
        "end_line": 44,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.unreachable#47",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.unreachable(result)",
        "snippet": "def unreachable(result):\n    ''' Test if task result yields unreachable '''\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'unreachable' test expects a dictionary\")\n    return result.get('unreachable', False)",
        "begin_line": 47,
        "end_line": 51,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.reachable#54",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.reachable(result)",
        "snippet": "def reachable(result):\n    ''' Test if task result yields reachable '''\n    return not unreachable(result)",
        "begin_line": 54,
        "end_line": 56,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.changed#59",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.changed(result)",
        "snippet": "def changed(result):\n    ''' Test if task result yields changed '''\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'changed' test expects a dictionary\")\n    if 'changed' not in result:\n        changed = False\n        if (\n            'results' in result and   # some modules return a 'results' key\n            isinstance(result['results'], MutableSequence) and\n            isinstance(result['results'][0], MutableMapping)\n        ):\n            for res in result['results']:\n                if res.get('changed', False):\n                    changed = True\n                    break\n    else:\n        changed = result.get('changed', False)\n    return changed",
        "begin_line": 59,
        "end_line": 76,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.skipped#79",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.skipped(result)",
        "snippet": "def skipped(result):\n    ''' Test if task result yields skipped '''\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'skipped' test expects a dictionary\")\n    return result.get('skipped', False)",
        "begin_line": 79,
        "end_line": 83,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.started#86",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.started(result)",
        "snippet": "def started(result):\n    ''' Test if async task has started '''\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'started' test expects a dictionary\")\n    if 'started' in result:\n        # For async tasks, return status\n        # NOTE: The value of started is 0 or 1, not False or True :-/\n        return result.get('started', 0) == 1\n    else:\n        # For non-async tasks, warn user, but return as if started\n        display.warning(\"The 'started' test expects an async task, but a non-async task was tested\")\n        return True",
        "begin_line": 86,
        "end_line": 97,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.finished#100",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.finished(result)",
        "snippet": "def finished(result):\n    ''' Test if async task has finished '''\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'finished' test expects a dictionary\")\n    if 'finished' in result:\n        # For async tasks, return status\n        # NOTE: The value of finished is 0 or 1, not False or True :-/\n        return result.get('finished', 0) == 1\n    else:\n        # For non-async tasks, warn user, but return as if finished\n        display.warning(\"The 'finished' test expects an async task, but a non-async task was tested\")\n        return True",
        "begin_line": 100,
        "end_line": 111,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.regex#114",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.regex(value='', pattern='', ignorecase=False, multiline=False, match_type='search')",
        "snippet": "def regex(value='', pattern='', ignorecase=False, multiline=False, match_type='search'):\n    ''' Expose `re` as a boolean filter using the `search` method by default.\n        This is likely only useful for `search` and `match` which already\n        have their own filters.\n    '''\n    # In addition to ensuring the correct type, to_text here will ensure\n    # _fail_with_undefined_error happens if the value is Undefined\n    value = to_text(value, errors='surrogate_or_strict')\n    flags = 0\n    if ignorecase:\n        flags |= re.I\n    if multiline:\n        flags |= re.M\n    _re = re.compile(pattern, flags=flags)\n    return bool(getattr(_re, match_type, 'search')(value))",
        "begin_line": 114,
        "end_line": 128,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.match#131",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.match(value, pattern='', ignorecase=False, multiline=False)",
        "snippet": "def match(value, pattern='', ignorecase=False, multiline=False):\n    ''' Perform a `re.match` returning a boolean '''\n    return regex(value, pattern, ignorecase, multiline, 'match')",
        "begin_line": 131,
        "end_line": 133,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.search#136",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.search(value, pattern='', ignorecase=False, multiline=False)",
        "snippet": "def search(value, pattern='', ignorecase=False, multiline=False):\n    ''' Perform a `re.search` returning a boolean '''\n    return regex(value, pattern, ignorecase, multiline, 'search')",
        "begin_line": 136,
        "end_line": 138,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.version_compare#141",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.version_compare(value, version, operator='eq', strict=False)",
        "snippet": "def version_compare(value, version, operator='eq', strict=False):\n    ''' Perform a version comparison on a value '''\n    op_map = {\n        '==': 'eq', '=': 'eq', 'eq': 'eq',\n        '<': 'lt', 'lt': 'lt',\n        '<=': 'le', 'le': 'le',\n        '>': 'gt', 'gt': 'gt',\n        '>=': 'ge', 'ge': 'ge',\n        '!=': 'ne', '<>': 'ne', 'ne': 'ne'\n    }\n\n    if strict:\n        Version = StrictVersion\n    else:\n        Version = LooseVersion\n\n    if operator in op_map:\n        operator = op_map[operator]\n    else:\n        raise errors.AnsibleFilterError('Invalid operator type')\n\n    try:\n        method = getattr(py_operator, operator)\n        return method(Version(str(value)), Version(str(version)))\n    except Exception as e:\n        raise errors.AnsibleFilterError('Version comparison: %s' % e)",
        "begin_line": 141,
        "end_line": 166,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.truthy#169",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.truthy(value, convert_bool=False)",
        "snippet": "def truthy(value, convert_bool=False):\n    \"\"\"Evaluate as value for truthiness using python ``bool``\n\n    Optionally, attempt to do a conversion to bool from boolean like values\n    such as ``\"false\"``, ``\"true\"``, ``\"yes\"``, ``\"no\"``, ``\"on\"``, ``\"off\"``, etc.\n\n    .. versionadded:: 2.10\n    \"\"\"\n    if convert_bool:\n        try:\n            value = boolean(value)\n        except TypeError:\n            pass\n\n    return bool(value)",
        "begin_line": 169,
        "end_line": 183,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.falsy#186",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.falsy(value, convert_bool=False)",
        "snippet": "def falsy(value, convert_bool=False):\n    \"\"\"Evaluate as value for falsiness using python ``bool``\n\n    Optionally, attempt to do a conversion to bool from boolean like values\n    such as ``\"false\"``, ``\"true\"``, ``\"yes\"``, ``\"no\"``, ``\"on\"``, ``\"off\"``, etc.\n\n    .. versionadded:: 2.10\n    \"\"\"\n    return not truthy(value, convert_bool=convert_bool)",
        "begin_line": 186,
        "end_line": 194,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.TestModule.tests#200",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core.TestModule",
        "signature": "lib.ansible.plugins.test.core.TestModule.tests(self)",
        "snippet": "    def tests(self):\n        return {\n            # failure testing\n            'failed': failed,\n            'failure': failed,\n            'succeeded': success,\n            'success': success,\n            'successful': success,\n            'reachable': reachable,\n            'unreachable': unreachable,\n\n            # changed testing\n            'changed': changed,\n            'change': changed,\n\n            # skip testing\n            'skipped': skipped,\n            'skip': skipped,\n\n            # async testing\n            'finished': finished,\n            'started': started,\n\n            # regex\n            'match': match,\n            'search': search,\n            'regex': regex,\n\n            # version comparison\n            'version_compare': version_compare,\n            'version': version_compare,\n\n            # lists\n            'any': any,\n            'all': all,\n\n            # truthiness\n            'truthy': truthy,\n            'falsy': falsy,\n        }",
        "begin_line": 200,
        "end_line": 239,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.yaml_helper.YamlTestUtils._dump_stream#17",
        "src_path": "test/units/mock/yaml_helper.py",
        "class_name": "test.units.mock.yaml_helper.YamlTestUtils",
        "signature": "test.units.mock.yaml_helper.YamlTestUtils._dump_stream(self, obj, stream, dumper=None)",
        "snippet": "    def _dump_stream(self, obj, stream, dumper=None):\n        \"\"\"Dump to a py2-unicode or py3-string stream.\"\"\"\n        if PY3:\n            return yaml.dump(obj, stream, Dumper=dumper)\n        else:\n            return yaml.dump(obj, stream, Dumper=dumper, encoding=None)",
        "begin_line": 17,
        "end_line": 22,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.yaml_helper.YamlTestUtils._dump_string#24",
        "src_path": "test/units/mock/yaml_helper.py",
        "class_name": "test.units.mock.yaml_helper.YamlTestUtils",
        "signature": "test.units.mock.yaml_helper.YamlTestUtils._dump_string(self, obj, dumper=None)",
        "snippet": "    def _dump_string(self, obj, dumper=None):\n        \"\"\"Dump to a py2-unicode or py3-string\"\"\"\n        if PY3:\n            return yaml.dump(obj, Dumper=dumper)\n        else:\n            return yaml.dump(obj, Dumper=dumper, encoding=None)",
        "begin_line": 24,
        "end_line": 29,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.yaml_helper.YamlTestUtils._dump_load_cycle#31",
        "src_path": "test/units/mock/yaml_helper.py",
        "class_name": "test.units.mock.yaml_helper.YamlTestUtils",
        "signature": "test.units.mock.yaml_helper.YamlTestUtils._dump_load_cycle(self, obj)",
        "snippet": "    def _dump_load_cycle(self, obj):\n        # Each pass though a dump or load revs the 'generation'\n        # obj to yaml string\n        string_from_object_dump = self._dump_string(obj, dumper=AnsibleDumper)\n\n        # wrap a stream/file like StringIO around that yaml\n        stream_from_object_dump = io.StringIO(string_from_object_dump)\n        loader = self._loader(stream_from_object_dump)\n        # load the yaml stream to create a new instance of the object (gen 2)\n        obj_2 = loader.get_data()\n\n        # dump the gen 2 objects directory to strings\n        string_from_object_dump_2 = self._dump_string(obj_2,\n                                                      dumper=AnsibleDumper)\n\n        # The gen 1 and gen 2 yaml strings\n        self.assertEqual(string_from_object_dump, string_from_object_dump_2)\n        # the gen 1 (orig) and gen 2 py object\n        self.assertEqual(obj, obj_2)\n\n        # again! gen 3... load strings into py objects\n        stream_3 = io.StringIO(string_from_object_dump_2)\n        loader_3 = self._loader(stream_3)\n        obj_3 = loader_3.get_data()\n\n        string_from_object_dump_3 = self._dump_string(obj_3, dumper=AnsibleDumper)\n\n        self.assertEqual(obj, obj_3)\n        # should be transitive, but...\n        self.assertEqual(obj_2, obj_3)\n        self.assertEqual(string_from_object_dump, string_from_object_dump_3)",
        "begin_line": 31,
        "end_line": 61,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.modules.utils.set_module_args#9",
        "src_path": "test/units/modules/utils.py",
        "class_name": "test.units.modules.utils",
        "signature": "test.units.modules.utils.set_module_args(args)",
        "snippet": "def set_module_args(args):\n    if '_ansible_remote_tmp' not in args:\n        args['_ansible_remote_tmp'] = '/tmp'\n    if '_ansible_keep_remote_files' not in args:\n        args['_ansible_keep_remote_files'] = False\n\n    args = json.dumps({'ANSIBLE_MODULE_ARGS': args})\n    basic._ANSIBLE_ARGS = to_bytes(args)",
        "begin_line": 9,
        "end_line": 16,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.modules.utils.exit_json#27",
        "src_path": "test/units/modules/utils.py",
        "class_name": "test.units.modules.utils",
        "signature": "test.units.modules.utils.exit_json(*args, **kwargs)",
        "snippet": "def exit_json(*args, **kwargs):\n    if 'changed' not in kwargs:\n        kwargs['changed'] = False\n    raise AnsibleExitJson(kwargs)",
        "begin_line": 27,
        "end_line": 30,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.modules.utils.fail_json#33",
        "src_path": "test/units/modules/utils.py",
        "class_name": "test.units.modules.utils",
        "signature": "test.units.modules.utils.fail_json(*args, **kwargs)",
        "snippet": "def fail_json(*args, **kwargs):\n    kwargs['failed'] = True\n    raise AnsibleFailJson(kwargs)",
        "begin_line": 33,
        "end_line": 35,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.modules.utils.ModuleTestCase.setUp#40",
        "src_path": "test/units/modules/utils.py",
        "class_name": "test.units.modules.utils.ModuleTestCase",
        "signature": "test.units.modules.utils.ModuleTestCase.setUp(self)",
        "snippet": "    def setUp(self):\n        self.mock_module = patch.multiple(basic.AnsibleModule, exit_json=exit_json, fail_json=fail_json)\n        self.mock_module.start()\n        self.mock_sleep = patch('time.sleep')\n        self.mock_sleep.start()\n        set_module_args({})\n        self.addCleanup(self.mock_module.stop)\n        self.addCleanup(self.mock_sleep.stop)",
        "begin_line": 40,
        "end_line": 47,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.plugins.become.conftest.parser#17",
        "src_path": "test/units/plugins/become/conftest.py",
        "class_name": "test.units.plugins.become.conftest",
        "signature": "test.units.plugins.become.conftest.parser()",
        "snippet": "def parser():\n    parser = opt_help.create_base_parser('testparser')\n\n    opt_help.add_runas_options(parser)\n    opt_help.add_meta_options(parser)\n    opt_help.add_runtask_options(parser)\n    opt_help.add_vault_options(parser)\n    opt_help.add_async_options(parser)\n    opt_help.add_connect_options(parser)\n    opt_help.add_subset_options(parser)\n    opt_help.add_check_options(parser)\n    opt_help.add_inventory_options(parser)\n\n    return parser",
        "begin_line": 17,
        "end_line": 30,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.plugins.become.conftest.reset_cli_args#34",
        "src_path": "test/units/plugins/become/conftest.py",
        "class_name": "test.units.plugins.become.conftest",
        "signature": "test.units.plugins.become.conftest.reset_cli_args()",
        "snippet": "def reset_cli_args():\n    co.GlobalCLIArgs._Singleton__instance = None\n    yield\n    co.GlobalCLIArgs._Singleton__instance = None",
        "begin_line": 34,
        "end_line": 37,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.facts.base.BaseFactsTest._mock_module#40",
        "src_path": "test/units/module_utils/facts/base.py",
        "class_name": "test.units.module_utils.facts.base.BaseFactsTest",
        "signature": "test.units.module_utils.facts.base.BaseFactsTest._mock_module(self)",
        "snippet": "    def _mock_module(self):\n        mock_module = Mock()\n        mock_module.params = {'gather_subset': self.gather_subset,\n                              'gather_timeout': 5,\n                              'filter': '*'}\n        mock_module.get_bin_path = Mock(return_value=None)\n        return mock_module",
        "begin_line": 40,
        "end_line": 46,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.facts.base.BaseFactsTest.test_collect#50",
        "src_path": "test/units/module_utils/facts/base.py",
        "class_name": "test.units.module_utils.facts.base.BaseFactsTest",
        "signature": "test.units.module_utils.facts.base.BaseFactsTest.test_collect(self, mock_gfc, mock_ps)",
        "snippet": "    def test_collect(self, mock_gfc, mock_ps):\n        module = self._mock_module()\n        fact_collector = self.collector_class()\n        facts_dict = fact_collector.collect(module=module, collected_facts=self.collected_facts)\n        self.assertIsInstance(facts_dict, dict)\n        return facts_dict",
        "begin_line": 50,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.facts.base.BaseFactsTest.test_collect_with_namespace#59",
        "src_path": "test/units/module_utils/facts/base.py",
        "class_name": "test.units.module_utils.facts.base.BaseFactsTest",
        "signature": "test.units.module_utils.facts.base.BaseFactsTest.test_collect_with_namespace(self, mock_gfc, mock_ps)",
        "snippet": "    def test_collect_with_namespace(self, mock_gfc, mock_ps):\n        module = self._mock_module()\n        fact_collector = self.collector_class()\n        facts_dict = fact_collector.collect_with_namespace(module=module,\n                                                           collected_facts=self.collected_facts)\n        self.assertIsInstance(facts_dict, dict)\n        return facts_dict",
        "begin_line": 59,
        "end_line": 65,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.plugins.loader_fixtures.import_fixture.test.__init__#7",
        "src_path": "test/units/plugins/loader_fixtures/import_fixture.py",
        "class_name": "test.units.plugins.loader_fixtures.import_fixture.test",
        "signature": "test.units.plugins.loader_fixtures.import_fixture.test.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        pass",
        "begin_line": 7,
        "end_line": 8,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.modules.conftest.patch_ansible_module#14",
        "src_path": "test/units/modules/conftest.py",
        "class_name": "test.units.modules.conftest",
        "signature": "test.units.modules.conftest.patch_ansible_module(request, mocker)",
        "snippet": "def patch_ansible_module(request, mocker):\n    if isinstance(request.param, string_types):\n        args = request.param\n    elif isinstance(request.param, MutableMapping):\n        if 'ANSIBLE_MODULE_ARGS' not in request.param:\n            request.param = {'ANSIBLE_MODULE_ARGS': request.param}\n        if '_ansible_remote_tmp' not in request.param['ANSIBLE_MODULE_ARGS']:\n            request.param['ANSIBLE_MODULE_ARGS']['_ansible_remote_tmp'] = '/tmp'\n        if '_ansible_keep_remote_files' not in request.param['ANSIBLE_MODULE_ARGS']:\n            request.param['ANSIBLE_MODULE_ARGS']['_ansible_keep_remote_files'] = False\n        args = json.dumps(request.param)\n    else:\n        raise Exception('Malformed data to the patch_ansible_module pytest fixture')\n\n    mocker.patch('ansible.module_utils.basic._ANSIBLE_ARGS', to_bytes(args))",
        "begin_line": 14,
        "end_line": 28,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.conftest.stdin#17",
        "src_path": "test/units/module_utils/conftest.py",
        "class_name": "test.units.module_utils.conftest",
        "signature": "test.units.module_utils.conftest.stdin(mocker, request)",
        "snippet": "def stdin(mocker, request):\n    old_args = ansible.module_utils.basic._ANSIBLE_ARGS\n    ansible.module_utils.basic._ANSIBLE_ARGS = None\n    old_argv = sys.argv\n    sys.argv = ['ansible_unittest']\n\n    if isinstance(request.param, string_types):\n        args = request.param\n    elif isinstance(request.param, MutableMapping):\n        if 'ANSIBLE_MODULE_ARGS' not in request.param:\n            request.param = {'ANSIBLE_MODULE_ARGS': request.param}\n        if '_ansible_remote_tmp' not in request.param['ANSIBLE_MODULE_ARGS']:\n            request.param['ANSIBLE_MODULE_ARGS']['_ansible_remote_tmp'] = '/tmp'\n        if '_ansible_keep_remote_files' not in request.param['ANSIBLE_MODULE_ARGS']:\n            request.param['ANSIBLE_MODULE_ARGS']['_ansible_keep_remote_files'] = False\n        args = json.dumps(request.param)\n    else:\n        raise Exception('Malformed data to the stdin pytest fixture')\n\n    fake_stdin = BytesIO(to_bytes(args, errors='surrogate_or_strict'))\n    if PY3:\n        mocker.patch('ansible.module_utils.basic.sys.stdin', mocker.MagicMock())\n        mocker.patch('ansible.module_utils.basic.sys.stdin.buffer', fake_stdin)\n    else:\n        mocker.patch('ansible.module_utils.basic.sys.stdin', fake_stdin)\n\n    yield fake_stdin\n\n    ansible.module_utils.basic._ANSIBLE_ARGS = old_args\n    sys.argv = old_argv",
        "begin_line": 17,
        "end_line": 46,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.conftest.am#50",
        "src_path": "test/units/module_utils/conftest.py",
        "class_name": "test.units.module_utils.conftest",
        "signature": "test.units.module_utils.conftest.am(stdin, request)",
        "snippet": "def am(stdin, request):\n    old_args = ansible.module_utils.basic._ANSIBLE_ARGS\n    ansible.module_utils.basic._ANSIBLE_ARGS = None\n    old_argv = sys.argv\n    sys.argv = ['ansible_unittest']\n\n    argspec = {}\n    if hasattr(request, 'param'):\n        if isinstance(request.param, dict):\n            argspec = request.param\n\n    am = ansible.module_utils.basic.AnsibleModule(\n        argument_spec=argspec,\n    )\n    am._name = 'ansible_unittest'\n\n    yield am\n\n    ansible.module_utils.basic._ANSIBLE_ARGS = old_args\n    sys.argv = old_argv",
        "begin_line": 50,
        "end_line": 69,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.procenv.swap_stdin_and_argv#34",
        "src_path": "test/units/mock/procenv.py",
        "class_name": "test.units.mock.procenv",
        "signature": "test.units.mock.procenv.swap_stdin_and_argv(stdin_data='', argv_data=tuple())",
        "snippet": "def swap_stdin_and_argv(stdin_data='', argv_data=tuple()):\n    \"\"\"\n    context manager that temporarily masks the test runner's values for stdin and argv\n    \"\"\"\n    real_stdin = sys.stdin\n    real_argv = sys.argv\n\n    if PY3:\n        fake_stream = StringIO(stdin_data)\n        fake_stream.buffer = BytesIO(to_bytes(stdin_data))\n    else:\n        fake_stream = BytesIO(to_bytes(stdin_data))\n\n    try:\n        sys.stdin = fake_stream\n        sys.argv = argv_data\n\n        yield\n    finally:\n        sys.stdin = real_stdin\n        sys.argv = real_argv",
        "begin_line": 34,
        "end_line": 54,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.procenv.ModuleTestCase.setUp#78",
        "src_path": "test/units/mock/procenv.py",
        "class_name": "test.units.mock.procenv.ModuleTestCase",
        "signature": "test.units.mock.procenv.ModuleTestCase.setUp(self, module_args=None)",
        "snippet": "    def setUp(self, module_args=None):\n        if module_args is None:\n            module_args = {'_ansible_remote_tmp': '/tmp', '_ansible_keep_remote_files': False}\n\n        args = json.dumps(dict(ANSIBLE_MODULE_ARGS=module_args))\n\n        # unittest doesn't have a clean place to use a context manager, so we have to enter/exit manually\n        self.stdin_swap = swap_stdin_and_argv(stdin_data=args)\n        self.stdin_swap.__enter__()",
        "begin_line": 78,
        "end_line": 86,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.procenv.ModuleTestCase.tearDown#88",
        "src_path": "test/units/mock/procenv.py",
        "class_name": "test.units.mock.procenv.ModuleTestCase",
        "signature": "test.units.mock.procenv.ModuleTestCase.tearDown(self)",
        "snippet": "    def tearDown(self):\n        # unittest doesn't have a clean place to use a context manager, so we have to enter/exit manually\n        self.stdin_swap.__exit__(None, None, None)",
        "begin_line": 88,
        "end_line": 90,
        "comment": "",
        "is_bug": false
    }
]