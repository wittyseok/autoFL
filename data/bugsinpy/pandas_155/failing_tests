coverage run -m pytest pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime
============================= test session starts ==============================
platform linux -- Python 3.8.3, pytest-5.4.3, py-1.8.1, pluggy-0.13.1
rootdir: /home/user/BugsInPy/temp/projects/pandas, inifile: setup.cfg
plugins: hypothesis-5.16.0
collected 56 items

pandas/tests/window/test_rolling.py ..............FFFFFFFFFFFFFF........ [ 64%]
......FFFFFFFFFFFFFF                                                     [100%]

=================================== FAILURES ===================================
________________ TestRolling.test_rolling_datetime[axis 1-None] ________________

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f2458bd7a60>
axis_frame = 1, tz_naive_fixture = None

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
_______________ TestRolling.test_rolling_datetime[axis 1-'UTC'] ________________

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f2459074a30>
axis_frame = 1, tz_naive_fixture = 'UTC'

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
____________ TestRolling.test_rolling_datetime[axis 1-'US/Eastern'] ____________

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f24587bacd0>
axis_frame = 1, tz_naive_fixture = 'US/Eastern'

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
____________ TestRolling.test_rolling_datetime[axis 1-'Asia/Tokyo'] ____________

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f2458bcb9a0>
axis_frame = 1, tz_naive_fixture = 'Asia/Tokyo'

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
_______ TestRolling.test_rolling_datetime[axis 1-'dateutil/US/Pacific'] ________

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f24587743a0>
axis_frame = 1, tz_naive_fixture = 'dateutil/US/Pacific'

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
_____ TestRolling.test_rolling_datetime[axis 1-'dateutil/Asia/Singapore'] ______

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f24587f46a0>
axis_frame = 1, tz_naive_fixture = 'dateutil/Asia/Singapore'

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
______________ TestRolling.test_rolling_datetime[axis 1-tzutc()] _______________

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f2458a121c0>
axis_frame = 1, tz_naive_fixture = tzutc()

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
_____________ TestRolling.test_rolling_datetime[axis 1-tzlocal()] ______________

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f24583c08b0>
axis_frame = 1, tz_naive_fixture = tzlocal()

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
_______ TestRolling.test_rolling_datetime[axis 1-pytz.FixedOffset(300)] ________

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f24581c9f40>
axis_frame = 1, tz_naive_fixture = pytz.FixedOffset(300)

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
_______________ TestRolling.test_rolling_datetime[axis 1-<UTC>] ________________

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f24583c0550>
axis_frame = 1, tz_naive_fixture = <UTC>

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
_______ TestRolling.test_rolling_datetime[axis 1-pytz.FixedOffset(-300)] _______

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f24583c0370>
axis_frame = 1, tz_naive_fixture = pytz.FixedOffset(-300)

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
_______ TestRolling.test_rolling_datetime[axis 1-datetime.timezone.utc] ________

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f2458a12610>
axis_frame = 1, tz_naive_fixture = datetime.timezone.utc

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
_ TestRolling.test_rolling_datetime[axis 1-datetime.timezone(datetime.timedelta(seconds=3600))] _

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f245882f9d0>
axis_frame = 1
tz_naive_fixture = datetime.timezone(datetime.timedelta(seconds=3600))

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
_ TestRolling.test_rolling_datetime[axis 1-datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')] _

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f2458b551c0>
axis_frame = 1
tz_naive_fixture = datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
____________ TestRolling.test_rolling_datetime[axis 'columns'-None] ____________

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f2458cc8ac0>
axis_frame = 'columns', tz_naive_fixture = None

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
___________ TestRolling.test_rolling_datetime[axis 'columns'-'UTC'] ____________

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f24585dedf0>
axis_frame = 'columns', tz_naive_fixture = 'UTC'

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
________ TestRolling.test_rolling_datetime[axis 'columns'-'US/Eastern'] ________

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f24586e0d90>
axis_frame = 'columns', tz_naive_fixture = 'US/Eastern'

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
________ TestRolling.test_rolling_datetime[axis 'columns'-'Asia/Tokyo'] ________

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f2458c83a60>
axis_frame = 'columns', tz_naive_fixture = 'Asia/Tokyo'

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
___ TestRolling.test_rolling_datetime[axis 'columns'-'dateutil/US/Pacific'] ____

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f24587745e0>
axis_frame = 'columns', tz_naive_fixture = 'dateutil/US/Pacific'

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
_ TestRolling.test_rolling_datetime[axis 'columns'-'dateutil/Asia/Singapore'] __

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f2458c73160>
axis_frame = 'columns', tz_naive_fixture = 'dateutil/Asia/Singapore'

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
__________ TestRolling.test_rolling_datetime[axis 'columns'-tzutc()] ___________

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f2458c68820>
axis_frame = 'columns', tz_naive_fixture = tzutc()

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
_________ TestRolling.test_rolling_datetime[axis 'columns'-tzlocal()] __________

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f2458c8cd60>
axis_frame = 'columns', tz_naive_fixture = tzlocal()

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
___ TestRolling.test_rolling_datetime[axis 'columns'-pytz.FixedOffset(300)] ____

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f2458cc8460>
axis_frame = 'columns', tz_naive_fixture = pytz.FixedOffset(300)

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
___________ TestRolling.test_rolling_datetime[axis 'columns'-<UTC>] ____________

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f24586e07f0>
axis_frame = 'columns', tz_naive_fixture = <UTC>

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
___ TestRolling.test_rolling_datetime[axis 'columns'-pytz.FixedOffset(-300)] ___

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f2458664280>
axis_frame = 'columns', tz_naive_fixture = pytz.FixedOffset(-300)

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
___ TestRolling.test_rolling_datetime[axis 'columns'-datetime.timezone.utc] ____

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f24586593d0>
axis_frame = 'columns', tz_naive_fixture = datetime.timezone.utc

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
_ TestRolling.test_rolling_datetime[axis 'columns'-datetime.timezone(datetime.timedelta(seconds=3600))] _

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f2458c69ca0>
axis_frame = 'columns'
tz_naive_fixture = datetime.timezone(datetime.timedelta(seconds=3600))

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
_ TestRolling.test_rolling_datetime[axis 'columns'-datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')] _

self = <pandas.tests.window.test_rolling.TestRolling object at 0x7f2458c8c2b0>
axis_frame = 'columns'
tz_naive_fixture = datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')

    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):
        # GH-28192
        tz = tz_naive_fixture
        df = pd.DataFrame(
            {
                i: [1] * 2
                for i in pd.date_range("2019-8-01", "2019-08-03", freq="D", tz=tz)
            }
        )
        if axis_frame in [0, "index"]:
            result = df.T.rolling("2D", axis=axis_frame).sum().T
        else:
>           result = df.rolling("2D", axis=axis_frame).sum()

pandas/tests/window/test_rolling.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/generic.py:10767: in rolling
    return Rolling(
pandas/core/window/rolling.py:88: in __init__
    self.validate()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Rolling [window=2D,center=False,axis=1]

    def validate(self):
        super().validate()
    
        # we allow rolling on a datetimelike index
        if (self.obj.empty or self.is_datetimelike) and isinstance(
            self.window, (str, ABCDateOffset, timedelta)
        ):
    
            self._validate_monotonic()
            freq = self._validate_freq()
    
            # we don't allow center
            if self.center:
                raise NotImplementedError(
                    "center is not implemented "
                    "for datetimelike and offset "
                    "based windows"
                )
    
            # this will raise ValueError on non-fixed freqs
            self.win_freq = self.window
            self.window = freq.nanos
            self.win_type = "freq"
    
            # min_periods must be an integer
            if self.min_periods is None:
                self.min_periods = 1
    
        elif not is_integer(self.window):
>           raise ValueError("window must be an integer")
E           ValueError: window must be an integer

pandas/core/window/rolling.py:1695: ValueError
=========================== short test summary info ============================
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 1-None]
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 1-'UTC']
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 1-'US/Eastern']
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 1-'Asia/Tokyo']
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 1-'dateutil/US/Pacific']
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 1-'dateutil/Asia/Singapore']
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 1-tzutc()]
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 1-tzlocal()]
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 1-pytz.FixedOffset(300)]
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 1-<UTC>]
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 1-pytz.FixedOffset(-300)]
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 1-datetime.timezone.utc]
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 1-datetime.timezone(datetime.timedelta(seconds=3600))]
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 1-datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')]
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 'columns'-None]
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 'columns'-'UTC']
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 'columns'-'US/Eastern']
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 'columns'-'Asia/Tokyo']
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 'columns'-'dateutil/US/Pacific']
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 'columns'-'dateutil/Asia/Singapore']
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 'columns'-tzutc()]
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 'columns'-tzlocal()]
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 'columns'-pytz.FixedOffset(300)]
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 'columns'-<UTC>]
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 'columns'-pytz.FixedOffset(-300)]
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 'columns'-datetime.timezone.utc]
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 'columns'-datetime.timezone(datetime.timedelta(seconds=3600))]
FAILED pandas/tests/window/test_rolling.py::TestRolling::test_rolling_datetime[axis 'columns'-datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')]
======================== 28 failed, 28 passed in 7.10s =========================
