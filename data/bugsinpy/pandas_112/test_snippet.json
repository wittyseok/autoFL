[
    {
        "name": "pandas.tests.frame.conftest.float_frame_with_na#9",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.float_frame_with_na()",
        "snippet": "def float_frame_with_na():\n    \"\"\"\n    Fixture for DataFrame of floats with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']; some entries are missing\n\n                       A         B         C         D\n    ABwBzA0ljw -1.128865 -0.897161  0.046603  0.274997\n    DJiRzmbyQF  0.728869  0.233502  0.722431 -0.890872\n    neMgPD5UBF  0.486072 -1.027393 -0.031553  1.449522\n    0yWA4n8VeX -1.937191 -1.142531  0.805215 -0.462018\n    3slYUbbqU1  0.153260  1.164691  1.489795 -0.545826\n    soujjZ0A08       NaN       NaN       NaN       NaN\n    7W6NLGsjB9       NaN       NaN       NaN       NaN\n    ...              ...       ...       ...       ...\n    uhfeaNkCR1 -0.231210 -0.340472  0.244717 -0.901590\n    n6p7GYuBIV -0.419052  1.922721 -0.125361 -0.727717\n    ZhzAeY6p1y  1.234374 -1.425359 -0.827038 -0.633189\n    uWdPsORyUh  0.046738 -0.980445 -1.102965  0.605503\n    3DJA6aN590 -0.091018 -1.684734 -1.100900  0.215947\n    2GBPAzdbMk -2.883405 -1.021071  1.209877  1.633083\n    sHadBoyVHw -2.223032 -0.326384  0.258931  0.245517\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    # set some NAs\n    df.loc[5:10] = np.nan\n    df.loc[15:20, -2:] = np.nan\n    return df",
        "begin_line": 9,
        "end_line": 38,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.bool_frame_with_na#42",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.bool_frame_with_na()",
        "snippet": "def bool_frame_with_na():\n    \"\"\"\n    Fixture for DataFrame of booleans with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']; some entries are missing\n\n                    A      B      C      D\n    zBZxY2IDGd  False  False  False  False\n    IhBWBMWllt  False   True   True   True\n    ctjdvZSR6R   True  False   True   True\n    AVTujptmxb  False   True  False   True\n    G9lrImrSWq  False  False  False   True\n    sFFwdIUfz2    NaN    NaN    NaN    NaN\n    s15ptEJnRb    NaN    NaN    NaN    NaN\n    ...           ...    ...    ...    ...\n    UW41KkDyZ4   True   True  False  False\n    l9l6XkOdqV   True  False  False  False\n    X2MeZfzDYA  False   True  False  False\n    xWkIKU7vfX  False   True  False   True\n    QOhL6VmpGU  False  False  False   True\n    22PwkRJdat  False   True  False  False\n    kfboQ3VeIK   True  False   True  False\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData()) > 0\n    df = df.astype(object)\n    # set some NAs\n    df.loc[5:10] = np.nan\n    df.loc[15:20, -2:] = np.nan\n    return df",
        "begin_line": 42,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.int_frame#76",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.int_frame()",
        "snippet": "def int_frame():\n    \"\"\"\n    Fixture for DataFrame of ints with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']\n\n                A  B  C  D\n    vpBeWjM651  1  0  1  0\n    5JyxmrP1En -1  0  0  0\n    qEDaoD49U2 -1  1  0  0\n    m66TkTfsFe  0  0  0  0\n    EHPaNzEUFm -1  0 -1  0\n    fpRJCevQhi  2  0  0  0\n    OlQvnmfi3Q  0  0 -2  0\n    ...        .. .. .. ..\n    uB1FPlz4uP  0  0  0  1\n    EcSe6yNzCU  0  0 -1  0\n    L50VudaiI8 -1  1 -2  0\n    y3bpw4nwIp  0 -1  0  0\n    H0RdLLwrCT  1  1  0  0\n    rY82K0vMwm  0  0  0  0\n    1OPIUjnkjk  2  0  0  0\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame({k: v.astype(int) for k, v in tm.getSeriesData().items()})\n    # force these all to int64 to avoid platform testing issues\n    return DataFrame({c: s for c, s in df.items()}, dtype=np.int64)",
        "begin_line": 76,
        "end_line": 103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.datetime_frame#107",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.datetime_frame()",
        "snippet": "def datetime_frame():\n    \"\"\"\n    Fixture for DataFrame of floats with DatetimeIndex\n\n    Columns are ['A', 'B', 'C', 'D']\n\n                       A         B         C         D\n    2000-01-03 -1.122153  0.468535  0.122226  1.693711\n    2000-01-04  0.189378  0.486100  0.007864 -1.216052\n    2000-01-05  0.041401 -0.835752 -0.035279 -0.414357\n    2000-01-06  0.430050  0.894352  0.090719  0.036939\n    2000-01-07 -0.620982 -0.668211 -0.706153  1.466335\n    2000-01-10 -0.752633  0.328434 -0.815325  0.699674\n    2000-01-11 -2.236969  0.615737 -0.829076 -1.196106\n    ...              ...       ...       ...       ...\n    2000-02-03  1.642618 -0.579288  0.046005  1.385249\n    2000-02-04 -0.544873 -1.160962 -0.284071 -1.418351\n    2000-02-07 -2.656149 -0.601387  1.410148  0.444150\n    2000-02-08 -1.201881 -1.289040  0.772992 -1.445300\n    2000-02-09  1.377373  0.398619  1.008453 -0.928207\n    2000-02-10  0.473194 -0.636677  0.984058  0.511519\n    2000-02-11 -0.965556  0.408313 -1.312844 -0.381948\n\n    [30 rows x 4 columns]\n    \"\"\"\n    return DataFrame(tm.getTimeSeriesData())",
        "begin_line": 107,
        "end_line": 132,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.float_string_frame#136",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.float_string_frame()",
        "snippet": "def float_string_frame():\n    \"\"\"\n    Fixture for DataFrame of floats and strings with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D', 'foo'].\n\n                       A         B         C         D  foo\n    w3orJvq07g -1.594062 -1.084273 -1.252457  0.356460  bar\n    PeukuVdmz2  0.109855 -0.955086 -0.809485  0.409747  bar\n    ahp2KvwiM8 -1.533729 -0.142519 -0.154666  1.302623  bar\n    3WSJ7BUCGd  2.484964  0.213829  0.034778 -2.327831  bar\n    khdAmufk0U -0.193480 -0.743518 -0.077987  0.153646  bar\n    LE2DZiFlrE -0.193566 -1.343194 -0.107321  0.959978  bar\n    HJXSJhVn7b  0.142590  1.257603 -0.659409 -0.223844  bar\n    ...              ...       ...       ...       ...  ...\n    9a1Vypttgw -1.316394  1.601354  0.173596  1.213196  bar\n    h5d1gVFbEy  0.609475  1.106738 -0.155271  0.294630  bar\n    mK9LsTQG92  1.303613  0.857040 -1.019153  0.369468  bar\n    oOLksd9gKH  0.558219 -0.134491 -0.289869 -0.951033  bar\n    9jgoOjKyHg  0.058270 -0.496110 -0.413212 -0.852659  bar\n    jZLDHclHAO  0.096298  1.267510  0.549206 -0.005235  bar\n    lR0nxDp1C2 -2.119350 -0.794384  0.544118  0.145849  bar\n\n    [30 rows x 5 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    df[\"foo\"] = \"bar\"\n    return df",
        "begin_line": 136,
        "end_line": 163,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_float_frame#167",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_float_frame()",
        "snippet": "def mixed_float_frame():\n    \"\"\"\n    Fixture for DataFrame of different float types with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D'].\n\n                       A         B         C         D\n    GI7bbDaEZe -0.237908 -0.246225 -0.468506  0.752993\n    KGp9mFepzA -1.140809 -0.644046 -1.225586  0.801588\n    VeVYLAb1l2 -1.154013 -1.677615  0.690430 -0.003731\n    kmPME4WKhO  0.979578  0.998274 -0.776367  0.897607\n    CPyopdXTiz  0.048119 -0.257174  0.836426  0.111266\n    0kJZQndAj0  0.274357 -0.281135 -0.344238  0.834541\n    tqdwQsaHG8 -0.979716 -0.519897  0.582031  0.144710\n    ...              ...       ...       ...       ...\n    7FhZTWILQj -2.906357  1.261039 -0.780273 -0.537237\n    4pUDPM4eGq -2.042512 -0.464382 -0.382080  1.132612\n    B8dUgUzwTi -1.506637 -0.364435  1.087891  0.297653\n    hErlVYjVv9  1.477453 -0.495515 -0.713867  1.438427\n    1BKN3o7YLs  0.127535 -0.349812 -0.881836  0.489827\n    9S4Ekn7zga  1.445518 -2.095149  0.031982  0.373204\n    xN1dNn6OV6  1.425017 -0.983995 -0.363281 -0.224502\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    df.A = df.A.astype(\"float32\")\n    df.B = df.B.astype(\"float32\")\n    df.C = df.C.astype(\"float16\")\n    df.D = df.D.astype(\"float64\")\n    return df",
        "begin_line": 167,
        "end_line": 197,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_int_frame#201",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_int_frame()",
        "snippet": "def mixed_int_frame():\n    \"\"\"\n    Fixture for DataFrame of different int types with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D'].\n\n                A  B    C    D\n    mUrCZ67juP  0  1    2    2\n    rw99ACYaKS  0  1    0    0\n    7QsEcpaaVU  0  1    1    1\n    xkrimI2pcE  0  1    0    0\n    dz01SuzoS8  0  1  255  255\n    ccQkqOHX75 -1  1    0    0\n    DN0iXaoDLd  0  1    0    0\n    ...        .. ..  ...  ...\n    Dfb141wAaQ  1  1  254  254\n    IPD8eQOVu5  0  1    0    0\n    CcaKulsCmv  0  1    0    0\n    rIBa8gu7E5  0  1    0    0\n    RP6peZmh5o  0  1    1    1\n    NMb9pipQWQ  0  1    0    0\n    PqgbJEzjib  0  1    3    3\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame({k: v.astype(int) for k, v in tm.getSeriesData().items()})\n    df.A = df.A.astype(\"int32\")\n    df.B = np.ones(len(df.B), dtype=\"uint64\")\n    df.C = df.C.astype(\"uint8\")\n    df.D = df.C.astype(\"int64\")\n    return df",
        "begin_line": 201,
        "end_line": 231,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_type_frame#235",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_type_frame()",
        "snippet": "def mixed_type_frame():\n    \"\"\"\n    Fixture for DataFrame of float/int/string columns with RangeIndex\n    Columns are ['a', 'b', 'c', 'float32', 'int32'].\n    \"\"\"\n    return DataFrame(\n        {\n            \"a\": 1.0,\n            \"b\": 2,\n            \"c\": \"foo\",\n            \"float32\": np.array([1.0] * 10, dtype=\"float32\"),\n            \"int32\": np.array([1] * 10, dtype=\"int32\"),\n        },\n        index=np.arange(10),\n    )",
        "begin_line": 235,
        "end_line": 249,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.timezone_frame#253",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.timezone_frame()",
        "snippet": "def timezone_frame():\n    \"\"\"\n    Fixture for DataFrame of date_range Series with different time zones\n\n    Columns are ['A', 'B', 'C']; some entries are missing\n\n               A                         B                         C\n    0 2013-01-01 2013-01-01 00:00:00-05:00 2013-01-01 00:00:00+01:00\n    1 2013-01-02                       NaT                       NaT\n    2 2013-01-03 2013-01-03 00:00:00-05:00 2013-01-03 00:00:00+01:00\n    \"\"\"\n    df = DataFrame(\n        {\n            \"A\": date_range(\"20130101\", periods=3),\n            \"B\": date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n            \"C\": date_range(\"20130101\", periods=3, tz=\"CET\"),\n        }\n    )\n    df.iloc[1, 1] = NaT\n    df.iloc[1, 2] = NaT\n    return df",
        "begin_line": 253,
        "end_line": 273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.uint64_frame#277",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.uint64_frame()",
        "snippet": "def uint64_frame():\n    \"\"\"\n    Fixture for DataFrame with uint64 values\n\n    Columns are ['A', 'B']\n    \"\"\"\n    return DataFrame(\n        {\"A\": np.arange(3), \"B\": [2 ** 63, 2 ** 63 + 5, 2 ** 63 + 10]}, dtype=np.uint64\n    )",
        "begin_line": 277,
        "end_line": 285,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.simple_frame#289",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.simple_frame()",
        "snippet": "def simple_frame():\n    \"\"\"\n    Fixture for simple 3x3 DataFrame\n\n    Columns are ['one', 'two', 'three'], index is ['a', 'b', 'c'].\n\n       one  two  three\n    a  1.0  2.0    3.0\n    b  4.0  5.0    6.0\n    c  7.0  8.0    9.0\n    \"\"\"\n    arr = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])\n\n    return DataFrame(arr, columns=[\"one\", \"two\", \"three\"], index=[\"a\", \"b\", \"c\"])",
        "begin_line": 289,
        "end_line": 302,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.frame_of_index_cols#306",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.frame_of_index_cols()",
        "snippet": "def frame_of_index_cols():\n    \"\"\"\n    Fixture for DataFrame of columns that can be used for indexing\n\n    Columns are ['A', 'B', 'C', 'D', 'E', ('tuple', 'as', 'label')];\n    'A' & 'B' contain duplicates (but are jointly unique), the rest are unique.\n\n         A      B  C         D         E  (tuple, as, label)\n    0  foo    one  a  0.608477 -0.012500           -1.664297\n    1  foo    two  b -0.633460  0.249614           -0.364411\n    2  foo  three  c  0.615256  2.154968           -0.834666\n    3  bar    one  d  0.234246  1.085675            0.718445\n    4  bar    two  e  0.533841 -0.005702           -3.533912\n    \"\"\"\n    df = DataFrame(\n        {\n            \"A\": [\"foo\", \"foo\", \"foo\", \"bar\", \"bar\"],\n            \"B\": [\"one\", \"two\", \"three\", \"one\", \"two\"],\n            \"C\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n            \"D\": np.random.randn(5),\n            \"E\": np.random.randn(5),\n            (\"tuple\", \"as\", \"label\"): np.random.randn(5),\n        }\n    )\n    return df",
        "begin_line": 306,
        "end_line": 330,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common._check_mixed_float#1",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common",
        "signature": "pandas.tests.frame.common._check_mixed_float(df, dtype=None)",
        "snippet": "def _check_mixed_float(df, dtype=None):\n    # float16 are most likely to be upcasted to float32\n    dtypes = dict(A=\"float32\", B=\"float32\", C=\"float16\", D=\"float64\")\n    if isinstance(dtype, str):\n        dtypes = {k: dtype for k, v in dtypes.items()}\n    elif isinstance(dtype, dict):\n        dtypes.update(dtype)\n    if dtypes.get(\"A\"):\n        assert df.dtypes[\"A\"] == dtypes[\"A\"]\n    if dtypes.get(\"B\"):\n        assert df.dtypes[\"B\"] == dtypes[\"B\"]\n    if dtypes.get(\"C\"):\n        assert df.dtypes[\"C\"] == dtypes[\"C\"]\n    if dtypes.get(\"D\"):\n        assert df.dtypes[\"D\"] == dtypes[\"D\"]",
        "begin_line": 1,
        "end_line": 15,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common._check_mixed_int#18",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common",
        "signature": "pandas.tests.frame.common._check_mixed_int(df, dtype=None)",
        "snippet": "def _check_mixed_int(df, dtype=None):\n    dtypes = dict(A=\"int32\", B=\"uint64\", C=\"uint8\", D=\"int64\")\n    if isinstance(dtype, str):\n        dtypes = {k: dtype for k, v in dtypes.items()}\n    elif isinstance(dtype, dict):\n        dtypes.update(dtype)\n    if dtypes.get(\"A\"):\n        assert df.dtypes[\"A\"] == dtypes[\"A\"]\n    if dtypes.get(\"B\"):\n        assert df.dtypes[\"B\"] == dtypes[\"B\"]\n    if dtypes.get(\"C\"):\n        assert df.dtypes[\"C\"] == dtypes[\"C\"]\n    if dtypes.get(\"D\"):\n        assert df.dtypes[\"D\"] == dtypes[\"D\"]",
        "begin_line": 18,
        "end_line": 31,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.assert_stat_op_calc#30",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics",
        "signature": "pandas.tests.frame.test_analytics.assert_stat_op_calc(opname, alternative, frame, has_skipna=True, check_dtype=True, check_dates=False, check_less_precise=False, skipna_alternative=None)",
        "snippet": "def assert_stat_op_calc(\n    opname,\n    alternative,\n    frame,\n    has_skipna=True,\n    check_dtype=True,\n    check_dates=False,\n    check_less_precise=False,\n    skipna_alternative=None,\n):\n    \"\"\"\n    Check that operator opname works as advertised on frame\n\n    Parameters\n    ----------\n    opname : string\n        Name of the operator to test on frame\n    alternative : function\n        Function that opname is tested against; i.e. \"frame.opname()\" should\n        equal \"alternative(frame)\".\n    frame : DataFrame\n        The object that the tests are executed on\n    has_skipna : bool, default True\n        Whether the method \"opname\" has the kwarg \"skip_na\"\n    check_dtype : bool, default True\n        Whether the dtypes of the result of \"frame.opname()\" and\n        \"alternative(frame)\" should be checked.\n    check_dates : bool, default false\n        Whether opname should be tested on a Datetime Series\n    check_less_precise : bool, default False\n        Whether results should only be compared approximately;\n        passed on to tm.assert_series_equal\n    skipna_alternative : function, default None\n        NaN-safe version of alternative\n    \"\"\"\n\n    f = getattr(frame, opname)\n\n    if check_dates:\n        df = DataFrame({\"b\": date_range(\"1/1/2001\", periods=2)})\n        result = getattr(df, opname)()\n        assert isinstance(result, Series)\n\n        df[\"a\"] = range(len(df))\n        result = getattr(df, opname)()\n        assert isinstance(result, Series)\n        assert len(result)\n\n    if has_skipna:\n\n        def wrapper(x):\n            return alternative(x.values)\n\n        skipna_wrapper = tm._make_skipna_wrapper(alternative, skipna_alternative)\n        result0 = f(axis=0, skipna=False)\n        result1 = f(axis=1, skipna=False)\n        tm.assert_series_equal(\n            result0,\n            frame.apply(wrapper),\n            check_dtype=check_dtype,\n            check_less_precise=check_less_precise,\n        )\n        # HACK: win32\n        tm.assert_series_equal(\n            result1,\n            frame.apply(wrapper, axis=1),\n            check_dtype=False,\n            check_less_precise=check_less_precise,\n        )\n    else:\n        skipna_wrapper = alternative\n\n    result0 = f(axis=0)\n    result1 = f(axis=1)\n    tm.assert_series_equal(\n        result0,\n        frame.apply(skipna_wrapper),\n        check_dtype=check_dtype,\n        check_less_precise=check_less_precise,\n    )\n\n    if opname in [\"sum\", \"prod\"]:\n        expected = frame.apply(skipna_wrapper, axis=1)\n        tm.assert_series_equal(\n            result1, expected, check_dtype=False, check_less_precise=check_less_precise\n        )\n\n    # check dtypes\n    if check_dtype:\n        lcd_dtype = frame.values.dtype\n        assert lcd_dtype == result0.dtype\n        assert lcd_dtype == result1.dtype\n\n    # bad axis\n    with pytest.raises(ValueError, match=\"No axis named 2\"):\n        f(axis=2)\n\n    # all NA case\n    if has_skipna:\n        all_na = frame * np.NaN\n        r0 = getattr(all_na, opname)(axis=0)\n        r1 = getattr(all_na, opname)(axis=1)\n        if opname in [\"sum\", \"prod\"]:\n            unit = 1 if opname == \"prod\" else 0  # result for empty sum/prod\n            expected = pd.Series(unit, index=r0.index, dtype=r0.dtype)\n            tm.assert_series_equal(r0, expected)\n            expected = pd.Series(unit, index=r1.index, dtype=r1.dtype)\n            tm.assert_series_equal(r1, expected)",
        "begin_line": 30,
        "end_line": 137,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.wrapper#80",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics",
        "signature": "pandas.tests.frame.test_analytics.wrapper(x)",
        "snippet": "        def wrapper(x):\n            return alternative(x.values)",
        "begin_line": 80,
        "end_line": 81,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.assert_stat_op_api#140",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics",
        "signature": "pandas.tests.frame.test_analytics.assert_stat_op_api(opname, float_frame, float_string_frame, has_numeric_only=False)",
        "snippet": "def assert_stat_op_api(opname, float_frame, float_string_frame, has_numeric_only=False):\n    \"\"\"\n    Check that API for operator opname works as advertised on frame\n\n    Parameters\n    ----------\n    opname : string\n        Name of the operator to test on frame\n    float_frame : DataFrame\n        DataFrame with columns of type float\n    float_string_frame : DataFrame\n        DataFrame with both float and string columns\n    has_numeric_only : bool, default False\n        Whether the method \"opname\" has the kwarg \"numeric_only\"\n    \"\"\"\n\n    # make sure works on mixed-type frame\n    getattr(float_string_frame, opname)(axis=0)\n    getattr(float_string_frame, opname)(axis=1)\n\n    if has_numeric_only:\n        getattr(float_string_frame, opname)(axis=0, numeric_only=True)\n        getattr(float_string_frame, opname)(axis=1, numeric_only=True)\n        getattr(float_frame, opname)(axis=0, numeric_only=False)\n        getattr(float_frame, opname)(axis=1, numeric_only=False)",
        "begin_line": 140,
        "end_line": 164,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.assert_bool_op_calc#167",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics",
        "signature": "pandas.tests.frame.test_analytics.assert_bool_op_calc(opname, alternative, frame, has_skipna=True)",
        "snippet": "def assert_bool_op_calc(opname, alternative, frame, has_skipna=True):\n    \"\"\"\n    Check that bool operator opname works as advertised on frame\n\n    Parameters\n    ----------\n    opname : string\n        Name of the operator to test on frame\n    alternative : function\n        Function that opname is tested against; i.e. \"frame.opname()\" should\n        equal \"alternative(frame)\".\n    frame : DataFrame\n        The object that the tests are executed on\n    has_skipna : bool, default True\n        Whether the method \"opname\" has the kwarg \"skip_na\"\n    \"\"\"\n\n    f = getattr(frame, opname)\n\n    if has_skipna:\n\n        def skipna_wrapper(x):\n            nona = x.dropna().values\n            return alternative(nona)\n\n        def wrapper(x):\n            return alternative(x.values)\n\n        result0 = f(axis=0, skipna=False)\n        result1 = f(axis=1, skipna=False)\n\n        tm.assert_series_equal(result0, frame.apply(wrapper))\n        tm.assert_series_equal(\n            result1, frame.apply(wrapper, axis=1), check_dtype=False\n        )  # HACK: win32\n    else:\n        skipna_wrapper = alternative\n        wrapper = alternative\n\n    result0 = f(axis=0)\n    result1 = f(axis=1)\n\n    tm.assert_series_equal(result0, frame.apply(skipna_wrapper))\n    tm.assert_series_equal(\n        result1, frame.apply(skipna_wrapper, axis=1), check_dtype=False\n    )\n\n    # bad axis\n    with pytest.raises(ValueError, match=\"No axis named 2\"):\n        f(axis=2)\n\n    # all NA case\n    if has_skipna:\n        all_na = frame * np.NaN\n        r0 = getattr(all_na, opname)(axis=0)\n        r1 = getattr(all_na, opname)(axis=1)\n        if opname == \"any\":\n            assert not r0.any()\n            assert not r1.any()\n        else:\n            assert r0.all()\n            assert r1.all()",
        "begin_line": 167,
        "end_line": 228,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.skipna_wrapper#188",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics",
        "signature": "pandas.tests.frame.test_analytics.skipna_wrapper(x)",
        "snippet": "        def skipna_wrapper(x):\n            nona = x.dropna().values\n            return alternative(nona)",
        "begin_line": 188,
        "end_line": 190,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.wrapper#192",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics",
        "signature": "pandas.tests.frame.test_analytics.wrapper(x)",
        "snippet": "        def wrapper(x):\n            return alternative(x.values)",
        "begin_line": 192,
        "end_line": 193,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.assert_bool_op_api#231",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics",
        "signature": "pandas.tests.frame.test_analytics.assert_bool_op_api(opname, bool_frame_with_na, float_string_frame, has_bool_only=False)",
        "snippet": "def assert_bool_op_api(\n    opname, bool_frame_with_na, float_string_frame, has_bool_only=False\n):\n    \"\"\"\n    Check that API for boolean operator opname works as advertised on frame\n\n    Parameters\n    ----------\n    opname : string\n        Name of the operator to test on frame\n    float_frame : DataFrame\n        DataFrame with columns of type float\n    float_string_frame : DataFrame\n        DataFrame with both float and string columns\n    has_bool_only : bool, default False\n        Whether the method \"opname\" has the kwarg \"bool_only\"\n    \"\"\"\n    # make sure op works on mixed-type frame\n    mixed = float_string_frame\n    mixed[\"_bool_\"] = np.random.randn(len(mixed)) > 0.5\n    getattr(mixed, opname)(axis=0)\n    getattr(mixed, opname)(axis=1)\n\n    if has_bool_only:\n        getattr(mixed, opname)(axis=0, bool_only=True)\n        getattr(mixed, opname)(axis=1, bool_only=True)\n        getattr(bool_frame_with_na, opname)(axis=0, bool_only=False)\n        getattr(bool_frame_with_na, opname)(axis=1, bool_only=False)",
        "begin_line": 231,
        "end_line": 258,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_pearson#267",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_pearson(self, float_frame)",
        "snippet": "    def test_corr_pearson(self, float_frame):\n        float_frame[\"A\"][:5] = np.nan\n        float_frame[\"B\"][5:10] = np.nan\n\n        self._check_method(float_frame, \"pearson\")",
        "begin_line": 267,
        "end_line": 271,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_kendall#274",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_kendall(self, float_frame)",
        "snippet": "    def test_corr_kendall(self, float_frame):\n        float_frame[\"A\"][:5] = np.nan\n        float_frame[\"B\"][5:10] = np.nan\n\n        self._check_method(float_frame, \"kendall\")",
        "begin_line": 274,
        "end_line": 278,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_spearman#281",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_spearman(self, float_frame)",
        "snippet": "    def test_corr_spearman(self, float_frame):\n        float_frame[\"A\"][:5] = np.nan\n        float_frame[\"B\"][5:10] = np.nan\n\n        self._check_method(float_frame, \"spearman\")",
        "begin_line": 281,
        "end_line": 285,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics._check_method#287",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics._check_method(self, frame, method='pearson')",
        "snippet": "    def _check_method(self, frame, method=\"pearson\"):\n        correls = frame.corr(method=method)\n        expected = frame[\"A\"].corr(frame[\"C\"], method=method)\n        tm.assert_almost_equal(correls[\"A\"][\"C\"], expected)",
        "begin_line": 287,
        "end_line": 290,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_non_numeric#293",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_non_numeric(self, float_frame, float_string_frame)",
        "snippet": "    def test_corr_non_numeric(self, float_frame, float_string_frame):\n        float_frame[\"A\"][:5] = np.nan\n        float_frame[\"B\"][5:10] = np.nan\n\n        # exclude non-numeric types\n        result = float_string_frame.corr()\n        expected = float_string_frame.loc[:, [\"A\", \"B\", \"C\", \"D\"]].corr()\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 293,
        "end_line": 300,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_nooverlap#304",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_nooverlap(self, meth)",
        "snippet": "    def test_corr_nooverlap(self, meth):\n        # nothing in common\n        df = DataFrame(\n            {\n                \"A\": [1, 1.5, 1, np.nan, np.nan, np.nan],\n                \"B\": [np.nan, np.nan, np.nan, 1, 1.5, 1],\n                \"C\": [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],\n            }\n        )\n        rs = df.corr(meth)\n        assert isna(rs.loc[\"A\", \"B\"])\n        assert isna(rs.loc[\"B\", \"A\"])\n        assert rs.loc[\"A\", \"A\"] == 1\n        assert rs.loc[\"B\", \"B\"] == 1\n        assert isna(rs.loc[\"C\", \"C\"])",
        "begin_line": 304,
        "end_line": 318,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_constant#322",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_constant(self, meth)",
        "snippet": "    def test_corr_constant(self, meth):\n        # constant --> all NA\n\n        df = DataFrame(\n            {\n                \"A\": [1, 1, 1, np.nan, np.nan, np.nan],\n                \"B\": [np.nan, np.nan, np.nan, 1, 1, 1],\n            }\n        )\n        rs = df.corr(meth)\n        assert isna(rs.values).all()",
        "begin_line": 322,
        "end_line": 332,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_int#334",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_int(self)",
        "snippet": "    def test_corr_int(self):\n        # dtypes other than float64 #1761\n        df3 = DataFrame({\"a\": [1, 2, 3, 4], \"b\": [1, 2, 3, 4]})\n\n        df3.cov()\n        df3.corr()",
        "begin_line": 334,
        "end_line": 339,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_int_and_boolean#342",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_int_and_boolean(self)",
        "snippet": "    def test_corr_int_and_boolean(self):\n        # when dtypes of pandas series are different\n        # then ndarray will have dtype=object,\n        # so it need to be properly handled\n        df = DataFrame({\"a\": [True, False], \"b\": [1, 0]})\n\n        expected = DataFrame(np.ones((2, 2)), index=[\"a\", \"b\"], columns=[\"a\", \"b\"])\n        for meth in [\"pearson\", \"kendall\", \"spearman\"]:\n\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"ignore\", RuntimeWarning)\n                result = df.corr(meth)\n            tm.assert_frame_equal(result, expected)",
        "begin_line": 342,
        "end_line": 354,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_cov_independent_index_column#356",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_cov_independent_index_column(self)",
        "snippet": "    def test_corr_cov_independent_index_column(self):\n        # GH 14617\n        df = pd.DataFrame(np.random.randn(4 * 10).reshape(10, 4), columns=list(\"abcd\"))\n        for method in [\"cov\", \"corr\"]:\n            result = getattr(df, method)()\n            assert result.index is not result.columns\n            assert result.index.equals(result.columns)",
        "begin_line": 356,
        "end_line": 362,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_invalid_method#364",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corr_invalid_method(self)",
        "snippet": "    def test_corr_invalid_method(self):\n        # GH 22298\n        df = pd.DataFrame(np.random.normal(size=(10, 2)))\n        msg = \"method must be either 'pearson', 'spearman', 'kendall', or a callable, \"\n        with pytest.raises(ValueError, match=msg):\n            df.corr(method=\"____\")",
        "begin_line": 364,
        "end_line": 369,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_cov#371",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_cov(self, float_frame, float_string_frame)",
        "snippet": "    def test_cov(self, float_frame, float_string_frame):\n        # min_periods no NAs (corner case)\n        expected = float_frame.cov()\n        result = float_frame.cov(min_periods=len(float_frame))\n\n        tm.assert_frame_equal(expected, result)\n\n        result = float_frame.cov(min_periods=len(float_frame) + 1)\n        assert isna(result.values).all()\n\n        # with NAs\n        frame = float_frame.copy()\n        frame[\"A\"][:5] = np.nan\n        frame[\"B\"][5:10] = np.nan\n        result = float_frame.cov(min_periods=len(float_frame) - 8)\n        expected = float_frame.cov()\n        expected.loc[\"A\", \"B\"] = np.nan\n        expected.loc[\"B\", \"A\"] = np.nan\n\n        # regular\n        float_frame[\"A\"][:5] = np.nan\n        float_frame[\"B\"][:10] = np.nan\n        cov = float_frame.cov()\n\n        tm.assert_almost_equal(cov[\"A\"][\"C\"], float_frame[\"A\"].cov(float_frame[\"C\"]))\n\n        # exclude non-numeric types\n        result = float_string_frame.cov()\n        expected = float_string_frame.loc[:, [\"A\", \"B\", \"C\", \"D\"]].cov()\n        tm.assert_frame_equal(result, expected)\n\n        # Single column frame\n        df = DataFrame(np.linspace(0.0, 1.0, 10))\n        result = df.cov()\n        expected = DataFrame(\n            np.cov(df.values.T).reshape((1, 1)), index=df.columns, columns=df.columns\n        )\n        tm.assert_frame_equal(result, expected)\n        df.loc[0] = np.nan\n        result = df.cov()\n        expected = DataFrame(\n            np.cov(df.values[1:].T).reshape((1, 1)),\n            index=df.columns,\n            columns=df.columns,\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 371,
        "end_line": 416,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith#418",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith(self, datetime_frame)",
        "snippet": "    def test_corrwith(self, datetime_frame):\n        a = datetime_frame\n        noise = Series(np.random.randn(len(a)), index=a.index)\n\n        b = datetime_frame.add(noise, axis=0)\n\n        # make sure order does not matter\n        b = b.reindex(columns=b.columns[::-1], index=b.index[::-1][10:])\n        del b[\"B\"]\n\n        colcorr = a.corrwith(b, axis=0)\n        tm.assert_almost_equal(colcorr[\"A\"], a[\"A\"].corr(b[\"A\"]))\n\n        rowcorr = a.corrwith(b, axis=1)\n        tm.assert_series_equal(rowcorr, a.T.corrwith(b.T, axis=0))\n\n        dropped = a.corrwith(b, axis=0, drop=True)\n        tm.assert_almost_equal(dropped[\"A\"], a[\"A\"].corr(b[\"A\"]))\n        assert \"B\" not in dropped\n\n        dropped = a.corrwith(b, axis=1, drop=True)\n        assert a.index[-1] not in dropped.index\n\n        # non time-series data\n        index = [\"a\", \"b\", \"c\", \"d\", \"e\"]\n        columns = [\"one\", \"two\", \"three\", \"four\"]\n        df1 = DataFrame(np.random.randn(5, 4), index=index, columns=columns)\n        df2 = DataFrame(np.random.randn(4, 4), index=index[:4], columns=columns)\n        correls = df1.corrwith(df2, axis=1)\n        for row in index[:4]:\n            tm.assert_almost_equal(correls[row], df1.loc[row].corr(df2.loc[row]))",
        "begin_line": 418,
        "end_line": 448,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith_with_objects#450",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith_with_objects(self)",
        "snippet": "    def test_corrwith_with_objects(self):\n        df1 = tm.makeTimeDataFrame()\n        df2 = tm.makeTimeDataFrame()\n        cols = [\"A\", \"B\", \"C\", \"D\"]\n\n        df1[\"obj\"] = \"foo\"\n        df2[\"obj\"] = \"bar\"\n\n        result = df1.corrwith(df2)\n        expected = df1.loc[:, cols].corrwith(df2.loc[:, cols])\n        tm.assert_series_equal(result, expected)\n\n        result = df1.corrwith(df2, axis=1)\n        expected = df1.loc[:, cols].corrwith(df2.loc[:, cols], axis=1)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 450,
        "end_line": 464,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith_series#466",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith_series(self, datetime_frame)",
        "snippet": "    def test_corrwith_series(self, datetime_frame):\n        result = datetime_frame.corrwith(datetime_frame[\"A\"])\n        expected = datetime_frame.apply(datetime_frame[\"A\"].corr)\n\n        tm.assert_series_equal(result, expected)",
        "begin_line": 466,
        "end_line": 470,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith_matches_corrcoef#472",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith_matches_corrcoef(self)",
        "snippet": "    def test_corrwith_matches_corrcoef(self):\n        df1 = DataFrame(np.arange(10000), columns=[\"a\"])\n        df2 = DataFrame(np.arange(10000) ** 2, columns=[\"a\"])\n        c1 = df1.corrwith(df2)[\"a\"]\n        c2 = np.corrcoef(df1[\"a\"], df2[\"a\"])[0][1]\n\n        tm.assert_almost_equal(c1, c2)\n        assert c1 < 1",
        "begin_line": 472,
        "end_line": 479,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith_mixed_dtypes#481",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith_mixed_dtypes(self)",
        "snippet": "    def test_corrwith_mixed_dtypes(self):\n        # GH 18570\n        df = pd.DataFrame(\n            {\"a\": [1, 4, 3, 2], \"b\": [4, 6, 7, 3], \"c\": [\"a\", \"b\", \"c\", \"d\"]}\n        )\n        s = pd.Series([0, 6, 7, 3])\n        result = df.corrwith(s)\n        corrs = [df[\"a\"].corr(s), df[\"b\"].corr(s)]\n        expected = pd.Series(data=corrs, index=[\"a\", \"b\"])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 481,
        "end_line": 490,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith_index_intersection#492",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith_index_intersection(self)",
        "snippet": "    def test_corrwith_index_intersection(self):\n        df1 = pd.DataFrame(np.random.random(size=(10, 2)), columns=[\"a\", \"b\"])\n        df2 = pd.DataFrame(np.random.random(size=(10, 3)), columns=[\"a\", \"b\", \"c\"])\n\n        result = df1.corrwith(df2, drop=True).index.sort_values()\n        expected = df1.columns.intersection(df2.columns).sort_values()\n        tm.assert_index_equal(result, expected)",
        "begin_line": 492,
        "end_line": 498,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith_index_union#500",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith_index_union(self)",
        "snippet": "    def test_corrwith_index_union(self):\n        df1 = pd.DataFrame(np.random.random(size=(10, 2)), columns=[\"a\", \"b\"])\n        df2 = pd.DataFrame(np.random.random(size=(10, 3)), columns=[\"a\", \"b\", \"c\"])\n\n        result = df1.corrwith(df2, drop=False).index.sort_values()\n        expected = df1.columns.union(df2.columns).sort_values()\n        tm.assert_index_equal(result, expected)",
        "begin_line": 500,
        "end_line": 506,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith_dup_cols#508",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith_dup_cols(self)",
        "snippet": "    def test_corrwith_dup_cols(self):\n        # GH 21925\n        df1 = pd.DataFrame(np.vstack([np.arange(10)] * 3).T)\n        df2 = df1.copy()\n        df2 = pd.concat((df2, df2[0]), axis=1)\n\n        result = df1.corrwith(df2)\n        expected = pd.Series(np.ones(4), index=[0, 0, 1, 2])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 508,
        "end_line": 516,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith_spearman#519",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith_spearman(self)",
        "snippet": "    def test_corrwith_spearman(self):\n        # GH 21925\n        df = pd.DataFrame(np.random.random(size=(100, 3)))\n        result = df.corrwith(df ** 2, method=\"spearman\")\n        expected = Series(np.ones(len(result)))\n        tm.assert_series_equal(result, expected)",
        "begin_line": 519,
        "end_line": 524,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith_kendall#527",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_corrwith_kendall(self)",
        "snippet": "    def test_corrwith_kendall(self):\n        # GH 21925\n        df = pd.DataFrame(np.random.random(size=(100, 3)))\n        result = df.corrwith(df ** 2, method=\"kendall\")\n        expected = Series(np.ones(len(result)))\n        tm.assert_series_equal(result, expected)",
        "begin_line": 527,
        "end_line": 532,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_bool_describe_in_mixed_frame#537",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_bool_describe_in_mixed_frame(self)",
        "snippet": "    def test_bool_describe_in_mixed_frame(self):\n        df = DataFrame(\n            {\n                \"string_data\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n                \"bool_data\": [True, True, False, False, False],\n                \"int_data\": [10, 20, 30, 40, 50],\n            }\n        )\n\n        # Integer data are included in .describe() output,\n        # Boolean and string data are not.\n        result = df.describe()\n        expected = DataFrame(\n            {\"int_data\": [5, 30, df.int_data.std(), 10, 20, 30, 40, 50]},\n            index=[\"count\", \"mean\", \"std\", \"min\", \"25%\", \"50%\", \"75%\", \"max\"],\n        )\n        tm.assert_frame_equal(result, expected)\n\n        # Top value is a boolean value that is False\n        result = df.describe(include=[\"bool\"])\n\n        expected = DataFrame(\n            {\"bool_data\": [5, 2, False, 3]}, index=[\"count\", \"unique\", \"top\", \"freq\"]\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 537,
        "end_line": 561,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_describe_empty_object#563",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_describe_empty_object(self)",
        "snippet": "    def test_describe_empty_object(self):\n        # https://github.com/pandas-dev/pandas/issues/27183\n        df = pd.DataFrame({\"A\": [None, None]}, dtype=object)\n        result = df.describe()\n        expected = pd.DataFrame(\n            {\"A\": [0, 0, np.nan, np.nan]},\n            dtype=object,\n            index=[\"count\", \"unique\", \"top\", \"freq\"],\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[:0].describe()\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 563,
        "end_line": 575,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_describe_bool_frame#577",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_describe_bool_frame(self)",
        "snippet": "    def test_describe_bool_frame(self):\n        # GH 13891\n        df = pd.DataFrame(\n            {\n                \"bool_data_1\": [False, False, True, True],\n                \"bool_data_2\": [False, True, True, True],\n            }\n        )\n        result = df.describe()\n        expected = DataFrame(\n            {\"bool_data_1\": [4, 2, True, 2], \"bool_data_2\": [4, 2, True, 3]},\n            index=[\"count\", \"unique\", \"top\", \"freq\"],\n        )\n        tm.assert_frame_equal(result, expected)\n\n        df = pd.DataFrame(\n            {\n                \"bool_data\": [False, False, True, True, False],\n                \"int_data\": [0, 1, 2, 3, 4],\n            }\n        )\n        result = df.describe()\n        expected = DataFrame(\n            {\"int_data\": [5, 2, df.int_data.std(), 0, 1, 2, 3, 4]},\n            index=[\"count\", \"mean\", \"std\", \"min\", \"25%\", \"50%\", \"75%\", \"max\"],\n        )\n        tm.assert_frame_equal(result, expected)\n\n        df = pd.DataFrame(\n            {\"bool_data\": [False, False, True, True], \"str_data\": [\"a\", \"b\", \"c\", \"a\"]}\n        )\n        result = df.describe()\n        expected = DataFrame(\n            {\"bool_data\": [4, 2, True, 2], \"str_data\": [4, 3, \"a\", 2]},\n            index=[\"count\", \"unique\", \"top\", \"freq\"],\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 577,
        "end_line": 613,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_describe_categorical#615",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_describe_categorical(self)",
        "snippet": "    def test_describe_categorical(self):\n        df = DataFrame({\"value\": np.random.randint(0, 10000, 100)})\n        labels = [\"{0} - {1}\".format(i, i + 499) for i in range(0, 10000, 500)]\n        cat_labels = Categorical(labels, labels)\n\n        df = df.sort_values(by=[\"value\"], ascending=True)\n        df[\"value_group\"] = pd.cut(\n            df.value, range(0, 10500, 500), right=False, labels=cat_labels\n        )\n        cat = df\n\n        # Categoricals should not show up together with numerical columns\n        result = cat.describe()\n        assert len(result.columns) == 1\n\n        # In a frame, describe() for the cat should be the same as for string\n        # arrays (count, unique, top, freq)\n\n        cat = Categorical(\n            [\"a\", \"b\", \"b\", \"b\"], categories=[\"a\", \"b\", \"c\"], ordered=True\n        )\n        s = Series(cat)\n        result = s.describe()\n        expected = Series([4, 2, \"b\", 3], index=[\"count\", \"unique\", \"top\", \"freq\"])\n        tm.assert_series_equal(result, expected)\n\n        cat = Series(Categorical([\"a\", \"b\", \"c\", \"c\"]))\n        df3 = DataFrame({\"cat\": cat, \"s\": [\"a\", \"b\", \"c\", \"c\"]})\n        result = df3.describe()\n        tm.assert_numpy_array_equal(result[\"cat\"].values, result[\"s\"].values)",
        "begin_line": 615,
        "end_line": 644,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_describe_empty_categorical_column#646",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_describe_empty_categorical_column(self)",
        "snippet": "    def test_describe_empty_categorical_column(self):\n        # GH 26397\n        # Ensure the index of an an empty categorical DataFrame column\n        # also contains (count, unique, top, freq)\n        df = pd.DataFrame({\"empty_col\": Categorical([])})\n        result = df.describe()\n        expected = DataFrame(\n            {\"empty_col\": [0, 0, np.nan, np.nan]},\n            index=[\"count\", \"unique\", \"top\", \"freq\"],\n            dtype=\"object\",\n        )\n        tm.assert_frame_equal(result, expected)\n        # ensure NaN, not None\n        assert np.isnan(result.iloc[2, 0])\n        assert np.isnan(result.iloc[3, 0])",
        "begin_line": 646,
        "end_line": 660,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_describe_categorical_columns#662",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_describe_categorical_columns(self)",
        "snippet": "    def test_describe_categorical_columns(self):\n        # GH 11558\n        columns = pd.CategoricalIndex([\"int1\", \"int2\", \"obj\"], ordered=True, name=\"XXX\")\n        df = DataFrame(\n            {\n                \"int1\": [10, 20, 30, 40, 50],\n                \"int2\": [10, 20, 30, 40, 50],\n                \"obj\": [\"A\", 0, None, \"X\", 1],\n            },\n            columns=columns,\n        )\n        result = df.describe()\n\n        exp_columns = pd.CategoricalIndex(\n            [\"int1\", \"int2\"],\n            categories=[\"int1\", \"int2\", \"obj\"],\n            ordered=True,\n            name=\"XXX\",\n        )\n        expected = DataFrame(\n            {\n                \"int1\": [5, 30, df.int1.std(), 10, 20, 30, 40, 50],\n                \"int2\": [5, 30, df.int2.std(), 10, 20, 30, 40, 50],\n            },\n            index=[\"count\", \"mean\", \"std\", \"min\", \"25%\", \"50%\", \"75%\", \"max\"],\n            columns=exp_columns,\n        )\n\n        tm.assert_frame_equal(result, expected)\n        tm.assert_categorical_equal(result.columns.values, expected.columns.values)",
        "begin_line": 662,
        "end_line": 691,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_describe_datetime_columns#693",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_describe_datetime_columns(self)",
        "snippet": "    def test_describe_datetime_columns(self):\n        columns = pd.DatetimeIndex(\n            [\"2011-01-01\", \"2011-02-01\", \"2011-03-01\"],\n            freq=\"MS\",\n            tz=\"US/Eastern\",\n            name=\"XXX\",\n        )\n        df = DataFrame(\n            {\n                0: [10, 20, 30, 40, 50],\n                1: [10, 20, 30, 40, 50],\n                2: [\"A\", 0, None, \"X\", 1],\n            }\n        )\n        df.columns = columns\n        result = df.describe()\n\n        exp_columns = pd.DatetimeIndex(\n            [\"2011-01-01\", \"2011-02-01\"], freq=\"MS\", tz=\"US/Eastern\", name=\"XXX\"\n        )\n        expected = DataFrame(\n            {\n                0: [5, 30, df.iloc[:, 0].std(), 10, 20, 30, 40, 50],\n                1: [5, 30, df.iloc[:, 1].std(), 10, 20, 30, 40, 50],\n            },\n            index=[\"count\", \"mean\", \"std\", \"min\", \"25%\", \"50%\", \"75%\", \"max\"],\n        )\n        expected.columns = exp_columns\n        tm.assert_frame_equal(result, expected)\n        assert result.columns.freq == \"MS\"\n        assert result.columns.tz == expected.columns.tz",
        "begin_line": 693,
        "end_line": 723,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_describe_timedelta_values#725",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_describe_timedelta_values(self)",
        "snippet": "    def test_describe_timedelta_values(self):\n        # GH 6145\n        t1 = pd.timedelta_range(\"1 days\", freq=\"D\", periods=5)\n        t2 = pd.timedelta_range(\"1 hours\", freq=\"H\", periods=5)\n        df = pd.DataFrame({\"t1\": t1, \"t2\": t2})\n\n        expected = DataFrame(\n            {\n                \"t1\": [\n                    5,\n                    pd.Timedelta(\"3 days\"),\n                    df.iloc[:, 0].std(),\n                    pd.Timedelta(\"1 days\"),\n                    pd.Timedelta(\"2 days\"),\n                    pd.Timedelta(\"3 days\"),\n                    pd.Timedelta(\"4 days\"),\n                    pd.Timedelta(\"5 days\"),\n                ],\n                \"t2\": [\n                    5,\n                    pd.Timedelta(\"3 hours\"),\n                    df.iloc[:, 1].std(),\n                    pd.Timedelta(\"1 hours\"),\n                    pd.Timedelta(\"2 hours\"),\n                    pd.Timedelta(\"3 hours\"),\n                    pd.Timedelta(\"4 hours\"),\n                    pd.Timedelta(\"5 hours\"),\n                ],\n            },\n            index=[\"count\", \"mean\", \"std\", \"min\", \"25%\", \"50%\", \"75%\", \"max\"],\n        )\n\n        result = df.describe()\n        tm.assert_frame_equal(result, expected)\n\n        exp_repr = (\n            \"                           t1                      t2\\n\"\n            \"count                       5                       5\\n\"\n            \"mean          3 days 00:00:00         0 days 03:00:00\\n\"\n            \"std    1 days 13:56:50.394919  0 days 01:34:52.099788\\n\"\n            \"min           1 days 00:00:00         0 days 01:00:00\\n\"\n            \"25%           2 days 00:00:00         0 days 02:00:00\\n\"\n            \"50%           3 days 00:00:00         0 days 03:00:00\\n\"\n            \"75%           4 days 00:00:00         0 days 04:00:00\\n\"\n            \"max           5 days 00:00:00         0 days 05:00:00\"\n        )\n        assert repr(result) == exp_repr",
        "begin_line": 725,
        "end_line": 771,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_describe_tz_values#773",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_describe_tz_values(self, tz_naive_fixture)",
        "snippet": "    def test_describe_tz_values(self, tz_naive_fixture):\n        # GH 21332\n        tz = tz_naive_fixture\n        s1 = Series(range(5))\n        start = Timestamp(2018, 1, 1)\n        end = Timestamp(2018, 1, 5)\n        s2 = Series(date_range(start, end, tz=tz))\n        df = pd.DataFrame({\"s1\": s1, \"s2\": s2})\n\n        expected = DataFrame(\n            {\n                \"s1\": [\n                    5,\n                    np.nan,\n                    np.nan,\n                    np.nan,\n                    np.nan,\n                    np.nan,\n                    2,\n                    1.581139,\n                    0,\n                    1,\n                    2,\n                    3,\n                    4,\n                ],\n                \"s2\": [\n                    5,\n                    5,\n                    s2.value_counts().index[0],\n                    1,\n                    start.tz_localize(tz),\n                    end.tz_localize(tz),\n                    np.nan,\n                    np.nan,\n                    np.nan,\n                    np.nan,\n                    np.nan,\n                    np.nan,\n                    np.nan,\n                ],\n            },\n            index=[\n                \"count\",\n                \"unique\",\n                \"top\",\n                \"freq\",\n                \"first\",\n                \"last\",\n                \"mean\",\n                \"std\",\n                \"min\",\n                \"25%\",\n                \"50%\",\n                \"75%\",\n                \"max\",\n            ],\n        )\n        result = df.describe(include=\"all\")\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 773,
        "end_line": 832,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_describe_percentiles_integer_idx#834",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_describe_percentiles_integer_idx(self)",
        "snippet": "    def test_describe_percentiles_integer_idx(self):\n        # Issue 26660\n        df = pd.DataFrame({\"x\": [1]})\n        pct = np.linspace(0, 1, 10 + 1)\n        result = df.describe(percentiles=pct)\n\n        expected = DataFrame(\n            {\"x\": [1.0, 1.0, np.NaN, 1.0, *[1.0 for _ in pct], 1.0]},\n            index=[\n                \"count\",\n                \"mean\",\n                \"std\",\n                \"min\",\n                \"0%\",\n                \"10%\",\n                \"20%\",\n                \"30%\",\n                \"40%\",\n                \"50%\",\n                \"60%\",\n                \"70%\",\n                \"80%\",\n                \"90%\",\n                \"100%\",\n                \"max\",\n            ],\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 834,
        "end_line": 861,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_stat_op_api#866",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_stat_op_api(self, float_frame, float_string_frame)",
        "snippet": "    def test_stat_op_api(self, float_frame, float_string_frame):\n        assert_stat_op_api(\n            \"count\", float_frame, float_string_frame, has_numeric_only=True\n        )\n        assert_stat_op_api(\n            \"sum\", float_frame, float_string_frame, has_numeric_only=True\n        )\n\n        assert_stat_op_api(\"nunique\", float_frame, float_string_frame)\n        assert_stat_op_api(\"mean\", float_frame, float_string_frame)\n        assert_stat_op_api(\"product\", float_frame, float_string_frame)\n        assert_stat_op_api(\"median\", float_frame, float_string_frame)\n        assert_stat_op_api(\"min\", float_frame, float_string_frame)\n        assert_stat_op_api(\"max\", float_frame, float_string_frame)\n        assert_stat_op_api(\"mad\", float_frame, float_string_frame)\n        assert_stat_op_api(\"var\", float_frame, float_string_frame)\n        assert_stat_op_api(\"std\", float_frame, float_string_frame)\n        assert_stat_op_api(\"sem\", float_frame, float_string_frame)\n        assert_stat_op_api(\"median\", float_frame, float_string_frame)\n\n        try:\n            from scipy.stats import skew, kurtosis  # noqa:F401\n\n            assert_stat_op_api(\"skew\", float_frame, float_string_frame)\n            assert_stat_op_api(\"kurt\", float_frame, float_string_frame)\n        except ImportError:\n            pass",
        "begin_line": 866,
        "end_line": 892,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_stat_op_calc#894",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_stat_op_calc(self, float_frame_with_na, mixed_float_frame)",
        "snippet": "    def test_stat_op_calc(self, float_frame_with_na, mixed_float_frame):\n        def count(s):\n            return notna(s).sum()\n\n        def nunique(s):\n            return len(algorithms.unique1d(s.dropna()))\n\n        def mad(x):\n            return np.abs(x - x.mean()).mean()\n\n        def var(x):\n            return np.var(x, ddof=1)\n\n        def std(x):\n            return np.std(x, ddof=1)\n\n        def sem(x):\n            return np.std(x, ddof=1) / np.sqrt(len(x))\n\n        def skewness(x):\n            from scipy.stats import skew  # noqa:F811\n\n            if len(x) < 3:\n                return np.nan\n            return skew(x, bias=False)\n\n        def kurt(x):\n            from scipy.stats import kurtosis  # noqa:F811\n\n            if len(x) < 4:\n                return np.nan\n            return kurtosis(x, bias=False)\n\n        assert_stat_op_calc(\n            \"nunique\",\n            nunique,\n            float_frame_with_na,\n            has_skipna=False,\n            check_dtype=False,\n            check_dates=True,\n        )\n\n        # mixed types (with upcasting happening)\n        assert_stat_op_calc(\n            \"sum\",\n            np.sum,\n            mixed_float_frame.astype(\"float32\"),\n            check_dtype=False,\n            check_less_precise=True,\n        )\n\n        assert_stat_op_calc(\n            \"sum\", np.sum, float_frame_with_na, skipna_alternative=np.nansum\n        )\n        assert_stat_op_calc(\"mean\", np.mean, float_frame_with_na, check_dates=True)\n        assert_stat_op_calc(\"product\", np.prod, float_frame_with_na)\n\n        assert_stat_op_calc(\"mad\", mad, float_frame_with_na)\n        assert_stat_op_calc(\"var\", var, float_frame_with_na)\n        assert_stat_op_calc(\"std\", std, float_frame_with_na)\n        assert_stat_op_calc(\"sem\", sem, float_frame_with_na)\n\n        assert_stat_op_calc(\n            \"count\",\n            count,\n            float_frame_with_na,\n            has_skipna=False,\n            check_dtype=False,\n            check_dates=True,\n        )\n\n        try:\n            from scipy import skew, kurtosis  # noqa:F401\n\n            assert_stat_op_calc(\"skew\", skewness, float_frame_with_na)\n            assert_stat_op_calc(\"kurt\", kurt, float_frame_with_na)\n        except ImportError:\n            pass",
        "begin_line": 894,
        "end_line": 971,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.count#895",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.count(s)",
        "snippet": "        def count(s):\n            return notna(s).sum()",
        "begin_line": 895,
        "end_line": 896,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.nunique#898",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.nunique(s)",
        "snippet": "        def nunique(s):\n            return len(algorithms.unique1d(s.dropna()))",
        "begin_line": 898,
        "end_line": 899,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.mad#901",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.mad(x)",
        "snippet": "        def mad(x):\n            return np.abs(x - x.mean()).mean()",
        "begin_line": 901,
        "end_line": 902,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.var#904",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.var(x)",
        "snippet": "        def var(x):\n            return np.var(x, ddof=1)",
        "begin_line": 904,
        "end_line": 905,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.std#907",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.std(x)",
        "snippet": "        def std(x):\n            return np.std(x, ddof=1)",
        "begin_line": 907,
        "end_line": 908,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.sem#910",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.sem(x)",
        "snippet": "        def sem(x):\n            return np.std(x, ddof=1) / np.sqrt(len(x))",
        "begin_line": 910,
        "end_line": 911,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.skewness#913",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.skewness(x)",
        "snippet": "        def skewness(x):\n            from scipy.stats import skew  # noqa:F811\n\n            if len(x) < 3:\n                return np.nan\n            return skew(x, bias=False)",
        "begin_line": 913,
        "end_line": 918,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.kurt#920",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.kurt(x)",
        "snippet": "        def kurt(x):\n            from scipy.stats import kurtosis  # noqa:F811\n\n            if len(x) < 4:\n                return np.nan\n            return kurtosis(x, bias=False)",
        "begin_line": 920,
        "end_line": 925,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_median#975",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_median(self, float_frame_with_na, int_frame)",
        "snippet": "    def test_median(self, float_frame_with_na, int_frame):\n        def wrapper(x):\n            if isna(x).any():\n                return np.nan\n            return np.median(x)\n\n        assert_stat_op_calc(\"median\", wrapper, float_frame_with_na, check_dates=True)\n        assert_stat_op_calc(\n            \"median\", wrapper, int_frame, check_dtype=False, check_dates=True\n        )",
        "begin_line": 975,
        "end_line": 984,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.wrapper#976",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.wrapper(x)",
        "snippet": "        def wrapper(x):\n            if isna(x).any():\n                return np.nan\n            return np.median(x)",
        "begin_line": 976,
        "end_line": 979,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_stat_operators_attempt_obj_array#989",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_stat_operators_attempt_obj_array(self, method)",
        "snippet": "    def test_stat_operators_attempt_obj_array(self, method):\n        # GH#676\n        data = {\n            \"a\": [\n                -0.00049987540199591344,\n                -0.0016467257772919831,\n                0.00067695870775883013,\n            ],\n            \"b\": [-0, -0, 0.0],\n            \"c\": [\n                0.00031111847529610595,\n                0.0014902627951905339,\n                -0.00094099200035979691,\n            ],\n        }\n        df1 = DataFrame(data, index=[\"foo\", \"bar\", \"baz\"], dtype=\"O\")\n\n        df2 = DataFrame({0: [np.nan, 2], 1: [np.nan, 3], 2: [np.nan, 4]}, dtype=object)\n\n        for df in [df1, df2]:\n            assert df.values.dtype == np.object_\n            result = getattr(df, method)(1)\n            expected = getattr(df.astype(\"f8\"), method)(1)\n\n            if method in [\"sum\", \"prod\"]:\n                tm.assert_series_equal(result, expected)",
        "begin_line": 989,
        "end_line": 1014,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_mixed_ops#1017",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_mixed_ops(self, op)",
        "snippet": "    def test_mixed_ops(self, op):\n        # GH#16116\n        df = DataFrame(\n            {\n                \"int\": [1, 2, 3, 4],\n                \"float\": [1.0, 2.0, 3.0, 4.0],\n                \"str\": [\"a\", \"b\", \"c\", \"d\"],\n            }\n        )\n\n        result = getattr(df, op)()\n        assert len(result) == 2\n\n        with pd.option_context(\"use_bottleneck\", False):\n            result = getattr(df, op)()\n            assert len(result) == 2",
        "begin_line": 1017,
        "end_line": 1032,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_reduce_mixed_frame#1034",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_reduce_mixed_frame(self)",
        "snippet": "    def test_reduce_mixed_frame(self):\n        # GH 6806\n        df = DataFrame(\n            {\n                \"bool_data\": [True, True, False, False, False],\n                \"int_data\": [10, 20, 30, 40, 50],\n                \"string_data\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n            }\n        )\n        df.reindex(columns=[\"bool_data\", \"int_data\", \"string_data\"])\n        test = df.sum(axis=0)\n        tm.assert_numpy_array_equal(\n            test.values, np.array([2, 150, \"abcde\"], dtype=object)\n        )\n        tm.assert_series_equal(test, df.T.sum(axis=1))",
        "begin_line": 1034,
        "end_line": 1048,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_nunique#1050",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_nunique(self)",
        "snippet": "    def test_nunique(self):\n        df = DataFrame({\"A\": [1, 1, 1], \"B\": [1, 2, 3], \"C\": [1, np.nan, 3]})\n        tm.assert_series_equal(df.nunique(), Series({\"A\": 1, \"B\": 3, \"C\": 2}))\n        tm.assert_series_equal(\n            df.nunique(dropna=False), Series({\"A\": 1, \"B\": 3, \"C\": 3})\n        )\n        tm.assert_series_equal(df.nunique(axis=1), Series({0: 1, 1: 2, 2: 2}))\n        tm.assert_series_equal(\n            df.nunique(axis=1, dropna=False), Series({0: 1, 1: 3, 2: 2})\n        )",
        "begin_line": 1050,
        "end_line": 1059,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_mean_mixed_datetime_numeric#1062",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_mean_mixed_datetime_numeric(self, tz)",
        "snippet": "    def test_mean_mixed_datetime_numeric(self, tz):\n        # https://github.com/pandas-dev/pandas/issues/24752\n        df = pd.DataFrame({\"A\": [1, 1], \"B\": [pd.Timestamp(\"2000\", tz=tz)] * 2})\n        result = df.mean()\n        expected = pd.Series([1.0], index=[\"A\"])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1062,
        "end_line": 1067,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_mean_excludes_datetimes#1070",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_mean_excludes_datetimes(self, tz)",
        "snippet": "    def test_mean_excludes_datetimes(self, tz):\n        # https://github.com/pandas-dev/pandas/issues/24752\n        # Our long-term desired behavior is unclear, but the behavior in\n        # 0.24.0rc1 was buggy.\n        df = pd.DataFrame({\"A\": [pd.Timestamp(\"2000\", tz=tz)] * 2})\n        result = df.mean()\n        expected = pd.Series(dtype=np.float64)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1070,
        "end_line": 1077,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_mean_mixed_string_decimal#1079",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_mean_mixed_string_decimal(self)",
        "snippet": "    def test_mean_mixed_string_decimal(self):\n        # GH 11670\n        # possible bug when calculating mean of DataFrame?\n\n        d = [\n            {\"A\": 2, \"B\": None, \"C\": Decimal(\"628.00\")},\n            {\"A\": 1, \"B\": None, \"C\": Decimal(\"383.00\")},\n            {\"A\": 3, \"B\": None, \"C\": Decimal(\"651.00\")},\n            {\"A\": 2, \"B\": None, \"C\": Decimal(\"575.00\")},\n            {\"A\": 4, \"B\": None, \"C\": Decimal(\"1114.00\")},\n            {\"A\": 1, \"B\": \"TEST\", \"C\": Decimal(\"241.00\")},\n            {\"A\": 2, \"B\": None, \"C\": Decimal(\"572.00\")},\n            {\"A\": 4, \"B\": None, \"C\": Decimal(\"609.00\")},\n            {\"A\": 3, \"B\": None, \"C\": Decimal(\"820.00\")},\n            {\"A\": 5, \"B\": None, \"C\": Decimal(\"1223.00\")},\n        ]\n\n        df = pd.DataFrame(d)\n\n        result = df.mean()\n        expected = pd.Series([2.7, 681.6], index=[\"A\", \"C\"])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1079,
        "end_line": 1100,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_var_std#1102",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_var_std(self, datetime_frame)",
        "snippet": "    def test_var_std(self, datetime_frame):\n        result = datetime_frame.std(ddof=4)\n        expected = datetime_frame.apply(lambda x: x.std(ddof=4))\n        tm.assert_almost_equal(result, expected)\n\n        result = datetime_frame.var(ddof=4)\n        expected = datetime_frame.apply(lambda x: x.var(ddof=4))\n        tm.assert_almost_equal(result, expected)\n\n        arr = np.repeat(np.random.random((1, 1000)), 1000, 0)\n        result = nanops.nanvar(arr, axis=0)\n        assert not (result < 0).any()\n\n        with pd.option_context(\"use_bottleneck\", False):\n            result = nanops.nanvar(arr, axis=0)\n            assert not (result < 0).any()",
        "begin_line": 1102,
        "end_line": 1117,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_numeric_only_flag#1120",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_numeric_only_flag(self, meth)",
        "snippet": "    def test_numeric_only_flag(self, meth):\n        # GH 9201\n        df1 = DataFrame(np.random.randn(5, 3), columns=[\"foo\", \"bar\", \"baz\"])\n        # set one entry to a number in str format\n        df1.loc[0, \"foo\"] = \"100\"\n\n        df2 = DataFrame(np.random.randn(5, 3), columns=[\"foo\", \"bar\", \"baz\"])\n        # set one entry to a non-number str\n        df2.loc[0, \"foo\"] = \"a\"\n\n        result = getattr(df1, meth)(axis=1, numeric_only=True)\n        expected = getattr(df1[[\"bar\", \"baz\"]], meth)(axis=1)\n        tm.assert_series_equal(expected, result)\n\n        result = getattr(df2, meth)(axis=1, numeric_only=True)\n        expected = getattr(df2[[\"bar\", \"baz\"]], meth)(axis=1)\n        tm.assert_series_equal(expected, result)\n\n        # df1 has all numbers, df2 has a letter inside\n        msg = r\"unsupported operand type\\(s\\) for -: 'float' and 'str'\"\n        with pytest.raises(TypeError, match=msg):\n            getattr(df1, meth)(axis=1, numeric_only=False)\n        msg = \"could not convert string to float: 'a'\"\n        with pytest.raises(TypeError, match=msg):\n            getattr(df2, meth)(axis=1, numeric_only=False)",
        "begin_line": 1120,
        "end_line": 1144,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_sem#1146",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_sem(self, datetime_frame)",
        "snippet": "    def test_sem(self, datetime_frame):\n        result = datetime_frame.sem(ddof=4)\n        expected = datetime_frame.apply(lambda x: x.std(ddof=4) / np.sqrt(len(x)))\n        tm.assert_almost_equal(result, expected)\n\n        arr = np.repeat(np.random.random((1, 1000)), 1000, 0)\n        result = nanops.nansem(arr, axis=0)\n        assert not (result < 0).any()\n\n        with pd.option_context(\"use_bottleneck\", False):\n            result = nanops.nansem(arr, axis=0)\n            assert not (result < 0).any()",
        "begin_line": 1146,
        "end_line": 1157,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_kurt#1160",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_kurt(self)",
        "snippet": "    def test_kurt(self):\n        index = MultiIndex(\n            levels=[[\"bar\"], [\"one\", \"two\", \"three\"], [0, 1]],\n            codes=[[0, 0, 0, 0, 0, 0], [0, 1, 2, 0, 1, 2], [0, 1, 0, 1, 0, 1]],\n        )\n        df = DataFrame(np.random.randn(6, 3), index=index)\n\n        kurt = df.kurt()\n        kurt2 = df.kurt(level=0).xs(\"bar\")\n        tm.assert_series_equal(kurt, kurt2, check_names=False)\n        assert kurt.name is None\n        assert kurt2.name == \"bar\"",
        "begin_line": 1160,
        "end_line": 1171,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_mode_dropna#1226",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_mode_dropna(self, dropna, expected)",
        "snippet": "    def test_mode_dropna(self, dropna, expected):\n\n        df = DataFrame(\n            {\n                \"A\": [12, 12, 19, 11],\n                \"B\": [10, 10, np.nan, 3],\n                \"C\": [1, np.nan, np.nan, np.nan],\n                \"D\": [np.nan, np.nan, \"a\", np.nan],\n                \"E\": Categorical([np.nan, np.nan, \"a\", np.nan]),\n                \"F\": to_datetime([\"NaT\", \"2000-1-2\", \"NaT\", \"NaT\"]),\n                \"G\": to_timedelta([\"1 days\", \"nan\", \"nan\", \"nan\"]),\n                \"H\": [8, 8, 9, 9],\n                \"I\": [9, 9, 8, 8],\n                \"J\": [1, 1, np.nan, np.nan],\n                \"K\": Categorical([\"a\", np.nan, \"a\", np.nan]),\n                \"L\": to_datetime([\"2000-1-2\", \"2000-1-2\", \"NaT\", \"NaT\"]),\n                \"M\": to_timedelta([\"1 days\", \"nan\", \"1 days\", \"nan\"]),\n                \"N\": np.arange(4, dtype=\"int64\"),\n            }\n        )\n\n        result = df[sorted(expected.keys())].mode(dropna=dropna)\n        expected = DataFrame(expected)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1226,
        "end_line": 1249,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_mode_sortwarning#1251",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_mode_sortwarning(self)",
        "snippet": "    def test_mode_sortwarning(self):\n        # Check for the warning that is raised when the mode\n        # results cannot be sorted\n\n        df = DataFrame({\"A\": [np.nan, np.nan, \"a\", \"a\"]})\n        expected = DataFrame({\"A\": [\"a\", np.nan]})\n\n        with tm.assert_produces_warning(UserWarning, check_stacklevel=False):\n            result = df.mode(dropna=False)\n            result = result.sort_values(by=\"A\").reset_index(drop=True)\n\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1251,
        "end_line": 1262,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_operators_timedelta64#1264",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_operators_timedelta64(self)",
        "snippet": "    def test_operators_timedelta64(self):\n        df = DataFrame(\n            dict(\n                A=date_range(\"2012-1-1\", periods=3, freq=\"D\"),\n                B=date_range(\"2012-1-2\", periods=3, freq=\"D\"),\n                C=Timestamp(\"20120101\") - timedelta(minutes=5, seconds=5),\n            )\n        )\n\n        diffs = DataFrame(dict(A=df[\"A\"] - df[\"C\"], B=df[\"A\"] - df[\"B\"]))\n\n        # min\n        result = diffs.min()\n        assert result[0] == diffs.loc[0, \"A\"]\n        assert result[1] == diffs.loc[0, \"B\"]\n\n        result = diffs.min(axis=1)\n        assert (result == diffs.loc[0, \"B\"]).all()\n\n        # max\n        result = diffs.max()\n        assert result[0] == diffs.loc[2, \"A\"]\n        assert result[1] == diffs.loc[2, \"B\"]\n\n        result = diffs.max(axis=1)\n        assert (result == diffs[\"A\"]).all()\n\n        # abs\n        result = diffs.abs()\n        result2 = abs(diffs)\n        expected = DataFrame(dict(A=df[\"A\"] - df[\"C\"], B=df[\"B\"] - df[\"A\"]))\n        tm.assert_frame_equal(result, expected)\n        tm.assert_frame_equal(result2, expected)\n\n        # mixed frame\n        mixed = diffs.copy()\n        mixed[\"C\"] = \"foo\"\n        mixed[\"D\"] = 1\n        mixed[\"E\"] = 1.0\n        mixed[\"F\"] = Timestamp(\"20130101\")\n\n        # results in an object array\n        result = mixed.min()\n        expected = Series(\n            [\n                pd.Timedelta(timedelta(seconds=5 * 60 + 5)),\n                pd.Timedelta(timedelta(days=-1)),\n                \"foo\",\n                1,\n                1.0,\n                Timestamp(\"20130101\"),\n            ],\n            index=mixed.columns,\n        )\n        tm.assert_series_equal(result, expected)\n\n        # excludes numeric\n        result = mixed.min(axis=1)\n        expected = Series([1, 1, 1.0], index=[0, 1, 2])\n        tm.assert_series_equal(result, expected)\n\n        # works when only those columns are selected\n        result = mixed[[\"A\", \"B\"]].min(1)\n        expected = Series([timedelta(days=-1)] * 3)\n        tm.assert_series_equal(result, expected)\n\n        result = mixed[[\"A\", \"B\"]].min()\n        expected = Series(\n            [timedelta(seconds=5 * 60 + 5), timedelta(days=-1)], index=[\"A\", \"B\"]\n        )\n        tm.assert_series_equal(result, expected)\n\n        # GH 3106\n        df = DataFrame(\n            {\n                \"time\": date_range(\"20130102\", periods=5),\n                \"time2\": date_range(\"20130105\", periods=5),\n            }\n        )\n        df[\"off1\"] = df[\"time2\"] - df[\"time\"]\n        assert df[\"off1\"].dtype == \"timedelta64[ns]\"\n\n        df[\"off2\"] = df[\"time\"] - df[\"time2\"]\n        df._consolidate_inplace()\n        assert df[\"off1\"].dtype == \"timedelta64[ns]\"\n        assert df[\"off2\"].dtype == \"timedelta64[ns]\"",
        "begin_line": 1264,
        "end_line": 1349,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_sum_corner#1351",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_sum_corner(self)",
        "snippet": "    def test_sum_corner(self):\n        empty_frame = DataFrame()\n\n        axis0 = empty_frame.sum(0)\n        axis1 = empty_frame.sum(1)\n        assert isinstance(axis0, Series)\n        assert isinstance(axis1, Series)\n        assert len(axis0) == 0\n        assert len(axis1) == 0",
        "begin_line": 1351,
        "end_line": 1359,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_sum_prod_nanops#1362",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_sum_prod_nanops(self, method, unit)",
        "snippet": "    def test_sum_prod_nanops(self, method, unit):\n        idx = [\"a\", \"b\", \"c\"]\n        df = pd.DataFrame(\n            {\"a\": [unit, unit], \"b\": [unit, np.nan], \"c\": [np.nan, np.nan]}\n        )\n        # The default\n        result = getattr(df, method)\n        expected = pd.Series([unit, unit, unit], index=idx, dtype=\"float64\")\n\n        # min_count=1\n        result = getattr(df, method)(min_count=1)\n        expected = pd.Series([unit, unit, np.nan], index=idx)\n        tm.assert_series_equal(result, expected)\n\n        # min_count=0\n        result = getattr(df, method)(min_count=0)\n        expected = pd.Series([unit, unit, unit], index=idx, dtype=\"float64\")\n        tm.assert_series_equal(result, expected)\n\n        result = getattr(df.iloc[1:], method)(min_count=1)\n        expected = pd.Series([unit, np.nan, np.nan], index=idx)\n        tm.assert_series_equal(result, expected)\n\n        # min_count > 1\n        df = pd.DataFrame({\"A\": [unit] * 10, \"B\": [unit] * 5 + [np.nan] * 5})\n        result = getattr(df, method)(min_count=5)\n        expected = pd.Series(result, index=[\"A\", \"B\"])\n        tm.assert_series_equal(result, expected)\n\n        result = getattr(df, method)(min_count=6)\n        expected = pd.Series(result, index=[\"A\", \"B\"])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1362,
        "end_line": 1393,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_sum_nanops_timedelta#1395",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_sum_nanops_timedelta(self)",
        "snippet": "    def test_sum_nanops_timedelta(self):\n        # prod isn't defined on timedeltas\n        idx = [\"a\", \"b\", \"c\"]\n        df = pd.DataFrame({\"a\": [0, 0], \"b\": [0, np.nan], \"c\": [np.nan, np.nan]})\n\n        df2 = df.apply(pd.to_timedelta)\n\n        # 0 by default\n        result = df2.sum()\n        expected = pd.Series([0, 0, 0], dtype=\"m8[ns]\", index=idx)\n        tm.assert_series_equal(result, expected)\n\n        # min_count=0\n        result = df2.sum(min_count=0)\n        tm.assert_series_equal(result, expected)\n\n        # min_count=1\n        result = df2.sum(min_count=1)\n        expected = pd.Series([0, 0, np.nan], dtype=\"m8[ns]\", index=idx)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1395,
        "end_line": 1414,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_sum_object#1416",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_sum_object(self, float_frame)",
        "snippet": "    def test_sum_object(self, float_frame):\n        values = float_frame.values.astype(int)\n        frame = DataFrame(values, index=float_frame.index, columns=float_frame.columns)\n        deltas = frame * timedelta(1)\n        deltas.sum()",
        "begin_line": 1416,
        "end_line": 1420,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_sum_bool#1422",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_sum_bool(self, float_frame)",
        "snippet": "    def test_sum_bool(self, float_frame):\n        # ensure this works, bug report\n        bools = np.isnan(float_frame)\n        bools.sum(1)\n        bools.sum(0)",
        "begin_line": 1422,
        "end_line": 1426,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_mean_corner#1428",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_mean_corner(self, float_frame, float_string_frame)",
        "snippet": "    def test_mean_corner(self, float_frame, float_string_frame):\n        # unit test when have object data\n        the_mean = float_string_frame.mean(axis=0)\n        the_sum = float_string_frame.sum(axis=0, numeric_only=True)\n        tm.assert_index_equal(the_sum.index, the_mean.index)\n        assert len(the_mean.index) < len(float_string_frame.columns)\n\n        # xs sum mixed type, just want to know it works...\n        the_mean = float_string_frame.mean(axis=1)\n        the_sum = float_string_frame.sum(axis=1, numeric_only=True)\n        tm.assert_index_equal(the_sum.index, the_mean.index)\n\n        # take mean of boolean column\n        float_frame[\"bool\"] = float_frame[\"A\"] > 0\n        means = float_frame.mean(0)\n        assert means[\"bool\"] == float_frame[\"bool\"].values.mean()",
        "begin_line": 1428,
        "end_line": 1443,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_mean_datetimelike#1445",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_mean_datetimelike(self)",
        "snippet": "    def test_mean_datetimelike(self):\n        # GH#24757 check that datetimelike are excluded by default, handled\n        #  correctly with numeric_only=True\n\n        df = pd.DataFrame(\n            {\n                \"A\": np.arange(3),\n                \"B\": pd.date_range(\"2016-01-01\", periods=3),\n                \"C\": pd.timedelta_range(\"1D\", periods=3),\n                \"D\": pd.period_range(\"2016\", periods=3, freq=\"A\"),\n            }\n        )\n        result = df.mean(numeric_only=True)\n        expected = pd.Series({\"A\": 1.0})\n        tm.assert_series_equal(result, expected)\n\n        result = df.mean()\n        expected = pd.Series({\"A\": 1.0, \"C\": df.loc[1, \"C\"]})\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1445,
        "end_line": 1463,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_mean_datetimelike_numeric_only_false#1470",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_mean_datetimelike_numeric_only_false(self)",
        "snippet": "    def test_mean_datetimelike_numeric_only_false(self):\n        df = pd.DataFrame(\n            {\n                \"A\": np.arange(3),\n                \"B\": pd.date_range(\"2016-01-01\", periods=3),\n                \"C\": pd.timedelta_range(\"1D\", periods=3),\n                \"D\": pd.period_range(\"2016\", periods=3, freq=\"A\"),\n            }\n        )\n\n        result = df.mean(numeric_only=False)\n        expected = pd.Series(\n            {\"A\": 1, \"B\": df.loc[1, \"B\"], \"C\": df.loc[1, \"C\"], \"D\": df.loc[1, \"D\"]}\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1470,
        "end_line": 1484,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_stats_mixed_type#1486",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_stats_mixed_type(self, float_string_frame)",
        "snippet": "    def test_stats_mixed_type(self, float_string_frame):\n        # don't blow up\n        float_string_frame.std(1)\n        float_string_frame.var(1)\n        float_string_frame.mean(1)\n        float_string_frame.skew(1)",
        "begin_line": 1486,
        "end_line": 1491,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_sum_bools#1493",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_sum_bools(self)",
        "snippet": "    def test_sum_bools(self):\n        df = DataFrame(index=range(1), columns=range(10))\n        bools = isna(df)\n        assert bools.sum(axis=1)[0] == 10",
        "begin_line": 1493,
        "end_line": 1496,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_cumsum_corner#1501",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_cumsum_corner(self)",
        "snippet": "    def test_cumsum_corner(self):\n        dm = DataFrame(np.arange(20).reshape(4, 5), index=range(4), columns=range(5))\n        # ?(wesm)\n        result = dm.cumsum()  # noqa",
        "begin_line": 1501,
        "end_line": 1504,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_cumsum#1506",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_cumsum(self, datetime_frame)",
        "snippet": "    def test_cumsum(self, datetime_frame):\n        datetime_frame.loc[5:10, 0] = np.nan\n        datetime_frame.loc[10:15, 1] = np.nan\n        datetime_frame.loc[15:, 2] = np.nan\n\n        # axis = 0\n        cumsum = datetime_frame.cumsum()\n        expected = datetime_frame.apply(Series.cumsum)\n        tm.assert_frame_equal(cumsum, expected)\n\n        # axis = 1\n        cumsum = datetime_frame.cumsum(axis=1)\n        expected = datetime_frame.apply(Series.cumsum, axis=1)\n        tm.assert_frame_equal(cumsum, expected)\n\n        # works\n        df = DataFrame({\"A\": np.arange(20)}, index=np.arange(20))\n        result = df.cumsum()  # noqa\n\n        # fix issue\n        cumsum_xs = datetime_frame.cumsum(axis=1)\n        assert np.shape(cumsum_xs) == np.shape(datetime_frame)",
        "begin_line": 1506,
        "end_line": 1527,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_cumprod#1529",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_cumprod(self, datetime_frame)",
        "snippet": "    def test_cumprod(self, datetime_frame):\n        datetime_frame.loc[5:10, 0] = np.nan\n        datetime_frame.loc[10:15, 1] = np.nan\n        datetime_frame.loc[15:, 2] = np.nan\n\n        # axis = 0\n        cumprod = datetime_frame.cumprod()\n        expected = datetime_frame.apply(Series.cumprod)\n        tm.assert_frame_equal(cumprod, expected)\n\n        # axis = 1\n        cumprod = datetime_frame.cumprod(axis=1)\n        expected = datetime_frame.apply(Series.cumprod, axis=1)\n        tm.assert_frame_equal(cumprod, expected)\n\n        # fix issue\n        cumprod_xs = datetime_frame.cumprod(axis=1)\n        assert np.shape(cumprod_xs) == np.shape(datetime_frame)\n\n        # ints\n        df = datetime_frame.fillna(0).astype(int)\n        df.cumprod(0)\n        df.cumprod(1)\n\n        # ints32\n        df = datetime_frame.fillna(0).astype(np.int32)\n        df.cumprod(0)\n        df.cumprod(1)",
        "begin_line": 1529,
        "end_line": 1556,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_cummin#1558",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_cummin(self, datetime_frame)",
        "snippet": "    def test_cummin(self, datetime_frame):\n        datetime_frame.loc[5:10, 0] = np.nan\n        datetime_frame.loc[10:15, 1] = np.nan\n        datetime_frame.loc[15:, 2] = np.nan\n\n        # axis = 0\n        cummin = datetime_frame.cummin()\n        expected = datetime_frame.apply(Series.cummin)\n        tm.assert_frame_equal(cummin, expected)\n\n        # axis = 1\n        cummin = datetime_frame.cummin(axis=1)\n        expected = datetime_frame.apply(Series.cummin, axis=1)\n        tm.assert_frame_equal(cummin, expected)\n\n        # it works\n        df = DataFrame({\"A\": np.arange(20)}, index=np.arange(20))\n        result = df.cummin()  # noqa\n\n        # fix issue\n        cummin_xs = datetime_frame.cummin(axis=1)\n        assert np.shape(cummin_xs) == np.shape(datetime_frame)",
        "begin_line": 1558,
        "end_line": 1579,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_cummax#1581",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_cummax(self, datetime_frame)",
        "snippet": "    def test_cummax(self, datetime_frame):\n        datetime_frame.loc[5:10, 0] = np.nan\n        datetime_frame.loc[10:15, 1] = np.nan\n        datetime_frame.loc[15:, 2] = np.nan\n\n        # axis = 0\n        cummax = datetime_frame.cummax()\n        expected = datetime_frame.apply(Series.cummax)\n        tm.assert_frame_equal(cummax, expected)\n\n        # axis = 1\n        cummax = datetime_frame.cummax(axis=1)\n        expected = datetime_frame.apply(Series.cummax, axis=1)\n        tm.assert_frame_equal(cummax, expected)\n\n        # it works\n        df = DataFrame({\"A\": np.arange(20)}, index=np.arange(20))\n        result = df.cummax()  # noqa\n\n        # fix issue\n        cummax_xs = datetime_frame.cummax(axis=1)\n        assert np.shape(cummax_xs) == np.shape(datetime_frame)",
        "begin_line": 1581,
        "end_line": 1602,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_count#1607",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_count(self)",
        "snippet": "    def test_count(self):\n        # corner case\n        frame = DataFrame()\n        ct1 = frame.count(1)\n        assert isinstance(ct1, Series)\n\n        ct2 = frame.count(0)\n        assert isinstance(ct2, Series)\n\n        # GH#423\n        df = DataFrame(index=range(10))\n        result = df.count(1)\n        expected = Series(0, index=df.index)\n        tm.assert_series_equal(result, expected)\n\n        df = DataFrame(columns=range(10))\n        result = df.count(0)\n        expected = Series(0, index=df.columns)\n        tm.assert_series_equal(result, expected)\n\n        df = DataFrame()\n        result = df.count()\n        expected = Series(0, index=[])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1607,
        "end_line": 1630,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_count_objects#1632",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_count_objects(self, float_string_frame)",
        "snippet": "    def test_count_objects(self, float_string_frame):\n        dm = DataFrame(float_string_frame._series)\n        df = DataFrame(float_string_frame._series)\n\n        tm.assert_series_equal(dm.count(), df.count())\n        tm.assert_series_equal(dm.count(1), df.count(1))",
        "begin_line": 1632,
        "end_line": 1637,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_pct_change#1639",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_pct_change(self)",
        "snippet": "    def test_pct_change(self):\n        # GH#11150\n        pnl = DataFrame(\n            [np.arange(0, 40, 10), np.arange(0, 40, 10), np.arange(0, 40, 10)]\n        ).astype(np.float64)\n        pnl.iat[1, 0] = np.nan\n        pnl.iat[1, 1] = np.nan\n        pnl.iat[2, 3] = 60\n\n        for axis in range(2):\n            expected = pnl.ffill(axis=axis) / pnl.ffill(axis=axis).shift(axis=axis) - 1\n            result = pnl.pct_change(axis=axis, fill_method=\"pad\")\n\n            tm.assert_frame_equal(result, expected)",
        "begin_line": 1639,
        "end_line": 1652,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_idxmin#1657",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_idxmin(self, float_frame, int_frame)",
        "snippet": "    def test_idxmin(self, float_frame, int_frame):\n        frame = float_frame\n        frame.loc[5:10] = np.nan\n        frame.loc[15:20, -2:] = np.nan\n        for skipna in [True, False]:\n            for axis in [0, 1]:\n                for df in [frame, int_frame]:\n                    result = df.idxmin(axis=axis, skipna=skipna)\n                    expected = df.apply(Series.idxmin, axis=axis, skipna=skipna)\n                    tm.assert_series_equal(result, expected)\n\n        msg = \"No axis named 2 for object type <class 'pandas.core.frame.DataFrame'>\"\n        with pytest.raises(ValueError, match=msg):\n            frame.idxmin(axis=2)",
        "begin_line": 1657,
        "end_line": 1670,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_idxmax#1672",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_idxmax(self, float_frame, int_frame)",
        "snippet": "    def test_idxmax(self, float_frame, int_frame):\n        frame = float_frame\n        frame.loc[5:10] = np.nan\n        frame.loc[15:20, -2:] = np.nan\n        for skipna in [True, False]:\n            for axis in [0, 1]:\n                for df in [frame, int_frame]:\n                    result = df.idxmax(axis=axis, skipna=skipna)\n                    expected = df.apply(Series.idxmax, axis=axis, skipna=skipna)\n                    tm.assert_series_equal(result, expected)\n\n        msg = \"No axis named 2 for object type <class 'pandas.core.frame.DataFrame'>\"\n        with pytest.raises(ValueError, match=msg):\n            frame.idxmax(axis=2)",
        "begin_line": 1672,
        "end_line": 1685,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_any_all#1691",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_any_all(self, opname, bool_frame_with_na, float_string_frame)",
        "snippet": "    def test_any_all(self, opname, bool_frame_with_na, float_string_frame):\n        assert_bool_op_calc(\n            opname, getattr(np, opname), bool_frame_with_na, has_skipna=True\n        )\n        assert_bool_op_api(\n            opname, bool_frame_with_na, float_string_frame, has_bool_only=True\n        )",
        "begin_line": 1691,
        "end_line": 1697,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_any_all_extra#1699",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_any_all_extra(self)",
        "snippet": "    def test_any_all_extra(self):\n        df = DataFrame(\n            {\n                \"A\": [True, False, False],\n                \"B\": [True, True, False],\n                \"C\": [True, True, True],\n            },\n            index=[\"a\", \"b\", \"c\"],\n        )\n        result = df[[\"A\", \"B\"]].any(1)\n        expected = Series([True, True, False], index=[\"a\", \"b\", \"c\"])\n        tm.assert_series_equal(result, expected)\n\n        result = df[[\"A\", \"B\"]].any(1, bool_only=True)\n        tm.assert_series_equal(result, expected)\n\n        result = df.all(1)\n        expected = Series([True, False, False], index=[\"a\", \"b\", \"c\"])\n        tm.assert_series_equal(result, expected)\n\n        result = df.all(1, bool_only=True)\n        tm.assert_series_equal(result, expected)\n\n        # Axis is None\n        result = df.all(axis=None).item()\n        assert result is False\n\n        result = df.any(axis=None).item()\n        assert result is True\n\n        result = df[[\"C\"]].all(axis=None).item()\n        assert result is True",
        "begin_line": 1699,
        "end_line": 1730,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_any_datetime#1732",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_any_datetime(self)",
        "snippet": "    def test_any_datetime(self):\n\n        # GH 23070\n        float_data = [1, np.nan, 3, np.nan]\n        datetime_data = [\n            pd.Timestamp(\"1960-02-15\"),\n            pd.Timestamp(\"1960-02-16\"),\n            pd.NaT,\n            pd.NaT,\n        ]\n        df = DataFrame({\"A\": float_data, \"B\": datetime_data})\n\n        result = df.any(1)\n        expected = Series([True, True, True, False])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1732,
        "end_line": 1746,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_any_all_bool_only#1748",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_any_all_bool_only(self)",
        "snippet": "    def test_any_all_bool_only(self):\n\n        # GH 25101\n        df = DataFrame(\n            {\"col1\": [1, 2, 3], \"col2\": [4, 5, 6], \"col3\": [None, None, None]}\n        )\n\n        result = df.all(bool_only=True)\n        expected = Series(dtype=np.bool)\n        tm.assert_series_equal(result, expected)\n\n        df = DataFrame(\n            {\n                \"col1\": [1, 2, 3],\n                \"col2\": [4, 5, 6],\n                \"col3\": [None, None, None],\n                \"col4\": [False, False, True],\n            }\n        )\n\n        result = df.all(bool_only=True)\n        expected = Series({\"col4\": False})\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1748,
        "end_line": 1770,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_any_all_np_func#1859",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_any_all_np_func(self, func, data, expected)",
        "snippet": "    def test_any_all_np_func(self, func, data, expected):\n        # GH 19976\n        data = DataFrame(data)\n        result = func(data)\n        assert isinstance(result, np.bool_)\n        assert result.item() is expected\n\n        # method version\n        result = getattr(DataFrame(data), func.__name__)(axis=None)\n        assert isinstance(result, np.bool_)\n        assert result.item() is expected",
        "begin_line": 1859,
        "end_line": 1869,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_any_all_object#1871",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_any_all_object(self)",
        "snippet": "    def test_any_all_object(self):\n        # GH 19976\n        result = np.all(DataFrame(columns=[\"a\", \"b\"])).item()\n        assert result is True\n\n        result = np.any(DataFrame(columns=[\"a\", \"b\"])).item()\n        assert result is False",
        "begin_line": 1871,
        "end_line": 1877,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_any_all_level_axis_none_raises#1880",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_any_all_level_axis_none_raises(self, method)",
        "snippet": "    def test_any_all_level_axis_none_raises(self, method):\n        df = DataFrame(\n            {\"A\": 1},\n            index=MultiIndex.from_product(\n                [[\"A\", \"B\"], [\"a\", \"b\"]], names=[\"out\", \"in\"]\n            ),\n        )\n        xpr = \"Must specify 'axis' when aggregating by level.\"\n        with pytest.raises(ValueError, match=xpr):\n            getattr(df, method)(axis=None, level=\"out\")",
        "begin_line": 1880,
        "end_line": 1889,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin#1894",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin(self)",
        "snippet": "    def test_isin(self):\n        # GH 4211\n        df = DataFrame(\n            {\n                \"vals\": [1, 2, 3, 4],\n                \"ids\": [\"a\", \"b\", \"f\", \"n\"],\n                \"ids2\": [\"a\", \"n\", \"c\", \"n\"],\n            },\n            index=[\"foo\", \"bar\", \"baz\", \"qux\"],\n        )\n        other = [\"a\", \"b\", \"c\"]\n\n        result = df.isin(other)\n        expected = DataFrame([df.loc[s].isin(other) for s in df.index])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1894,
        "end_line": 1908,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_empty#1911",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_empty(self, empty)",
        "snippet": "    def test_isin_empty(self, empty):\n        # GH 16991\n        df = DataFrame({\"A\": [\"a\", \"b\", \"c\"], \"B\": [\"a\", \"e\", \"f\"]})\n        expected = DataFrame(False, df.index, df.columns)\n\n        result = df.isin(empty)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1911,
        "end_line": 1917,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_dict#1919",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_dict(self)",
        "snippet": "    def test_isin_dict(self):\n        df = DataFrame({\"A\": [\"a\", \"b\", \"c\"], \"B\": [\"a\", \"e\", \"f\"]})\n        d = {\"A\": [\"a\"]}\n\n        expected = DataFrame(False, df.index, df.columns)\n        expected.loc[0, \"A\"] = True\n\n        result = df.isin(d)\n        tm.assert_frame_equal(result, expected)\n\n        # non unique columns\n        df = DataFrame({\"A\": [\"a\", \"b\", \"c\"], \"B\": [\"a\", \"e\", \"f\"]})\n        df.columns = [\"A\", \"A\"]\n        expected = DataFrame(False, df.index, df.columns)\n        expected.loc[0, \"A\"] = True\n        result = df.isin(d)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1919,
        "end_line": 1935,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_with_string_scalar#1937",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_with_string_scalar(self)",
        "snippet": "    def test_isin_with_string_scalar(self):\n        # GH 4763\n        df = DataFrame(\n            {\n                \"vals\": [1, 2, 3, 4],\n                \"ids\": [\"a\", \"b\", \"f\", \"n\"],\n                \"ids2\": [\"a\", \"n\", \"c\", \"n\"],\n            },\n            index=[\"foo\", \"bar\", \"baz\", \"qux\"],\n        )\n        with pytest.raises(TypeError):\n            df.isin(\"a\")\n\n        with pytest.raises(TypeError):\n            df.isin(\"aaa\")",
        "begin_line": 1937,
        "end_line": 1951,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_df#1953",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_df(self)",
        "snippet": "    def test_isin_df(self):\n        df1 = DataFrame({\"A\": [1, 2, 3, 4], \"B\": [2, np.nan, 4, 4]})\n        df2 = DataFrame({\"A\": [0, 2, 12, 4], \"B\": [2, np.nan, 4, 5]})\n        expected = DataFrame(False, df1.index, df1.columns)\n        result = df1.isin(df2)\n        expected[\"A\"].loc[[1, 3]] = True\n        expected[\"B\"].loc[[0, 2]] = True\n        tm.assert_frame_equal(result, expected)\n\n        # partial overlapping columns\n        df2.columns = [\"A\", \"C\"]\n        result = df1.isin(df2)\n        expected[\"B\"] = False\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1953,
        "end_line": 1966,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_tuples#1968",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_tuples(self)",
        "snippet": "    def test_isin_tuples(self):\n        # GH 16394\n        df = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [\"a\", \"b\", \"f\"]})\n        df[\"C\"] = list(zip(df[\"A\"], df[\"B\"]))\n        result = df[\"C\"].isin([(1, \"a\")])\n        tm.assert_series_equal(result, Series([True, False, False], name=\"C\"))",
        "begin_line": 1968,
        "end_line": 1973,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_df_dupe_values#1975",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_df_dupe_values(self)",
        "snippet": "    def test_isin_df_dupe_values(self):\n        df1 = DataFrame({\"A\": [1, 2, 3, 4], \"B\": [2, np.nan, 4, 4]})\n        # just cols duped\n        df2 = DataFrame([[0, 2], [12, 4], [2, np.nan], [4, 5]], columns=[\"B\", \"B\"])\n        with pytest.raises(ValueError):\n            df1.isin(df2)\n\n        # just index duped\n        df2 = DataFrame(\n            [[0, 2], [12, 4], [2, np.nan], [4, 5]],\n            columns=[\"A\", \"B\"],\n            index=[0, 0, 1, 1],\n        )\n        with pytest.raises(ValueError):\n            df1.isin(df2)\n\n        # cols and index:\n        df2.columns = [\"B\", \"B\"]\n        with pytest.raises(ValueError):\n            df1.isin(df2)",
        "begin_line": 1975,
        "end_line": 1994,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_dupe_self#1996",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_dupe_self(self)",
        "snippet": "    def test_isin_dupe_self(self):\n        other = DataFrame({\"A\": [1, 0, 1, 0], \"B\": [1, 1, 0, 0]})\n        df = DataFrame([[1, 1], [1, 0], [0, 0]], columns=[\"A\", \"A\"])\n        result = df.isin(other)\n        expected = DataFrame(False, index=df.index, columns=df.columns)\n        expected.loc[0] = True\n        expected.iloc[1, 1] = True\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1996,
        "end_line": 2003,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_against_series#2005",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_against_series(self)",
        "snippet": "    def test_isin_against_series(self):\n        df = pd.DataFrame(\n            {\"A\": [1, 2, 3, 4], \"B\": [2, np.nan, 4, 4]}, index=[\"a\", \"b\", \"c\", \"d\"]\n        )\n        s = pd.Series([1, 3, 11, 4], index=[\"a\", \"b\", \"c\", \"d\"])\n        expected = DataFrame(False, index=df.index, columns=df.columns)\n        expected[\"A\"].loc[\"a\"] = True\n        expected.loc[\"d\"] = True\n        result = df.isin(s)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2005,
        "end_line": 2014,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_multiIndex#2016",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_multiIndex(self)",
        "snippet": "    def test_isin_multiIndex(self):\n        idx = MultiIndex.from_tuples(\n            [\n                (0, \"a\", \"foo\"),\n                (0, \"a\", \"bar\"),\n                (0, \"b\", \"bar\"),\n                (0, \"b\", \"baz\"),\n                (2, \"a\", \"foo\"),\n                (2, \"a\", \"bar\"),\n                (2, \"c\", \"bar\"),\n                (2, \"c\", \"baz\"),\n                (1, \"b\", \"foo\"),\n                (1, \"b\", \"bar\"),\n                (1, \"c\", \"bar\"),\n                (1, \"c\", \"baz\"),\n            ]\n        )\n        df1 = DataFrame({\"A\": np.ones(12), \"B\": np.zeros(12)}, index=idx)\n        df2 = DataFrame(\n            {\n                \"A\": [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],\n                \"B\": [1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1],\n            }\n        )\n        # against regular index\n        expected = DataFrame(False, index=df1.index, columns=df1.columns)\n        result = df1.isin(df2)\n        tm.assert_frame_equal(result, expected)\n\n        df2.index = idx\n        expected = df2.values.astype(np.bool)\n        expected[:, 1] = ~expected[:, 1]\n        expected = DataFrame(expected, columns=[\"A\", \"B\"], index=idx)\n\n        result = df1.isin(df2)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2016,
        "end_line": 2051,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_empty_datetimelike#2053",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_isin_empty_datetimelike(self)",
        "snippet": "    def test_isin_empty_datetimelike(self):\n        # GH 15473\n        df1_ts = DataFrame({\"date\": pd.to_datetime([\"2014-01-01\", \"2014-01-02\"])})\n        df1_td = DataFrame({\"date\": [pd.Timedelta(1, \"s\"), pd.Timedelta(2, \"s\")]})\n        df2 = DataFrame({\"date\": []})\n        df3 = DataFrame()\n\n        expected = DataFrame({\"date\": [False, False]})\n\n        result = df1_ts.isin(df2)\n        tm.assert_frame_equal(result, expected)\n        result = df1_ts.isin(df3)\n        tm.assert_frame_equal(result, expected)\n\n        result = df1_td.isin(df2)\n        tm.assert_frame_equal(result, expected)\n        result = df1_td.isin(df3)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2053,
        "end_line": 2070,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_round#2075",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_round(self)",
        "snippet": "    def test_round(self):\n        # GH 2665\n\n        # Test that rounding an empty DataFrame does nothing\n        df = DataFrame()\n        tm.assert_frame_equal(df, df.round())\n\n        # Here's the test frame we'll be working with\n        df = DataFrame({\"col1\": [1.123, 2.123, 3.123], \"col2\": [1.234, 2.234, 3.234]})\n\n        # Default round to integer (i.e. decimals=0)\n        expected_rounded = DataFrame({\"col1\": [1.0, 2.0, 3.0], \"col2\": [1.0, 2.0, 3.0]})\n        tm.assert_frame_equal(df.round(), expected_rounded)\n\n        # Round with an integer\n        decimals = 2\n        expected_rounded = DataFrame(\n            {\"col1\": [1.12, 2.12, 3.12], \"col2\": [1.23, 2.23, 3.23]}\n        )\n        tm.assert_frame_equal(df.round(decimals), expected_rounded)\n\n        # This should also work with np.round (since np.round dispatches to\n        # df.round)\n        tm.assert_frame_equal(np.round(df, decimals), expected_rounded)\n\n        # Round with a list\n        round_list = [1, 2]\n        with pytest.raises(TypeError):\n            df.round(round_list)\n\n        # Round with a dictionary\n        expected_rounded = DataFrame(\n            {\"col1\": [1.1, 2.1, 3.1], \"col2\": [1.23, 2.23, 3.23]}\n        )\n        round_dict = {\"col1\": 1, \"col2\": 2}\n        tm.assert_frame_equal(df.round(round_dict), expected_rounded)\n\n        # Incomplete dict\n        expected_partially_rounded = DataFrame(\n            {\"col1\": [1.123, 2.123, 3.123], \"col2\": [1.2, 2.2, 3.2]}\n        )\n        partial_round_dict = {\"col2\": 1}\n        tm.assert_frame_equal(df.round(partial_round_dict), expected_partially_rounded)\n\n        # Dict with unknown elements\n        wrong_round_dict = {\"col3\": 2, \"col2\": 1}\n        tm.assert_frame_equal(df.round(wrong_round_dict), expected_partially_rounded)\n\n        # float input to `decimals`\n        non_int_round_dict = {\"col1\": 1, \"col2\": 0.5}\n        with pytest.raises(TypeError):\n            df.round(non_int_round_dict)\n\n        # String input\n        non_int_round_dict = {\"col1\": 1, \"col2\": \"foo\"}\n        with pytest.raises(TypeError):\n            df.round(non_int_round_dict)\n\n        non_int_round_Series = Series(non_int_round_dict)\n        with pytest.raises(TypeError):\n            df.round(non_int_round_Series)\n\n        # List input\n        non_int_round_dict = {\"col1\": 1, \"col2\": [1, 2]}\n        with pytest.raises(TypeError):\n            df.round(non_int_round_dict)\n\n        non_int_round_Series = Series(non_int_round_dict)\n        with pytest.raises(TypeError):\n            df.round(non_int_round_Series)\n\n        # Non integer Series inputs\n        non_int_round_Series = Series(non_int_round_dict)\n        with pytest.raises(TypeError):\n            df.round(non_int_round_Series)\n\n        non_int_round_Series = Series(non_int_round_dict)\n        with pytest.raises(TypeError):\n            df.round(non_int_round_Series)\n\n        # Negative numbers\n        negative_round_dict = {\"col1\": -1, \"col2\": -2}\n        big_df = df * 100\n        expected_neg_rounded = DataFrame(\n            {\"col1\": [110.0, 210, 310], \"col2\": [100.0, 200, 300]}\n        )\n        tm.assert_frame_equal(big_df.round(negative_round_dict), expected_neg_rounded)\n\n        # nan in Series round\n        nan_round_Series = Series({\"col1\": np.nan, \"col2\": 1})\n\n        # TODO(wesm): unused?\n        expected_nan_round = DataFrame(  # noqa\n            {\"col1\": [1.123, 2.123, 3.123], \"col2\": [1.2, 2.2, 3.2]}\n        )\n\n        with pytest.raises(TypeError):\n            df.round(nan_round_Series)\n\n        # Make sure this doesn't break existing Series.round\n        tm.assert_series_equal(df[\"col1\"].round(1), expected_rounded[\"col1\"])\n\n        # named columns\n        # GH 11986\n        decimals = 2\n        expected_rounded = DataFrame(\n            {\"col1\": [1.12, 2.12, 3.12], \"col2\": [1.23, 2.23, 3.23]}\n        )\n        df.columns.name = \"cols\"\n        expected_rounded.columns.name = \"cols\"\n        tm.assert_frame_equal(df.round(decimals), expected_rounded)\n\n        # interaction of named columns & series\n        tm.assert_series_equal(df[\"col1\"].round(decimals), expected_rounded[\"col1\"])\n        tm.assert_series_equal(df.round(decimals)[\"col1\"], expected_rounded[\"col1\"])",
        "begin_line": 2075,
        "end_line": 2189,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_numpy_round#2191",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_numpy_round(self)",
        "snippet": "    def test_numpy_round(self):\n        # GH 12600\n        df = DataFrame([[1.53, 1.36], [0.06, 7.01]])\n        out = np.round(df, decimals=0)\n        expected = DataFrame([[2.0, 1.0], [0.0, 7.0]])\n        tm.assert_frame_equal(out, expected)\n\n        msg = \"the 'out' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            np.round(df, decimals=0, out=df)",
        "begin_line": 2191,
        "end_line": 2200,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_numpy_round_nan#2202",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_numpy_round_nan(self)",
        "snippet": "    def test_numpy_round_nan(self):\n        # See gh-14197\n        df = Series([1.53, np.nan, 0.06]).to_frame()\n        with tm.assert_produces_warning(None):\n            result = df.round()\n        expected = Series([2.0, np.nan, 0.0]).to_frame()\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2202,
        "end_line": 2208,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_round_mixed_type#2210",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_round_mixed_type(self)",
        "snippet": "    def test_round_mixed_type(self):\n        # GH 11885\n        df = DataFrame(\n            {\n                \"col1\": [1.1, 2.2, 3.3, 4.4],\n                \"col2\": [\"1\", \"a\", \"c\", \"f\"],\n                \"col3\": date_range(\"20111111\", periods=4),\n            }\n        )\n        round_0 = DataFrame(\n            {\n                \"col1\": [1.0, 2.0, 3.0, 4.0],\n                \"col2\": [\"1\", \"a\", \"c\", \"f\"],\n                \"col3\": date_range(\"20111111\", periods=4),\n            }\n        )\n        tm.assert_frame_equal(df.round(), round_0)\n        tm.assert_frame_equal(df.round(1), df)\n        tm.assert_frame_equal(df.round({\"col1\": 1}), df)\n        tm.assert_frame_equal(df.round({\"col1\": 0}), round_0)\n        tm.assert_frame_equal(df.round({\"col1\": 0, \"col2\": 1}), round_0)\n        tm.assert_frame_equal(df.round({\"col3\": 1}), df)",
        "begin_line": 2210,
        "end_line": 2231,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_round_issue#2233",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_round_issue(self)",
        "snippet": "    def test_round_issue(self):\n        # GH 11611\n\n        df = pd.DataFrame(\n            np.random.random([3, 3]),\n            columns=[\"A\", \"B\", \"C\"],\n            index=[\"first\", \"second\", \"third\"],\n        )\n\n        dfs = pd.concat((df, df), axis=1)\n        rounded = dfs.round()\n        tm.assert_index_equal(rounded.index, dfs.index)\n\n        decimals = pd.Series([1, 0, 2], index=[\"A\", \"B\", \"A\"])\n        msg = \"Index of decimals must be unique\"\n        with pytest.raises(ValueError, match=msg):\n            df.round(decimals)",
        "begin_line": 2233,
        "end_line": 2249,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_built_in_round#2251",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_built_in_round(self)",
        "snippet": "    def test_built_in_round(self):\n        # GH 11763\n        # Here's the test frame we'll be working with\n        df = DataFrame({\"col1\": [1.123, 2.123, 3.123], \"col2\": [1.234, 2.234, 3.234]})\n\n        # Default round to integer (i.e. decimals=0)\n        expected_rounded = DataFrame({\"col1\": [1.0, 2.0, 3.0], \"col2\": [1.0, 2.0, 3.0]})\n        tm.assert_frame_equal(round(df), expected_rounded)",
        "begin_line": 2251,
        "end_line": 2258,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_round_nonunique_categorical#2260",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_round_nonunique_categorical(self)",
        "snippet": "    def test_round_nonunique_categorical(self):\n        # See GH21809\n        idx = pd.CategoricalIndex([\"low\"] * 3 + [\"hi\"] * 3)\n        df = pd.DataFrame(np.random.rand(6, 3), columns=list(\"abc\"))\n\n        expected = df.round(3)\n        expected.index = idx\n\n        df_categorical = df.copy().set_index(idx)\n        assert df_categorical.shape == (6, 3)\n        result = df_categorical.round(3)\n        assert result.shape == (6, 3)\n\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2260,
        "end_line": 2273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_round_interval_category_columns#2275",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_round_interval_category_columns(self)",
        "snippet": "    def test_round_interval_category_columns(self):\n        # GH 30063\n        columns = pd.CategoricalIndex(pd.interval_range(0, 2))\n        df = DataFrame([[0.66, 1.1], [0.3, 0.25]], columns=columns)\n\n        result = df.round()\n        expected = DataFrame([[1.0, 1.0], [0.0, 0.0]], columns=columns)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2275,
        "end_line": 2282,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_clip#2287",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_clip(self, float_frame)",
        "snippet": "    def test_clip(self, float_frame):\n        median = float_frame.median().median()\n        original = float_frame.copy()\n\n        double = float_frame.clip(upper=median, lower=median)\n        assert not (double.values != median).any()\n\n        # Verify that float_frame was not changed inplace\n        assert (float_frame.values == original.values).all()",
        "begin_line": 2287,
        "end_line": 2295,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_inplace_clip#2297",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_inplace_clip(self, float_frame)",
        "snippet": "    def test_inplace_clip(self, float_frame):\n        # GH 15388\n        median = float_frame.median().median()\n        frame_copy = float_frame.copy()\n\n        frame_copy.clip(upper=median, lower=median, inplace=True)\n        assert not (frame_copy.values != median).any()",
        "begin_line": 2297,
        "end_line": 2303,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_dataframe_clip#2305",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_dataframe_clip(self)",
        "snippet": "    def test_dataframe_clip(self):\n        # GH 2747\n        df = DataFrame(np.random.randn(1000, 2))\n\n        for lb, ub in [(-1, 1), (1, -1)]:\n            clipped_df = df.clip(lb, ub)\n\n            lb, ub = min(lb, ub), max(ub, lb)\n            lb_mask = df.values <= lb\n            ub_mask = df.values >= ub\n            mask = ~lb_mask & ~ub_mask\n            assert (clipped_df.values[lb_mask] == lb).all()\n            assert (clipped_df.values[ub_mask] == ub).all()\n            assert (clipped_df.values[mask] == df.values[mask]).all()",
        "begin_line": 2305,
        "end_line": 2318,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_clip_mixed_numeric#2320",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_clip_mixed_numeric(self)",
        "snippet": "    def test_clip_mixed_numeric(self):\n        # TODO(jreback)\n        # clip on mixed integer or floats\n        # with integer clippers coerces to float\n        df = DataFrame({\"A\": [1, 2, 3], \"B\": [1.0, np.nan, 3.0]})\n        result = df.clip(1, 2)\n        expected = DataFrame({\"A\": [1, 2, 2], \"B\": [1.0, np.nan, 2.0]})\n        tm.assert_frame_equal(result, expected, check_like=True)\n\n        # GH 24162, clipping now preserves numeric types per column\n        df = DataFrame([[1, 2, 3.4], [3, 4, 5.6]], columns=[\"foo\", \"bar\", \"baz\"])\n        expected = df.dtypes\n        result = df.clip(upper=3).dtypes\n        tm.assert_series_equal(result, expected)",
        "begin_line": 2320,
        "end_line": 2333,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_clip_against_series#2336",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_clip_against_series(self, inplace)",
        "snippet": "    def test_clip_against_series(self, inplace):\n        # GH 6966\n\n        df = DataFrame(np.random.randn(1000, 2))\n        lb = Series(np.random.randn(1000))\n        ub = lb + 1\n\n        original = df.copy()\n        clipped_df = df.clip(lb, ub, axis=0, inplace=inplace)\n\n        if inplace:\n            clipped_df = df\n\n        for i in range(2):\n            lb_mask = original.iloc[:, i] <= lb\n            ub_mask = original.iloc[:, i] >= ub\n            mask = ~lb_mask & ~ub_mask\n\n            result = clipped_df.loc[lb_mask, i]\n            tm.assert_series_equal(result, lb[lb_mask], check_names=False)\n            assert result.name == i\n\n            result = clipped_df.loc[ub_mask, i]\n            tm.assert_series_equal(result, ub[ub_mask], check_names=False)\n            assert result.name == i\n\n            tm.assert_series_equal(clipped_df.loc[mask, i], df.loc[mask, i])",
        "begin_line": 2336,
        "end_line": 2362,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_clip_against_list_like#2373",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_clip_against_list_like(self, simple_frame, inplace, lower, axis, res)",
        "snippet": "    def test_clip_against_list_like(self, simple_frame, inplace, lower, axis, res):\n        # GH 15390\n        original = simple_frame.copy(deep=True)\n\n        result = original.clip(lower=lower, upper=[5, 6, 7], axis=axis, inplace=inplace)\n\n        expected = pd.DataFrame(res, columns=original.columns, index=original.index)\n        if inplace:\n            result = original\n        tm.assert_frame_equal(result, expected, check_exact=True)",
        "begin_line": 2373,
        "end_line": 2382,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_clip_against_frame#2385",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_clip_against_frame(self, axis)",
        "snippet": "    def test_clip_against_frame(self, axis):\n        df = DataFrame(np.random.randn(1000, 2))\n        lb = DataFrame(np.random.randn(1000, 2))\n        ub = lb + 1\n\n        clipped_df = df.clip(lb, ub, axis=axis)\n\n        lb_mask = df <= lb\n        ub_mask = df >= ub\n        mask = ~lb_mask & ~ub_mask\n\n        tm.assert_frame_equal(clipped_df[lb_mask], lb[lb_mask])\n        tm.assert_frame_equal(clipped_df[ub_mask], ub[ub_mask])\n        tm.assert_frame_equal(clipped_df[mask], df[mask])",
        "begin_line": 2385,
        "end_line": 2398,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_clip_against_unordered_columns#2400",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_clip_against_unordered_columns(self)",
        "snippet": "    def test_clip_against_unordered_columns(self):\n        # GH 20911\n        df1 = DataFrame(np.random.randn(1000, 4), columns=[\"A\", \"B\", \"C\", \"D\"])\n        df2 = DataFrame(np.random.randn(1000, 4), columns=[\"D\", \"A\", \"B\", \"C\"])\n        df3 = DataFrame(df2.values - 1, columns=[\"B\", \"D\", \"C\", \"A\"])\n        result_upper = df1.clip(lower=0, upper=df2)\n        expected_upper = df1.clip(lower=0, upper=df2[df1.columns])\n        result_lower = df1.clip(lower=df3, upper=3)\n        expected_lower = df1.clip(lower=df3[df1.columns], upper=3)\n        result_lower_upper = df1.clip(lower=df3, upper=df2)\n        expected_lower_upper = df1.clip(lower=df3[df1.columns], upper=df2[df1.columns])\n        tm.assert_frame_equal(result_upper, expected_upper)\n        tm.assert_frame_equal(result_lower, expected_lower)\n        tm.assert_frame_equal(result_lower_upper, expected_lower_upper)",
        "begin_line": 2400,
        "end_line": 2413,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_clip_with_na_args#2415",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_clip_with_na_args(self, float_frame)",
        "snippet": "    def test_clip_with_na_args(self, float_frame):\n        \"\"\"Should process np.nan argument as None \"\"\"\n        # GH 17276\n        tm.assert_frame_equal(float_frame.clip(np.nan), float_frame)\n        tm.assert_frame_equal(float_frame.clip(upper=np.nan, lower=np.nan), float_frame)\n\n        # GH 19992\n        df = DataFrame({\"col_0\": [1, 2, 3], \"col_1\": [4, 5, 6], \"col_2\": [7, 8, 9]})\n\n        result = df.clip(lower=[4, 5, np.nan], axis=0)\n        expected = DataFrame(\n            {\"col_0\": [4, 5, np.nan], \"col_1\": [4, 5, np.nan], \"col_2\": [7, 8, np.nan]}\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.clip(lower=[4, 5, np.nan], axis=1)\n        expected = DataFrame(\n            {\"col_0\": [4, 4, 4], \"col_1\": [5, 5, 6], \"col_2\": [np.nan, np.nan, np.nan]}\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2415,
        "end_line": 2434,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_dot#2439",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_dot(self)",
        "snippet": "    def test_dot(self):\n        a = DataFrame(\n            np.random.randn(3, 4), index=[\"a\", \"b\", \"c\"], columns=[\"p\", \"q\", \"r\", \"s\"]\n        )\n        b = DataFrame(\n            np.random.randn(4, 2), index=[\"p\", \"q\", \"r\", \"s\"], columns=[\"one\", \"two\"]\n        )\n\n        result = a.dot(b)\n        expected = DataFrame(\n            np.dot(a.values, b.values), index=[\"a\", \"b\", \"c\"], columns=[\"one\", \"two\"]\n        )\n        # Check alignment\n        b1 = b.reindex(index=reversed(b.index))\n        result = a.dot(b)\n        tm.assert_frame_equal(result, expected)\n\n        # Check series argument\n        result = a.dot(b[\"one\"])\n        tm.assert_series_equal(result, expected[\"one\"], check_names=False)\n        assert result.name is None\n\n        result = a.dot(b1[\"one\"])\n        tm.assert_series_equal(result, expected[\"one\"], check_names=False)\n        assert result.name is None\n\n        # can pass correct-length arrays\n        row = a.iloc[0].values\n\n        result = a.dot(row)\n        expected = a.dot(a.iloc[0])\n        tm.assert_series_equal(result, expected)\n\n        with pytest.raises(ValueError, match=\"Dot product shape mismatch\"):\n            a.dot(row[:-1])\n\n        a = np.random.rand(1, 5)\n        b = np.random.rand(5, 1)\n        A = DataFrame(a)\n\n        # TODO(wesm): unused\n        B = DataFrame(b)  # noqa\n\n        # it works\n        result = A.dot(b)\n\n        # unaligned\n        df = DataFrame(np.random.randn(3, 4), index=[1, 2, 3], columns=range(4))\n        df2 = DataFrame(np.random.randn(5, 3), index=range(5), columns=[1, 2, 3])\n\n        with pytest.raises(ValueError, match=\"aligned\"):\n            df.dot(df2)",
        "begin_line": 2439,
        "end_line": 2490,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_matmul#2492",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics",
        "signature": "pandas.tests.frame.test_analytics.TestDataFrameAnalytics.test_matmul(self)",
        "snippet": "    def test_matmul(self):\n        # matmul test is for GH 10259\n        a = DataFrame(\n            np.random.randn(3, 4), index=[\"a\", \"b\", \"c\"], columns=[\"p\", \"q\", \"r\", \"s\"]\n        )\n        b = DataFrame(\n            np.random.randn(4, 2), index=[\"p\", \"q\", \"r\", \"s\"], columns=[\"one\", \"two\"]\n        )\n\n        # DataFrame @ DataFrame\n        result = operator.matmul(a, b)\n        expected = DataFrame(\n            np.dot(a.values, b.values), index=[\"a\", \"b\", \"c\"], columns=[\"one\", \"two\"]\n        )\n        tm.assert_frame_equal(result, expected)\n\n        # DataFrame @ Series\n        result = operator.matmul(a, b.one)\n        expected = Series(np.dot(a.values, b.one.values), index=[\"a\", \"b\", \"c\"])\n        tm.assert_series_equal(result, expected)\n\n        # np.array @ DataFrame\n        result = operator.matmul(a.values, b)\n        assert isinstance(result, DataFrame)\n        assert result.columns.equals(b.columns)\n        assert result.index.equals(pd.Index(range(3)))\n        expected = np.dot(a.values, b.values)\n        tm.assert_almost_equal(result.values, expected)\n\n        # nested list @ DataFrame (__rmatmul__)\n        result = operator.matmul(a.values.tolist(), b)\n        expected = DataFrame(\n            np.dot(a.values, b.values), index=[\"a\", \"b\", \"c\"], columns=[\"one\", \"two\"]\n        )\n        tm.assert_almost_equal(result.values, expected.values)\n\n        # mixed dtype DataFrame @ DataFrame\n        a[\"q\"] = a.q.round().astype(int)\n        result = operator.matmul(a, b)\n        expected = DataFrame(\n            np.dot(a.values, b.values), index=[\"a\", \"b\", \"c\"], columns=[\"one\", \"two\"]\n        )\n        tm.assert_frame_equal(result, expected)\n\n        # different dtypes DataFrame @ DataFrame\n        a = a.astype(int)\n        result = operator.matmul(a, b)\n        expected = DataFrame(\n            np.dot(a.values, b.values), index=[\"a\", \"b\", \"c\"], columns=[\"one\", \"two\"]\n        )\n        tm.assert_frame_equal(result, expected)\n\n        # unaligned\n        df = DataFrame(np.random.randn(3, 4), index=[1, 2, 3], columns=range(4))\n        df2 = DataFrame(np.random.randn(5, 3), index=range(5), columns=[1, 2, 3])\n\n        with pytest.raises(ValueError, match=\"aligned\"):\n            operator.matmul(df, df2)",
        "begin_line": 2492,
        "end_line": 2549,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.df_duplicates#2553",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics",
        "signature": "pandas.tests.frame.test_analytics.df_duplicates()",
        "snippet": "def df_duplicates():\n    return pd.DataFrame(\n        {\"a\": [1, 2, 3, 4, 4], \"b\": [1, 1, 1, 1, 1], \"c\": [0, 1, 2, 5, 4]},\n        index=[0, 0, 1, 1, 1],\n    )",
        "begin_line": 2553,
        "end_line": 2557,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.df_strings#2561",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics",
        "signature": "pandas.tests.frame.test_analytics.df_strings()",
        "snippet": "def df_strings():\n    return pd.DataFrame(\n        {\n            \"a\": np.random.permutation(10),\n            \"b\": list(ascii_lowercase[:10]),\n            \"c\": np.random.permutation(10).astype(\"float64\"),\n        }\n    )",
        "begin_line": 2561,
        "end_line": 2568,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.df_main_dtypes#2572",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics",
        "signature": "pandas.tests.frame.test_analytics.df_main_dtypes()",
        "snippet": "def df_main_dtypes():\n    return pd.DataFrame(\n        {\n            \"group\": [1, 1, 2],\n            \"int\": [1, 2, 3],\n            \"float\": [4.0, 5.0, 6.0],\n            \"string\": list(\"abc\"),\n            \"category_string\": pd.Series(list(\"abc\")).astype(\"category\"),\n            \"category_int\": [7, 8, 9],\n            \"datetime\": pd.date_range(\"20130101\", periods=3),\n            \"datetimetz\": pd.date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n            \"timedelta\": pd.timedelta_range(\"1 s\", periods=3, freq=\"s\"),\n        },\n        columns=[\n            \"group\",\n            \"int\",\n            \"float\",\n            \"string\",\n            \"category_string\",\n            \"category_int\",\n            \"datetime\",\n            \"datetimetz\",\n            \"timedelta\",\n        ],\n    )",
        "begin_line": 2572,
        "end_line": 2596,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_n#2622",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_n(self, df_strings, nselect_method, n, order)",
        "snippet": "    def test_n(self, df_strings, nselect_method, n, order):\n        # GH 10393\n        df = df_strings\n        if \"b\" in order:\n\n            error_msg = (\n                f\"Column 'b' has dtype object, \"\n                f\"cannot use method '{nselect_method}' with this dtype\"\n            )\n            with pytest.raises(TypeError, match=error_msg):\n                getattr(df, nselect_method)(n, order)\n        else:\n            ascending = nselect_method == \"nsmallest\"\n            result = getattr(df, nselect_method)(n, order)\n            expected = df.sort_values(order, ascending=ascending).head(n)\n            tm.assert_frame_equal(result, expected)",
        "begin_line": 2622,
        "end_line": 2637,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_n_error#2642",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_n_error(self, df_main_dtypes, nselect_method, columns)",
        "snippet": "    def test_n_error(self, df_main_dtypes, nselect_method, columns):\n        df = df_main_dtypes\n        col = columns[1]\n        error_msg = (\n            f\"Column '{col}' has dtype {df[col].dtype}, \"\n            f\"cannot use method '{nselect_method}' with this dtype\"\n        )\n        # escape some characters that may be in the repr\n        error_msg = (\n            error_msg.replace(\"(\", \"\\\\(\")\n            .replace(\")\", \"\\\\)\")\n            .replace(\"[\", \"\\\\[\")\n            .replace(\"]\", \"\\\\]\")\n        )\n        with pytest.raises(TypeError, match=error_msg):\n            getattr(df, nselect_method)(2, columns)",
        "begin_line": 2642,
        "end_line": 2657,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_n_all_dtypes#2659",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_n_all_dtypes(self, df_main_dtypes)",
        "snippet": "    def test_n_all_dtypes(self, df_main_dtypes):\n        df = df_main_dtypes\n        df.nsmallest(2, list(set(df) - {\"category_string\", \"string\"}))\n        df.nlargest(2, list(set(df) - {\"category_string\", \"string\"}))",
        "begin_line": 2659,
        "end_line": 2662,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_duplicates_on_starter_columns#2681",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_duplicates_on_starter_columns(self, method, expected)",
        "snippet": "    def test_duplicates_on_starter_columns(self, method, expected):\n        # regression test for #22752\n\n        df = pd.DataFrame({\"a\": [2, 2, 2, 1, 1, 1], \"b\": [1, 2, 3, 3, 2, 1]})\n\n        result = getattr(df, method)(4, columns=[\"a\", \"b\"])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2681,
        "end_line": 2687,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_n_identical_values#2689",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_n_identical_values(self)",
        "snippet": "    def test_n_identical_values(self):\n        # GH 15297\n        df = pd.DataFrame({\"a\": [1] * 5, \"b\": [1, 2, 3, 4, 5]})\n\n        result = df.nlargest(3, \"a\")\n        expected = pd.DataFrame({\"a\": [1] * 3, \"b\": [1, 2, 3]}, index=[0, 1, 2])\n        tm.assert_frame_equal(result, expected)\n\n        result = df.nsmallest(3, \"a\")\n        expected = pd.DataFrame({\"a\": [1] * 3, \"b\": [1, 2, 3]})\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2689,
        "end_line": 2699,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_n_duplicate_index#2706",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_n_duplicate_index(self, df_duplicates, n, order)",
        "snippet": "    def test_n_duplicate_index(self, df_duplicates, n, order):\n        # GH 13412\n\n        df = df_duplicates\n        result = df.nsmallest(n, order)\n        expected = df.sort_values(order).head(n)\n        tm.assert_frame_equal(result, expected)\n\n        result = df.nlargest(n, order)\n        expected = df.sort_values(order, ascending=False).head(n)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2706,
        "end_line": 2716,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_duplicate_keep_all_ties#2718",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_duplicate_keep_all_ties(self)",
        "snippet": "    def test_duplicate_keep_all_ties(self):\n        # GH 16818\n        df = pd.DataFrame(\n            {\"a\": [5, 4, 4, 2, 3, 3, 3, 3], \"b\": [10, 9, 8, 7, 5, 50, 10, 20]}\n        )\n        result = df.nlargest(4, \"a\", keep=\"all\")\n        expected = pd.DataFrame(\n            {\n                \"a\": {0: 5, 1: 4, 2: 4, 4: 3, 5: 3, 6: 3, 7: 3},\n                \"b\": {0: 10, 1: 9, 2: 8, 4: 5, 5: 50, 6: 10, 7: 20},\n            }\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.nsmallest(2, \"a\", keep=\"all\")\n        expected = pd.DataFrame(\n            {\n                \"a\": {3: 2, 4: 3, 5: 3, 6: 3, 7: 3},\n                \"b\": {3: 7, 4: 5, 5: 50, 6: 10, 7: 20},\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2718,
        "end_line": 2739,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_series_broadcasting#2741",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_series_broadcasting(self)",
        "snippet": "    def test_series_broadcasting(self):\n        # smoke test for numpy warnings\n        # GH 16378, GH 16306\n        df = DataFrame([1.0, 1.0, 1.0])\n        df_nan = DataFrame({\"A\": [np.nan, 2.0, np.nan]})\n        s = Series([1, 1, 1])\n        s_nan = Series([np.nan, np.nan, 1])\n\n        with tm.assert_produces_warning(None):\n            df_nan.clip(lower=s, axis=0)\n            for op in [\"lt\", \"le\", \"gt\", \"ge\", \"eq\", \"ne\"]:\n                getattr(df, op)(s_nan, axis=0)",
        "begin_line": 2741,
        "end_line": 2752,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_series_nat_conversion#2754",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_series_nat_conversion(self)",
        "snippet": "    def test_series_nat_conversion(self):\n        # GH 18521\n        # Check rank does not mutate DataFrame\n        df = DataFrame(np.random.randn(10, 3), dtype=\"float64\")\n        expected = df.copy()\n        df.rank()\n        result = df\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2754,
        "end_line": 2761,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_multiindex_column_lookup#2763",
        "src_path": "pandas/tests/frame/test_analytics.py",
        "class_name": "pandas.tests.frame.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.frame.test_analytics.TestNLargestNSmallest.test_multiindex_column_lookup(self)",
        "snippet": "    def test_multiindex_column_lookup(self):\n        # Check whether tuples are correctly treated as multi-level lookups.\n        # GH 23033\n        df = pd.DataFrame(\n            columns=pd.MultiIndex.from_product([[\"x\"], [\"a\", \"b\"]]),\n            data=[[0.33, 0.13], [0.86, 0.25], [0.25, 0.70], [0.85, 0.91]],\n        )\n\n        # nsmallest\n        result = df.nsmallest(3, (\"x\", \"a\"))\n        expected = df.iloc[[2, 0, 3]]\n        tm.assert_frame_equal(result, expected)\n\n        # nlargest\n        result = df.nlargest(3, (\"x\", \"b\"))\n        expected = df.iloc[[3, 2, 1]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2763,
        "end_line": 2779,
        "comment": "",
        "is_bug": false
    }
]