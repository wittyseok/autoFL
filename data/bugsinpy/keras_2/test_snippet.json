[
    {
        "name": "tests.keras.legacy.conftest.clear_session_after_test#6",
        "src_path": "tests/keras/legacy/conftest.py",
        "class_name": "tests.keras.legacy.conftest",
        "signature": "tests.keras.legacy.conftest.clear_session_after_test()",
        "snippet": "def clear_session_after_test():\n    \"\"\"This wrapper runs for all the tests in the legacy directory (recursively).\n    \"\"\"\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore', message=r'(.+) Keras 2 ',\n                                category=UserWarning)\n        yield",
        "begin_line": 6,
        "end_line": 12,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.check_dtype#46",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.check_dtype(var, dtype)",
        "snippet": "def check_dtype(var, dtype):\n    if K.backend() == 'theano':\n        assert var.dtype == dtype\n    else:\n        assert var.dtype.name == '%s_ref' % dtype",
        "begin_line": 46,
        "end_line": 50,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.cntk_func_tensors#53",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.cntk_func_tensors(function_name, shapes_or_vals, **kwargs)",
        "snippet": "def cntk_func_tensors(function_name, shapes_or_vals, **kwargs):\n    placeholders = []\n    variables = []\n    for shape_or_val in shapes_or_vals:\n        if isinstance(shape_or_val, tuple):\n            shape = shape_or_val\n            placeholders.append(KC.placeholder(shape))\n        else:\n            value = shape_or_val\n            variables.append(KC.variable(value))\n\n    output_cntk = getattr(KC, function_name)(*(placeholders + variables), **kwargs)\n    cntk_func = KC.function(placeholders, [output_cntk])\n    return output_cntk, cntk_func",
        "begin_line": 53,
        "end_line": 66,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.parse_shape_or_val#69",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.parse_shape_or_val(shape_or_val)",
        "snippet": "def parse_shape_or_val(shape_or_val):\n    if isinstance(shape_or_val, np.ndarray):\n        return shape_or_val.shape, shape_or_val\n    else:\n        return shape_or_val, np.random.random(shape_or_val).astype(np.float32) - 0.5",
        "begin_line": 69,
        "end_line": 73,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.assert_list_pairwise#76",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.assert_list_pairwise(z_list, shape=True, allclose=True, itself=False, atol=1e-05)",
        "snippet": "def assert_list_pairwise(z_list,\n                         shape=True,\n                         allclose=True,\n                         itself=False,\n                         atol=1e-05):\n    for (z1, z2) in zip(z_list[1:], z_list[:-1]):\n        if shape:\n            assert z1.shape == z2.shape\n        if allclose:\n            assert_allclose(z1, z2, atol=atol)\n        if itself:\n            assert z1 == z2",
        "begin_line": 76,
        "end_line": 87,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.assert_list_keras_shape#90",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.assert_list_keras_shape(t_list, z_list)",
        "snippet": "def assert_list_keras_shape(t_list, z_list):\n    for t, z in zip(t_list, z_list):\n        if hasattr(t, '_keras_shape') and len(t._keras_shape) > 1:\n            for i, s in enumerate(t._keras_shape):\n                if s:\n                    assert t._keras_shape[i] == z.shape[i]",
        "begin_line": 90,
        "end_line": 95,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.check_single_tensor_operation#98",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.check_single_tensor_operation(function_name, x_shape_or_val, backend_list, **kwargs)",
        "snippet": "def check_single_tensor_operation(function_name,\n                                  x_shape_or_val,\n                                  backend_list,\n                                  **kwargs):\n    shape_or_val = kwargs.pop('shape_or_val', True)\n    assert_value_equality = kwargs.pop('assert_value_equality', True)\n    cntk_dynamicity = kwargs.pop('cntk_dynamicity', False)\n\n    if shape_or_val:\n        x_shape, x_val = parse_shape_or_val(x_shape_or_val)\n\n    t_list = []\n    z_list = []\n    for k in backend_list:\n        if shape_or_val:\n            if (k == KC) & (cntk_dynamicity):\n                t, f = cntk_func_tensors(function_name, [x_shape], **kwargs)\n                z = f([x_val])[0]\n            else:\n                t = getattr(k, function_name)(k.variable(x_val), **kwargs)\n                z = k.eval(t)\n        else:\n            t = getattr(k, function_name)(x_shape_or_val, **kwargs)\n            z = k.eval(t)\n        t_list += [t]\n        z_list += [z]\n\n    assert_list_pairwise(z_list, allclose=assert_value_equality)\n    assert_list_keras_shape(t_list, z_list)",
        "begin_line": 98,
        "end_line": 126,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.check_two_tensor_operation#129",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.check_two_tensor_operation(function_name, x_shape_or_val, y_shape_or_val, backend_list, **kwargs)",
        "snippet": "def check_two_tensor_operation(function_name,\n                               x_shape_or_val,\n                               y_shape_or_val,\n                               backend_list,\n                               **kwargs):\n    concat_args = kwargs.pop('concat_args', False)\n    cntk_dynamicity = kwargs.pop('cntk_dynamicity', False)\n    cntk_two_dynamicity = kwargs.pop('cntk_two_dynamicity', False)\n\n    x_shape, x_val = parse_shape_or_val(x_shape_or_val)\n    y_shape, y_val = parse_shape_or_val(y_shape_or_val)\n\n    t_list = []\n    z_list = []\n    for k in backend_list:\n        if (k == KC) & (cntk_dynamicity):\n            t, f = cntk_func_tensors(function_name, [x_shape, y_val], **kwargs)\n            z = f([x_val])[0]\n        elif (k == KC) & (cntk_two_dynamicity):\n            t, f = cntk_func_tensors(function_name, [x_shape, y_shape], **kwargs)\n            z = f([x_val, y_val])[0]\n        elif (k == KTH) & (function_name[:4] == 'conv'):\n            t = getattr(k, function_name)(\n                k.variable(x_val), k.variable(convert_kernel(y_val)), **kwargs)\n            z = k.eval(t)\n        elif concat_args:\n            t = getattr(k, function_name)(\n                [k.variable(x_val), k.variable(y_val)], **kwargs)\n            z = k.eval(t)\n        else:\n            t = getattr(k, function_name)(\n                k.variable(x_val), k.variable(y_val), **kwargs)\n            z = k.eval(t)\n        t_list += [t]\n        z_list += [z]\n\n    assert_list_pairwise(z_list)\n    assert_list_keras_shape(t_list, z_list)",
        "begin_line": 129,
        "end_line": 166,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.check_composed_tensor_operations#169",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.check_composed_tensor_operations(first_function_name, first_function_args, second_function_name, second_function_args, input_shape, backend_list)",
        "snippet": "def check_composed_tensor_operations(first_function_name,\n                                     first_function_args,\n                                     second_function_name,\n                                     second_function_args,\n                                     input_shape,\n                                     backend_list):\n    val = np.random.random(input_shape) - 0.5\n\n    z_list = []\n    for k in backend_list:\n        x = k.variable(val)\n        y = getattr(k, first_function_name)(x, **first_function_args)\n        z = k.eval(getattr(k, second_function_name)(y, **second_function_args))\n        z_list += [z]\n\n    assert_list_pairwise(z_list)",
        "begin_line": 169,
        "end_line": 184,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.check_rnn_operation#187",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.check_rnn_operation(step_function_k, step_function_np, inputs_np, initial_states_np, mask_np=None, constants_np=None, **kwargs)",
        "snippet": "def check_rnn_operation(step_function_k,\n                        step_function_np,\n                        inputs_np,\n                        initial_states_np,\n                        mask_np=None,\n                        constants_np=None,\n                        **kwargs):\n    inputs_k = K.variable(inputs_np)\n    initial_states_k = [K.variable(s) for s in initial_states_np]\n    if mask_np is not None:\n        mask_k = K.variable(mask_np)\n    else:\n        mask_k = None\n    if constants_np is not None:\n        constants_k = [K.variable(c) for c in constants_np]\n    else:\n        constants_k = None\n\n    last_output_np, output_np, last_states_np = KNP.rnn(\n        step_function_np,\n        inputs_np,\n        initial_states_np,\n        mask=mask_np,\n        constants=constants_np,\n        **kwargs)\n    # note that numpy reference implementation is independent of `unroll` argument\n\n    for unroll in [True, False]:\n        last_output_k, output_k, last_states_k = K.rnn(\n            step_function_k,\n            inputs_k,\n            initial_states_k,\n            mask=mask_k,\n            constants=constants_k,\n            unroll=unroll,\n            input_length=inputs_np.shape[1] if unroll else None,\n            **kwargs)\n\n        last_states_k = [K.eval(s) for s in last_states_k]\n        last_output_k = K.eval(last_output_k)\n        output_k = K.eval(output_k)\n\n        assert_allclose(last_output_k, last_output_np, atol=1e-05)\n        assert_allclose(output_k, output_np, atol=1e-05)\n        assert len(last_states_k) == len(last_states_np)\n        for s_k, s_np in zip(last_states_k, last_states_np):\n            assert_allclose(s_k, s_np, atol=1e-05)",
        "begin_line": 187,
        "end_line": 233,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_is_keras_tensor#238",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_is_keras_tensor(self)",
        "snippet": "    def test_is_keras_tensor(self):\n        np_var = np.array([1, 2])\n        with pytest.raises(ValueError):\n            K.is_keras_tensor(np_var)\n\n        keras_var = K.variable(np_var)\n        assert K.is_keras_tensor(keras_var) is False\n        keras_placeholder = K.placeholder(shape=(2, 4, 5))\n        assert K.is_keras_tensor(keras_placeholder) is False",
        "begin_line": 238,
        "end_line": 246,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_set_learning_phase#248",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_set_learning_phase(self)",
        "snippet": "    def test_set_learning_phase(self):\n        # not supported learning_phase\n        with pytest.raises(ValueError):\n            K.set_learning_phase(2)",
        "begin_line": 248,
        "end_line": 251,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_eye#253",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_eye(self)",
        "snippet": "    def test_eye(self):\n        check_single_tensor_operation('eye', 3, WITH_NP, shape_or_val=False)",
        "begin_line": 253,
        "end_line": 254,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_ones#256",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_ones(self)",
        "snippet": "    def test_ones(self):\n        check_single_tensor_operation('ones', (3, 5, 10, 8),\n                                      WITH_NP, shape_or_val=False)",
        "begin_line": 256,
        "end_line": 258,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_zeros#260",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_zeros(self)",
        "snippet": "    def test_zeros(self):\n        check_single_tensor_operation('zeros', (3, 5, 10, 8),\n                                      WITH_NP, shape_or_val=False)",
        "begin_line": 260,
        "end_line": 262,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_ones_like#264",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_ones_like(self)",
        "snippet": "    def test_ones_like(self):\n        check_single_tensor_operation('ones_like', (3, 5, 10, 8),\n                                      WITH_NP, shape_or_val=True)",
        "begin_line": 264,
        "end_line": 266,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_zeros_like#268",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_zeros_like(self)",
        "snippet": "    def test_zeros_like(self):\n        check_single_tensor_operation('zeros_like', (3, 5, 10, 8),\n                                      WITH_NP, shape_or_val=True)",
        "begin_line": 268,
        "end_line": 270,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_linear_operations#272",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_linear_operations(self)",
        "snippet": "    def test_linear_operations(self):\n        check_two_tensor_operation('dot', (4, 2), (2, 4), WITH_NP)\n        check_two_tensor_operation('dot', (4, 2), (5, 2, 3), WITH_NP)\n\n        check_two_tensor_operation('batch_dot', (4, 2, 3), (4, 5, 3),\n                                   WITH_NP, cntk_two_dynamicity=True, axes=(2, 2))\n        check_two_tensor_operation('batch_dot', (4, 2, 3), (4, 3),\n                                   WITH_NP, cntk_two_dynamicity=True, axes=(2, 1))\n        check_two_tensor_operation('batch_dot', (4, 2), (4, 2, 3),\n                                   WITH_NP, cntk_two_dynamicity=True, axes=(1, 1))\n        check_two_tensor_operation('batch_dot', (32, 20), (32, 20),\n                                   WITH_NP, cntk_two_dynamicity=True, axes=1)\n        check_two_tensor_operation('batch_dot', (32, 20), (32, 20),\n                                   WITH_NP, cntk_two_dynamicity=True, axes=(1, 1))\n        check_two_tensor_operation('batch_dot', (4, 2, 3), (4, 5, 3),\n                                   WITH_NP, axes=(2, 2))\n        check_two_tensor_operation('batch_dot', (4, 2, 3), (4, 3),\n                                   WITH_NP, axes=(2, 1))\n        check_two_tensor_operation('batch_dot', (4, 2), (4, 2, 3),\n                                   WITH_NP, axes=(1, 1))\n        check_two_tensor_operation('batch_dot', (32, 20), (32, 20),\n                                   WITH_NP, axes=1)\n        check_two_tensor_operation('batch_dot', (32, 20), (32, 20),\n                                   WITH_NP, axes=(1, 1))\n\n        check_single_tensor_operation('transpose', (4, 2), WITH_NP)\n        check_single_tensor_operation('reverse', (4, 3, 2), WITH_NP, axes=1)\n        if K.backend() != 'cntk':\n            check_single_tensor_operation('reverse', (4, 3, 2), WITH_NP, axes=(1, 2))",
        "begin_line": 272,
        "end_line": 300,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_random_variables#302",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_random_variables(self)",
        "snippet": "    def test_random_variables(self):\n        check_single_tensor_operation('random_uniform_variable', (2, 3), WITH_NP,\n                                      low=0., high=1.,\n                                      shape_or_val=False,\n                                      assert_value_equality=False)\n        check_single_tensor_operation('random_normal_variable', (2, 3), WITH_NP,\n                                      mean=0., scale=1.,\n                                      shape_or_val=False,\n                                      assert_value_equality=False)",
        "begin_line": 302,
        "end_line": 310,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_batch_dot_shape#312",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_batch_dot_shape(self)",
        "snippet": "    def test_batch_dot_shape(self):\n        # Note : batch_dot implementation is different for\n        # placeholders and variables in CNTK backend\n\n        test_cases = []\n        test_cases.append([(None, 3, 4, 5), (None, 2, 3, 4), (2, 3)])\n        test_cases.append([(None, 3, 4, 5), (None, 2, 4), 2])\n        test_cases.append([(None, 3, 4), (None, 2, 3, 4), (2, 3)])\n        test_cases.append([(None, 4, 3), (None, 3, 5), (2, 1)])\n        test_cases.append([(None, 4), (None, 3, 4), (1, 2)])\n        test_cases.append([(None, 4), (None, 4), None])\n\n        batch_size = 7\n\n        def batch_shape(shape):\n            return (batch_size, ) + shape[1:]\n\n        def random(shape):\n            return np.random.random(batch_shape(shape))\n\n        for x_shape, y_shape, axes in test_cases:\n            x_np = random(x_shape)\n            y_np = random(y_shape)\n            z_np = KNP.batch_dot(x_np, y_np, axes)\n\n            # test with placeholders\n            x = K.placeholder(shape=x_shape)\n            y = K.placeholder(shape=y_shape)\n            z = K.batch_dot(x, y, axes)\n\n            z_shape = K.int_shape(z)\n            if z_shape is not None:\n                assert z_shape[1:] == z_np.shape[1:]\n\n            f = K.function([x, y], [z])\n\n            assert_allclose(f([x_np, y_np])[0], z_np, atol=1e-05)\n\n            # test with placeholders (no shape info)\n            if K.backend() != 'cntk':\n                x = K.placeholder(ndim=len(x_shape))\n                y = K.placeholder(ndim=len(y_shape))\n                z = K.batch_dot(x, y, axes)\n\n                z_shape = K.int_shape(z)\n                if z_shape is not None:\n                    assert len(z_shape) == z_np.ndim\n                    assert set(z_shape) <= set((None, 1))\n\n                f = K.function([x, y], [z])\n\n                assert_allclose(f([x_np, y_np])[0], z_np, atol=1e-05)\n\n            # test with variables\n            x = K.variable(x_np)\n            y = K.variable(y_np)\n            z = K.batch_dot(x, y, axes)\n\n            z_shape = K.int_shape(z)\n            if z_shape is not None:\n                assert z_shape[1:] == z_np.shape[1:]\n\n            z = K.eval(z)\n            assert_allclose(z, z_np, atol=1e-05)",
        "begin_line": 312,
        "end_line": 375,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.batch_shape#326",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.batch_shape(shape)",
        "snippet": "        def batch_shape(shape):\n            return (batch_size, ) + shape[1:]",
        "begin_line": 326,
        "end_line": 327,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.random#329",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.random(shape)",
        "snippet": "        def random(shape):\n            return np.random.random(batch_shape(shape))",
        "begin_line": 329,
        "end_line": 330,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_shape_operations#377",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_shape_operations(self)",
        "snippet": "    def test_shape_operations(self):\n        check_two_tensor_operation('concatenate', (4, 3), (4, 2), WITH_NP,\n                                   axis=-1, concat_args=True)\n\n        check_single_tensor_operation('reshape', (4, 2), WITH_NP, shape=(8, 1))\n        check_single_tensor_operation('permute_dimensions', (4, 2, 3), WITH_NP,\n                                      pattern=(2, 0, 1))\n        check_single_tensor_operation('repeat', (4, 1), WITH_NP, n=3)\n        check_single_tensor_operation('flatten', (4, 1), WITH_NP)\n        check_single_tensor_operation('batch_flatten', (20, 2, 5), WITH_NP,\n                                      cntk_dynamicity=True)\n        check_single_tensor_operation('expand_dims', (4, 3), WITH_NP, axis=-1)\n        check_single_tensor_operation('expand_dims', (4, 3, 2), WITH_NP, axis=1)\n        check_single_tensor_operation('squeeze', (4, 3, 1), WITH_NP, axis=2)\n        check_single_tensor_operation('squeeze', (4, 1, 1), WITH_NP, axis=1)\n        check_composed_tensor_operations('reshape', {'shape': (4, 3, 1, 1)},\n                                         'squeeze', {'axis': 2},\n                                         (4, 3, 1, 1), WITH_NP)",
        "begin_line": 377,
        "end_line": 394,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_none_shape_operations#399",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_none_shape_operations(self)",
        "snippet": "    def test_none_shape_operations(self):\n        # Test shape inference when input\n        # shape has `None` entries\n        x = K.placeholder((3, None, 4))\n\n        y = K.batch_flatten(x)\n        if hasattr(y, '_keras_shape'):\n            assert y._keras_shape == (3, None)\n\n        y = K.flatten(x)\n        if hasattr(y, '_keras_shape'):\n            assert y._keras_shape == (None,)",
        "begin_line": 399,
        "end_line": 410,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_repeat_elements#412",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_repeat_elements(self)",
        "snippet": "    def test_repeat_elements(self):\n        reps = 3\n        for ndims in [1, 2, 3]:\n            shape = np.arange(2, 2 + ndims)\n            arr = np.arange(np.prod(shape)).reshape(shape)\n\n            for rep_axis in range(ndims):\n                check_single_tensor_operation('repeat_elements', arr, WITH_NP,\n                                              rep=reps, axis=rep_axis)\n\n                if K.backend() != 'cntk':\n                    shape = list(shape)\n                    shape[rep_axis] = None\n                    x = K.placeholder(shape=shape)\n                    y = K.repeat_elements(x, reps, axis=rep_axis)\n                    assert y._keras_shape == tuple(shape)\n                    assert y._keras_shape == K.int_shape(y)",
        "begin_line": 412,
        "end_line": 428,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_tile#430",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_tile(self)",
        "snippet": "    def test_tile(self):\n        shape = (3, 4)\n        arr = np.arange(np.prod(shape)).reshape(shape)\n        check_single_tensor_operation('tile', arr, WITH_NP, n=[2, 1])\n        check_single_tensor_operation('tile', (2, 5), WITH_NP, n=[5, 2])\n\n        # test theano shape inference when\n        # input shape has None entries\n        if K.backend() == 'theano':\n            x = K.placeholder(shape=(None, 4))\n            n = 2\n            y = K.tile(x, n)\n            assert y._keras_shape == (None, 8)\n            n = (4, 3)\n            y = K.tile(x, n)\n            assert y._keras_shape == (None, 12)",
        "begin_line": 430,
        "end_line": 445,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_gather#447",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_gather(self)",
        "snippet": "    def test_gather(self):\n        shape = (10, 2, 3)\n        ref = np.arange(np.prod(shape)).reshape(shape)\n        inds = [1, 3, 7, 9]\n        t_list = [k.gather(k.variable(ref), k.variable(inds, dtype='int32'))\n                  for k in WITH_NP]\n        z_list = [k.eval(k.gather(k.variable(ref), k.variable(inds, dtype='int32')))\n                  for k in WITH_NP]\n\n        assert_list_pairwise(z_list)\n        assert_list_keras_shape(t_list, z_list)\n\n        # test theano shape inference when\n        # input shape has None entries\n        if K.backend() == 'theano':\n            x = K.placeholder(shape=(None, 3, 4))\n            indices = K.placeholder(shape=(5, 6), dtype='int32')\n            y = K.gather(x, indices)\n            assert y._keras_shape == (5, 6, 3, 4)",
        "begin_line": 447,
        "end_line": 465,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_value_manipulation#470",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_value_manipulation(self, function_name)",
        "snippet": "    def test_value_manipulation(self, function_name):\n        val = np.random.random((4, 2))\n        v_list = [getattr(k, function_name)(k.variable(val))\n                  for k in WITH_NP]\n\n        if function_name == 'get_value':\n            assert_list_pairwise(v_list)\n        else:\n            assert_list_pairwise(v_list, shape=False, allclose=False, itself=True)",
        "begin_line": 470,
        "end_line": 478,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_print_tensor#480",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_print_tensor(self)",
        "snippet": "    def test_print_tensor(self):\n        check_single_tensor_operation('print_tensor', (), WITH_NP)\n        check_single_tensor_operation('print_tensor', (2,), WITH_NP)\n        check_single_tensor_operation('print_tensor', (4, 3), WITH_NP)\n        check_single_tensor_operation('print_tensor', (1, 2, 3), WITH_NP)",
        "begin_line": 480,
        "end_line": 484,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_elementwise_operations#486",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_elementwise_operations(self)",
        "snippet": "    def test_elementwise_operations(self):\n        check_single_tensor_operation('max', (4, 2), WITH_NP)\n        check_single_tensor_operation('max', (4, 2), WITH_NP, axis=1, keepdims=True)\n        check_single_tensor_operation('max', (4, 2, 3), WITH_NP, axis=[1, -1])\n\n        check_single_tensor_operation('min', (4, 2), WITH_NP)\n        check_single_tensor_operation('min', (4, 2), WITH_NP, axis=1, keepdims=True)\n        check_single_tensor_operation('min', (4, 2, 3), WITH_NP, axis=[1, -1])\n\n        check_single_tensor_operation('mean', (4, 2), WITH_NP)\n        check_single_tensor_operation('mean', (4, 2), WITH_NP, axis=1, keepdims=True)\n        check_single_tensor_operation('mean', (4, 2, 3),\n                                      WITH_NP, axis=-1, keepdims=True)\n        check_single_tensor_operation('mean', (4, 2, 3), WITH_NP, axis=[1, -1])\n\n        check_single_tensor_operation('var', (4, 2), WITH_NP)\n        check_single_tensor_operation('var', (4, 2), WITH_NP, axis=1, keepdims=True)\n        check_single_tensor_operation('var', (4, 2, 3), WITH_NP, axis=[1, -1])\n\n        check_single_tensor_operation('std', (4, 2), WITH_NP)\n        check_single_tensor_operation('std', (4, 2), WITH_NP, axis=1, keepdims=True)\n        check_single_tensor_operation('std', (4, 2, 3), WITH_NP, axis=[1, -1])\n\n        check_single_tensor_operation('logsumexp', (4, 2), WITH_NP)\n        check_single_tensor_operation('logsumexp', (4, 2),\n                                      WITH_NP, axis=1, keepdims=True)\n        check_single_tensor_operation('logsumexp', (4, 2, 3), WITH_NP, axis=[1, -1])\n\n        check_single_tensor_operation('prod', (4, 2), WITH_NP)\n        check_single_tensor_operation('prod', (4, 2), WITH_NP, axis=1, keepdims=True)\n        check_single_tensor_operation('prod', (4, 2, 3), WITH_NP, axis=[1, -1])\n\n        check_single_tensor_operation('any', (4, 2), WITH_NP)\n        check_single_tensor_operation('any', (4, 2), WITH_NP, axis=1, keepdims=True)\n        check_single_tensor_operation('any', (4, 2, 3), WITH_NP, axis=[1, -1])\n\n        check_single_tensor_operation('all', (4, 2), WITH_NP)\n        check_single_tensor_operation('all', (4, 2), WITH_NP, axis=1, keepdims=True)\n        check_single_tensor_operation('all', (4, 2, 3), WITH_NP, axis=[1, -1])\n\n        check_single_tensor_operation('argmax', (4, 2), WITH_NP)\n        check_single_tensor_operation('argmax', (4, 2), WITH_NP, axis=1)\n\n        check_single_tensor_operation('argmin', (4, 2), WITH_NP)\n        check_single_tensor_operation('argmin', (4, 2), WITH_NP, axis=1)\n\n        check_single_tensor_operation('square', (4, 2), WITH_NP)\n        check_single_tensor_operation('abs', (4, 2), WITH_NP)\n        check_single_tensor_operation('sqrt', (4, 2), WITH_NP)\n        check_single_tensor_operation('exp', (4, 2), WITH_NP)\n\n        check_single_tensor_operation('round', (4, 2), WITH_NP)\n        check_single_tensor_operation('sign', (4, 2), WITH_NP)\n        check_single_tensor_operation('pow', (4, 2), WITH_NP, a=3)\n        check_single_tensor_operation('clip', (4, 2), WITH_NP, min_value=0.4,\n                                      max_value=0.6)\n\n        check_single_tensor_operation('cos', (4, 2), WITH_NP)\n        check_single_tensor_operation('sin', (4, 2), WITH_NP)\n\n        # two-tensor ops\n        check_two_tensor_operation('equal', (4, 2), (4, 2), WITH_NP)\n        check_two_tensor_operation('not_equal', (4, 2), (4, 2), WITH_NP)\n        check_two_tensor_operation('greater', (4, 2), (4, 2), WITH_NP)\n        check_two_tensor_operation('greater_equal', (4, 2), (4, 2), WITH_NP)\n        check_two_tensor_operation('less', (4, 2), (4, 2), WITH_NP)\n        check_two_tensor_operation('less_equal', (4, 2), (4, 2), WITH_NP)\n        check_two_tensor_operation('maximum', (4, 2), (4, 2), WITH_NP)\n        check_two_tensor_operation('minimum', (4, 2), (4, 2), WITH_NP)",
        "begin_line": 486,
        "end_line": 554,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_reset_uids#557",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_reset_uids(self)",
        "snippet": "    def test_reset_uids(self):\n        first = K.get_uid()\n        K.get_uid()\n        K.reset_uids()\n        assert K.get_uid() == first",
        "begin_line": 557,
        "end_line": 561,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_cumsum#565",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_cumsum(self)",
        "snippet": "    def test_cumsum(self):\n        check_single_tensor_operation('cumsum', (4, 2), WITH_NP)\n        check_single_tensor_operation('cumsum', (4, 2), WITH_NP, axis=1)",
        "begin_line": 565,
        "end_line": 567,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_cumprod#571",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_cumprod(self)",
        "snippet": "    def test_cumprod(self):\n        check_single_tensor_operation('cumprod', (4, 2), WITH_NP)\n        check_single_tensor_operation('cumprod', (4, 2), WITH_NP, axis=1)",
        "begin_line": 571,
        "end_line": 573,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_log#579",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_log(self)",
        "snippet": "    def test_log(self):\n        check_single_tensor_operation('log', (4, 2), WITH_NP)",
        "begin_line": 579,
        "end_line": 580,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_update_add#584",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_update_add(self)",
        "snippet": "    def test_update_add(self):\n        x = np.random.randn(3, 4)\n        x_var = K.variable(x)\n        increment = np.random.randn(3, 4)\n\n        x += increment\n        K.eval(K.update_add(x_var, increment))\n\n        assert_allclose(x, K.eval(x_var), atol=1e-05)",
        "begin_line": 584,
        "end_line": 592,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_update_sub#596",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_update_sub(self)",
        "snippet": "    def test_update_sub(self):\n        x = np.random.randn(3, 4)\n        x_var = K.variable(x)\n        decrement = np.random.randn(3, 4)\n\n        x -= decrement\n        K.eval(K.update_sub(x_var, decrement))\n\n        assert_allclose(x, K.eval(x_var), atol=1e-05)",
        "begin_line": 596,
        "end_line": 604,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_gradient#608",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_gradient(self)",
        "snippet": "    def test_gradient(self):\n        val = np.random.random((4, 2))\n        x_list = [k.variable(val) for k in [KTH, KTF]]\n        z_list = []\n        zero_list = []\n        for x, k in zip(x_list, [KTH, KTF]):\n            exp = x * k.exp(x)\n            loss = k.sum(exp)\n            zero_loss = k.stop_gradient(loss)\n            grad = k.gradients(loss, [exp])\n            zero_grad = k.gradients(loss + zero_loss, [exp])\n            z_list.append(k.eval(grad[0]))\n            zero_list.append(k.eval(zero_grad[0]))\n\n        assert_list_pairwise(z_list)\n        assert_list_pairwise(zero_list)\n        for i in range(len(z_list)):\n            assert_allclose(zero_list[i], z_list[i], atol=1e-05)",
        "begin_line": 608,
        "end_line": 625,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_stop_gradient#627",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_stop_gradient(self)",
        "snippet": "    def test_stop_gradient(self):\n        # This test checks the consistency of the stop_gradient backend API.\n        # It doesn't check the functionality (which is checked at the\n        # test_gradient test).\n        val = np.random.random((4, 2))\n        a = K.variable(val)\n        b = K.square(a)\n        c, d = K.stop_gradient([a, b])\n        e = K.stop_gradient(b)",
        "begin_line": 627,
        "end_line": 635,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_function#640",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_function(self)",
        "snippet": "    def test_function(self):\n        test_backend = [KTH, KTF]\n        val = np.random.random((4, 2))\n        input_val = np.random.random((4, 2))\n\n        f_list = []\n        x_list = []\n        for k in test_backend:\n            x = k.variable(val)\n            x_list.append(x)\n            y = k.placeholder(ndim=2)\n            exp = k.square(x) + y\n            update = x * 2\n            f = k.function([y], [exp], updates=[(x, update)])\n            f_list.append(f)\n\n        function_outputs_list = [f([input_val])[0] for f in f_list]\n        assert_list_pairwise(function_outputs_list)\n\n        new_val_list = [k.get_value(x) for x, k in zip(x_list, test_backend)]\n        assert_list_pairwise(new_val_list)",
        "begin_line": 640,
        "end_line": 660,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_function_tf_fetches#664",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_function_tf_fetches(self)",
        "snippet": "    def test_function_tf_fetches(self):\n        # Additional operations can be passed to tf.Session().run() via its\n        # `fetches` arguments. In contrast to `updates` argument of\n        # KTF.function() these do not have control dependency on `outputs`, so\n        # they can run in parallel. Also they should not contribute to output of\n        # KTF.function().\n\n        x = K.variable(0.)\n        y = K.variable(0.)\n        x_placeholder = K.placeholder(shape=())\n        y_placeholder = K.placeholder(shape=())\n\n        f = K.function(inputs=[x_placeholder, y_placeholder],\n                       outputs=[x_placeholder + y_placeholder],\n                       updates=[(x, x_placeholder + 1.)],\n                       fetches=[K.update(y, 5.)])\n        output = f([10., 20.])\n        assert output == [30.]\n        assert K.get_session().run(fetches=[x, y]) == [11., 5.]",
        "begin_line": 664,
        "end_line": 682,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_function_tf_feed_dict#686",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_function_tf_feed_dict(self)",
        "snippet": "    def test_function_tf_feed_dict(self):\n        # Additional substitutions can be passed to `tf.Session().run()` via its\n        # `feed_dict` arguments. Note that the feed_dict is passed once in the\n        # constructor but we can modify the values in the dictionary. Through\n        # this feed_dict we can provide additional substitutions besides Keras\n        # inputs.\n\n        x = K.variable(0.)\n        y = K.variable(0.)\n        x_placeholder = K.placeholder(shape=())\n        y_placeholder = K.placeholder(shape=())\n\n        feed_dict = {y_placeholder: 3.}\n\n        f = K.function(inputs=[x_placeholder],\n                       outputs=[x_placeholder + 1.],\n                       updates=[(x, x_placeholder + 10.)],\n                       feed_dict=feed_dict,\n                       fetches=[K.update(y, y_placeholder * 10.)])\n        output = f([10.])\n        assert output == [11.]\n        assert K.get_session().run(fetches=[x, y]) == [20., 30.]\n\n        # updated value in feed_dict will be modified within the K.function()\n        feed_dict[y_placeholder] = 4.\n        output = f([20.])\n        assert output == [21.]\n        assert K.get_session().run(fetches=[x, y]) == [30., 40.]",
        "begin_line": 686,
        "end_line": 713,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_function_tf_run_options_with_run_metadata#717",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_function_tf_run_options_with_run_metadata(self)",
        "snippet": "    def test_function_tf_run_options_with_run_metadata(self):\n        from tensorflow.core.protobuf import config_pb2\n        x_placeholder = K.placeholder(shape=())\n        y_placeholder = K.placeholder(shape=())\n\n        run_options = config_pb2.RunOptions(output_partition_graphs=True)\n        run_metadata = config_pb2.RunMetadata()\n        # enable run_options.\n        f = K.function(inputs=[x_placeholder, y_placeholder],\n                       outputs=[x_placeholder + y_placeholder],\n                       options=run_options,\n                       run_metadata=run_metadata)\n        output = f([10., 20.])\n        assert output == [30.]\n        assert len(run_metadata.partition_graphs) > 0\n        # disable run_options.\n        f = K.function(inputs=[x_placeholder, y_placeholder],\n                       outputs=[x_placeholder + y_placeholder],\n                       run_metadata=run_metadata)\n        output = f([10., 20.])\n        assert output == [30.]\n        assert len(run_metadata.partition_graphs) == 0",
        "begin_line": 717,
        "end_line": 738,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_function_tf_string_input#742",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_function_tf_string_input(self)",
        "snippet": "    def test_function_tf_string_input(self):\n        # Test functions with string inputs.\n\n        x_placeholder = K.placeholder(shape=(), dtype=\"string\")\n        x_identity = K.identity(x_placeholder)\n\n        f = K.function(inputs=[x_placeholder], outputs=[x_identity])\n        output = f([b'test'])\n        assert output == [b'test']",
        "begin_line": 742,
        "end_line": 750,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_rnn#752",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_rnn(self)",
        "snippet": "    def test_rnn(self):\n        # implement a simple RNN\n        num_samples = 4\n        input_dim = 5\n        output_dim = 3\n        timesteps = 6\n\n        _, x = parse_shape_or_val((num_samples, timesteps, input_dim))\n        _, h0 = parse_shape_or_val((num_samples, output_dim))\n        _, wi = parse_shape_or_val((input_dim, output_dim))\n        _, wh = parse_shape_or_val((output_dim, output_dim))\n        mask = np.random.randint(2, size=(num_samples, timesteps))\n\n        wi_k = K.variable(wi)\n        wh_k = K.variable(wh)\n\n        def get_step_function(backend, w_i, w_h):\n\n            def simple_rnn(inputs, states):\n                assert len(states) == 1\n                h = states[0]\n                y = backend.dot(inputs, w_i) + backend.dot(h, w_h)\n                return y, [y]\n\n            return simple_rnn\n\n        kwargs_list = [\n            {'go_backwards': False, 'mask': None},\n            {'go_backwards': True, 'mask': None},\n            {'go_backwards': False, 'mask': mask},\n            {'go_backwards': True, 'mask': mask},\n        ]\n        for kwargs in kwargs_list:\n            check_rnn_operation(step_function_k=get_step_function(K, wi_k, wh_k),\n                                step_function_np=get_step_function(KNP, wi, wh),\n                                inputs_np=x,\n                                initial_states_np=[h0],\n                                mask_np=kwargs.pop('mask', None),\n                                **kwargs)",
        "begin_line": 752,
        "end_line": 790,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.get_step_function#768",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.get_step_function(backend, w_i, w_h)",
        "snippet": "        def get_step_function(backend, w_i, w_h):\n\n            def simple_rnn(inputs, states):\n                assert len(states) == 1\n                h = states[0]\n                y = backend.dot(inputs, w_i) + backend.dot(h, w_h)\n                return y, [y]\n\n            return simple_rnn",
        "begin_line": 768,
        "end_line": 776,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.simple_rnn#770",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.simple_rnn(inputs, states)",
        "snippet": "            def simple_rnn(inputs, states):\n                assert len(states) == 1\n                h = states[0]\n                y = backend.dot(inputs, w_i) + backend.dot(h, w_h)\n                return y, [y]",
        "begin_line": 770,
        "end_line": 774,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_rnn_additional_states#792",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_rnn_additional_states(self)",
        "snippet": "    def test_rnn_additional_states(self):\n        # implement a simple RNN with an additional state\n        # whose shape is different from that of the output\n        num_samples = 4\n        input_dim = 5\n        output_dim = 3\n        timesteps = 6\n\n        _, x = parse_shape_or_val((num_samples, timesteps, input_dim))\n        _, h0 = parse_shape_or_val((num_samples, output_dim))\n        h1 = np.concatenate([h0, h0], axis=-1)\n        _, wi = parse_shape_or_val((input_dim, output_dim))\n        _, wh = parse_shape_or_val((output_dim, output_dim))\n        mask = np.random.randint(2, size=(num_samples, timesteps))\n\n        wi_k = K.variable(wi)\n        wh_k = K.variable(wh)\n\n        def get_step_function(backend, w_i, w_h):\n\n            def simple_rnn_with_extra_mock_state(inputs, states):\n                assert len(states) == 2\n                h = states[0]\n                y = backend.dot(inputs, w_i) + backend.dot(h, w_h)\n                return y, [y, backend.concatenate([y, y], axis=-1)]\n\n            return simple_rnn_with_extra_mock_state\n\n        kwargs_list = [\n            {'go_backwards': False, 'mask': None},\n            {'go_backwards': True, 'mask': None},\n            {'go_backwards': False, 'mask': mask},\n            {'go_backwards': True, 'mask': mask},\n        ]\n        for kwargs in kwargs_list:\n            check_rnn_operation(step_function_k=get_step_function(K, wi_k, wh_k),\n                                step_function_np=get_step_function(KNP, wi, wh),\n                                inputs_np=x,\n                                initial_states_np=[h0, h1],\n                                mask_np=kwargs.pop('mask', None),\n                                **kwargs)",
        "begin_line": 792,
        "end_line": 832,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.get_step_function#810",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.get_step_function(backend, w_i, w_h)",
        "snippet": "        def get_step_function(backend, w_i, w_h):\n\n            def simple_rnn_with_extra_mock_state(inputs, states):\n                assert len(states) == 2\n                h = states[0]\n                y = backend.dot(inputs, w_i) + backend.dot(h, w_h)\n                return y, [y, backend.concatenate([y, y], axis=-1)]\n\n            return simple_rnn_with_extra_mock_state",
        "begin_line": 810,
        "end_line": 818,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.simple_rnn_with_extra_mock_state#812",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.simple_rnn_with_extra_mock_state(inputs, states)",
        "snippet": "            def simple_rnn_with_extra_mock_state(inputs, states):\n                assert len(states) == 2\n                h = states[0]\n                y = backend.dot(inputs, w_i) + backend.dot(h, w_h)\n                return y, [y, backend.concatenate([y, y], axis=-1)]",
        "begin_line": 812,
        "end_line": 816,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_rnn_no_states#834",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_rnn_no_states(self)",
        "snippet": "    def test_rnn_no_states(self):\n        # implement a simple RNN without states\n        num_samples = 3\n        input_dim = 8\n        output_dim = 4\n        timesteps = 5\n\n        _, x = parse_shape_or_val((num_samples, timesteps, input_dim))\n        _, wi = parse_shape_or_val((input_dim, output_dim))\n        mask = np.random.randint(2, size=(num_samples, timesteps))\n\n        wi_k = K.variable(wi)\n\n        def get_step_function(backend, w_i):\n\n            def simple_no_states(inputs, states):\n                assert len(states) == 0\n                y = backend.dot(inputs, w_i)\n                return y, []\n\n            return simple_no_states\n\n        kwargs_list = [\n            {'go_backwards': False, 'mask': None},\n            {'go_backwards': True, 'mask': None},\n            {'go_backwards': False, 'mask': mask},\n            {'go_backwards': True, 'mask': mask},\n        ]\n        for kwargs in kwargs_list:\n            check_rnn_operation(step_function_k=get_step_function(K, wi_k),\n                                step_function_np=get_step_function(KNP, wi),\n                                inputs_np=x,\n                                initial_states_np=[],\n                                mask_np=kwargs.pop('mask', None),\n                                **kwargs)",
        "begin_line": 834,
        "end_line": 868,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.get_step_function#847",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.get_step_function(backend, w_i)",
        "snippet": "        def get_step_function(backend, w_i):\n\n            def simple_no_states(inputs, states):\n                assert len(states) == 0\n                y = backend.dot(inputs, w_i)\n                return y, []\n\n            return simple_no_states",
        "begin_line": 847,
        "end_line": 854,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.simple_no_states#849",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.simple_no_states(inputs, states)",
        "snippet": "            def simple_no_states(inputs, states):\n                assert len(states) == 0\n                y = backend.dot(inputs, w_i)\n                return y, []",
        "begin_line": 849,
        "end_line": 852,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_rnn_constants#870",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_rnn_constants(self)",
        "snippet": "    def test_rnn_constants(self):\n        # implement a simple RNN\n        num_samples = 4\n        input_dim = 5\n        output_dim = 3\n        timesteps = 6\n\n        _, x = parse_shape_or_val((num_samples, timesteps, input_dim))\n        _, h0 = parse_shape_or_val((num_samples, output_dim))\n        _, c = parse_shape_or_val((num_samples, output_dim))\n        _, wi = parse_shape_or_val((input_dim, output_dim))\n        _, wh = parse_shape_or_val((output_dim, output_dim))\n        mask = np.random.randint(2, size=(num_samples, timesteps))\n\n        wi_k = K.variable(wi)\n        wh_k = K.variable(wh)\n\n        def get_step_function(backend, w_i, w_h):\n\n            def simple_rnn_add_constant(inputs, states_and_constants):\n                # constants are appended to states in K.rnn\n                [h, c] = states_and_constants\n                y = backend.dot(inputs, w_i) + backend.dot(h, w_h) + c\n                return y, [y]\n\n            return simple_rnn_add_constant\n\n        kwargs_list = [\n            {'go_backwards': False, 'mask': None},\n            {'go_backwards': True, 'mask': None},\n            {'go_backwards': False, 'mask': mask},\n            {'go_backwards': True, 'mask': mask},\n        ]\n        for kwargs in kwargs_list:\n            check_rnn_operation(step_function_k=get_step_function(K, wi_k, wh_k),\n                                step_function_np=get_step_function(KNP, wi, wh),\n                                inputs_np=x,\n                                initial_states_np=[h0],\n                                mask_np=kwargs.pop('mask', None),\n                                constants_np=[c],\n                                **kwargs)",
        "begin_line": 870,
        "end_line": 910,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.get_step_function#887",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.get_step_function(backend, w_i, w_h)",
        "snippet": "        def get_step_function(backend, w_i, w_h):\n\n            def simple_rnn_add_constant(inputs, states_and_constants):\n                # constants are appended to states in K.rnn\n                [h, c] = states_and_constants\n                y = backend.dot(inputs, w_i) + backend.dot(h, w_h) + c\n                return y, [y]\n\n            return simple_rnn_add_constant",
        "begin_line": 887,
        "end_line": 895,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.simple_rnn_add_constant#889",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.simple_rnn_add_constant(inputs, states_and_constants)",
        "snippet": "            def simple_rnn_add_constant(inputs, states_and_constants):\n                # constants are appended to states in K.rnn\n                [h, c] = states_and_constants\n                y = backend.dot(inputs, w_i) + backend.dot(h, w_h) + c\n                return y, [y]",
        "begin_line": 889,
        "end_line": 893,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_rnn_output_and_state_masking_independent#912",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_rnn_output_and_state_masking_independent(self)",
        "snippet": "    def test_rnn_output_and_state_masking_independent(self):\n        num_samples = 2\n        num_timesteps = 4\n        state_and_io_size = 5\n        mask_last_num_timesteps = 2  # for second sample only\n\n        # a step function that just outputs inputs,\n        # but increments states +1 per timestep\n        def step_function(inputs, states):\n            return inputs, [s + 1 for s in states]\n\n        inputs_vals = np.random.random(\n            (num_samples, num_timesteps, state_and_io_size))\n        initial_state_vals = np.random.random((num_samples, state_and_io_size))\n        # masking of two last timesteps for second sample only\n        mask_vals = np.ones((num_samples, num_timesteps))\n        mask_vals[1, -mask_last_num_timesteps:] = 0\n\n        # outputs expected to be same as inputs for the first sample\n        expected_outputs = inputs_vals.copy()\n        # but for the second sample all outputs in masked region should be the same\n        # as last output before masked region\n        expected_outputs[1, -mask_last_num_timesteps:] = \\\n            expected_outputs[1, -(mask_last_num_timesteps + 1)]\n\n        expected_state = initial_state_vals.copy()\n        # first state should be incremented for every timestep (no masking)\n        expected_state[0] += num_timesteps\n        # second state should not be incremented for last two timesteps\n        expected_state[1] += (num_timesteps - mask_last_num_timesteps)\n\n        # verify same expected output for `unroll=true/false`\n        inputs = K.variable(inputs_vals)\n        initial_states = [K.variable(initial_state_vals)]\n        mask = K.variable(mask_vals)\n        for unroll in [True, False]:\n            last_output, outputs, last_states = K.rnn(\n                step_function,\n                inputs,\n                initial_states,\n                mask=mask,\n                unroll=unroll,\n                input_length=num_timesteps if unroll else None)\n\n            assert_allclose(K.eval(outputs), expected_outputs)\n            assert_allclose(K.eval(last_states[0]), expected_state)",
        "begin_line": 912,
        "end_line": 957,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.step_function#920",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.step_function(inputs, states)",
        "snippet": "        def step_function(inputs, states):\n            return inputs, [s + 1 for s in states]",
        "begin_line": 920,
        "end_line": 921,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_rnn_output_num_dim_larger_than_2_masking#960",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_rnn_output_num_dim_larger_than_2_masking(self)",
        "snippet": "    def test_rnn_output_num_dim_larger_than_2_masking(self):\n        num_samples = 3\n        num_timesteps = 4\n        num_features = 5\n\n        def step_function(inputs, states):\n            outputs = K.tile(K.expand_dims(inputs), [1, 1, 2])\n            return outputs, states\n\n        inputs_vals = np.random.random((num_samples, num_timesteps, num_features))\n        initial_state_vals = np.random.random((num_samples, 6))\n        mask_vals = np.ones((num_samples, num_timesteps))\n        mask_vals[-1, -1] = 0  # final timestep masked for last sample\n\n        expected_outputs = np.repeat(inputs_vals[..., None], repeats=2, axis=-1)\n        # for the last sample, the final timestep (in masked region) should be the\n        # same as the second to final output (before masked region)\n        expected_outputs[-1, -1] = expected_outputs[-1, -2]\n\n        inputs = K.variable(inputs_vals)\n        initial_states = [K.variable(initial_state_vals)]\n        mask = K.variable(mask_vals)\n        for unroll in [True, False]:\n            last_output, outputs, last_states = K.rnn(\n                step_function,\n                inputs,\n                initial_states,\n                mask=mask,\n                unroll=unroll,\n                input_length=num_timesteps if unroll else None)\n\n            assert_allclose(K.eval(outputs), expected_outputs)",
        "begin_line": 960,
        "end_line": 991,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.step_function#965",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.step_function(inputs, states)",
        "snippet": "        def step_function(inputs, states):\n            outputs = K.tile(K.expand_dims(inputs), [1, 1, 2])\n            return outputs, states",
        "begin_line": 965,
        "end_line": 967,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_rnn_state_num_dim_larger_than_2_masking#994",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_rnn_state_num_dim_larger_than_2_masking(self)",
        "snippet": "    def test_rnn_state_num_dim_larger_than_2_masking(self):\n        num_samples = 3\n        num_timesteps = 4\n\n        def step_function(inputs, states):\n            return inputs, [s + 1 for s in states]\n\n        inputs_vals = np.random.random((num_samples, num_timesteps, 5))\n        initial_state_vals = np.random.random((num_samples, 6, 7))\n        mask_vals = np.ones((num_samples, num_timesteps))\n        mask_vals[0, -2:] = 0  # final two timesteps masked for first sample\n\n        expected_last_state = initial_state_vals.copy()\n        expected_last_state[0] += (num_timesteps - 2)\n        expected_last_state[1:] += num_timesteps\n\n        inputs = K.variable(inputs_vals)\n        initial_states = [K.variable(initial_state_vals)]\n        mask = K.variable(mask_vals)\n        for unroll in [True, False]:\n            last_output, outputs, last_states = K.rnn(\n                step_function,\n                inputs,\n                initial_states,\n                mask=mask,\n                unroll=unroll,\n                input_length=num_timesteps if unroll else None)\n\n            # not updated last timestep:\n            assert_allclose(K.eval(last_states[0]), expected_last_state)",
        "begin_line": 994,
        "end_line": 1023,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.step_function#998",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.step_function(inputs, states)",
        "snippet": "        def step_function(inputs, states):\n            return inputs, [s + 1 for s in states]",
        "begin_line": 998,
        "end_line": 999,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_logsumexp#1040",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_logsumexp(self, x_np, axis, keepdims)",
        "snippet": "    def test_logsumexp(self, x_np, axis, keepdims):\n        '''\n        Check if K.logsumexp works properly for values close to one.\n        '''\n        x = K.variable(x_np)\n        assert_allclose(K.eval(K.logsumexp(x, axis=axis, keepdims=keepdims)),\n                        np.log(np.sum(np.exp(x_np), axis=axis, keepdims=keepdims)),\n                        rtol=1e-5)",
        "begin_line": 1040,
        "end_line": 1047,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_logsumexp_optim#1051",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_logsumexp_optim(self)",
        "snippet": "    def test_logsumexp_optim(self):\n        '''\n        Check if optimization works.\n        '''\n        x_np = np.array([1e+4, 1e-4])\n        result = K.eval(K.logsumexp(K.variable(x_np), axis=0))\n        assert_allclose(result, 1e4, rtol=1e-5)",
        "begin_line": 1051,
        "end_line": 1057,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_switch#1059",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_switch(self)",
        "snippet": "    def test_switch(self):\n        # scalar\n        val = np.random.random()\n        z_list = []\n        for k in WITH_NP:\n            x = k.variable(val)\n            x = k.switch(k.greater_equal(x, 0.5), x * 0.1, x * 0.2)\n            z_list.append(k.eval(x))\n        assert_list_pairwise(z_list)\n        # non scalar\n        shapes = []\n        shapes.append([(4, 3, 2), (4, 3, 2), (4, 3, 2)])\n        shapes.append([(4, 3,), (4, 3, 2), (4, 3, 2)])\n        shapes.append([(4,), (4, 3, 2), (4, 3, 2)])\n        for s in shapes:\n            z_list = []\n            arrays = list(map(np.random.random, s))\n            for k in WITH_NP:\n                x, then_expr, else_expr = map(k.variable, arrays)\n                cond = k.greater_equal(x, 0.5)\n                z_list.append(k.eval(k.switch(cond, then_expr, else_expr)))\n            assert_list_pairwise(z_list)",
        "begin_line": 1059,
        "end_line": 1080,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_dropout#1082",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_dropout(self)",
        "snippet": "    def test_dropout(self):\n        val = np.random.random((100, 100))\n        z_list = [k.eval(k.dropout(k.variable(val), level=0.2))\n                  for k in WITH_NP]\n        assert_list_pairwise(z_list, allclose=False)\n        # dropout patterns are different, only check mean\n        for i in range(len(z_list) - 1):\n            assert np.abs(z_list[i].mean() - z_list[i + 1].mean()) < 0.05\n\n        z_list = [k.eval(k.dropout(k.variable(val), level=0.2,\n                                   noise_shape=list(val.shape)))\n                  for k in WITH_NP]\n        assert_list_pairwise(z_list, allclose=False)\n        # dropout patterns are different, only check mean\n        for i in range(len(z_list) - 1):\n            assert np.abs(z_list[i].mean() - z_list[i + 1].mean()) < 0.05\n\n        # Test invalid use cases\n        with pytest.raises(ValueError):\n            z = K.dropout(K.variable(val), level=-0.5)",
        "begin_line": 1082,
        "end_line": 1101,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_relu#1116",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_relu(self, alpha, max_value, threshold)",
        "snippet": "    def test_relu(self, alpha, max_value, threshold):\n        check_single_tensor_operation('relu', (4, 2), WITH_NP, alpha=alpha,\n                                      max_value=max_value, threshold=threshold)",
        "begin_line": 1116,
        "end_line": 1118,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_nn_operations#1120",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_nn_operations(self)",
        "snippet": "    def test_nn_operations(self):\n        check_single_tensor_operation('softsign', (4, 10), WITH_NP)\n        check_single_tensor_operation('softplus', (4, 10), WITH_NP)\n        check_single_tensor_operation('elu', (4, 10), WITH_NP, alpha=0.5)\n\n        check_single_tensor_operation('sigmoid', (4, 2), WITH_NP)\n        check_single_tensor_operation('hard_sigmoid', (4, 2), WITH_NP)\n        check_single_tensor_operation('tanh', (4, 2), WITH_NP)\n\n        check_single_tensor_operation('softmax', (4, 10), WITH_NP)\n        check_single_tensor_operation('softmax', (4, 5, 3), WITH_NP, axis=1)\n        check_single_tensor_operation('softmax', (4, 5, 3, 10), WITH_NP, axis=2)\n\n        check_two_tensor_operation('binary_crossentropy', (4, 2), (4, 2),\n                                   WITH_NP, from_logits=True)\n        # cross_entropy call require the label is a valid probability distribution,\n        # otherwise it is garbage in garbage out...\n        # due to the algo difference, we can't guarantee CNTK has the same result\n        # on the garbage input.\n        # so create a separate test case for valid label input\n        if K.backend() != 'cntk':\n            check_two_tensor_operation('categorical_crossentropy', (4, 2), (4, 2),\n                                       WITH_NP, from_logits=True)\n        xval = np.asarray([[0.26157712, 0.0432167], [-0.43380741, 0.30559841],\n                           [0.20225059, -0.38956559], [-0.13805378, 0.08506755]],\n                          dtype=np.float32)\n        yval = np.asarray([[0.46221867, 0.53778133], [0.51228984, 0.48771016],\n                           [0.64916514, 0.35083486], [0.47028078, 0.52971922]],\n                          dtype=np.float32)\n        check_two_tensor_operation('categorical_crossentropy', yval, xval, WITH_NP,\n                                   cntk_two_dynamicity=True, from_logits=True)\n        check_two_tensor_operation('binary_crossentropy', (4, 2), (4, 2),\n                                   WITH_NP, from_logits=False)\n        check_two_tensor_operation('categorical_crossentropy', (4, 2), (4, 2),\n                                   WITH_NP, from_logits=False)\n\n        check_single_tensor_operation('l2_normalize', (4, 3), WITH_NP, axis=-1)\n        check_single_tensor_operation('l2_normalize', (4, 3), WITH_NP, axis=1)",
        "begin_line": 1120,
        "end_line": 1157,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_in_top_k#1160",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_in_top_k(self)",
        "snippet": "    def test_in_top_k(self):\n        batch_size = 20\n        num_classes = 10\n\n        # Random prediction test case\n        predictions = np.random.random((batch_size, num_classes)).astype('float32')\n        targets = np.random.randint(num_classes, size=batch_size, dtype='int32')\n\n        # (k == 0 or k > num_classes) does not raise an error\n        # but just return an unmeaningful tensor.\n        for k in range(1, num_classes + 1):\n            z_list = [b.eval(b.in_top_k(b.variable(predictions, dtype='float32'),\n                                        b.variable(targets, dtype='int32'), k))\n                      for b in WITH_NP]\n            assert_list_pairwise(z_list)\n\n        # Identical prediction test case:\n        # randomly set half of the predictions to an identical value\n        num_identical = num_classes // 2\n        for i in range(batch_size):\n            idx_identical = np.random.choice(num_classes,\n                                             size=num_identical, replace=False)\n            predictions[i, idx_identical] = predictions[i, 0]\n        targets = np.zeros(batch_size, dtype='int32')\n\n        for k in range(1, num_classes + 1):\n            z_list = [b.eval(b.in_top_k(b.variable(predictions, dtype='float32'),\n                                        b.variable(targets, dtype='int32'), k))\n                      for b in WITH_NP]\n            assert_list_pairwise(z_list)",
        "begin_line": 1160,
        "end_line": 1189,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_conv#1204",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_conv(self, op, input_shape, kernel_shape, padding, data_format)",
        "snippet": "    def test_conv(self, op, input_shape, kernel_shape, padding, data_format):\n        check_two_tensor_operation(\n            op, input_shape, kernel_shape, WITH_NP,\n            padding=padding, data_format=data_format,\n            cntk_dynamicity=True)",
        "begin_line": 1204,
        "end_line": 1208,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_conv_transpose#1217",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_conv_transpose(self, op, input_shape, kernel_shape, output_shape, padding, data_format)",
        "snippet": "    def test_conv_transpose(self,\n                            op,\n                            input_shape,\n                            kernel_shape,\n                            output_shape,\n                            padding,\n                            data_format):\n        check_two_tensor_operation(\n            op, input_shape, kernel_shape, WITH_NP,\n            output_shape=output_shape, padding=padding, data_format=data_format,\n            cntk_dynamicity=True)",
        "begin_line": 1217,
        "end_line": 1227,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_dilated_conv#1244",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_dilated_conv(self, op, input_shape, kernel_shape, padding, data_format, dilation_rate)",
        "snippet": "    def test_dilated_conv(self,\n                          op,\n                          input_shape,\n                          kernel_shape,\n                          padding,\n                          data_format,\n                          dilation_rate):\n        check_two_tensor_operation(\n            op, input_shape, kernel_shape, WITH_NP,\n            padding=padding, data_format=data_format,\n            dilation_rate=dilation_rate, cntk_dynamicity=True)",
        "begin_line": 1244,
        "end_line": 1254,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_dilated_conv_transpose#1266",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_dilated_conv_transpose(self, op, input_shape, kernel_shape, output_shape, padding, data_format, dilation_rate)",
        "snippet": "    def test_dilated_conv_transpose(self,\n                                    op,\n                                    input_shape,\n                                    kernel_shape,\n                                    output_shape,\n                                    padding,\n                                    data_format,\n                                    dilation_rate):\n        check_two_tensor_operation(\n            op, input_shape, kernel_shape, WITH_NP, output_shape=output_shape,\n            padding=padding, data_format=data_format, dilation_rate=dilation_rate,\n            cntk_dynamicity=True)",
        "begin_line": 1266,
        "end_line": 1277,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_depthwise_conv#1285",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_depthwise_conv(self, op, input_shape, kernel_shape, padding, data_format)",
        "snippet": "    def test_depthwise_conv(self,\n                            op,\n                            input_shape,\n                            kernel_shape,\n                            padding,\n                            data_format):\n        check_two_tensor_operation(\n            op, input_shape, kernel_shape, WITH_NP,\n            padding=padding, data_format=data_format,\n            cntk_dynamicity=True)",
        "begin_line": 1285,
        "end_line": 1294,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_pool#1315",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_pool(self, op, input_shape, pool_size, strides, padding, data_format, pool_mode)",
        "snippet": "    def test_pool(self,\n                  op,\n                  input_shape,\n                  pool_size,\n                  strides,\n                  padding,\n                  data_format,\n                  pool_mode):\n        check_single_tensor_operation(\n            op, input_shape, WITH_NP,\n            pool_size=pool_size, strides=strides,\n            padding=padding, data_format=data_format, pool_mode=pool_mode,\n            cntk_dynamicity=True)",
        "begin_line": 1315,
        "end_line": 1327,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_separable_conv#1338",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_separable_conv(self, op, input_shape, kernel_shape, depth_multiplier, padding, data_format)",
        "snippet": "    def test_separable_conv(self,\n                            op,\n                            input_shape,\n                            kernel_shape,\n                            depth_multiplier,\n                            padding,\n                            data_format):\n        if data_format == 'channels_first':\n            input_depth = input_shape[1]\n        else:\n            input_depth = input_shape[-1]\n        _, x = parse_shape_or_val(input_shape)\n        _, depthwise = parse_shape_or_val(kernel_shape +\n                                          (input_depth, depth_multiplier))\n        _, pointwise = parse_shape_or_val((1,) * len(kernel_shape) +\n                                          (input_depth * depth_multiplier, 7))\n        y1 = KNP.separable_conv(x, depthwise, pointwise,\n                                padding=padding, data_format=data_format)\n        if K.backend() == 'cntk':\n            _, cntk_func = cntk_func_tensors(\n                op, [input_shape, depthwise, pointwise],\n                padding=padding, data_format=data_format)\n            y2 = cntk_func([x])[0]\n        else:\n            y2 = K.eval(getattr(K, op)(\n                K.variable(x),\n                K.variable(depthwise), K.variable(pointwise),\n                padding=padding, data_format=data_format))\n        assert_allclose(y1, y2, atol=1e-05)",
        "begin_line": 1338,
        "end_line": 1366,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_random_normal#1368",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_random_normal(self)",
        "snippet": "    def test_random_normal(self):\n        # test standard normal as well as a normal with a different set of parameters\n        for mean, std in [(0., 1.), (-10., 5.)]:\n            rand = K.eval(K.random_normal((300, 200),\n                                          mean=mean, stddev=std, seed=1337))\n            assert rand.shape == (300, 200)\n            assert np.abs(np.mean(rand) - mean) < std * 0.015\n            assert np.abs(np.std(rand) - std) < std * 0.015\n\n            # test that random_normal also generates different values when used\n            # within a function\n            r = K.random_normal((10, 10), mean=mean, stddev=std, seed=1337)\n            samples = np.array([K.eval(r) for _ in range(200)])\n            assert np.abs(np.mean(samples) - mean) < std * 0.015\n            assert np.abs(np.std(samples) - std) < std * 0.015",
        "begin_line": 1368,
        "end_line": 1382,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_random_uniform#1384",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_random_uniform(self)",
        "snippet": "    def test_random_uniform(self):\n        min_val = -1.\n        max_val = 1.\n        rand = K.eval(K.random_uniform((200, 100), min_val, max_val))\n        assert rand.shape == (200, 100)\n        assert np.abs(np.mean(rand)) < 0.015\n        assert max_val - 0.015 < np.max(rand) <= max_val\n        assert min_val + 0.015 > np.min(rand) >= min_val\n\n        r = K.random_uniform((10, 10), minval=min_val, maxval=max_val)\n        samples = np.array([K.eval(r) for _ in range(200)])\n        assert np.abs(np.mean(samples)) < 0.015\n        assert max_val - 0.015 < np.max(samples) <= max_val\n        assert min_val + 0.015 > np.min(samples) >= min_val",
        "begin_line": 1384,
        "end_line": 1397,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_random_binomial#1399",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_random_binomial(self)",
        "snippet": "    def test_random_binomial(self):\n        p = 0.5\n        rand = K.eval(K.random_binomial((200, 100), p))\n        assert rand.shape == (200, 100)\n        assert np.abs(np.mean(rand) - p) < 0.015\n        assert np.max(rand) == 1\n        assert np.min(rand) == 0\n\n        r = K.random_binomial((10, 10), p)\n        samples = np.array([K.eval(r) for _ in range(200)])\n        assert np.abs(np.mean(samples) - p) < 0.015\n        assert np.max(samples) == 1\n        assert np.min(samples) == 0",
        "begin_line": 1399,
        "end_line": 1411,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_truncated_normal#1413",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_truncated_normal(self)",
        "snippet": "    def test_truncated_normal(self):\n        mean = 0.\n        std = 1.\n        min_val = -2.\n        max_val = 2.\n        rand = K.eval(K.truncated_normal((300, 200),\n                                         mean=mean, stddev=std, seed=1337))\n        assert rand.shape == (300, 200)\n        assert np.abs(np.mean(rand) - mean) < 0.015\n        assert np.max(rand) <= max_val\n        assert np.min(rand) >= min_val\n\n        # assumption in initializers.VarianceScaling\n        assert np.abs(np.std(rand) - std * 0.87962) < 0.015",
        "begin_line": 1413,
        "end_line": 1426,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_conv_invalid_use#1428",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_conv_invalid_use(self)",
        "snippet": "    def test_conv_invalid_use(self):\n        dummy_x_1d = K.variable(np.ones((4, 8, 2)))\n        dummy_w_1d = K.variable(np.ones((3, 2, 3)))\n        dummy_x_2d = K.variable(np.ones((2, 3, 4, 5)))\n        dummy_w_2d = K.variable(np.ones((2, 2, 3, 4)))\n        dummy_x_3d = K.variable(np.ones((2, 3, 4, 5, 4)))\n        dummy_w_3d = K.variable(np.ones((2, 2, 2, 3, 4)))\n        dummy_w1x1_2d = K.variable(np.ones((1, 1, 12, 7)))\n\n        with pytest.raises(ValueError):\n            K.conv1d(dummy_x_1d, dummy_w_1d, data_format='channels_middle')\n\n        with pytest.raises(ValueError):\n            K.conv2d(dummy_x_2d, dummy_w_2d, data_format='channels_middle')\n\n        with pytest.raises(ValueError):\n            K.conv3d(dummy_x_3d, dummy_w_3d, data_format='channels_middle')\n\n        if K.backend() != 'theano':\n            with pytest.raises(ValueError):\n                K.separable_conv2d(dummy_x_2d, dummy_w_2d, dummy_w1x1_2d,\n                                   data_format='channels_middle')\n\n        with pytest.raises(ValueError):\n            K.depthwise_conv2d(dummy_x_2d, dummy_w_2d,\n                               data_format='channels_middle')\n\n        if K.backend() == 'cntk':\n            with pytest.raises(ValueError):\n                K.separable_conv2d(dummy_x_2d, dummy_w_2d, dummy_w1x1_2d,\n                                   dilation_rate=(1, 2))\n            with pytest.raises(ValueError):\n                K.separable_conv2d(dummy_x_2d, dummy_w_2d, dummy_w1x1_2d,\n                                   strides=(2, 2), dilation_rate=(1, 2))\n            with pytest.raises(ValueError):\n                K.depthwise_conv2d(dummy_x_2d, dummy_w_2d,\n                                   dilation_rate=(1, 2))\n            with pytest.raises(ValueError):\n                K.depthwise_conv2d(dummy_x_2d, dummy_w_2d,\n                                   strides=(2, 2), dilation_rate=(1, 2))",
        "begin_line": 1428,
        "end_line": 1467,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_pooling_invalid_use#1469",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_pooling_invalid_use(self)",
        "snippet": "    def test_pooling_invalid_use(self):\n        for (input_shape, pool_size) in zip([(5, 10, 12, 3), (5, 10, 12, 6, 3)],\n                                            [(2, 2), (2, 2, 2)]):\n            x = K.variable(np.random.random(input_shape))\n            if len(pool_size) == 2:\n                with pytest.raises(ValueError):\n                    K.pool2d(x, pool_size=pool_size, data_format='channels_middle')\n                with pytest.raises(ValueError):\n                    K.pool2d(x, pool_size=pool_size, padding='twice')\n                with pytest.raises(ValueError):\n                    K.pool2d(x, pool_size=pool_size, pool_mode='median')\n            else:\n                with pytest.raises(ValueError):\n                    K.pool3d(x, pool_size=pool_size, data_format='channels_middle')\n                with pytest.raises(ValueError):\n                    K.pool3d(x, pool_size=pool_size, padding='twice')\n                with pytest.raises(ValueError):\n                    K.pool3d(x, pool_size=pool_size, pool_mode='median')",
        "begin_line": 1469,
        "end_line": 1486,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_resize_images#1488",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_resize_images(self)",
        "snippet": "    def test_resize_images(self):\n        for data_format in ['channels_first', 'channels_last']:\n            shape = (5, 5)\n            if data_format == 'channels_first':\n                x_shape = (2, 3) + shape\n            elif data_format == 'channels_last':\n                x_shape = (2,) + shape + (3,)\n            check_single_tensor_operation('resize_images', x_shape,\n                                          WITH_NP, cntk_dynamicity=True,\n                                          height_factor=2,\n                                          width_factor=2,\n                                          data_format=data_format)\n\n        # Test invalid use cases\n        xval = np.random.random(x_shape)\n        with pytest.raises(ValueError):\n            K.resize_images(K.variable(xval), 2, 2,\n                            data_format='channels_middle')",
        "begin_line": 1488,
        "end_line": 1505,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend._helper_bilinear#1508",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend._helper_bilinear(data_format, height_factor, width_factor)",
        "snippet": "    def _helper_bilinear(data_format, height_factor, width_factor):\n        x_shape = (2, 3, 4, 5)\n        check_single_tensor_operation('resize_images', x_shape,\n                                      [KTF, KTH],\n                                      height_factor=height_factor,\n                                      width_factor=width_factor,\n                                      data_format=data_format,\n                                      interpolation='bilinear')",
        "begin_line": 1508,
        "end_line": 1515,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_resize_images_bilinear#1519",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_resize_images_bilinear(self, data_format)",
        "snippet": "    def test_resize_images_bilinear(self, data_format):\n        self._helper_bilinear(data_format, 2, 2)\n        with pytest.raises(NotImplementedError):\n            self._helper_bilinear(data_format, 4, 4)",
        "begin_line": 1519,
        "end_line": 1522,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_resize_volumes#1524",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_resize_volumes(self)",
        "snippet": "    def test_resize_volumes(self):\n        for data_format in ['channels_first', 'channels_last']:\n            shape = (5, 5, 5)\n            if data_format == 'channels_first':\n                x_shape = (2, 3) + shape\n            elif data_format == 'channels_last':\n                x_shape = (2,) + shape + (3,)\n            check_single_tensor_operation('resize_volumes', x_shape,\n                                          WITH_NP, cntk_dynamicity=True,\n                                          depth_factor=2,\n                                          height_factor=2,\n                                          width_factor=2,\n                                          data_format=data_format)\n\n        # Test invalid use cases\n        xval = np.random.random(x_shape)\n        with pytest.raises(ValueError):\n            K.resize_volumes(K.variable(xval), 2, 2, 2,\n                             data_format='channels_middle')",
        "begin_line": 1524,
        "end_line": 1542,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_temporal_padding#1544",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_temporal_padding(self)",
        "snippet": "    def test_temporal_padding(self):\n        check_single_tensor_operation('temporal_padding', (4, 3, 3),\n                                      WITH_NP)\n        check_single_tensor_operation('temporal_padding', (2, 3, 4),\n                                      WITH_NP, padding=(1, 2))",
        "begin_line": 1544,
        "end_line": 1548,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_spatial_2d_padding#1550",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_spatial_2d_padding(self)",
        "snippet": "    def test_spatial_2d_padding(self):\n        padding = ((1, 2), (2, 1))\n        for data_format in ['channels_first', 'channels_last']:\n            shape = (5, 5)\n            if data_format == 'channels_first':\n                x_shape = (1, 3) + shape\n            else:\n                x_shape = (1,) + shape + (3,)\n            check_single_tensor_operation('spatial_2d_padding', x_shape, WITH_NP,\n                                          padding=padding, data_format=data_format)\n        # Check handling of dynamic shapes.\n        if K in [KTF, KTH]:\n            x = K.placeholder(shape=(1, None, None, 1))\n            y = K.spatial_2d_padding(x, padding=padding, data_format='channels_last')\n            assert K.int_shape(y) == (1, None, None, 1)\n\n        # Test invalid use cases\n        xval = np.random.random(x_shape)\n        with pytest.raises(ValueError):\n            K.spatial_2d_padding(K.variable(xval), padding=padding,\n                                 data_format='channels_middle')",
        "begin_line": 1550,
        "end_line": 1570,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_spatial_3d_padding#1572",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_spatial_3d_padding(self)",
        "snippet": "    def test_spatial_3d_padding(self):\n        padding = ((1, 2), (2, 1), (1, 2))\n        for data_format in ['channels_first', 'channels_last']:\n            shape = (5, 5, 5)\n            if data_format == 'channels_first':\n                x_shape = (1, 3) + shape\n            else:\n                x_shape = (1,) + shape + (3,)\n            check_single_tensor_operation('spatial_3d_padding', x_shape, WITH_NP,\n                                          padding=padding, data_format=data_format)\n        # Check handling of dynamic shapes.\n        if K in [KTF, KTH]:\n            x = K.placeholder(shape=(1, None, None, None, 1))\n            y = K.spatial_3d_padding(x, padding=padding, data_format='channels_last')\n            assert K.int_shape(y) == (1, None, None, None, 1)\n\n        # Test invalid use cases\n        xval = np.random.random(x_shape)\n        with pytest.raises(ValueError):\n            K.spatial_3d_padding(K.variable(xval), padding=padding,\n                                 data_format='channels_middle')",
        "begin_line": 1572,
        "end_line": 1592,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_bias_add#1594",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_bias_add(self)",
        "snippet": "    def test_bias_add(self):\n        for data_format in ['channels_first', 'channels_last']:\n            for shape in [(), (3,), (2, 3), (5, 3, 2)]:\n                if data_format == 'channels_first':\n                    x_shape = (1, 4) + shape\n                else:\n                    x_shape = (1,) + shape + (4,)\n                bias_shape = (4,)\n                check_two_tensor_operation('bias_add', x_shape, bias_shape,\n                                           WITH_NP, cntk_dynamicity=True,\n                                           data_format=data_format)\n\n            if data_format == 'channels_first':\n                x_shape = (20, 6, 10)\n            else:\n                x_shape = (20, 10, 6)\n            check_two_tensor_operation('bias_add', x_shape, (10, 6),\n                                       WITH_NP, cntk_dynamicity=True,\n                                       data_format=data_format)\n\n        # Test invalid use cases\n        x = K.variable(np.random.random(x_shape))\n        b = K.variable(np.random.random(bias_shape))\n        with pytest.raises(ValueError):\n            K.bias_add(x, b, data_format='channels_middle')",
        "begin_line": 1594,
        "end_line": 1618,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_batchnorm_th#1623",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_batchnorm_th(self, x_shape)",
        "snippet": "    def test_batchnorm_th(self, x_shape):\n        x_val = np.random.random(x_shape).astype(np.float32)\n        x = K.variable(x_val)\n        z, _, _ = K.normalize_batch_in_training(\n            x, None, None, reduction_axes='per-activation')\n        z = K.eval(z)\n        assert z.shape == x_shape",
        "begin_line": 1623,
        "end_line": 1629,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_batchnorm_tf#1634",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_batchnorm_tf(self, x_shape)",
        "snippet": "    def test_batchnorm_tf(self, x_shape):\n        x_val = np.random.random(x_shape).astype(np.float32)\n        x = K.variable(x_val)\n        z, _, _ = K.normalize_batch_in_training(\n            x, None, None, reduction_axes=[0, 1, 2, 3])\n        z = K.eval(z)\n        assert z.shape == x_shape",
        "begin_line": 1634,
        "end_line": 1640,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_batchnorm_cntk#1644",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_batchnorm_cntk(self, x_shape)",
        "snippet": "    def test_batchnorm_cntk(self, x_shape):\n        x_val = np.random.random(x_shape).astype(np.float32)\n        x = K.placeholder(x_shape)\n        z, _, _ = K.normalize_batch_in_training(\n            x, None, None, reduction_axes=[0, 1, 2, 3])\n        z = K.function([x], [z])([x_val])[0]\n        assert z.shape == x_shape",
        "begin_line": 1644,
        "end_line": 1650,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_ctc#1657",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_ctc(self)",
        "snippet": "    def test_ctc(self):\n        if K.backend() == 'theano':\n            ref = [1.73308, 3.81351]\n        else:\n            ref = [3.34211, 5.42262]\n        # simplified version of TensorFlow's test\n\n        label_lens = np.expand_dims(np.asarray([5, 4]), 1)\n        input_lens = np.expand_dims(np.asarray([5, 5]), 1)  # number of timesteps\n\n        # dimensions are batch x time x categories\n        labels = np.asarray([[0, 1, 2, 1, 0], [0, 1, 1, 0, -1]])\n        inputs = np.asarray(\n            [[[0.633766, 0.221185, 0.0917319, 0.0129757, 0.0142857, 0.0260553],\n              [0.111121, 0.588392, 0.278779, 0.0055756, 0.00569609, 0.010436],\n              [0.0357786, 0.633813, 0.321418, 0.00249248, 0.00272882, 0.0037688],\n              [0.0663296, 0.643849, 0.280111, 0.00283995, 0.0035545, 0.00331533],\n              [0.458235, 0.396634, 0.123377, 0.00648837, 0.00903441, 0.00623107]],\n             [[0.30176, 0.28562, 0.0831517, 0.0862751, 0.0816851, 0.161508],\n              [0.24082, 0.397533, 0.0557226, 0.0546814, 0.0557528, 0.19549],\n              [0.230246, 0.450868, 0.0389607, 0.038309, 0.0391602, 0.202456],\n              [0.280884, 0.429522, 0.0326593, 0.0339046, 0.0326856, 0.190345],\n              [0.423286, 0.315517, 0.0338439, 0.0393744, 0.0339315, 0.154046]]],\n            dtype=np.float32)\n\n        k_labels = K.variable(labels, dtype=\"int32\")\n        k_inputs = K.variable(inputs, dtype=\"float32\")\n        k_input_lens = K.variable(input_lens, dtype=\"int32\")\n        k_label_lens = K.variable(label_lens, dtype=\"int32\")\n        res = K.eval(K.ctc_batch_cost(k_labels, k_inputs, k_input_lens,\n                                      k_label_lens))\n        if K.backend() == 'theano':\n            assert_allclose(res[0, :], ref, atol=1e-05)\n        else:\n            assert_allclose(res[:, 0], ref, atol=1e-05)\n\n        # test when batch_size = 1, that is, one sample only\n        # get only first sample from above test case\n        if K.backend() == 'theano':\n            ref = [1.73308]\n        else:\n            ref = [3.34211]\n\n        input_lens = np.expand_dims(np.asarray([5]), 1)\n        label_lens = np.expand_dims(np.asarray([5]), 1)\n\n        labels = np.asarray([[0, 1, 2, 1, 0]])\n        inputs = np.asarray(\n            [[[0.633766, 0.221185, 0.0917319, 0.0129757, 0.0142857, 0.0260553],\n              [0.111121, 0.588392, 0.278779, 0.0055756, 0.00569609, 0.010436],\n              [0.0357786, 0.633813, 0.321418, 0.00249248, 0.00272882, 0.0037688],\n              [0.0663296, 0.643849, 0.280111, 0.00283995, 0.0035545, 0.00331533],\n              [0.458235, 0.396634, 0.123377, 0.00648837, 0.00903441, 0.00623107]]],\n            dtype=np.float32)\n\n        k_labels = K.variable(labels, dtype=\"int32\")\n        k_inputs = K.variable(inputs, dtype=\"float32\")\n        k_input_lens = K.variable(input_lens, dtype=\"int32\")\n        k_label_lens = K.variable(label_lens, dtype=\"int32\")\n        res = K.eval(K.ctc_batch_cost(k_labels, k_inputs, k_input_lens,\n                                      k_label_lens))\n        if K.backend() == 'theano':\n            assert_allclose(res[0, :], ref, atol=1e-05)\n        else:\n            assert_allclose(res[:, 0], ref, atol=1e-05)",
        "begin_line": 1657,
        "end_line": 1721,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_ctc_decode_greedy#1725",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_ctc_decode_greedy(self)",
        "snippet": "    def test_ctc_decode_greedy(self):\n        \"\"\"Test two batch entries - best path decoder.\"\"\"\n        max_time_steps = 6\n\n        seq_len_0 = 4\n        input_prob_matrix_0 = np.asarray(\n            [[1.0, 0.0, 0.0, 0.0],  # t=0\n             [0.0, 0.0, 0.4, 0.6],  # t=1\n             [0.0, 0.0, 0.4, 0.6],  # t=2\n             [0.0, 0.9, 0.1, 0.0],  # t=3\n             [0.0, 0.0, 0.0, 0.0],  # t=4 (ignored)\n             [0.0, 0.0, 0.0, 0.0]],  # t=5 (ignored)\n            dtype=np.float32)\n\n        seq_len_1 = 5\n        # dimensions are time x depth\n\n        input_prob_matrix_1 = np.asarray(\n            [[0.1, 0.9, 0.0, 0.0],  # t=0\n             [0.0, 0.9, 0.1, 0.0],  # t=1\n             [0.0, 0.0, 0.1, 0.9],  # t=2\n             [0.0, 0.9, 0.1, 0.1],  # t=3\n             [0.9, 0.1, 0.0, 0.0],  # t=4\n             [0.0, 0.0, 0.0, 0.0]],  # t=5 (ignored)\n            dtype=np.float32)\n\n        # len max_time_steps array of batch_size x depth matrices\n        inputs = [np.vstack([input_prob_matrix_0[t, :],\n                             input_prob_matrix_1[t, :]])\n                  for t in range(max_time_steps)]\n\n        # change tensorflow order to keras backend order\n        inputs = np.asarray(inputs).transpose((1, 0, 2))\n\n        # batch_size length vector of sequence_lengths\n        input_length = np.array([seq_len_0, seq_len_1], dtype=np.int32)\n\n        decode_pred_np, log_prob_pred_np = KNP.ctc_decode(inputs,\n                                                          input_length, greedy=True)\n        inputs = K.variable(inputs)\n        input_length = K.variable(input_length)\n        decode_pred_tf, log_prob_pred_tf = K.ctc_decode(inputs,\n                                                        input_length, greedy=True)\n\n        assert len(decode_pred_tf) == 1\n\n        decode_pred = K.eval(decode_pred_tf[0])\n        log_prob_pred = K.eval(log_prob_pred_tf)\n\n        assert np.alltrue(decode_pred_np == decode_pred)\n        assert np.allclose(log_prob_pred_np, log_prob_pred)",
        "begin_line": 1725,
        "end_line": 1775,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_slice#1785",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_slice(self, x_size)",
        "snippet": "    def test_slice(self, x_size):\n        npt = np.array([[[1, 1, 1], [2, 2, 2]],\n                       [[3, 3, 3], [4, 4, 4]],\n                       [[5, 5, 5], [6, 6, 6]]])\n        x_start = [1, 0, 0]\n        tft = K.constant(npt)\n        test_input = K.eval(K.slice(tft, x_start, x_size))\n        expected = KNP.slice(npt, x_start, x_size)\n        assert np.allclose(test_input, expected)",
        "begin_line": 1785,
        "end_line": 1793,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_ctc_decode_beam_search#1798",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_ctc_decode_beam_search(self)",
        "snippet": "    def test_ctc_decode_beam_search(self):\n        \"\"\"Test one batch, two beams - hibernating beam search.\"\"\"\n\n        depth = 6\n\n        seq_len_0 = 5\n        input_prob_matrix_0 = np.asarray(\n            [[0.30999, 0.309938, 0.0679938, 0.0673362, 0.0708352, 0.173908],\n             [0.215136, 0.439699, 0.0370931, 0.0393967, 0.0381581, 0.230517],\n             [0.199959, 0.489485, 0.0233221, 0.0251417, 0.0233289, 0.238763],\n             [0.279611, 0.452966, 0.0204795, 0.0209126, 0.0194803, 0.20655],\n             [0.51286, 0.288951, 0.0243026, 0.0220788, 0.0219297, 0.129878],\n             # Random entry added in at time=5\n             [0.155251, 0.164444, 0.173517, 0.176138, 0.169979, 0.160671]],\n            dtype=np.float32)\n\n        # Add arbitrary offset - this is fine\n        input_prob_matrix_0 = input_prob_matrix_0 + 2.0\n\n        # len max_time_steps array of batch_size x depth matrices\n        inputs = ([input_prob_matrix_0[t, :][np.newaxis, :]\n                   for t in range(seq_len_0)] +  # Pad to max_time_steps = 8\n                  2 * [np.zeros((1, depth), dtype=np.float32)])\n\n        # Take exponential as we directly apply ctc_decode_beam_search\n        inputs = np.exp(inputs)\n\n        # change tensorflow order to keras backend order\n        inputs = K.variable(inputs.transpose((1, 0, 2)))\n\n        # batch_size length vector of sequence_lengths\n        input_length = K.variable(np.array([seq_len_0], dtype=np.int32))\n        # batch_size length vector of log probabilities\n        log_prob_truth = np.array(\n            [\n                -5.811451,  # output beam 0\n                -6.63339  # output beam 1\n            ],\n            np.float32)[np.newaxis, :]\n\n        decode_truth = [np.array([1, 0]), np.array([[1]])]\n\n        beam_width = 2\n        top_paths = 2\n\n        decode_pred_tf, log_prob_pred_tf = K.ctc_decode(inputs,\n                                                        input_length,\n                                                        greedy=False,\n                                                        beam_width=beam_width,\n                                                        top_paths=top_paths)\n\n        assert len(decode_pred_tf) == top_paths\n\n        log_prob_pred = K.eval(log_prob_pred_tf)\n\n        for i in range(top_paths):\n            assert np.alltrue(decode_truth[i] == K.eval(decode_pred_tf[i]))\n\n        assert np.allclose(log_prob_truth, log_prob_pred)",
        "begin_line": 1798,
        "end_line": 1856,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_ctc_decode_beam_search_no_merge#1861",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_ctc_decode_beam_search_no_merge(self)",
        "snippet": "    def test_ctc_decode_beam_search_no_merge(self):\n        # A simple CTC probability map with some repeating characters,\n        # shape(batch, input_width, char_count)\n        # Without merging should be decoded as: \"AABB\", with merging as: \"AB\".\n        input_prob = np.array([\n            [  # blank, A ,B\n                [0, 0, 1],  # blank\n                [1, 0, 0],  # A\n                [0, 0, 1],  # blank\n                [1, 0, 0],  # A\n                [0, 1, 0],  # B\n                [0, 0, 1],  # blank\n                [0, 1, 0]  # B\n            ]\n        ])\n        input_len = np.array(input_prob.shape[0] * [input_prob.shape[1]])\n\n        def decode(merge_repeated):\n            input_prob_tensor = K.placeholder(shape=(None, None, None),\n                                              dtype='float32')\n            input_len_tensor = K.placeholder(shape=(None), dtype='int64')\n            paths_tensors, _ = K.ctc_decode(input_prob_tensor, input_len_tensor,\n                                            greedy=False, beam_width=1, top_paths=1,\n                                            merge_repeated=merge_repeated)\n            decode_func = K.function([input_prob_tensor, input_len_tensor],\n                                     paths_tensors)\n            paths = decode_func([input_prob, input_len])\n            return paths\n\n        # merged: A B\n        assert np.allclose(decode(merge_repeated=True), [np.array([[0, 1]])])\n        # not merged: A A B B\n        assert np.allclose(decode(merge_repeated=False), [np.array([[0, 0, 1, 1]])])",
        "begin_line": 1861,
        "end_line": 1893,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.decode#1878",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.decode(merge_repeated)",
        "snippet": "        def decode(merge_repeated):\n            input_prob_tensor = K.placeholder(shape=(None, None, None),\n                                              dtype='float32')\n            input_len_tensor = K.placeholder(shape=(None), dtype='int64')\n            paths_tensors, _ = K.ctc_decode(input_prob_tensor, input_len_tensor,\n                                            greedy=False, beam_width=1, top_paths=1,\n                                            merge_repeated=merge_repeated)\n            decode_func = K.function([input_prob_tensor, input_len_tensor],\n                                     paths_tensors)\n            paths = decode_func([input_prob, input_len])\n            return paths",
        "begin_line": 1878,
        "end_line": 1888,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_one_hot#1895",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_one_hot(self)",
        "snippet": "    def test_one_hot(self):\n        input_length = 10\n        num_classes = 20\n        batch_size = 30\n        indices = np.random.randint(0, num_classes, size=(batch_size, input_length))\n        oh = KNP.one_hot(np.int32(indices), num_classes)\n        koh = K.eval(K.one_hot(K.variable(indices, dtype='int32'), num_classes))\n        assert np.all(koh == oh)",
        "begin_line": 1895,
        "end_line": 1902,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_sparse_dot#1907",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_sparse_dot(self)",
        "snippet": "    def test_sparse_dot(self):\n        x_d = np.array([0, 7, 2, 3], dtype=np.float32)\n        x_r = np.array([0, 2, 2, 3], dtype=np.int64)\n        x_c = np.array([4, 3, 2, 3], dtype=np.int64)\n\n        x_sparse = sparse.csr_matrix((x_d, (x_r, x_c)), shape=(4, 5))\n        x_dense = x_sparse.toarray()\n\n        W = np.random.random((5, 4))\n        t_W = K.variable(W)\n        k_s = K.eval(K.dot(K.variable(x_sparse), t_W))\n        k_d = K.eval(K.dot(K.variable(x_dense), t_W))\n\n        assert k_s.shape == k_d.shape\n        assert_allclose(k_s, k_d, atol=1e-05)",
        "begin_line": 1907,
        "end_line": 1921,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_sparse_concat#1926",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_sparse_concat(self)",
        "snippet": "    def test_sparse_concat(self):\n        x_d = np.array([0, 7, 2, 3], dtype=np.float32)\n        x_r = np.array([0, 2, 2, 3], dtype=np.int64)\n        x_c = np.array([4, 3, 2, 3], dtype=np.int64)\n\n        x_sparse_1 = sparse.csr_matrix((x_d, (x_r, x_c)), shape=(4, 5))\n\n        x_d = np.array([0, 7, 2, 3], dtype=np.float32)\n        x_r = np.array([0, 2, 2, 3], dtype=np.int64)\n        x_c = np.array([4, 3, 2, 3], dtype=np.int64)\n\n        x_sparse_2 = sparse.csr_matrix((x_d, (x_r, x_c)), shape=(4, 5))\n\n        x_dense_1 = x_sparse_1.toarray()\n        x_dense_2 = x_sparse_2.toarray()\n\n        k_s = K.concatenate([K.variable(x_sparse_1), K.variable(x_sparse_2)])\n        assert K.is_sparse(k_s)\n\n        k_s_d = K.eval(k_s)\n\n        k_d = K.eval(K.concatenate([K.variable(x_dense_1), K.variable(x_dense_2)]))\n\n        assert k_s_d.shape == k_d.shape\n        assert_allclose(k_s_d, k_d, atol=1e-05)",
        "begin_line": 1926,
        "end_line": 1950,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_stack#1952",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_stack(self)",
        "snippet": "    def test_stack(self):\n        tensor_list = [np.random.randn(5, 4, 6, 10) for _ in range(5)]\n        stack_axis = 3\n        results = []\n        if WITH_NP[0] == KC:\n            check_two_tensor_operation('stack', (5, 4, 6, 10),\n                                       (5, 4, 6, 10), WITH_NP,\n                                       axis=stack_axis, concat_args=True)\n        else:\n            for k in WITH_NP:\n                tensor_list_var = [k.variable(tensor) for tensor in tensor_list]\n                out = k.eval(k.stack(tensor_list_var, axis=stack_axis))\n                results.append(out)\n\n            assert_list_pairwise(results)",
        "begin_line": 1952,
        "end_line": 1966,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_map#1969",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_map(self)",
        "snippet": "    def test_map(self):\n        x = np.random.rand(10, 3).astype(np.float32)\n        vx = K.variable(x)\n        kx = K.eval(K.map_fn(K.sum, vx))\n        # make sure we can also walk the indexes in tensorflow which we\n        # can't without specifying dtype\n        kx2 = K.eval(K.map_fn(\n            lambda i: K.sum(vx[i]),\n            K.arange(10),\n            dtype=K.floatx()\n        ))\n\n        assert (10,) == kx.shape\n        assert (10,) == kx2.shape\n        assert_allclose(x.sum(axis=1), kx, atol=1e-05)\n        assert_allclose(kx, kx2, atol=1e-05)",
        "begin_line": 1969,
        "end_line": 1984,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_foldl#1987",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_foldl(self)",
        "snippet": "    def test_foldl(self):\n        x = np.random.rand(10, 3).astype(np.float32)\n        kx = K.eval(K.foldl(lambda a, b: a + b, K.variable(x)))\n\n        assert (3,) == kx.shape\n        assert_allclose(x.sum(axis=0), kx, atol=1e-05)",
        "begin_line": 1987,
        "end_line": 1992,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_foldr#1995",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_foldr(self)",
        "snippet": "    def test_foldr(self):\n        # This test aims to make sure that we walk the array from right to left\n        # and checks it in the following way: multiplying left to right 1e-40\n        # cannot be held into a float32 so it causes an underflow while from\n        # right to left we have no such problem and the result is larger\n        x = np.array([1e-20, 1e-20, 10, 10, 10], dtype=np.float32)\n        vx = K.variable(x)\n        p1 = K.eval(K.foldl(lambda a, b: a * b, vx))\n        p2 = K.eval(K.foldr(lambda a, b: a * b, vx))\n\n        assert p1 < p2\n        assert 9e-38 < p2 <= 1e-37",
        "begin_line": 1995,
        "end_line": 2006,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_arange#2010",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_arange(self)",
        "snippet": "    def test_arange(self):\n        for test_value in (-20, 0, 1, 10):\n            a_list = []\n            dtype_list = []\n            for k in WITH_NP:\n                t = k.arange(test_value)\n                a = k.eval(t)\n                assert np.array_equal(a, np.arange(test_value))\n                dtype_list.append(k.dtype(t))\n                a_list.append(a)\n\n            for i in range(len(a_list) - 1):\n                assert np.array_equal(a_list[i], a_list[i + 1])\n\n        for start, stop, step in ((0, 5, 1), (-5, 5, 2), (0, 1, 2)):\n            a_list = []\n            for k in WITH_NP:\n                a = k.eval(k.arange(start, stop, step))\n                assert np.array_equal(a, np.arange(start, stop, step))\n                a_list.append(a)\n            for i in range(len(a_list) - 1):\n                assert np.array_equal(a_list[i], a_list[i + 1])\n\n        for dtype in ('int32', 'int64', 'float32', 'float64'):\n            for k in WITH_NP:\n                t = k.arange(10, dtype=dtype)\n                assert k.dtype(t) == dtype\n\n        start = K.constant(1, dtype='int32')\n        t = K.arange(start)\n        assert len(K.eval(t)) == 1\n\n        start = K.constant(-1, dtype='int32')\n        t = K.arange(start)\n        assert len(K.eval(t)) == 0",
        "begin_line": 2010,
        "end_line": 2044,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_in_train_phase#2047",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_in_train_phase(self, training)",
        "snippet": "    def test_in_train_phase(self, training):\n        check_two_tensor_operation('in_train_phase', (3, 3), (2, 2), WITH_NP,\n                                   training=training)\n        check_two_tensor_operation('in_train_phase', (2, 3), (2, 3), WITH_NP,\n                                   training=training)",
        "begin_line": 2047,
        "end_line": 2051,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_in_test_phase#2054",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_in_test_phase(self, training)",
        "snippet": "    def test_in_test_phase(self, training):\n        check_two_tensor_operation('in_test_phase', (3, 3), (2, 2), WITH_NP,\n                                   training=training)\n        check_two_tensor_operation('in_test_phase', (2, 3), (2, 3), WITH_NP,\n                                   training=training)",
        "begin_line": 2054,
        "end_line": 2058,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_setfloatx_incorrect_values#2060",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_setfloatx_incorrect_values(self)",
        "snippet": "    def test_setfloatx_incorrect_values(self):\n        # Keep track of the old value\n        old_floatx = floatx()\n        # Try some incorrect values\n        initial = floatx()\n        for value in ['', 'beerfloat', 123]:\n            with pytest.raises(ValueError):\n                set_floatx(value)\n        assert floatx() == initial\n        # Restore old value\n        set_floatx(old_floatx)",
        "begin_line": 2060,
        "end_line": 2070,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_setfloatx_correct_values#2072",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_setfloatx_correct_values(self)",
        "snippet": "    def test_setfloatx_correct_values(self):\n        # Keep track of the old value\n        old_floatx = floatx()\n        # Check correct values\n        for value in ['float16', 'float32', 'float64']:\n            set_floatx(value)\n            assert floatx() == value\n        # Restore old value\n        set_floatx(old_floatx)",
        "begin_line": 2072,
        "end_line": 2080,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_set_floatx#2084",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_set_floatx(self)",
        "snippet": "    def test_set_floatx(self):\n        \"\"\"\n        Make sure that changes to the global floatx are effectively\n        taken into account by the backend.\n        \"\"\"\n        # Keep track of the old value\n        old_floatx = floatx()\n\n        set_floatx('float16')\n        var = variable([10])\n        check_dtype(var, 'float16')\n\n        set_floatx('float64')\n        var = variable([10])\n        check_dtype(var, 'float64')\n\n        # Restore old value\n        set_floatx(old_floatx)",
        "begin_line": 2084,
        "end_line": 2101,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_dtype#2103",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_dtype(self)",
        "snippet": "    def test_dtype(self):\n        assert K.dtype(K.variable(1, dtype='float64')) == 'float64'\n        assert K.dtype(K.variable(1, dtype='float32')) == 'float32'\n        assert K.dtype(K.variable(1, dtype='float16')) == 'float16'",
        "begin_line": 2103,
        "end_line": 2106,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_variable_support_bool_dtype#2108",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_variable_support_bool_dtype(self)",
        "snippet": "    def test_variable_support_bool_dtype(self):\n        # Github issue: 7819\n        if K.backend() == 'tensorflow':\n            assert K.dtype(K.variable(1, dtype='int16')) == 'int16'\n            assert K.dtype(K.variable(False, dtype='bool')) == 'bool'\n            with pytest.raises(TypeError):\n                K.variable('', dtype='unsupported')",
        "begin_line": 2108,
        "end_line": 2114,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_clip_supports_tensor_arguments#2116",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_clip_supports_tensor_arguments(self)",
        "snippet": "    def test_clip_supports_tensor_arguments(self):\n        # GitHub issue: 11435\n        x = K.variable([-10., -5., 0., 5., 10.])\n        min_value = K.variable([-5., -4., 0., 3., 5.])\n        max_value = K.variable([5., 4., 1., 4., 9.])\n\n        assert np.allclose(K.eval(K.clip(x, min_value, max_value)),\n                           np.asarray([-5., -4., 0., 4., 9.], dtype=np.float32))",
        "begin_line": 2116,
        "end_line": 2123,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_tensorflow_session_parallelism_settings#2127",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_tensorflow_session_parallelism_settings(self, monkeypatch)",
        "snippet": "    def test_tensorflow_session_parallelism_settings(self, monkeypatch):\n        for threads in [0, 1, 4]:\n            K.clear_session()\n            monkeypatch.setenv('OMP_NUM_THREADS', str(threads))\n            cfg = K.get_session()._config\n            assert cfg.intra_op_parallelism_threads == threads\n            assert cfg.inter_op_parallelism_threads == threads",
        "begin_line": 2127,
        "end_line": 2133,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.conftest.clear_session_after_test#6",
        "src_path": "tests/conftest.py",
        "class_name": "tests.conftest",
        "signature": "tests.conftest.clear_session_after_test()",
        "snippet": "def clear_session_after_test():\n    \"\"\"Test wrapper to clean up after TensorFlow and CNTK tests.\n\n    This wrapper runs for all the tests in the keras test suite.\n    \"\"\"\n    yield\n    if K.backend() == 'tensorflow' or K.backend() == 'cntk':\n        K.clear_session()",
        "begin_line": 6,
        "end_line": 13,
        "comment": "",
        "is_bug": false
    }
]