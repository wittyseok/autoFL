[
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.assert_dtype#29",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64",
        "signature": "pandas.tests.arithmetic.test_timedelta64.assert_dtype(obj, expected_dtype)",
        "snippet": "def assert_dtype(obj, expected_dtype):\n    \"\"\"\n    Helper to check the dtype for a Series, Index, or single-column DataFrame.\n    \"\"\"\n    if isinstance(obj, DataFrame):\n        dtype = obj.dtypes.iat[0]\n    else:\n        dtype = obj.dtype\n\n    assert dtype == expected_dtype",
        "begin_line": 29,
        "end_line": 38,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayLikeComparisons.test_compare_timedelta64_zerodim#50",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayLikeComparisons",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayLikeComparisons.test_compare_timedelta64_zerodim(self, box_with_array)",
        "snippet": "    def test_compare_timedelta64_zerodim(self, box_with_array):\n        # GH#26689 should unbox when comparing with zerodim array\n        box = box_with_array\n        xbox = box_with_array if box_with_array is not pd.Index else np.ndarray\n\n        tdi = pd.timedelta_range(\"2H\", periods=4)\n        other = np.array(tdi.to_numpy()[0])\n\n        tdi = tm.box_expected(tdi, box)\n        res = tdi <= other\n        expected = np.array([True, False, False, False])\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(res, expected)\n\n        msg = \"Invalid comparison between dtype\"\n        with pytest.raises(TypeError, match=msg):\n            # zero-dim of wrong dtype should still raise\n            tdi >= np.array(4)",
        "begin_line": 50,
        "end_line": 67,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayLikeComparisons.test_compare_timedeltalike_scalar#73",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayLikeComparisons",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayLikeComparisons.test_compare_timedeltalike_scalar(self, box_with_array, td_scalar)",
        "snippet": "    def test_compare_timedeltalike_scalar(self, box_with_array, td_scalar):\n        # regression test for GH#5963\n        box = box_with_array\n        xbox = box if box is not pd.Index else np.ndarray\n        ser = pd.Series([timedelta(days=1), timedelta(days=2)])\n        ser = tm.box_expected(ser, box)\n        actual = ser > td_scalar\n        expected = pd.Series([False, True])\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(actual, expected)",
        "begin_line": 73,
        "end_line": 82,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayLikeComparisons.test_td64_comparisons_invalid#85",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayLikeComparisons",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayLikeComparisons.test_td64_comparisons_invalid(self, box_with_array, invalid)",
        "snippet": "    def test_td64_comparisons_invalid(self, box_with_array, invalid):\n        # GH#13624 for str\n        box = box_with_array\n        rng = timedelta_range(\"1 days\", periods=10)\n        obj = tm.box_expected(rng, box)\n\n        assert_invalid_comparison(obj, invalid, box)",
        "begin_line": 85,
        "end_line": 91,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayLikeComparisons.test_td64arr_cmp_arraylike_invalid#108",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayLikeComparisons",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayLikeComparisons.test_td64arr_cmp_arraylike_invalid(self, other)",
        "snippet": "    def test_td64arr_cmp_arraylike_invalid(self, other):\n        # We don't parametrize this over box_with_array because listlike\n        #  other plays poorly with assert_invalid_comparison reversed checks\n\n        rng = timedelta_range(\"1 days\", periods=10)._data\n        assert_invalid_comparison(rng, other, tm.to_array)",
        "begin_line": 108,
        "end_line": 113,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayLikeComparisons.test_td64arr_cmp_mixed_invalid#115",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayLikeComparisons",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayLikeComparisons.test_td64arr_cmp_mixed_invalid(self)",
        "snippet": "    def test_td64arr_cmp_mixed_invalid(self):\n        rng = timedelta_range(\"1 days\", periods=5)._data\n\n        other = np.array([0, 1, 2, rng[3], pd.Timestamp.now()])\n        result = rng == other\n        expected = np.array([False, False, False, True, False])\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = rng != other\n        tm.assert_numpy_array_equal(result, ~expected)\n\n        msg = \"Invalid comparison between|Cannot compare type|not supported between\"\n        with pytest.raises(TypeError, match=msg):\n            rng < other\n        with pytest.raises(TypeError, match=msg):\n            rng > other\n        with pytest.raises(TypeError, match=msg):\n            rng <= other\n        with pytest.raises(TypeError, match=msg):\n            rng >= other",
        "begin_line": 115,
        "end_line": 134,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayComparisons.test_comp_nat#141",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayComparisons",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayComparisons.test_comp_nat(self, dtype)",
        "snippet": "    def test_comp_nat(self, dtype):\n        left = pd.TimedeltaIndex(\n            [pd.Timedelta(\"1 days\"), pd.NaT, pd.Timedelta(\"3 days\")]\n        )\n        right = pd.TimedeltaIndex([pd.NaT, pd.NaT, pd.Timedelta(\"3 days\")])\n\n        lhs, rhs = left, right\n        if dtype is object:\n            lhs, rhs = left.astype(object), right.astype(object)\n\n        result = rhs == lhs\n        expected = np.array([False, False, True])\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = rhs != lhs\n        expected = np.array([True, True, False])\n        tm.assert_numpy_array_equal(result, expected)\n\n        expected = np.array([False, False, False])\n        tm.assert_numpy_array_equal(lhs == pd.NaT, expected)\n        tm.assert_numpy_array_equal(pd.NaT == rhs, expected)\n\n        expected = np.array([True, True, True])\n        tm.assert_numpy_array_equal(lhs != pd.NaT, expected)\n        tm.assert_numpy_array_equal(pd.NaT != lhs, expected)\n\n        expected = np.array([False, False, False])\n        tm.assert_numpy_array_equal(lhs < pd.NaT, expected)\n        tm.assert_numpy_array_equal(pd.NaT > lhs, expected)",
        "begin_line": 141,
        "end_line": 169,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayComparisons.test_comparisons_nat#171",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayComparisons",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayComparisons.test_comparisons_nat(self)",
        "snippet": "    def test_comparisons_nat(self):\n        tdidx1 = pd.TimedeltaIndex(\n            [\n                \"1 day\",\n                pd.NaT,\n                \"1 day 00:00:01\",\n                pd.NaT,\n                \"1 day 00:00:01\",\n                \"5 day 00:00:03\",\n            ]\n        )\n        tdidx2 = pd.TimedeltaIndex(\n            [\"2 day\", \"2 day\", pd.NaT, pd.NaT, \"1 day 00:00:02\", \"5 days 00:00:03\"]\n        )\n        tdarr = np.array(\n            [\n                np.timedelta64(2, \"D\"),\n                np.timedelta64(2, \"D\"),\n                np.timedelta64(\"nat\"),\n                np.timedelta64(\"nat\"),\n                np.timedelta64(1, \"D\") + np.timedelta64(2, \"s\"),\n                np.timedelta64(5, \"D\") + np.timedelta64(3, \"s\"),\n            ]\n        )\n\n        cases = [(tdidx1, tdidx2), (tdidx1, tdarr)]\n\n        # Check pd.NaT is handles as the same as np.nan\n        for idx1, idx2 in cases:\n\n            result = idx1 < idx2\n            expected = np.array([True, False, False, False, True, False])\n            tm.assert_numpy_array_equal(result, expected)\n\n            result = idx2 > idx1\n            expected = np.array([True, False, False, False, True, False])\n            tm.assert_numpy_array_equal(result, expected)\n\n            result = idx1 <= idx2\n            expected = np.array([True, False, False, False, True, True])\n            tm.assert_numpy_array_equal(result, expected)\n\n            result = idx2 >= idx1\n            expected = np.array([True, False, False, False, True, True])\n            tm.assert_numpy_array_equal(result, expected)\n\n            result = idx1 == idx2\n            expected = np.array([False, False, False, False, False, True])\n            tm.assert_numpy_array_equal(result, expected)\n\n            result = idx1 != idx2\n            expected = np.array([True, True, True, True, True, False])\n            tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 171,
        "end_line": 223,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayComparisons.test_comparisons_coverage#226",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayComparisons",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayComparisons.test_comparisons_coverage(self)",
        "snippet": "    def test_comparisons_coverage(self):\n        rng = timedelta_range(\"1 days\", periods=10)\n\n        result = rng < rng[3]\n        expected = np.array([True, True, True] + [False] * 7)\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = rng == list(rng)\n        exp = rng == rng\n        tm.assert_numpy_array_equal(result, exp)",
        "begin_line": 226,
        "end_line": 235,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_ufunc_coercions#246",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_ufunc_coercions(self)",
        "snippet": "    def test_ufunc_coercions(self):\n        # normal ops are also tested in tseries/test_timedeltas.py\n        idx = TimedeltaIndex([\"2H\", \"4H\", \"6H\", \"8H\", \"10H\"], freq=\"2H\", name=\"x\")\n\n        for result in [idx * 2, np.multiply(idx, 2)]:\n            assert isinstance(result, TimedeltaIndex)\n            exp = TimedeltaIndex([\"4H\", \"8H\", \"12H\", \"16H\", \"20H\"], freq=\"4H\", name=\"x\")\n            tm.assert_index_equal(result, exp)\n            assert result.freq == \"4H\"\n\n        for result in [idx / 2, np.divide(idx, 2)]:\n            assert isinstance(result, TimedeltaIndex)\n            exp = TimedeltaIndex([\"1H\", \"2H\", \"3H\", \"4H\", \"5H\"], freq=\"H\", name=\"x\")\n            tm.assert_index_equal(result, exp)\n            assert result.freq == \"H\"\n\n        idx = TimedeltaIndex([\"2H\", \"4H\", \"6H\", \"8H\", \"10H\"], freq=\"2H\", name=\"x\")\n        for result in [-idx, np.negative(idx)]:\n            assert isinstance(result, TimedeltaIndex)\n            exp = TimedeltaIndex(\n                [\"-2H\", \"-4H\", \"-6H\", \"-8H\", \"-10H\"], freq=\"-2H\", name=\"x\"\n            )\n            tm.assert_index_equal(result, exp)\n            assert result.freq == \"-2H\"\n\n        idx = TimedeltaIndex([\"-2H\", \"-1H\", \"0H\", \"1H\", \"2H\"], freq=\"H\", name=\"x\")\n        for result in [abs(idx), np.absolute(idx)]:\n            assert isinstance(result, TimedeltaIndex)\n            exp = TimedeltaIndex([\"2H\", \"1H\", \"0H\", \"1H\", \"2H\"], freq=None, name=\"x\")\n            tm.assert_index_equal(result, exp)\n            assert result.freq is None",
        "begin_line": 246,
        "end_line": 276,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_subtraction_ops#278",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_subtraction_ops(self)",
        "snippet": "    def test_subtraction_ops(self):\n        # with datetimes/timedelta and tdi/dti\n        tdi = TimedeltaIndex([\"1 days\", pd.NaT, \"2 days\"], name=\"foo\")\n        dti = pd.date_range(\"20130101\", periods=3, name=\"bar\")\n        td = Timedelta(\"1 days\")\n        dt = Timestamp(\"20130101\")\n\n        msg = \"cannot subtract a datelike from a TimedeltaArray\"\n        with pytest.raises(TypeError, match=msg):\n            tdi - dt\n        with pytest.raises(TypeError, match=msg):\n            tdi - dti\n\n        msg = r\"unsupported operand type\\(s\\) for -\"\n        with pytest.raises(TypeError, match=msg):\n            td - dt\n\n        msg = \"(bad|unsupported) operand type for unary\"\n        with pytest.raises(TypeError, match=msg):\n            td - dti\n\n        result = dt - dti\n        expected = TimedeltaIndex([\"0 days\", \"-1 days\", \"-2 days\"], name=\"bar\")\n        tm.assert_index_equal(result, expected)\n\n        result = dti - dt\n        expected = TimedeltaIndex([\"0 days\", \"1 days\", \"2 days\"], name=\"bar\")\n        tm.assert_index_equal(result, expected)\n\n        result = tdi - td\n        expected = TimedeltaIndex([\"0 days\", pd.NaT, \"1 days\"], name=\"foo\")\n        tm.assert_index_equal(result, expected, check_names=False)\n\n        result = td - tdi\n        expected = TimedeltaIndex([\"0 days\", pd.NaT, \"-1 days\"], name=\"foo\")\n        tm.assert_index_equal(result, expected, check_names=False)\n\n        result = dti - td\n        expected = DatetimeIndex(\n            [\"20121231\", \"20130101\", \"20130102\"], freq=\"D\", name=\"bar\"\n        )\n        tm.assert_index_equal(result, expected, check_names=False)\n\n        result = dt - tdi\n        expected = DatetimeIndex([\"20121231\", pd.NaT, \"20121230\"], name=\"foo\")\n        tm.assert_index_equal(result, expected)",
        "begin_line": 278,
        "end_line": 323,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_subtraction_ops_with_tz#325",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_subtraction_ops_with_tz(self)",
        "snippet": "    def test_subtraction_ops_with_tz(self):\n\n        # check that dt/dti subtraction ops with tz are validated\n        dti = pd.date_range(\"20130101\", periods=3)\n        ts = Timestamp(\"20130101\")\n        dt = ts.to_pydatetime()\n        dti_tz = pd.date_range(\"20130101\", periods=3).tz_localize(\"US/Eastern\")\n        ts_tz = Timestamp(\"20130101\").tz_localize(\"US/Eastern\")\n        ts_tz2 = Timestamp(\"20130101\").tz_localize(\"CET\")\n        dt_tz = ts_tz.to_pydatetime()\n        td = Timedelta(\"1 days\")\n\n        def _check(result, expected):\n            assert result == expected\n            assert isinstance(result, Timedelta)\n\n        # scalars\n        result = ts - ts\n        expected = Timedelta(\"0 days\")\n        _check(result, expected)\n\n        result = dt_tz - ts_tz\n        expected = Timedelta(\"0 days\")\n        _check(result, expected)\n\n        result = ts_tz - dt_tz\n        expected = Timedelta(\"0 days\")\n        _check(result, expected)\n\n        # tz mismatches\n        msg = \"Timestamp subtraction must have the same timezones or no timezones\"\n        with pytest.raises(TypeError, match=msg):\n            dt_tz - ts\n        msg = \"can't subtract offset-naive and offset-aware datetimes\"\n        with pytest.raises(TypeError, match=msg):\n            dt_tz - dt\n        msg = \"Timestamp subtraction must have the same timezones or no timezones\"\n        with pytest.raises(TypeError, match=msg):\n            dt_tz - ts_tz2\n        msg = \"can't subtract offset-naive and offset-aware datetimes\"\n        with pytest.raises(TypeError, match=msg):\n            dt - dt_tz\n        msg = \"Timestamp subtraction must have the same timezones or no timezones\"\n        with pytest.raises(TypeError, match=msg):\n            ts - dt_tz\n        with pytest.raises(TypeError, match=msg):\n            ts_tz2 - ts\n        with pytest.raises(TypeError, match=msg):\n            ts_tz2 - dt\n        with pytest.raises(TypeError, match=msg):\n            ts_tz - ts_tz2\n\n        # with dti\n        with pytest.raises(TypeError, match=msg):\n            dti - ts_tz\n        with pytest.raises(TypeError, match=msg):\n            dti_tz - ts\n        with pytest.raises(TypeError, match=msg):\n            dti_tz - ts_tz2\n\n        result = dti_tz - dt_tz\n        expected = TimedeltaIndex([\"0 days\", \"1 days\", \"2 days\"])\n        tm.assert_index_equal(result, expected)\n\n        result = dt_tz - dti_tz\n        expected = TimedeltaIndex([\"0 days\", \"-1 days\", \"-2 days\"])\n        tm.assert_index_equal(result, expected)\n\n        result = dti_tz - ts_tz\n        expected = TimedeltaIndex([\"0 days\", \"1 days\", \"2 days\"])\n        tm.assert_index_equal(result, expected)\n\n        result = ts_tz - dti_tz\n        expected = TimedeltaIndex([\"0 days\", \"-1 days\", \"-2 days\"])\n        tm.assert_index_equal(result, expected)\n\n        result = td - td\n        expected = Timedelta(\"0 days\")\n        _check(result, expected)\n\n        result = dti_tz - td\n        expected = DatetimeIndex([\"20121231\", \"20130101\", \"20130102\"], tz=\"US/Eastern\")\n        tm.assert_index_equal(result, expected)",
        "begin_line": 325,
        "end_line": 407,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted._check#337",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted._check(result, expected)",
        "snippet": "        def _check(result, expected):\n            assert result == expected\n            assert isinstance(result, Timedelta)",
        "begin_line": 337,
        "end_line": 339,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_dti_tdi_numeric_ops#409",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_dti_tdi_numeric_ops(self)",
        "snippet": "    def test_dti_tdi_numeric_ops(self):\n        # These are normally union/diff set-like ops\n        tdi = TimedeltaIndex([\"1 days\", pd.NaT, \"2 days\"], name=\"foo\")\n        dti = pd.date_range(\"20130101\", periods=3, name=\"bar\")\n\n        # TODO(wesm): unused?\n        # td = Timedelta('1 days')\n        # dt = Timestamp('20130101')\n\n        result = tdi - tdi\n        expected = TimedeltaIndex([\"0 days\", pd.NaT, \"0 days\"], name=\"foo\")\n        tm.assert_index_equal(result, expected)\n\n        result = tdi + tdi\n        expected = TimedeltaIndex([\"2 days\", pd.NaT, \"4 days\"], name=\"foo\")\n        tm.assert_index_equal(result, expected)\n\n        result = dti - tdi  # name will be reset\n        expected = DatetimeIndex([\"20121231\", pd.NaT, \"20130101\"])\n        tm.assert_index_equal(result, expected)",
        "begin_line": 409,
        "end_line": 428,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_addition_ops#430",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_addition_ops(self)",
        "snippet": "    def test_addition_ops(self):\n        # with datetimes/timedelta and tdi/dti\n        tdi = TimedeltaIndex([\"1 days\", pd.NaT, \"2 days\"], name=\"foo\")\n        dti = pd.date_range(\"20130101\", periods=3, name=\"bar\")\n        td = Timedelta(\"1 days\")\n        dt = Timestamp(\"20130101\")\n\n        result = tdi + dt\n        expected = DatetimeIndex([\"20130102\", pd.NaT, \"20130103\"], name=\"foo\")\n        tm.assert_index_equal(result, expected)\n\n        result = dt + tdi\n        expected = DatetimeIndex([\"20130102\", pd.NaT, \"20130103\"], name=\"foo\")\n        tm.assert_index_equal(result, expected)\n\n        result = td + tdi\n        expected = TimedeltaIndex([\"2 days\", pd.NaT, \"3 days\"], name=\"foo\")\n        tm.assert_index_equal(result, expected)\n\n        result = tdi + td\n        expected = TimedeltaIndex([\"2 days\", pd.NaT, \"3 days\"], name=\"foo\")\n        tm.assert_index_equal(result, expected)\n\n        # unequal length\n        msg = \"cannot add indices of unequal length\"\n        with pytest.raises(ValueError, match=msg):\n            tdi + dti[0:1]\n        with pytest.raises(ValueError, match=msg):\n            tdi[0:1] + dti\n\n        # random indexes\n        msg = \"Addition/subtraction of integers and integer-arrays\"\n        with pytest.raises(TypeError, match=msg):\n            tdi + pd.Int64Index([1, 2, 3])\n\n        # this is a union!\n        # pytest.raises(TypeError, lambda : Int64Index([1,2,3]) + tdi)\n\n        result = tdi + dti  # name will be reset\n        expected = DatetimeIndex([\"20130102\", pd.NaT, \"20130105\"])\n        tm.assert_index_equal(result, expected)\n\n        result = dti + tdi  # name will be reset\n        expected = DatetimeIndex([\"20130102\", pd.NaT, \"20130105\"])\n        tm.assert_index_equal(result, expected)\n\n        result = dt + td\n        expected = Timestamp(\"20130102\")\n        assert result == expected\n\n        result = td + dt\n        expected = Timestamp(\"20130102\")\n        assert result == expected",
        "begin_line": 430,
        "end_line": 482,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_timedelta#487",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_timedelta(self, freq)",
        "snippet": "    def test_timedelta(self, freq):\n        index = pd.date_range(\"1/1/2000\", periods=50, freq=freq)\n\n        shifted = index + timedelta(1)\n        back = shifted + timedelta(-1)\n        back = back._with_freq(\"infer\")\n        tm.assert_index_equal(index, back)\n\n        if freq == \"D\":\n            expected = pd.tseries.offsets.Day(1)\n            assert index.freq == expected\n            assert shifted.freq == expected\n            assert back.freq == expected\n        else:  # freq == 'B'\n            assert index.freq == pd.tseries.offsets.BusinessDay(1)\n            assert shifted.freq is None\n            assert back.freq == pd.tseries.offsets.BusinessDay(1)\n\n        result = index - timedelta(1)\n        expected = index + timedelta(-1)\n        tm.assert_index_equal(result, expected)\n\n        # GH#4134, buggy with timedeltas\n        rng = pd.date_range(\"2013\", \"2014\")\n        s = Series(rng)\n        result1 = rng - pd.offsets.Hour(1)\n        result2 = DatetimeIndex(s - np.timedelta64(100000000))\n        result3 = rng - np.timedelta64(100000000)\n        result4 = DatetimeIndex(s - pd.offsets.Hour(1))\n\n        assert result1.freq == rng.freq\n        result1 = result1._with_freq(None)\n        tm.assert_index_equal(result1, result4)\n\n        assert result3.freq == rng.freq\n        result3 = result3._with_freq(None)\n        tm.assert_index_equal(result2, result3)",
        "begin_line": 487,
        "end_line": 523,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_tda_add_sub_index#525",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_tda_add_sub_index(self)",
        "snippet": "    def test_tda_add_sub_index(self):\n        # Check that TimedeltaArray defers to Index on arithmetic ops\n        tdi = TimedeltaIndex([\"1 days\", pd.NaT, \"2 days\"])\n        tda = tdi.array\n\n        dti = pd.date_range(\"1999-12-31\", periods=3, freq=\"D\")\n\n        result = tda + dti\n        expected = tdi + dti\n        tm.assert_index_equal(result, expected)\n\n        result = tda + tdi\n        expected = tdi + tdi\n        tm.assert_index_equal(result, expected)\n\n        result = tda - tdi\n        expected = tdi - tdi\n        tm.assert_index_equal(result, expected)",
        "begin_line": 525,
        "end_line": 542,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_tda_add_dt64_object_array#544",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_tda_add_dt64_object_array(self, box_df_fail, tz_naive_fixture)",
        "snippet": "    def test_tda_add_dt64_object_array(self, box_df_fail, tz_naive_fixture):\n        # Result should be cast back to DatetimeArray\n        dti = pd.date_range(\"2016-01-01\", periods=3, tz=tz_naive_fixture)\n        dti = dti._with_freq(None)\n        tdi = dti - dti\n\n        obj = tm.box_expected(tdi, box_df_fail)\n        other = tm.box_expected(dti, box_df_fail)\n\n        warn = PerformanceWarning if box_df_fail is not pd.DataFrame else None\n        with tm.assert_produces_warning(warn):\n            result = obj + other.astype(object)\n        tm.assert_equal(result, other)",
        "begin_line": 544,
        "end_line": 556,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_tdi_iadd_timedeltalike#561",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_tdi_iadd_timedeltalike(self, two_hours, box_with_array)",
        "snippet": "    def test_tdi_iadd_timedeltalike(self, two_hours, box_with_array):\n        # only test adding/sub offsets as + is now numeric\n        rng = timedelta_range(\"1 days\", \"10 days\")\n        expected = timedelta_range(\"1 days 02:00:00\", \"10 days 02:00:00\", freq=\"D\")\n\n        rng = tm.box_expected(rng, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        orig_rng = rng\n        rng += two_hours\n        tm.assert_equal(rng, expected)\n        if box_with_array is not pd.Index:\n            # Check that operation is actually inplace\n            tm.assert_equal(orig_rng, expected)",
        "begin_line": 561,
        "end_line": 574,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_tdi_isub_timedeltalike#576",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_tdi_isub_timedeltalike(self, two_hours, box_with_array)",
        "snippet": "    def test_tdi_isub_timedeltalike(self, two_hours, box_with_array):\n        # only test adding/sub offsets as - is now numeric\n        rng = timedelta_range(\"1 days\", \"10 days\")\n        expected = timedelta_range(\"0 days 22:00:00\", \"9 days 22:00:00\")\n\n        rng = tm.box_expected(rng, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        orig_rng = rng\n        rng -= two_hours\n        tm.assert_equal(rng, expected)\n        if box_with_array is not pd.Index:\n            # Check that operation is actually inplace\n            tm.assert_equal(orig_rng, expected)",
        "begin_line": 576,
        "end_line": 589,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_tdi_ops_attributes#593",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArithmeticUnsorted.test_tdi_ops_attributes(self)",
        "snippet": "    def test_tdi_ops_attributes(self):\n        rng = timedelta_range(\"2 days\", periods=5, freq=\"2D\", name=\"x\")\n\n        result = rng + 1 * rng.freq\n        exp = timedelta_range(\"4 days\", periods=5, freq=\"2D\", name=\"x\")\n        tm.assert_index_equal(result, exp)\n        assert result.freq == \"2D\"\n\n        result = rng - 2 * rng.freq\n        exp = timedelta_range(\"-2 days\", periods=5, freq=\"2D\", name=\"x\")\n        tm.assert_index_equal(result, exp)\n        assert result.freq == \"2D\"\n\n        result = rng * 2\n        exp = timedelta_range(\"4 days\", periods=5, freq=\"4D\", name=\"x\")\n        tm.assert_index_equal(result, exp)\n        assert result.freq == \"4D\"\n\n        result = rng / 2\n        exp = timedelta_range(\"1 days\", periods=5, freq=\"D\", name=\"x\")\n        tm.assert_index_equal(result, exp)\n        assert result.freq == \"D\"\n\n        result = -rng\n        exp = timedelta_range(\"-2 days\", periods=5, freq=\"-2D\", name=\"x\")\n        tm.assert_index_equal(result, exp)\n        assert result.freq == \"-2D\"\n\n        rng = pd.timedelta_range(\"-2 days\", periods=5, freq=\"D\", name=\"x\")\n\n        result = abs(rng)\n        exp = TimedeltaIndex(\n            [\"2 days\", \"1 days\", \"0 days\", \"1 days\", \"2 days\"], name=\"x\"\n        )\n        tm.assert_index_equal(result, exp)\n        assert result.freq is None",
        "begin_line": 593,
        "end_line": 628,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestAddSubNaTMasking.test_tdi_add_timestamp_nat_masking#634",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestAddSubNaTMasking",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestAddSubNaTMasking.test_tdi_add_timestamp_nat_masking(self)",
        "snippet": "    def test_tdi_add_timestamp_nat_masking(self):\n        # GH#17991 checking for overflow-masking with NaT\n        tdinat = pd.to_timedelta([\"24658 days 11:15:00\", \"NaT\"])\n\n        tsneg = Timestamp(\"1950-01-01\")\n        ts_neg_variants = [\n            tsneg,\n            tsneg.to_pydatetime(),\n            tsneg.to_datetime64().astype(\"datetime64[ns]\"),\n            tsneg.to_datetime64().astype(\"datetime64[D]\"),\n        ]\n\n        tspos = Timestamp(\"1980-01-01\")\n        ts_pos_variants = [\n            tspos,\n            tspos.to_pydatetime(),\n            tspos.to_datetime64().astype(\"datetime64[ns]\"),\n            tspos.to_datetime64().astype(\"datetime64[D]\"),\n        ]\n\n        for variant in ts_neg_variants + ts_pos_variants:\n            res = tdinat + variant\n            assert res[1] is pd.NaT",
        "begin_line": 634,
        "end_line": 656,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestAddSubNaTMasking.test_tdi_add_overflow#658",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestAddSubNaTMasking",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestAddSubNaTMasking.test_tdi_add_overflow(self)",
        "snippet": "    def test_tdi_add_overflow(self):\n        # See GH#14068\n        # preliminary test scalar analogue of vectorized tests below\n        # TODO: Make raised error message more informative and test\n        with pytest.raises(OutOfBoundsDatetime, match=\"10155196800000000000\"):\n            pd.to_timedelta(106580, \"D\") + Timestamp(\"2000\")\n        with pytest.raises(OutOfBoundsDatetime, match=\"10155196800000000000\"):\n            Timestamp(\"2000\") + pd.to_timedelta(106580, \"D\")\n\n        _NaT = int(pd.NaT) + 1\n        msg = \"Overflow in int64 addition\"\n        with pytest.raises(OverflowError, match=msg):\n            pd.to_timedelta([106580], \"D\") + Timestamp(\"2000\")\n        with pytest.raises(OverflowError, match=msg):\n            Timestamp(\"2000\") + pd.to_timedelta([106580], \"D\")\n        with pytest.raises(OverflowError, match=msg):\n            pd.to_timedelta([_NaT]) - Timedelta(\"1 days\")\n        with pytest.raises(OverflowError, match=msg):\n            pd.to_timedelta([\"5 days\", _NaT]) - Timedelta(\"1 days\")\n        with pytest.raises(OverflowError, match=msg):\n            (\n                pd.to_timedelta([_NaT, \"5 days\", \"1 hours\"])\n                - pd.to_timedelta([\"7 seconds\", _NaT, \"4 hours\"])\n            )\n\n        # These should not overflow!\n        exp = TimedeltaIndex([pd.NaT])\n        result = pd.to_timedelta([pd.NaT]) - Timedelta(\"1 days\")\n        tm.assert_index_equal(result, exp)\n\n        exp = TimedeltaIndex([\"4 days\", pd.NaT])\n        result = pd.to_timedelta([\"5 days\", pd.NaT]) - Timedelta(\"1 days\")\n        tm.assert_index_equal(result, exp)\n\n        exp = TimedeltaIndex([pd.NaT, pd.NaT, \"5 hours\"])\n        result = pd.to_timedelta([pd.NaT, \"5 days\", \"1 hours\"]) + pd.to_timedelta(\n            [\"7 seconds\", pd.NaT, \"4 hours\"]\n        )\n        tm.assert_index_equal(result, exp)",
        "begin_line": 658,
        "end_line": 696,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_timedelta_ops_with_missing_values#704",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_timedelta_ops_with_missing_values(self)",
        "snippet": "    def test_timedelta_ops_with_missing_values(self):\n        # setup\n        s1 = pd.to_timedelta(Series([\"00:00:01\"]))\n        s2 = pd.to_timedelta(Series([\"00:00:02\"]))\n\n        msg = r\"dtype datetime64\\[ns\\] cannot be converted to timedelta64\\[ns\\]\"\n        with pytest.raises(TypeError, match=msg):\n            # Passing datetime64-dtype data to TimedeltaIndex is no longer\n            #  supported GH#29794\n            pd.to_timedelta(Series([pd.NaT]))\n\n        sn = pd.to_timedelta(Series([pd.NaT], dtype=\"m8[ns]\"))\n\n        df1 = pd.DataFrame([\"00:00:01\"]).apply(pd.to_timedelta)\n        df2 = pd.DataFrame([\"00:00:02\"]).apply(pd.to_timedelta)\n        with pytest.raises(TypeError, match=msg):\n            # Passing datetime64-dtype data to TimedeltaIndex is no longer\n            #  supported GH#29794\n            pd.DataFrame([pd.NaT]).apply(pd.to_timedelta)\n\n        dfn = pd.DataFrame([pd.NaT.value]).apply(pd.to_timedelta)\n\n        scalar1 = pd.to_timedelta(\"00:00:01\")\n        scalar2 = pd.to_timedelta(\"00:00:02\")\n        timedelta_NaT = pd.to_timedelta(\"NaT\")\n\n        actual = scalar1 + scalar1\n        assert actual == scalar2\n        actual = scalar2 - scalar1\n        assert actual == scalar1\n\n        actual = s1 + s1\n        tm.assert_series_equal(actual, s2)\n        actual = s2 - s1\n        tm.assert_series_equal(actual, s1)\n\n        actual = s1 + scalar1\n        tm.assert_series_equal(actual, s2)\n        actual = scalar1 + s1\n        tm.assert_series_equal(actual, s2)\n        actual = s2 - scalar1\n        tm.assert_series_equal(actual, s1)\n        actual = -scalar1 + s2\n        tm.assert_series_equal(actual, s1)\n\n        actual = s1 + timedelta_NaT\n        tm.assert_series_equal(actual, sn)\n        actual = timedelta_NaT + s1\n        tm.assert_series_equal(actual, sn)\n        actual = s1 - timedelta_NaT\n        tm.assert_series_equal(actual, sn)\n        actual = -timedelta_NaT + s1\n        tm.assert_series_equal(actual, sn)\n\n        msg = \"unsupported operand type\"\n        with pytest.raises(TypeError, match=msg):\n            s1 + np.nan\n        with pytest.raises(TypeError, match=msg):\n            np.nan + s1\n        with pytest.raises(TypeError, match=msg):\n            s1 - np.nan\n        with pytest.raises(TypeError, match=msg):\n            -np.nan + s1\n\n        actual = s1 + pd.NaT\n        tm.assert_series_equal(actual, sn)\n        actual = s2 - pd.NaT\n        tm.assert_series_equal(actual, sn)\n\n        actual = s1 + df1\n        tm.assert_frame_equal(actual, df2)\n        actual = s2 - df1\n        tm.assert_frame_equal(actual, df1)\n        actual = df1 + s1\n        tm.assert_frame_equal(actual, df2)\n        actual = df2 - s1\n        tm.assert_frame_equal(actual, df1)\n\n        actual = df1 + df1\n        tm.assert_frame_equal(actual, df2)\n        actual = df2 - df1\n        tm.assert_frame_equal(actual, df1)\n\n        actual = df1 + scalar1\n        tm.assert_frame_equal(actual, df2)\n        actual = df2 - scalar1\n        tm.assert_frame_equal(actual, df1)\n\n        actual = df1 + timedelta_NaT\n        tm.assert_frame_equal(actual, dfn)\n        actual = df1 - timedelta_NaT\n        tm.assert_frame_equal(actual, dfn)\n\n        msg = \"cannot subtract a datelike from|unsupported operand type\"\n        with pytest.raises(TypeError, match=msg):\n            df1 + np.nan\n        with pytest.raises(TypeError, match=msg):\n            df1 - np.nan\n\n        actual = df1 + pd.NaT  # NaT is datetime, not timedelta\n        tm.assert_frame_equal(actual, dfn)\n        actual = df1 - pd.NaT\n        tm.assert_frame_equal(actual, dfn)",
        "begin_line": 704,
        "end_line": 806,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_operators_timedelta64#810",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_operators_timedelta64(self)",
        "snippet": "    def test_operators_timedelta64(self):\n        # series ops\n        v1 = pd.date_range(\"2012-1-1\", periods=3, freq=\"D\")\n        v2 = pd.date_range(\"2012-1-2\", periods=3, freq=\"D\")\n        rs = Series(v2) - Series(v1)\n        xp = Series(1e9 * 3600 * 24, rs.index).astype(\"int64\").astype(\"timedelta64[ns]\")\n        tm.assert_series_equal(rs, xp)\n        assert rs.dtype == \"timedelta64[ns]\"\n\n        df = DataFrame(dict(A=v1))\n        td = Series([timedelta(days=i) for i in range(3)])\n        assert td.dtype == \"timedelta64[ns]\"\n\n        # series on the rhs\n        result = df[\"A\"] - df[\"A\"].shift()\n        assert result.dtype == \"timedelta64[ns]\"\n\n        result = df[\"A\"] + td\n        assert result.dtype == \"M8[ns]\"\n\n        # scalar Timestamp on rhs\n        maxa = df[\"A\"].max()\n        assert isinstance(maxa, Timestamp)\n\n        resultb = df[\"A\"] - df[\"A\"].max()\n        assert resultb.dtype == \"timedelta64[ns]\"\n\n        # timestamp on lhs\n        result = resultb + df[\"A\"]\n        values = [Timestamp(\"20111230\"), Timestamp(\"20120101\"), Timestamp(\"20120103\")]\n        expected = Series(values, name=\"A\")\n        tm.assert_series_equal(result, expected)\n\n        # datetimes on rhs\n        result = df[\"A\"] - datetime(2001, 1, 1)\n        expected = Series([timedelta(days=4017 + i) for i in range(3)], name=\"A\")\n        tm.assert_series_equal(result, expected)\n        assert result.dtype == \"m8[ns]\"\n\n        d = datetime(2001, 1, 1, 3, 4)\n        resulta = df[\"A\"] - d\n        assert resulta.dtype == \"m8[ns]\"\n\n        # roundtrip\n        resultb = resulta + d\n        tm.assert_series_equal(df[\"A\"], resultb)\n\n        # timedeltas on rhs\n        td = timedelta(days=1)\n        resulta = df[\"A\"] + td\n        resultb = resulta - td\n        tm.assert_series_equal(resultb, df[\"A\"])\n        assert resultb.dtype == \"M8[ns]\"\n\n        # roundtrip\n        td = timedelta(minutes=5, seconds=3)\n        resulta = df[\"A\"] + td\n        resultb = resulta - td\n        tm.assert_series_equal(df[\"A\"], resultb)\n        assert resultb.dtype == \"M8[ns]\"\n\n        # inplace\n        value = rs[2] + np.timedelta64(timedelta(minutes=5, seconds=1))\n        rs[2] += np.timedelta64(timedelta(minutes=5, seconds=1))\n        assert rs[2] == value",
        "begin_line": 810,
        "end_line": 874,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_timedelta64_ops_nat#876",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_timedelta64_ops_nat(self)",
        "snippet": "    def test_timedelta64_ops_nat(self):\n        # GH 11349\n        timedelta_series = Series([NaT, Timedelta(\"1s\")])\n        nat_series_dtype_timedelta = Series([NaT, NaT], dtype=\"timedelta64[ns]\")\n        single_nat_dtype_timedelta = Series([NaT], dtype=\"timedelta64[ns]\")\n\n        # subtraction\n        tm.assert_series_equal(timedelta_series - NaT, nat_series_dtype_timedelta)\n        tm.assert_series_equal(-NaT + timedelta_series, nat_series_dtype_timedelta)\n\n        tm.assert_series_equal(\n            timedelta_series - single_nat_dtype_timedelta, nat_series_dtype_timedelta\n        )\n        tm.assert_series_equal(\n            -single_nat_dtype_timedelta + timedelta_series, nat_series_dtype_timedelta\n        )\n\n        # addition\n        tm.assert_series_equal(\n            nat_series_dtype_timedelta + NaT, nat_series_dtype_timedelta\n        )\n        tm.assert_series_equal(\n            NaT + nat_series_dtype_timedelta, nat_series_dtype_timedelta\n        )\n\n        tm.assert_series_equal(\n            nat_series_dtype_timedelta + single_nat_dtype_timedelta,\n            nat_series_dtype_timedelta,\n        )\n        tm.assert_series_equal(\n            single_nat_dtype_timedelta + nat_series_dtype_timedelta,\n            nat_series_dtype_timedelta,\n        )\n\n        tm.assert_series_equal(timedelta_series + NaT, nat_series_dtype_timedelta)\n        tm.assert_series_equal(NaT + timedelta_series, nat_series_dtype_timedelta)\n\n        tm.assert_series_equal(\n            timedelta_series + single_nat_dtype_timedelta, nat_series_dtype_timedelta\n        )\n        tm.assert_series_equal(\n            single_nat_dtype_timedelta + timedelta_series, nat_series_dtype_timedelta\n        )\n\n        tm.assert_series_equal(\n            nat_series_dtype_timedelta + NaT, nat_series_dtype_timedelta\n        )\n        tm.assert_series_equal(\n            NaT + nat_series_dtype_timedelta, nat_series_dtype_timedelta\n        )\n\n        tm.assert_series_equal(\n            nat_series_dtype_timedelta + single_nat_dtype_timedelta,\n            nat_series_dtype_timedelta,\n        )\n        tm.assert_series_equal(\n            single_nat_dtype_timedelta + nat_series_dtype_timedelta,\n            nat_series_dtype_timedelta,\n        )\n\n        # multiplication\n        tm.assert_series_equal(\n            nat_series_dtype_timedelta * 1.0, nat_series_dtype_timedelta\n        )\n        tm.assert_series_equal(\n            1.0 * nat_series_dtype_timedelta, nat_series_dtype_timedelta\n        )\n\n        tm.assert_series_equal(timedelta_series * 1, timedelta_series)\n        tm.assert_series_equal(1 * timedelta_series, timedelta_series)\n\n        tm.assert_series_equal(timedelta_series * 1.5, Series([NaT, Timedelta(\"1.5s\")]))\n        tm.assert_series_equal(1.5 * timedelta_series, Series([NaT, Timedelta(\"1.5s\")]))\n\n        tm.assert_series_equal(timedelta_series * np.nan, nat_series_dtype_timedelta)\n        tm.assert_series_equal(np.nan * timedelta_series, nat_series_dtype_timedelta)\n\n        # division\n        tm.assert_series_equal(timedelta_series / 2, Series([NaT, Timedelta(\"0.5s\")]))\n        tm.assert_series_equal(timedelta_series / 2.0, Series([NaT, Timedelta(\"0.5s\")]))\n        tm.assert_series_equal(timedelta_series / np.nan, nat_series_dtype_timedelta)",
        "begin_line": 876,
        "end_line": 956,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_sub_timestamp_raises#961",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_sub_timestamp_raises(self, box_with_array)",
        "snippet": "    def test_td64arr_sub_timestamp_raises(self, box_with_array):\n        idx = TimedeltaIndex([\"1 day\", \"2 day\"])\n        idx = tm.box_expected(idx, box_with_array)\n\n        msg = (\n            \"cannot subtract a datelike from|\"\n            \"Could not operate|\"\n            \"cannot perform operation\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            idx - Timestamp(\"2011-01-01\")",
        "begin_line": 961,
        "end_line": 971,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_timestamp#973",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_timestamp(self, box_with_array, tz_naive_fixture)",
        "snippet": "    def test_td64arr_add_timestamp(self, box_with_array, tz_naive_fixture):\n        # GH#23215\n\n        # TODO: parametrize over scalar datetime types?\n        tz = tz_naive_fixture\n        other = Timestamp(\"2011-01-01\", tz=tz)\n\n        idx = TimedeltaIndex([\"1 day\", \"2 day\"])\n        expected = DatetimeIndex([\"2011-01-02\", \"2011-01-03\"], tz=tz)\n\n        idx = tm.box_expected(idx, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = idx + other\n        tm.assert_equal(result, expected)\n\n        result = other + idx\n        tm.assert_equal(result, expected)",
        "begin_line": 973,
        "end_line": 990,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_sub_datetimelike_scalar#1000",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_sub_datetimelike_scalar(self, ts, box_with_array)",
        "snippet": "    def test_td64arr_add_sub_datetimelike_scalar(self, ts, box_with_array):\n        # GH#11925, GH#29558\n        tdi = timedelta_range(\"1 day\", periods=3)\n        expected = pd.date_range(\"2012-01-02\", periods=3)\n\n        tdarr = tm.box_expected(tdi, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        tm.assert_equal(ts + tdarr, expected)\n        tm.assert_equal(tdarr + ts, expected)\n\n        expected2 = pd.date_range(\"2011-12-31\", periods=3, freq=\"-1D\")\n        expected2 = tm.box_expected(expected2, box_with_array)\n\n        tm.assert_equal(ts - tdarr, expected2)\n        tm.assert_equal(ts + (-tdarr), expected2)\n\n        msg = \"cannot subtract a datelike\"\n        with pytest.raises(TypeError, match=msg):\n            tdarr - ts",
        "begin_line": 1000,
        "end_line": 1019,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_tdi_sub_dt64_array#1021",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_tdi_sub_dt64_array(self, box_with_array)",
        "snippet": "    def test_tdi_sub_dt64_array(self, box_with_array):\n        dti = pd.date_range(\"2016-01-01\", periods=3)\n        tdi = dti - dti.shift(1)\n        dtarr = dti.values\n        expected = pd.DatetimeIndex(dtarr) - tdi\n\n        tdi = tm.box_expected(tdi, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        msg = \"cannot subtract a datelike from\"\n        with pytest.raises(TypeError, match=msg):\n            tdi - dtarr\n\n        # TimedeltaIndex.__rsub__\n        result = dtarr - tdi\n        tm.assert_equal(result, expected)",
        "begin_line": 1021,
        "end_line": 1036,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_tdi_add_dt64_array#1038",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_tdi_add_dt64_array(self, box_with_array)",
        "snippet": "    def test_tdi_add_dt64_array(self, box_with_array):\n        dti = pd.date_range(\"2016-01-01\", periods=3)\n        tdi = dti - dti.shift(1)\n        dtarr = dti.values\n        expected = pd.DatetimeIndex(dtarr) + tdi\n\n        tdi = tm.box_expected(tdi, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = tdi + dtarr\n        tm.assert_equal(result, expected)\n        result = dtarr + tdi\n        tm.assert_equal(result, expected)",
        "begin_line": 1038,
        "end_line": 1050,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_datetime64_nat#1052",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_datetime64_nat(self, box_with_array)",
        "snippet": "    def test_td64arr_add_datetime64_nat(self, box_with_array):\n        # GH#23215\n        other = np.datetime64(\"NaT\")\n\n        tdi = timedelta_range(\"1 day\", periods=3)\n        expected = pd.DatetimeIndex([\"NaT\", \"NaT\", \"NaT\"])\n\n        tdser = tm.box_expected(tdi, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        tm.assert_equal(tdser + other, expected)\n        tm.assert_equal(other + tdser, expected)",
        "begin_line": 1052,
        "end_line": 1063,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_sub_periodlike#1070",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_sub_periodlike(self, box_with_array, tdi_freq, pi_freq)",
        "snippet": "    def test_td64arr_sub_periodlike(self, box_with_array, tdi_freq, pi_freq):\n        # GH#20049 subtracting PeriodIndex should raise TypeError\n        tdi = TimedeltaIndex([\"1 hours\", \"2 hours\"], freq=tdi_freq)\n        dti = Timestamp(\"2018-03-07 17:16:40\") + tdi\n        pi = dti.to_period(pi_freq)\n\n        # TODO: parametrize over box for pi?\n        tdi = tm.box_expected(tdi, box_with_array)\n        msg = \"cannot subtract|unsupported operand type\"\n        with pytest.raises(TypeError, match=msg):\n            tdi - pi\n\n        # FIXME: don't leave commented-out\n        # FIXME: this raises with period scalar but not with PeriodIndex?\n        # with pytest.raises(TypeError):\n        #    pi - tdi\n\n        # GH#13078 subtraction of Period scalar not supported\n        with pytest.raises(TypeError, match=msg):\n            tdi - pi[0]\n        with pytest.raises(TypeError, match=msg):\n            pi[0] - tdi",
        "begin_line": 1070,
        "end_line": 1091,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_addsub_numeric_scalar_invalid#1104",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_addsub_numeric_scalar_invalid(self, box_with_array, other)",
        "snippet": "    def test_td64arr_addsub_numeric_scalar_invalid(self, box_with_array, other):\n        # vector-like others are tested in test_td64arr_add_sub_numeric_arr_invalid\n        tdser = pd.Series([\"59 Days\", \"59 Days\", \"NaT\"], dtype=\"m8[ns]\")\n        tdarr = tm.box_expected(tdser, box_with_array)\n\n        assert_invalid_addsub_type(tdarr, other)",
        "begin_line": 1104,
        "end_line": 1109,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_addsub_numeric_arr_invalid#1121",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_addsub_numeric_arr_invalid(self, box_with_array, vec, any_real_dtype)",
        "snippet": "    def test_td64arr_addsub_numeric_arr_invalid(\n        self, box_with_array, vec, any_real_dtype\n    ):\n        tdser = pd.Series([\"59 Days\", \"59 Days\", \"NaT\"], dtype=\"m8[ns]\")\n        tdarr = tm.box_expected(tdser, box_with_array)\n\n        vector = vec.astype(any_real_dtype)\n        assert_invalid_addsub_type(tdarr, vector)",
        "begin_line": 1121,
        "end_line": 1128,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_sub_int#1130",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_sub_int(self, box_with_array, one)",
        "snippet": "    def test_td64arr_add_sub_int(self, box_with_array, one):\n        # Variants of `one` for #19012, deprecated GH#22535\n        rng = timedelta_range(\"1 days 09:00:00\", freq=\"H\", periods=10)\n        tdarr = tm.box_expected(rng, box_with_array)\n\n        msg = \"Addition/subtraction of integers\"\n        assert_invalid_addsub_type(tdarr, one, msg)\n\n        # TOOD: get inplace ops into assert_invalid_addsub_type\n        with pytest.raises(TypeError, match=msg):\n            tdarr += one\n        with pytest.raises(TypeError, match=msg):\n            tdarr -= one",
        "begin_line": 1130,
        "end_line": 1142,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_sub_integer_array#1144",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_sub_integer_array(self, box_with_array)",
        "snippet": "    def test_td64arr_add_sub_integer_array(self, box_with_array):\n        # GH#19959, deprecated GH#22535\n        # GH#22696 for DataFrame case, check that we don't dispatch to numpy\n        #  implementation, which treats int64 as m8[ns]\n\n        rng = timedelta_range(\"1 days 09:00:00\", freq=\"H\", periods=3)\n        tdarr = tm.box_expected(rng, box_with_array)\n        other = tm.box_expected([4, 3, 2], box_with_array)\n\n        msg = \"Addition/subtraction of integers and integer-arrays\"\n        assert_invalid_addsub_type(tdarr, other, msg)",
        "begin_line": 1144,
        "end_line": 1154,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_addsub_integer_array_no_freq#1156",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_addsub_integer_array_no_freq(self, box_with_array)",
        "snippet": "    def test_td64arr_addsub_integer_array_no_freq(self, box_with_array):\n        # GH#19959\n        tdi = TimedeltaIndex([\"1 Day\", \"NaT\", \"3 Hours\"])\n        tdarr = tm.box_expected(tdi, box_with_array)\n        other = tm.box_expected([14, -1, 16], box_with_array)\n\n        msg = \"Addition/subtraction of integers\"\n        assert_invalid_addsub_type(tdarr, other, msg)",
        "begin_line": 1156,
        "end_line": 1163,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_td64_array#1168",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_td64_array(self, box_with_array)",
        "snippet": "    def test_td64arr_add_td64_array(self, box_with_array):\n        box = box_with_array\n        dti = pd.date_range(\"2016-01-01\", periods=3)\n        tdi = dti - dti.shift(1)\n        tdarr = tdi.values\n\n        expected = 2 * tdi\n        tdi = tm.box_expected(tdi, box)\n        expected = tm.box_expected(expected, box)\n\n        result = tdi + tdarr\n        tm.assert_equal(result, expected)\n        result = tdarr + tdi\n        tm.assert_equal(result, expected)",
        "begin_line": 1168,
        "end_line": 1181,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_sub_td64_array#1183",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_sub_td64_array(self, box_with_array)",
        "snippet": "    def test_td64arr_sub_td64_array(self, box_with_array):\n        box = box_with_array\n        dti = pd.date_range(\"2016-01-01\", periods=3)\n        tdi = dti - dti.shift(1)\n        tdarr = tdi.values\n\n        expected = 0 * tdi\n        tdi = tm.box_expected(tdi, box)\n        expected = tm.box_expected(expected, box)\n\n        result = tdi - tdarr\n        tm.assert_equal(result, expected)\n        result = tdarr - tdi\n        tm.assert_equal(result, expected)",
        "begin_line": 1183,
        "end_line": 1196,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_sub_tdi#1198",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_sub_tdi(self, box, names)",
        "snippet": "    def test_td64arr_add_sub_tdi(self, box, names):\n        # GH#17250 make sure result dtype is correct\n        # GH#19043 make sure names are propagated correctly\n        if box is pd.DataFrame and names[1] != names[0]:\n            pytest.skip(\n                \"Name propagation for DataFrame does not behave like \"\n                \"it does for Index/Series\"\n            )\n\n        tdi = TimedeltaIndex([\"0 days\", \"1 day\"], name=names[0])\n        ser = Series([Timedelta(hours=3), Timedelta(hours=4)], name=names[1])\n        expected = Series(\n            [Timedelta(hours=3), Timedelta(days=1, hours=4)], name=names[2]\n        )\n\n        ser = tm.box_expected(ser, box)\n        expected = tm.box_expected(expected, box)\n\n        result = tdi + ser\n        tm.assert_equal(result, expected)\n        assert_dtype(result, \"timedelta64[ns]\")\n\n        result = ser + tdi\n        tm.assert_equal(result, expected)\n        assert_dtype(result, \"timedelta64[ns]\")\n\n        expected = Series(\n            [Timedelta(hours=-3), Timedelta(days=1, hours=-4)], name=names[2]\n        )\n        expected = tm.box_expected(expected, box)\n\n        result = tdi - ser\n        tm.assert_equal(result, expected)\n        assert_dtype(result, \"timedelta64[ns]\")\n\n        result = ser - tdi\n        tm.assert_equal(result, -expected)\n        assert_dtype(result, \"timedelta64[ns]\")",
        "begin_line": 1198,
        "end_line": 1235,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_sub_td64_nat#1237",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_sub_td64_nat(self, box_with_array)",
        "snippet": "    def test_td64arr_add_sub_td64_nat(self, box_with_array):\n        # GH#23320 special handling for timedelta64(\"NaT\")\n        box = box_with_array\n        tdi = pd.TimedeltaIndex([NaT, Timedelta(\"1s\")])\n        other = np.timedelta64(\"NaT\")\n        expected = pd.TimedeltaIndex([\"NaT\"] * 2)\n\n        obj = tm.box_expected(tdi, box)\n        expected = tm.box_expected(expected, box)\n\n        result = obj + other\n        tm.assert_equal(result, expected)\n        result = other + obj\n        tm.assert_equal(result, expected)\n        result = obj - other\n        tm.assert_equal(result, expected)\n        result = other - obj\n        tm.assert_equal(result, expected)",
        "begin_line": 1237,
        "end_line": 1254,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_sub_NaT#1256",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_sub_NaT(self, box_with_array)",
        "snippet": "    def test_td64arr_sub_NaT(self, box_with_array):\n        # GH#18808\n        box = box_with_array\n        ser = Series([NaT, Timedelta(\"1s\")])\n        expected = Series([NaT, NaT], dtype=\"timedelta64[ns]\")\n\n        ser = tm.box_expected(ser, box)\n        expected = tm.box_expected(expected, box)\n\n        res = ser - pd.NaT\n        tm.assert_equal(res, expected)",
        "begin_line": 1256,
        "end_line": 1266,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_timedeltalike#1268",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_timedeltalike(self, two_hours, box_with_array)",
        "snippet": "    def test_td64arr_add_timedeltalike(self, two_hours, box_with_array):\n        # only test adding/sub offsets as + is now numeric\n        # GH#10699 for Tick cases\n        box = box_with_array\n        rng = timedelta_range(\"1 days\", \"10 days\")\n        expected = timedelta_range(\"1 days 02:00:00\", \"10 days 02:00:00\", freq=\"D\")\n        rng = tm.box_expected(rng, box)\n        expected = tm.box_expected(expected, box)\n\n        result = rng + two_hours\n        tm.assert_equal(result, expected)\n\n        result = two_hours + rng\n        tm.assert_equal(result, expected)",
        "begin_line": 1268,
        "end_line": 1281,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_sub_timedeltalike#1283",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_sub_timedeltalike(self, two_hours, box_with_array)",
        "snippet": "    def test_td64arr_sub_timedeltalike(self, two_hours, box_with_array):\n        # only test adding/sub offsets as - is now numeric\n        # GH#10699 for Tick cases\n        box = box_with_array\n        rng = timedelta_range(\"1 days\", \"10 days\")\n        expected = timedelta_range(\"0 days 22:00:00\", \"9 days 22:00:00\")\n\n        rng = tm.box_expected(rng, box)\n        expected = tm.box_expected(expected, box)\n\n        result = rng - two_hours\n        tm.assert_equal(result, expected)\n\n        result = two_hours - rng\n        tm.assert_equal(result, -expected)",
        "begin_line": 1283,
        "end_line": 1297,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_offset_index#1302",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_offset_index(self, names, box)",
        "snippet": "    def test_td64arr_add_offset_index(self, names, box):\n        # GH#18849, GH#19744\n        if box is pd.DataFrame and names[1] != names[0]:\n            pytest.skip(\n                \"Name propagation for DataFrame does not behave like \"\n                \"it does for Index/Series\"\n            )\n\n        tdi = TimedeltaIndex([\"1 days 00:00:00\", \"3 days 04:00:00\"], name=names[0])\n        other = pd.Index([pd.offsets.Hour(n=1), pd.offsets.Minute(n=-2)], name=names[1])\n\n        expected = TimedeltaIndex(\n            [tdi[n] + other[n] for n in range(len(tdi))], freq=\"infer\", name=names[2]\n        )\n        tdi = tm.box_expected(tdi, box)\n        expected = tm.box_expected(expected, box)\n\n        with tm.assert_produces_warning(PerformanceWarning):\n            res = tdi + other\n        tm.assert_equal(res, expected)\n\n        with tm.assert_produces_warning(PerformanceWarning):\n            res2 = other + tdi\n        tm.assert_equal(res2, expected)",
        "begin_line": 1302,
        "end_line": 1325,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_offset_array#1329",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_offset_array(self, box_with_array)",
        "snippet": "    def test_td64arr_add_offset_array(self, box_with_array):\n        # GH#18849\n        box = box_with_array\n        tdi = TimedeltaIndex([\"1 days 00:00:00\", \"3 days 04:00:00\"])\n        other = np.array([pd.offsets.Hour(n=1), pd.offsets.Minute(n=-2)])\n\n        expected = TimedeltaIndex(\n            [tdi[n] + other[n] for n in range(len(tdi))], freq=\"infer\"\n        )\n\n        tdi = tm.box_expected(tdi, box)\n        expected = tm.box_expected(expected, box)\n\n        with tm.assert_produces_warning(PerformanceWarning):\n            res = tdi + other\n        tm.assert_equal(res, expected)\n\n        with tm.assert_produces_warning(PerformanceWarning):\n            res2 = other + tdi\n        tm.assert_equal(res2, expected)",
        "begin_line": 1329,
        "end_line": 1348,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_sub_offset_index#1353",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_sub_offset_index(self, names, box_with_array)",
        "snippet": "    def test_td64arr_sub_offset_index(self, names, box_with_array):\n        # GH#18824, GH#19744\n        box = box_with_array\n        xbox = box if box is not tm.to_array else pd.Index\n        exname = names[2] if box is not tm.to_array else names[1]\n\n        if box is pd.DataFrame and names[1] == \"bar\":\n            pytest.skip(\n                \"Name propagation for DataFrame does not behave like \"\n                \"it does for Index/Series\"\n            )\n\n        tdi = TimedeltaIndex([\"1 days 00:00:00\", \"3 days 04:00:00\"], name=names[0])\n        other = pd.Index([pd.offsets.Hour(n=1), pd.offsets.Minute(n=-2)], name=names[1])\n\n        expected = TimedeltaIndex(\n            [tdi[n] - other[n] for n in range(len(tdi))], freq=\"infer\", name=exname\n        )\n\n        tdi = tm.box_expected(tdi, box)\n        expected = tm.box_expected(expected, xbox)\n\n        with tm.assert_produces_warning(PerformanceWarning):\n            res = tdi - other\n        tm.assert_equal(res, expected)",
        "begin_line": 1353,
        "end_line": 1377,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_sub_offset_array#1379",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_sub_offset_array(self, box_with_array)",
        "snippet": "    def test_td64arr_sub_offset_array(self, box_with_array):\n        # GH#18824\n        tdi = TimedeltaIndex([\"1 days 00:00:00\", \"3 days 04:00:00\"])\n        other = np.array([pd.offsets.Hour(n=1), pd.offsets.Minute(n=-2)])\n\n        expected = TimedeltaIndex(\n            [tdi[n] - other[n] for n in range(len(tdi))], freq=\"infer\"\n        )\n\n        tdi = tm.box_expected(tdi, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        with tm.assert_produces_warning(PerformanceWarning):\n            res = tdi - other\n        tm.assert_equal(res, expected)",
        "begin_line": 1379,
        "end_line": 1393,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_with_offset_series#1398",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_with_offset_series(self, names, box_df_fail)",
        "snippet": "    def test_td64arr_with_offset_series(self, names, box_df_fail):\n        # GH#18849\n        box = box_df_fail\n        box2 = Series if box in [pd.Index, tm.to_array] else box\n        exname = names[2] if box is not tm.to_array else names[1]\n\n        tdi = TimedeltaIndex([\"1 days 00:00:00\", \"3 days 04:00:00\"], name=names[0])\n        other = Series([pd.offsets.Hour(n=1), pd.offsets.Minute(n=-2)], name=names[1])\n\n        expected_add = Series([tdi[n] + other[n] for n in range(len(tdi))], name=exname)\n        tdi = tm.box_expected(tdi, box)\n        expected_add = tm.box_expected(expected_add, box2)\n\n        with tm.assert_produces_warning(PerformanceWarning):\n            res = tdi + other\n        tm.assert_equal(res, expected_add)\n\n        with tm.assert_produces_warning(PerformanceWarning):\n            res2 = other + tdi\n        tm.assert_equal(res2, expected_add)\n\n        # TODO: separate/parametrize add/sub test?\n        expected_sub = Series([tdi[n] - other[n] for n in range(len(tdi))], name=exname)\n        expected_sub = tm.box_expected(expected_sub, box2)\n\n        with tm.assert_produces_warning(PerformanceWarning):\n            res3 = tdi - other\n        tm.assert_equal(res3, expected_sub)",
        "begin_line": 1398,
        "end_line": 1425,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_addsub_anchored_offset_arraylike#1428",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_addsub_anchored_offset_arraylike(self, obox, box_with_array)",
        "snippet": "    def test_td64arr_addsub_anchored_offset_arraylike(self, obox, box_with_array):\n        # GH#18824\n        tdi = TimedeltaIndex([\"1 days 00:00:00\", \"3 days 04:00:00\"])\n        tdi = tm.box_expected(tdi, box_with_array)\n\n        anchored = obox([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)])\n\n        # addition/subtraction ops with anchored offsets should issue\n        # a PerformanceWarning and _then_ raise a TypeError.\n        msg = \"has incorrect type|cannot add the type MonthEnd\"\n        with pytest.raises(TypeError, match=msg):\n            with tm.assert_produces_warning(PerformanceWarning):\n                tdi + anchored\n        with pytest.raises(TypeError, match=msg):\n            with tm.assert_produces_warning(PerformanceWarning):\n                anchored + tdi\n        with pytest.raises(TypeError, match=msg):\n            with tm.assert_produces_warning(PerformanceWarning):\n                tdi - anchored\n        with pytest.raises(TypeError, match=msg):\n            with tm.assert_produces_warning(PerformanceWarning):\n                anchored - tdi",
        "begin_line": 1428,
        "end_line": 1449,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_sub_object_array#1454",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps.test_td64arr_add_sub_object_array(self, box_with_array)",
        "snippet": "    def test_td64arr_add_sub_object_array(self, box_with_array):\n        tdi = pd.timedelta_range(\"1 day\", periods=3, freq=\"D\")\n        tdarr = tm.box_expected(tdi, box_with_array)\n\n        other = np.array(\n            [pd.Timedelta(days=1), pd.offsets.Day(2), pd.Timestamp(\"2000-01-04\")]\n        )\n\n        with tm.assert_produces_warning(PerformanceWarning):\n            result = tdarr + other\n\n        expected = pd.Index(\n            [pd.Timedelta(days=2), pd.Timedelta(days=4), pd.Timestamp(\"2000-01-07\")]\n        )\n        expected = tm.box_expected(expected, box_with_array)\n        if box_with_array is pd.DataFrame:\n            expected = expected.astype(object)\n        tm.assert_equal(result, expected)\n\n        msg = \"unsupported operand type|cannot subtract a datelike\"\n        with pytest.raises(TypeError, match=msg):\n            with tm.assert_produces_warning(PerformanceWarning):\n                tdarr - other\n\n        with tm.assert_produces_warning(PerformanceWarning):\n            result = other - tdarr\n\n        expected = pd.Index(\n            [pd.Timedelta(0), pd.Timedelta(0), pd.Timestamp(\"2000-01-01\")]\n        )\n        expected = tm.box_expected(expected, box_with_array)\n        if box_with_array is pd.DataFrame:\n            expected = expected.astype(object)\n        tm.assert_equal(result, expected)",
        "begin_line": 1454,
        "end_line": 1487,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_mul_int#1498",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_mul_int(self, box_with_array)",
        "snippet": "    def test_td64arr_mul_int(self, box_with_array):\n        idx = TimedeltaIndex(np.arange(5, dtype=\"int64\"))\n        idx = tm.box_expected(idx, box_with_array)\n\n        result = idx * 1\n        tm.assert_equal(result, idx)\n\n        result = 1 * idx\n        tm.assert_equal(result, idx)",
        "begin_line": 1498,
        "end_line": 1506,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_mul_tdlike_scalar_raises#1508",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_mul_tdlike_scalar_raises(self, two_hours, box_with_array)",
        "snippet": "    def test_td64arr_mul_tdlike_scalar_raises(self, two_hours, box_with_array):\n        rng = timedelta_range(\"1 days\", \"10 days\", name=\"foo\")\n        rng = tm.box_expected(rng, box_with_array)\n        msg = \"argument must be an integer|cannot use operands with types dtype\"\n        with pytest.raises(TypeError, match=msg):\n            rng * two_hours",
        "begin_line": 1508,
        "end_line": 1513,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_tdi_mul_int_array_zerodim#1515",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_tdi_mul_int_array_zerodim(self, box_with_array)",
        "snippet": "    def test_tdi_mul_int_array_zerodim(self, box_with_array):\n        rng5 = np.arange(5, dtype=\"int64\")\n        idx = TimedeltaIndex(rng5)\n        expected = TimedeltaIndex(rng5 * 5)\n\n        idx = tm.box_expected(idx, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = idx * np.array(5, dtype=\"int64\")\n        tm.assert_equal(result, expected)",
        "begin_line": 1515,
        "end_line": 1524,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_tdi_mul_int_array#1526",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_tdi_mul_int_array(self, box_with_array)",
        "snippet": "    def test_tdi_mul_int_array(self, box_with_array):\n        rng5 = np.arange(5, dtype=\"int64\")\n        idx = TimedeltaIndex(rng5)\n        expected = TimedeltaIndex(rng5 ** 2)\n\n        idx = tm.box_expected(idx, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = idx * rng5\n        tm.assert_equal(result, expected)",
        "begin_line": 1526,
        "end_line": 1535,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_tdi_mul_int_series#1537",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_tdi_mul_int_series(self, box_with_array)",
        "snippet": "    def test_tdi_mul_int_series(self, box_with_array):\n        box = box_with_array\n        xbox = pd.Series if box in [pd.Index, tm.to_array] else box\n\n        idx = TimedeltaIndex(np.arange(5, dtype=\"int64\"))\n        expected = TimedeltaIndex(np.arange(5, dtype=\"int64\") ** 2)\n\n        idx = tm.box_expected(idx, box)\n        expected = tm.box_expected(expected, xbox)\n\n        result = idx * pd.Series(np.arange(5, dtype=\"int64\"))\n        tm.assert_equal(result, expected)",
        "begin_line": 1537,
        "end_line": 1548,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_tdi_mul_float_series#1550",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_tdi_mul_float_series(self, box_with_array)",
        "snippet": "    def test_tdi_mul_float_series(self, box_with_array):\n        box = box_with_array\n        xbox = pd.Series if box in [pd.Index, tm.to_array] else box\n\n        idx = TimedeltaIndex(np.arange(5, dtype=\"int64\"))\n        idx = tm.box_expected(idx, box)\n\n        rng5f = np.arange(5, dtype=\"float64\")\n        expected = TimedeltaIndex(rng5f * (rng5f + 1.0))\n        expected = tm.box_expected(expected, xbox)\n\n        result = idx * Series(rng5f + 1.0)\n        tm.assert_equal(result, expected)",
        "begin_line": 1550,
        "end_line": 1562,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_tdi_rmul_arraylike#1576",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_tdi_rmul_arraylike(self, other, box_with_array)",
        "snippet": "    def test_tdi_rmul_arraylike(self, other, box_with_array):\n        box = box_with_array\n        xbox = get_upcast_box(box, other)\n\n        tdi = TimedeltaIndex([\"1 Day\"] * 10)\n        expected = timedelta_range(\"1 days\", \"10 days\")\n        expected._data.freq = None\n\n        tdi = tm.box_expected(tdi, box)\n        expected = tm.box_expected(expected, xbox)\n\n        result = other * tdi\n        tm.assert_equal(result, expected)\n        commute = tdi * other\n        tm.assert_equal(commute, expected)",
        "begin_line": 1576,
        "end_line": 1590,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_div_nat_invalid#1595",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_div_nat_invalid(self, box_with_array)",
        "snippet": "    def test_td64arr_div_nat_invalid(self, box_with_array):\n        # don't allow division by NaT (maybe could in the future)\n        rng = timedelta_range(\"1 days\", \"10 days\", name=\"foo\")\n        rng = tm.box_expected(rng, box_with_array)\n\n        with pytest.raises(TypeError, match=\"unsupported operand type\"):\n            rng / pd.NaT\n        with pytest.raises(TypeError, match=\"Cannot divide NaTType by\"):\n            pd.NaT / rng",
        "begin_line": 1595,
        "end_line": 1603,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_div_td64nat#1605",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_div_td64nat(self, box_with_array)",
        "snippet": "    def test_td64arr_div_td64nat(self, box_with_array):\n        # GH#23829\n        rng = timedelta_range(\"1 days\", \"10 days\")\n        rng = tm.box_expected(rng, box_with_array)\n\n        other = np.timedelta64(\"NaT\")\n\n        expected = np.array([np.nan] * 10)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = rng / other\n        tm.assert_equal(result, expected)\n\n        result = other / rng\n        tm.assert_equal(result, expected)",
        "begin_line": 1605,
        "end_line": 1619,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_div_int#1621",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_div_int(self, box_with_array)",
        "snippet": "    def test_td64arr_div_int(self, box_with_array):\n        idx = TimedeltaIndex(np.arange(5, dtype=\"int64\"))\n        idx = tm.box_expected(idx, box_with_array)\n\n        result = idx / 1\n        tm.assert_equal(result, idx)\n\n        with pytest.raises(TypeError, match=\"Cannot divide\"):\n            # GH#23829\n            1 / idx",
        "begin_line": 1621,
        "end_line": 1630,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_div_tdlike_scalar#1632",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_div_tdlike_scalar(self, two_hours, box_with_array)",
        "snippet": "    def test_td64arr_div_tdlike_scalar(self, two_hours, box_with_array):\n        # GH#20088, GH#22163 ensure DataFrame returns correct dtype\n        rng = timedelta_range(\"1 days\", \"10 days\", name=\"foo\")\n        expected = pd.Float64Index((np.arange(10) + 1) * 12, name=\"foo\")\n\n        rng = tm.box_expected(rng, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = rng / two_hours\n        tm.assert_equal(result, expected)\n\n        result = two_hours / rng\n        expected = 1 / expected\n        tm.assert_equal(result, expected)",
        "begin_line": 1632,
        "end_line": 1645,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_div_td64_scalar#1649",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_div_td64_scalar(self, m, unit, box_with_array)",
        "snippet": "    def test_td64arr_div_td64_scalar(self, m, unit, box_with_array):\n        startdate = Series(pd.date_range(\"2013-01-01\", \"2013-01-03\"))\n        enddate = Series(pd.date_range(\"2013-03-01\", \"2013-03-03\"))\n\n        ser = enddate - startdate\n        ser[2] = np.nan\n        flat = ser\n        ser = tm.box_expected(ser, box_with_array)\n\n        # op\n        expected = Series([x / np.timedelta64(m, unit) for x in flat])\n        expected = tm.box_expected(expected, box_with_array)\n        result = ser / np.timedelta64(m, unit)\n        tm.assert_equal(result, expected)\n\n        # reverse op\n        expected = Series([Timedelta(np.timedelta64(m, unit)) / x for x in flat])\n        expected = tm.box_expected(expected, box_with_array)\n        result = np.timedelta64(m, unit) / ser\n        tm.assert_equal(result, expected)",
        "begin_line": 1649,
        "end_line": 1668,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_div_tdlike_scalar_with_nat#1670",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_div_tdlike_scalar_with_nat(self, two_hours, box_with_array)",
        "snippet": "    def test_td64arr_div_tdlike_scalar_with_nat(self, two_hours, box_with_array):\n        rng = TimedeltaIndex([\"1 days\", pd.NaT, \"2 days\"], name=\"foo\")\n        expected = pd.Float64Index([12, np.nan, 24], name=\"foo\")\n\n        rng = tm.box_expected(rng, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = rng / two_hours\n        tm.assert_equal(result, expected)\n\n        result = two_hours / rng\n        expected = 1 / expected\n        tm.assert_equal(result, expected)",
        "begin_line": 1670,
        "end_line": 1682,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_div_td64_ndarray#1684",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_div_td64_ndarray(self, box_with_array)",
        "snippet": "    def test_td64arr_div_td64_ndarray(self, box_with_array):\n        # GH#22631\n        rng = TimedeltaIndex([\"1 days\", pd.NaT, \"2 days\"])\n        expected = pd.Float64Index([12, np.nan, 24])\n\n        rng = tm.box_expected(rng, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        other = np.array([2, 4, 2], dtype=\"m8[h]\")\n        result = rng / other\n        tm.assert_equal(result, expected)\n\n        result = rng / tm.box_expected(other, box_with_array)\n        tm.assert_equal(result, expected)\n\n        result = rng / other.astype(object)\n        tm.assert_equal(result, expected)\n\n        result = rng / list(other)\n        tm.assert_equal(result, expected)\n\n        # reversed op\n        expected = 1 / expected\n        result = other / rng\n        tm.assert_equal(result, expected)\n\n        result = tm.box_expected(other, box_with_array) / rng\n        tm.assert_equal(result, expected)\n\n        result = other.astype(object) / rng\n        tm.assert_equal(result, expected)\n\n        result = list(other) / rng\n        tm.assert_equal(result, expected)",
        "begin_line": 1684,
        "end_line": 1717,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_tdarr_div_length_mismatch#1719",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_tdarr_div_length_mismatch(self, box_with_array)",
        "snippet": "    def test_tdarr_div_length_mismatch(self, box_with_array):\n        rng = TimedeltaIndex([\"1 days\", pd.NaT, \"2 days\"])\n        mismatched = [1, 2, 3, 4]\n\n        rng = tm.box_expected(rng, box_with_array)\n        msg = \"Cannot divide vectors|Unable to coerce to Series\"\n        for obj in [mismatched, mismatched[:2]]:\n            # one shorter, one longer\n            for other in [obj, np.array(obj), pd.Index(obj)]:\n                with pytest.raises(ValueError, match=msg):\n                    rng / other\n                with pytest.raises(ValueError, match=msg):\n                    other / rng",
        "begin_line": 1719,
        "end_line": 1731,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_floordiv_tdscalar#1736",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_floordiv_tdscalar(self, box_with_array, scalar_td)",
        "snippet": "    def test_td64arr_floordiv_tdscalar(self, box_with_array, scalar_td):\n        # GH#18831\n        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)\n        td1.iloc[2] = np.nan\n\n        expected = Series([0, 0, np.nan])\n\n        td1 = tm.box_expected(td1, box_with_array, transpose=False)\n        expected = tm.box_expected(expected, box_with_array, transpose=False)\n\n        result = td1 // scalar_td\n        tm.assert_equal(result, expected)",
        "begin_line": 1736,
        "end_line": 1747,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_rfloordiv_tdscalar#1749",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_rfloordiv_tdscalar(self, box_with_array, scalar_td)",
        "snippet": "    def test_td64arr_rfloordiv_tdscalar(self, box_with_array, scalar_td):\n        # GH#18831\n        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)\n        td1.iloc[2] = np.nan\n\n        expected = Series([1, 1, np.nan])\n\n        td1 = tm.box_expected(td1, box_with_array, transpose=False)\n        expected = tm.box_expected(expected, box_with_array, transpose=False)\n\n        result = scalar_td // td1\n        tm.assert_equal(result, expected)",
        "begin_line": 1749,
        "end_line": 1760,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_rfloordiv_tdscalar_explicit#1762",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_rfloordiv_tdscalar_explicit(self, box_with_array, scalar_td)",
        "snippet": "    def test_td64arr_rfloordiv_tdscalar_explicit(self, box_with_array, scalar_td):\n        # GH#18831\n        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)\n        td1.iloc[2] = np.nan\n\n        expected = Series([1, 1, np.nan])\n\n        td1 = tm.box_expected(td1, box_with_array, transpose=False)\n        expected = tm.box_expected(expected, box_with_array, transpose=False)\n\n        # We can test __rfloordiv__ using this syntax,\n        # see `test_timedelta_rfloordiv`\n        result = td1.__rfloordiv__(scalar_td)\n        tm.assert_equal(result, expected)",
        "begin_line": 1762,
        "end_line": 1775,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_floordiv_int#1777",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_floordiv_int(self, box_with_array)",
        "snippet": "    def test_td64arr_floordiv_int(self, box_with_array):\n        idx = TimedeltaIndex(np.arange(5, dtype=\"int64\"))\n        idx = tm.box_expected(idx, box_with_array)\n        result = idx // 1\n        tm.assert_equal(result, idx)\n\n        pattern = \"floor_divide cannot use operands|Cannot divide int by Timedelta*\"\n        with pytest.raises(TypeError, match=pattern):\n            1 // idx",
        "begin_line": 1777,
        "end_line": 1785,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_floordiv_tdlike_scalar#1787",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_floordiv_tdlike_scalar(self, two_hours, box_with_array)",
        "snippet": "    def test_td64arr_floordiv_tdlike_scalar(self, two_hours, box_with_array):\n        tdi = timedelta_range(\"1 days\", \"10 days\", name=\"foo\")\n        expected = pd.Int64Index((np.arange(10) + 1) * 12, name=\"foo\")\n\n        tdi = tm.box_expected(tdi, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = tdi // two_hours\n        tm.assert_equal(result, expected)",
        "begin_line": 1787,
        "end_line": 1795,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_rfloordiv_tdlike_scalar#1807",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_rfloordiv_tdlike_scalar(self, scalar_td, box_with_array)",
        "snippet": "    def test_td64arr_rfloordiv_tdlike_scalar(self, scalar_td, box_with_array):\n        # GH#19125\n        tdi = TimedeltaIndex([\"00:05:03\", \"00:05:03\", pd.NaT], freq=None)\n        expected = pd.Index([2.0, 2.0, np.nan])\n\n        tdi = tm.box_expected(tdi, box_with_array, transpose=False)\n        expected = tm.box_expected(expected, box_with_array, transpose=False)\n\n        res = tdi.__rfloordiv__(scalar_td)\n        tm.assert_equal(res, expected)\n\n        expected = pd.Index([0.0, 0.0, np.nan])\n        expected = tm.box_expected(expected, box_with_array, transpose=False)\n\n        res = tdi // (scalar_td)\n        tm.assert_equal(res, expected)",
        "begin_line": 1807,
        "end_line": 1822,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_mod_tdscalar#1829",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_mod_tdscalar(self, box_with_array, three_days)",
        "snippet": "    def test_td64arr_mod_tdscalar(self, box_with_array, three_days):\n        tdi = timedelta_range(\"1 Day\", \"9 days\")\n        tdarr = tm.box_expected(tdi, box_with_array)\n\n        expected = TimedeltaIndex([\"1 Day\", \"2 Days\", \"0 Days\"] * 3)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = tdarr % three_days\n        tm.assert_equal(result, expected)\n\n        if box_with_array is pd.DataFrame:\n            pytest.xfail(\"DataFrame does not have __divmod__ or __rdivmod__\")\n\n        result = divmod(tdarr, three_days)\n        tm.assert_equal(result[1], expected)\n        tm.assert_equal(result[0], tdarr // three_days)",
        "begin_line": 1829,
        "end_line": 1844,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_mod_int#1846",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_mod_int(self, box_with_array)",
        "snippet": "    def test_td64arr_mod_int(self, box_with_array):\n        tdi = timedelta_range(\"1 ns\", \"10 ns\", periods=10)\n        tdarr = tm.box_expected(tdi, box_with_array)\n\n        expected = TimedeltaIndex([\"1 ns\", \"0 ns\"] * 5)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = tdarr % 2\n        tm.assert_equal(result, expected)\n\n        msg = \"Cannot divide int by\"\n        with pytest.raises(TypeError, match=msg):\n            2 % tdarr\n\n        if box_with_array is pd.DataFrame:\n            pytest.xfail(\"DataFrame does not have __divmod__ or __rdivmod__\")\n\n        result = divmod(tdarr, 2)\n        tm.assert_equal(result[1], expected)\n        tm.assert_equal(result[0], tdarr // 2)",
        "begin_line": 1846,
        "end_line": 1865,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_rmod_tdscalar#1867",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_rmod_tdscalar(self, box_with_array, three_days)",
        "snippet": "    def test_td64arr_rmod_tdscalar(self, box_with_array, three_days):\n        tdi = timedelta_range(\"1 Day\", \"9 days\")\n        tdarr = tm.box_expected(tdi, box_with_array)\n\n        expected = [\"0 Days\", \"1 Day\", \"0 Days\"] + [\"3 Days\"] * 6\n        expected = TimedeltaIndex(expected)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = three_days % tdarr\n        tm.assert_equal(result, expected)\n\n        if box_with_array is pd.DataFrame:\n            pytest.xfail(\"DataFrame does not have __divmod__ or __rdivmod__\")\n\n        result = divmod(three_days, tdarr)\n        tm.assert_equal(result[1], expected)\n        tm.assert_equal(result[0], three_days // tdarr)",
        "begin_line": 1867,
        "end_line": 1883,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_mul_tdscalar_invalid#1888",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_mul_tdscalar_invalid(self, box_with_array, scalar_td)",
        "snippet": "    def test_td64arr_mul_tdscalar_invalid(self, box_with_array, scalar_td):\n        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)\n        td1.iloc[2] = np.nan\n\n        td1 = tm.box_expected(td1, box_with_array)\n\n        # check that we are getting a TypeError\n        # with 'operate' (from core/ops.py) for the ops that are not\n        # defined\n        pattern = \"operate|unsupported|cannot|not supported\"\n        with pytest.raises(TypeError, match=pattern):\n            td1 * scalar_td\n        with pytest.raises(TypeError, match=pattern):\n            scalar_td * td1",
        "begin_line": 1888,
        "end_line": 1901,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_mul_too_short_raises#1903",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_mul_too_short_raises(self, box_with_array)",
        "snippet": "    def test_td64arr_mul_too_short_raises(self, box_with_array):\n        idx = TimedeltaIndex(np.arange(5, dtype=\"int64\"))\n        idx = tm.box_expected(idx, box_with_array)\n        msg = (\n            \"cannot use operands with types dtype|\"\n            \"Cannot multiply with unequal lengths|\"\n            \"Unable to coerce to Series\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            idx * idx[:3]\n        with pytest.raises(ValueError, match=msg):\n            idx * np.array([1, 2])",
        "begin_line": 1903,
        "end_line": 1914,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_mul_td64arr_raises#1916",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_mul_td64arr_raises(self, box_with_array)",
        "snippet": "    def test_td64arr_mul_td64arr_raises(self, box_with_array):\n        idx = TimedeltaIndex(np.arange(5, dtype=\"int64\"))\n        idx = tm.box_expected(idx, box_with_array)\n        msg = \"cannot use operands with types dtype\"\n        with pytest.raises(TypeError, match=msg):\n            idx * idx",
        "begin_line": 1916,
        "end_line": 1921,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_mul_numeric_scalar#1926",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_mul_numeric_scalar(self, box_with_array, one)",
        "snippet": "    def test_td64arr_mul_numeric_scalar(self, box_with_array, one):\n        # GH#4521\n        # divide/multiply by integers\n        tdser = pd.Series([\"59 Days\", \"59 Days\", \"NaT\"], dtype=\"m8[ns]\")\n        expected = Series([\"-59 Days\", \"-59 Days\", \"NaT\"], dtype=\"timedelta64[ns]\")\n\n        tdser = tm.box_expected(tdser, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = tdser * (-one)\n        tm.assert_equal(result, expected)\n        result = (-one) * tdser\n        tm.assert_equal(result, expected)\n\n        expected = Series([\"118 Days\", \"118 Days\", \"NaT\"], dtype=\"timedelta64[ns]\")\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = tdser * (2 * one)\n        tm.assert_equal(result, expected)\n        result = (2 * one) * tdser\n        tm.assert_equal(result, expected)",
        "begin_line": 1926,
        "end_line": 1946,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_div_numeric_scalar#1949",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_div_numeric_scalar(self, box_with_array, two)",
        "snippet": "    def test_td64arr_div_numeric_scalar(self, box_with_array, two):\n        # GH#4521\n        # divide/multiply by integers\n        tdser = pd.Series([\"59 Days\", \"59 Days\", \"NaT\"], dtype=\"m8[ns]\")\n        expected = Series([\"29.5D\", \"29.5D\", \"NaT\"], dtype=\"timedelta64[ns]\")\n\n        tdser = tm.box_expected(tdser, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = tdser / two\n        tm.assert_equal(result, expected)\n\n        with pytest.raises(TypeError, match=\"Cannot divide\"):\n            two / tdser",
        "begin_line": 1949,
        "end_line": 1962,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_rmul_numeric_array#1969",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_rmul_numeric_array(self, box_with_array, vector, any_real_dtype)",
        "snippet": "    def test_td64arr_rmul_numeric_array(self, box_with_array, vector, any_real_dtype):\n        # GH#4521\n        # divide/multiply by integers\n        xbox = get_upcast_box(box_with_array, vector)\n\n        tdser = pd.Series([\"59 Days\", \"59 Days\", \"NaT\"], dtype=\"m8[ns]\")\n        vector = vector.astype(any_real_dtype)\n\n        expected = Series([\"1180 Days\", \"1770 Days\", \"NaT\"], dtype=\"timedelta64[ns]\")\n\n        tdser = tm.box_expected(tdser, box_with_array)\n        expected = tm.box_expected(expected, xbox)\n\n        result = tdser * vector\n        tm.assert_equal(result, expected)\n\n        result = vector * tdser\n        tm.assert_equal(result, expected)",
        "begin_line": 1969,
        "end_line": 1986,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_div_numeric_array#1993",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_div_numeric_array(self, box_with_array, vector, any_real_dtype)",
        "snippet": "    def test_td64arr_div_numeric_array(self, box_with_array, vector, any_real_dtype):\n        # GH#4521\n        # divide/multiply by integers\n        xbox = get_upcast_box(box_with_array, vector)\n\n        tdser = pd.Series([\"59 Days\", \"59 Days\", \"NaT\"], dtype=\"m8[ns]\")\n        vector = vector.astype(any_real_dtype)\n\n        expected = Series([\"2.95D\", \"1D 23H 12m\", \"NaT\"], dtype=\"timedelta64[ns]\")\n\n        tdser = tm.box_expected(tdser, box_with_array)\n        expected = tm.box_expected(expected, xbox)\n\n        result = tdser / vector\n        tm.assert_equal(result, expected)\n\n        pattern = (\n            \"true_divide cannot use operands|\"\n            \"cannot perform __div__|\"\n            \"cannot perform __truediv__|\"\n            \"unsupported operand|\"\n            \"Cannot divide\"\n        )\n        with pytest.raises(TypeError, match=pattern):\n            vector / tdser\n\n        if not isinstance(vector, pd.Index):\n            # Index.__rdiv__ won't try to operate elementwise, just raises\n            result = tdser / vector.astype(object)\n            if box_with_array is pd.DataFrame:\n                expected = [tdser.iloc[0, n] / vector[n] for n in range(len(vector))]\n            else:\n                expected = [tdser[n] / vector[n] for n in range(len(tdser))]\n            expected = pd.Index(expected)  # do dtype inference\n            expected = tm.box_expected(expected, xbox)\n            tm.assert_equal(result, expected)\n\n        with pytest.raises(TypeError, match=pattern):\n            vector.astype(object) / tdser",
        "begin_line": 1993,
        "end_line": 2031,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_mul_int_series#2033",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_td64arr_mul_int_series(self, box_df_fail, names)",
        "snippet": "    def test_td64arr_mul_int_series(self, box_df_fail, names):\n        # GH#19042 test for correct name attachment\n        box = box_df_fail  # broadcasts along wrong axis, but doesn't raise\n        exname = names[2] if box is not tm.to_array else names[1]\n\n        tdi = TimedeltaIndex(\n            [\"0days\", \"1day\", \"2days\", \"3days\", \"4days\"], name=names[0]\n        )\n        # TODO: Should we be parametrizing over types for `ser` too?\n        ser = Series([0, 1, 2, 3, 4], dtype=np.int64, name=names[1])\n\n        expected = Series(\n            [\"0days\", \"1day\", \"4days\", \"9days\", \"16days\"],\n            dtype=\"timedelta64[ns]\",\n            name=exname,\n        )\n\n        tdi = tm.box_expected(tdi, box)\n        box = Series if (box is pd.Index or box is tm.to_array) else box\n        expected = tm.box_expected(expected, box)\n\n        result = ser * tdi\n        tm.assert_equal(result, expected)\n\n        # The direct operation tdi * ser still needs to be fixed.\n        result = ser.__rmul__(tdi)\n        tm.assert_equal(result, expected)",
        "begin_line": 2033,
        "end_line": 2059,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_float_series_rdiv_td64arr#2062",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeMulDivOps.test_float_series_rdiv_td64arr(self, box_with_array, names)",
        "snippet": "    def test_float_series_rdiv_td64arr(self, box_with_array, names):\n        # GH#19042 test for correct name attachment\n        # TODO: the direct operation TimedeltaIndex / Series still\n        # needs to be fixed.\n        box = box_with_array\n        tdi = TimedeltaIndex(\n            [\"0days\", \"1day\", \"2days\", \"3days\", \"4days\"], name=names[0]\n        )\n        ser = Series([1.5, 3, 4.5, 6, 7.5], dtype=np.float64, name=names[1])\n\n        xname = names[2] if box is not tm.to_array else names[1]\n        expected = Series(\n            [tdi[n] / ser[n] for n in range(len(ser))],\n            dtype=\"timedelta64[ns]\",\n            name=xname,\n        )\n\n        xbox = box\n        if box in [pd.Index, tm.to_array] and type(ser) is Series:\n            xbox = Series\n\n        tdi = tm.box_expected(tdi, box)\n        expected = tm.box_expected(expected, xbox)\n\n        result = ser.__rdiv__(tdi)\n        if box is pd.DataFrame:\n            # TODO: Should we skip this case sooner or test something else?\n            assert result is NotImplemented\n        else:\n            tm.assert_equal(result, expected)",
        "begin_line": 2062,
        "end_line": 2091,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayLikeArithmetic.test_td64arr_pow_invalid#2099",
        "src_path": "pandas/tests/arithmetic/test_timedelta64.py",
        "class_name": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayLikeArithmetic",
        "signature": "pandas.tests.arithmetic.test_timedelta64.TestTimedelta64ArrayLikeArithmetic.test_td64arr_pow_invalid(self, scalar_td, box_with_array)",
        "snippet": "    def test_td64arr_pow_invalid(self, scalar_td, box_with_array):\n        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)\n        td1.iloc[2] = np.nan\n\n        td1 = tm.box_expected(td1, box_with_array)\n\n        # check that we are getting a TypeError\n        # with 'operate' (from core/ops.py) for the ops that are not\n        # defined\n        pattern = \"operate|unsupported|cannot|not supported\"\n        with pytest.raises(TypeError, match=pattern):\n            scalar_td ** td1\n\n        with pytest.raises(TypeError, match=pattern):\n            td1 ** scalar_td",
        "begin_line": 2099,
        "end_line": 2113,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64ArrayLikeComparisons.test_compare_zerodim#47",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64ArrayLikeComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64ArrayLikeComparisons.test_compare_zerodim(self, tz_naive_fixture, box_with_array)",
        "snippet": "    def test_compare_zerodim(self, tz_naive_fixture, box_with_array):\n        # Test comparison with zero-dimensional array is unboxed\n        tz = tz_naive_fixture\n        box = box_with_array\n        xbox = box_with_array if box_with_array is not pd.Index else np.ndarray\n        dti = date_range(\"20130101\", periods=3, tz=tz)\n\n        other = np.array(dti.to_numpy()[0])\n\n        dtarr = tm.box_expected(dti, box)\n        result = dtarr <= other\n        expected = np.array([True, False, False])\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(result, expected)",
        "begin_line": 47,
        "end_line": 60,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64ArrayLikeComparisons.test_dt64arr_cmp_scalar_invalid#80",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64ArrayLikeComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64ArrayLikeComparisons.test_dt64arr_cmp_scalar_invalid(self, other, tz_naive_fixture, box_with_array)",
        "snippet": "    def test_dt64arr_cmp_scalar_invalid(self, other, tz_naive_fixture, box_with_array):\n        # GH#22074, GH#15966\n        tz = tz_naive_fixture\n\n        rng = date_range(\"1/1/2000\", periods=10, tz=tz)\n        dtarr = tm.box_expected(rng, box_with_array)\n        assert_invalid_comparison(dtarr, other, box_with_array)",
        "begin_line": 80,
        "end_line": 86,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64ArrayLikeComparisons.test_dt64arr_cmp_arraylike_invalid#103",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64ArrayLikeComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64ArrayLikeComparisons.test_dt64arr_cmp_arraylike_invalid(self, other, tz_naive_fixture)",
        "snippet": "    def test_dt64arr_cmp_arraylike_invalid(self, other, tz_naive_fixture):\n        # We don't parametrize this over box_with_array because listlike\n        #  other plays poorly with assert_invalid_comparison reversed checks\n        tz = tz_naive_fixture\n\n        dta = date_range(\"1970-01-01\", freq=\"ns\", periods=10, tz=tz)._data\n        assert_invalid_comparison(dta, other, tm.to_array)",
        "begin_line": 103,
        "end_line": 109,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64ArrayLikeComparisons.test_dt64arr_cmp_mixed_invalid#111",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64ArrayLikeComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64ArrayLikeComparisons.test_dt64arr_cmp_mixed_invalid(self, tz_naive_fixture)",
        "snippet": "    def test_dt64arr_cmp_mixed_invalid(self, tz_naive_fixture):\n        tz = tz_naive_fixture\n\n        dta = date_range(\"1970-01-01\", freq=\"h\", periods=5, tz=tz)._data\n\n        other = np.array([0, 1, 2, dta[3], pd.Timedelta(days=1)])\n        result = dta == other\n        expected = np.array([False, False, False, True, False])\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = dta != other\n        tm.assert_numpy_array_equal(result, ~expected)\n\n        msg = \"Invalid comparison between|Cannot compare type|not supported between\"\n        with pytest.raises(TypeError, match=msg):\n            dta < other\n        with pytest.raises(TypeError, match=msg):\n            dta > other\n        with pytest.raises(TypeError, match=msg):\n            dta <= other\n        with pytest.raises(TypeError, match=msg):\n            dta >= other",
        "begin_line": 111,
        "end_line": 132,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64ArrayLikeComparisons.test_dt64arr_nat_comparison#134",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64ArrayLikeComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64ArrayLikeComparisons.test_dt64arr_nat_comparison(self, tz_naive_fixture, box_with_array)",
        "snippet": "    def test_dt64arr_nat_comparison(self, tz_naive_fixture, box_with_array):\n        # GH#22242, GH#22163 DataFrame considered NaT == ts incorrectly\n        tz = tz_naive_fixture\n        box = box_with_array\n        xbox = box if box is not pd.Index else np.ndarray\n\n        ts = pd.Timestamp.now(tz)\n        ser = pd.Series([ts, pd.NaT])\n\n        # FIXME: Can't transpose because that loses the tz dtype on\n        #  the NaT column\n        obj = tm.box_expected(ser, box, transpose=False)\n\n        expected = pd.Series([True, False], dtype=np.bool_)\n        expected = tm.box_expected(expected, xbox, transpose=False)\n\n        result = obj == ts\n        tm.assert_equal(result, expected)",
        "begin_line": 134,
        "end_line": 151,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_nat_comparisons#176",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_nat_comparisons(self, dtype, index_or_series, reverse, pair)",
        "snippet": "    def test_nat_comparisons(self, dtype, index_or_series, reverse, pair):\n        box = index_or_series\n        l, r = pair\n        if reverse:\n            # add lhs / rhs switched data\n            l, r = r, l\n\n        left = Series(l, dtype=dtype)\n        right = box(r, dtype=dtype)\n        # Series, Index\n\n        expected = Series([False, False, True])\n        tm.assert_series_equal(left == right, expected)\n\n        expected = Series([True, True, False])\n        tm.assert_series_equal(left != right, expected)\n\n        expected = Series([False, False, False])\n        tm.assert_series_equal(left < right, expected)\n\n        expected = Series([False, False, False])\n        tm.assert_series_equal(left > right, expected)\n\n        expected = Series([False, False, True])\n        tm.assert_series_equal(left >= right, expected)\n\n        expected = Series([False, False, True])\n        tm.assert_series_equal(left <= right, expected)",
        "begin_line": 176,
        "end_line": 203,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_comparison_invalid#205",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_comparison_invalid(self, tz_naive_fixture, box_with_array)",
        "snippet": "    def test_comparison_invalid(self, tz_naive_fixture, box_with_array):\n        # GH#4968\n        # invalid date/int comparisons\n        tz = tz_naive_fixture\n        ser = Series(range(5))\n        ser2 = Series(pd.date_range(\"20010101\", periods=5, tz=tz))\n\n        ser = tm.box_expected(ser, box_with_array)\n        ser2 = tm.box_expected(ser2, box_with_array)\n\n        assert_invalid_comparison(ser, ser2, box_with_array)",
        "begin_line": 205,
        "end_line": 215,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_nat_comparisons_scalar#226",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_nat_comparisons_scalar(self, dtype, data, box_with_array)",
        "snippet": "    def test_nat_comparisons_scalar(self, dtype, data, box_with_array):\n        if box_with_array is tm.to_array and dtype is object:\n            # dont bother testing ndarray comparison methods as this fails\n            #  on older numpys (since they check object identity)\n            return\n\n        xbox = box_with_array if box_with_array is not pd.Index else np.ndarray\n\n        left = Series(data, dtype=dtype)\n        left = tm.box_expected(left, box_with_array)\n\n        expected = [False, False, False]\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(left == NaT, expected)\n        tm.assert_equal(NaT == left, expected)\n\n        expected = [True, True, True]\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(left != NaT, expected)\n        tm.assert_equal(NaT != left, expected)\n\n        expected = [False, False, False]\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(left < NaT, expected)\n        tm.assert_equal(NaT > left, expected)\n        tm.assert_equal(left <= NaT, expected)\n        tm.assert_equal(NaT >= left, expected)\n\n        tm.assert_equal(left > NaT, expected)\n        tm.assert_equal(NaT < left, expected)\n        tm.assert_equal(left >= NaT, expected)\n        tm.assert_equal(NaT <= left, expected)",
        "begin_line": 226,
        "end_line": 257,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_series_comparison_scalars#260",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_series_comparison_scalars(self, val)",
        "snippet": "    def test_series_comparison_scalars(self, val):\n        series = Series(date_range(\"1/1/2000\", periods=10))\n\n        result = series > val\n        expected = Series([x > val for x in series])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 260,
        "end_line": 265,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_timestamp_compare_series#270",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_timestamp_compare_series(self, left, right)",
        "snippet": "    def test_timestamp_compare_series(self, left, right):\n        # see gh-4982\n        # Make sure we can compare Timestamps on the right AND left hand side.\n        ser = pd.Series(pd.date_range(\"20010101\", periods=10), name=\"dates\")\n        s_nat = ser.copy(deep=True)\n\n        ser[0] = pd.Timestamp(\"nat\")\n        ser[3] = pd.Timestamp(\"nat\")\n\n        left_f = getattr(operator, left)\n        right_f = getattr(operator, right)\n\n        # No NaT\n        expected = left_f(ser, pd.Timestamp(\"20010109\"))\n        result = right_f(pd.Timestamp(\"20010109\"), ser)\n        tm.assert_series_equal(result, expected)\n\n        # NaT\n        expected = left_f(ser, pd.Timestamp(\"nat\"))\n        result = right_f(pd.Timestamp(\"nat\"), ser)\n        tm.assert_series_equal(result, expected)\n\n        # Compare to Timestamp with series containing NaT\n        expected = left_f(s_nat, pd.Timestamp(\"20010109\"))\n        result = right_f(pd.Timestamp(\"20010109\"), s_nat)\n        tm.assert_series_equal(result, expected)\n\n        # Compare to NaT with series containing NaT\n        expected = left_f(s_nat, pd.Timestamp(\"nat\"))\n        result = right_f(pd.Timestamp(\"nat\"), s_nat)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 270,
        "end_line": 300,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_dt64arr_timestamp_equality#302",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64SeriesComparison.test_dt64arr_timestamp_equality(self, box_with_array)",
        "snippet": "    def test_dt64arr_timestamp_equality(self, box_with_array):\n        # GH#11034\n        xbox = box_with_array if box_with_array is not pd.Index else np.ndarray\n\n        ser = pd.Series([pd.Timestamp(\"2000-01-29 01:59:00\"), \"NaT\"])\n        ser = tm.box_expected(ser, box_with_array)\n\n        result = ser != ser\n        expected = tm.box_expected([False, True], xbox)\n        tm.assert_equal(result, expected)\n\n        result = ser != ser[0]\n        expected = tm.box_expected([False, True], xbox)\n        tm.assert_equal(result, expected)\n\n        result = ser != ser[1]\n        expected = tm.box_expected([True, True], xbox)\n        tm.assert_equal(result, expected)\n\n        result = ser == ser\n        expected = tm.box_expected([True, False], xbox)\n        tm.assert_equal(result, expected)\n\n        result = ser == ser[0]\n        expected = tm.box_expected([True, False], xbox)\n        tm.assert_equal(result, expected)\n\n        result = ser == ser[1]\n        expected = tm.box_expected([False, False], xbox)\n        tm.assert_equal(result, expected)",
        "begin_line": 302,
        "end_line": 331,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_comparators#341",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_comparators(self, op)",
        "snippet": "    def test_comparators(self, op):\n        index = tm.makeDateIndex(100)\n        element = index[len(index) // 2]\n        element = Timestamp(element).to_datetime64()\n\n        arr = np.array(index)\n        arr_result = op(arr, element)\n        index_result = op(index, element)\n\n        assert isinstance(index_result, np.ndarray)\n        tm.assert_numpy_array_equal(arr_result, index_result)",
        "begin_line": 341,
        "end_line": 351,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_datetimelike#357",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_datetimelike(self, other, tz_naive_fixture)",
        "snippet": "    def test_dti_cmp_datetimelike(self, other, tz_naive_fixture):\n        tz = tz_naive_fixture\n        dti = pd.date_range(\"2016-01-01\", periods=2, tz=tz)\n        if tz is not None:\n            if isinstance(other, np.datetime64):\n                # no tzaware version available\n                return\n            other = localize_pydatetime(other, dti.tzinfo)\n\n        result = dti == other\n        expected = np.array([True, False])\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = dti > other\n        expected = np.array([False, True])\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = dti >= other\n        expected = np.array([True, True])\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = dti < other\n        expected = np.array([False, False])\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = dti <= other\n        expected = np.array([True, False])\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 357,
        "end_line": 384,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_nat#387",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_nat(self, dtype, box_with_array)",
        "snippet": "    def test_dti_cmp_nat(self, dtype, box_with_array):\n        if box_with_array is tm.to_array and dtype is object:\n            # dont bother testing ndarray comparison methods as this fails\n            #  on older numpys (since they check object identity)\n            return\n\n        xbox = box_with_array if box_with_array is not pd.Index else np.ndarray\n\n        left = pd.DatetimeIndex(\n            [pd.Timestamp(\"2011-01-01\"), pd.NaT, pd.Timestamp(\"2011-01-03\")]\n        )\n        right = pd.DatetimeIndex([pd.NaT, pd.NaT, pd.Timestamp(\"2011-01-03\")])\n\n        left = tm.box_expected(left, box_with_array)\n        right = tm.box_expected(right, box_with_array)\n\n        lhs, rhs = left, right\n        if dtype is object:\n            lhs, rhs = left.astype(object), right.astype(object)\n\n        result = rhs == lhs\n        expected = np.array([False, False, True])\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(result, expected)\n\n        result = lhs != rhs\n        expected = np.array([True, True, False])\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(result, expected)\n\n        expected = np.array([False, False, False])\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(lhs == pd.NaT, expected)\n        tm.assert_equal(pd.NaT == rhs, expected)\n\n        expected = np.array([True, True, True])\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(lhs != pd.NaT, expected)\n        tm.assert_equal(pd.NaT != lhs, expected)\n\n        expected = np.array([False, False, False])\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(lhs < pd.NaT, expected)\n        tm.assert_equal(pd.NaT > lhs, expected)",
        "begin_line": 387,
        "end_line": 430,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_nat_behaves_like_float_cmp_nan#432",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_nat_behaves_like_float_cmp_nan(self)",
        "snippet": "    def test_dti_cmp_nat_behaves_like_float_cmp_nan(self):\n        fidx1 = pd.Index([1.0, np.nan, 3.0, np.nan, 5.0, 7.0])\n        fidx2 = pd.Index([2.0, 3.0, np.nan, np.nan, 6.0, 7.0])\n\n        didx1 = pd.DatetimeIndex(\n            [\"2014-01-01\", pd.NaT, \"2014-03-01\", pd.NaT, \"2014-05-01\", \"2014-07-01\"]\n        )\n        didx2 = pd.DatetimeIndex(\n            [\"2014-02-01\", \"2014-03-01\", pd.NaT, pd.NaT, \"2014-06-01\", \"2014-07-01\"]\n        )\n        darr = np.array(\n            [\n                np_datetime64_compat(\"2014-02-01 00:00Z\"),\n                np_datetime64_compat(\"2014-03-01 00:00Z\"),\n                np_datetime64_compat(\"nat\"),\n                np.datetime64(\"nat\"),\n                np_datetime64_compat(\"2014-06-01 00:00Z\"),\n                np_datetime64_compat(\"2014-07-01 00:00Z\"),\n            ]\n        )\n\n        cases = [(fidx1, fidx2), (didx1, didx2), (didx1, darr)]\n\n        # Check pd.NaT is handles as the same as np.nan\n        with tm.assert_produces_warning(None):\n            for idx1, idx2 in cases:\n\n                result = idx1 < idx2\n                expected = np.array([True, False, False, False, True, False])\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx2 > idx1\n                expected = np.array([True, False, False, False, True, False])\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx1 <= idx2\n                expected = np.array([True, False, False, False, True, True])\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx2 >= idx1\n                expected = np.array([True, False, False, False, True, True])\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx1 == idx2\n                expected = np.array([False, False, False, False, False, True])\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx1 != idx2\n                expected = np.array([True, True, True, True, True, False])\n                tm.assert_numpy_array_equal(result, expected)\n\n        with tm.assert_produces_warning(None):\n            for idx1, val in [(fidx1, np.nan), (didx1, pd.NaT)]:\n                result = idx1 < val\n                expected = np.array([False, False, False, False, False, False])\n                tm.assert_numpy_array_equal(result, expected)\n                result = idx1 > val\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx1 <= val\n                tm.assert_numpy_array_equal(result, expected)\n                result = idx1 >= val\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx1 == val\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx1 != val\n                expected = np.array([True, True, True, True, True, True])\n                tm.assert_numpy_array_equal(result, expected)\n\n        # Check pd.NaT is handles as the same as np.nan\n        with tm.assert_produces_warning(None):\n            for idx1, val in [(fidx1, 3), (didx1, datetime(2014, 3, 1))]:\n                result = idx1 < val\n                expected = np.array([True, False, False, False, False, False])\n                tm.assert_numpy_array_equal(result, expected)\n                result = idx1 > val\n                expected = np.array([False, False, False, False, True, True])\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx1 <= val\n                expected = np.array([True, False, True, False, False, False])\n                tm.assert_numpy_array_equal(result, expected)\n                result = idx1 >= val\n                expected = np.array([False, False, True, False, True, True])\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx1 == val\n                expected = np.array([False, False, True, False, False, False])\n                tm.assert_numpy_array_equal(result, expected)\n\n                result = idx1 != val\n                expected = np.array([True, True, False, True, True, True])\n                tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 432,
        "end_line": 526,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_comparison_tzawareness_compat#532",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_comparison_tzawareness_compat(self, op, box_df_fail)",
        "snippet": "    def test_comparison_tzawareness_compat(self, op, box_df_fail):\n        # GH#18162\n        box = box_df_fail\n\n        dr = pd.date_range(\"2016-01-01\", periods=6)\n        dz = dr.tz_localize(\"US/Pacific\")\n\n        dr = tm.box_expected(dr, box)\n        dz = tm.box_expected(dz, box)\n\n        msg = \"Cannot compare tz-naive and tz-aware\"\n        with pytest.raises(TypeError, match=msg):\n            op(dr, dz)\n\n        # FIXME: DataFrame case fails to raise for == and !=, wrong\n        #  message for inequalities\n        with pytest.raises(TypeError, match=msg):\n            op(dr, list(dz))\n        with pytest.raises(TypeError, match=msg):\n            op(dr, np.array(list(dz), dtype=object))\n        with pytest.raises(TypeError, match=msg):\n            op(dz, dr)\n\n        # FIXME: DataFrame case fails to raise for == and !=, wrong\n        #  message for inequalities\n        with pytest.raises(TypeError, match=msg):\n            op(dz, list(dr))\n        with pytest.raises(TypeError, match=msg):\n            op(dz, np.array(list(dr), dtype=object))\n\n        # The aware==aware and naive==naive comparisons should *not* raise\n        assert np.all(dr == dr)\n        assert np.all(dr == list(dr))\n        assert np.all(list(dr) == dr)\n        assert np.all(np.array(list(dr), dtype=object) == dr)\n        assert np.all(dr == np.array(list(dr), dtype=object))\n\n        assert np.all(dz == dz)\n        assert np.all(dz == list(dz))\n        assert np.all(list(dz) == dz)\n        assert np.all(np.array(list(dz), dtype=object) == dz)\n        assert np.all(dz == np.array(list(dz), dtype=object))",
        "begin_line": 532,
        "end_line": 573,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_comparison_tzawareness_compat_scalars#579",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_comparison_tzawareness_compat_scalars(self, op, box_with_array)",
        "snippet": "    def test_comparison_tzawareness_compat_scalars(self, op, box_with_array):\n        # GH#18162\n        dr = pd.date_range(\"2016-01-01\", periods=6)\n        dz = dr.tz_localize(\"US/Pacific\")\n\n        dr = tm.box_expected(dr, box_with_array)\n        dz = tm.box_expected(dz, box_with_array)\n\n        # Check comparisons against scalar Timestamps\n        ts = pd.Timestamp(\"2000-03-14 01:59\")\n        ts_tz = pd.Timestamp(\"2000-03-14 01:59\", tz=\"Europe/Amsterdam\")\n\n        assert np.all(dr > ts)\n        msg = \"Cannot compare tz-naive and tz-aware\"\n        with pytest.raises(TypeError, match=msg):\n            op(dr, ts_tz)\n\n        assert np.all(dz > ts_tz)\n        with pytest.raises(TypeError, match=msg):\n            op(dz, ts)\n\n        # GH#12601: Check comparison against Timestamps and DatetimeIndex\n        with pytest.raises(TypeError, match=msg):\n            op(ts, dz)",
        "begin_line": 579,
        "end_line": 602,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_scalar_comparison_tzawareness#617",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_scalar_comparison_tzawareness(self, op, other, tz_aware_fixture, box_with_array)",
        "snippet": "    def test_scalar_comparison_tzawareness(\n        self, op, other, tz_aware_fixture, box_with_array\n    ):\n        tz = tz_aware_fixture\n        dti = pd.date_range(\"2016-01-01\", periods=2, tz=tz)\n\n        dtarr = tm.box_expected(dti, box_with_array)\n        msg = \"Cannot compare tz-naive and tz-aware\"\n        with pytest.raises(TypeError, match=msg):\n            op(dtarr, other)\n        with pytest.raises(TypeError, match=msg):\n            op(other, dtarr)",
        "begin_line": 617,
        "end_line": 628,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_nat_comparison_tzawareness#634",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_nat_comparison_tzawareness(self, op)",
        "snippet": "    def test_nat_comparison_tzawareness(self, op):\n        # GH#19276\n        # tzaware DatetimeIndex should not raise when compared to NaT\n        dti = pd.DatetimeIndex(\n            [\"2014-01-01\", pd.NaT, \"2014-03-01\", pd.NaT, \"2014-05-01\", \"2014-07-01\"]\n        )\n        expected = np.array([op == operator.ne] * len(dti))\n        result = op(dti, pd.NaT)\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = op(dti.tz_localize(\"US/Pacific\"), pd.NaT)\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 634,
        "end_line": 645,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_str#647",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_str(self, tz_naive_fixture)",
        "snippet": "    def test_dti_cmp_str(self, tz_naive_fixture):\n        # GH#22074\n        # regardless of tz, we expect these comparisons are valid\n        tz = tz_naive_fixture\n        rng = date_range(\"1/1/2000\", periods=10, tz=tz)\n        other = \"1/1/2000\"\n\n        result = rng == other\n        expected = np.array([True] + [False] * 9)\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = rng != other\n        expected = np.array([False] + [True] * 9)\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = rng < other\n        expected = np.array([False] * 10)\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = rng <= other\n        expected = np.array([True] + [False] * 9)\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = rng > other\n        expected = np.array([False] + [True] * 9)\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = rng >= other\n        expected = np.array([True] * 10)\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 647,
        "end_line": 676,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_list#678",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_list(self)",
        "snippet": "    def test_dti_cmp_list(self):\n        rng = date_range(\"1/1/2000\", periods=10)\n\n        result = rng == list(rng)\n        expected = rng == rng\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 678,
        "end_line": 683,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_tdi_tzawareness#694",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_tdi_tzawareness(self, other)",
        "snippet": "    def test_dti_cmp_tdi_tzawareness(self, other):\n        # GH#22074\n        # reversion test that we _don't_ call _assert_tzawareness_compat\n        # when comparing against TimedeltaIndex\n        dti = date_range(\"2000-01-01\", periods=10, tz=\"Asia/Tokyo\")\n\n        result = dti == other\n        expected = np.array([False] * 10)\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = dti != other\n        expected = np.array([True] * 10)\n        tm.assert_numpy_array_equal(result, expected)\n        msg = \"Invalid comparison between\"\n        with pytest.raises(TypeError, match=msg):\n            dti < other\n        with pytest.raises(TypeError, match=msg):\n            dti <= other\n        with pytest.raises(TypeError, match=msg):\n            dti > other\n        with pytest.raises(TypeError, match=msg):\n            dti >= other",
        "begin_line": 694,
        "end_line": 715,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_object_dtype#717",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexComparisons.test_dti_cmp_object_dtype(self)",
        "snippet": "    def test_dti_cmp_object_dtype(self):\n        # GH#22074\n        dti = date_range(\"2000-01-01\", periods=10, tz=\"Asia/Tokyo\")\n\n        other = dti.astype(\"O\")\n\n        result = dti == other\n        expected = np.array([True] * 10)\n        tm.assert_numpy_array_equal(result, expected)\n\n        other = dti.tz_localize(None)\n        msg = \"Cannot compare tz-naive and tz-aware\"\n        with pytest.raises(TypeError, match=msg):\n            # tzawareness failure\n            dti != other\n\n        other = np.array(list(dti[:5]) + [Timedelta(days=1)] * 5)\n        result = dti == other\n        expected = np.array([True] * 5 + [False] * 5)\n        tm.assert_numpy_array_equal(result, expected)\n        msg = \">=' not supported between instances of 'Timestamp' and 'Timedelta'\"\n        with pytest.raises(TypeError, match=msg):\n            dti >= other",
        "begin_line": 717,
        "end_line": 739,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_timedeltalike_scalar#753",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_timedeltalike_scalar(self, tz_naive_fixture, two_hours, box_with_array)",
        "snippet": "    def test_dt64arr_add_timedeltalike_scalar(\n        self, tz_naive_fixture, two_hours, box_with_array\n    ):\n        # GH#22005, GH#22163 check DataFrame doesn't raise TypeError\n        tz = tz_naive_fixture\n\n        rng = pd.date_range(\"2000-01-01\", \"2000-02-01\", tz=tz)\n        expected = pd.date_range(\"2000-01-01 02:00\", \"2000-02-01 02:00\", tz=tz)\n\n        rng = tm.box_expected(rng, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = rng + two_hours\n        tm.assert_equal(result, expected)",
        "begin_line": 753,
        "end_line": 766,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_iadd_timedeltalike_scalar#768",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_iadd_timedeltalike_scalar(self, tz_naive_fixture, two_hours, box_with_array)",
        "snippet": "    def test_dt64arr_iadd_timedeltalike_scalar(\n        self, tz_naive_fixture, two_hours, box_with_array\n    ):\n        tz = tz_naive_fixture\n\n        rng = pd.date_range(\"2000-01-01\", \"2000-02-01\", tz=tz)\n        expected = pd.date_range(\"2000-01-01 02:00\", \"2000-02-01 02:00\", tz=tz)\n\n        rng = tm.box_expected(rng, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        rng += two_hours\n        tm.assert_equal(rng, expected)",
        "begin_line": 768,
        "end_line": 780,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_timedeltalike_scalar#782",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_timedeltalike_scalar(self, tz_naive_fixture, two_hours, box_with_array)",
        "snippet": "    def test_dt64arr_sub_timedeltalike_scalar(\n        self, tz_naive_fixture, two_hours, box_with_array\n    ):\n        tz = tz_naive_fixture\n\n        rng = pd.date_range(\"2000-01-01\", \"2000-02-01\", tz=tz)\n        expected = pd.date_range(\"1999-12-31 22:00\", \"2000-01-31 22:00\", tz=tz)\n\n        rng = tm.box_expected(rng, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = rng - two_hours\n        tm.assert_equal(result, expected)",
        "begin_line": 782,
        "end_line": 794,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_isub_timedeltalike_scalar#796",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_isub_timedeltalike_scalar(self, tz_naive_fixture, two_hours, box_with_array)",
        "snippet": "    def test_dt64arr_isub_timedeltalike_scalar(\n        self, tz_naive_fixture, two_hours, box_with_array\n    ):\n        tz = tz_naive_fixture\n\n        rng = pd.date_range(\"2000-01-01\", \"2000-02-01\", tz=tz)\n        expected = pd.date_range(\"1999-12-31 22:00\", \"2000-01-31 22:00\", tz=tz)\n\n        rng = tm.box_expected(rng, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        rng -= two_hours\n        tm.assert_equal(rng, expected)",
        "begin_line": 796,
        "end_line": 808,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_td64_scalar#811",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_td64_scalar(self, box_with_array)",
        "snippet": "    def test_dt64arr_add_td64_scalar(self, box_with_array):\n        # scalar timedeltas/np.timedelta64 objects\n        # operate with np.timedelta64 correctly\n        ser = Series([Timestamp(\"20130101 9:01\"), Timestamp(\"20130101 9:02\")])\n\n        expected = Series(\n            [Timestamp(\"20130101 9:01:01\"), Timestamp(\"20130101 9:02:01\")]\n        )\n\n        dtarr = tm.box_expected(ser, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = dtarr + np.timedelta64(1, \"s\")\n        tm.assert_equal(result, expected)\n        result = np.timedelta64(1, \"s\") + dtarr\n        tm.assert_equal(result, expected)\n\n        expected = Series(\n            [Timestamp(\"20130101 9:01:00.005\"), Timestamp(\"20130101 9:02:00.005\")]\n        )\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = dtarr + np.timedelta64(5, \"ms\")\n        tm.assert_equal(result, expected)\n        result = np.timedelta64(5, \"ms\") + dtarr\n        tm.assert_equal(result, expected)",
        "begin_line": 811,
        "end_line": 836,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_sub_td64_nat#838",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_sub_td64_nat(self, box_with_array, tz_naive_fixture)",
        "snippet": "    def test_dt64arr_add_sub_td64_nat(self, box_with_array, tz_naive_fixture):\n        # GH#23320 special handling for timedelta64(\"NaT\")\n        tz = tz_naive_fixture\n\n        dti = pd.date_range(\"1994-04-01\", periods=9, tz=tz, freq=\"QS\")\n        other = np.timedelta64(\"NaT\")\n        expected = pd.DatetimeIndex([\"NaT\"] * 9, tz=tz)\n\n        # FIXME: fails with transpose=True due to tz-aware DataFrame\n        #  transpose bug\n        obj = tm.box_expected(dti, box_with_array, transpose=False)\n        expected = tm.box_expected(expected, box_with_array, transpose=False)\n\n        result = obj + other\n        tm.assert_equal(result, expected)\n        result = other + obj\n        tm.assert_equal(result, expected)\n        result = obj - other\n        tm.assert_equal(result, expected)\n        msg = \"cannot subtract\"\n        with pytest.raises(TypeError, match=msg):\n            other - obj",
        "begin_line": 838,
        "end_line": 859,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_sub_td64ndarray#861",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_sub_td64ndarray(self, tz_naive_fixture, box_with_array)",
        "snippet": "    def test_dt64arr_add_sub_td64ndarray(self, tz_naive_fixture, box_with_array):\n\n        tz = tz_naive_fixture\n        dti = pd.date_range(\"2016-01-01\", periods=3, tz=tz)\n        tdi = pd.TimedeltaIndex([\"-1 Day\", \"-1 Day\", \"-1 Day\"])\n        tdarr = tdi.values\n\n        expected = pd.date_range(\"2015-12-31\", \"2016-01-02\", periods=3, tz=tz)\n\n        dtarr = tm.box_expected(dti, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = dtarr + tdarr\n        tm.assert_equal(result, expected)\n        result = tdarr + dtarr\n        tm.assert_equal(result, expected)\n\n        expected = pd.date_range(\"2016-01-02\", \"2016-01-04\", periods=3, tz=tz)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = dtarr - tdarr\n        tm.assert_equal(result, expected)\n        msg = \"cannot subtract|(bad|unsupported) operand type for unary\"\n        with pytest.raises(TypeError, match=msg):\n            tdarr - dtarr",
        "begin_line": 861,
        "end_line": 885,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_dtscalar#898",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_dtscalar(self, box_with_array, ts)",
        "snippet": "    def test_dt64arr_sub_dtscalar(self, box_with_array, ts):\n        # GH#8554, GH#22163 DataFrame op should _not_ return dt64 dtype\n        idx = pd.date_range(\"2013-01-01\", periods=3)._with_freq(None)\n        idx = tm.box_expected(idx, box_with_array)\n\n        expected = pd.TimedeltaIndex([\"0 Days\", \"1 Day\", \"2 Days\"])\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = idx - ts\n        tm.assert_equal(result, expected)",
        "begin_line": 898,
        "end_line": 907,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_datetime64_not_ns#909",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_datetime64_not_ns(self, box_with_array)",
        "snippet": "    def test_dt64arr_sub_datetime64_not_ns(self, box_with_array):\n        # GH#7996, GH#22163 ensure non-nano datetime64 is converted to nano\n        #  for DataFrame operation\n        dt64 = np.datetime64(\"2013-01-01\")\n        assert dt64.dtype == \"datetime64[D]\"\n\n        dti = pd.date_range(\"20130101\", periods=3)._with_freq(None)\n        dtarr = tm.box_expected(dti, box_with_array)\n\n        expected = pd.TimedeltaIndex([\"0 Days\", \"1 Day\", \"2 Days\"])\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = dtarr - dt64\n        tm.assert_equal(result, expected)\n\n        result = dt64 - dtarr\n        tm.assert_equal(result, -expected)",
        "begin_line": 909,
        "end_line": 925,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_timestamp#927",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_timestamp(self, box_with_array)",
        "snippet": "    def test_dt64arr_sub_timestamp(self, box_with_array):\n        ser = pd.date_range(\"2014-03-17\", periods=2, freq=\"D\", tz=\"US/Eastern\")\n        ser = ser._with_freq(None)\n        ts = ser[0]\n\n        ser = tm.box_expected(ser, box_with_array)\n\n        delta_series = pd.Series([np.timedelta64(0, \"D\"), np.timedelta64(1, \"D\")])\n        expected = tm.box_expected(delta_series, box_with_array)\n\n        tm.assert_equal(ser - ts, expected)\n        tm.assert_equal(ts - ser, -expected)",
        "begin_line": 927,
        "end_line": 938,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_NaT#940",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_NaT(self, box_with_array)",
        "snippet": "    def test_dt64arr_sub_NaT(self, box_with_array):\n        # GH#18808\n        dti = pd.DatetimeIndex([pd.NaT, pd.Timestamp(\"19900315\")])\n        ser = tm.box_expected(dti, box_with_array)\n\n        result = ser - pd.NaT\n        expected = pd.Series([pd.NaT, pd.NaT], dtype=\"timedelta64[ns]\")\n        expected = tm.box_expected(expected, box_with_array)\n        tm.assert_equal(result, expected)\n\n        dti_tz = dti.tz_localize(\"Asia/Tokyo\")\n        ser_tz = tm.box_expected(dti_tz, box_with_array)\n\n        result = ser_tz - pd.NaT\n        expected = pd.Series([pd.NaT, pd.NaT], dtype=\"timedelta64[ns]\")\n        expected = tm.box_expected(expected, box_with_array)\n        tm.assert_equal(result, expected)",
        "begin_line": 940,
        "end_line": 956,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_dt64object_array#961",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_sub_dt64object_array(self, box_with_array, tz_naive_fixture)",
        "snippet": "    def test_dt64arr_sub_dt64object_array(self, box_with_array, tz_naive_fixture):\n        dti = pd.date_range(\"2016-01-01\", periods=3, tz=tz_naive_fixture)\n        expected = dti - dti\n\n        obj = tm.box_expected(dti, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        warn = PerformanceWarning if box_with_array is not pd.DataFrame else None\n        with tm.assert_produces_warning(warn):\n            result = obj - obj.astype(object)\n        tm.assert_equal(result, expected)",
        "begin_line": 961,
        "end_line": 971,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_naive_sub_dt64ndarray#973",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_naive_sub_dt64ndarray(self, box_with_array)",
        "snippet": "    def test_dt64arr_naive_sub_dt64ndarray(self, box_with_array):\n        dti = pd.date_range(\"2016-01-01\", periods=3, tz=None)\n        dt64vals = dti.values\n\n        dtarr = tm.box_expected(dti, box_with_array)\n\n        expected = dtarr - dtarr\n        result = dtarr - dt64vals\n        tm.assert_equal(result, expected)\n        result = dt64vals - dtarr\n        tm.assert_equal(result, expected)",
        "begin_line": 973,
        "end_line": 983,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_aware_sub_dt64ndarray_raises#985",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_aware_sub_dt64ndarray_raises(self, tz_aware_fixture, box_with_array)",
        "snippet": "    def test_dt64arr_aware_sub_dt64ndarray_raises(\n        self, tz_aware_fixture, box_with_array\n    ):\n\n        tz = tz_aware_fixture\n        dti = pd.date_range(\"2016-01-01\", periods=3, tz=tz)\n        dt64vals = dti.values\n\n        dtarr = tm.box_expected(dti, box_with_array)\n        msg = \"subtraction must have the same timezones or\"\n        with pytest.raises(TypeError, match=msg):\n            dtarr - dt64vals\n        with pytest.raises(TypeError, match=msg):\n            dt64vals - dtarr",
        "begin_line": 985,
        "end_line": 998,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_dt64ndarray_raises#1003",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_dt64ndarray_raises(self, tz_naive_fixture, box_with_array)",
        "snippet": "    def test_dt64arr_add_dt64ndarray_raises(self, tz_naive_fixture, box_with_array):\n\n        tz = tz_naive_fixture\n        dti = pd.date_range(\"2016-01-01\", periods=3, tz=tz)\n        dt64vals = dti.values\n\n        dtarr = tm.box_expected(dti, box_with_array)\n        msg = \"cannot add\"\n        with pytest.raises(TypeError, match=msg):\n            dtarr + dt64vals\n        with pytest.raises(TypeError, match=msg):\n            dt64vals + dtarr",
        "begin_line": 1003,
        "end_line": 1014,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_timestamp_raises#1016",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_timestamp_raises(self, box_with_array)",
        "snippet": "    def test_dt64arr_add_timestamp_raises(self, box_with_array):\n        # GH#22163 ensure DataFrame doesn't cast Timestamp to i8\n        idx = DatetimeIndex([\"2011-01-01\", \"2011-01-02\"])\n        idx = tm.box_expected(idx, box_with_array)\n        msg = \"cannot add\"\n        with pytest.raises(TypeError, match=msg):\n            idx + Timestamp(\"2011-01-01\")\n        with pytest.raises(TypeError, match=msg):\n            Timestamp(\"2011-01-01\") + idx",
        "begin_line": 1016,
        "end_line": 1024,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_sub_invalid#1041",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_sub_invalid(self, dti_freq, other, box_with_array)",
        "snippet": "    def test_dt64arr_add_sub_invalid(self, dti_freq, other, box_with_array):\n        dti = DatetimeIndex([\"2011-01-01\", \"2011-01-02\"], freq=dti_freq)\n        dtarr = tm.box_expected(dti, box_with_array)\n        msg = \"|\".join(\n            [\n                \"unsupported operand type\",\n                \"cannot (add|subtract)\",\n                \"cannot use operands with types\",\n                \"ufunc '?(add|subtract)'? cannot use operands with types\",\n            ]\n        )\n        assert_invalid_addsub_type(dtarr, other, msg)",
        "begin_line": 1041,
        "end_line": 1052,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_sub_parr#1056",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_add_sub_parr(self, dti_freq, pi_freq, box_with_array, box_with_array2)",
        "snippet": "    def test_dt64arr_add_sub_parr(\n        self, dti_freq, pi_freq, box_with_array, box_with_array2\n    ):\n        # GH#20049 subtracting PeriodIndex should raise TypeError\n        dti = pd.DatetimeIndex([\"2011-01-01\", \"2011-01-02\"], freq=dti_freq)\n        pi = dti.to_period(pi_freq)\n\n        dtarr = tm.box_expected(dti, box_with_array)\n        parr = tm.box_expected(pi, box_with_array2)\n        msg = \"|\".join(\n            [\n                \"cannot (add|subtract)\",\n                \"unsupported operand\",\n                \"descriptor.*requires\",\n                \"ufunc.*cannot use operands\",\n            ]\n        )\n        assert_invalid_addsub_type(dtarr, parr, msg)",
        "begin_line": 1056,
        "end_line": 1073,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_addsub_time_objects_raises#1075",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64Arithmetic.test_dt64arr_addsub_time_objects_raises(self, box_with_array, tz_naive_fixture)",
        "snippet": "    def test_dt64arr_addsub_time_objects_raises(self, box_with_array, tz_naive_fixture):\n        # https://github.com/pandas-dev/pandas/issues/10329\n\n        tz = tz_naive_fixture\n\n        obj1 = pd.date_range(\"2012-01-01\", periods=3, tz=tz)\n        obj2 = [time(i, i, i) for i in range(3)]\n\n        obj1 = tm.box_expected(obj1, box_with_array)\n        obj2 = tm.box_expected(obj2, box_with_array)\n\n        with warnings.catch_warnings(record=True):\n            # pandas.errors.PerformanceWarning: Non-vectorized DateOffset being\n            # applied to Series or DatetimeIndex\n            # we aren't testing that here, so ignore.\n            warnings.simplefilter(\"ignore\", PerformanceWarning)\n\n            # If `x + y` raises, then `y + x` should raise here as well\n\n            msg = (\n                r\"unsupported operand type\\(s\\) for -: \"\n                \"'(Timestamp|DatetimeArray)' and 'datetime.time'\"\n            )\n            with pytest.raises(TypeError, match=msg):\n                obj1 - obj2\n\n            msg = \"|\".join(\n                [\n                    \"cannot subtract DatetimeArray from ndarray\",\n                    \"ufunc (subtract|'subtract') cannot use operands with types \"\n                    r\"dtype\\('O'\\) and dtype\\('<M8\\[ns\\]'\\)\",\n                ]\n            )\n            with pytest.raises(TypeError, match=msg):\n                obj2 - obj1\n\n            msg = (\n                r\"unsupported operand type\\(s\\) for \\+: \"\n                \"'(Timestamp|DatetimeArray)' and 'datetime.time'\"\n            )\n            with pytest.raises(TypeError, match=msg):\n                obj1 + obj2\n\n            msg = \"|\".join(\n                [\n                    r\"unsupported operand type\\(s\\) for \\+: \"\n                    \"'(Timestamp|DatetimeArray)' and 'datetime.time'\",\n                    \"ufunc (add|'add') cannot use operands with types \"\n                    r\"dtype\\('O'\\) and dtype\\('<M8\\[ns\\]'\\)\",\n                ]\n            )\n            with pytest.raises(TypeError, match=msg):\n                obj2 + obj1",
        "begin_line": 1075,
        "end_line": 1127,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_series_add_tick_DateOffset#1136",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_series_add_tick_DateOffset(self, box_with_array)",
        "snippet": "    def test_dt64arr_series_add_tick_DateOffset(self, box_with_array):\n        # GH#4532\n        # operate with pd.offsets\n        ser = Series([Timestamp(\"20130101 9:01\"), Timestamp(\"20130101 9:02\")])\n        expected = Series(\n            [Timestamp(\"20130101 9:01:05\"), Timestamp(\"20130101 9:02:05\")]\n        )\n\n        ser = tm.box_expected(ser, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = ser + pd.offsets.Second(5)\n        tm.assert_equal(result, expected)\n\n        result2 = pd.offsets.Second(5) + ser\n        tm.assert_equal(result2, expected)",
        "begin_line": 1136,
        "end_line": 1151,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_series_sub_tick_DateOffset#1153",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_series_sub_tick_DateOffset(self, box_with_array)",
        "snippet": "    def test_dt64arr_series_sub_tick_DateOffset(self, box_with_array):\n        # GH#4532\n        # operate with pd.offsets\n        ser = Series([Timestamp(\"20130101 9:01\"), Timestamp(\"20130101 9:02\")])\n        expected = Series(\n            [Timestamp(\"20130101 9:00:55\"), Timestamp(\"20130101 9:01:55\")]\n        )\n\n        ser = tm.box_expected(ser, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = ser - pd.offsets.Second(5)\n        tm.assert_equal(result, expected)\n\n        result2 = -pd.offsets.Second(5) + ser\n        tm.assert_equal(result2, expected)\n        msg = \"(bad|unsupported) operand type for unary\"\n        with pytest.raises(TypeError, match=msg):\n            pd.offsets.Second(5) - ser",
        "begin_line": 1153,
        "end_line": 1171,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_tick_DateOffset_smoke#1176",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_tick_DateOffset_smoke(self, cls_name, box_with_array)",
        "snippet": "    def test_dt64arr_add_sub_tick_DateOffset_smoke(self, cls_name, box_with_array):\n        # GH#4532\n        # smoke tests for valid DateOffsets\n        ser = Series([Timestamp(\"20130101 9:01\"), Timestamp(\"20130101 9:02\")])\n        ser = tm.box_expected(ser, box_with_array)\n\n        offset_cls = getattr(pd.offsets, cls_name)\n        ser + offset_cls(5)\n        offset_cls(5) + ser\n        ser - offset_cls(5)",
        "begin_line": 1176,
        "end_line": 1185,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dti_add_tick_tzaware#1187",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dti_add_tick_tzaware(self, tz_aware_fixture, box_with_array)",
        "snippet": "    def test_dti_add_tick_tzaware(self, tz_aware_fixture, box_with_array):\n        # GH#21610, GH#22163 ensure DataFrame doesn't return object-dtype\n        tz = tz_aware_fixture\n        if tz == \"US/Pacific\":\n            dates = date_range(\"2012-11-01\", periods=3, tz=tz)\n            offset = dates + pd.offsets.Hour(5)\n            assert dates[0] + pd.offsets.Hour(5) == offset[0]\n\n        dates = date_range(\"2010-11-01 00:00\", periods=3, tz=tz, freq=\"H\")\n        expected = DatetimeIndex(\n            [\"2010-11-01 05:00\", \"2010-11-01 06:00\", \"2010-11-01 07:00\"],\n            freq=\"H\",\n            tz=tz,\n        )\n\n        dates = tm.box_expected(dates, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        # TODO: parametrize over the scalar being added?  radd?  sub?\n        offset = dates + pd.offsets.Hour(5)\n        tm.assert_equal(offset, expected)\n        offset = dates + np.timedelta64(5, \"h\")\n        tm.assert_equal(offset, expected)\n        offset = dates + timedelta(hours=5)\n        tm.assert_equal(offset, expected)",
        "begin_line": 1187,
        "end_line": 1211,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_relativedelta_offsets#1216",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_relativedelta_offsets(self, box_with_array)",
        "snippet": "    def test_dt64arr_add_sub_relativedelta_offsets(self, box_with_array):\n        # GH#10699\n        vec = DatetimeIndex(\n            [\n                Timestamp(\"2000-01-05 00:15:00\"),\n                Timestamp(\"2000-01-31 00:23:00\"),\n                Timestamp(\"2000-01-01\"),\n                Timestamp(\"2000-03-31\"),\n                Timestamp(\"2000-02-29\"),\n                Timestamp(\"2000-12-31\"),\n                Timestamp(\"2000-05-15\"),\n                Timestamp(\"2001-06-15\"),\n            ]\n        )\n        vec = tm.box_expected(vec, box_with_array)\n        vec_items = vec.squeeze() if box_with_array is pd.DataFrame else vec\n\n        # DateOffset relativedelta fastpath\n        relative_kwargs = [\n            (\"years\", 2),\n            (\"months\", 5),\n            (\"days\", 3),\n            (\"hours\", 5),\n            (\"minutes\", 10),\n            (\"seconds\", 2),\n            (\"microseconds\", 5),\n        ]\n        for i, kwd in enumerate(relative_kwargs):\n            off = pd.DateOffset(**dict([kwd]))\n\n            expected = DatetimeIndex([x + off for x in vec_items])\n            expected = tm.box_expected(expected, box_with_array)\n            tm.assert_equal(expected, vec + off)\n\n            expected = DatetimeIndex([x - off for x in vec_items])\n            expected = tm.box_expected(expected, box_with_array)\n            tm.assert_equal(expected, vec - off)\n\n            off = pd.DateOffset(**dict(relative_kwargs[: i + 1]))\n\n            expected = DatetimeIndex([x + off for x in vec_items])\n            expected = tm.box_expected(expected, box_with_array)\n            tm.assert_equal(expected, vec + off)\n\n            expected = DatetimeIndex([x - off for x in vec_items])\n            expected = tm.box_expected(expected, box_with_array)\n            tm.assert_equal(expected, vec - off)\n            msg = \"(bad|unsupported) operand type for unary\"\n            with pytest.raises(TypeError, match=msg):\n                off - vec",
        "begin_line": 1216,
        "end_line": 1265,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_DateOffsets#1320",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_DateOffsets(self, box_with_array, n, normalize, cls_and_kwargs)",
        "snippet": "    def test_dt64arr_add_sub_DateOffsets(\n        self, box_with_array, n, normalize, cls_and_kwargs\n    ):\n        # GH#10699\n        # assert vectorized operation matches pointwise operations\n\n        if isinstance(cls_and_kwargs, tuple):\n            # If cls_name param is a tuple, then 2nd entry is kwargs for\n            # the offset constructor\n            cls_name, kwargs = cls_and_kwargs\n        else:\n            cls_name = cls_and_kwargs\n            kwargs = {}\n\n        if n == 0 and cls_name in [\n            \"WeekOfMonth\",\n            \"LastWeekOfMonth\",\n            \"FY5253Quarter\",\n            \"FY5253\",\n        ]:\n            # passing n = 0 is invalid for these offset classes\n            return\n\n        vec = DatetimeIndex(\n            [\n                Timestamp(\"2000-01-05 00:15:00\"),\n                Timestamp(\"2000-01-31 00:23:00\"),\n                Timestamp(\"2000-01-01\"),\n                Timestamp(\"2000-03-31\"),\n                Timestamp(\"2000-02-29\"),\n                Timestamp(\"2000-12-31\"),\n                Timestamp(\"2000-05-15\"),\n                Timestamp(\"2001-06-15\"),\n            ]\n        )\n        vec = tm.box_expected(vec, box_with_array)\n        vec_items = vec.squeeze() if box_with_array is pd.DataFrame else vec\n\n        offset_cls = getattr(pd.offsets, cls_name)\n\n        with warnings.catch_warnings(record=True):\n            # pandas.errors.PerformanceWarning: Non-vectorized DateOffset being\n            # applied to Series or DatetimeIndex\n            # we aren't testing that here, so ignore.\n            warnings.simplefilter(\"ignore\", PerformanceWarning)\n\n            offset = offset_cls(n, normalize=normalize, **kwargs)\n\n            expected = DatetimeIndex([x + offset for x in vec_items])\n            expected = tm.box_expected(expected, box_with_array)\n            tm.assert_equal(expected, vec + offset)\n\n            expected = DatetimeIndex([x - offset for x in vec_items])\n            expected = tm.box_expected(expected, box_with_array)\n            tm.assert_equal(expected, vec - offset)\n\n            expected = DatetimeIndex([offset + x for x in vec_items])\n            expected = tm.box_expected(expected, box_with_array)\n            tm.assert_equal(expected, offset + vec)\n            msg = \"(bad|unsupported) operand type for unary\"\n            with pytest.raises(TypeError, match=msg):\n                offset - vec",
        "begin_line": 1320,
        "end_line": 1381,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_DateOffset#1383",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_DateOffset(self, box_with_array)",
        "snippet": "    def test_dt64arr_add_sub_DateOffset(self, box_with_array):\n        # GH#10699\n        s = date_range(\"2000-01-01\", \"2000-01-31\", name=\"a\")\n        s = tm.box_expected(s, box_with_array)\n        result = s + pd.DateOffset(years=1)\n        result2 = pd.DateOffset(years=1) + s\n        exp = date_range(\"2001-01-01\", \"2001-01-31\", name=\"a\")._with_freq(None)\n        exp = tm.box_expected(exp, box_with_array)\n        tm.assert_equal(result, exp)\n        tm.assert_equal(result2, exp)\n\n        result = s - pd.DateOffset(years=1)\n        exp = date_range(\"1999-01-01\", \"1999-01-31\", name=\"a\")._with_freq(None)\n        exp = tm.box_expected(exp, box_with_array)\n        tm.assert_equal(result, exp)\n\n        s = DatetimeIndex(\n            [\n                Timestamp(\"2000-01-15 00:15:00\", tz=\"US/Central\"),\n                Timestamp(\"2000-02-15\", tz=\"US/Central\"),\n            ],\n            name=\"a\",\n        )\n        s = tm.box_expected(s, box_with_array)\n        result = s + pd.offsets.Day()\n        result2 = pd.offsets.Day() + s\n        exp = DatetimeIndex(\n            [\n                Timestamp(\"2000-01-16 00:15:00\", tz=\"US/Central\"),\n                Timestamp(\"2000-02-16\", tz=\"US/Central\"),\n            ],\n            name=\"a\",\n        )\n        exp = tm.box_expected(exp, box_with_array)\n        tm.assert_equal(result, exp)\n        tm.assert_equal(result2, exp)\n\n        s = DatetimeIndex(\n            [\n                Timestamp(\"2000-01-15 00:15:00\", tz=\"US/Central\"),\n                Timestamp(\"2000-02-15\", tz=\"US/Central\"),\n            ],\n            name=\"a\",\n        )\n        s = tm.box_expected(s, box_with_array)\n        result = s + pd.offsets.MonthEnd()\n        result2 = pd.offsets.MonthEnd() + s\n        exp = DatetimeIndex(\n            [\n                Timestamp(\"2000-01-31 00:15:00\", tz=\"US/Central\"),\n                Timestamp(\"2000-02-29\", tz=\"US/Central\"),\n            ],\n            name=\"a\",\n        )\n        exp = tm.box_expected(exp, box_with_array)\n        tm.assert_equal(result, exp)\n        tm.assert_equal(result2, exp)",
        "begin_line": 1383,
        "end_line": 1439,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_offset_array#1453",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dt64arr_add_sub_offset_array(self, tz_naive_fixture, box_with_array, box_other, op, other)",
        "snippet": "    def test_dt64arr_add_sub_offset_array(\n        self, tz_naive_fixture, box_with_array, box_other, op, other\n    ):\n        # GH#18849\n        # GH#10699 array of offsets\n\n        tz = tz_naive_fixture\n        dti = pd.date_range(\"2017-01-01\", periods=2, tz=tz)\n        dtarr = tm.box_expected(dti, box_with_array)\n\n        other = np.array([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)])\n        expected = DatetimeIndex([op(dti[n], other[n]) for n in range(len(dti))])\n        expected = tm.box_expected(expected, box_with_array)\n\n        if box_other:\n            other = tm.box_expected(other, box_with_array)\n\n        warn = PerformanceWarning\n        if box_with_array is pd.DataFrame and not (tz is None and not box_other):\n            warn = None\n        with tm.assert_produces_warning(warn):\n            res = op(dtarr, other)\n\n        tm.assert_equal(res, expected)",
        "begin_line": 1453,
        "end_line": 1476,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dti_add_sub_nonzero_mth_offset#1527",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64DateOffsetArithmetic.test_dti_add_sub_nonzero_mth_offset(self, op, offset, exp, exp_freq, tz_aware_fixture, box_with_array)",
        "snippet": "    def test_dti_add_sub_nonzero_mth_offset(\n        self, op, offset, exp, exp_freq, tz_aware_fixture, box_with_array\n    ):\n        # GH 26258\n        tz = tz_aware_fixture\n        date = date_range(start=\"01 Jan 2014\", end=\"01 Jan 2017\", freq=\"AS\", tz=tz)\n        date = tm.box_expected(date, box_with_array, False)\n        mth = getattr(date, op)\n        result = mth(offset)\n\n        expected = pd.DatetimeIndex(exp, tz=tz)\n        expected = tm.box_expected(expected, box_with_array, False)\n        tm.assert_equal(result, expected)",
        "begin_line": 1527,
        "end_line": 1539,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling.test_dt64_overflow_masking#1545",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling.test_dt64_overflow_masking(self, box_with_array)",
        "snippet": "    def test_dt64_overflow_masking(self, box_with_array):\n        # GH#25317\n        left = Series([Timestamp(\"1969-12-31\")])\n        right = Series([NaT])\n\n        left = tm.box_expected(left, box_with_array)\n        right = tm.box_expected(right, box_with_array)\n\n        expected = TimedeltaIndex([NaT])\n        expected = tm.box_expected(expected, box_with_array)\n\n        result = left - right\n        tm.assert_equal(result, expected)",
        "begin_line": 1545,
        "end_line": 1557,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling.test_dt64_series_arith_overflow#1559",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling.test_dt64_series_arith_overflow(self)",
        "snippet": "    def test_dt64_series_arith_overflow(self):\n        # GH#12534, fixed by GH#19024\n        dt = pd.Timestamp(\"1700-01-31\")\n        td = pd.Timedelta(\"20000 Days\")\n        dti = pd.date_range(\"1949-09-30\", freq=\"100Y\", periods=4)\n        ser = pd.Series(dti)\n        msg = \"Overflow in int64 addition\"\n        with pytest.raises(OverflowError, match=msg):\n            ser - dt\n        with pytest.raises(OverflowError, match=msg):\n            dt - ser\n        with pytest.raises(OverflowError, match=msg):\n            ser + td\n        with pytest.raises(OverflowError, match=msg):\n            td + ser\n\n        ser.iloc[-1] = pd.NaT\n        expected = pd.Series(\n            [\"2004-10-03\", \"2104-10-04\", \"2204-10-04\", \"NaT\"], dtype=\"datetime64[ns]\"\n        )\n        res = ser + td\n        tm.assert_series_equal(res, expected)\n        res = td + ser\n        tm.assert_series_equal(res, expected)\n\n        ser.iloc[1:] = pd.NaT\n        expected = pd.Series(\n            [\"91279 Days\", \"NaT\", \"NaT\", \"NaT\"], dtype=\"timedelta64[ns]\"\n        )\n        res = ser - dt\n        tm.assert_series_equal(res, expected)\n        res = dt - ser\n        tm.assert_series_equal(res, -expected)",
        "begin_line": 1559,
        "end_line": 1591,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling.test_datetimeindex_sub_timestamp_overflow#1593",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling.test_datetimeindex_sub_timestamp_overflow(self)",
        "snippet": "    def test_datetimeindex_sub_timestamp_overflow(self):\n        dtimax = pd.to_datetime([\"now\", pd.Timestamp.max])\n        dtimin = pd.to_datetime([\"now\", pd.Timestamp.min])\n\n        tsneg = Timestamp(\"1950-01-01\")\n        ts_neg_variants = [\n            tsneg,\n            tsneg.to_pydatetime(),\n            tsneg.to_datetime64().astype(\"datetime64[ns]\"),\n            tsneg.to_datetime64().astype(\"datetime64[D]\"),\n        ]\n\n        tspos = Timestamp(\"1980-01-01\")\n        ts_pos_variants = [\n            tspos,\n            tspos.to_pydatetime(),\n            tspos.to_datetime64().astype(\"datetime64[ns]\"),\n            tspos.to_datetime64().astype(\"datetime64[D]\"),\n        ]\n        msg = \"Overflow in int64 addition\"\n        for variant in ts_neg_variants:\n            with pytest.raises(OverflowError, match=msg):\n                dtimax - variant\n\n        expected = pd.Timestamp.max.value - tspos.value\n        for variant in ts_pos_variants:\n            res = dtimax - variant\n            assert res[1].value == expected\n\n        expected = pd.Timestamp.min.value - tsneg.value\n        for variant in ts_neg_variants:\n            res = dtimin - variant\n            assert res[1].value == expected\n\n        for variant in ts_pos_variants:\n            with pytest.raises(OverflowError, match=msg):\n                dtimin - variant",
        "begin_line": 1593,
        "end_line": 1629,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling.test_datetimeindex_sub_datetimeindex_overflow#1631",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetime64OverflowHandling.test_datetimeindex_sub_datetimeindex_overflow(self)",
        "snippet": "    def test_datetimeindex_sub_datetimeindex_overflow(self):\n        # GH#22492, GH#22508\n        dtimax = pd.to_datetime([\"now\", pd.Timestamp.max])\n        dtimin = pd.to_datetime([\"now\", pd.Timestamp.min])\n\n        ts_neg = pd.to_datetime([\"1950-01-01\", \"1950-01-01\"])\n        ts_pos = pd.to_datetime([\"1980-01-01\", \"1980-01-01\"])\n\n        # General tests\n        expected = pd.Timestamp.max.value - ts_pos[1].value\n        result = dtimax - ts_pos\n        assert result[1].value == expected\n\n        expected = pd.Timestamp.min.value - ts_neg[1].value\n        result = dtimin - ts_neg\n        assert result[1].value == expected\n        msg = \"Overflow in int64 addition\"\n        with pytest.raises(OverflowError, match=msg):\n            dtimax - ts_neg\n\n        with pytest.raises(OverflowError, match=msg):\n            dtimin - ts_pos\n\n        # Edge cases\n        tmin = pd.to_datetime([pd.Timestamp.min])\n        t1 = tmin + pd.Timedelta.max + pd.Timedelta(\"1us\")\n        with pytest.raises(OverflowError, match=msg):\n            t1 - tmin\n\n        tmax = pd.to_datetime([pd.Timestamp.max])\n        t2 = tmax + pd.Timedelta.min - pd.Timedelta(\"1us\")\n        with pytest.raises(OverflowError, match=msg):\n            tmax - t2",
        "begin_line": 1631,
        "end_line": 1663,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_empty_series_add_sub#1667",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_empty_series_add_sub(self)",
        "snippet": "    def test_empty_series_add_sub(self):\n        # GH#13844\n        a = Series(dtype=\"M8[ns]\")\n        b = Series(dtype=\"m8[ns]\")\n        tm.assert_series_equal(a, a + b)\n        tm.assert_series_equal(a, a - b)\n        tm.assert_series_equal(a, b + a)\n        msg = \"cannot subtract\"\n        with pytest.raises(TypeError, match=msg):\n            b - a",
        "begin_line": 1667,
        "end_line": 1676,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_operators_datetimelike#1678",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_operators_datetimelike(self)",
        "snippet": "    def test_operators_datetimelike(self):\n\n        # ## timedelta64 ###\n        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)\n        td1.iloc[2] = np.nan\n\n        # ## datetime64 ###\n        dt1 = Series(\n            [\n                pd.Timestamp(\"20111230\"),\n                pd.Timestamp(\"20120101\"),\n                pd.Timestamp(\"20120103\"),\n            ]\n        )\n        dt1.iloc[2] = np.nan\n        dt2 = Series(\n            [\n                pd.Timestamp(\"20111231\"),\n                pd.Timestamp(\"20120102\"),\n                pd.Timestamp(\"20120104\"),\n            ]\n        )\n        dt1 - dt2\n        dt2 - dt1\n\n        # datetime64 with timetimedelta\n        dt1 + td1\n        td1 + dt1\n        dt1 - td1\n\n        # timetimedelta with datetime64\n        td1 + dt1\n        dt1 + td1",
        "begin_line": 1678,
        "end_line": 1710,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64ser_sub_datetime_dtype#1712",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64ser_sub_datetime_dtype(self)",
        "snippet": "    def test_dt64ser_sub_datetime_dtype(self):\n        ts = Timestamp(datetime(1993, 1, 7, 13, 30, 00))\n        dt = datetime(1993, 6, 22, 13, 30)\n        ser = Series([ts])\n        result = pd.to_timedelta(np.abs(ser - dt))\n        assert result.dtype == \"timedelta64[ns]\"",
        "begin_line": 1712,
        "end_line": 1717,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_operators_datetimelike_invalid#1723",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_operators_datetimelike_invalid(self, all_arithmetic_operators)",
        "snippet": "    def test_operators_datetimelike_invalid(self, all_arithmetic_operators):\n        # these are all TypeEror ops\n        op_str = all_arithmetic_operators\n\n        def check(get_ser, test_ser):\n\n            # check that we are getting a TypeError\n            # with 'operate' (from core/ops.py) for the ops that are not\n            # defined\n            op = getattr(get_ser, op_str, None)\n            # Previously, _validate_for_numeric_binop in core/indexes/base.py\n            # did this for us.\n            with pytest.raises(\n                TypeError, match=\"operate|[cC]annot|unsupported operand\"\n            ):\n                op(test_ser)\n\n        # ## timedelta64 ###\n        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)\n        td1.iloc[2] = np.nan\n\n        # ## datetime64 ###\n        dt1 = Series(\n            [Timestamp(\"20111230\"), Timestamp(\"20120101\"), Timestamp(\"20120103\")]\n        )\n        dt1.iloc[2] = np.nan\n        dt2 = Series(\n            [Timestamp(\"20111231\"), Timestamp(\"20120102\"), Timestamp(\"20120104\")]\n        )\n        if op_str not in [\"__sub__\", \"__rsub__\"]:\n            check(dt1, dt2)\n\n        # ## datetime64 with timetimedelta ###\n        # TODO(jreback) __rsub__ should raise?\n        if op_str not in [\"__add__\", \"__radd__\", \"__sub__\"]:\n            check(dt1, td1)\n\n        # 8260, 10763\n        # datetime64 with tz\n        tz = \"US/Eastern\"\n        dt1 = Series(date_range(\"2000-01-01 09:00:00\", periods=5, tz=tz), name=\"foo\")\n        dt2 = dt1.copy()\n        dt2.iloc[2] = np.nan\n        td1 = Series(pd.timedelta_range(\"1 days 1 min\", periods=5, freq=\"H\"))\n        td2 = td1.copy()\n        td2.iloc[1] = np.nan\n\n        if op_str not in [\"__add__\", \"__radd__\", \"__sub__\", \"__rsub__\"]:\n            check(dt2, td2)",
        "begin_line": 1723,
        "end_line": 1771,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.check#1727",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.check(get_ser, test_ser)",
        "snippet": "        def check(get_ser, test_ser):\n\n            # check that we are getting a TypeError\n            # with 'operate' (from core/ops.py) for the ops that are not\n            # defined\n            op = getattr(get_ser, op_str, None)\n            # Previously, _validate_for_numeric_binop in core/indexes/base.py\n            # did this for us.\n            with pytest.raises(\n                TypeError, match=\"operate|[cC]annot|unsupported operand\"\n            ):\n                op(test_ser)",
        "begin_line": 1727,
        "end_line": 1738,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_sub_single_tz#1773",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_sub_single_tz(self)",
        "snippet": "    def test_sub_single_tz(self):\n        # GH#12290\n        s1 = Series([pd.Timestamp(\"2016-02-10\", tz=\"America/Sao_Paulo\")])\n        s2 = Series([pd.Timestamp(\"2016-02-08\", tz=\"America/Sao_Paulo\")])\n        result = s1 - s2\n        expected = Series([Timedelta(\"2days\")])\n        tm.assert_series_equal(result, expected)\n        result = s2 - s1\n        expected = Series([Timedelta(\"-2days\")])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1773,
        "end_line": 1782,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64tz_series_sub_dtitz#1784",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64tz_series_sub_dtitz(self)",
        "snippet": "    def test_dt64tz_series_sub_dtitz(self):\n        # GH#19071 subtracting tzaware DatetimeIndex from tzaware Series\n        # (with same tz) raises, fixed by #19024\n        dti = pd.date_range(\"1999-09-30\", periods=10, tz=\"US/Pacific\")\n        ser = pd.Series(dti)\n        expected = pd.Series(pd.TimedeltaIndex([\"0days\"] * 10))\n\n        res = dti - ser\n        tm.assert_series_equal(res, expected)\n        res = ser - dti\n        tm.assert_series_equal(res, expected)",
        "begin_line": 1784,
        "end_line": 1794,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_sub_datetime_compat#1796",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_sub_datetime_compat(self)",
        "snippet": "    def test_sub_datetime_compat(self):\n        # see GH#14088\n        s = Series([datetime(2016, 8, 23, 12, tzinfo=pytz.utc), pd.NaT])\n        dt = datetime(2016, 8, 22, 12, tzinfo=pytz.utc)\n        exp = Series([Timedelta(\"1 days\"), pd.NaT])\n        tm.assert_series_equal(s - dt, exp)\n        tm.assert_series_equal(s - Timestamp(dt), exp)",
        "begin_line": 1796,
        "end_line": 1802,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64_series_add_mixed_tick_DateOffset#1804",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64_series_add_mixed_tick_DateOffset(self)",
        "snippet": "    def test_dt64_series_add_mixed_tick_DateOffset(self):\n        # GH#4532\n        # operate with pd.offsets\n        s = Series([Timestamp(\"20130101 9:01\"), Timestamp(\"20130101 9:02\")])\n\n        result = s + pd.offsets.Milli(5)\n        result2 = pd.offsets.Milli(5) + s\n        expected = Series(\n            [Timestamp(\"20130101 9:01:00.005\"), Timestamp(\"20130101 9:02:00.005\")]\n        )\n        tm.assert_series_equal(result, expected)\n        tm.assert_series_equal(result2, expected)\n\n        result = s + pd.offsets.Minute(5) + pd.offsets.Milli(5)\n        expected = Series(\n            [Timestamp(\"20130101 9:06:00.005\"), Timestamp(\"20130101 9:07:00.005\")]\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1804,
        "end_line": 1821,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_datetime64_ops_nat#1823",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_datetime64_ops_nat(self)",
        "snippet": "    def test_datetime64_ops_nat(self):\n        # GH#11349\n        datetime_series = Series([NaT, Timestamp(\"19900315\")])\n        nat_series_dtype_timestamp = Series([NaT, NaT], dtype=\"datetime64[ns]\")\n        single_nat_dtype_datetime = Series([NaT], dtype=\"datetime64[ns]\")\n\n        # subtraction\n        tm.assert_series_equal(-NaT + datetime_series, nat_series_dtype_timestamp)\n        msg = \"Unary negative expects\"\n        with pytest.raises(TypeError, match=msg):\n            -single_nat_dtype_datetime + datetime_series\n\n        tm.assert_series_equal(\n            -NaT + nat_series_dtype_timestamp, nat_series_dtype_timestamp\n        )\n        with pytest.raises(TypeError, match=msg):\n            -single_nat_dtype_datetime + nat_series_dtype_timestamp\n\n        # addition\n        tm.assert_series_equal(\n            nat_series_dtype_timestamp + NaT, nat_series_dtype_timestamp\n        )\n        tm.assert_series_equal(\n            NaT + nat_series_dtype_timestamp, nat_series_dtype_timestamp\n        )\n\n        tm.assert_series_equal(\n            nat_series_dtype_timestamp + NaT, nat_series_dtype_timestamp\n        )\n        tm.assert_series_equal(\n            NaT + nat_series_dtype_timestamp, nat_series_dtype_timestamp\n        )",
        "begin_line": 1823,
        "end_line": 1854,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64_mul_div_numeric_invalid#1869",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64_mul_div_numeric_invalid(self, one, dt64_series)",
        "snippet": "    def test_dt64_mul_div_numeric_invalid(self, one, dt64_series):\n        # multiplication\n        msg = \"cannot perform .* with this index type\"\n        with pytest.raises(TypeError, match=msg):\n            dt64_series * one\n        with pytest.raises(TypeError, match=msg):\n            one * dt64_series\n\n        # division\n        with pytest.raises(TypeError, match=msg):\n            dt64_series / one\n        with pytest.raises(TypeError, match=msg):\n            one / dt64_series",
        "begin_line": 1869,
        "end_line": 1881,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64_series_add_intlike#1885",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_dt64_series_add_intlike(self, tz_naive_fixture, op)",
        "snippet": "    def test_dt64_series_add_intlike(self, tz_naive_fixture, op):\n        # GH#19123\n        tz = tz_naive_fixture\n        dti = pd.DatetimeIndex([\"2016-01-02\", \"2016-02-03\", \"NaT\"], tz=tz)\n        ser = Series(dti)\n\n        other = Series([20, 30, 40], dtype=\"uint8\")\n\n        method = getattr(ser, op)\n        msg = \"|\".join(\n            [\n                \"Addition/subtraction of integers and integer-arrays\",\n                \"cannot subtract .* from ndarray\",\n            ]\n        )\n        with pytest.raises(TypeError, match=msg):\n            method(1)\n        with pytest.raises(TypeError, match=msg):\n            method(other)\n        with pytest.raises(TypeError, match=msg):\n            method(np.array(other))\n        with pytest.raises(TypeError, match=msg):\n            method(pd.Index(other))",
        "begin_line": 1885,
        "end_line": 1907,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_operators_datetimelike_with_timezones#1912",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestTimestampSeriesArithmetic.test_operators_datetimelike_with_timezones(self)",
        "snippet": "    def test_operators_datetimelike_with_timezones(self):\n        tz = \"US/Eastern\"\n        dt1 = Series(date_range(\"2000-01-01 09:00:00\", periods=5, tz=tz), name=\"foo\")\n        dt2 = dt1.copy()\n        dt2.iloc[2] = np.nan\n\n        td1 = Series(pd.timedelta_range(\"1 days 1 min\", periods=5, freq=\"H\"))\n        td2 = td1.copy()\n        td2.iloc[1] = np.nan\n\n        result = dt1 + td1[0]\n        exp = (dt1.dt.tz_localize(None) + td1[0]).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n\n        result = dt2 + td2[0]\n        exp = (dt2.dt.tz_localize(None) + td2[0]).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n\n        # odd numpy behavior with scalar timedeltas\n        result = td1[0] + dt1\n        exp = (dt1.dt.tz_localize(None) + td1[0]).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n\n        result = td2[0] + dt2\n        exp = (dt2.dt.tz_localize(None) + td2[0]).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n\n        result = dt1 - td1[0]\n        exp = (dt1.dt.tz_localize(None) - td1[0]).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n        msg = \"(bad|unsupported) operand type for unary\"\n        with pytest.raises(TypeError, match=msg):\n            td1[0] - dt1\n\n        result = dt2 - td2[0]\n        exp = (dt2.dt.tz_localize(None) - td2[0]).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n        with pytest.raises(TypeError, match=msg):\n            td2[0] - dt2\n\n        result = dt1 + td1\n        exp = (dt1.dt.tz_localize(None) + td1).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n\n        result = dt2 + td2\n        exp = (dt2.dt.tz_localize(None) + td2).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n\n        result = dt1 - td1\n        exp = (dt1.dt.tz_localize(None) - td1).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n\n        result = dt2 - td2\n        exp = (dt2.dt.tz_localize(None) - td2).dt.tz_localize(tz)\n        tm.assert_series_equal(result, exp)\n        msg = \"cannot (add|subtract)\"\n        with pytest.raises(TypeError, match=msg):\n            td1 - dt1\n        with pytest.raises(TypeError, match=msg):\n            td2 - dt2",
        "begin_line": 1912,
        "end_line": 1971,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_addsub_int#1979",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_addsub_int(self, tz_naive_fixture, one)",
        "snippet": "    def test_dti_addsub_int(self, tz_naive_fixture, one):\n        # Variants of `one` for #19012\n        tz = tz_naive_fixture\n        rng = pd.date_range(\"2000-01-01 09:00\", freq=\"H\", periods=10, tz=tz)\n        msg = \"Addition/subtraction of integers\"\n\n        with pytest.raises(TypeError, match=msg):\n            rng + one\n        with pytest.raises(TypeError, match=msg):\n            rng += one\n        with pytest.raises(TypeError, match=msg):\n            rng - one\n        with pytest.raises(TypeError, match=msg):\n            rng -= one",
        "begin_line": 1979,
        "end_line": 1992,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_intarray_tick#1999",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_intarray_tick(self, int_holder, freq)",
        "snippet": "    def test_dti_add_intarray_tick(self, int_holder, freq):\n        # GH#19959\n        dti = pd.date_range(\"2016-01-01\", periods=2, freq=freq)\n        other = int_holder([4, -1])\n\n        msg = \"Addition/subtraction of integers|cannot subtract DatetimeArray from\"\n        assert_invalid_addsub_type(dti, other, msg)",
        "begin_line": 1999,
        "end_line": 2005,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_intarray_non_tick#2009",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_intarray_non_tick(self, int_holder, freq)",
        "snippet": "    def test_dti_add_intarray_non_tick(self, int_holder, freq):\n        # GH#19959\n        dti = pd.date_range(\"2016-01-01\", periods=2, freq=freq)\n        other = int_holder([4, -1])\n\n        msg = \"Addition/subtraction of integers|cannot subtract DatetimeArray from\"\n        assert_invalid_addsub_type(dti, other, msg)",
        "begin_line": 2009,
        "end_line": 2015,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_intarray_no_freq#2018",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_intarray_no_freq(self, int_holder)",
        "snippet": "    def test_dti_add_intarray_no_freq(self, int_holder):\n        # GH#19959\n        dti = pd.DatetimeIndex([\"2016-01-01\", \"NaT\", \"2017-04-05 06:07:08\"])\n        other = int_holder([9, 4, -1])\n        msg = \"|\".join(\n            [\"cannot subtract DatetimeArray from\", \"Addition/subtraction of integers\"]\n        )\n        assert_invalid_addsub_type(dti, other, msg)",
        "begin_line": 2018,
        "end_line": 2025,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_tdi#2030",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_tdi(self, tz_naive_fixture)",
        "snippet": "    def test_dti_add_tdi(self, tz_naive_fixture):\n        # GH#17558\n        tz = tz_naive_fixture\n        dti = DatetimeIndex([Timestamp(\"2017-01-01\", tz=tz)] * 10)\n        tdi = pd.timedelta_range(\"0 days\", periods=10)\n        expected = pd.date_range(\"2017-01-01\", periods=10, tz=tz)\n        expected = expected._with_freq(None)\n\n        # add with TimdeltaIndex\n        result = dti + tdi\n        tm.assert_index_equal(result, expected)\n\n        result = tdi + dti\n        tm.assert_index_equal(result, expected)\n\n        # add with timedelta64 array\n        result = dti + tdi.values\n        tm.assert_index_equal(result, expected)\n\n        result = tdi.values + dti\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2030,
        "end_line": 2050,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_iadd_tdi#2052",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_iadd_tdi(self, tz_naive_fixture)",
        "snippet": "    def test_dti_iadd_tdi(self, tz_naive_fixture):\n        # GH#17558\n        tz = tz_naive_fixture\n        dti = DatetimeIndex([Timestamp(\"2017-01-01\", tz=tz)] * 10)\n        tdi = pd.timedelta_range(\"0 days\", periods=10)\n        expected = pd.date_range(\"2017-01-01\", periods=10, tz=tz)\n        expected = expected._with_freq(None)\n\n        # iadd with TimdeltaIndex\n        result = DatetimeIndex([Timestamp(\"2017-01-01\", tz=tz)] * 10)\n        result += tdi\n        tm.assert_index_equal(result, expected)\n\n        result = pd.timedelta_range(\"0 days\", periods=10)\n        result += dti\n        tm.assert_index_equal(result, expected)\n\n        # iadd with timedelta64 array\n        result = DatetimeIndex([Timestamp(\"2017-01-01\", tz=tz)] * 10)\n        result += tdi.values\n        tm.assert_index_equal(result, expected)\n\n        result = pd.timedelta_range(\"0 days\", periods=10)\n        result += dti\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2052,
        "end_line": 2076,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_sub_tdi#2078",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_sub_tdi(self, tz_naive_fixture)",
        "snippet": "    def test_dti_sub_tdi(self, tz_naive_fixture):\n        # GH#17558\n        tz = tz_naive_fixture\n        dti = DatetimeIndex([Timestamp(\"2017-01-01\", tz=tz)] * 10)\n        tdi = pd.timedelta_range(\"0 days\", periods=10)\n        expected = pd.date_range(\"2017-01-01\", periods=10, tz=tz, freq=\"-1D\")\n        expected = expected._with_freq(None)\n\n        # sub with TimedeltaIndex\n        result = dti - tdi\n        tm.assert_index_equal(result, expected)\n\n        msg = \"cannot subtract .*TimedeltaArray\"\n        with pytest.raises(TypeError, match=msg):\n            tdi - dti\n\n        # sub with timedelta64 array\n        result = dti - tdi.values\n        tm.assert_index_equal(result, expected)\n\n        msg = \"cannot subtract DatetimeArray from\"\n        with pytest.raises(TypeError, match=msg):\n            tdi.values - dti",
        "begin_line": 2078,
        "end_line": 2100,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_isub_tdi#2102",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_isub_tdi(self, tz_naive_fixture)",
        "snippet": "    def test_dti_isub_tdi(self, tz_naive_fixture):\n        # GH#17558\n        tz = tz_naive_fixture\n        dti = DatetimeIndex([Timestamp(\"2017-01-01\", tz=tz)] * 10)\n        tdi = pd.timedelta_range(\"0 days\", periods=10)\n        expected = pd.date_range(\"2017-01-01\", periods=10, tz=tz, freq=\"-1D\")\n        expected = expected._with_freq(None)\n\n        # isub with TimedeltaIndex\n        result = DatetimeIndex([Timestamp(\"2017-01-01\", tz=tz)] * 10)\n        result -= tdi\n        tm.assert_index_equal(result, expected)\n\n        msg = \"cannot subtract .* from a TimedeltaArray\"\n        with pytest.raises(TypeError, match=msg):\n            tdi -= dti\n\n        # isub with timedelta64 array\n        result = DatetimeIndex([Timestamp(\"2017-01-01\", tz=tz)] * 10)\n        result -= tdi.values\n        tm.assert_index_equal(result, expected)\n\n        msg = \"|\".join(\n            [\n                \"cannot perform __neg__ with this index type:\",\n                \"ufunc subtract cannot use operands with types\",\n                \"cannot subtract DatetimeArray from\",\n            ]\n        )\n        with pytest.raises(TypeError, match=msg):\n            tdi.values -= dti",
        "begin_line": 2102,
        "end_line": 2132,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_add_datetimelike_and_dtarr#2151",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_add_datetimelike_and_dtarr(self, box_with_array, addend, tz)",
        "snippet": "    def test_add_datetimelike_and_dtarr(self, box_with_array, addend, tz):\n        # GH#9631\n        dti = DatetimeIndex([\"2011-01-01\", \"2011-01-02\"]).tz_localize(tz)\n        dtarr = tm.box_expected(dti, box_with_array)\n        msg = \"cannot add DatetimeArray and\"\n\n        with pytest.raises(TypeError, match=msg):\n            dtarr + addend\n        with pytest.raises(TypeError, match=msg):\n            addend + dtarr",
        "begin_line": 2151,
        "end_line": 2160,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dta_add_sub_index#2164",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dta_add_sub_index(self, tz_naive_fixture)",
        "snippet": "    def test_dta_add_sub_index(self, tz_naive_fixture):\n        # Check that DatetimeArray defers to Index classes\n        dti = date_range(\"20130101\", periods=3, tz=tz_naive_fixture)\n        dta = dti.array\n        result = dta - dti\n        expected = dti - dti\n        tm.assert_index_equal(result, expected)\n\n        tdi = result\n        result = dta + tdi\n        expected = dti + tdi\n        tm.assert_index_equal(result, expected)\n\n        result = dta - tdi\n        expected = dti - tdi\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2164,
        "end_line": 2179,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_sub_dti_dti#2181",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_sub_dti_dti(self)",
        "snippet": "    def test_sub_dti_dti(self):\n        # previously performed setop (deprecated in 0.16.0), now changed to\n        # return subtraction -> TimeDeltaIndex (GH ...)\n\n        dti = date_range(\"20130101\", periods=3)\n        dti_tz = date_range(\"20130101\", periods=3).tz_localize(\"US/Eastern\")\n        dti_tz2 = date_range(\"20130101\", periods=3).tz_localize(\"UTC\")\n        expected = TimedeltaIndex([0, 0, 0])\n\n        result = dti - dti\n        tm.assert_index_equal(result, expected)\n\n        result = dti_tz - dti_tz\n        tm.assert_index_equal(result, expected)\n        msg = \"DatetimeArray subtraction must have the same timezones or\"\n        with pytest.raises(TypeError, match=msg):\n            dti_tz - dti\n\n        with pytest.raises(TypeError, match=msg):\n            dti - dti_tz\n\n        with pytest.raises(TypeError, match=msg):\n            dti_tz - dti_tz2\n\n        # isub\n        dti -= dti\n        tm.assert_index_equal(dti, expected)\n\n        # different length raises ValueError\n        dti1 = date_range(\"20130101\", periods=3)\n        dti2 = date_range(\"20130101\", periods=4)\n        msg = \"cannot add indices of unequal length\"\n        with pytest.raises(ValueError, match=msg):\n            dti1 - dti2\n\n        # NaN propagation\n        dti1 = DatetimeIndex([\"2012-01-01\", np.nan, \"2012-01-03\"])\n        dti2 = DatetimeIndex([\"2012-01-02\", \"2012-01-03\", np.nan])\n        expected = TimedeltaIndex([\"1 days\", np.nan, np.nan])\n        result = dti2 - dti1\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2181,
        "end_line": 2221,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_timedelta64_equal_timedelta_supported_ops#2228",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_timedelta64_equal_timedelta_supported_ops(self, op)",
        "snippet": "    def test_timedelta64_equal_timedelta_supported_ops(self, op):\n        ser = Series(\n            [\n                Timestamp(\"20130301\"),\n                Timestamp(\"20130228 23:00:00\"),\n                Timestamp(\"20130228 22:00:00\"),\n                Timestamp(\"20130228 21:00:00\"),\n            ]\n        )\n\n        intervals = [\"D\", \"h\", \"m\", \"s\", \"us\"]\n\n        def timedelta64(*args):\n            # see casting notes in NumPy gh-12927\n            return np.sum(list(starmap(np.timedelta64, zip(args, intervals))))\n\n        for d, h, m, s, us in product(*([range(2)] * 5)):\n            nptd = timedelta64(d, h, m, s, us)\n            pytd = timedelta(days=d, hours=h, minutes=m, seconds=s, microseconds=us)\n            lhs = op(ser, nptd)\n            rhs = op(ser, pytd)\n\n            tm.assert_series_equal(lhs, rhs)",
        "begin_line": 2228,
        "end_line": 2250,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.timedelta64#2240",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.timedelta64(*args)",
        "snippet": "        def timedelta64(*args):\n            # see casting notes in NumPy gh-12927\n            return np.sum(list(starmap(np.timedelta64, zip(args, intervals))))",
        "begin_line": 2240,
        "end_line": 2242,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_ops_nat_mixed_datetime64_timedelta64#2252",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_ops_nat_mixed_datetime64_timedelta64(self)",
        "snippet": "    def test_ops_nat_mixed_datetime64_timedelta64(self):\n        # GH#11349\n        timedelta_series = Series([NaT, Timedelta(\"1s\")])\n        datetime_series = Series([NaT, Timestamp(\"19900315\")])\n        nat_series_dtype_timedelta = Series([NaT, NaT], dtype=\"timedelta64[ns]\")\n        nat_series_dtype_timestamp = Series([NaT, NaT], dtype=\"datetime64[ns]\")\n        single_nat_dtype_datetime = Series([NaT], dtype=\"datetime64[ns]\")\n        single_nat_dtype_timedelta = Series([NaT], dtype=\"timedelta64[ns]\")\n\n        # subtraction\n        tm.assert_series_equal(\n            datetime_series - single_nat_dtype_datetime, nat_series_dtype_timedelta\n        )\n\n        tm.assert_series_equal(\n            datetime_series - single_nat_dtype_timedelta, nat_series_dtype_timestamp\n        )\n        tm.assert_series_equal(\n            -single_nat_dtype_timedelta + datetime_series, nat_series_dtype_timestamp\n        )\n\n        # without a Series wrapping the NaT, it is ambiguous\n        # whether it is a datetime64 or timedelta64\n        # defaults to interpreting it as timedelta64\n        tm.assert_series_equal(\n            nat_series_dtype_timestamp - single_nat_dtype_datetime,\n            nat_series_dtype_timedelta,\n        )\n\n        tm.assert_series_equal(\n            nat_series_dtype_timestamp - single_nat_dtype_timedelta,\n            nat_series_dtype_timestamp,\n        )\n        tm.assert_series_equal(\n            -single_nat_dtype_timedelta + nat_series_dtype_timestamp,\n            nat_series_dtype_timestamp,\n        )\n        msg = \"cannot subtract a datelike\"\n        with pytest.raises(TypeError, match=msg):\n            timedelta_series - single_nat_dtype_datetime\n\n        # addition\n        tm.assert_series_equal(\n            nat_series_dtype_timestamp + single_nat_dtype_timedelta,\n            nat_series_dtype_timestamp,\n        )\n        tm.assert_series_equal(\n            single_nat_dtype_timedelta + nat_series_dtype_timestamp,\n            nat_series_dtype_timestamp,\n        )\n\n        tm.assert_series_equal(\n            nat_series_dtype_timestamp + single_nat_dtype_timedelta,\n            nat_series_dtype_timestamp,\n        )\n        tm.assert_series_equal(\n            single_nat_dtype_timedelta + nat_series_dtype_timestamp,\n            nat_series_dtype_timestamp,\n        )\n\n        tm.assert_series_equal(\n            nat_series_dtype_timedelta + single_nat_dtype_datetime,\n            nat_series_dtype_timestamp,\n        )\n        tm.assert_series_equal(\n            single_nat_dtype_datetime + nat_series_dtype_timedelta,\n            nat_series_dtype_timestamp,\n        )",
        "begin_line": 2252,
        "end_line": 2319,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_ufunc_coercions#2321",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_ufunc_coercions(self)",
        "snippet": "    def test_ufunc_coercions(self):\n        idx = date_range(\"2011-01-01\", periods=3, freq=\"2D\", name=\"x\")\n\n        delta = np.timedelta64(1, \"D\")\n        exp = date_range(\"2011-01-02\", periods=3, freq=\"2D\", name=\"x\")\n        for result in [idx + delta, np.add(idx, delta)]:\n            assert isinstance(result, DatetimeIndex)\n            tm.assert_index_equal(result, exp)\n            assert result.freq == \"2D\"\n\n        exp = date_range(\"2010-12-31\", periods=3, freq=\"2D\", name=\"x\")\n\n        for result in [idx - delta, np.subtract(idx, delta)]:\n            assert isinstance(result, DatetimeIndex)\n            tm.assert_index_equal(result, exp)\n            assert result.freq == \"2D\"\n\n        # When adding/subtracting an ndarray (which has no .freq), the result\n        #  does not infer freq\n        idx = idx._with_freq(None)\n        delta = np.array(\n            [np.timedelta64(1, \"D\"), np.timedelta64(2, \"D\"), np.timedelta64(3, \"D\")]\n        )\n        exp = DatetimeIndex([\"2011-01-02\", \"2011-01-05\", \"2011-01-08\"], name=\"x\")\n\n        for result in [idx + delta, np.add(idx, delta)]:\n            tm.assert_index_equal(result, exp)\n            assert result.freq == exp.freq\n\n        exp = DatetimeIndex([\"2010-12-31\", \"2011-01-01\", \"2011-01-02\"], name=\"x\")\n        for result in [idx - delta, np.subtract(idx, delta)]:\n            assert isinstance(result, DatetimeIndex)\n            tm.assert_index_equal(result, exp)\n            assert result.freq == exp.freq",
        "begin_line": 2321,
        "end_line": 2354,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_series#2356",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_add_series(self, tz_naive_fixture, names)",
        "snippet": "    def test_dti_add_series(self, tz_naive_fixture, names):\n        # GH#13905\n        tz = tz_naive_fixture\n        index = DatetimeIndex(\n            [\"2016-06-28 05:30\", \"2016-06-28 05:31\"], tz=tz, name=names[0]\n        )\n        ser = Series([Timedelta(seconds=5)] * 2, index=index, name=names[1])\n        expected = Series(index + Timedelta(seconds=5), index=index, name=names[2])\n\n        # passing name arg isn't enough when names[2] is None\n        expected.name = names[2]\n        assert expected.dtype == index.dtype\n        result = ser + index\n        tm.assert_series_equal(result, expected)\n        result2 = index + ser\n        tm.assert_series_equal(result2, expected)\n\n        expected = index + Timedelta(seconds=5)\n        result3 = ser.values + index\n        tm.assert_index_equal(result3, expected)\n        result4 = index + ser.values\n        tm.assert_index_equal(result4, expected)",
        "begin_line": 2356,
        "end_line": 2377,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_addsub_offset_arraylike#2380",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_addsub_offset_arraylike(self, tz_naive_fixture, names, op, index_or_series)",
        "snippet": "    def test_dti_addsub_offset_arraylike(\n        self, tz_naive_fixture, names, op, index_or_series\n    ):\n        # GH#18849, GH#19744\n        box = pd.Index\n        other_box = index_or_series\n\n        tz = tz_naive_fixture\n        dti = pd.date_range(\"2017-01-01\", periods=2, tz=tz, name=names[0])\n        other = other_box([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)], name=names[1])\n\n        xbox = get_upcast_box(box, other)\n\n        with tm.assert_produces_warning(PerformanceWarning):\n            res = op(dti, other)\n\n        expected = DatetimeIndex(\n            [op(dti[n], other[n]) for n in range(len(dti))], name=names[2], freq=\"infer\"\n        )\n        expected = tm.box_expected(expected, xbox)\n        tm.assert_equal(res, expected)",
        "begin_line": 2380,
        "end_line": 2400,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_addsub_object_arraylike#2403",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic",
        "signature": "pandas.tests.arithmetic.test_datetime64.TestDatetimeIndexArithmetic.test_dti_addsub_object_arraylike(self, tz_naive_fixture, box_with_array, other_box)",
        "snippet": "    def test_dti_addsub_object_arraylike(\n        self, tz_naive_fixture, box_with_array, other_box\n    ):\n        tz = tz_naive_fixture\n\n        dti = pd.date_range(\"2017-01-01\", periods=2, tz=tz)\n        dtarr = tm.box_expected(dti, box_with_array)\n        other = other_box([pd.offsets.MonthEnd(), pd.Timedelta(days=4)])\n        xbox = get_upcast_box(box_with_array, other)\n\n        expected = pd.DatetimeIndex([\"2017-01-31\", \"2017-01-06\"], tz=tz_naive_fixture)\n        expected = tm.box_expected(expected, xbox)\n\n        warn = PerformanceWarning\n        if box_with_array is pd.DataFrame and tz is not None:\n            warn = None\n\n        with tm.assert_produces_warning(warn):\n            result = dtarr + other\n        tm.assert_equal(result, expected)\n\n        expected = pd.DatetimeIndex([\"2016-12-31\", \"2016-12-29\"], tz=tz_naive_fixture)\n        expected = tm.box_expected(expected, xbox)\n\n        with tm.assert_produces_warning(warn):\n            result = dtarr - other\n        tm.assert_equal(result, expected)",
        "begin_line": 2403,
        "end_line": 2429,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.test_shift_months#2434",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64",
        "signature": "pandas.tests.arithmetic.test_datetime64.test_shift_months(years, months)",
        "snippet": "def test_shift_months(years, months):\n    dti = DatetimeIndex(\n        [\n            Timestamp(\"2000-01-05 00:15:00\"),\n            Timestamp(\"2000-01-31 00:23:00\"),\n            Timestamp(\"2000-01-01\"),\n            Timestamp(\"2000-02-29\"),\n            Timestamp(\"2000-12-31\"),\n        ]\n    )\n    actual = DatetimeIndex(shift_months(dti.asi8, years * 12 + months))\n\n    raw = [x + pd.offsets.DateOffset(years=years, months=months) for x in dti]\n    expected = DatetimeIndex(raw)\n    tm.assert_index_equal(actual, expected)",
        "begin_line": 2434,
        "end_line": 2448,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.test_datetime64.test_dt64arr_addsub_object_dtype_2d#2451",
        "src_path": "pandas/tests/arithmetic/test_datetime64.py",
        "class_name": "pandas.tests.arithmetic.test_datetime64",
        "signature": "pandas.tests.arithmetic.test_datetime64.test_dt64arr_addsub_object_dtype_2d()",
        "snippet": "def test_dt64arr_addsub_object_dtype_2d():\n    # block-wise DataFrame operations will require operating on 2D\n    #  DatetimeArray/TimedeltaArray, so check that specifically.\n    dti = pd.date_range(\"1994-02-13\", freq=\"2W\", periods=4)\n    dta = dti._data.reshape((4, 1))\n\n    other = np.array([[pd.offsets.Day(n)] for n in range(4)])\n    assert other.shape == dta.shape\n\n    with tm.assert_produces_warning(PerformanceWarning):\n        result = dta + other\n    with tm.assert_produces_warning(PerformanceWarning):\n        expected = (dta[:, 0] + other[:, 0]).reshape(-1, 1)\n\n    assert isinstance(result, DatetimeArray)\n    assert result.freq is None\n    tm.assert_numpy_array_equal(result._data, expected._data)\n\n    with tm.assert_produces_warning(PerformanceWarning):\n        # Case where we expect to get a TimedeltaArray back\n        result2 = dta - dta.astype(object)\n\n    assert isinstance(result2, TimedeltaArray)\n    assert result2.shape == (4, 1)\n    assert result2.freq is None\n    assert (result2.asi8 == 0).all()",
        "begin_line": 2451,
        "end_line": 2476,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.one#23",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.one(request)",
        "snippet": "def one(request):\n    \"\"\"\n    Several variants of integer value 1. The zero-dim integer array\n    behaves like an integer.\n\n    This fixture can be used to check that datetimelike indexes handle\n    addition and subtraction of integers and zero-dimensional arrays\n    of integers.\n\n    Examples\n    --------\n    >>> dti = pd.date_range('2016-01-01', periods=2, freq='H')\n    >>> dti\n    DatetimeIndex(['2016-01-01 00:00:00', '2016-01-01 01:00:00'],\n    dtype='datetime64[ns]', freq='H')\n    >>> dti + one\n    DatetimeIndex(['2016-01-01 01:00:00', '2016-01-01 02:00:00'],\n    dtype='datetime64[ns]', freq='H')\n    \"\"\"\n    return request.param",
        "begin_line": 23,
        "end_line": 42,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.zero#59",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.zero(request)",
        "snippet": "def zero(request):\n    \"\"\"\n    Several types of scalar zeros and length 5 vectors of zeros.\n\n    This fixture can be used to check that numeric-dtype indexes handle\n    division by any zero numeric-dtype.\n\n    Uses vector of length 5 for broadcasting with `numeric_idx` fixture,\n    which creates numeric-dtype vectors also of length 5.\n\n    Examples\n    --------\n    >>> arr = pd.RangeIndex(5)\n    >>> arr / zeros\n    Float64Index([nan, inf, inf, inf, inf], dtype='float64')\n    \"\"\"\n    return request.param",
        "begin_line": 59,
        "end_line": 75,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.numeric_idx#91",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.numeric_idx(request)",
        "snippet": "def numeric_idx(request):\n    \"\"\"\n    Several types of numeric-dtypes Index objects\n    \"\"\"\n    return request.param",
        "begin_line": 91,
        "end_line": 95,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.scalar_td#110",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.scalar_td(request)",
        "snippet": "def scalar_td(request):\n    \"\"\"\n    Several variants of Timedelta scalars representing 5 minutes and 4 seconds\n    \"\"\"\n    return request.param",
        "begin_line": 110,
        "end_line": 114,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.three_days#128",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.three_days(request)",
        "snippet": "def three_days(request):\n    \"\"\"\n    Several timedelta-like and DateOffset objects that each represent\n    a 3-day timedelta\n    \"\"\"\n    return request.param",
        "begin_line": 128,
        "end_line": 133,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.two_hours#147",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.two_hours(request)",
        "snippet": "def two_hours(request):\n    \"\"\"\n    Several timedelta-like and DateOffset objects that each represent\n    a 2-hour timedelta\n    \"\"\"\n    return request.param",
        "begin_line": 147,
        "end_line": 152,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.not_hourly#170",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.not_hourly(request)",
        "snippet": "def not_hourly(request):\n    \"\"\"\n    Several timedelta-like and DateOffset instances that are _not_\n    compatible with Hourly frequencies.\n    \"\"\"\n    return request.param",
        "begin_line": 170,
        "end_line": 175,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.not_daily#186",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.not_daily(request)",
        "snippet": "def not_daily(request):\n    \"\"\"\n    Several timedelta-like and DateOffset instances that are _not_\n    compatible with Daily frequencies.\n    \"\"\"\n    return request.param",
        "begin_line": 186,
        "end_line": 191,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.mismatched_freq#202",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.mismatched_freq(request)",
        "snippet": "def mismatched_freq(request):\n    \"\"\"\n    Several timedelta-like and DateOffset instances that are _not_\n    compatible with Monthly or Annual frequencies.\n    \"\"\"\n    return request.param",
        "begin_line": 202,
        "end_line": 207,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.box#214",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.box(request)",
        "snippet": "def box(request):\n    \"\"\"\n    Several array-like containers that should have effectively identical\n    behavior with respect to arithmetic operations.\n    \"\"\"\n    return request.param",
        "begin_line": 214,
        "end_line": 219,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.box_df_fail#231",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.box_df_fail(request)",
        "snippet": "def box_df_fail(request):\n    \"\"\"\n    Fixture equivalent to `box` fixture but xfailing the DataFrame case.\n    \"\"\"\n    return request.param",
        "begin_line": 231,
        "end_line": 235,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.conftest.box_with_array#239",
        "src_path": "pandas/tests/arithmetic/conftest.py",
        "class_name": "pandas.tests.arithmetic.conftest",
        "signature": "pandas.tests.arithmetic.conftest.box_with_array(request)",
        "snippet": "def box_with_array(request):\n    \"\"\"\n    Fixture to test behavior for Index, Series, DataFrame, and pandas Array\n    classes\n    \"\"\"\n    return request.param",
        "begin_line": 239,
        "end_line": 244,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.common.assert_invalid_addsub_type#11",
        "src_path": "pandas/tests/arithmetic/common.py",
        "class_name": "pandas.tests.arithmetic.common",
        "signature": "pandas.tests.arithmetic.common.assert_invalid_addsub_type(left, right, msg=None)",
        "snippet": "def assert_invalid_addsub_type(left, right, msg=None):\n    \"\"\"\n    Helper to assert that left and right can be neither added nor subtracted.\n\n    Parameters\n    ----------\n    left : object\n    right : object\n    msg : str or None, default None\n    \"\"\"\n    with pytest.raises(TypeError, match=msg):\n        left + right\n    with pytest.raises(TypeError, match=msg):\n        right + left\n    with pytest.raises(TypeError, match=msg):\n        left - right\n    with pytest.raises(TypeError, match=msg):\n        right - left",
        "begin_line": 11,
        "end_line": 28,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.common.get_upcast_box#31",
        "src_path": "pandas/tests/arithmetic/common.py",
        "class_name": "pandas.tests.arithmetic.common",
        "signature": "pandas.tests.arithmetic.common.get_upcast_box(box, vector)",
        "snippet": "def get_upcast_box(box, vector):\n    \"\"\"\n    Given two box-types, find the one that takes priority\n    \"\"\"\n    if box is DataFrame or isinstance(vector, DataFrame):\n        return DataFrame\n    if box is Series or isinstance(vector, Series):\n        return Series\n    if box is Index or isinstance(vector, Index):\n        return Index\n    return box",
        "begin_line": 31,
        "end_line": 41,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arithmetic.common.assert_invalid_comparison#44",
        "src_path": "pandas/tests/arithmetic/common.py",
        "class_name": "pandas.tests.arithmetic.common",
        "signature": "pandas.tests.arithmetic.common.assert_invalid_comparison(left, right, box)",
        "snippet": "def assert_invalid_comparison(left, right, box):\n    \"\"\"\n    Assert that comparison operations with mismatched types behave correctly.\n\n    Parameters\n    ----------\n    left : np.ndarray, ExtensionArray, Index, or Series\n    right : object\n    box : {pd.DataFrame, pd.Series, pd.Index, tm.to_array}\n    \"\"\"\n    # Not for tznaive-tzaware comparison\n\n    # Note: not quite the same as how we do this for tm.box_expected\n    xbox = box if box is not Index else np.array\n\n    result = left == right\n    expected = xbox(np.zeros(result.shape, dtype=np.bool_))\n\n    tm.assert_equal(result, expected)\n\n    result = right == left\n    tm.assert_equal(result, expected)\n\n    result = left != right\n    tm.assert_equal(result, ~expected)\n\n    result = right != left\n    tm.assert_equal(result, ~expected)\n\n    msg = \"Invalid comparison between|Cannot compare type|not supported between\"\n    with pytest.raises(TypeError, match=msg):\n        left < right\n    with pytest.raises(TypeError, match=msg):\n        left <= right\n    with pytest.raises(TypeError, match=msg):\n        left > right\n    with pytest.raises(TypeError, match=msg):\n        left >= right\n    with pytest.raises(TypeError, match=msg):\n        right < left\n    with pytest.raises(TypeError, match=msg):\n        right <= left\n    with pytest.raises(TypeError, match=msg):\n        right > left\n    with pytest.raises(TypeError, match=msg):\n        right >= left",
        "begin_line": 44,
        "end_line": 89,
        "comment": "",
        "is_bug": false
    }
]