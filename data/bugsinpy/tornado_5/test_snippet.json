[
    {
        "name": "tornado.test.ioloop_test.FakeTimeSelect.__init__#40",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.FakeTimeSelect",
        "signature": "tornado.test.ioloop_test.FakeTimeSelect.__init__(self)",
        "snippet": "    def __init__(self):\n        self._time = 1000\n        super(FakeTimeSelect, self).__init__()",
        "begin_line": 40,
        "end_line": 42,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.FakeTimeSelect.time#44",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.FakeTimeSelect",
        "signature": "tornado.test.ioloop_test.FakeTimeSelect.time(self)",
        "snippet": "    def time(self):\n        return self._time",
        "begin_line": 44,
        "end_line": 45,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.FakeTimeSelect.sleep#47",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.FakeTimeSelect",
        "signature": "tornado.test.ioloop_test.FakeTimeSelect.sleep(self, t)",
        "snippet": "    def sleep(self, t):\n        self._time += t",
        "begin_line": 47,
        "end_line": 48,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.FakeTimeSelect.poll#50",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.FakeTimeSelect",
        "signature": "tornado.test.ioloop_test.FakeTimeSelect.poll(self, timeout)",
        "snippet": "    def poll(self, timeout):\n        events = super(FakeTimeSelect, self).poll(0)\n        if events:\n            return events\n        self._time += timeout\n        return []",
        "begin_line": 50,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.FakeTimeIOLoop.initialize#65",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.FakeTimeIOLoop",
        "signature": "tornado.test.ioloop_test.FakeTimeIOLoop.initialize(self)",
        "snippet": "    def initialize(self):\n        self.fts = FakeTimeSelect()\n        super(FakeTimeIOLoop, self).initialize(impl=self.fts,\n                                               time_func=self.fts.time)",
        "begin_line": 65,
        "end_line": 68,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.FakeTimeIOLoop.sleep#70",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.FakeTimeIOLoop",
        "signature": "tornado.test.ioloop_test.FakeTimeIOLoop.sleep(self, t)",
        "snippet": "    def sleep(self, t):\n        \"\"\"Simulate a blocking sleep by advancing the clock.\"\"\"\n        self.fts.sleep(t)",
        "begin_line": 70,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_return_sequence#76",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_return_sequence(self)",
        "snippet": "    def test_add_callback_return_sequence(self):\n        # A callback returning {} or [] shouldn't spin the CPU, see Issue #1803.\n        self.calls = 0\n\n        loop = self.io_loop\n        test = self\n        old_add_callback = loop.add_callback\n\n        def add_callback(self, callback, *args, **kwargs):\n            test.calls += 1\n            old_add_callback(callback, *args, **kwargs)\n\n        loop.add_callback = types.MethodType(add_callback, loop)\n        loop.add_callback(lambda: {})\n        loop.add_callback(lambda: [])\n        loop.add_timeout(datetime.timedelta(milliseconds=50), loop.stop)\n        loop.start()\n        self.assertLess(self.calls, 10)",
        "begin_line": 76,
        "end_line": 93,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.add_callback#84",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.add_callback(self, callback, *args, **kwargs)",
        "snippet": "        def add_callback(self, callback, *args, **kwargs):\n            test.calls += 1\n            old_add_callback(callback, *args, **kwargs)",
        "begin_line": 84,
        "end_line": 86,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_wakeup#96",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_wakeup(self)",
        "snippet": "    def test_add_callback_wakeup(self):\n        # Make sure that add_callback from inside a running IOLoop\n        # wakes up the IOLoop immediately instead of waiting for a timeout.\n        def callback():\n            self.called = True\n            self.stop()\n\n        def schedule_callback():\n            self.called = False\n            self.io_loop.add_callback(callback)\n            # Store away the time so we can check if we woke up immediately\n            self.start_time = time.time()\n        self.io_loop.add_timeout(self.io_loop.time(), schedule_callback)\n        self.wait()\n        self.assertAlmostEqual(time.time(), self.start_time, places=2)\n        self.assertTrue(self.called)",
        "begin_line": 96,
        "end_line": 111,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.callback#99",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.callback()",
        "snippet": "        def callback():\n            self.called = True\n            self.stop()",
        "begin_line": 99,
        "end_line": 101,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.schedule_callback#103",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.schedule_callback()",
        "snippet": "        def schedule_callback():\n            self.called = False\n            self.io_loop.add_callback(callback)\n            # Store away the time so we can check if we woke up immediately\n            self.start_time = time.time()",
        "begin_line": 103,
        "end_line": 107,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_wakeup_other_thread#114",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_wakeup_other_thread(self)",
        "snippet": "    def test_add_callback_wakeup_other_thread(self):\n        def target():\n            # sleep a bit to let the ioloop go into its poll loop\n            time.sleep(0.01)\n            self.stop_time = time.time()\n            self.io_loop.add_callback(self.stop)\n        thread = threading.Thread(target=target)\n        self.io_loop.add_callback(thread.start)\n        self.wait()\n        delta = time.time() - self.stop_time\n        self.assertLess(delta, 0.1)\n        thread.join()",
        "begin_line": 114,
        "end_line": 125,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.target#115",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.target()",
        "snippet": "        def target():\n            # sleep a bit to let the ioloop go into its poll loop\n            time.sleep(0.01)\n            self.stop_time = time.time()\n            self.io_loop.add_callback(self.stop)",
        "begin_line": 115,
        "end_line": 119,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_timeout_timedelta#127",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_timeout_timedelta(self)",
        "snippet": "    def test_add_timeout_timedelta(self):\n        self.io_loop.add_timeout(datetime.timedelta(microseconds=1), self.stop)\n        self.wait()",
        "begin_line": 127,
        "end_line": 129,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_multiple_add#131",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_multiple_add(self)",
        "snippet": "    def test_multiple_add(self):\n        sock, port = bind_unused_port()\n        try:\n            self.io_loop.add_handler(sock.fileno(), lambda fd, events: None,\n                                     IOLoop.READ)\n            # Attempting to add the same handler twice fails\n            # (with a platform-dependent exception)\n            self.assertRaises(Exception, self.io_loop.add_handler,\n                              sock.fileno(), lambda fd, events: None,\n                              IOLoop.READ)\n        finally:\n            self.io_loop.remove_handler(sock.fileno())\n            sock.close()",
        "begin_line": 131,
        "end_line": 143,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_remove_without_add#145",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_remove_without_add(self)",
        "snippet": "    def test_remove_without_add(self):\n        # remove_handler should not throw an exception if called on an fd\n        # was never added.\n        sock, port = bind_unused_port()\n        try:\n            self.io_loop.remove_handler(sock.fileno())\n        finally:\n            sock.close()",
        "begin_line": 145,
        "end_line": 152,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_from_signal#154",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_from_signal(self)",
        "snippet": "    def test_add_callback_from_signal(self):\n        # cheat a little bit and just run this normally, since we can't\n        # easily simulate the races that happen with real signal handlers\n        self.io_loop.add_callback_from_signal(self.stop)\n        self.wait()",
        "begin_line": 154,
        "end_line": 158,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_from_signal_other_thread#160",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_from_signal_other_thread(self)",
        "snippet": "    def test_add_callback_from_signal_other_thread(self):\n        # Very crude test, just to make sure that we cover this case.\n        # This also happens to be the first test where we run an IOLoop in\n        # a non-main thread.\n        other_ioloop = IOLoop()\n        thread = threading.Thread(target=other_ioloop.start)\n        thread.start()\n        other_ioloop.add_callback_from_signal(other_ioloop.stop)\n        thread.join()\n        other_ioloop.close()",
        "begin_line": 160,
        "end_line": 169,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_while_closing#171",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_while_closing(self)",
        "snippet": "    def test_add_callback_while_closing(self):\n        # add_callback should not fail if it races with another thread\n        # closing the IOLoop. The callbacks are dropped silently\n        # without executing.\n        closing = threading.Event()\n\n        def target():\n            other_ioloop.add_callback(other_ioloop.stop)\n            other_ioloop.start()\n            closing.set()\n            other_ioloop.close(all_fds=True)\n        other_ioloop = IOLoop()\n        thread = threading.Thread(target=target)\n        thread.start()\n        closing.wait()\n        for i in range(1000):\n            other_ioloop.add_callback(lambda: None)",
        "begin_line": 171,
        "end_line": 187,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.target#177",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.target()",
        "snippet": "        def target():\n            other_ioloop.add_callback(other_ioloop.stop)\n            other_ioloop.start()\n            closing.set()\n            other_ioloop.close(all_fds=True)",
        "begin_line": 177,
        "end_line": 181,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_handle_callback_exception#189",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_handle_callback_exception(self)",
        "snippet": "    def test_handle_callback_exception(self):\n        # IOLoop.handle_callback_exception can be overridden to catch\n        # exceptions in callbacks.\n        def handle_callback_exception(callback):\n            self.assertIs(sys.exc_info()[0], ZeroDivisionError)\n            self.stop()\n        self.io_loop.handle_callback_exception = handle_callback_exception\n        with NullContext():\n            # remove the test StackContext that would see this uncaught\n            # exception as a test failure.\n            self.io_loop.add_callback(lambda: 1 / 0)\n        self.wait()",
        "begin_line": 189,
        "end_line": 200,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.handle_callback_exception#192",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.handle_callback_exception(callback)",
        "snippet": "        def handle_callback_exception(callback):\n            self.assertIs(sys.exc_info()[0], ZeroDivisionError)\n            self.stop()",
        "begin_line": 192,
        "end_line": 194,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_read_while_writeable#203",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_read_while_writeable(self)",
        "snippet": "    def test_read_while_writeable(self):\n        # Ensure that write events don't come in while we're waiting for\n        # a read and haven't asked for writeability. (the reverse is\n        # difficult to test for)\n        client, server = socket.socketpair()\n        try:\n            def handler(fd, events):\n                self.assertEqual(events, IOLoop.READ)\n                self.stop()\n            self.io_loop.add_handler(client.fileno(), handler, IOLoop.READ)\n            self.io_loop.add_timeout(self.io_loop.time() + 0.01,\n                                     functools.partial(server.send, b'asdf'))\n            self.wait()\n            self.io_loop.remove_handler(client.fileno())\n        finally:\n            client.close()\n            server.close()",
        "begin_line": 203,
        "end_line": 219,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.handler#209",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.handler(fd, events)",
        "snippet": "            def handler(fd, events):\n                self.assertEqual(events, IOLoop.READ)\n                self.stop()",
        "begin_line": 209,
        "end_line": 211,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_remove_timeout_after_fire#221",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_remove_timeout_after_fire(self)",
        "snippet": "    def test_remove_timeout_after_fire(self):\n        # It is not an error to call remove_timeout after it has run.\n        handle = self.io_loop.add_timeout(self.io_loop.time(), self.stop)\n        self.wait()\n        self.io_loop.remove_timeout(handle)",
        "begin_line": 221,
        "end_line": 225,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_remove_timeout_cleanup#227",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_remove_timeout_cleanup(self)",
        "snippet": "    def test_remove_timeout_cleanup(self):\n        # Add and remove enough callbacks to trigger cleanup.\n        # Not a very thorough test, but it ensures that the cleanup code\n        # gets executed and doesn't blow up.  This test is only really useful\n        # on PollIOLoop subclasses, but it should run silently on any\n        # implementation.\n        for i in range(2000):\n            timeout = self.io_loop.add_timeout(self.io_loop.time() + 3600,\n                                               lambda: None)\n            self.io_loop.remove_timeout(timeout)\n        # HACK: wait two IOLoop iterations for the GC to happen.\n        self.io_loop.add_callback(lambda: self.io_loop.add_callback(self.stop))\n        self.wait()",
        "begin_line": 227,
        "end_line": 239,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_remove_timeout_from_timeout#241",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_remove_timeout_from_timeout(self)",
        "snippet": "    def test_remove_timeout_from_timeout(self):\n        calls = [False, False]\n\n        # Schedule several callbacks and wait for them all to come due at once.\n        # t2 should be cancelled by t1, even though it is already scheduled to\n        # be run before the ioloop even looks at it.\n        now = self.io_loop.time()\n\n        def t1():\n            calls[0] = True\n            self.io_loop.remove_timeout(t2_handle)\n        self.io_loop.add_timeout(now + 0.01, t1)\n\n        def t2():\n            calls[1] = True\n        t2_handle = self.io_loop.add_timeout(now + 0.02, t2)\n        self.io_loop.add_timeout(now + 0.03, self.stop)\n        time.sleep(0.03)\n        self.wait()\n        self.assertEqual(calls, [True, False])",
        "begin_line": 241,
        "end_line": 260,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.t1#249",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.t1()",
        "snippet": "        def t1():\n            calls[0] = True\n            self.io_loop.remove_timeout(t2_handle)",
        "begin_line": 249,
        "end_line": 251,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.t2#254",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.t2()",
        "snippet": "        def t2():\n            calls[1] = True",
        "begin_line": 254,
        "end_line": 255,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_timeout_with_arguments#262",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_timeout_with_arguments(self)",
        "snippet": "    def test_timeout_with_arguments(self):\n        # This tests that all the timeout methods pass through *args correctly.\n        results = []\n        self.io_loop.add_timeout(self.io_loop.time(), results.append, 1)\n        self.io_loop.add_timeout(datetime.timedelta(seconds=0),\n                                 results.append, 2)\n        self.io_loop.call_at(self.io_loop.time(), results.append, 3)\n        self.io_loop.call_later(0, results.append, 4)\n        self.io_loop.call_later(0, self.stop)\n        self.wait()\n        # The asyncio event loop does not guarantee the order of these\n        # callbacks, but PollIOLoop does.\n        self.assertEqual(sorted(results), [1, 2, 3, 4])",
        "begin_line": 262,
        "end_line": 274,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_timeout_return#276",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_timeout_return(self)",
        "snippet": "    def test_add_timeout_return(self):\n        # All the timeout methods return non-None handles that can be\n        # passed to remove_timeout.\n        handle = self.io_loop.add_timeout(self.io_loop.time(), lambda: None)\n        self.assertFalse(handle is None)\n        self.io_loop.remove_timeout(handle)",
        "begin_line": 276,
        "end_line": 281,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_call_at_return#283",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_call_at_return(self)",
        "snippet": "    def test_call_at_return(self):\n        handle = self.io_loop.call_at(self.io_loop.time(), lambda: None)\n        self.assertFalse(handle is None)\n        self.io_loop.remove_timeout(handle)",
        "begin_line": 283,
        "end_line": 286,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_call_later_return#288",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_call_later_return(self)",
        "snippet": "    def test_call_later_return(self):\n        handle = self.io_loop.call_later(0, lambda: None)\n        self.assertFalse(handle is None)\n        self.io_loop.remove_timeout(handle)",
        "begin_line": 288,
        "end_line": 291,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_close_file_object#293",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_close_file_object(self)",
        "snippet": "    def test_close_file_object(self):\n        \"\"\"When a file object is used instead of a numeric file descriptor,\n        the object should be closed (by IOLoop.close(all_fds=True),\n        not just the fd.\n        \"\"\"\n        # Use a socket since they are supported by IOLoop on all platforms.\n        # Unfortunately, sockets don't support the .closed attribute for\n        # inspecting their close status, so we must use a wrapper.\n        class SocketWrapper(object):\n            def __init__(self, sockobj):\n                self.sockobj = sockobj\n                self.closed = False\n\n            def fileno(self):\n                return self.sockobj.fileno()\n\n            def close(self):\n                self.closed = True\n                self.sockobj.close()\n        sockobj, port = bind_unused_port()\n        socket_wrapper = SocketWrapper(sockobj)\n        io_loop = IOLoop()\n        io_loop.add_handler(socket_wrapper, lambda fd, events: None,\n                            IOLoop.READ)\n        io_loop.close(all_fds=True)\n        self.assertTrue(socket_wrapper.closed)",
        "begin_line": 293,
        "end_line": 318,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.SocketWrapper.test_close_file_object#293",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.SocketWrapper",
        "signature": "tornado.test.ioloop_test.SocketWrapper.test_close_file_object(self)",
        "snippet": "    def test_close_file_object(self):\n        \"\"\"When a file object is used instead of a numeric file descriptor,\n        the object should be closed (by IOLoop.close(all_fds=True),\n        not just the fd.\n        \"\"\"\n        # Use a socket since they are supported by IOLoop on all platforms.\n        # Unfortunately, sockets don't support the .closed attribute for\n        # inspecting their close status, so we must use a wrapper.\n        class SocketWrapper(object):\n            def __init__(self, sockobj):\n                self.sockobj = sockobj\n                self.closed = False\n\n            def fileno(self):\n                return self.sockobj.fileno()\n\n            def close(self):\n                self.closed = True\n                self.sockobj.close()\n        sockobj, port = bind_unused_port()\n        socket_wrapper = SocketWrapper(sockobj)\n        io_loop = IOLoop()\n        io_loop.add_handler(socket_wrapper, lambda fd, events: None,\n                            IOLoop.READ)\n        io_loop.close(all_fds=True)\n        self.assertTrue(socket_wrapper.closed)",
        "begin_line": 293,
        "end_line": 318,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.SocketWrapper.__init__#302",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.SocketWrapper",
        "signature": "tornado.test.ioloop_test.SocketWrapper.__init__(self, sockobj)",
        "snippet": "            def __init__(self, sockobj):\n                self.sockobj = sockobj\n                self.closed = False",
        "begin_line": 302,
        "end_line": 304,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.SocketWrapper.fileno#306",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.SocketWrapper",
        "signature": "tornado.test.ioloop_test.SocketWrapper.fileno(self)",
        "snippet": "            def fileno(self):\n                return self.sockobj.fileno()",
        "begin_line": 306,
        "end_line": 307,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.SocketWrapper.close#309",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.SocketWrapper",
        "signature": "tornado.test.ioloop_test.SocketWrapper.close(self)",
        "snippet": "            def close(self):\n                self.closed = True\n                self.sockobj.close()",
        "begin_line": 309,
        "end_line": 311,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_handler_callback_file_object#320",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_handler_callback_file_object(self)",
        "snippet": "    def test_handler_callback_file_object(self):\n        \"\"\"The handler callback receives the same fd object it passed in.\"\"\"\n        server_sock, port = bind_unused_port()\n        fds = []\n\n        def handle_connection(fd, events):\n            fds.append(fd)\n            conn, addr = server_sock.accept()\n            conn.close()\n            self.stop()\n        self.io_loop.add_handler(server_sock, handle_connection, IOLoop.READ)\n        with contextlib.closing(socket.socket()) as client_sock:\n            client_sock.connect(('127.0.0.1', port))\n            self.wait()\n        self.io_loop.remove_handler(server_sock)\n        self.io_loop.add_handler(server_sock.fileno(), handle_connection,\n                                 IOLoop.READ)\n        with contextlib.closing(socket.socket()) as client_sock:\n            client_sock.connect(('127.0.0.1', port))\n            self.wait()\n        self.assertIs(fds[0], server_sock)\n        self.assertEqual(fds[1], server_sock.fileno())\n        self.io_loop.remove_handler(server_sock.fileno())\n        server_sock.close()",
        "begin_line": 320,
        "end_line": 343,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.handle_connection#325",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.handle_connection(fd, events)",
        "snippet": "        def handle_connection(fd, events):\n            fds.append(fd)\n            conn, addr = server_sock.accept()\n            conn.close()\n            self.stop()",
        "begin_line": 325,
        "end_line": 329,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_mixed_fd_fileobj#345",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_mixed_fd_fileobj(self)",
        "snippet": "    def test_mixed_fd_fileobj(self):\n        server_sock, port = bind_unused_port()\n\n        def f(fd, events):\n            pass\n        self.io_loop.add_handler(server_sock, f, IOLoop.READ)\n        with self.assertRaises(Exception):\n            # The exact error is unspecified - some implementations use\n            # IOError, others use ValueError.\n            self.io_loop.add_handler(server_sock.fileno(), f, IOLoop.READ)\n        self.io_loop.remove_handler(server_sock.fileno())\n        server_sock.close()",
        "begin_line": 345,
        "end_line": 356,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.f#348",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.f(fd, events)",
        "snippet": "        def f(fd, events):\n            pass",
        "begin_line": 348,
        "end_line": 349,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_reentrant#358",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_reentrant(self)",
        "snippet": "    def test_reentrant(self):\n        \"\"\"Calling start() twice should raise an error, not deadlock.\"\"\"\n        returned_from_start = [False]\n        got_exception = [False]\n\n        def callback():\n            try:\n                self.io_loop.start()\n                returned_from_start[0] = True\n            except Exception:\n                got_exception[0] = True\n            self.stop()\n        self.io_loop.add_callback(callback)\n        self.wait()\n        self.assertTrue(got_exception[0])\n        self.assertFalse(returned_from_start[0])",
        "begin_line": 358,
        "end_line": 373,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.callback#363",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.callback()",
        "snippet": "        def callback():\n            try:\n                self.io_loop.start()\n                returned_from_start[0] = True\n            except Exception:\n                got_exception[0] = True\n            self.stop()",
        "begin_line": 363,
        "end_line": 369,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_exception_logging#375",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_exception_logging(self)",
        "snippet": "    def test_exception_logging(self):\n        \"\"\"Uncaught exceptions get logged by the IOLoop.\"\"\"\n        # Use a NullContext to keep the exception from being caught by\n        # AsyncTestCase.\n        with NullContext():\n            self.io_loop.add_callback(lambda: 1 / 0)\n            self.io_loop.add_callback(self.stop)\n            with ExpectLog(app_log, \"Exception in callback\"):\n                self.wait()",
        "begin_line": 375,
        "end_line": 383,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_exception_logging_future#385",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_exception_logging_future(self)",
        "snippet": "    def test_exception_logging_future(self):\n        \"\"\"The IOLoop examines exceptions from Futures and logs them.\"\"\"\n        with NullContext():\n            @gen.coroutine\n            def callback():\n                self.io_loop.add_callback(self.stop)\n                1 / 0\n            self.io_loop.add_callback(callback)\n            with ExpectLog(app_log, \"Exception in callback\"):\n                self.wait()",
        "begin_line": 385,
        "end_line": 394,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.callback#389",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.callback()",
        "snippet": "            def callback():\n                self.io_loop.add_callback(self.stop)\n                1 / 0",
        "begin_line": 389,
        "end_line": 391,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_exception_logging_native_coro#397",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_exception_logging_native_coro(self)",
        "snippet": "    def test_exception_logging_native_coro(self):\n        \"\"\"The IOLoop examines exceptions from awaitables and logs them.\"\"\"\n        namespace = exec_test(globals(), locals(), \"\"\"\n        async def callback():\n            # Stop the IOLoop two iterations after raising an exception\n            # to give the exception time to be logged.\n            self.io_loop.add_callback(self.io_loop.add_callback, self.stop)\n            1 / 0\n        \"\"\")\n        with NullContext():\n            self.io_loop.add_callback(namespace[\"callback\"])\n            with ExpectLog(app_log, \"Exception in callback\"):\n                self.wait()",
        "begin_line": 397,
        "end_line": 409,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_spawn_callback#411",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_spawn_callback(self)",
        "snippet": "    def test_spawn_callback(self):\n        # An added callback runs in the test's stack_context, so will be\n        # re-raised in wait().\n        self.io_loop.add_callback(lambda: 1 / 0)\n        with self.assertRaises(ZeroDivisionError):\n            self.wait()\n        # A spawned callback is run directly on the IOLoop, so it will be\n        # logged without stopping the test.\n        self.io_loop.spawn_callback(lambda: 1 / 0)\n        self.io_loop.add_callback(self.stop)\n        with ExpectLog(app_log, \"Exception in callback\"):\n            self.wait()",
        "begin_line": 411,
        "end_line": 422,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_remove_handler_from_handler#425",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_remove_handler_from_handler(self)",
        "snippet": "    def test_remove_handler_from_handler(self):\n        # Create two sockets with simultaneous read events.\n        client, server = socket.socketpair()\n        try:\n            client.send(b'abc')\n            server.send(b'abc')\n\n            # After reading from one fd, remove the other from the IOLoop.\n            chunks = []\n\n            def handle_read(fd, events):\n                chunks.append(fd.recv(1024))\n                if fd is client:\n                    self.io_loop.remove_handler(server)\n                else:\n                    self.io_loop.remove_handler(client)\n            self.io_loop.add_handler(client, handle_read, self.io_loop.READ)\n            self.io_loop.add_handler(server, handle_read, self.io_loop.READ)\n            self.io_loop.call_later(0.1, self.stop)\n            self.wait()\n\n            # Only one fd was read; the other was cleanly removed.\n            self.assertEqual(chunks, [b'abc'])\n        finally:\n            client.close()\n            server.close()",
        "begin_line": 425,
        "end_line": 450,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.handle_read#435",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.handle_read(fd, events)",
        "snippet": "            def handle_read(fd, events):\n                chunks.append(fd.recv(1024))\n                if fd is client:\n                    self.io_loop.remove_handler(server)\n                else:\n                    self.io_loop.remove_handler(client)",
        "begin_line": 435,
        "end_line": 440,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrent.setUp#456",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrent",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrent.setUp(self)",
        "snippet": "    def setUp(self):\n        self.io_loop = None\n        IOLoop.clear_current()",
        "begin_line": 456,
        "end_line": 458,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrent.tearDown#460",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrent",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrent.tearDown(self)",
        "snippet": "    def tearDown(self):\n        if self.io_loop is not None:\n            self.io_loop.close()",
        "begin_line": 460,
        "end_line": 462,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrent.test_default_current#464",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrent",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrent.test_default_current(self)",
        "snippet": "    def test_default_current(self):\n        self.io_loop = IOLoop()\n        # The first IOLoop with default arguments is made current.\n        self.assertIs(self.io_loop, IOLoop.current())\n        # A second IOLoop can be created but is not made current.\n        io_loop2 = IOLoop()\n        self.assertIs(self.io_loop, IOLoop.current())\n        io_loop2.close()",
        "begin_line": 464,
        "end_line": 471,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrent.test_non_current#473",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrent",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrent.test_non_current(self)",
        "snippet": "    def test_non_current(self):\n        self.io_loop = IOLoop(make_current=False)\n        # The new IOLoop is not initially made current.\n        self.assertIsNone(IOLoop.current(instance=False))\n        # Starting the IOLoop makes it current, and stopping the loop\n        # makes it non-current. This process is repeatable.\n        for i in range(3):\n            def f():\n                self.current_io_loop = IOLoop.current()\n                self.io_loop.stop()\n            self.io_loop.add_callback(f)\n            self.io_loop.start()\n            self.assertIs(self.current_io_loop, self.io_loop)\n            # Now that the loop is stopped, it is no longer current.\n            self.assertIsNone(IOLoop.current(instance=False))",
        "begin_line": 473,
        "end_line": 487,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrent.f#480",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrent",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrent.f()",
        "snippet": "            def f():\n                self.current_io_loop = IOLoop.current()\n                self.io_loop.stop()",
        "begin_line": 480,
        "end_line": 482,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrent.test_force_current#489",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrent",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrent.test_force_current(self)",
        "snippet": "    def test_force_current(self):\n        self.io_loop = IOLoop(make_current=True)\n        self.assertIs(self.io_loop, IOLoop.current())\n        with self.assertRaises(RuntimeError):\n            # A second make_current=True construction cannot succeed.\n            IOLoop(make_current=True)\n        # current() was not affected by the failed construction.\n        self.assertIs(self.io_loop, IOLoop.current())",
        "begin_line": 489,
        "end_line": 496,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrentAsync.test_clear_without_current#501",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrentAsync",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrentAsync.test_clear_without_current(self)",
        "snippet": "    def test_clear_without_current(self):\n        # If there is no current IOLoop, clear_current is a no-op (but\n        # should not fail). Use a thread so we see the threading.Local\n        # in a pristine state.\n        with ThreadPoolExecutor(1) as e:\n            yield e.submit(IOLoop.clear_current)",
        "begin_line": 501,
        "end_line": 506,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.setUp#510",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.setUp(self)",
        "snippet": "    def setUp(self):\n        super(TestIOLoopAddCallback, self).setUp()\n        self.active_contexts = []",
        "begin_line": 510,
        "end_line": 512,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.add_callback#514",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.add_callback(self, callback, *args, **kwargs)",
        "snippet": "    def add_callback(self, callback, *args, **kwargs):\n        self.io_loop.add_callback(callback, *args, **kwargs)",
        "begin_line": 514,
        "end_line": 515,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.context#518",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.context(self, name)",
        "snippet": "    def context(self, name):\n        self.active_contexts.append(name)\n        yield\n        self.assertEqual(self.active_contexts.pop(), name)",
        "begin_line": 518,
        "end_line": 521,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.test_pre_wrap#523",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.test_pre_wrap(self)",
        "snippet": "    def test_pre_wrap(self):\n        # A pre-wrapped callback is run in the context in which it was\n        # wrapped, not when it was added to the IOLoop.\n        def f1():\n            self.assertIn('c1', self.active_contexts)\n            self.assertNotIn('c2', self.active_contexts)\n            self.stop()\n\n        with StackContext(functools.partial(self.context, 'c1')):\n            wrapped = wrap(f1)\n\n        with StackContext(functools.partial(self.context, 'c2')):\n            self.add_callback(wrapped)\n\n        self.wait()",
        "begin_line": 523,
        "end_line": 537,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.f1#526",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.f1()",
        "snippet": "        def f1():\n            self.assertIn('c1', self.active_contexts)\n            self.assertNotIn('c2', self.active_contexts)\n            self.stop()",
        "begin_line": 526,
        "end_line": 529,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.test_pre_wrap_with_args#539",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.test_pre_wrap_with_args(self)",
        "snippet": "    def test_pre_wrap_with_args(self):\n        # Same as test_pre_wrap, but the function takes arguments.\n        # Implementation note: The function must not be wrapped in a\n        # functools.partial until after it has been passed through\n        # stack_context.wrap\n        def f1(foo, bar):\n            self.assertIn('c1', self.active_contexts)\n            self.assertNotIn('c2', self.active_contexts)\n            self.stop((foo, bar))\n\n        with StackContext(functools.partial(self.context, 'c1')):\n            wrapped = wrap(f1)\n\n        with StackContext(functools.partial(self.context, 'c2')):\n            self.add_callback(wrapped, 1, bar=2)\n\n        result = self.wait()\n        self.assertEqual(result, (1, 2))",
        "begin_line": 539,
        "end_line": 556,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.f1#544",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.f1(foo, bar)",
        "snippet": "        def f1(foo, bar):\n            self.assertIn('c1', self.active_contexts)\n            self.assertNotIn('c2', self.active_contexts)\n            self.stop((foo, bar))",
        "begin_line": 544,
        "end_line": 547,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallbackFromSignal.add_callback#561",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallbackFromSignal",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallbackFromSignal.add_callback(self, callback, *args, **kwargs)",
        "snippet": "    def add_callback(self, callback, *args, **kwargs):\n        self.io_loop.add_callback_from_signal(callback, *args, **kwargs)",
        "begin_line": 561,
        "end_line": 562,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.test_add_future_threads#567",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.test_add_future_threads(self)",
        "snippet": "    def test_add_future_threads(self):\n        with futures.ThreadPoolExecutor(1) as pool:\n            self.io_loop.add_future(pool.submit(lambda: None),\n                                    lambda future: self.stop(future))\n            future = self.wait()\n            self.assertTrue(future.done())\n            self.assertTrue(future.result() is None)",
        "begin_line": 567,
        "end_line": 573,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.test_add_future_stack_context#575",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.test_add_future_stack_context(self)",
        "snippet": "    def test_add_future_stack_context(self):\n        ready = threading.Event()\n\n        def task():\n            # we must wait for the ioloop callback to be scheduled before\n            # the task completes to ensure that add_future adds the callback\n            # asynchronously (which is the scenario in which capturing\n            # the stack_context matters)\n            ready.wait(1)\n            assert ready.isSet(), \"timed out\"\n            raise Exception(\"worker\")\n\n        def callback(future):\n            self.future = future\n            raise Exception(\"callback\")\n\n        def handle_exception(typ, value, traceback):\n            self.exception = value\n            self.stop()\n            return True\n\n        # stack_context propagates to the ioloop callback, but the worker\n        # task just has its exceptions caught and saved in the Future.\n        with futures.ThreadPoolExecutor(1) as pool:\n            with ExceptionStackContext(handle_exception):\n                self.io_loop.add_future(pool.submit(task), callback)\n            ready.set()\n        self.wait()\n\n        self.assertEqual(self.exception.args[0], \"callback\")\n        self.assertEqual(self.future.exception().args[0], \"worker\")",
        "begin_line": 575,
        "end_line": 605,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.task#578",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.task()",
        "snippet": "        def task():\n            # we must wait for the ioloop callback to be scheduled before\n            # the task completes to ensure that add_future adds the callback\n            # asynchronously (which is the scenario in which capturing\n            # the stack_context matters)\n            ready.wait(1)\n            assert ready.isSet(), \"timed out\"\n            raise Exception(\"worker\")",
        "begin_line": 578,
        "end_line": 585,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.callback#587",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.callback(future)",
        "snippet": "        def callback(future):\n            self.future = future\n            raise Exception(\"callback\")",
        "begin_line": 587,
        "end_line": 589,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.handle_exception#591",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.handle_exception(typ, value, traceback)",
        "snippet": "        def handle_exception(typ, value, traceback):\n            self.exception = value\n            self.stop()\n            return True",
        "begin_line": 591,
        "end_line": 594,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.test_run_in_executor_gen#608",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.test_run_in_executor_gen(self)",
        "snippet": "    def test_run_in_executor_gen(self):\n        event1 = threading.Event()\n        event2 = threading.Event()\n\n        def sync_func(self_event, other_event):\n            self_event.set()\n            other_event.wait()\n            # Note that return value doesn't actually do anything,\n            # it is just passed through to our final assertion to\n            # make sure it is passed through properly.\n            return self_event\n\n        # Run two synchronous functions, which would deadlock if not\n        # run in parallel.\n        res = yield [\n            IOLoop.current().run_in_executor(None, sync_func, event1, event2),\n            IOLoop.current().run_in_executor(None, sync_func, event2, event1)\n        ]\n\n        self.assertEqual([event1, event2], res)",
        "begin_line": 608,
        "end_line": 627,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.sync_func#612",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.sync_func(self_event, other_event)",
        "snippet": "        def sync_func(self_event, other_event):\n            self_event.set()\n            other_event.wait()\n            # Note that return value doesn't actually do anything,\n            # it is just passed through to our final assertion to\n            # make sure it is passed through properly.\n            return self_event",
        "begin_line": 612,
        "end_line": 618,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.test_run_in_executor_native#631",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.test_run_in_executor_native(self)",
        "snippet": "    def test_run_in_executor_native(self):\n        event1 = threading.Event()\n        event2 = threading.Event()\n\n        def sync_func(self_event, other_event):\n            self_event.set()\n            other_event.wait()\n            return self_event\n\n        # Go through an async wrapper to ensure that the result of\n        # run_in_executor works with await and not just gen.coroutine\n        # (simply passing the underlying concurrrent future would do that).\n        namespace = exec_test(globals(), locals(), \"\"\"\n            async def async_wrapper(self_event, other_event):\n                return await IOLoop.current().run_in_executor(\n                    None, sync_func, self_event, other_event)\n        \"\"\")\n\n        res = yield [\n            namespace[\"async_wrapper\"](event1, event2),\n            namespace[\"async_wrapper\"](event2, event1)\n        ]\n\n        self.assertEqual([event1, event2], res)",
        "begin_line": 631,
        "end_line": 654,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.sync_func#635",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.sync_func(self_event, other_event)",
        "snippet": "        def sync_func(self_event, other_event):\n            self_event.set()\n            other_event.wait()\n            return self_event",
        "begin_line": 635,
        "end_line": 638,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.test_set_default_executor#657",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.test_set_default_executor(self)",
        "snippet": "    def test_set_default_executor(self):\n        count = [0]\n\n        class MyExecutor(futures.ThreadPoolExecutor):\n            def submit(self, func, *args):\n                count[0] += 1\n                return super(MyExecutor, self).submit(func, *args)\n\n        event = threading.Event()\n\n        def sync_func():\n            event.set()\n\n        executor = MyExecutor(1)\n        loop = IOLoop.current()\n        loop.set_default_executor(executor)\n        yield loop.run_in_executor(None, sync_func)\n        self.assertEqual(1, count[0])\n        self.assertTrue(event.is_set())",
        "begin_line": 657,
        "end_line": 675,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.MyExecutor.test_set_default_executor#657",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.MyExecutor",
        "signature": "tornado.test.ioloop_test.MyExecutor.test_set_default_executor(self)",
        "snippet": "    def test_set_default_executor(self):\n        count = [0]\n\n        class MyExecutor(futures.ThreadPoolExecutor):\n            def submit(self, func, *args):\n                count[0] += 1\n                return super(MyExecutor, self).submit(func, *args)\n\n        event = threading.Event()\n\n        def sync_func():\n            event.set()\n\n        executor = MyExecutor(1)\n        loop = IOLoop.current()\n        loop.set_default_executor(executor)\n        yield loop.run_in_executor(None, sync_func)\n        self.assertEqual(1, count[0])\n        self.assertTrue(event.is_set())",
        "begin_line": 657,
        "end_line": 675,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.MyExecutor.submit#661",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.MyExecutor",
        "signature": "tornado.test.ioloop_test.MyExecutor.submit(self, func, *args)",
        "snippet": "            def submit(self, func, *args):\n                count[0] += 1\n                return super(MyExecutor, self).submit(func, *args)",
        "begin_line": 661,
        "end_line": 663,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.sync_func#667",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.sync_func()",
        "snippet": "        def sync_func():\n            event.set()",
        "begin_line": 667,
        "end_line": 668,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.setUp#679",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.setUp(self)",
        "snippet": "    def setUp(self):\n        self.io_loop = IOLoop()",
        "begin_line": 679,
        "end_line": 680,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.tearDown#682",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.tearDown(self)",
        "snippet": "    def tearDown(self):\n        self.io_loop.close()",
        "begin_line": 682,
        "end_line": 683,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_sync_result#685",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_sync_result(self)",
        "snippet": "    def test_sync_result(self):\n        with self.assertRaises(gen.BadYieldError):\n            self.io_loop.run_sync(lambda: 42)",
        "begin_line": 685,
        "end_line": 687,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_sync_exception#689",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_sync_exception(self)",
        "snippet": "    def test_sync_exception(self):\n        with self.assertRaises(ZeroDivisionError):\n            self.io_loop.run_sync(lambda: 1 / 0)",
        "begin_line": 689,
        "end_line": 691,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_async_result#693",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_async_result(self)",
        "snippet": "    def test_async_result(self):\n        @gen.coroutine\n        def f():\n            yield gen.moment\n            raise gen.Return(42)\n        self.assertEqual(self.io_loop.run_sync(f), 42)",
        "begin_line": 693,
        "end_line": 698,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.f#695",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.f()",
        "snippet": "        def f():\n            yield gen.moment\n            raise gen.Return(42)",
        "begin_line": 695,
        "end_line": 697,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_async_exception#700",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_async_exception(self)",
        "snippet": "    def test_async_exception(self):\n        @gen.coroutine\n        def f():\n            yield gen.moment\n            1 / 0\n        with self.assertRaises(ZeroDivisionError):\n            self.io_loop.run_sync(f)",
        "begin_line": 700,
        "end_line": 706,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.f#702",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.f()",
        "snippet": "        def f():\n            yield gen.moment\n            1 / 0",
        "begin_line": 702,
        "end_line": 704,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_current#708",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_current(self)",
        "snippet": "    def test_current(self):\n        def f():\n            self.assertIs(IOLoop.current(), self.io_loop)\n        self.io_loop.run_sync(f)",
        "begin_line": 708,
        "end_line": 711,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.f#709",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.f()",
        "snippet": "        def f():\n            self.assertIs(IOLoop.current(), self.io_loop)",
        "begin_line": 709,
        "end_line": 710,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_timeout#713",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_timeout(self)",
        "snippet": "    def test_timeout(self):\n        @gen.coroutine\n        def f():\n            yield gen.sleep(1)\n        self.assertRaises(TimeoutError, self.io_loop.run_sync, f, timeout=0.01)",
        "begin_line": 713,
        "end_line": 717,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.f#715",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.f()",
        "snippet": "        def f():\n            yield gen.sleep(1)",
        "begin_line": 715,
        "end_line": 716,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_native_coroutine#720",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_native_coroutine(self)",
        "snippet": "    def test_native_coroutine(self):\n        @gen.coroutine\n        def f1():\n            yield gen.moment\n\n        namespace = exec_test(globals(), locals(), \"\"\"\n        async def f2():\n            await f1()\n        \"\"\")\n        self.io_loop.run_sync(namespace['f2'])",
        "begin_line": 720,
        "end_line": 729,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.f1#722",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.f1()",
        "snippet": "        def f1():\n            yield gen.moment",
        "begin_line": 722,
        "end_line": 723,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.setUp#735",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.setUp(self)",
        "snippet": "    def setUp(self):\n        self.io_loop = FakeTimeIOLoop()\n        self.io_loop.make_current()",
        "begin_line": 735,
        "end_line": 737,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.tearDown#739",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.tearDown(self)",
        "snippet": "    def tearDown(self):\n        self.io_loop.close()",
        "begin_line": 739,
        "end_line": 740,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.test_basic#742",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.test_basic(self)",
        "snippet": "    def test_basic(self):\n        calls = []\n\n        def cb():\n            calls.append(self.io_loop.time())\n        pc = PeriodicCallback(cb, 10000)\n        pc.start()\n        self.io_loop.call_later(50, self.io_loop.stop)\n        self.io_loop.start()\n        self.assertEqual(calls, [1010, 1020, 1030, 1040, 1050])",
        "begin_line": 742,
        "end_line": 751,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.cb#745",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.cb()",
        "snippet": "        def cb():\n            calls.append(self.io_loop.time())",
        "begin_line": 745,
        "end_line": 746,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.test_overrun#753",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.test_overrun(self)",
        "snippet": "    def test_overrun(self):\n        sleep_durations = [9, 9, 10, 11, 20, 20, 35, 35, 0, 0]\n        expected = [\n            1010, 1020, 1030,  # first 3 calls on schedule\n            1050, 1070,  # next 2 delayed one cycle\n            1100, 1130,  # next 2 delayed 2 cycles\n            1170, 1210,  # next 2 delayed 3 cycles\n            1220, 1230,  # then back on schedule.\n        ]\n        calls = []\n\n        def cb():\n            calls.append(self.io_loop.time())\n            if not sleep_durations:\n                self.io_loop.stop()\n                return\n            self.io_loop.sleep(sleep_durations.pop(0))\n        pc = PeriodicCallback(cb, 10000)\n        pc.start()\n        self.io_loop.start()\n        self.assertEqual(calls, expected)",
        "begin_line": 753,
        "end_line": 773,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.cb#764",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.cb()",
        "snippet": "        def cb():\n            calls.append(self.io_loop.time())\n            if not sleep_durations:\n                self.io_loop.stop()\n                return\n            self.io_loop.sleep(sleep_durations.pop(0))",
        "begin_line": 764,
        "end_line": 769,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.test_io_loop_set_at_start#775",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.test_io_loop_set_at_start(self)",
        "snippet": "    def test_io_loop_set_at_start(self):\n        # Check PeriodicCallback uses the current IOLoop at start() time,\n        # not at instantiation time.\n        calls = []\n        io_loop = FakeTimeIOLoop()\n\n        def cb():\n            calls.append(io_loop.time())\n        pc = PeriodicCallback(cb, 10000)\n        io_loop.make_current()\n        pc.start()\n        io_loop.call_later(50, io_loop.stop)\n        io_loop.start()\n        self.assertEqual(calls, [1010, 1020, 1030, 1040, 1050])\n        io_loop.close()",
        "begin_line": 775,
        "end_line": 789,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.cb#781",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.cb()",
        "snippet": "        def cb():\n            calls.append(io_loop.time())",
        "begin_line": 781,
        "end_line": 782,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallbackMath.simulate_calls#793",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallbackMath",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallbackMath.simulate_calls(self, pc, durations)",
        "snippet": "    def simulate_calls(self, pc, durations):\n        \"\"\"Simulate a series of calls to the PeriodicCallback.\n\n        Pass a list of call durations in seconds (negative values\n        work to simulate clock adjustments during the call, or more or\n        less equivalently, between calls). This method returns the\n        times at which each call would be made.\n        \"\"\"\n        calls = []\n        now = 1000\n        pc._next_timeout = now\n        for d in durations:\n            pc._update_next(now)\n            calls.append(pc._next_timeout)\n            now = pc._next_timeout + d\n        return calls",
        "begin_line": 793,
        "end_line": 808,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallbackMath.test_basic#810",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallbackMath",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallbackMath.test_basic(self)",
        "snippet": "    def test_basic(self):\n        pc = PeriodicCallback(None, 10000)\n        self.assertEqual(self.simulate_calls(pc, [0] * 5),\n                         [1010, 1020, 1030, 1040, 1050])",
        "begin_line": 810,
        "end_line": 813,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallbackMath.test_overrun#815",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallbackMath",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallbackMath.test_overrun(self)",
        "snippet": "    def test_overrun(self):\n        # If a call runs for too long, we skip entire cycles to get\n        # back on schedule.\n        call_durations = [9, 9, 10, 11, 20, 20, 35, 35, 0, 0, 0]\n        expected = [\n            1010, 1020, 1030,  # first 3 calls on schedule\n            1050, 1070,  # next 2 delayed one cycle\n            1100, 1130,  # next 2 delayed 2 cycles\n            1170, 1210,  # next 2 delayed 3 cycles\n            1220, 1230,  # then back on schedule.\n        ]\n\n        pc = PeriodicCallback(None, 10000)\n        self.assertEqual(self.simulate_calls(pc, call_durations),\n                         expected)",
        "begin_line": 815,
        "end_line": 829,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallbackMath.test_clock_backwards#831",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallbackMath",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallbackMath.test_clock_backwards(self)",
        "snippet": "    def test_clock_backwards(self):\n        pc = PeriodicCallback(None, 10000)\n        # Backwards jumps are ignored, potentially resulting in a\n        # slightly slow schedule (although we assume that when\n        # time.time() and time.monotonic() are different, time.time()\n        # is getting adjusted by NTP and is therefore more accurate)\n        self.assertEqual(self.simulate_calls(pc, [-2, -1, -3, -2, 0]),\n                         [1010, 1020, 1030, 1040, 1050])\n\n        # For big jumps, we should perhaps alter the schedule, but we\n        # don't currently. This trace shows that we run callbacks\n        # every 10s of time.time(), but the first and second calls are\n        # 110s of real time apart because the backwards jump is\n        # ignored.\n        self.assertEqual(self.simulate_calls(pc, [-100, 0, 0]),\n                         [1010, 1020, 1030])",
        "begin_line": 831,
        "end_line": 846,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopConfiguration.run_python#849",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopConfiguration",
        "signature": "tornado.test.ioloop_test.TestIOLoopConfiguration.run_python(self, *statements)",
        "snippet": "    def run_python(self, *statements):\n        statements = [\n            'from tornado.ioloop import IOLoop, PollIOLoop',\n            'classname = lambda x: x.__class__.__name__',\n        ] + list(statements)\n        args = [sys.executable, '-c', '; '.join(statements)]\n        return native_str(subprocess.check_output(args)).strip()",
        "begin_line": 849,
        "end_line": 855,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_default#857",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopConfiguration",
        "signature": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_default(self)",
        "snippet": "    def test_default(self):\n        if asyncio is not None:\n            # When asyncio is available, it is used by default.\n            cls = self.run_python('print(classname(IOLoop.current()))')\n            self.assertEqual(cls, 'AsyncIOMainLoop')\n            cls = self.run_python('print(classname(IOLoop()))')\n            self.assertEqual(cls, 'AsyncIOLoop')\n        else:\n            # Otherwise, the default is a subclass of PollIOLoop\n            is_poll = self.run_python(\n                'print(isinstance(IOLoop.current(), PollIOLoop))')\n            self.assertEqual(is_poll, 'True')",
        "begin_line": 857,
        "end_line": 868,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_explicit_select#872",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopConfiguration",
        "signature": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_explicit_select(self)",
        "snippet": "    def test_explicit_select(self):\n        # SelectIOLoop can always be configured explicitly.\n        default_class = self.run_python(\n            'IOLoop.configure(\"tornado.platform.select.SelectIOLoop\")',\n            'print(classname(IOLoop.current()))')\n        self.assertEqual(default_class, 'SelectIOLoop')",
        "begin_line": 872,
        "end_line": 877,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_asyncio#880",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopConfiguration",
        "signature": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_asyncio(self)",
        "snippet": "    def test_asyncio(self):\n        cls = self.run_python(\n            'IOLoop.configure(\"tornado.platform.asyncio.AsyncIOLoop\")',\n            'print(classname(IOLoop.current()))')\n        self.assertEqual(cls, 'AsyncIOMainLoop')",
        "begin_line": 880,
        "end_line": 884,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_asyncio_main#887",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopConfiguration",
        "signature": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_asyncio_main(self)",
        "snippet": "    def test_asyncio_main(self):\n        cls = self.run_python(\n            'from tornado.platform.asyncio import AsyncIOMainLoop',\n            'AsyncIOMainLoop().install()',\n            'print(classname(IOLoop.current()))')\n        self.assertEqual(cls, 'AsyncIOMainLoop')",
        "begin_line": 887,
        "end_line": 892,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_twisted#897",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopConfiguration",
        "signature": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_twisted(self)",
        "snippet": "    def test_twisted(self):\n        cls = self.run_python(\n            'from tornado.platform.twisted import TwistedIOLoop',\n            'TwistedIOLoop().install()',\n            'print(classname(IOLoop.current()))')\n        self.assertEqual(cls, 'TwistedIOLoop')",
        "begin_line": 897,
        "end_line": 902,
        "comment": "",
        "is_bug": false
    }
]