[
    {
        "name": "pandas.tests.reshape.test_concat.sort#37",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat",
        "signature": "pandas.tests.reshape.test_concat.sort(request)",
        "snippet": "def sort(request):\n    \"\"\"Boolean sort keyword for concat and DataFrame.append.\"\"\"\n    return request.param",
        "begin_line": 37,
        "end_line": 39,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.setup_method#47",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n\n        dt_data = [\n            pd.Timestamp(\"2011-01-01\"),\n            pd.Timestamp(\"2011-01-02\"),\n            pd.Timestamp(\"2011-01-03\"),\n        ]\n        tz_data = [\n            pd.Timestamp(\"2011-01-01\", tz=\"US/Eastern\"),\n            pd.Timestamp(\"2011-01-02\", tz=\"US/Eastern\"),\n            pd.Timestamp(\"2011-01-03\", tz=\"US/Eastern\"),\n        ]\n\n        td_data = [\n            pd.Timedelta(\"1 days\"),\n            pd.Timedelta(\"2 days\"),\n            pd.Timedelta(\"3 days\"),\n        ]\n\n        period_data = [\n            pd.Period(\"2011-01\", freq=\"M\"),\n            pd.Period(\"2011-02\", freq=\"M\"),\n            pd.Period(\"2011-03\", freq=\"M\"),\n        ]\n\n        self.data = {\n            \"bool\": [True, False, True],\n            \"int64\": [1, 2, 3],\n            \"float64\": [1.1, np.nan, 3.3],\n            \"category\": pd.Categorical([\"X\", \"Y\", \"Z\"]),\n            \"object\": [\"a\", \"b\", \"c\"],\n            \"datetime64[ns]\": dt_data,\n            \"datetime64[ns, US/Eastern]\": tz_data,\n            \"timedelta64[ns]\": td_data,\n            \"period[M]\": period_data,\n        }",
        "begin_line": 47,
        "end_line": 82,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon._check_expected_dtype#84",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon._check_expected_dtype(self, obj, label)",
        "snippet": "    def _check_expected_dtype(self, obj, label):\n        \"\"\"\n        Check whether obj has expected dtype depending on label\n        considering not-supported dtypes\n        \"\"\"\n        if isinstance(obj, pd.Index):\n            if label == \"bool\":\n                assert obj.dtype == \"object\"\n            else:\n                assert obj.dtype == label\n        elif isinstance(obj, pd.Series):\n            if label.startswith(\"period\"):\n                assert obj.dtype == \"Period[M]\"\n            else:\n                assert obj.dtype == label\n        else:\n            raise ValueError",
        "begin_line": 84,
        "end_line": 100,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_dtypes#102",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_dtypes(self)",
        "snippet": "    def test_dtypes(self):\n        # to confirm test case covers intended dtypes\n        for typ, vals in self.data.items():\n            self._check_expected_dtype(pd.Index(vals), typ)\n            self._check_expected_dtype(pd.Series(vals), typ)",
        "begin_line": 102,
        "end_line": 106,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concatlike_same_dtypes#108",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concatlike_same_dtypes(self)",
        "snippet": "    def test_concatlike_same_dtypes(self):\n        # GH 13660\n        for typ1, vals1 in self.data.items():\n\n            vals2 = vals1\n            vals3 = vals1\n\n            if typ1 == \"category\":\n                exp_data = pd.Categorical(list(vals1) + list(vals2))\n                exp_data3 = pd.Categorical(list(vals1) + list(vals2) + list(vals3))\n            else:\n                exp_data = vals1 + vals2\n                exp_data3 = vals1 + vals2 + vals3\n\n            # ----- Index ----- #\n\n            # index.append\n            res = pd.Index(vals1).append(pd.Index(vals2))\n            exp = pd.Index(exp_data)\n            tm.assert_index_equal(res, exp)\n\n            # 3 elements\n            res = pd.Index(vals1).append([pd.Index(vals2), pd.Index(vals3)])\n            exp = pd.Index(exp_data3)\n            tm.assert_index_equal(res, exp)\n\n            # index.append name mismatch\n            i1 = pd.Index(vals1, name=\"x\")\n            i2 = pd.Index(vals2, name=\"y\")\n            res = i1.append(i2)\n            exp = pd.Index(exp_data)\n            tm.assert_index_equal(res, exp)\n\n            # index.append name match\n            i1 = pd.Index(vals1, name=\"x\")\n            i2 = pd.Index(vals2, name=\"x\")\n            res = i1.append(i2)\n            exp = pd.Index(exp_data, name=\"x\")\n            tm.assert_index_equal(res, exp)\n\n            # cannot append non-index\n            with pytest.raises(TypeError, match=\"all inputs must be Index\"):\n                pd.Index(vals1).append(vals2)\n\n            with pytest.raises(TypeError, match=\"all inputs must be Index\"):\n                pd.Index(vals1).append([pd.Index(vals2), vals3])\n\n            # ----- Series ----- #\n\n            # series.append\n            res = pd.Series(vals1).append(pd.Series(vals2), ignore_index=True)\n            exp = pd.Series(exp_data)\n            tm.assert_series_equal(res, exp, check_index_type=True)\n\n            # concat\n            res = pd.concat([pd.Series(vals1), pd.Series(vals2)], ignore_index=True)\n            tm.assert_series_equal(res, exp, check_index_type=True)\n\n            # 3 elements\n            res = pd.Series(vals1).append(\n                [pd.Series(vals2), pd.Series(vals3)], ignore_index=True\n            )\n            exp = pd.Series(exp_data3)\n            tm.assert_series_equal(res, exp)\n\n            res = pd.concat(\n                [pd.Series(vals1), pd.Series(vals2), pd.Series(vals3)],\n                ignore_index=True,\n            )\n            tm.assert_series_equal(res, exp)\n\n            # name mismatch\n            s1 = pd.Series(vals1, name=\"x\")\n            s2 = pd.Series(vals2, name=\"y\")\n            res = s1.append(s2, ignore_index=True)\n            exp = pd.Series(exp_data)\n            tm.assert_series_equal(res, exp, check_index_type=True)\n\n            res = pd.concat([s1, s2], ignore_index=True)\n            tm.assert_series_equal(res, exp, check_index_type=True)\n\n            # name match\n            s1 = pd.Series(vals1, name=\"x\")\n            s2 = pd.Series(vals2, name=\"x\")\n            res = s1.append(s2, ignore_index=True)\n            exp = pd.Series(exp_data, name=\"x\")\n            tm.assert_series_equal(res, exp, check_index_type=True)\n\n            res = pd.concat([s1, s2], ignore_index=True)\n            tm.assert_series_equal(res, exp, check_index_type=True)\n\n            # cannot append non-index\n            msg = (\n                r\"cannot concatenate object of type '.+'; \"\n                \"only Series and DataFrame objs are valid\"\n            )\n            with pytest.raises(TypeError, match=msg):\n                pd.Series(vals1).append(vals2)\n\n            with pytest.raises(TypeError, match=msg):\n                pd.Series(vals1).append([pd.Series(vals2), vals3])\n\n            with pytest.raises(TypeError, match=msg):\n                pd.concat([pd.Series(vals1), vals2])\n\n            with pytest.raises(TypeError, match=msg):\n                pd.concat([pd.Series(vals1), pd.Series(vals2), vals3])",
        "begin_line": 108,
        "end_line": 214,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concatlike_dtypes_coercion#216",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concatlike_dtypes_coercion(self)",
        "snippet": "    def test_concatlike_dtypes_coercion(self):\n        # GH 13660\n        for typ1, vals1 in self.data.items():\n            for typ2, vals2 in self.data.items():\n\n                vals3 = vals2\n\n                # basically infer\n                exp_index_dtype = None\n                exp_series_dtype = None\n\n                if typ1 == typ2:\n                    # same dtype is tested in test_concatlike_same_dtypes\n                    continue\n                elif typ1 == \"category\" or typ2 == \"category\":\n                    # ToDo: suspicious\n                    continue\n\n                # specify expected dtype\n                if typ1 == \"bool\" and typ2 in (\"int64\", \"float64\"):\n                    # series coerces to numeric based on numpy rule\n                    # index doesn't because bool is object dtype\n                    exp_series_dtype = typ2\n                elif typ2 == \"bool\" and typ1 in (\"int64\", \"float64\"):\n                    exp_series_dtype = typ1\n                elif (\n                    typ1 == \"datetime64[ns, US/Eastern]\"\n                    or typ2 == \"datetime64[ns, US/Eastern]\"\n                    or typ1 == \"timedelta64[ns]\"\n                    or typ2 == \"timedelta64[ns]\"\n                ):\n                    exp_index_dtype = object\n                    exp_series_dtype = object\n\n                exp_data = vals1 + vals2\n                exp_data3 = vals1 + vals2 + vals3\n\n                # ----- Index ----- #\n\n                # index.append\n                res = pd.Index(vals1).append(pd.Index(vals2))\n                exp = pd.Index(exp_data, dtype=exp_index_dtype)\n                tm.assert_index_equal(res, exp)\n\n                # 3 elements\n                res = pd.Index(vals1).append([pd.Index(vals2), pd.Index(vals3)])\n                exp = pd.Index(exp_data3, dtype=exp_index_dtype)\n                tm.assert_index_equal(res, exp)\n\n                # ----- Series ----- #\n\n                # series.append\n                res = pd.Series(vals1).append(pd.Series(vals2), ignore_index=True)\n                exp = pd.Series(exp_data, dtype=exp_series_dtype)\n                tm.assert_series_equal(res, exp, check_index_type=True)\n\n                # concat\n                res = pd.concat([pd.Series(vals1), pd.Series(vals2)], ignore_index=True)\n                tm.assert_series_equal(res, exp, check_index_type=True)\n\n                # 3 elements\n                res = pd.Series(vals1).append(\n                    [pd.Series(vals2), pd.Series(vals3)], ignore_index=True\n                )\n                exp = pd.Series(exp_data3, dtype=exp_series_dtype)\n                tm.assert_series_equal(res, exp)\n\n                res = pd.concat(\n                    [pd.Series(vals1), pd.Series(vals2), pd.Series(vals3)],\n                    ignore_index=True,\n                )\n                tm.assert_series_equal(res, exp)",
        "begin_line": 216,
        "end_line": 287,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concatlike_common_coerce_to_pandas_object#289",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concatlike_common_coerce_to_pandas_object(self)",
        "snippet": "    def test_concatlike_common_coerce_to_pandas_object(self):\n        # GH 13626\n        # result must be Timestamp/Timedelta, not datetime.datetime/timedelta\n        dti = pd.DatetimeIndex([\"2011-01-01\", \"2011-01-02\"])\n        tdi = pd.TimedeltaIndex([\"1 days\", \"2 days\"])\n\n        exp = pd.Index(\n            [\n                pd.Timestamp(\"2011-01-01\"),\n                pd.Timestamp(\"2011-01-02\"),\n                pd.Timedelta(\"1 days\"),\n                pd.Timedelta(\"2 days\"),\n            ]\n        )\n\n        res = dti.append(tdi)\n        tm.assert_index_equal(res, exp)\n        assert isinstance(res[0], pd.Timestamp)\n        assert isinstance(res[-1], pd.Timedelta)\n\n        dts = pd.Series(dti)\n        tds = pd.Series(tdi)\n        res = dts.append(tds)\n        tm.assert_series_equal(res, pd.Series(exp, index=[0, 1, 0, 1]))\n        assert isinstance(res.iloc[0], pd.Timestamp)\n        assert isinstance(res.iloc[-1], pd.Timedelta)\n\n        res = pd.concat([dts, tds])\n        tm.assert_series_equal(res, pd.Series(exp, index=[0, 1, 0, 1]))\n        assert isinstance(res.iloc[0], pd.Timestamp)\n        assert isinstance(res.iloc[-1], pd.Timedelta)",
        "begin_line": 289,
        "end_line": 319,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concatlike_datetimetz#321",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concatlike_datetimetz(self, tz_aware_fixture)",
        "snippet": "    def test_concatlike_datetimetz(self, tz_aware_fixture):\n        tz = tz_aware_fixture\n        # GH 7795\n        dti1 = pd.DatetimeIndex([\"2011-01-01\", \"2011-01-02\"], tz=tz)\n        dti2 = pd.DatetimeIndex([\"2012-01-01\", \"2012-01-02\"], tz=tz)\n\n        exp = pd.DatetimeIndex(\n            [\"2011-01-01\", \"2011-01-02\", \"2012-01-01\", \"2012-01-02\"], tz=tz\n        )\n\n        res = dti1.append(dti2)\n        tm.assert_index_equal(res, exp)\n\n        dts1 = pd.Series(dti1)\n        dts2 = pd.Series(dti2)\n        res = dts1.append(dts2)\n        tm.assert_series_equal(res, pd.Series(exp, index=[0, 1, 0, 1]))\n\n        res = pd.concat([dts1, dts2])\n        tm.assert_series_equal(res, pd.Series(exp, index=[0, 1, 0, 1]))",
        "begin_line": 321,
        "end_line": 340,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concatlike_datetimetz_short#343",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concatlike_datetimetz_short(self, tz)",
        "snippet": "    def test_concatlike_datetimetz_short(self, tz):\n        # GH#7795\n        ix1 = pd.date_range(start=\"2014-07-15\", end=\"2014-07-17\", freq=\"D\", tz=tz)\n        ix2 = pd.DatetimeIndex([\"2014-07-11\", \"2014-07-21\"], tz=tz)\n        df1 = pd.DataFrame(0, index=ix1, columns=[\"A\", \"B\"])\n        df2 = pd.DataFrame(0, index=ix2, columns=[\"A\", \"B\"])\n\n        exp_idx = pd.DatetimeIndex(\n            [\"2014-07-15\", \"2014-07-16\", \"2014-07-17\", \"2014-07-11\", \"2014-07-21\"],\n            tz=tz,\n        )\n        exp = pd.DataFrame(0, index=exp_idx, columns=[\"A\", \"B\"])\n\n        tm.assert_frame_equal(df1.append(df2), exp)\n        tm.assert_frame_equal(pd.concat([df1, df2]), exp)",
        "begin_line": 343,
        "end_line": 357,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concatlike_datetimetz_to_object#359",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concatlike_datetimetz_to_object(self, tz_aware_fixture)",
        "snippet": "    def test_concatlike_datetimetz_to_object(self, tz_aware_fixture):\n        tz = tz_aware_fixture\n        # GH 13660\n\n        # different tz coerces to object\n        dti1 = pd.DatetimeIndex([\"2011-01-01\", \"2011-01-02\"], tz=tz)\n        dti2 = pd.DatetimeIndex([\"2012-01-01\", \"2012-01-02\"])\n\n        exp = pd.Index(\n            [\n                pd.Timestamp(\"2011-01-01\", tz=tz),\n                pd.Timestamp(\"2011-01-02\", tz=tz),\n                pd.Timestamp(\"2012-01-01\"),\n                pd.Timestamp(\"2012-01-02\"),\n            ],\n            dtype=object,\n        )\n\n        res = dti1.append(dti2)\n        tm.assert_index_equal(res, exp)\n\n        dts1 = pd.Series(dti1)\n        dts2 = pd.Series(dti2)\n        res = dts1.append(dts2)\n        tm.assert_series_equal(res, pd.Series(exp, index=[0, 1, 0, 1]))\n\n        res = pd.concat([dts1, dts2])\n        tm.assert_series_equal(res, pd.Series(exp, index=[0, 1, 0, 1]))\n\n        # different tz\n        dti3 = pd.DatetimeIndex([\"2012-01-01\", \"2012-01-02\"], tz=\"US/Pacific\")\n\n        exp = pd.Index(\n            [\n                pd.Timestamp(\"2011-01-01\", tz=tz),\n                pd.Timestamp(\"2011-01-02\", tz=tz),\n                pd.Timestamp(\"2012-01-01\", tz=\"US/Pacific\"),\n                pd.Timestamp(\"2012-01-02\", tz=\"US/Pacific\"),\n            ],\n            dtype=object,\n        )\n\n        res = dti1.append(dti3)\n        # tm.assert_index_equal(res, exp)\n\n        dts1 = pd.Series(dti1)\n        dts3 = pd.Series(dti3)\n        res = dts1.append(dts3)\n        tm.assert_series_equal(res, pd.Series(exp, index=[0, 1, 0, 1]))\n\n        res = pd.concat([dts1, dts3])\n        tm.assert_series_equal(res, pd.Series(exp, index=[0, 1, 0, 1]))",
        "begin_line": 359,
        "end_line": 410,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concatlike_common_period#412",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concatlike_common_period(self)",
        "snippet": "    def test_concatlike_common_period(self):\n        # GH 13660\n        pi1 = pd.PeriodIndex([\"2011-01\", \"2011-02\"], freq=\"M\")\n        pi2 = pd.PeriodIndex([\"2012-01\", \"2012-02\"], freq=\"M\")\n\n        exp = pd.PeriodIndex([\"2011-01\", \"2011-02\", \"2012-01\", \"2012-02\"], freq=\"M\")\n\n        res = pi1.append(pi2)\n        tm.assert_index_equal(res, exp)\n\n        ps1 = pd.Series(pi1)\n        ps2 = pd.Series(pi2)\n        res = ps1.append(ps2)\n        tm.assert_series_equal(res, pd.Series(exp, index=[0, 1, 0, 1]))\n\n        res = pd.concat([ps1, ps2])\n        tm.assert_series_equal(res, pd.Series(exp, index=[0, 1, 0, 1]))",
        "begin_line": 412,
        "end_line": 428,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concatlike_common_period_diff_freq_to_object#430",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concatlike_common_period_diff_freq_to_object(self)",
        "snippet": "    def test_concatlike_common_period_diff_freq_to_object(self):\n        # GH 13221\n        pi1 = pd.PeriodIndex([\"2011-01\", \"2011-02\"], freq=\"M\")\n        pi2 = pd.PeriodIndex([\"2012-01-01\", \"2012-02-01\"], freq=\"D\")\n\n        exp = pd.Index(\n            [\n                pd.Period(\"2011-01\", freq=\"M\"),\n                pd.Period(\"2011-02\", freq=\"M\"),\n                pd.Period(\"2012-01-01\", freq=\"D\"),\n                pd.Period(\"2012-02-01\", freq=\"D\"),\n            ],\n            dtype=object,\n        )\n\n        res = pi1.append(pi2)\n        tm.assert_index_equal(res, exp)\n\n        ps1 = pd.Series(pi1)\n        ps2 = pd.Series(pi2)\n        res = ps1.append(ps2)\n        tm.assert_series_equal(res, pd.Series(exp, index=[0, 1, 0, 1]))\n\n        res = pd.concat([ps1, ps2])\n        tm.assert_series_equal(res, pd.Series(exp, index=[0, 1, 0, 1]))",
        "begin_line": 430,
        "end_line": 454,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concatlike_common_period_mixed_dt_to_object#456",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concatlike_common_period_mixed_dt_to_object(self)",
        "snippet": "    def test_concatlike_common_period_mixed_dt_to_object(self):\n        # GH 13221\n        # different datetimelike\n        pi1 = pd.PeriodIndex([\"2011-01\", \"2011-02\"], freq=\"M\")\n        tdi = pd.TimedeltaIndex([\"1 days\", \"2 days\"])\n        exp = pd.Index(\n            [\n                pd.Period(\"2011-01\", freq=\"M\"),\n                pd.Period(\"2011-02\", freq=\"M\"),\n                pd.Timedelta(\"1 days\"),\n                pd.Timedelta(\"2 days\"),\n            ],\n            dtype=object,\n        )\n\n        res = pi1.append(tdi)\n        tm.assert_index_equal(res, exp)\n\n        ps1 = pd.Series(pi1)\n        tds = pd.Series(tdi)\n        res = ps1.append(tds)\n        tm.assert_series_equal(res, pd.Series(exp, index=[0, 1, 0, 1]))\n\n        res = pd.concat([ps1, tds])\n        tm.assert_series_equal(res, pd.Series(exp, index=[0, 1, 0, 1]))\n\n        # inverse\n        exp = pd.Index(\n            [\n                pd.Timedelta(\"1 days\"),\n                pd.Timedelta(\"2 days\"),\n                pd.Period(\"2011-01\", freq=\"M\"),\n                pd.Period(\"2011-02\", freq=\"M\"),\n            ],\n            dtype=object,\n        )\n\n        res = tdi.append(pi1)\n        tm.assert_index_equal(res, exp)\n\n        ps1 = pd.Series(pi1)\n        tds = pd.Series(tdi)\n        res = tds.append(ps1)\n        tm.assert_series_equal(res, pd.Series(exp, index=[0, 1, 0, 1]))\n\n        res = pd.concat([tds, ps1])\n        tm.assert_series_equal(res, pd.Series(exp, index=[0, 1, 0, 1]))",
        "begin_line": 456,
        "end_line": 502,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concat_categorical#504",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concat_categorical(self)",
        "snippet": "    def test_concat_categorical(self):\n        # GH 13524\n\n        # same categories -> category\n        s1 = pd.Series([1, 2, np.nan], dtype=\"category\")\n        s2 = pd.Series([2, 1, 2], dtype=\"category\")\n\n        exp = pd.Series([1, 2, np.nan, 2, 1, 2], dtype=\"category\")\n        tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)\n        tm.assert_series_equal(s1.append(s2, ignore_index=True), exp)\n\n        # partially different categories => not-category\n        s1 = pd.Series([3, 2], dtype=\"category\")\n        s2 = pd.Series([2, 1], dtype=\"category\")\n\n        exp = pd.Series([3, 2, 2, 1])\n        tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)\n        tm.assert_series_equal(s1.append(s2, ignore_index=True), exp)\n\n        # completely different categories (same dtype) => not-category\n        s1 = pd.Series([10, 11, np.nan], dtype=\"category\")\n        s2 = pd.Series([np.nan, 1, 3, 2], dtype=\"category\")\n\n        exp = pd.Series([10, 11, np.nan, np.nan, 1, 3, 2], dtype=\"object\")\n        tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)\n        tm.assert_series_equal(s1.append(s2, ignore_index=True), exp)",
        "begin_line": 504,
        "end_line": 529,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_union_categorical_same_categories_different_order#531",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_union_categorical_same_categories_different_order(self)",
        "snippet": "    def test_union_categorical_same_categories_different_order(self):\n        # https://github.com/pandas-dev/pandas/issues/19096\n        a = pd.Series(Categorical([\"a\", \"b\", \"c\"], categories=[\"a\", \"b\", \"c\"]))\n        b = pd.Series(Categorical([\"a\", \"b\", \"c\"], categories=[\"b\", \"a\", \"c\"]))\n        result = pd.concat([a, b], ignore_index=True)\n        expected = pd.Series(\n            Categorical([\"a\", \"b\", \"c\", \"a\", \"b\", \"c\"], categories=[\"a\", \"b\", \"c\"])\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 531,
        "end_line": 539,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concat_categorical_coercion#541",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concat_categorical_coercion(self)",
        "snippet": "    def test_concat_categorical_coercion(self):\n        # GH 13524\n\n        # category + not-category => not-category\n        s1 = pd.Series([1, 2, np.nan], dtype=\"category\")\n        s2 = pd.Series([2, 1, 2])\n\n        exp = pd.Series([1, 2, np.nan, 2, 1, 2], dtype=\"object\")\n        tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)\n        tm.assert_series_equal(s1.append(s2, ignore_index=True), exp)\n\n        # result shouldn't be affected by 1st elem dtype\n        exp = pd.Series([2, 1, 2, 1, 2, np.nan], dtype=\"object\")\n        tm.assert_series_equal(pd.concat([s2, s1], ignore_index=True), exp)\n        tm.assert_series_equal(s2.append(s1, ignore_index=True), exp)\n\n        # all values are not in category => not-category\n        s1 = pd.Series([3, 2], dtype=\"category\")\n        s2 = pd.Series([2, 1])\n\n        exp = pd.Series([3, 2, 2, 1])\n        tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)\n        tm.assert_series_equal(s1.append(s2, ignore_index=True), exp)\n\n        exp = pd.Series([2, 1, 3, 2])\n        tm.assert_series_equal(pd.concat([s2, s1], ignore_index=True), exp)\n        tm.assert_series_equal(s2.append(s1, ignore_index=True), exp)\n\n        # completely different categories => not-category\n        s1 = pd.Series([10, 11, np.nan], dtype=\"category\")\n        s2 = pd.Series([1, 3, 2])\n\n        exp = pd.Series([10, 11, np.nan, 1, 3, 2], dtype=\"object\")\n        tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)\n        tm.assert_series_equal(s1.append(s2, ignore_index=True), exp)\n\n        exp = pd.Series([1, 3, 2, 10, 11, np.nan], dtype=\"object\")\n        tm.assert_series_equal(pd.concat([s2, s1], ignore_index=True), exp)\n        tm.assert_series_equal(s2.append(s1, ignore_index=True), exp)\n\n        # different dtype => not-category\n        s1 = pd.Series([10, 11, np.nan], dtype=\"category\")\n        s2 = pd.Series([\"a\", \"b\", \"c\"])\n\n        exp = pd.Series([10, 11, np.nan, \"a\", \"b\", \"c\"])\n        tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)\n        tm.assert_series_equal(s1.append(s2, ignore_index=True), exp)\n\n        exp = pd.Series([\"a\", \"b\", \"c\", 10, 11, np.nan])\n        tm.assert_series_equal(pd.concat([s2, s1], ignore_index=True), exp)\n        tm.assert_series_equal(s2.append(s1, ignore_index=True), exp)\n\n        # if normal series only contains NaN-likes => not-category\n        s1 = pd.Series([10, 11], dtype=\"category\")\n        s2 = pd.Series([np.nan, np.nan, np.nan])\n\n        exp = pd.Series([10, 11, np.nan, np.nan, np.nan])\n        tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)\n        tm.assert_series_equal(s1.append(s2, ignore_index=True), exp)\n\n        exp = pd.Series([np.nan, np.nan, np.nan, 10, 11])\n        tm.assert_series_equal(pd.concat([s2, s1], ignore_index=True), exp)\n        tm.assert_series_equal(s2.append(s1, ignore_index=True), exp)",
        "begin_line": 541,
        "end_line": 603,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concat_categorical_3elem_coercion#605",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concat_categorical_3elem_coercion(self)",
        "snippet": "    def test_concat_categorical_3elem_coercion(self):\n        # GH 13524\n\n        # mixed dtypes => not-category\n        s1 = pd.Series([1, 2, np.nan], dtype=\"category\")\n        s2 = pd.Series([2, 1, 2], dtype=\"category\")\n        s3 = pd.Series([1, 2, 1, 2, np.nan])\n\n        exp = pd.Series([1, 2, np.nan, 2, 1, 2, 1, 2, 1, 2, np.nan], dtype=\"object\")\n        tm.assert_series_equal(pd.concat([s1, s2, s3], ignore_index=True), exp)\n        tm.assert_series_equal(s1.append([s2, s3], ignore_index=True), exp)\n\n        exp = pd.Series([1, 2, 1, 2, np.nan, 1, 2, np.nan, 2, 1, 2], dtype=\"object\")\n        tm.assert_series_equal(pd.concat([s3, s1, s2], ignore_index=True), exp)\n        tm.assert_series_equal(s3.append([s1, s2], ignore_index=True), exp)\n\n        # values are all in either category => not-category\n        s1 = pd.Series([4, 5, 6], dtype=\"category\")\n        s2 = pd.Series([1, 2, 3], dtype=\"category\")\n        s3 = pd.Series([1, 3, 4])\n\n        exp = pd.Series([4, 5, 6, 1, 2, 3, 1, 3, 4])\n        tm.assert_series_equal(pd.concat([s1, s2, s3], ignore_index=True), exp)\n        tm.assert_series_equal(s1.append([s2, s3], ignore_index=True), exp)\n\n        exp = pd.Series([1, 3, 4, 4, 5, 6, 1, 2, 3])\n        tm.assert_series_equal(pd.concat([s3, s1, s2], ignore_index=True), exp)\n        tm.assert_series_equal(s3.append([s1, s2], ignore_index=True), exp)\n\n        # values are all in either category => not-category\n        s1 = pd.Series([4, 5, 6], dtype=\"category\")\n        s2 = pd.Series([1, 2, 3], dtype=\"category\")\n        s3 = pd.Series([10, 11, 12])\n\n        exp = pd.Series([4, 5, 6, 1, 2, 3, 10, 11, 12])\n        tm.assert_series_equal(pd.concat([s1, s2, s3], ignore_index=True), exp)\n        tm.assert_series_equal(s1.append([s2, s3], ignore_index=True), exp)\n\n        exp = pd.Series([10, 11, 12, 4, 5, 6, 1, 2, 3])\n        tm.assert_series_equal(pd.concat([s3, s1, s2], ignore_index=True), exp)\n        tm.assert_series_equal(s3.append([s1, s2], ignore_index=True), exp)",
        "begin_line": 605,
        "end_line": 645,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concat_categorical_multi_coercion#647",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concat_categorical_multi_coercion(self)",
        "snippet": "    def test_concat_categorical_multi_coercion(self):\n        # GH 13524\n\n        s1 = pd.Series([1, 3], dtype=\"category\")\n        s2 = pd.Series([3, 4], dtype=\"category\")\n        s3 = pd.Series([2, 3])\n        s4 = pd.Series([2, 2], dtype=\"category\")\n        s5 = pd.Series([1, np.nan])\n        s6 = pd.Series([1, 3, 2], dtype=\"category\")\n\n        # mixed dtype, values are all in categories => not-category\n        exp = pd.Series([1, 3, 3, 4, 2, 3, 2, 2, 1, np.nan, 1, 3, 2])\n        res = pd.concat([s1, s2, s3, s4, s5, s6], ignore_index=True)\n        tm.assert_series_equal(res, exp)\n        res = s1.append([s2, s3, s4, s5, s6], ignore_index=True)\n        tm.assert_series_equal(res, exp)\n\n        exp = pd.Series([1, 3, 2, 1, np.nan, 2, 2, 2, 3, 3, 4, 1, 3])\n        res = pd.concat([s6, s5, s4, s3, s2, s1], ignore_index=True)\n        tm.assert_series_equal(res, exp)\n        res = s6.append([s5, s4, s3, s2, s1], ignore_index=True)\n        tm.assert_series_equal(res, exp)",
        "begin_line": 647,
        "end_line": 668,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concat_categorical_ordered#670",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concat_categorical_ordered(self)",
        "snippet": "    def test_concat_categorical_ordered(self):\n        # GH 13524\n\n        s1 = pd.Series(pd.Categorical([1, 2, np.nan], ordered=True))\n        s2 = pd.Series(pd.Categorical([2, 1, 2], ordered=True))\n\n        exp = pd.Series(pd.Categorical([1, 2, np.nan, 2, 1, 2], ordered=True))\n        tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)\n        tm.assert_series_equal(s1.append(s2, ignore_index=True), exp)\n\n        exp = pd.Series(\n            pd.Categorical([1, 2, np.nan, 2, 1, 2, 1, 2, np.nan], ordered=True)\n        )\n        tm.assert_series_equal(pd.concat([s1, s2, s1], ignore_index=True), exp)\n        tm.assert_series_equal(s1.append([s2, s1], ignore_index=True), exp)",
        "begin_line": 670,
        "end_line": 684,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concat_categorical_coercion_nan#686",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concat_categorical_coercion_nan(self)",
        "snippet": "    def test_concat_categorical_coercion_nan(self):\n        # GH 13524\n\n        # some edge cases\n        # category + not-category => not category\n        s1 = pd.Series(np.array([np.nan, np.nan], dtype=np.float64), dtype=\"category\")\n        s2 = pd.Series([np.nan, 1])\n\n        exp = pd.Series([np.nan, np.nan, np.nan, 1])\n        tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)\n        tm.assert_series_equal(s1.append(s2, ignore_index=True), exp)\n\n        s1 = pd.Series([1, np.nan], dtype=\"category\")\n        s2 = pd.Series([np.nan, np.nan])\n\n        exp = pd.Series([1, np.nan, np.nan, np.nan], dtype=\"object\")\n        tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)\n        tm.assert_series_equal(s1.append(s2, ignore_index=True), exp)\n\n        # mixed dtype, all nan-likes => not-category\n        s1 = pd.Series([np.nan, np.nan], dtype=\"category\")\n        s2 = pd.Series([np.nan, np.nan])\n\n        exp = pd.Series([np.nan, np.nan, np.nan, np.nan])\n        tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)\n        tm.assert_series_equal(s1.append(s2, ignore_index=True), exp)\n        tm.assert_series_equal(pd.concat([s2, s1], ignore_index=True), exp)\n        tm.assert_series_equal(s2.append(s1, ignore_index=True), exp)\n\n        # all category nan-likes => category\n        s1 = pd.Series([np.nan, np.nan], dtype=\"category\")\n        s2 = pd.Series([np.nan, np.nan], dtype=\"category\")\n\n        exp = pd.Series([np.nan, np.nan, np.nan, np.nan], dtype=\"category\")\n\n        tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)\n        tm.assert_series_equal(s1.append(s2, ignore_index=True), exp)",
        "begin_line": 686,
        "end_line": 722,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concat_categorical_empty#724",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatAppendCommon",
        "signature": "pandas.tests.reshape.test_concat.TestConcatAppendCommon.test_concat_categorical_empty(self)",
        "snippet": "    def test_concat_categorical_empty(self):\n        # GH 13524\n\n        s1 = pd.Series([], dtype=\"category\")\n        s2 = pd.Series([1, 2], dtype=\"category\")\n\n        tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), s2)\n        tm.assert_series_equal(s1.append(s2, ignore_index=True), s2)\n\n        tm.assert_series_equal(pd.concat([s2, s1], ignore_index=True), s2)\n        tm.assert_series_equal(s2.append(s1, ignore_index=True), s2)\n\n        s1 = pd.Series([], dtype=\"category\")\n        s2 = pd.Series([], dtype=\"category\")\n\n        tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), s2)\n        tm.assert_series_equal(s1.append(s2, ignore_index=True), s2)\n\n        s1 = pd.Series([], dtype=\"category\")\n        s2 = pd.Series([], dtype=\"object\")\n\n        # different dtype => not-category\n        tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), s2)\n        tm.assert_series_equal(s1.append(s2, ignore_index=True), s2)\n        tm.assert_series_equal(pd.concat([s2, s1], ignore_index=True), s2)\n        tm.assert_series_equal(s2.append(s1, ignore_index=True), s2)\n\n        s1 = pd.Series([], dtype=\"category\")\n        s2 = pd.Series([np.nan, np.nan])\n\n        # empty Series is ignored\n        exp = pd.Series([np.nan, np.nan])\n        tm.assert_series_equal(pd.concat([s1, s2], ignore_index=True), exp)\n        tm.assert_series_equal(s1.append(s2, ignore_index=True), exp)\n\n        tm.assert_series_equal(pd.concat([s2, s1], ignore_index=True), exp)\n        tm.assert_series_equal(s2.append(s1, ignore_index=True), exp)",
        "begin_line": 724,
        "end_line": 760,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestAppend.test_append#764",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestAppend",
        "signature": "pandas.tests.reshape.test_concat.TestAppend.test_append(self, sort, float_frame)",
        "snippet": "    def test_append(self, sort, float_frame):\n        mixed_frame = float_frame.copy()\n        mixed_frame[\"foo\"] = \"bar\"\n\n        begin_index = float_frame.index[:5]\n        end_index = float_frame.index[5:]\n\n        begin_frame = float_frame.reindex(begin_index)\n        end_frame = float_frame.reindex(end_index)\n\n        appended = begin_frame.append(end_frame)\n        tm.assert_almost_equal(appended[\"A\"], float_frame[\"A\"])\n\n        del end_frame[\"A\"]\n        partial_appended = begin_frame.append(end_frame, sort=sort)\n        assert \"A\" in partial_appended\n\n        partial_appended = end_frame.append(begin_frame, sort=sort)\n        assert \"A\" in partial_appended\n\n        # mixed type handling\n        appended = mixed_frame[:5].append(mixed_frame[5:])\n        tm.assert_frame_equal(appended, mixed_frame)\n\n        # what to test here\n        mixed_appended = mixed_frame[:5].append(float_frame[5:], sort=sort)\n        mixed_appended2 = float_frame[:5].append(mixed_frame[5:], sort=sort)\n\n        # all equal except 'foo' column\n        tm.assert_frame_equal(\n            mixed_appended.reindex(columns=[\"A\", \"B\", \"C\", \"D\"]),\n            mixed_appended2.reindex(columns=[\"A\", \"B\", \"C\", \"D\"]),\n        )",
        "begin_line": 764,
        "end_line": 796,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestAppend.test_append_empty#798",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestAppend",
        "signature": "pandas.tests.reshape.test_concat.TestAppend.test_append_empty(self, float_frame)",
        "snippet": "    def test_append_empty(self, float_frame):\n        empty = DataFrame()\n\n        appended = float_frame.append(empty)\n        tm.assert_frame_equal(float_frame, appended)\n        assert appended is not float_frame\n\n        appended = empty.append(float_frame)\n        tm.assert_frame_equal(float_frame, appended)\n        assert appended is not float_frame",
        "begin_line": 798,
        "end_line": 807,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestAppend.test_append_overlap_raises#809",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestAppend",
        "signature": "pandas.tests.reshape.test_concat.TestAppend.test_append_overlap_raises(self, float_frame)",
        "snippet": "    def test_append_overlap_raises(self, float_frame):\n        msg = \"Indexes have overlapping values\"\n        with pytest.raises(ValueError, match=msg):\n            float_frame.append(float_frame, verify_integrity=True)",
        "begin_line": 809,
        "end_line": 812,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestAppend.test_append_new_columns#814",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestAppend",
        "signature": "pandas.tests.reshape.test_concat.TestAppend.test_append_new_columns(self)",
        "snippet": "    def test_append_new_columns(self):\n        # see gh-6129: new columns\n        df = DataFrame({\"a\": {\"x\": 1, \"y\": 2}, \"b\": {\"x\": 3, \"y\": 4}})\n        row = Series([5, 6, 7], index=[\"a\", \"b\", \"c\"], name=\"z\")\n        expected = DataFrame(\n            {\n                \"a\": {\"x\": 1, \"y\": 2, \"z\": 5},\n                \"b\": {\"x\": 3, \"y\": 4, \"z\": 6},\n                \"c\": {\"z\": 7},\n            }\n        )\n        result = df.append(row)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 814,
        "end_line": 826,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestAppend.test_append_length0_frame#828",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestAppend",
        "signature": "pandas.tests.reshape.test_concat.TestAppend.test_append_length0_frame(self, sort)",
        "snippet": "    def test_append_length0_frame(self, sort):\n        df = DataFrame(columns=[\"A\", \"B\", \"C\"])\n        df3 = DataFrame(index=[0, 1], columns=[\"A\", \"B\"])\n        df5 = df.append(df3, sort=sort)\n\n        expected = DataFrame(index=[0, 1], columns=[\"A\", \"B\", \"C\"])\n        tm.assert_frame_equal(df5, expected)",
        "begin_line": 828,
        "end_line": 834,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestAppend.test_append_records#836",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestAppend",
        "signature": "pandas.tests.reshape.test_concat.TestAppend.test_append_records(self)",
        "snippet": "    def test_append_records(self):\n        arr1 = np.zeros((2,), dtype=(\"i4,f4,a10\"))\n        arr1[:] = [(1, 2.0, \"Hello\"), (2, 3.0, \"World\")]\n\n        arr2 = np.zeros((3,), dtype=(\"i4,f4,a10\"))\n        arr2[:] = [(3, 4.0, \"foo\"), (5, 6.0, \"bar\"), (7.0, 8.0, \"baz\")]\n\n        df1 = DataFrame(arr1)\n        df2 = DataFrame(arr2)\n\n        result = df1.append(df2, ignore_index=True)\n        expected = DataFrame(np.concatenate((arr1, arr2)))\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 836,
        "end_line": 848,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestAppend.test_append_sorts#851",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestAppend",
        "signature": "pandas.tests.reshape.test_concat.TestAppend.test_append_sorts(self, sort)",
        "snippet": "    def test_append_sorts(self, sort):\n        df1 = pd.DataFrame({\"a\": [1, 2], \"b\": [1, 2]}, columns=[\"b\", \"a\"])\n        df2 = pd.DataFrame({\"a\": [1, 2], \"c\": [3, 4]}, index=[2, 3])\n\n        with tm.assert_produces_warning(None):\n            result = df1.append(df2, sort=sort)\n\n        # for None / True\n        expected = pd.DataFrame(\n            {\"b\": [1, 2, None, None], \"a\": [1, 2, 1, 2], \"c\": [None, None, 3, 4]},\n            columns=[\"a\", \"b\", \"c\"],\n        )\n        if sort is False:\n            expected = expected[[\"b\", \"a\", \"c\"]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 851,
        "end_line": 865,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestAppend.test_append_different_columns#867",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestAppend",
        "signature": "pandas.tests.reshape.test_concat.TestAppend.test_append_different_columns(self, sort)",
        "snippet": "    def test_append_different_columns(self, sort):\n        df = DataFrame(\n            {\n                \"bools\": np.random.randn(10) > 0,\n                \"ints\": np.random.randint(0, 10, 10),\n                \"floats\": np.random.randn(10),\n                \"strings\": [\"foo\", \"bar\"] * 5,\n            }\n        )\n\n        a = df[:5].loc[:, [\"bools\", \"ints\", \"floats\"]]\n        b = df[5:].loc[:, [\"strings\", \"ints\", \"floats\"]]\n\n        appended = a.append(b, sort=sort)\n        assert isna(appended[\"strings\"][0:4]).all()\n        assert isna(appended[\"bools\"][5:]).all()",
        "begin_line": 867,
        "end_line": 882,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestAppend.test_append_many#884",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestAppend",
        "signature": "pandas.tests.reshape.test_concat.TestAppend.test_append_many(self, sort, float_frame)",
        "snippet": "    def test_append_many(self, sort, float_frame):\n        chunks = [\n            float_frame[:5],\n            float_frame[5:10],\n            float_frame[10:15],\n            float_frame[15:],\n        ]\n\n        result = chunks[0].append(chunks[1:])\n        tm.assert_frame_equal(result, float_frame)\n\n        chunks[-1] = chunks[-1].copy()\n        chunks[-1][\"foo\"] = \"bar\"\n        result = chunks[0].append(chunks[1:], sort=sort)\n        tm.assert_frame_equal(result.loc[:, float_frame.columns], float_frame)\n        assert (result[\"foo\"][15:] == \"bar\").all()\n        assert result[\"foo\"][:15].isna().all()",
        "begin_line": 884,
        "end_line": 900,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestAppend.test_append_preserve_index_name#902",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestAppend",
        "signature": "pandas.tests.reshape.test_concat.TestAppend.test_append_preserve_index_name(self)",
        "snippet": "    def test_append_preserve_index_name(self):\n        # #980\n        df1 = DataFrame(columns=[\"A\", \"B\", \"C\"])\n        df1 = df1.set_index([\"A\"])\n        df2 = DataFrame(data=[[1, 4, 7], [2, 5, 8], [3, 6, 9]], columns=[\"A\", \"B\", \"C\"])\n        df2 = df2.set_index([\"A\"])\n\n        result = df1.append(df2)\n        assert result.index.name == \"A\"",
        "begin_line": 902,
        "end_line": 910,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestAppend.test_append_same_columns_type#936",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestAppend",
        "signature": "pandas.tests.reshape.test_concat.TestAppend.test_append_same_columns_type(self, index)",
        "snippet": "    def test_append_same_columns_type(self, index):\n        # GH18359\n\n        # df wider than ser\n        df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], columns=index)\n        ser_index = index[:2]\n        ser = pd.Series([7, 8], index=ser_index, name=2)\n        result = df.append(ser)\n        expected = pd.DataFrame(\n            [[1.0, 2.0, 3.0], [4, 5, 6], [7, 8, np.nan]], index=[0, 1, 2], columns=index\n        )\n        tm.assert_frame_equal(result, expected)\n\n        # ser wider than df\n        ser_index = index\n        index = index[:2]\n        df = pd.DataFrame([[1, 2], [4, 5]], columns=index)\n        ser = pd.Series([7, 8, 9], index=ser_index, name=2)\n        result = df.append(ser)\n        expected = pd.DataFrame(\n            [[1, 2, np.nan], [4, 5, np.nan], [7, 8, 9]],\n            index=[0, 1, 2],\n            columns=ser_index,\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 936,
        "end_line": 960,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestAppend.test_append_different_columns_types#967",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestAppend",
        "signature": "pandas.tests.reshape.test_concat.TestAppend.test_append_different_columns_types(self, df_columns, series_index)",
        "snippet": "    def test_append_different_columns_types(self, df_columns, series_index):\n        # GH18359\n        # See also test 'test_append_different_columns_types_raises' below\n        # for errors raised when appending\n\n        df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], columns=df_columns)\n        ser = pd.Series([7, 8, 9], index=series_index, name=2)\n\n        result = df.append(ser)\n        idx_diff = ser.index.difference(df_columns)\n        combined_columns = Index(df_columns.tolist()).append(idx_diff)\n        expected = pd.DataFrame(\n            [\n                [1.0, 2.0, 3.0, np.nan, np.nan, np.nan],\n                [4, 5, 6, np.nan, np.nan, np.nan],\n                [np.nan, np.nan, np.nan, 7, 8, 9],\n            ],\n            index=[0, 1, 2],\n            columns=combined_columns,\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 967,
        "end_line": 987,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestAppend.test_append_different_columns_types_raises#997",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestAppend",
        "signature": "pandas.tests.reshape.test_concat.TestAppend.test_append_different_columns_types_raises(self, index_can_append, index_cannot_append_with_other)",
        "snippet": "    def test_append_different_columns_types_raises(\n        self, index_can_append, index_cannot_append_with_other\n    ):\n        # GH18359\n        # Dataframe.append will raise if MultiIndex appends\n        # or is appended to a different index type\n        #\n        # See also test 'test_append_different_columns_types' above for\n        # appending without raising.\n\n        df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], columns=index_can_append)\n        ser = pd.Series([7, 8, 9], index=index_cannot_append_with_other, name=2)\n        msg = (\n            r\"Expected tuple, got (int|long|float|str|\"\n            r\"pandas._libs.interval.Interval)|\"\n            r\"object of type '(int|float|Timestamp|\"\n            r\"pandas._libs.interval.Interval)' has no len\\(\\)|\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            df.append(ser)\n\n        df = pd.DataFrame(\n            [[1, 2, 3], [4, 5, 6]], columns=index_cannot_append_with_other\n        )\n        ser = pd.Series([7, 8, 9], index=index_can_append, name=2)\n\n        with pytest.raises(TypeError, match=msg):\n            df.append(ser)",
        "begin_line": 997,
        "end_line": 1024,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestAppend.test_append_dtype_coerce#1026",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestAppend",
        "signature": "pandas.tests.reshape.test_concat.TestAppend.test_append_dtype_coerce(self, sort)",
        "snippet": "    def test_append_dtype_coerce(self, sort):\n\n        # GH 4993\n        # appending with datetime will incorrectly convert datetime64\n\n        df1 = DataFrame(\n            index=[1, 2],\n            data=[dt.datetime(2013, 1, 1, 0, 0), dt.datetime(2013, 1, 2, 0, 0)],\n            columns=[\"start_time\"],\n        )\n        df2 = DataFrame(\n            index=[4, 5],\n            data=[\n                [dt.datetime(2013, 1, 3, 0, 0), dt.datetime(2013, 1, 3, 6, 10)],\n                [dt.datetime(2013, 1, 4, 0, 0), dt.datetime(2013, 1, 4, 7, 10)],\n            ],\n            columns=[\"start_time\", \"end_time\"],\n        )\n\n        expected = concat(\n            [\n                Series(\n                    [\n                        pd.NaT,\n                        pd.NaT,\n                        dt.datetime(2013, 1, 3, 6, 10),\n                        dt.datetime(2013, 1, 4, 7, 10),\n                    ],\n                    name=\"end_time\",\n                ),\n                Series(\n                    [\n                        dt.datetime(2013, 1, 1, 0, 0),\n                        dt.datetime(2013, 1, 2, 0, 0),\n                        dt.datetime(2013, 1, 3, 0, 0),\n                        dt.datetime(2013, 1, 4, 0, 0),\n                    ],\n                    name=\"start_time\",\n                ),\n            ],\n            axis=1,\n            sort=sort,\n        )\n        result = df1.append(df2, ignore_index=True, sort=sort)\n        if sort:\n            expected = expected[[\"end_time\", \"start_time\"]]\n        else:\n            expected = expected[[\"start_time\", \"end_time\"]]\n\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1026,
        "end_line": 1075,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestAppend.test_append_missing_column_proper_upcast#1077",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestAppend",
        "signature": "pandas.tests.reshape.test_concat.TestAppend.test_append_missing_column_proper_upcast(self, sort)",
        "snippet": "    def test_append_missing_column_proper_upcast(self, sort):\n        df1 = DataFrame({\"A\": np.array([1, 2, 3, 4], dtype=\"i8\")})\n        df2 = DataFrame({\"B\": np.array([True, False, True, False], dtype=bool)})\n\n        appended = df1.append(df2, ignore_index=True, sort=sort)\n        assert appended[\"A\"].dtype == \"f8\"\n        assert appended[\"B\"].dtype == \"O\"",
        "begin_line": 1077,
        "end_line": 1083,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestAppend.test_append_empty_frame_to_series_with_dateutil_tz#1085",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestAppend",
        "signature": "pandas.tests.reshape.test_concat.TestAppend.test_append_empty_frame_to_series_with_dateutil_tz(self)",
        "snippet": "    def test_append_empty_frame_to_series_with_dateutil_tz(self):\n        # GH 23682\n        date = Timestamp(\"2018-10-24 07:30:00\", tz=dateutil.tz.tzutc())\n        s = Series({\"date\": date, \"a\": 1.0, \"b\": 2.0})\n        df = DataFrame(columns=[\"c\", \"d\"])\n        result = df.append(s, ignore_index=True)\n        # n.b. it's not clear to me that expected is correct here.\n        # It's possible that the `date` column should have\n        # datetime64[ns, tz] dtype for both result and expected.\n        # that would be more consistent with new columns having\n        # their own dtype (float for a and b, datetime64ns, tz for date).\n        expected = DataFrame(\n            [[np.nan, np.nan, 1.0, 2.0, date]],\n            columns=[\"c\", \"d\", \"a\", \"b\", \"date\"],\n            dtype=object,\n        )\n        # These columns get cast to object after append\n        expected[\"a\"] = expected[\"a\"].astype(float)\n        expected[\"b\"] = expected[\"b\"].astype(float)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1085,
        "end_line": 1104,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_copy#1108",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_copy(self)",
        "snippet": "    def test_concat_copy(self):\n        df = DataFrame(np.random.randn(4, 3))\n        df2 = DataFrame(np.random.randint(0, 10, size=4).reshape(4, 1))\n        df3 = DataFrame({5: \"foo\"}, index=range(4))\n\n        # These are actual copies.\n        result = concat([df, df2, df3], axis=1, copy=True)\n\n        for b in result._data.blocks:\n            assert b.values.base is None\n\n        # These are the same.\n        result = concat([df, df2, df3], axis=1, copy=False)\n\n        for b in result._data.blocks:\n            if b.is_float:\n                assert b.values.base is df._data.blocks[0].values.base\n            elif b.is_integer:\n                assert b.values.base is df2._data.blocks[0].values.base\n            elif b.is_object:\n                assert b.values.base is not None\n\n        # Float block was consolidated.\n        df4 = DataFrame(np.random.randn(4, 1))\n        result = concat([df, df2, df3, df4], axis=1, copy=False)\n        for b in result._data.blocks:\n            if b.is_float:\n                assert b.values.base is None\n            elif b.is_integer:\n                assert b.values.base is df2._data.blocks[0].values.base\n            elif b.is_object:\n                assert b.values.base is not None",
        "begin_line": 1108,
        "end_line": 1139,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_with_group_keys#1141",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_with_group_keys(self)",
        "snippet": "    def test_concat_with_group_keys(self):\n        df = DataFrame(np.random.randn(4, 3))\n        df2 = DataFrame(np.random.randn(4, 4))\n\n        # axis=0\n        df = DataFrame(np.random.randn(3, 4))\n        df2 = DataFrame(np.random.randn(4, 4))\n\n        result = concat([df, df2], keys=[0, 1])\n        exp_index = MultiIndex.from_arrays(\n            [[0, 0, 0, 1, 1, 1, 1], [0, 1, 2, 0, 1, 2, 3]]\n        )\n        expected = DataFrame(np.r_[df.values, df2.values], index=exp_index)\n        tm.assert_frame_equal(result, expected)\n\n        result = concat([df, df], keys=[0, 1])\n        exp_index2 = MultiIndex.from_arrays([[0, 0, 0, 1, 1, 1], [0, 1, 2, 0, 1, 2]])\n        expected = DataFrame(np.r_[df.values, df.values], index=exp_index2)\n        tm.assert_frame_equal(result, expected)\n\n        # axis=1\n        df = DataFrame(np.random.randn(4, 3))\n        df2 = DataFrame(np.random.randn(4, 4))\n\n        result = concat([df, df2], keys=[0, 1], axis=1)\n        expected = DataFrame(np.c_[df.values, df2.values], columns=exp_index)\n        tm.assert_frame_equal(result, expected)\n\n        result = concat([df, df], keys=[0, 1], axis=1)\n        expected = DataFrame(np.c_[df.values, df.values], columns=exp_index2)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1141,
        "end_line": 1171,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_keys_specific_levels#1173",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_keys_specific_levels(self)",
        "snippet": "    def test_concat_keys_specific_levels(self):\n        df = DataFrame(np.random.randn(10, 4))\n        pieces = [df.iloc[:, [0, 1]], df.iloc[:, [2]], df.iloc[:, [3]]]\n        level = [\"three\", \"two\", \"one\", \"zero\"]\n        result = concat(\n            pieces,\n            axis=1,\n            keys=[\"one\", \"two\", \"three\"],\n            levels=[level],\n            names=[\"group_key\"],\n        )\n\n        tm.assert_index_equal(result.columns.levels[0], Index(level, name=\"group_key\"))\n        tm.assert_index_equal(result.columns.levels[1], Index([0, 1, 2, 3]))\n\n        assert result.columns.names == [\"group_key\", None]",
        "begin_line": 1173,
        "end_line": 1188,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_dataframe_keys_bug#1190",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_dataframe_keys_bug(self, sort)",
        "snippet": "    def test_concat_dataframe_keys_bug(self, sort):\n        t1 = DataFrame(\n            {\"value\": Series([1, 2, 3], index=Index([\"a\", \"b\", \"c\"], name=\"id\"))}\n        )\n        t2 = DataFrame({\"value\": Series([7, 8], index=Index([\"a\", \"b\"], name=\"id\"))})\n\n        # it works\n        result = concat([t1, t2], axis=1, keys=[\"t1\", \"t2\"], sort=sort)\n        assert list(result.columns) == [(\"t1\", \"value\"), (\"t2\", \"value\")]",
        "begin_line": 1190,
        "end_line": 1198,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_series_partial_columns_names#1200",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_series_partial_columns_names(self)",
        "snippet": "    def test_concat_series_partial_columns_names(self):\n        # GH10698\n        foo = Series([1, 2], name=\"foo\")\n        bar = Series([1, 2])\n        baz = Series([4, 5])\n\n        result = concat([foo, bar, baz], axis=1)\n        expected = DataFrame(\n            {\"foo\": [1, 2], 0: [1, 2], 1: [4, 5]}, columns=[\"foo\", 0, 1]\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = concat([foo, bar, baz], axis=1, keys=[\"red\", \"blue\", \"yellow\"])\n        expected = DataFrame(\n            {\"red\": [1, 2], \"blue\": [1, 2], \"yellow\": [4, 5]},\n            columns=[\"red\", \"blue\", \"yellow\"],\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = concat([foo, bar, baz], axis=1, ignore_index=True)\n        expected = DataFrame({0: [1, 2], 1: [1, 2], 2: [4, 5]})\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1200,
        "end_line": 1221,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_dict#1223",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_dict(self)",
        "snippet": "    def test_concat_dict(self):\n        frames = {\n            \"foo\": DataFrame(np.random.randn(4, 3)),\n            \"bar\": DataFrame(np.random.randn(4, 3)),\n            \"baz\": DataFrame(np.random.randn(4, 3)),\n            \"qux\": DataFrame(np.random.randn(4, 3)),\n        }\n\n        sorted_keys = list(frames.keys())\n\n        result = concat(frames)\n        expected = concat([frames[k] for k in sorted_keys], keys=sorted_keys)\n        tm.assert_frame_equal(result, expected)\n\n        result = concat(frames, axis=1)\n        expected = concat([frames[k] for k in sorted_keys], keys=sorted_keys, axis=1)\n        tm.assert_frame_equal(result, expected)\n\n        keys = [\"baz\", \"foo\", \"bar\"]\n        result = concat(frames, keys=keys)\n        expected = concat([frames[k] for k in keys], keys=keys)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1223,
        "end_line": 1244,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_ignore_index#1246",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_ignore_index(self, sort)",
        "snippet": "    def test_concat_ignore_index(self, sort):\n        frame1 = DataFrame(\n            {\"test1\": [\"a\", \"b\", \"c\"], \"test2\": [1, 2, 3], \"test3\": [4.5, 3.2, 1.2]}\n        )\n        frame2 = DataFrame({\"test3\": [5.2, 2.2, 4.3]})\n        frame1.index = Index([\"x\", \"y\", \"z\"])\n        frame2.index = Index([\"x\", \"y\", \"q\"])\n\n        v1 = concat([frame1, frame2], axis=1, ignore_index=True, sort=sort)\n\n        nan = np.nan\n        expected = DataFrame(\n            [\n                [nan, nan, nan, 4.3],\n                [\"a\", 1, 4.5, 5.2],\n                [\"b\", 2, 3.2, 2.2],\n                [\"c\", 3, 1.2, nan],\n            ],\n            index=Index([\"q\", \"x\", \"y\", \"z\"]),\n        )\n        if not sort:\n            expected = expected.loc[[\"x\", \"y\", \"z\", \"q\"]]\n\n        tm.assert_frame_equal(v1, expected)",
        "begin_line": 1246,
        "end_line": 1269,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_multiindex_with_keys#1271",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_multiindex_with_keys(self)",
        "snippet": "    def test_concat_multiindex_with_keys(self):\n        index = MultiIndex(\n            levels=[[\"foo\", \"bar\", \"baz\", \"qux\"], [\"one\", \"two\", \"three\"]],\n            codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],\n            names=[\"first\", \"second\"],\n        )\n        frame = DataFrame(\n            np.random.randn(10, 3),\n            index=index,\n            columns=Index([\"A\", \"B\", \"C\"], name=\"exp\"),\n        )\n        result = concat([frame, frame], keys=[0, 1], names=[\"iteration\"])\n\n        assert result.index.names == (\"iteration\",) + index.names\n        tm.assert_frame_equal(result.loc[0], frame)\n        tm.assert_frame_equal(result.loc[1], frame)\n        assert result.index.nlevels == 3",
        "begin_line": 1271,
        "end_line": 1287,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_multiindex_with_tz#1289",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_multiindex_with_tz(self)",
        "snippet": "    def test_concat_multiindex_with_tz(self):\n        # GH 6606\n        df = DataFrame(\n            {\n                \"dt\": [\n                    datetime(2014, 1, 1),\n                    datetime(2014, 1, 2),\n                    datetime(2014, 1, 3),\n                ],\n                \"b\": [\"A\", \"B\", \"C\"],\n                \"c\": [1, 2, 3],\n                \"d\": [4, 5, 6],\n            }\n        )\n        df[\"dt\"] = df[\"dt\"].apply(lambda d: Timestamp(d, tz=\"US/Pacific\"))\n        df = df.set_index([\"dt\", \"b\"])\n\n        exp_idx1 = DatetimeIndex(\n            [\"2014-01-01\", \"2014-01-02\", \"2014-01-03\"] * 2, tz=\"US/Pacific\", name=\"dt\"\n        )\n        exp_idx2 = Index([\"A\", \"B\", \"C\"] * 2, name=\"b\")\n        exp_idx = MultiIndex.from_arrays([exp_idx1, exp_idx2])\n        expected = DataFrame(\n            {\"c\": [1, 2, 3] * 2, \"d\": [4, 5, 6] * 2}, index=exp_idx, columns=[\"c\", \"d\"]\n        )\n\n        result = concat([df, df])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1289,
        "end_line": 1316,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_multiindex_with_none_in_index_names#1318",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_multiindex_with_none_in_index_names(self)",
        "snippet": "    def test_concat_multiindex_with_none_in_index_names(self):\n        # GH 15787\n        index = pd.MultiIndex.from_product([[1], range(5)], names=[\"level1\", None])\n        df = pd.DataFrame({\"col\": range(5)}, index=index, dtype=np.int32)\n\n        result = concat([df, df], keys=[1, 2], names=[\"level2\"])\n        index = pd.MultiIndex.from_product(\n            [[1, 2], [1], range(5)], names=[\"level2\", \"level1\", None]\n        )\n        expected = pd.DataFrame(\n            {\"col\": list(range(5)) * 2}, index=index, dtype=np.int32\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = concat([df, df[:2]], keys=[1, 2], names=[\"level2\"])\n        level2 = [1] * 5 + [2] * 2\n        level1 = [1] * 7\n        no_name = list(range(5)) + list(range(2))\n        tuples = list(zip(level2, level1, no_name))\n        index = pd.MultiIndex.from_tuples(tuples, names=[\"level2\", \"level1\", None])\n        expected = pd.DataFrame({\"col\": no_name}, index=index, dtype=np.int32)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1318,
        "end_line": 1339,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_keys_and_levels#1341",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_keys_and_levels(self)",
        "snippet": "    def test_concat_keys_and_levels(self):\n        df = DataFrame(np.random.randn(1, 3))\n        df2 = DataFrame(np.random.randn(1, 4))\n\n        levels = [[\"foo\", \"baz\"], [\"one\", \"two\"]]\n        names = [\"first\", \"second\"]\n        result = concat(\n            [df, df2, df, df2],\n            keys=[(\"foo\", \"one\"), (\"foo\", \"two\"), (\"baz\", \"one\"), (\"baz\", \"two\")],\n            levels=levels,\n            names=names,\n        )\n        expected = concat([df, df2, df, df2])\n        exp_index = MultiIndex(\n            levels=levels + [[0]],\n            codes=[[0, 0, 1, 1], [0, 1, 0, 1], [0, 0, 0, 0]],\n            names=names + [None],\n        )\n        expected.index = exp_index\n\n        tm.assert_frame_equal(result, expected)\n\n        # no names\n        result = concat(\n            [df, df2, df, df2],\n            keys=[(\"foo\", \"one\"), (\"foo\", \"two\"), (\"baz\", \"one\"), (\"baz\", \"two\")],\n            levels=levels,\n        )\n        assert result.index.names == (None,) * 3\n\n        # no levels\n        result = concat(\n            [df, df2, df, df2],\n            keys=[(\"foo\", \"one\"), (\"foo\", \"two\"), (\"baz\", \"one\"), (\"baz\", \"two\")],\n            names=[\"first\", \"second\"],\n        )\n        assert result.index.names == (\"first\", \"second\", None)\n        tm.assert_index_equal(\n            result.index.levels[0], Index([\"baz\", \"foo\"], name=\"first\")\n        )",
        "begin_line": 1341,
        "end_line": 1380,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_keys_levels_no_overlap#1382",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_keys_levels_no_overlap(self)",
        "snippet": "    def test_concat_keys_levels_no_overlap(self):\n        # GH #1406\n        df = DataFrame(np.random.randn(1, 3), index=[\"a\"])\n        df2 = DataFrame(np.random.randn(1, 4), index=[\"b\"])\n\n        msg = \"Values not found in passed level\"\n        with pytest.raises(ValueError, match=msg):\n            concat([df, df], keys=[\"one\", \"two\"], levels=[[\"foo\", \"bar\", \"baz\"]])\n\n        msg = \"Key one not in level\"\n        with pytest.raises(ValueError, match=msg):\n            concat([df, df2], keys=[\"one\", \"two\"], levels=[[\"foo\", \"bar\", \"baz\"]])",
        "begin_line": 1382,
        "end_line": 1393,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_rename_index#1395",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_rename_index(self)",
        "snippet": "    def test_concat_rename_index(self):\n        a = DataFrame(\n            np.random.rand(3, 3),\n            columns=list(\"ABC\"),\n            index=Index(list(\"abc\"), name=\"index_a\"),\n        )\n        b = DataFrame(\n            np.random.rand(3, 3),\n            columns=list(\"ABC\"),\n            index=Index(list(\"abc\"), name=\"index_b\"),\n        )\n\n        result = concat([a, b], keys=[\"key0\", \"key1\"], names=[\"lvl0\", \"lvl1\"])\n\n        exp = concat([a, b], keys=[\"key0\", \"key1\"], names=[\"lvl0\"])\n        names = list(exp.index.names)\n        names[1] = \"lvl1\"\n        exp.index.set_names(names, inplace=True)\n\n        tm.assert_frame_equal(result, exp)\n        assert result.index.names == exp.index.names",
        "begin_line": 1395,
        "end_line": 1415,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_crossed_dtypes_weird_corner#1417",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_crossed_dtypes_weird_corner(self)",
        "snippet": "    def test_crossed_dtypes_weird_corner(self):\n        columns = [\"A\", \"B\", \"C\", \"D\"]\n        df1 = DataFrame(\n            {\n                \"A\": np.array([1, 2, 3, 4], dtype=\"f8\"),\n                \"B\": np.array([1, 2, 3, 4], dtype=\"i8\"),\n                \"C\": np.array([1, 2, 3, 4], dtype=\"f8\"),\n                \"D\": np.array([1, 2, 3, 4], dtype=\"i8\"),\n            },\n            columns=columns,\n        )\n\n        df2 = DataFrame(\n            {\n                \"A\": np.array([1, 2, 3, 4], dtype=\"i8\"),\n                \"B\": np.array([1, 2, 3, 4], dtype=\"f8\"),\n                \"C\": np.array([1, 2, 3, 4], dtype=\"i8\"),\n                \"D\": np.array([1, 2, 3, 4], dtype=\"f8\"),\n            },\n            columns=columns,\n        )\n\n        appended = df1.append(df2, ignore_index=True)\n        expected = DataFrame(\n            np.concatenate([df1.values, df2.values], axis=0), columns=columns\n        )\n        tm.assert_frame_equal(appended, expected)\n\n        df = DataFrame(np.random.randn(1, 3), index=[\"a\"])\n        df2 = DataFrame(np.random.randn(1, 4), index=[\"b\"])\n        result = concat([df, df2], keys=[\"one\", \"two\"], names=[\"first\", \"second\"])\n        assert result.index.names == (\"first\", \"second\")",
        "begin_line": 1417,
        "end_line": 1448,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_dups_index#1450",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_dups_index(self)",
        "snippet": "    def test_dups_index(self):\n        # GH 4771\n\n        # single dtypes\n        df = DataFrame(\n            np.random.randint(0, 10, size=40).reshape(10, 4),\n            columns=[\"A\", \"A\", \"C\", \"C\"],\n        )\n\n        result = concat([df, df], axis=1)\n        tm.assert_frame_equal(result.iloc[:, :4], df)\n        tm.assert_frame_equal(result.iloc[:, 4:], df)\n\n        result = concat([df, df], axis=0)\n        tm.assert_frame_equal(result.iloc[:10], df)\n        tm.assert_frame_equal(result.iloc[10:], df)\n\n        # multi dtypes\n        df = concat(\n            [\n                DataFrame(np.random.randn(10, 4), columns=[\"A\", \"A\", \"B\", \"B\"]),\n                DataFrame(\n                    np.random.randint(0, 10, size=20).reshape(10, 2), columns=[\"A\", \"C\"]\n                ),\n            ],\n            axis=1,\n        )\n\n        result = concat([df, df], axis=1)\n        tm.assert_frame_equal(result.iloc[:, :6], df)\n        tm.assert_frame_equal(result.iloc[:, 6:], df)\n\n        result = concat([df, df], axis=0)\n        tm.assert_frame_equal(result.iloc[:10], df)\n        tm.assert_frame_equal(result.iloc[10:], df)\n\n        # append\n        result = df.iloc[0:8, :].append(df.iloc[8:])\n        tm.assert_frame_equal(result, df)\n\n        result = df.iloc[0:8, :].append(df.iloc[8:9]).append(df.iloc[9:10])\n        tm.assert_frame_equal(result, df)\n\n        expected = concat([df, df], axis=0)\n        result = df.append(df)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1450,
        "end_line": 1495,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_with_mixed_tuples#1497",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_with_mixed_tuples(self, sort)",
        "snippet": "    def test_with_mixed_tuples(self, sort):\n        # 10697\n        # columns have mixed tuples, so handle properly\n        df1 = DataFrame({\"A\": \"foo\", (\"B\", 1): \"bar\"}, index=range(2))\n        df2 = DataFrame({\"B\": \"foo\", (\"B\", 1): \"bar\"}, index=range(2))\n\n        # it works\n        concat([df1, df2], sort=sort)",
        "begin_line": 1497,
        "end_line": 1504,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_handle_empty_objects#1506",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_handle_empty_objects(self, sort)",
        "snippet": "    def test_handle_empty_objects(self, sort):\n        df = DataFrame(np.random.randn(10, 4), columns=list(\"abcd\"))\n\n        baz = df[:5].copy()\n        baz[\"foo\"] = \"bar\"\n        empty = df[5:5]\n\n        frames = [baz, empty, empty, df[5:]]\n        concatted = concat(frames, axis=0, sort=sort)\n\n        expected = df.reindex(columns=[\"a\", \"b\", \"c\", \"d\", \"foo\"])\n        expected[\"foo\"] = expected[\"foo\"].astype(\"O\")\n        expected.loc[0:4, \"foo\"] = \"bar\"\n\n        tm.assert_frame_equal(concatted, expected)\n\n        # empty as first element with time series\n        # GH3259\n        df = DataFrame(\n            dict(A=range(10000)), index=date_range(\"20130101\", periods=10000, freq=\"s\")\n        )\n        empty = DataFrame()\n        result = concat([df, empty], axis=1)\n        tm.assert_frame_equal(result, df)\n        result = concat([empty, df], axis=1)\n        tm.assert_frame_equal(result, df)\n\n        result = concat([df, empty])\n        tm.assert_frame_equal(result, df)\n        result = concat([empty, df])\n        tm.assert_frame_equal(result, df)",
        "begin_line": 1506,
        "end_line": 1536,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_mixed_objs#1538",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_mixed_objs(self)",
        "snippet": "    def test_concat_mixed_objs(self):\n\n        # concat mixed series/frames\n        # G2385\n\n        # axis 1\n        index = date_range(\"01-Jan-2013\", periods=10, freq=\"H\")\n        arr = np.arange(10, dtype=\"int64\")\n        s1 = Series(arr, index=index)\n        s2 = Series(arr, index=index)\n        df = DataFrame(arr.reshape(-1, 1), index=index)\n\n        expected = DataFrame(\n            np.repeat(arr, 2).reshape(-1, 2), index=index, columns=[0, 0]\n        )\n        result = concat([df, df], axis=1)\n        tm.assert_frame_equal(result, expected)\n\n        expected = DataFrame(\n            np.repeat(arr, 2).reshape(-1, 2), index=index, columns=[0, 1]\n        )\n        result = concat([s1, s2], axis=1)\n        tm.assert_frame_equal(result, expected)\n\n        expected = DataFrame(\n            np.repeat(arr, 3).reshape(-1, 3), index=index, columns=[0, 1, 2]\n        )\n        result = concat([s1, s2, s1], axis=1)\n        tm.assert_frame_equal(result, expected)\n\n        expected = DataFrame(\n            np.repeat(arr, 5).reshape(-1, 5), index=index, columns=[0, 0, 1, 2, 3]\n        )\n        result = concat([s1, df, s2, s2, s1], axis=1)\n        tm.assert_frame_equal(result, expected)\n\n        # with names\n        s1.name = \"foo\"\n        expected = DataFrame(\n            np.repeat(arr, 3).reshape(-1, 3), index=index, columns=[\"foo\", 0, 0]\n        )\n        result = concat([s1, df, s2], axis=1)\n        tm.assert_frame_equal(result, expected)\n\n        s2.name = \"bar\"\n        expected = DataFrame(\n            np.repeat(arr, 3).reshape(-1, 3), index=index, columns=[\"foo\", 0, \"bar\"]\n        )\n        result = concat([s1, df, s2], axis=1)\n        tm.assert_frame_equal(result, expected)\n\n        # ignore index\n        expected = DataFrame(\n            np.repeat(arr, 3).reshape(-1, 3), index=index, columns=[0, 1, 2]\n        )\n        result = concat([s1, df, s2], axis=1, ignore_index=True)\n        tm.assert_frame_equal(result, expected)\n\n        # axis 0\n        expected = DataFrame(\n            np.tile(arr, 3).reshape(-1, 1), index=index.tolist() * 3, columns=[0]\n        )\n        result = concat([s1, df, s2])\n        tm.assert_frame_equal(result, expected)\n\n        expected = DataFrame(np.tile(arr, 3).reshape(-1, 1), columns=[0])\n        result = concat([s1, df, s2], ignore_index=True)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1538,
        "end_line": 1605,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_empty_dtype_coerce#1607",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_empty_dtype_coerce(self)",
        "snippet": "    def test_empty_dtype_coerce(self):\n\n        # xref to #12411\n        # xref to #12045\n        # xref to #11594\n        # see below\n\n        # 10571\n        df1 = DataFrame(data=[[1, None], [2, None]], columns=[\"a\", \"b\"])\n        df2 = DataFrame(data=[[3, None], [4, None]], columns=[\"a\", \"b\"])\n        result = concat([df1, df2])\n        expected = df1.dtypes\n        tm.assert_series_equal(result.dtypes, expected)",
        "begin_line": 1607,
        "end_line": 1619,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_dtype_coerceion#1621",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_dtype_coerceion(self)",
        "snippet": "    def test_dtype_coerceion(self):\n\n        # 12411\n        df = DataFrame({\"date\": [pd.Timestamp(\"20130101\").tz_localize(\"UTC\"), pd.NaT]})\n\n        result = concat([df.iloc[[0]], df.iloc[[1]]])\n        tm.assert_series_equal(result.dtypes, df.dtypes)\n\n        # 12045\n        import datetime\n\n        df = DataFrame(\n            {\"date\": [datetime.datetime(2012, 1, 1), datetime.datetime(1012, 1, 2)]}\n        )\n        result = concat([df.iloc[[0]], df.iloc[[1]]])\n        tm.assert_series_equal(result.dtypes, df.dtypes)\n\n        # 11594\n        df = DataFrame({\"text\": [\"some words\"] + [None] * 9})\n        result = concat([df.iloc[[0]], df.iloc[[1]]])\n        tm.assert_series_equal(result.dtypes, df.dtypes)",
        "begin_line": 1621,
        "end_line": 1641,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_series#1643",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_series(self)",
        "snippet": "    def test_concat_series(self):\n\n        ts = tm.makeTimeSeries()\n        ts.name = \"foo\"\n\n        pieces = [ts[:5], ts[5:15], ts[15:]]\n\n        result = concat(pieces)\n        tm.assert_series_equal(result, ts)\n        assert result.name == ts.name\n\n        result = concat(pieces, keys=[0, 1, 2])\n        expected = ts.copy()\n\n        ts.index = DatetimeIndex(np.array(ts.index.values, dtype=\"M8[ns]\"))\n\n        exp_codes = [np.repeat([0, 1, 2], [len(x) for x in pieces]), np.arange(len(ts))]\n        exp_index = MultiIndex(levels=[[0, 1, 2], ts.index], codes=exp_codes)\n        expected.index = exp_index\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1643,
        "end_line": 1662,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_series_axis1#1664",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_series_axis1(self, sort=sort)",
        "snippet": "    def test_concat_series_axis1(self, sort=sort):\n        ts = tm.makeTimeSeries()\n\n        pieces = [ts[:-2], ts[2:], ts[2:-2]]\n\n        result = concat(pieces, axis=1)\n        expected = DataFrame(pieces).T\n        tm.assert_frame_equal(result, expected)\n\n        result = concat(pieces, keys=[\"A\", \"B\", \"C\"], axis=1)\n        expected = DataFrame(pieces, index=[\"A\", \"B\", \"C\"]).T\n        tm.assert_frame_equal(result, expected)\n\n        # preserve series names, #2489\n        s = Series(randn(5), name=\"A\")\n        s2 = Series(randn(5), name=\"B\")\n\n        result = concat([s, s2], axis=1)\n        expected = DataFrame({\"A\": s, \"B\": s2})\n        tm.assert_frame_equal(result, expected)\n\n        s2.name = None\n        result = concat([s, s2], axis=1)\n        tm.assert_index_equal(result.columns, Index([\"A\", 0], dtype=\"object\"))\n\n        # must reindex, #2603\n        s = Series(randn(3), index=[\"c\", \"a\", \"b\"], name=\"A\")\n        s2 = Series(randn(4), index=[\"d\", \"a\", \"b\", \"c\"], name=\"B\")\n        result = concat([s, s2], axis=1, sort=sort)\n        expected = DataFrame({\"A\": s, \"B\": s2})\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1664,
        "end_line": 1694,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_series_axis1_names_applied#1696",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_series_axis1_names_applied(self)",
        "snippet": "    def test_concat_series_axis1_names_applied(self):\n        # ensure names argument is not ignored on axis=1, #23490\n        s = Series([1, 2, 3])\n        s2 = Series([4, 5, 6])\n        result = concat([s, s2], axis=1, keys=[\"a\", \"b\"], names=[\"A\"])\n        expected = DataFrame(\n            [[1, 4], [2, 5], [3, 6]], columns=pd.Index([\"a\", \"b\"], name=\"A\")\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = concat([s, s2], axis=1, keys=[(\"a\", 1), (\"b\", 2)], names=[\"A\", \"B\"])\n        expected = DataFrame(\n            [[1, 4], [2, 5], [3, 6]],\n            columns=MultiIndex.from_tuples([(\"a\", 1), (\"b\", 2)], names=[\"A\", \"B\"]),\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1696,
        "end_line": 1711,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_single_with_key#1713",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_single_with_key(self)",
        "snippet": "    def test_concat_single_with_key(self):\n        df = DataFrame(np.random.randn(10, 4))\n\n        result = concat([df], keys=[\"foo\"])\n        expected = concat([df, df], keys=[\"foo\", \"bar\"])\n        tm.assert_frame_equal(result, expected[:10])",
        "begin_line": 1713,
        "end_line": 1718,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_exclude_none#1720",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_exclude_none(self)",
        "snippet": "    def test_concat_exclude_none(self):\n        df = DataFrame(np.random.randn(10, 4))\n\n        pieces = [df[:5], None, None, df[5:]]\n        result = concat(pieces)\n        tm.assert_frame_equal(result, df)\n        with pytest.raises(ValueError, match=\"All objects passed were None\"):\n            concat([None, None])",
        "begin_line": 1720,
        "end_line": 1727,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_datetime64_block#1729",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_datetime64_block(self)",
        "snippet": "    def test_concat_datetime64_block(self):\n        from pandas.core.indexes.datetimes import date_range\n\n        rng = date_range(\"1/1/2000\", periods=10)\n\n        df = DataFrame({\"time\": rng})\n\n        result = concat([df, df])\n        assert (result.iloc[:10][\"time\"] == rng).all()\n        assert (result.iloc[10:][\"time\"] == rng).all()",
        "begin_line": 1729,
        "end_line": 1738,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_timedelta64_block#1740",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_timedelta64_block(self)",
        "snippet": "    def test_concat_timedelta64_block(self):\n        from pandas import to_timedelta\n\n        rng = to_timedelta(np.arange(10), unit=\"s\")\n\n        df = DataFrame({\"time\": rng})\n\n        result = concat([df, df])\n        assert (result.iloc[:10][\"time\"] == rng).all()\n        assert (result.iloc[10:][\"time\"] == rng).all()",
        "begin_line": 1740,
        "end_line": 1749,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_keys_with_none#1751",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_keys_with_none(self)",
        "snippet": "    def test_concat_keys_with_none(self):\n        # #1649\n        df0 = DataFrame([[10, 20, 30], [10, 20, 30], [10, 20, 30]])\n\n        result = concat(dict(a=None, b=df0, c=df0[:2], d=df0[:1], e=df0))\n        expected = concat(dict(b=df0, c=df0[:2], d=df0[:1], e=df0))\n        tm.assert_frame_equal(result, expected)\n\n        result = concat(\n            [None, df0, df0[:2], df0[:1], df0], keys=[\"a\", \"b\", \"c\", \"d\", \"e\"]\n        )\n        expected = concat([df0, df0[:2], df0[:1], df0], keys=[\"b\", \"c\", \"d\", \"e\"])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1751,
        "end_line": 1763,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_bug_1719#1765",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_bug_1719(self)",
        "snippet": "    def test_concat_bug_1719(self):\n        ts1 = tm.makeTimeSeries()\n        ts2 = tm.makeTimeSeries()[::2]\n\n        # to join with union\n        # these two are of different length!\n        left = concat([ts1, ts2], join=\"outer\", axis=1)\n        right = concat([ts2, ts1], join=\"outer\", axis=1)\n\n        assert len(left) == len(right)",
        "begin_line": 1765,
        "end_line": 1774,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_bug_2972#1776",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_bug_2972(self)",
        "snippet": "    def test_concat_bug_2972(self):\n        ts0 = Series(np.zeros(5))\n        ts1 = Series(np.ones(5))\n        ts0.name = ts1.name = \"same name\"\n        result = concat([ts0, ts1], axis=1)\n\n        expected = DataFrame({0: ts0, 1: ts1})\n        expected.columns = [\"same name\", \"same name\"]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1776,
        "end_line": 1784,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_bug_3602#1786",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_bug_3602(self)",
        "snippet": "    def test_concat_bug_3602(self):\n\n        # GH 3602, duplicate columns\n        df1 = DataFrame(\n            {\n                \"firmNo\": [0, 0, 0, 0],\n                \"prc\": [6, 6, 6, 6],\n                \"stringvar\": [\"rrr\", \"rrr\", \"rrr\", \"rrr\"],\n            }\n        )\n        df2 = DataFrame(\n            {\"C\": [9, 10, 11, 12], \"misc\": [1, 2, 3, 4], \"prc\": [6, 6, 6, 6]}\n        )\n        expected = DataFrame(\n            [\n                [0, 6, \"rrr\", 9, 1, 6],\n                [0, 6, \"rrr\", 10, 2, 6],\n                [0, 6, \"rrr\", 11, 3, 6],\n                [0, 6, \"rrr\", 12, 4, 6],\n            ]\n        )\n        expected.columns = [\"firmNo\", \"prc\", \"stringvar\", \"C\", \"misc\", \"prc\"]\n\n        result = concat([df1, df2], axis=1)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1786,
        "end_line": 1810,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_inner_join_empty#1812",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_inner_join_empty(self)",
        "snippet": "    def test_concat_inner_join_empty(self):\n        # GH 15328\n        df_empty = pd.DataFrame()\n        df_a = pd.DataFrame({\"a\": [1, 2]}, index=[0, 1], dtype=\"int64\")\n        df_expected = pd.DataFrame({\"a\": []}, index=[], dtype=\"int64\")\n\n        for how, expected in [(\"inner\", df_expected), (\"outer\", df_a)]:\n            result = pd.concat([df_a, df_empty], axis=1, join=how)\n            tm.assert_frame_equal(result, expected)",
        "begin_line": 1812,
        "end_line": 1820,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_series_axis1_same_names_ignore_index#1822",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_series_axis1_same_names_ignore_index(self)",
        "snippet": "    def test_concat_series_axis1_same_names_ignore_index(self):\n        dates = date_range(\"01-Jan-2013\", \"01-Jan-2014\", freq=\"MS\")[0:-1]\n        s1 = Series(randn(len(dates)), index=dates, name=\"value\")\n        s2 = Series(randn(len(dates)), index=dates, name=\"value\")\n\n        result = concat([s1, s2], axis=1, ignore_index=True)\n        expected = Index([0, 1])\n\n        tm.assert_index_equal(result.columns, expected)",
        "begin_line": 1822,
        "end_line": 1830,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_iterables#1832",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_iterables(self)",
        "snippet": "    def test_concat_iterables(self):\n        # GH8645 check concat works with tuples, list, generators, and weird\n        # stuff like deque and custom iterables\n        df1 = DataFrame([1, 2, 3])\n        df2 = DataFrame([4, 5, 6])\n        expected = DataFrame([1, 2, 3, 4, 5, 6])\n        tm.assert_frame_equal(concat((df1, df2), ignore_index=True), expected)\n        tm.assert_frame_equal(concat([df1, df2], ignore_index=True), expected)\n        tm.assert_frame_equal(\n            concat((df for df in (df1, df2)), ignore_index=True), expected\n        )\n        tm.assert_frame_equal(concat(deque((df1, df2)), ignore_index=True), expected)\n\n        class CustomIterator1:\n            def __len__(self) -> int:\n                return 2\n\n            def __getitem__(self, index):\n                try:\n                    return {0: df1, 1: df2}[index]\n                except KeyError:\n                    raise IndexError\n\n        tm.assert_frame_equal(pd.concat(CustomIterator1(), ignore_index=True), expected)\n\n        class CustomIterator2(abc.Iterable):\n            def __iter__(self):\n                yield df1\n                yield df2\n\n        tm.assert_frame_equal(pd.concat(CustomIterator2(), ignore_index=True), expected)",
        "begin_line": 1832,
        "end_line": 1862,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.CustomIterator1.test_concat_iterables#1832",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.CustomIterator1",
        "signature": "pandas.tests.reshape.test_concat.CustomIterator1.test_concat_iterables(self)",
        "snippet": "    def test_concat_iterables(self):\n        # GH8645 check concat works with tuples, list, generators, and weird\n        # stuff like deque and custom iterables\n        df1 = DataFrame([1, 2, 3])\n        df2 = DataFrame([4, 5, 6])\n        expected = DataFrame([1, 2, 3, 4, 5, 6])\n        tm.assert_frame_equal(concat((df1, df2), ignore_index=True), expected)\n        tm.assert_frame_equal(concat([df1, df2], ignore_index=True), expected)\n        tm.assert_frame_equal(\n            concat((df for df in (df1, df2)), ignore_index=True), expected\n        )\n        tm.assert_frame_equal(concat(deque((df1, df2)), ignore_index=True), expected)\n\n        class CustomIterator1:\n            def __len__(self) -> int:\n                return 2\n\n            def __getitem__(self, index):\n                try:\n                    return {0: df1, 1: df2}[index]\n                except KeyError:\n                    raise IndexError\n\n        tm.assert_frame_equal(pd.concat(CustomIterator1(), ignore_index=True), expected)\n\n        class CustomIterator2(abc.Iterable):\n            def __iter__(self):\n                yield df1\n                yield df2\n\n        tm.assert_frame_equal(pd.concat(CustomIterator2(), ignore_index=True), expected)",
        "begin_line": 1832,
        "end_line": 1862,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.CustomIterator1.__len__#1846",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.CustomIterator1",
        "signature": "pandas.tests.reshape.test_concat.CustomIterator1.__len__(self)",
        "snippet": "            def __len__(self) -> int:\n                return 2",
        "begin_line": 1846,
        "end_line": 1847,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.CustomIterator1.__getitem__#1849",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.CustomIterator1",
        "signature": "pandas.tests.reshape.test_concat.CustomIterator1.__getitem__(self, index)",
        "snippet": "            def __getitem__(self, index):\n                try:\n                    return {0: df1, 1: df2}[index]\n                except KeyError:\n                    raise IndexError",
        "begin_line": 1849,
        "end_line": 1853,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.CustomIterator2.test_concat_iterables#1832",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.CustomIterator2",
        "signature": "pandas.tests.reshape.test_concat.CustomIterator2.test_concat_iterables(self)",
        "snippet": "    def test_concat_iterables(self):\n        # GH8645 check concat works with tuples, list, generators, and weird\n        # stuff like deque and custom iterables\n        df1 = DataFrame([1, 2, 3])\n        df2 = DataFrame([4, 5, 6])\n        expected = DataFrame([1, 2, 3, 4, 5, 6])\n        tm.assert_frame_equal(concat((df1, df2), ignore_index=True), expected)\n        tm.assert_frame_equal(concat([df1, df2], ignore_index=True), expected)\n        tm.assert_frame_equal(\n            concat((df for df in (df1, df2)), ignore_index=True), expected\n        )\n        tm.assert_frame_equal(concat(deque((df1, df2)), ignore_index=True), expected)\n\n        class CustomIterator1:\n            def __len__(self) -> int:\n                return 2\n\n            def __getitem__(self, index):\n                try:\n                    return {0: df1, 1: df2}[index]\n                except KeyError:\n                    raise IndexError\n\n        tm.assert_frame_equal(pd.concat(CustomIterator1(), ignore_index=True), expected)\n\n        class CustomIterator2(abc.Iterable):\n            def __iter__(self):\n                yield df1\n                yield df2\n\n        tm.assert_frame_equal(pd.concat(CustomIterator2(), ignore_index=True), expected)",
        "begin_line": 1832,
        "end_line": 1862,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.CustomIterator2.__iter__#1858",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.CustomIterator2",
        "signature": "pandas.tests.reshape.test_concat.CustomIterator2.__iter__(self)",
        "snippet": "            def __iter__(self):\n                yield df1\n                yield df2",
        "begin_line": 1858,
        "end_line": 1860,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_invalid#1864",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_invalid(self)",
        "snippet": "    def test_concat_invalid(self):\n\n        # trying to concat a ndframe with a non-ndframe\n        df1 = tm.makeCustomDataframe(10, 2)\n        msg = (\n            \"cannot concatenate object of type '{}'; \"\n            \"only Series and DataFrame objs are valid\"\n        )\n        for obj in [1, dict(), [1, 2], (1, 2)]:\n            with pytest.raises(TypeError, match=msg.format(type(obj))):\n                concat([df1, obj])",
        "begin_line": 1864,
        "end_line": 1874,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_invalid_first_argument#1876",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_invalid_first_argument(self)",
        "snippet": "    def test_concat_invalid_first_argument(self):\n        df1 = tm.makeCustomDataframe(10, 2)\n        df2 = tm.makeCustomDataframe(10, 2)\n        msg = (\n            \"first argument must be an iterable of pandas \"\n            'objects, you passed an object of type \"DataFrame\"'\n        )\n        with pytest.raises(TypeError, match=msg):\n            concat(df1, df2)\n\n        # generator ok though\n        concat(DataFrame(np.random.rand(5, 5)) for _ in range(3))\n\n        # text reader ok\n        # GH6583\n        data = \"\"\"index,A,B,C,D\nfoo,2,3,4,5\nbar,7,8,9,10\nbaz,12,13,14,15\nqux,12,13,14,15\nfoo2,12,13,14,15\nbar2,12,13,14,15\n\"\"\"\n\n        reader = read_csv(StringIO(data), chunksize=1)\n        result = concat(reader, ignore_index=True)\n        expected = read_csv(StringIO(data))\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1876,
        "end_line": 1903,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_NaT_series#1905",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_NaT_series(self)",
        "snippet": "    def test_concat_NaT_series(self):\n        # GH 11693\n        # test for merging NaT series with datetime series.\n        x = Series(\n            date_range(\"20151124 08:00\", \"20151124 09:00\", freq=\"1h\", tz=\"US/Eastern\")\n        )\n        y = Series(pd.NaT, index=[0, 1], dtype=\"datetime64[ns, US/Eastern]\")\n        expected = Series([x[0], x[1], pd.NaT, pd.NaT])\n\n        result = concat([x, y], ignore_index=True)\n        tm.assert_series_equal(result, expected)\n\n        # all NaT with tz\n        expected = Series(pd.NaT, index=range(4), dtype=\"datetime64[ns, US/Eastern]\")\n        result = pd.concat([y, y], ignore_index=True)\n        tm.assert_series_equal(result, expected)\n\n        # without tz\n        x = pd.Series(pd.date_range(\"20151124 08:00\", \"20151124 09:00\", freq=\"1h\"))\n        y = pd.Series(pd.date_range(\"20151124 10:00\", \"20151124 11:00\", freq=\"1h\"))\n        y[:] = pd.NaT\n        expected = pd.Series([x[0], x[1], pd.NaT, pd.NaT])\n        result = pd.concat([x, y], ignore_index=True)\n        tm.assert_series_equal(result, expected)\n\n        # all NaT without tz\n        x[:] = pd.NaT\n        expected = pd.Series(pd.NaT, index=range(4), dtype=\"datetime64[ns]\")\n        result = pd.concat([x, y], ignore_index=True)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1905,
        "end_line": 1934,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_tz_frame#1936",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_tz_frame(self)",
        "snippet": "    def test_concat_tz_frame(self):\n        df2 = DataFrame(\n            dict(\n                A=pd.Timestamp(\"20130102\", tz=\"US/Eastern\"),\n                B=pd.Timestamp(\"20130603\", tz=\"CET\"),\n            ),\n            index=range(5),\n        )\n\n        # concat\n        df3 = pd.concat([df2.A.to_frame(), df2.B.to_frame()], axis=1)\n        tm.assert_frame_equal(df2, df3)",
        "begin_line": 1936,
        "end_line": 1947,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_tz_series#1949",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_tz_series(self)",
        "snippet": "    def test_concat_tz_series(self):\n        # gh-11755: tz and no tz\n        x = Series(date_range(\"20151124 08:00\", \"20151124 09:00\", freq=\"1h\", tz=\"UTC\"))\n        y = Series(date_range(\"2012-01-01\", \"2012-01-02\"))\n        expected = Series([x[0], x[1], y[0], y[1]], dtype=\"object\")\n        result = concat([x, y], ignore_index=True)\n        tm.assert_series_equal(result, expected)\n\n        # gh-11887: concat tz and object\n        x = Series(date_range(\"20151124 08:00\", \"20151124 09:00\", freq=\"1h\", tz=\"UTC\"))\n        y = Series([\"a\", \"b\"])\n        expected = Series([x[0], x[1], y[0], y[1]], dtype=\"object\")\n        result = concat([x, y], ignore_index=True)\n        tm.assert_series_equal(result, expected)\n\n        # see gh-12217 and gh-12306\n        # Concatenating two UTC times\n        first = pd.DataFrame([[datetime(2016, 1, 1)]])\n        first[0] = first[0].dt.tz_localize(\"UTC\")\n\n        second = pd.DataFrame([[datetime(2016, 1, 2)]])\n        second[0] = second[0].dt.tz_localize(\"UTC\")\n\n        result = pd.concat([first, second])\n        assert result[0].dtype == \"datetime64[ns, UTC]\"\n\n        # Concatenating two London times\n        first = pd.DataFrame([[datetime(2016, 1, 1)]])\n        first[0] = first[0].dt.tz_localize(\"Europe/London\")\n\n        second = pd.DataFrame([[datetime(2016, 1, 2)]])\n        second[0] = second[0].dt.tz_localize(\"Europe/London\")\n\n        result = pd.concat([first, second])\n        assert result[0].dtype == \"datetime64[ns, Europe/London]\"\n\n        # Concatenating 2+1 London times\n        first = pd.DataFrame([[datetime(2016, 1, 1)], [datetime(2016, 1, 2)]])\n        first[0] = first[0].dt.tz_localize(\"Europe/London\")\n\n        second = pd.DataFrame([[datetime(2016, 1, 3)]])\n        second[0] = second[0].dt.tz_localize(\"Europe/London\")\n\n        result = pd.concat([first, second])\n        assert result[0].dtype == \"datetime64[ns, Europe/London]\"\n\n        # Concat'ing 1+2 London times\n        first = pd.DataFrame([[datetime(2016, 1, 1)]])\n        first[0] = first[0].dt.tz_localize(\"Europe/London\")\n\n        second = pd.DataFrame([[datetime(2016, 1, 2)], [datetime(2016, 1, 3)]])\n        second[0] = second[0].dt.tz_localize(\"Europe/London\")\n\n        result = pd.concat([first, second])\n        assert result[0].dtype == \"datetime64[ns, Europe/London]\"",
        "begin_line": 1949,
        "end_line": 2003,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_tz_series_with_datetimelike#2005",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_tz_series_with_datetimelike(self)",
        "snippet": "    def test_concat_tz_series_with_datetimelike(self):\n        # see gh-12620: tz and timedelta\n        x = [\n            pd.Timestamp(\"2011-01-01\", tz=\"US/Eastern\"),\n            pd.Timestamp(\"2011-02-01\", tz=\"US/Eastern\"),\n        ]\n        y = [pd.Timedelta(\"1 day\"), pd.Timedelta(\"2 day\")]\n        result = concat([pd.Series(x), pd.Series(y)], ignore_index=True)\n        tm.assert_series_equal(result, pd.Series(x + y, dtype=\"object\"))\n\n        # tz and period\n        y = [pd.Period(\"2011-03\", freq=\"M\"), pd.Period(\"2011-04\", freq=\"M\")]\n        result = concat([pd.Series(x), pd.Series(y)], ignore_index=True)\n        tm.assert_series_equal(result, pd.Series(x + y, dtype=\"object\"))",
        "begin_line": 2005,
        "end_line": 2018,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_tz_series_tzlocal#2020",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_tz_series_tzlocal(self)",
        "snippet": "    def test_concat_tz_series_tzlocal(self):\n        # see gh-13583\n        x = [\n            pd.Timestamp(\"2011-01-01\", tz=dateutil.tz.tzlocal()),\n            pd.Timestamp(\"2011-02-01\", tz=dateutil.tz.tzlocal()),\n        ]\n        y = [\n            pd.Timestamp(\"2012-01-01\", tz=dateutil.tz.tzlocal()),\n            pd.Timestamp(\"2012-02-01\", tz=dateutil.tz.tzlocal()),\n        ]\n\n        result = concat([pd.Series(x), pd.Series(y)], ignore_index=True)\n        tm.assert_series_equal(result, pd.Series(x + y))\n        assert result.dtype == \"datetime64[ns, tzlocal()]\"",
        "begin_line": 2020,
        "end_line": 2033,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_NaT_dataframes_all_NaT_axis_0#2038",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_NaT_dataframes_all_NaT_axis_0(self, tz1, tz2, s)",
        "snippet": "    def test_concat_NaT_dataframes_all_NaT_axis_0(self, tz1, tz2, s):\n        # GH 12396\n\n        # tz-naive\n        first = pd.DataFrame([[pd.NaT], [pd.NaT]]).apply(\n            lambda x: x.dt.tz_localize(tz1)\n        )\n        second = pd.DataFrame([s]).apply(lambda x: x.dt.tz_localize(tz2))\n\n        result = pd.concat([first, second], axis=0)\n        expected = pd.DataFrame(pd.Series([pd.NaT, pd.NaT, s], index=[0, 1, 0]))\n        expected = expected.apply(lambda x: x.dt.tz_localize(tz2))\n        if tz1 != tz2:\n            expected = expected.astype(object)\n\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2038,
        "end_line": 2053,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_NaT_dataframes_all_NaT_axis_1#2057",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_NaT_dataframes_all_NaT_axis_1(self, tz1, tz2)",
        "snippet": "    def test_concat_NaT_dataframes_all_NaT_axis_1(self, tz1, tz2):\n        # GH 12396\n\n        first = pd.DataFrame(pd.Series([pd.NaT, pd.NaT]).dt.tz_localize(tz1))\n        second = pd.DataFrame(pd.Series([pd.NaT]).dt.tz_localize(tz2), columns=[1])\n        expected = pd.DataFrame(\n            {\n                0: pd.Series([pd.NaT, pd.NaT]).dt.tz_localize(tz1),\n                1: pd.Series([pd.NaT, pd.NaT]).dt.tz_localize(tz2),\n            }\n        )\n        result = pd.concat([first, second], axis=1)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2057,
        "end_line": 2069,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_NaT_series_dataframe_all_NaT#2073",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_NaT_series_dataframe_all_NaT(self, tz1, tz2)",
        "snippet": "    def test_concat_NaT_series_dataframe_all_NaT(self, tz1, tz2):\n        # GH 12396\n\n        # tz-naive\n        first = pd.Series([pd.NaT, pd.NaT]).dt.tz_localize(tz1)\n        second = pd.DataFrame(\n            [\n                [pd.Timestamp(\"2015/01/01\", tz=tz2)],\n                [pd.Timestamp(\"2016/01/01\", tz=tz2)],\n            ],\n            index=[2, 3],\n        )\n\n        expected = pd.DataFrame(\n            [\n                pd.NaT,\n                pd.NaT,\n                pd.Timestamp(\"2015/01/01\", tz=tz2),\n                pd.Timestamp(\"2016/01/01\", tz=tz2),\n            ]\n        )\n        if tz1 != tz2:\n            expected = expected.astype(object)\n\n        result = pd.concat([first, second])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2073,
        "end_line": 2098,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_NaT_dataframes#2101",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_NaT_dataframes(self, tz)",
        "snippet": "    def test_concat_NaT_dataframes(self, tz):\n        # GH 12396\n\n        first = pd.DataFrame([[pd.NaT], [pd.NaT]])\n        first = first.apply(lambda x: x.dt.tz_localize(tz))\n        second = pd.DataFrame(\n            [[pd.Timestamp(\"2015/01/01\", tz=tz)], [pd.Timestamp(\"2016/01/01\", tz=tz)]],\n            index=[2, 3],\n        )\n        expected = pd.DataFrame(\n            [\n                pd.NaT,\n                pd.NaT,\n                pd.Timestamp(\"2015/01/01\", tz=tz),\n                pd.Timestamp(\"2016/01/01\", tz=tz),\n            ]\n        )\n\n        result = pd.concat([first, second], axis=0)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2101,
        "end_line": 2120,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_period_series#2122",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_period_series(self)",
        "snippet": "    def test_concat_period_series(self):\n        x = Series(pd.PeriodIndex([\"2015-11-01\", \"2015-12-01\"], freq=\"D\"))\n        y = Series(pd.PeriodIndex([\"2015-10-01\", \"2016-01-01\"], freq=\"D\"))\n        expected = Series([x[0], x[1], y[0], y[1]], dtype=\"Period[D]\")\n        result = concat([x, y], ignore_index=True)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 2122,
        "end_line": 2127,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_period_multiple_freq_series#2129",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_period_multiple_freq_series(self)",
        "snippet": "    def test_concat_period_multiple_freq_series(self):\n        x = Series(pd.PeriodIndex([\"2015-11-01\", \"2015-12-01\"], freq=\"D\"))\n        y = Series(pd.PeriodIndex([\"2015-10-01\", \"2016-01-01\"], freq=\"M\"))\n        expected = Series([x[0], x[1], y[0], y[1]], dtype=\"object\")\n        result = concat([x, y], ignore_index=True)\n        tm.assert_series_equal(result, expected)\n        assert result.dtype == \"object\"",
        "begin_line": 2129,
        "end_line": 2135,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_period_other_series#2137",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_period_other_series(self)",
        "snippet": "    def test_concat_period_other_series(self):\n        x = Series(pd.PeriodIndex([\"2015-11-01\", \"2015-12-01\"], freq=\"D\"))\n        y = Series(pd.PeriodIndex([\"2015-11-01\", \"2015-12-01\"], freq=\"M\"))\n        expected = Series([x[0], x[1], y[0], y[1]], dtype=\"object\")\n        result = concat([x, y], ignore_index=True)\n        tm.assert_series_equal(result, expected)\n        assert result.dtype == \"object\"\n\n        # non-period\n        x = Series(pd.PeriodIndex([\"2015-11-01\", \"2015-12-01\"], freq=\"D\"))\n        y = Series(pd.DatetimeIndex([\"2015-11-01\", \"2015-12-01\"]))\n        expected = Series([x[0], x[1], y[0], y[1]], dtype=\"object\")\n        result = concat([x, y], ignore_index=True)\n        tm.assert_series_equal(result, expected)\n        assert result.dtype == \"object\"\n\n        x = Series(pd.PeriodIndex([\"2015-11-01\", \"2015-12-01\"], freq=\"D\"))\n        y = Series([\"A\", \"B\"])\n        expected = Series([x[0], x[1], y[0], y[1]], dtype=\"object\")\n        result = concat([x, y], ignore_index=True)\n        tm.assert_series_equal(result, expected)\n        assert result.dtype == \"object\"",
        "begin_line": 2137,
        "end_line": 2158,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_empty_series#2160",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_empty_series(self)",
        "snippet": "    def test_concat_empty_series(self):\n        # GH 11082\n        s1 = pd.Series([1, 2, 3], name=\"x\")\n        s2 = pd.Series(name=\"y\", dtype=\"float64\")\n        res = pd.concat([s1, s2], axis=1)\n        exp = pd.DataFrame(\n            {\"x\": [1, 2, 3], \"y\": [np.nan, np.nan, np.nan]},\n            index=pd.Index([0, 1, 2], dtype=\"O\"),\n        )\n        tm.assert_frame_equal(res, exp)\n\n        s1 = pd.Series([1, 2, 3], name=\"x\")\n        s2 = pd.Series(name=\"y\", dtype=\"float64\")\n        res = pd.concat([s1, s2], axis=0)\n        # name will be reset\n        exp = pd.Series([1, 2, 3])\n        tm.assert_series_equal(res, exp)\n\n        # empty Series with no name\n        s1 = pd.Series([1, 2, 3], name=\"x\")\n        s2 = pd.Series(name=None, dtype=\"float64\")\n        res = pd.concat([s1, s2], axis=1)\n        exp = pd.DataFrame(\n            {\"x\": [1, 2, 3], 0: [np.nan, np.nan, np.nan]},\n            columns=[\"x\", 0],\n            index=pd.Index([0, 1, 2], dtype=\"O\"),\n        )\n        tm.assert_frame_equal(res, exp)",
        "begin_line": 2160,
        "end_line": 2187,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_empty_series_timelike#2191",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_empty_series_timelike(self, tz, values)",
        "snippet": "    def test_concat_empty_series_timelike(self, tz, values):\n        # GH 18447\n\n        first = Series([], dtype=\"M8[ns]\").dt.tz_localize(tz)\n        dtype = None if values else np.float64\n        second = Series(values, dtype=dtype)\n\n        expected = DataFrame(\n            {\n                0: pd.Series([pd.NaT] * len(values), dtype=\"M8[ns]\").dt.tz_localize(tz),\n                1: values,\n            }\n        )\n        result = concat([first, second], axis=1)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2191,
        "end_line": 2205,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_default_index#2207",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_default_index(self)",
        "snippet": "    def test_default_index(self):\n        # is_series and ignore_index\n        s1 = pd.Series([1, 2, 3], name=\"x\")\n        s2 = pd.Series([4, 5, 6], name=\"y\")\n        res = pd.concat([s1, s2], axis=1, ignore_index=True)\n        assert isinstance(res.columns, pd.RangeIndex)\n        exp = pd.DataFrame([[1, 4], [2, 5], [3, 6]])\n        # use check_index_type=True to check the result have\n        # RangeIndex (default index)\n        tm.assert_frame_equal(res, exp, check_index_type=True, check_column_type=True)\n\n        # is_series and all inputs have no names\n        s1 = pd.Series([1, 2, 3])\n        s2 = pd.Series([4, 5, 6])\n        res = pd.concat([s1, s2], axis=1, ignore_index=False)\n        assert isinstance(res.columns, pd.RangeIndex)\n        exp = pd.DataFrame([[1, 4], [2, 5], [3, 6]])\n        exp.columns = pd.RangeIndex(2)\n        tm.assert_frame_equal(res, exp, check_index_type=True, check_column_type=True)\n\n        # is_dataframe and ignore_index\n        df1 = pd.DataFrame({\"A\": [1, 2], \"B\": [5, 6]})\n        df2 = pd.DataFrame({\"A\": [3, 4], \"B\": [7, 8]})\n\n        res = pd.concat([df1, df2], axis=0, ignore_index=True)\n        exp = pd.DataFrame([[1, 5], [2, 6], [3, 7], [4, 8]], columns=[\"A\", \"B\"])\n        tm.assert_frame_equal(res, exp, check_index_type=True, check_column_type=True)\n\n        res = pd.concat([df1, df2], axis=1, ignore_index=True)\n        exp = pd.DataFrame([[1, 5, 3, 7], [2, 6, 4, 8]])\n        tm.assert_frame_equal(res, exp, check_index_type=True, check_column_type=True)",
        "begin_line": 2207,
        "end_line": 2237,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_multiindex_rangeindex#2239",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_multiindex_rangeindex(self)",
        "snippet": "    def test_concat_multiindex_rangeindex(self):\n        # GH13542\n        # when multi-index levels are RangeIndex objects\n        # there is a bug in concat with objects of len 1\n\n        df = DataFrame(np.random.randn(9, 2))\n        df.index = MultiIndex(\n            levels=[pd.RangeIndex(3), pd.RangeIndex(3)],\n            codes=[np.repeat(np.arange(3), 3), np.tile(np.arange(3), 3)],\n        )\n\n        res = concat([df.iloc[[2, 3, 4], :], df.iloc[[5], :]])\n        exp = df.iloc[[2, 3, 4, 5], :]\n        tm.assert_frame_equal(res, exp)",
        "begin_line": 2239,
        "end_line": 2252,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_multiindex_dfs_with_deepcopy#2254",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_multiindex_dfs_with_deepcopy(self)",
        "snippet": "    def test_concat_multiindex_dfs_with_deepcopy(self):\n        # GH 9967\n        from copy import deepcopy\n\n        example_multiindex1 = pd.MultiIndex.from_product([[\"a\"], [\"b\"]])\n        example_dataframe1 = pd.DataFrame([0], index=example_multiindex1)\n\n        example_multiindex2 = pd.MultiIndex.from_product([[\"a\"], [\"c\"]])\n        example_dataframe2 = pd.DataFrame([1], index=example_multiindex2)\n\n        example_dict = {\"s1\": example_dataframe1, \"s2\": example_dataframe2}\n        expected_index = pd.MultiIndex(\n            levels=[[\"s1\", \"s2\"], [\"a\"], [\"b\", \"c\"]],\n            codes=[[0, 1], [0, 0], [0, 1]],\n            names=[\"testname\", None, None],\n        )\n        expected = pd.DataFrame([[0], [1]], index=expected_index)\n        result_copy = pd.concat(deepcopy(example_dict), names=[\"testname\"])\n        tm.assert_frame_equal(result_copy, expected)\n        result_no_copy = pd.concat(example_dict, names=[\"testname\"])\n        tm.assert_frame_equal(result_no_copy, expected)",
        "begin_line": 2254,
        "end_line": 2274,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_categorical_concat_append#2276",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_categorical_concat_append(self)",
        "snippet": "    def test_categorical_concat_append(self):\n        cat = Categorical([\"a\", \"b\"], categories=[\"a\", \"b\"])\n        vals = [1, 2]\n        df = DataFrame({\"cats\": cat, \"vals\": vals})\n        cat2 = Categorical([\"a\", \"b\", \"a\", \"b\"], categories=[\"a\", \"b\"])\n        vals2 = [1, 2, 1, 2]\n        exp = DataFrame({\"cats\": cat2, \"vals\": vals2}, index=Index([0, 1, 0, 1]))\n\n        tm.assert_frame_equal(pd.concat([df, df]), exp)\n        tm.assert_frame_equal(df.append(df), exp)\n\n        # GH 13524 can concat different categories\n        cat3 = Categorical([\"a\", \"b\"], categories=[\"a\", \"b\", \"c\"])\n        vals3 = [1, 2]\n        df_different_categories = DataFrame({\"cats\": cat3, \"vals\": vals3})\n\n        res = pd.concat([df, df_different_categories], ignore_index=True)\n        exp = DataFrame({\"cats\": list(\"abab\"), \"vals\": [1, 2, 1, 2]})\n        tm.assert_frame_equal(res, exp)\n\n        res = df.append(df_different_categories, ignore_index=True)\n        tm.assert_frame_equal(res, exp)",
        "begin_line": 2276,
        "end_line": 2297,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_categorical_concat_dtypes#2299",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_categorical_concat_dtypes(self)",
        "snippet": "    def test_categorical_concat_dtypes(self):\n\n        # GH8143\n        index = [\"cat\", \"obj\", \"num\"]\n        cat = Categorical([\"a\", \"b\", \"c\"])\n        obj = Series([\"a\", \"b\", \"c\"])\n        num = Series([1, 2, 3])\n        df = pd.concat([Series(cat), obj, num], axis=1, keys=index)\n\n        result = df.dtypes == \"object\"\n        expected = Series([False, True, False], index=index)\n        tm.assert_series_equal(result, expected)\n\n        result = df.dtypes == \"int64\"\n        expected = Series([False, False, True], index=index)\n        tm.assert_series_equal(result, expected)\n\n        result = df.dtypes == \"category\"\n        expected = Series([True, False, False], index=index)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 2299,
        "end_line": 2318,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_categorical_concat#2320",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_categorical_concat(self, sort)",
        "snippet": "    def test_categorical_concat(self, sort):\n        # See GH 10177\n        df1 = DataFrame(\n            np.arange(18, dtype=\"int64\").reshape(6, 3), columns=[\"a\", \"b\", \"c\"]\n        )\n\n        df2 = DataFrame(np.arange(14, dtype=\"int64\").reshape(7, 2), columns=[\"a\", \"c\"])\n\n        cat_values = [\"one\", \"one\", \"two\", \"one\", \"two\", \"two\", \"one\"]\n        df2[\"h\"] = Series(Categorical(cat_values))\n\n        res = pd.concat((df1, df2), axis=0, ignore_index=True, sort=sort)\n        exp = DataFrame(\n            {\n                \"a\": [0, 3, 6, 9, 12, 15, 0, 2, 4, 6, 8, 10, 12],\n                \"b\": [\n                    1,\n                    4,\n                    7,\n                    10,\n                    13,\n                    16,\n                    np.nan,\n                    np.nan,\n                    np.nan,\n                    np.nan,\n                    np.nan,\n                    np.nan,\n                    np.nan,\n                ],\n                \"c\": [2, 5, 8, 11, 14, 17, 1, 3, 5, 7, 9, 11, 13],\n                \"h\": [None] * 6 + cat_values,\n            }\n        )\n        tm.assert_frame_equal(res, exp)",
        "begin_line": 2320,
        "end_line": 2354,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_categorical_concat_gh7864#2356",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_categorical_concat_gh7864(self)",
        "snippet": "    def test_categorical_concat_gh7864(self):\n        # GH 7864\n        # make sure ordering is preserved\n        df = DataFrame({\"id\": [1, 2, 3, 4, 5, 6], \"raw_grade\": list(\"abbaae\")})\n        df[\"grade\"] = Categorical(df[\"raw_grade\"])\n        df[\"grade\"].cat.set_categories([\"e\", \"a\", \"b\"])\n\n        df1 = df[0:3]\n        df2 = df[3:]\n\n        tm.assert_index_equal(df[\"grade\"].cat.categories, df1[\"grade\"].cat.categories)\n        tm.assert_index_equal(df[\"grade\"].cat.categories, df2[\"grade\"].cat.categories)\n\n        dfx = pd.concat([df1, df2])\n        tm.assert_index_equal(df[\"grade\"].cat.categories, dfx[\"grade\"].cat.categories)\n\n        dfa = df1.append(df2)\n        tm.assert_index_equal(df[\"grade\"].cat.categories, dfa[\"grade\"].cat.categories)",
        "begin_line": 2356,
        "end_line": 2373,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_categorical_concat_preserve#2375",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_categorical_concat_preserve(self)",
        "snippet": "    def test_categorical_concat_preserve(self):\n\n        # GH 8641  series concat not preserving category dtype\n        # GH 13524 can concat different categories\n        s = Series(list(\"abc\"), dtype=\"category\")\n        s2 = Series(list(\"abd\"), dtype=\"category\")\n\n        exp = Series(list(\"abcabd\"))\n        res = pd.concat([s, s2], ignore_index=True)\n        tm.assert_series_equal(res, exp)\n\n        exp = Series(list(\"abcabc\"), dtype=\"category\")\n        res = pd.concat([s, s], ignore_index=True)\n        tm.assert_series_equal(res, exp)\n\n        exp = Series(list(\"abcabc\"), index=[0, 1, 2, 0, 1, 2], dtype=\"category\")\n        res = pd.concat([s, s])\n        tm.assert_series_equal(res, exp)\n\n        a = Series(np.arange(6, dtype=\"int64\"))\n        b = Series(list(\"aabbca\"))\n\n        df2 = DataFrame({\"A\": a, \"B\": b.astype(CategoricalDtype(list(\"cab\")))})\n        res = pd.concat([df2, df2])\n        exp = DataFrame(\n            {\n                \"A\": pd.concat([a, a]),\n                \"B\": pd.concat([b, b]).astype(CategoricalDtype(list(\"cab\"))),\n            }\n        )\n        tm.assert_frame_equal(res, exp)",
        "begin_line": 2375,
        "end_line": 2405,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_categorical_index_preserver#2407",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_categorical_index_preserver(self)",
        "snippet": "    def test_categorical_index_preserver(self):\n\n        a = Series(np.arange(6, dtype=\"int64\"))\n        b = Series(list(\"aabbca\"))\n\n        df2 = DataFrame(\n            {\"A\": a, \"B\": b.astype(CategoricalDtype(list(\"cab\")))}\n        ).set_index(\"B\")\n        result = pd.concat([df2, df2])\n        expected = DataFrame(\n            {\n                \"A\": pd.concat([a, a]),\n                \"B\": pd.concat([b, b]).astype(CategoricalDtype(list(\"cab\"))),\n            }\n        ).set_index(\"B\")\n        tm.assert_frame_equal(result, expected)\n\n        # wrong categories\n        df3 = DataFrame(\n            {\"A\": a, \"B\": Categorical(b, categories=list(\"abe\"))}\n        ).set_index(\"B\")\n        msg = \"categories must match existing categories when appending\"\n        with pytest.raises(TypeError, match=msg):\n            pd.concat([df2, df3])",
        "begin_line": 2407,
        "end_line": 2430,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_categoricalindex#2432",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_categoricalindex(self)",
        "snippet": "    def test_concat_categoricalindex(self):\n        # GH 16111, categories that aren't lexsorted\n        categories = [9, 0, 1, 2, 3]\n\n        a = pd.Series(1, index=pd.CategoricalIndex([9, 0], categories=categories))\n        b = pd.Series(2, index=pd.CategoricalIndex([0, 1], categories=categories))\n        c = pd.Series(3, index=pd.CategoricalIndex([1, 2], categories=categories))\n\n        result = pd.concat([a, b, c], axis=1)\n\n        exp_idx = pd.CategoricalIndex([9, 0, 1, 2], categories=categories)\n        exp = pd.DataFrame(\n            {\n                0: [1, 1, np.nan, np.nan],\n                1: [np.nan, 2, 2, np.nan],\n                2: [np.nan, np.nan, 3, 3],\n            },\n            columns=[0, 1, 2],\n            index=exp_idx,\n        )\n        tm.assert_frame_equal(result, exp)",
        "begin_line": 2432,
        "end_line": 2452,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_order#2454",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_order(self)",
        "snippet": "    def test_concat_order(self):\n        # GH 17344\n        dfs = [pd.DataFrame(index=range(3), columns=[\"a\", 1, None])]\n        dfs += [\n            pd.DataFrame(index=range(3), columns=[None, 1, \"a\"]) for i in range(100)\n        ]\n\n        result = pd.concat(dfs, sort=True).columns\n        expected = dfs[0].columns\n        tm.assert_index_equal(result, expected)",
        "begin_line": 2454,
        "end_line": 2463,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_datetime_timezone#2465",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_datetime_timezone(self)",
        "snippet": "    def test_concat_datetime_timezone(self):\n        # GH 18523\n        idx1 = pd.date_range(\"2011-01-01\", periods=3, freq=\"H\", tz=\"Europe/Paris\")\n        idx2 = pd.date_range(start=idx1[0], end=idx1[-1], freq=\"H\")\n        df1 = pd.DataFrame({\"a\": [1, 2, 3]}, index=idx1)\n        df2 = pd.DataFrame({\"b\": [1, 2, 3]}, index=idx2)\n        result = pd.concat([df1, df2], axis=1)\n\n        exp_idx = (\n            DatetimeIndex(\n                [\n                    \"2011-01-01 00:00:00+01:00\",\n                    \"2011-01-01 01:00:00+01:00\",\n                    \"2011-01-01 02:00:00+01:00\",\n                ],\n                freq=\"H\",\n            )\n            .tz_convert(\"UTC\")\n            .tz_convert(\"Europe/Paris\")\n        )\n\n        expected = pd.DataFrame(\n            [[1, 1], [2, 2], [3, 3]], index=exp_idx, columns=[\"a\", \"b\"]\n        )\n\n        tm.assert_frame_equal(result, expected)\n\n        idx3 = pd.date_range(\"2011-01-01\", periods=3, freq=\"H\", tz=\"Asia/Tokyo\")\n        df3 = pd.DataFrame({\"b\": [1, 2, 3]}, index=idx3)\n        result = pd.concat([df1, df3], axis=1)\n\n        exp_idx = DatetimeIndex(\n            [\n                \"2010-12-31 15:00:00+00:00\",\n                \"2010-12-31 16:00:00+00:00\",\n                \"2010-12-31 17:00:00+00:00\",\n                \"2010-12-31 23:00:00+00:00\",\n                \"2011-01-01 00:00:00+00:00\",\n                \"2011-01-01 01:00:00+00:00\",\n            ]\n        )\n\n        expected = pd.DataFrame(\n            [\n                [np.nan, 1],\n                [np.nan, 2],\n                [np.nan, 3],\n                [1, np.nan],\n                [2, np.nan],\n                [3, np.nan],\n            ],\n            index=exp_idx,\n            columns=[\"a\", \"b\"],\n        )\n\n        tm.assert_frame_equal(result, expected)\n\n        # GH 13783: Concat after resample\n        result = pd.concat(\n            [df1.resample(\"H\").mean(), df2.resample(\"H\").mean()], sort=True\n        )\n        expected = pd.DataFrame(\n            {\"a\": [1, 2, 3] + [np.nan] * 3, \"b\": [np.nan] * 3 + [1, 2, 3]},\n            index=idx1.append(idx1),\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2465,
        "end_line": 2530,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_different_extension_dtypes_upcasts#2532",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_different_extension_dtypes_upcasts(self)",
        "snippet": "    def test_concat_different_extension_dtypes_upcasts(self):\n        a = pd.Series(pd.core.arrays.integer_array([1, 2]))\n        b = pd.Series(to_decimal([1, 2]))\n\n        result = pd.concat([a, b], ignore_index=True)\n        expected = pd.Series([1, 2, Decimal(1), Decimal(2)], dtype=object)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 2532,
        "end_line": 2538,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_odered_dict#2540",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat.TestConcatenate",
        "signature": "pandas.tests.reshape.test_concat.TestConcatenate.test_concat_odered_dict(self)",
        "snippet": "    def test_concat_odered_dict(self):\n        # GH 21510\n        expected = pd.concat(\n            [pd.Series(range(3)), pd.Series(range(4))], keys=[\"First\", \"Another\"]\n        )\n        result = pd.concat(\n            OrderedDict(\n                [(\"First\", pd.Series(range(3))), (\"Another\", pd.Series(range(4)))]\n            )\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 2540,
        "end_line": 2550,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.test_concat_no_unnecessary_upcast#2555",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat",
        "signature": "pandas.tests.reshape.test_concat.test_concat_no_unnecessary_upcast(dt, pdt)",
        "snippet": "def test_concat_no_unnecessary_upcast(dt, pdt):\n    # GH 13247\n    dims = pdt(dtype=object).ndim\n\n    dfs = [\n        pdt(np.array([1], dtype=dt, ndmin=dims)),\n        pdt(np.array([np.nan], dtype=dt, ndmin=dims)),\n        pdt(np.array([5], dtype=dt, ndmin=dims)),\n    ]\n    x = pd.concat(dfs)\n    assert x.values.dtype == dt",
        "begin_line": 2555,
        "end_line": 2565,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.test_concat_will_upcast#2570",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat",
        "signature": "pandas.tests.reshape.test_concat.test_concat_will_upcast(dt, pdt)",
        "snippet": "def test_concat_will_upcast(dt, pdt):\n    with catch_warnings(record=True):\n        dims = pdt().ndim\n        dfs = [\n            pdt(np.array([1], dtype=dt, ndmin=dims)),\n            pdt(np.array([np.nan], ndmin=dims)),\n            pdt(np.array([5], dtype=dt, ndmin=dims)),\n        ]\n        x = pd.concat(dfs)\n        assert x.values.dtype == \"float64\"",
        "begin_line": 2570,
        "end_line": 2579,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.test_concat_empty_and_non_empty_frame_regression#2582",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat",
        "signature": "pandas.tests.reshape.test_concat.test_concat_empty_and_non_empty_frame_regression()",
        "snippet": "def test_concat_empty_and_non_empty_frame_regression():\n    # GH 18178 regression test\n    df1 = pd.DataFrame({\"foo\": [1]})\n    df2 = pd.DataFrame({\"foo\": []})\n    expected = pd.DataFrame({\"foo\": [1.0]})\n    result = pd.concat([df1, df2])\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 2582,
        "end_line": 2588,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.test_concat_empty_and_non_empty_series_regression#2591",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat",
        "signature": "pandas.tests.reshape.test_concat.test_concat_empty_and_non_empty_series_regression()",
        "snippet": "def test_concat_empty_and_non_empty_series_regression():\n    # GH 18187 regression test\n    s1 = pd.Series([1])\n    s2 = pd.Series([], dtype=object)\n\n    expected = s1\n    result = pd.concat([s1, s2])\n    tm.assert_series_equal(result, expected)",
        "begin_line": 2591,
        "end_line": 2598,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.test_concat_sorts_columns#2601",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat",
        "signature": "pandas.tests.reshape.test_concat.test_concat_sorts_columns(sort)",
        "snippet": "def test_concat_sorts_columns(sort):\n    # GH-4588\n    df1 = pd.DataFrame({\"a\": [1, 2], \"b\": [1, 2]}, columns=[\"b\", \"a\"])\n    df2 = pd.DataFrame({\"a\": [3, 4], \"c\": [5, 6]})\n\n    # for sort=True/None\n    expected = pd.DataFrame(\n        {\"a\": [1, 2, 3, 4], \"b\": [1, 2, None, None], \"c\": [None, None, 5, 6]},\n        columns=[\"a\", \"b\", \"c\"],\n    )\n\n    if sort is False:\n        expected = expected[[\"b\", \"a\", \"c\"]]\n\n    # default\n    with tm.assert_produces_warning(None):\n        result = pd.concat([df1, df2], ignore_index=True, sort=sort)\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 2601,
        "end_line": 2618,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.test_concat_sorts_index#2621",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat",
        "signature": "pandas.tests.reshape.test_concat.test_concat_sorts_index(sort)",
        "snippet": "def test_concat_sorts_index(sort):\n    df1 = pd.DataFrame({\"a\": [1, 2, 3]}, index=[\"c\", \"a\", \"b\"])\n    df2 = pd.DataFrame({\"b\": [1, 2]}, index=[\"a\", \"b\"])\n\n    # For True/None\n    expected = pd.DataFrame(\n        {\"a\": [2, 3, 1], \"b\": [1, 2, None]}, index=[\"a\", \"b\", \"c\"], columns=[\"a\", \"b\"]\n    )\n    if sort is False:\n        expected = expected.loc[[\"c\", \"a\", \"b\"]]\n\n    # Warn and sort by default\n    with tm.assert_produces_warning(None):\n        result = pd.concat([df1, df2], axis=1, sort=sort)\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 2621,
        "end_line": 2635,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.test_concat_inner_sort#2638",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat",
        "signature": "pandas.tests.reshape.test_concat.test_concat_inner_sort(sort)",
        "snippet": "def test_concat_inner_sort(sort):\n    # https://github.com/pandas-dev/pandas/pull/20613\n    df1 = pd.DataFrame({\"a\": [1, 2], \"b\": [1, 2], \"c\": [1, 2]}, columns=[\"b\", \"a\", \"c\"])\n    df2 = pd.DataFrame({\"a\": [1, 2], \"b\": [3, 4]}, index=[3, 4])\n\n    with tm.assert_produces_warning(None):\n        # unset sort should *not* warn for inner join\n        # since that never sorted\n        result = pd.concat([df1, df2], sort=sort, join=\"inner\", ignore_index=True)\n\n    expected = pd.DataFrame({\"b\": [1, 2, 3, 4], \"a\": [1, 2, 1, 2]}, columns=[\"b\", \"a\"])\n    if sort is True:\n        expected = expected[[\"a\", \"b\"]]\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 2638,
        "end_line": 2651,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.test_concat_aligned_sort#2654",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat",
        "signature": "pandas.tests.reshape.test_concat.test_concat_aligned_sort()",
        "snippet": "def test_concat_aligned_sort():\n    # GH-4588\n    df = pd.DataFrame({\"c\": [1, 2], \"b\": [3, 4], \"a\": [5, 6]}, columns=[\"c\", \"b\", \"a\"])\n    result = pd.concat([df, df], sort=True, ignore_index=True)\n    expected = pd.DataFrame(\n        {\"a\": [5, 6, 5, 6], \"b\": [3, 4, 3, 4], \"c\": [1, 2, 1, 2]},\n        columns=[\"a\", \"b\", \"c\"],\n    )\n    tm.assert_frame_equal(result, expected)\n\n    result = pd.concat([df, df[[\"c\", \"b\"]]], join=\"inner\", sort=True, ignore_index=True)\n    expected = expected[[\"b\", \"c\"]]\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 2654,
        "end_line": 2666,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.test_concat_aligned_sort_does_not_raise#2669",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat",
        "signature": "pandas.tests.reshape.test_concat.test_concat_aligned_sort_does_not_raise()",
        "snippet": "def test_concat_aligned_sort_does_not_raise():\n    # GH-4588\n    # We catch TypeErrors from sorting internally and do not re-raise.\n    df = pd.DataFrame({1: [1, 2], \"a\": [3, 4]}, columns=[1, \"a\"])\n    expected = pd.DataFrame({1: [1, 2, 1, 2], \"a\": [3, 4, 3, 4]}, columns=[1, \"a\"])\n    result = pd.concat([df, df], ignore_index=True, sort=True)\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 2669,
        "end_line": 2675,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.test_concat_series_name_npscalar_tuple#2679",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat",
        "signature": "pandas.tests.reshape.test_concat.test_concat_series_name_npscalar_tuple(s1name, s2name)",
        "snippet": "def test_concat_series_name_npscalar_tuple(s1name, s2name):\n    # GH21015\n    s1 = pd.Series({\"a\": 1, \"b\": 2}, name=s1name)\n    s2 = pd.Series({\"c\": 5, \"d\": 6}, name=s2name)\n    result = pd.concat([s1, s2])\n    expected = pd.Series({\"a\": 1, \"b\": 2, \"c\": 5, \"d\": 6})\n    tm.assert_series_equal(result, expected)",
        "begin_line": 2679,
        "end_line": 2685,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.test_concat_categorical_tz#2688",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat",
        "signature": "pandas.tests.reshape.test_concat.test_concat_categorical_tz()",
        "snippet": "def test_concat_categorical_tz():\n    # GH-23816\n    a = pd.Series(pd.date_range(\"2017-01-01\", periods=2, tz=\"US/Pacific\"))\n    b = pd.Series([\"a\", \"b\"], dtype=\"category\")\n    result = pd.concat([a, b], ignore_index=True)\n    expected = pd.Series(\n        [\n            pd.Timestamp(\"2017-01-01\", tz=\"US/Pacific\"),\n            pd.Timestamp(\"2017-01-02\", tz=\"US/Pacific\"),\n            \"a\",\n            \"b\",\n        ]\n    )\n    tm.assert_series_equal(result, expected)",
        "begin_line": 2688,
        "end_line": 2701,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.test_concat_categorical_unchanged#2704",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat",
        "signature": "pandas.tests.reshape.test_concat.test_concat_categorical_unchanged()",
        "snippet": "def test_concat_categorical_unchanged():\n    # GH-12007\n    # test fix for when concat on categorical and float\n    # coerces dtype categorical -> float\n    df = pd.DataFrame(pd.Series([\"a\", \"b\", \"c\"], dtype=\"category\", name=\"A\"))\n    ser = pd.Series([0, 1, 2], index=[0, 1, 3], name=\"B\")\n    result = pd.concat([df, ser], axis=1)\n    expected = pd.DataFrame(\n        {\n            \"A\": pd.Series([\"a\", \"b\", \"c\", np.nan], dtype=\"category\"),\n            \"B\": pd.Series([0, 1, np.nan, 2], dtype=\"float\"),\n        }\n    )\n    tm.assert_equal(result, expected)",
        "begin_line": 2704,
        "end_line": 2717,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.test_concat_datetimeindex_freq#2720",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat",
        "signature": "pandas.tests.reshape.test_concat.test_concat_datetimeindex_freq()",
        "snippet": "def test_concat_datetimeindex_freq():\n    # GH 3232\n    # Monotonic index result\n    dr = pd.date_range(\"01-Jan-2013\", periods=100, freq=\"50L\", tz=\"UTC\")\n    data = list(range(100))\n    expected = pd.DataFrame(data, index=dr)\n    result = pd.concat([expected[:50], expected[50:]])\n    tm.assert_frame_equal(result, expected)\n\n    # Non-monotonic index result\n    result = pd.concat([expected[50:], expected[:50]])\n    expected = pd.DataFrame(data[50:] + data[:50], index=dr[50:].append(dr[:50]))\n    expected.index._data.freq = None\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 2720,
        "end_line": 2733,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.test_concat_empty_df_object_dtype#2736",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat",
        "signature": "pandas.tests.reshape.test_concat.test_concat_empty_df_object_dtype()",
        "snippet": "def test_concat_empty_df_object_dtype():\n    # GH 9149\n    df_1 = pd.DataFrame({\"Row\": [0, 1, 1], \"EmptyCol\": np.nan, \"NumberCol\": [1, 2, 3]})\n    df_2 = pd.DataFrame(columns=df_1.columns)\n    result = pd.concat([df_1, df_2], axis=0)\n    expected = df_1.astype(object)\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 2736,
        "end_line": 2742,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.test_concat_sparse#2745",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat",
        "signature": "pandas.tests.reshape.test_concat.test_concat_sparse()",
        "snippet": "def test_concat_sparse():\n    # GH 23557\n    a = pd.Series(SparseArray([0, 1, 2]))\n    expected = pd.DataFrame(data=[[0, 0], [1, 1], [2, 2]]).astype(\n        pd.SparseDtype(np.int64, 0)\n    )\n    result = pd.concat([a, a], axis=1)\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 2745,
        "end_line": 2752,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.test_concat.test_concat_copy_index#2756",
        "src_path": "pandas/tests/reshape/test_concat.py",
        "class_name": "pandas.tests.reshape.test_concat",
        "signature": "pandas.tests.reshape.test_concat.test_concat_copy_index(test_series, axis)",
        "snippet": "def test_concat_copy_index(test_series, axis):\n    # GH 29879\n    if test_series:\n        ser = Series([1, 2])\n        comb = concat([ser, ser], axis=axis, copy=True)\n        assert comb.index is not ser.index\n    else:\n        df = DataFrame([[1, 2], [3, 4]], columns=[\"a\", \"b\"])\n        comb = concat([df, df], axis=axis, copy=True)\n        assert comb.index is not df.index\n        assert comb.columns is not df.columns",
        "begin_line": 2756,
        "end_line": 2766,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalDtype.__init__#22",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalDtype",
        "signature": "pandas.tests.extension.decimal.array.DecimalDtype.__init__(self, context=None)",
        "snippet": "    def __init__(self, context=None):\n        self.context = context or decimal.getcontext()",
        "begin_line": 22,
        "end_line": 23,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalDtype.construct_from_string#40",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalDtype",
        "signature": "pandas.tests.extension.decimal.array.DecimalDtype.construct_from_string(cls, string)",
        "snippet": "    def construct_from_string(cls, string):\n        if string == cls.name:\n            return cls()\n        else:\n            raise TypeError(f\"Cannot construct a '{cls.__name__}' from '{string}'\")",
        "begin_line": 40,
        "end_line": 44,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__init__#54",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__init__(self, values, dtype=None, copy=False, context=None)",
        "snippet": "    def __init__(self, values, dtype=None, copy=False, context=None):\n        for val in values:\n            if not isinstance(val, decimal.Decimal):\n                raise TypeError(\"All values must be of type \" + str(decimal.Decimal))\n        values = np.asarray(values, dtype=object)\n\n        self._data = values\n        # Some aliases for common attribute names to ensure pandas supports\n        # these\n        self._items = self.data = self._data\n        # those aliases are currently not working due to assumptions\n        # in internal code (GH-20735)\n        # self._values = self.values = self.data\n        self._dtype = DecimalDtype(context)",
        "begin_line": 54,
        "end_line": 67,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.dtype#70",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.dtype(self)",
        "snippet": "    def dtype(self):\n        return self._dtype",
        "begin_line": 70,
        "end_line": 71,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__getitem__#114",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__getitem__(self, item)",
        "snippet": "    def __getitem__(self, item):\n        if isinstance(item, numbers.Integral):\n            return self._data[item]\n        else:\n            # array, slice.\n            if pd.api.types.is_list_like(item):\n                if not pd.api.types.is_array_like(item):\n                    item = pd.array(item)\n                dtype = item.dtype\n                if pd.api.types.is_bool_dtype(dtype):\n                    item = pd.api.indexers.check_bool_array_indexer(self, item)\n                elif pd.api.types.is_integer_dtype(dtype):\n                    item = np.asarray(item, dtype=\"int\")\n            return type(self)(self._data[item])",
        "begin_line": 114,
        "end_line": 127,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__len__#156",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__len__(self)",
        "snippet": "    def __len__(self) -> int:\n        return len(self._data)",
        "begin_line": 156,
        "end_line": 157,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.to_decimal#201",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array",
        "signature": "pandas.tests.extension.decimal.array.to_decimal(values, context=None)",
        "snippet": "def to_decimal(values, context=None):\n    return DecimalArray([decimal.Decimal(x) for x in values], context=context)",
        "begin_line": 201,
        "end_line": 202,
        "comment": "",
        "is_bug": false
    }
]