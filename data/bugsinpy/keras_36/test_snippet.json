[
    {
        "name": "tests.keras.layers.convolutional_test.test_causal_dilated_conv#24",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_causal_dilated_conv()",
        "snippet": "def test_causal_dilated_conv():\n    # Causal:\n    layer_test(convolutional.Conv1D,\n               input_data=np.reshape(np.arange(4, dtype='float32'), (1, 4, 1)),\n               kwargs={\n                   'filters': 1,\n                   'kernel_size': 2,\n                   'dilation_rate': 1,\n                   'padding': 'causal',\n                   'kernel_initializer': 'ones',\n                   'use_bias': False,\n               },\n               expected_output=[[[0], [1], [3], [5]]]\n               )\n\n    # Non-causal:\n    layer_test(convolutional.Conv1D,\n               input_data=np.reshape(np.arange(4, dtype='float32'), (1, 4, 1)),\n               kwargs={\n                   'filters': 1,\n                   'kernel_size': 2,\n                   'dilation_rate': 1,\n                   'padding': 'valid',\n                   'kernel_initializer': 'ones',\n                   'use_bias': False,\n               },\n               expected_output=[[[1], [3], [5]]]\n               )\n\n    # Causal dilated with larger kernel size:\n    layer_test(convolutional.Conv1D,\n               input_data=np.reshape(np.arange(10, dtype='float32'), (1, 10, 1)),\n               kwargs={\n                   'filters': 1,\n                   'kernel_size': 3,\n                   'dilation_rate': 2,\n                   'padding': 'causal',\n                   'kernel_initializer': 'ones',\n                   'use_bias': False,\n               },\n               expected_output=np.float32([[[0], [1], [2], [4], [6], [9], [12], [15], [18], [21]]])\n               )",
        "begin_line": 24,
        "end_line": 65,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_conv_1d#69",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_conv_1d()",
        "snippet": "def test_conv_1d():\n    batch_size = 2\n    steps = 8\n    input_dim = 2\n    kernel_size = 3\n    filters = 3\n\n    for padding in _convolution_paddings:\n        for strides in [1, 2]:\n            if padding == 'same' and strides != 1:\n                continue\n            layer_test(convolutional.Conv1D,\n                       kwargs={'filters': filters,\n                               'kernel_size': kernel_size,\n                               'padding': padding,\n                               'strides': strides},\n                       input_shape=(batch_size, steps, input_dim))\n\n            layer_test(convolutional.Conv1D,\n                       kwargs={'filters': filters,\n                               'kernel_size': kernel_size,\n                               'padding': padding,\n                               'kernel_regularizer': 'l2',\n                               'bias_regularizer': 'l2',\n                               'activity_regularizer': 'l2',\n                               'kernel_constraint': 'max_norm',\n                               'bias_constraint': 'max_norm',\n                               'strides': strides},\n                       input_shape=(batch_size, steps, input_dim))\n\n    # Test dilation\n    layer_test(convolutional.Conv1D,\n               kwargs={'filters': filters,\n                       'kernel_size': kernel_size,\n                       'padding': padding,\n                       'dilation_rate': 2,\n                       'activation': None},\n               input_shape=(batch_size, steps, input_dim))\n\n    convolutional.Conv1D(filters=filters,\n                         kernel_size=kernel_size,\n                         padding=padding,\n                         input_shape=(input_dim,))",
        "begin_line": 69,
        "end_line": 111,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_maxpooling_1d#115",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_maxpooling_1d()",
        "snippet": "def test_maxpooling_1d():\n    for padding in ['valid', 'same']:\n        for stride in [1, 2]:\n            layer_test(convolutional.MaxPooling1D,\n                       kwargs={'strides': stride,\n                               'padding': padding},\n                       input_shape=(3, 5, 4))",
        "begin_line": 115,
        "end_line": 121,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_averagepooling_1d#125",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_averagepooling_1d()",
        "snippet": "def test_averagepooling_1d():\n    for padding in ['valid', 'same']:\n        for stride in [1, 2]:\n            layer_test(convolutional.AveragePooling1D,\n                       kwargs={'strides': stride,\n                               'padding': padding},\n                       input_shape=(3, 5, 4))",
        "begin_line": 125,
        "end_line": 131,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_convolution_2d#137",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_convolution_2d()",
        "snippet": "def test_convolution_2d():\n    num_samples = 2\n    filters = 2\n    stack_size = 3\n    kernel_size = (3, 2)\n    num_row = 7\n    num_col = 6\n\n    for padding in _convolution_paddings:\n        for strides in [(1, 1), (2, 2)]:\n            if padding == 'same' and strides != (1, 1):\n                continue\n\n            layer_test(convolutional.Conv2D,\n                       kwargs={'filters': filters,\n                               'kernel_size': kernel_size,\n                               'padding': padding,\n                               'strides': strides,\n                               'data_format': 'channels_first'},\n                       input_shape=(num_samples, stack_size, num_row, num_col))\n\n    layer_test(convolutional.Conv2D,\n               kwargs={'filters': filters,\n                       'kernel_size': 3,\n                       'padding': padding,\n                       'data_format': 'channels_last',\n                       'activation': None,\n                       'kernel_regularizer': 'l2',\n                       'bias_regularizer': 'l2',\n                       'activity_regularizer': 'l2',\n                       'kernel_constraint': 'max_norm',\n                       'bias_constraint': 'max_norm',\n                       'strides': strides},\n               input_shape=(num_samples, num_row, num_col, stack_size))\n\n    # Test dilation\n    layer_test(convolutional.Conv2D,\n               kwargs={'filters': filters,\n                       'kernel_size': kernel_size,\n                       'padding': padding,\n                       'dilation_rate': (2, 2)},\n               input_shape=(num_samples, num_row, num_col, stack_size))\n\n    # Test invalid use case\n    with pytest.raises(ValueError):\n        model = Sequential([convolutional.Conv2D(filters=filters,\n                                                 kernel_size=kernel_size,\n                                                 padding=padding,\n                                                 batch_input_shape=(None, None, 5, None))])",
        "begin_line": 137,
        "end_line": 185,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_conv2d_transpose#189",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_conv2d_transpose()",
        "snippet": "def test_conv2d_transpose():\n    num_samples = 2\n    filters = 2\n    stack_size = 3\n    num_row = 5\n    num_col = 6\n\n    for padding in _convolution_paddings:\n        for strides in [(1, 1), (2, 2)]:\n            if padding == 'same' and strides != (1, 1):\n                continue\n            layer_test(convolutional.Deconvolution2D,\n                       kwargs={'filters': filters,\n                               'kernel_size': 3,\n                               'padding': padding,\n                               'strides': strides,\n                               'data_format': 'channels_last'},\n                       input_shape=(num_samples, num_row, num_col, stack_size),\n                       fixed_batch_size=True)\n\n    layer_test(convolutional.Deconvolution2D,\n               kwargs={'filters': filters,\n                       'kernel_size': 3,\n                       'padding': padding,\n                       'data_format': 'channels_first',\n                       'activation': None,\n                       'kernel_regularizer': 'l2',\n                       'bias_regularizer': 'l2',\n                       'activity_regularizer': 'l2',\n                       'kernel_constraint': 'max_norm',\n                       'bias_constraint': 'max_norm',\n                       'strides': strides},\n               input_shape=(num_samples, stack_size, num_row, num_col),\n               fixed_batch_size=True)\n\n    # Test invalid use case\n    with pytest.raises(ValueError):\n        model = Sequential([convolutional.Conv2DTranspose(filters=filters,\n                                                          kernel_size=3,\n                                                          padding=padding,\n                                                          batch_input_shape=(None, None, 5, None))])",
        "begin_line": 189,
        "end_line": 229,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_separable_conv_1d#234",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_separable_conv_1d()",
        "snippet": "def test_separable_conv_1d():\n    num_samples = 2\n    filters = 6\n    stack_size = 3\n    num_step = 9\n\n    for padding in _convolution_paddings:\n        for strides in [1, 2]:\n            for multiplier in [1, 2]:\n                for dilation_rate in [1, 2]:\n                    if padding == 'same' and strides != 1:\n                        continue\n                    if dilation_rate != 1 and strides != 1:\n                        continue\n\n                    layer_test(convolutional.SeparableConv1D,\n                               kwargs={'filters': filters,\n                                       'kernel_size': 3,\n                                       'padding': padding,\n                                       'strides': strides,\n                                       'depth_multiplier': multiplier,\n                                       'dilation_rate': dilation_rate},\n                               input_shape=(num_samples, num_step, stack_size))\n\n    layer_test(convolutional.SeparableConv1D,\n               kwargs={'filters': filters,\n                       'kernel_size': 3,\n                       'padding': padding,\n                       'data_format': 'channels_first',\n                       'activation': None,\n                       'depthwise_regularizer': 'l2',\n                       'pointwise_regularizer': 'l2',\n                       'bias_regularizer': 'l2',\n                       'activity_regularizer': 'l2',\n                       'pointwise_constraint': 'unit_norm',\n                       'depthwise_constraint': 'unit_norm',\n                       'strides': 1,\n                       'depth_multiplier': multiplier},\n               input_shape=(num_samples, stack_size, num_step))\n\n    # Test invalid use case\n    with pytest.raises(ValueError):\n        model = Sequential([convolutional.SeparableConv1D(filters=filters,\n                                                          kernel_size=3,\n                                                          padding=padding,\n                                                          batch_input_shape=(None, 5, None))])",
        "begin_line": 234,
        "end_line": 279,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_separable_conv_2d#284",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_separable_conv_2d()",
        "snippet": "def test_separable_conv_2d():\n    num_samples = 2\n    filters = 6\n    stack_size = 3\n    num_row = 7\n    num_col = 6\n\n    for padding in _convolution_paddings:\n        for strides in [(1, 1), (2, 2)]:\n            for multiplier in [1, 2]:\n                for dilation_rate in [(1, 1), (2, 2), (2, 1), (1, 2)]:\n                    if padding == 'same' and strides != (1, 1):\n                        continue\n                    if dilation_rate != (1, 1) and strides != (1, 1):\n                        continue\n\n                    layer_test(convolutional.SeparableConv2D,\n                               kwargs={'filters': filters,\n                                       'kernel_size': (3, 3),\n                                       'padding': padding,\n                                       'strides': strides,\n                                       'depth_multiplier': multiplier,\n                                       'dilation_rate': dilation_rate},\n                               input_shape=(num_samples, num_row, num_col, stack_size))\n\n    layer_test(convolutional.SeparableConv2D,\n               kwargs={'filters': filters,\n                       'kernel_size': 3,\n                       'padding': padding,\n                       'data_format': 'channels_first',\n                       'activation': None,\n                       'depthwise_regularizer': 'l2',\n                       'pointwise_regularizer': 'l2',\n                       'bias_regularizer': 'l2',\n                       'activity_regularizer': 'l2',\n                       'pointwise_constraint': 'unit_norm',\n                       'depthwise_constraint': 'unit_norm',\n                       'strides': strides,\n                       'depth_multiplier': multiplier},\n               input_shape=(num_samples, stack_size, num_row, num_col))\n\n    # Test invalid use case\n    with pytest.raises(ValueError):\n        model = Sequential([convolutional.SeparableConv2D(filters=filters,\n                                                          kernel_size=3,\n                                                          padding=padding,\n                                                          batch_input_shape=(None, None, 5, None))])",
        "begin_line": 284,
        "end_line": 330,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_globalpooling_1d#334",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_globalpooling_1d()",
        "snippet": "def test_globalpooling_1d():\n    layer_test(pooling.GlobalMaxPooling1D,\n               input_shape=(3, 4, 5))\n    layer_test(pooling.GlobalAveragePooling1D,\n               input_shape=(3, 4, 5))",
        "begin_line": 334,
        "end_line": 338,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_globalpooling_2d#342",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_globalpooling_2d()",
        "snippet": "def test_globalpooling_2d():\n    layer_test(pooling.GlobalMaxPooling2D,\n               kwargs={'data_format': 'channels_first'},\n               input_shape=(3, 4, 5, 6))\n    layer_test(pooling.GlobalMaxPooling2D,\n               kwargs={'data_format': 'channels_last'},\n               input_shape=(3, 5, 6, 4))\n    layer_test(pooling.GlobalAveragePooling2D,\n               kwargs={'data_format': 'channels_first'},\n               input_shape=(3, 4, 5, 6))\n    layer_test(pooling.GlobalAveragePooling2D,\n               kwargs={'data_format': 'channels_last'},\n               input_shape=(3, 5, 6, 4))",
        "begin_line": 342,
        "end_line": 354,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_globalpooling_3d#358",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_globalpooling_3d()",
        "snippet": "def test_globalpooling_3d():\n    layer_test(pooling.GlobalMaxPooling3D,\n               kwargs={'data_format': 'channels_first'},\n               input_shape=(3, 4, 3, 4, 3))\n    layer_test(pooling.GlobalMaxPooling3D,\n               kwargs={'data_format': 'channels_last'},\n               input_shape=(3, 4, 3, 4, 3))\n    layer_test(pooling.GlobalAveragePooling3D,\n               kwargs={'data_format': 'channels_first'},\n               input_shape=(3, 4, 3, 4, 3))\n    layer_test(pooling.GlobalAveragePooling3D,\n               kwargs={'data_format': 'channels_last'},\n               input_shape=(3, 4, 3, 4, 3))",
        "begin_line": 358,
        "end_line": 370,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_maxpooling_2d#374",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_maxpooling_2d()",
        "snippet": "def test_maxpooling_2d():\n    pool_size = (3, 3)\n\n    for strides in [(1, 1), (2, 2)]:\n        layer_test(convolutional.MaxPooling2D,\n                   kwargs={'strides': strides,\n                           'padding': 'valid',\n                           'pool_size': pool_size},\n                   input_shape=(3, 5, 6, 4))",
        "begin_line": 374,
        "end_line": 382,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_averagepooling_2d#386",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_averagepooling_2d()",
        "snippet": "def test_averagepooling_2d():\n    layer_test(convolutional.AveragePooling2D,\n               kwargs={'strides': (2, 2),\n                       'padding': 'same',\n                       'pool_size': (2, 2)},\n               input_shape=(3, 5, 6, 4))\n    layer_test(convolutional.AveragePooling2D,\n               kwargs={'strides': (2, 2),\n                       'padding': 'valid',\n                       'pool_size': (3, 3)},\n               input_shape=(3, 5, 6, 4))\n    layer_test(convolutional.AveragePooling2D,\n               kwargs={'strides': (1, 1),\n                       'padding': 'valid',\n                       'pool_size': (2, 2),\n                       'data_format': 'channels_first'},\n               input_shape=(3, 4, 5, 6))",
        "begin_line": 386,
        "end_line": 402,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_convolution_3d#406",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_convolution_3d()",
        "snippet": "def test_convolution_3d():\n    num_samples = 2\n    filters = 2\n    stack_size = 3\n\n    input_len_dim1 = 9\n    input_len_dim2 = 8\n    input_len_dim3 = 8\n\n    for padding in _convolution_paddings:\n        for strides in [(1, 1, 1), (2, 2, 2)]:\n            if padding == 'same' and strides != (1, 1, 1):\n                continue\n\n            layer_test(convolutional.Convolution3D,\n                       kwargs={'filters': filters,\n                               'kernel_size': 3,\n                               'padding': padding,\n                               'strides': strides},\n                       input_shape=(num_samples,\n                                    input_len_dim1, input_len_dim2, input_len_dim3,\n                                    stack_size))\n\n    layer_test(convolutional.Convolution3D,\n               kwargs={'filters': filters,\n                       'kernel_size': (1, 2, 3),\n                       'padding': padding,\n                       'activation': None,\n                       'kernel_regularizer': 'l2',\n                       'bias_regularizer': 'l2',\n                       'activity_regularizer': 'l2',\n                       'kernel_constraint': 'max_norm',\n                       'bias_constraint': 'max_norm',\n                       'strides': strides},\n               input_shape=(num_samples,\n                            input_len_dim1, input_len_dim2, input_len_dim3,\n                            stack_size))",
        "begin_line": 406,
        "end_line": 442,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_conv3d_transpose#446",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_conv3d_transpose()",
        "snippet": "def test_conv3d_transpose():\n    filters = 2\n    stack_size = 3\n    num_depth = 7\n    num_row = 5\n    num_col = 6\n\n    for padding in _convolution_paddings:\n        for strides in [(1, 1, 1), (2, 2, 2)]:\n            for data_format in ['channels_first', 'channels_last']:\n                if padding == 'same' and strides != (1, 1, 1):\n                    continue\n                layer_test(convolutional.Conv3DTranspose,\n                           kwargs={'filters': filters,\n                                   'kernel_size': 3,\n                                   'padding': padding,\n                                   'strides': strides,\n                                   'data_format': data_format},\n                           input_shape=(None, num_depth, num_row, num_col, stack_size),\n                           fixed_batch_size=True)\n\n    layer_test(convolutional.Conv3DTranspose,\n               kwargs={'filters': filters,\n                       'kernel_size': 3,\n                       'padding': padding,\n                       'data_format': 'channels_first',\n                       'activation': None,\n                       'kernel_regularizer': 'l2',\n                       'bias_regularizer': 'l2',\n                       'activity_regularizer': 'l2',\n                       'kernel_constraint': 'max_norm',\n                       'bias_constraint': 'max_norm',\n                       'strides': strides},\n               input_shape=(None, stack_size, num_depth, num_row, num_col),\n               fixed_batch_size=True)\n\n    # Test invalid use case\n    with pytest.raises(ValueError):\n        model = Sequential([convolutional.Conv3DTranspose(filters=filters,\n                                                          kernel_size=3,\n                                                          padding=padding,\n                                                          batch_input_shape=(None, None, 5, None, None))])",
        "begin_line": 446,
        "end_line": 487,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_maxpooling_3d#491",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_maxpooling_3d()",
        "snippet": "def test_maxpooling_3d():\n    pool_size = (3, 3, 3)\n\n    layer_test(convolutional.MaxPooling3D,\n               kwargs={'strides': 2,\n                       'padding': 'valid',\n                       'pool_size': pool_size},\n               input_shape=(3, 11, 12, 10, 4))\n    layer_test(convolutional.MaxPooling3D,\n               kwargs={'strides': 3,\n                       'padding': 'valid',\n                       'data_format': 'channels_first',\n                       'pool_size': pool_size},\n               input_shape=(3, 4, 11, 12, 10))",
        "begin_line": 491,
        "end_line": 504,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_averagepooling_3d#508",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_averagepooling_3d()",
        "snippet": "def test_averagepooling_3d():\n    pool_size = (3, 3, 3)\n\n    layer_test(convolutional.AveragePooling3D,\n               kwargs={'strides': 2,\n                       'padding': 'valid',\n                       'pool_size': pool_size},\n               input_shape=(3, 11, 12, 10, 4))\n    layer_test(convolutional.AveragePooling3D,\n               kwargs={'strides': 3,\n                       'padding': 'valid',\n                       'data_format': 'channels_first',\n                       'pool_size': pool_size},\n               input_shape=(3, 4, 11, 12, 10))",
        "begin_line": 508,
        "end_line": 521,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_zero_padding_1d#525",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_zero_padding_1d()",
        "snippet": "def test_zero_padding_1d():\n    num_samples = 2\n    input_dim = 2\n    num_steps = 5\n    shape = (num_samples, num_steps, input_dim)\n    inputs = np.ones(shape)\n\n    # basic test\n    layer_test(convolutional.ZeroPadding1D,\n               kwargs={'padding': 2},\n               input_shape=inputs.shape)\n    layer_test(convolutional.ZeroPadding1D,\n               kwargs={'padding': (1, 2)},\n               input_shape=inputs.shape)\n\n    # correctness test\n    layer = convolutional.ZeroPadding1D(padding=2)\n    layer.build(shape)\n    outputs = layer(K.variable(inputs))\n    np_output = K.eval(outputs)\n    for offset in [0, 1, -1, -2]:\n        assert_allclose(np_output[:, offset, :], 0.)\n    assert_allclose(np_output[:, 2:-2, :], 1.)\n\n    layer = convolutional.ZeroPadding1D(padding=(1, 2))\n    layer.build(shape)\n    outputs = layer(K.variable(inputs))\n    np_output = K.eval(outputs)\n    for left_offset in [0]:\n        assert_allclose(np_output[:, left_offset, :], 0.)\n    for right_offset in [-1, -2]:\n        assert_allclose(np_output[:, right_offset, :], 0.)\n    assert_allclose(np_output[:, 1:-2, :], 1.)\n    layer.get_config()",
        "begin_line": 525,
        "end_line": 558,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_zero_padding_2d#562",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_zero_padding_2d()",
        "snippet": "def test_zero_padding_2d():\n    num_samples = 2\n    stack_size = 2\n    input_num_row = 4\n    input_num_col = 5\n    for data_format in ['channels_first', 'channels_last']:\n        inputs = np.ones((num_samples, input_num_row, input_num_col, stack_size))\n        inputs = np.ones((num_samples, stack_size, input_num_row, input_num_col))\n\n        # basic test\n        layer_test(convolutional.ZeroPadding2D,\n                   kwargs={'padding': (2, 2), 'data_format': data_format},\n                   input_shape=inputs.shape)\n        layer_test(convolutional.ZeroPadding2D,\n                   kwargs={'padding': ((1, 2), (3, 4)), 'data_format': data_format},\n                   input_shape=inputs.shape)\n\n        # correctness test\n        layer = convolutional.ZeroPadding2D(padding=(2, 2),\n                                            data_format=data_format)\n        layer.build(inputs.shape)\n        outputs = layer(K.variable(inputs))\n        np_output = K.eval(outputs)\n        if data_format == 'channels_last':\n            for offset in [0, 1, -1, -2]:\n                assert_allclose(np_output[:, offset, :, :], 0.)\n                assert_allclose(np_output[:, :, offset, :], 0.)\n            assert_allclose(np_output[:, 2:-2, 2:-2, :], 1.)\n        elif data_format == 'channels_first':\n            for offset in [0, 1, -1, -2]:\n                assert_allclose(np_output[:, :, offset, :], 0.)\n                assert_allclose(np_output[:, :, :, offset], 0.)\n            assert_allclose(np_output[:, 2:-2, 2:-2, :], 1.)\n\n        layer = convolutional.ZeroPadding2D(padding=((1, 2), (3, 4)),\n                                            data_format=data_format)\n        layer.build(inputs.shape)\n        outputs = layer(K.variable(inputs))\n        np_output = K.eval(outputs)\n        if data_format == 'channels_last':\n            for top_offset in [0]:\n                assert_allclose(np_output[:, top_offset, :, :], 0.)\n            for bottom_offset in [-1, -2]:\n                assert_allclose(np_output[:, bottom_offset, :, :], 0.)\n            for left_offset in [0, 1, 2]:\n                assert_allclose(np_output[:, :, left_offset, :], 0.)\n            for right_offset in [-1, -2, -3, -4]:\n                assert_allclose(np_output[:, :, right_offset, :], 0.)\n            assert_allclose(np_output[:, 1:-2, 3:-4, :], 1.)\n        elif data_format == 'channels_first':\n            for top_offset in [0]:\n                assert_allclose(np_output[:, :, top_offset, :], 0.)\n            for bottom_offset in [-1, -2]:\n                assert_allclose(np_output[:, :, bottom_offset, :], 0.)\n            for left_offset in [0, 1, 2]:\n                assert_allclose(np_output[:, :, :, left_offset], 0.)\n            for right_offset in [-1, -2, -3, -4]:\n                assert_allclose(np_output[:, :, :, right_offset], 0.)\n            assert_allclose(np_output[:, :, 1:-2, 3:-4], 1.)",
        "begin_line": 562,
        "end_line": 620,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_zero_padding_3d#623",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_zero_padding_3d()",
        "snippet": "def test_zero_padding_3d():\n    num_samples = 2\n    stack_size = 2\n    input_len_dim1 = 4\n    input_len_dim2 = 5\n    input_len_dim3 = 3\n\n    inputs = np.ones((num_samples,\n                     input_len_dim1, input_len_dim2, input_len_dim3,\n                     stack_size))\n\n    # basic test\n    for data_format in ['channels_first', 'channels_last']:\n        layer_test(convolutional.ZeroPadding3D,\n                   kwargs={'padding': (2, 2, 2), 'data_format': data_format},\n                   input_shape=inputs.shape)\n        layer_test(convolutional.ZeroPadding3D,\n                   kwargs={'padding': ((1, 2), (3, 4), (0, 2)), 'data_format': data_format},\n                   input_shape=inputs.shape)\n\n        # correctness test\n        layer = convolutional.ZeroPadding3D(padding=(2, 2, 2),\n                                            data_format=data_format)\n        layer.build(inputs.shape)\n        outputs = layer(K.variable(inputs))\n        np_output = K.eval(outputs)\n        if data_format == 'channels_last':\n            for offset in [0, 1, -1, -2]:\n                assert_allclose(np_output[:, offset, :, :, :], 0.)\n                assert_allclose(np_output[:, :, offset, :, :], 0.)\n                assert_allclose(np_output[:, :, :, offset, :], 0.)\n            assert_allclose(np_output[:, 2:-2, 2:-2, 2:-2, :], 1.)\n        elif data_format == 'channels_first':\n            for offset in [0, 1, -1, -2]:\n                assert_allclose(np_output[:, :, offset, :, :], 0.)\n                assert_allclose(np_output[:, :, :, offset, :], 0.)\n                assert_allclose(np_output[:, :, :, :, offset], 0.)\n            assert_allclose(np_output[:, :, 2:-2, 2:-2, 2:-2], 1.)\n\n        layer = convolutional.ZeroPadding3D(padding=((1, 2), (3, 4), (0, 2)),\n                                            data_format=data_format)\n        layer.build(inputs.shape)\n        outputs = layer(K.variable(inputs))\n        np_output = K.eval(outputs)\n        if data_format == 'channels_last':\n            for dim1_offset in [0, -1, -2]:\n                assert_allclose(np_output[:, dim1_offset, :, :, :], 0.)\n            for dim2_offset in [0, 1, 2, -1, -2, -3, -4]:\n                assert_allclose(np_output[:, :, dim2_offset, :, :], 0.)\n            for dim3_offset in [-1, -2]:\n                assert_allclose(np_output[:, :, :, dim3_offset, :], 0.)\n            assert_allclose(np_output[:, 1:-2, 3:-4, 0:-2, :], 1.)\n        elif data_format == 'channels_first':\n            for dim1_offset in [0, -1, -2]:\n                assert_allclose(np_output[:, :, dim1_offset, :, :], 0.)\n            for dim2_offset in [0, 1, 2, -1, -2, -3, -4]:\n                assert_allclose(np_output[:, :, :, dim2_offset, :], 0.)\n            for dim3_offset in [-1, -2]:\n                assert_allclose(np_output[:, :, :, :, dim3_offset], 0.)\n            assert_allclose(np_output[:, :, 1:-2, 3:-4, 0:-2], 1.)",
        "begin_line": 623,
        "end_line": 682,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_upsampling_1d#686",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_upsampling_1d()",
        "snippet": "def test_upsampling_1d():\n    layer_test(convolutional.UpSampling1D,\n               kwargs={'size': 2},\n               input_shape=(3, 5, 4))",
        "begin_line": 686,
        "end_line": 689,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_upsampling_2d#693",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_upsampling_2d()",
        "snippet": "def test_upsampling_2d():\n    num_samples = 2\n    stack_size = 2\n    input_num_row = 11\n    input_num_col = 12\n\n    for data_format in ['channels_first', 'channels_last']:\n        if data_format == 'channels_first':\n            inputs = np.random.rand(num_samples, stack_size, input_num_row,\n                                    input_num_col)\n        else:  # tf\n            inputs = np.random.rand(num_samples, input_num_row, input_num_col,\n                                    stack_size)\n\n        # basic test\n        layer_test(convolutional.UpSampling2D,\n                   kwargs={'size': (2, 2), 'data_format': data_format},\n                   input_shape=inputs.shape)\n\n        for length_row in [2]:\n            for length_col in [2, 3]:\n                layer = convolutional.UpSampling2D(\n                    size=(length_row, length_col),\n                    data_format=data_format)\n                layer.build(inputs.shape)\n                outputs = layer(K.variable(inputs))\n                np_output = K.eval(outputs)\n                if data_format == 'channels_first':\n                    assert np_output.shape[2] == length_row * input_num_row\n                    assert np_output.shape[3] == length_col * input_num_col\n                else:  # tf\n                    assert np_output.shape[1] == length_row * input_num_row\n                    assert np_output.shape[2] == length_col * input_num_col\n\n                # compare with numpy\n                if data_format == 'channels_first':\n                    expected_out = np.repeat(inputs, length_row, axis=2)\n                    expected_out = np.repeat(expected_out, length_col, axis=3)\n                else:  # tf\n                    expected_out = np.repeat(inputs, length_row, axis=1)\n                    expected_out = np.repeat(expected_out, length_col, axis=2)\n\n                assert_allclose(np_output, expected_out)",
        "begin_line": 693,
        "end_line": 735,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_upsampling_3d#740",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_upsampling_3d()",
        "snippet": "def test_upsampling_3d():\n    num_samples = 2\n    stack_size = 2\n    input_len_dim1 = 10\n    input_len_dim2 = 11\n    input_len_dim3 = 12\n\n    for data_format in ['channels_first', 'channels_last']:\n        if data_format == 'channels_first':\n            inputs = np.random.rand(num_samples,\n                                    stack_size,\n                                    input_len_dim1, input_len_dim2, input_len_dim3)\n        else:  # tf\n            inputs = np.random.rand(num_samples,\n                                    input_len_dim1, input_len_dim2, input_len_dim3,\n                                    stack_size)\n\n        # basic test\n        layer_test(convolutional.UpSampling3D,\n                   kwargs={'size': (2, 2, 2), 'data_format': data_format},\n                   input_shape=inputs.shape)\n\n        for length_dim1 in [2, 3]:\n            for length_dim2 in [2]:\n                for length_dim3 in [3]:\n                    layer = convolutional.UpSampling3D(\n                        size=(length_dim1, length_dim2, length_dim3),\n                        data_format=data_format)\n                    layer.build(inputs.shape)\n                    outputs = layer(K.variable(inputs))\n                    np_output = K.eval(outputs)\n                    if data_format == 'channels_first':\n                        assert np_output.shape[2] == length_dim1 * input_len_dim1\n                        assert np_output.shape[3] == length_dim2 * input_len_dim2\n                        assert np_output.shape[4] == length_dim3 * input_len_dim3\n                    else:  # tf\n                        assert np_output.shape[1] == length_dim1 * input_len_dim1\n                        assert np_output.shape[2] == length_dim2 * input_len_dim2\n                        assert np_output.shape[3] == length_dim3 * input_len_dim3\n\n                    # compare with numpy\n                    if data_format == 'channels_first':\n                        expected_out = np.repeat(inputs, length_dim1, axis=2)\n                        expected_out = np.repeat(expected_out, length_dim2, axis=3)\n                        expected_out = np.repeat(expected_out, length_dim3, axis=4)\n                    else:  # tf\n                        expected_out = np.repeat(inputs, length_dim1, axis=1)\n                        expected_out = np.repeat(expected_out, length_dim2, axis=2)\n                        expected_out = np.repeat(expected_out, length_dim3, axis=3)\n\n                    assert_allclose(np_output, expected_out)",
        "begin_line": 740,
        "end_line": 790,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_cropping_1d#796",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_cropping_1d()",
        "snippet": "def test_cropping_1d():\n    num_samples = 2\n    time_length = 4\n    input_len_dim1 = 2\n    inputs = np.random.rand(num_samples, time_length, input_len_dim1)\n\n    layer_test(convolutional.Cropping1D,\n               kwargs={'cropping': (2, 2)},\n               input_shape=inputs.shape)",
        "begin_line": 796,
        "end_line": 804,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_cropping_2d#807",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_cropping_2d()",
        "snippet": "def test_cropping_2d():\n    num_samples = 2\n    stack_size = 2\n    input_len_dim1 = 9\n    input_len_dim2 = 9\n    cropping = ((2, 2), (3, 3))\n\n    for data_format in ['channels_first', 'channels_last']:\n        if data_format == 'channels_first':\n            inputs = np.random.rand(num_samples, stack_size,\n                                    input_len_dim1, input_len_dim2)\n        else:\n            inputs = np.random.rand(num_samples,\n                                    input_len_dim1, input_len_dim2,\n                                    stack_size)\n        # basic test\n        layer_test(convolutional.Cropping2D,\n                   kwargs={'cropping': cropping,\n                           'data_format': data_format},\n                   input_shape=inputs.shape)\n        # correctness test\n        layer = convolutional.Cropping2D(cropping=cropping,\n                                         data_format=data_format)\n        layer.build(inputs.shape)\n        outputs = layer(K.variable(inputs))\n        np_output = K.eval(outputs)\n        # compare with numpy\n        if data_format == 'channels_first':\n            expected_out = inputs[:,\n                                  :,\n                                  cropping[0][0]: -cropping[0][1],\n                                  cropping[1][0]: -cropping[1][1]]\n        else:\n            expected_out = inputs[:,\n                                  cropping[0][0]: -cropping[0][1],\n                                  cropping[1][0]: -cropping[1][1],\n                                  :]\n        assert_allclose(np_output, expected_out)\n\n    for data_format in ['channels_first', 'channels_last']:\n        if data_format == 'channels_first':\n            inputs = np.random.rand(num_samples, stack_size,\n                                    input_len_dim1, input_len_dim2)\n        else:\n            inputs = np.random.rand(num_samples,\n                                    input_len_dim1, input_len_dim2,\n                                    stack_size)\n        # another correctness test (no cropping)\n        cropping = ((0, 0), (0, 0))\n        layer = convolutional.Cropping2D(cropping=cropping,\n                                         data_format=data_format)\n        layer.build(inputs.shape)\n        outputs = layer(K.variable(inputs))\n        np_output = K.eval(outputs)\n        # compare with input\n        assert_allclose(np_output, inputs)\n\n    # Test invalid use cases\n    with pytest.raises(ValueError):\n        layer = convolutional.Cropping2D(cropping=((1, 1),))\n    with pytest.raises(ValueError):\n        layer = convolutional.Cropping2D(cropping=lambda x: x)",
        "begin_line": 807,
        "end_line": 868,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.layers.convolutional_test.test_cropping_3d#871",
        "src_path": "tests/keras/layers/convolutional_test.py",
        "class_name": "tests.keras.layers.convolutional_test",
        "signature": "tests.keras.layers.convolutional_test.test_cropping_3d()",
        "snippet": "def test_cropping_3d():\n    num_samples = 2\n    stack_size = 2\n    input_len_dim1 = 8\n    input_len_dim2 = 8\n    input_len_dim3 = 8\n    cropping = ((2, 2), (3, 3), (2, 3))\n\n    for data_format in ['channels_last', 'channels_first']:\n        if data_format == 'channels_first':\n            inputs = np.random.rand(num_samples, stack_size,\n                                    input_len_dim1, input_len_dim2, input_len_dim3)\n        else:\n            inputs = np.random.rand(num_samples,\n                                    input_len_dim1, input_len_dim2,\n                                    input_len_dim3, stack_size)\n        # basic test\n        layer_test(convolutional.Cropping3D,\n                   kwargs={'cropping': cropping,\n                           'data_format': data_format},\n                   input_shape=inputs.shape)\n        # correctness test\n        layer = convolutional.Cropping3D(cropping=cropping,\n                                         data_format=data_format)\n        layer.build(inputs.shape)\n        outputs = layer(K.variable(inputs))\n        np_output = K.eval(outputs)\n        # compare with numpy\n        if data_format == 'channels_first':\n            expected_out = inputs[:,\n                                  :,\n                                  cropping[0][0]: -cropping[0][1],\n                                  cropping[1][0]: -cropping[1][1],\n                                  cropping[2][0]: -cropping[2][1]]\n        else:\n            expected_out = inputs[:,\n                                  cropping[0][0]: -cropping[0][1],\n                                  cropping[1][0]: -cropping[1][1],\n                                  cropping[2][0]: -cropping[2][1],\n                                  :]\n        assert_allclose(np_output, expected_out)\n\n    for data_format in ['channels_last', 'channels_first']:\n        if data_format == 'channels_first':\n            inputs = np.random.rand(num_samples, stack_size,\n                                    input_len_dim1, input_len_dim2, input_len_dim3)\n        else:\n            inputs = np.random.rand(num_samples,\n                                    input_len_dim1, input_len_dim2,\n                                    input_len_dim3, stack_size)\n        # another correctness test (no cropping)\n        cropping = ((0, 0), (0, 0), (0, 0))\n        layer = convolutional.Cropping3D(cropping=cropping,\n                                         data_format=data_format)\n        layer.build(inputs.shape)\n        outputs = layer(K.variable(inputs))\n        np_output = K.eval(outputs)\n        # compare with input\n        assert_allclose(np_output, inputs)\n\n    # Test invalid use cases\n    with pytest.raises(ValueError):\n        layer = convolutional.Cropping3D(cropping=((1, 1),))\n    with pytest.raises(ValueError):\n        layer = convolutional.Cropping3D(cropping=lambda x: x)",
        "begin_line": 871,
        "end_line": 935,
        "comment": "",
        "is_bug": false
    }
]