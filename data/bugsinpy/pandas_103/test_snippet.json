[
    {
        "name": "pandas.tests.groupby.test_transform.assert_fp_equal#25",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.assert_fp_equal(a, b)",
        "snippet": "def assert_fp_equal(a, b):\n    assert (np.abs(a - b) < 1e-12).all()",
        "begin_line": 25,
        "end_line": 26,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform#29",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform()",
        "snippet": "def test_transform():\n    data = Series(np.arange(9) // 3, index=np.arange(9))\n\n    index = np.arange(9)\n    np.random.shuffle(index)\n    data = data.reindex(index)\n\n    grouped = data.groupby(lambda x: x // 3)\n\n    transformed = grouped.transform(lambda x: x * x.sum())\n    assert transformed[7] == 12\n\n    # GH 8046\n    # make sure that we preserve the input order\n\n    df = DataFrame(\n        np.arange(6, dtype=\"int64\").reshape(3, 2), columns=[\"a\", \"b\"], index=[0, 2, 1]\n    )\n    key = [0, 0, 1]\n    expected = (\n        df.sort_index()\n        .groupby(key)\n        .transform(lambda x: x - x.mean())\n        .groupby(key)\n        .mean()\n    )\n    result = df.groupby(key).transform(lambda x: x - x.mean()).groupby(key).mean()\n    tm.assert_frame_equal(result, expected)\n\n    def demean(arr):\n        return arr - arr.mean()\n\n    people = DataFrame(\n        np.random.randn(5, 5),\n        columns=[\"a\", \"b\", \"c\", \"d\", \"e\"],\n        index=[\"Joe\", \"Steve\", \"Wes\", \"Jim\", \"Travis\"],\n    )\n    key = [\"one\", \"two\", \"one\", \"two\", \"one\"]\n    result = people.groupby(key).transform(demean).groupby(key).mean()\n    expected = people.groupby(key).apply(demean).groupby(key).mean()\n    tm.assert_frame_equal(result, expected)\n\n    # GH 8430\n    df = tm.makeTimeDataFrame()\n    g = df.groupby(pd.Grouper(freq=\"M\"))\n    g.transform(lambda x: x - 1)\n\n    # GH 9700\n    df = DataFrame({\"a\": range(5, 10), \"b\": range(5)})\n    result = df.groupby(\"a\").transform(max)\n    expected = DataFrame({\"b\": range(5)})\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 29,
        "end_line": 80,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.demean#58",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.demean(arr)",
        "snippet": "    def demean(arr):\n        return arr - arr.mean()",
        "begin_line": 58,
        "end_line": 59,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_fast#83",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_fast()",
        "snippet": "def test_transform_fast():\n\n    df = DataFrame({\"id\": np.arange(100000) / 3, \"val\": np.random.randn(100000)})\n\n    grp = df.groupby(\"id\")[\"val\"]\n\n    values = np.repeat(grp.mean().values, ensure_platform_int(grp.count().values))\n    expected = pd.Series(values, index=df.index, name=\"val\")\n\n    result = grp.transform(np.mean)\n    tm.assert_series_equal(result, expected)\n\n    result = grp.transform(\"mean\")\n    tm.assert_series_equal(result, expected)\n\n    # GH 12737\n    df = pd.DataFrame(\n        {\n            \"grouping\": [0, 1, 1, 3],\n            \"f\": [1.1, 2.1, 3.1, 4.5],\n            \"d\": pd.date_range(\"2014-1-1\", \"2014-1-4\"),\n            \"i\": [1, 2, 3, 4],\n        },\n        columns=[\"grouping\", \"f\", \"i\", \"d\"],\n    )\n    result = df.groupby(\"grouping\").transform(\"first\")\n\n    dates = [\n        pd.Timestamp(\"2014-1-1\"),\n        pd.Timestamp(\"2014-1-2\"),\n        pd.Timestamp(\"2014-1-2\"),\n        pd.Timestamp(\"2014-1-4\"),\n    ]\n    expected = pd.DataFrame(\n        {\"f\": [1.1, 2.1, 2.1, 4.5], \"d\": dates, \"i\": [1, 2, 2, 4]},\n        columns=[\"f\", \"i\", \"d\"],\n    )\n    tm.assert_frame_equal(result, expected)\n\n    # selection\n    result = df.groupby(\"grouping\")[[\"f\", \"i\"]].transform(\"first\")\n    expected = expected[[\"f\", \"i\"]]\n    tm.assert_frame_equal(result, expected)\n\n    # dup columns\n    df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], columns=[\"g\", \"a\", \"a\"])\n    result = df.groupby(\"g\").transform(\"first\")\n    expected = df.drop(\"g\", axis=1)\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 83,
        "end_line": 131,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_broadcast#134",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_broadcast(tsframe, ts)",
        "snippet": "def test_transform_broadcast(tsframe, ts):\n    grouped = ts.groupby(lambda x: x.month)\n    result = grouped.transform(np.mean)\n\n    tm.assert_index_equal(result.index, ts.index)\n    for _, gp in grouped:\n        assert_fp_equal(result.reindex(gp.index), gp.mean())\n\n    grouped = tsframe.groupby(lambda x: x.month)\n    result = grouped.transform(np.mean)\n    tm.assert_index_equal(result.index, tsframe.index)\n    for _, gp in grouped:\n        agged = gp.mean()\n        res = result.reindex(gp.index)\n        for col in tsframe:\n            assert_fp_equal(res[col], agged[col])\n\n    # group columns\n    grouped = tsframe.groupby({\"A\": 0, \"B\": 0, \"C\": 1, \"D\": 1}, axis=1)\n    result = grouped.transform(np.mean)\n    tm.assert_index_equal(result.index, tsframe.index)\n    tm.assert_index_equal(result.columns, tsframe.columns)\n    for _, gp in grouped:\n        agged = gp.mean(1)\n        res = result.reindex(columns=gp.columns)\n        for idx in gp.index:\n            assert_fp_equal(res.xs(idx), agged[idx])",
        "begin_line": 134,
        "end_line": 160,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_axis#163",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_axis(tsframe)",
        "snippet": "def test_transform_axis(tsframe):\n\n    # make sure that we are setting the axes\n    # correctly when on axis=0 or 1\n    # in the presence of a non-monotonic indexer\n    # GH12713\n\n    base = tsframe.iloc[0:5]\n    r = len(base.index)\n    c = len(base.columns)\n    tso = DataFrame(\n        np.random.randn(r, c), index=base.index, columns=base.columns, dtype=\"float64\"\n    )\n    # monotonic\n    ts = tso\n    grouped = ts.groupby(lambda x: x.weekday())\n    result = ts - grouped.transform(\"mean\")\n    expected = grouped.apply(lambda x: x - x.mean())\n    tm.assert_frame_equal(result, expected)\n\n    ts = ts.T\n    grouped = ts.groupby(lambda x: x.weekday(), axis=1)\n    result = ts - grouped.transform(\"mean\")\n    expected = grouped.apply(lambda x: (x.T - x.mean(1)).T)\n    tm.assert_frame_equal(result, expected)\n\n    # non-monotonic\n    ts = tso.iloc[[1, 0] + list(range(2, len(base)))]\n    grouped = ts.groupby(lambda x: x.weekday())\n    result = ts - grouped.transform(\"mean\")\n    expected = grouped.apply(lambda x: x - x.mean())\n    tm.assert_frame_equal(result, expected)\n\n    ts = ts.T\n    grouped = ts.groupby(lambda x: x.weekday(), axis=1)\n    result = ts - grouped.transform(\"mean\")\n    expected = grouped.apply(lambda x: (x.T - x.mean(1)).T)\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 163,
        "end_line": 200,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_dtype#203",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_dtype()",
        "snippet": "def test_transform_dtype():\n    # GH 9807\n    # Check transform dtype output is preserved\n    df = DataFrame([[1, 3], [2, 3]])\n    result = df.groupby(1).transform(\"mean\")\n    expected = DataFrame([[1.5], [1.5]])\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 203,
        "end_line": 209,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_bug#212",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_bug()",
        "snippet": "def test_transform_bug():\n    # GH 5712\n    # transforming on a datetime column\n    df = DataFrame(dict(A=Timestamp(\"20130101\"), B=np.arange(5)))\n    result = df.groupby(\"A\")[\"B\"].transform(lambda x: x.rank(ascending=False))\n    expected = Series(np.arange(5, 0, step=-1), name=\"B\")\n    tm.assert_series_equal(result, expected)",
        "begin_line": 212,
        "end_line": 218,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_numeric_to_boolean#221",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_numeric_to_boolean()",
        "snippet": "def test_transform_numeric_to_boolean():\n    # GH 16875\n    # inconsistency in transforming boolean values\n    expected = pd.Series([True, True], name=\"A\")\n\n    df = pd.DataFrame({\"A\": [1.1, 2.2], \"B\": [1, 2]})\n    result = df.groupby(\"B\").A.transform(lambda x: True)\n    tm.assert_series_equal(result, expected)\n\n    df = pd.DataFrame({\"A\": [1, 2], \"B\": [1, 2]})\n    result = df.groupby(\"B\").A.transform(lambda x: True)\n    tm.assert_series_equal(result, expected)",
        "begin_line": 221,
        "end_line": 232,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_datetime_to_timedelta#235",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_datetime_to_timedelta()",
        "snippet": "def test_transform_datetime_to_timedelta():\n    # GH 15429\n    # transforming a datetime to timedelta\n    df = DataFrame(dict(A=Timestamp(\"20130101\"), B=np.arange(5)))\n    expected = pd.Series([Timestamp(\"20130101\") - Timestamp(\"20130101\")] * 5, name=\"A\")\n\n    # this does date math without changing result type in transform\n    base_time = df[\"A\"][0]\n    result = (\n        df.groupby(\"A\")[\"A\"].transform(lambda x: x.max() - x.min() + base_time)\n        - base_time\n    )\n    tm.assert_series_equal(result, expected)\n\n    # this does date math and causes the transform to return timedelta\n    result = df.groupby(\"A\")[\"A\"].transform(lambda x: x.max() - x.min())\n    tm.assert_series_equal(result, expected)",
        "begin_line": 235,
        "end_line": 251,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_datetime_to_numeric#254",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_datetime_to_numeric()",
        "snippet": "def test_transform_datetime_to_numeric():\n    # GH 10972\n    # convert dt to float\n    df = DataFrame({\"a\": 1, \"b\": date_range(\"2015-01-01\", periods=2, freq=\"D\")})\n    result = df.groupby(\"a\").b.transform(\n        lambda x: x.dt.dayofweek - x.dt.dayofweek.mean()\n    )\n\n    expected = Series([-0.5, 0.5], name=\"b\")\n    tm.assert_series_equal(result, expected)\n\n    # convert dt to int\n    df = DataFrame({\"a\": 1, \"b\": date_range(\"2015-01-01\", periods=2, freq=\"D\")})\n    result = df.groupby(\"a\").b.transform(\n        lambda x: x.dt.dayofweek - x.dt.dayofweek.min()\n    )\n\n    expected = Series([0, 1], name=\"b\")\n    tm.assert_series_equal(result, expected)",
        "begin_line": 254,
        "end_line": 272,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_casting#275",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_casting()",
        "snippet": "def test_transform_casting():\n    # 13046\n    data = \"\"\"\n    idx     A         ID3              DATETIME\n    0   B-028  b76cd912ff \"2014-10-08 13:43:27\"\n    1   B-054  4a57ed0b02 \"2014-10-08 14:26:19\"\n    2   B-076  1a682034f8 \"2014-10-08 14:29:01\"\n    3   B-023  b76cd912ff \"2014-10-08 18:39:34\"\n    4   B-023  f88g8d7sds \"2014-10-08 18:40:18\"\n    5   B-033  b76cd912ff \"2014-10-08 18:44:30\"\n    6   B-032  b76cd912ff \"2014-10-08 18:46:00\"\n    7   B-037  b76cd912ff \"2014-10-08 18:52:15\"\n    8   B-046  db959faf02 \"2014-10-08 18:59:59\"\n    9   B-053  b76cd912ff \"2014-10-08 19:17:48\"\n    10  B-065  b76cd912ff \"2014-10-08 19:21:38\"\n    \"\"\"\n    df = pd.read_csv(\n        StringIO(data), sep=r\"\\s+\", index_col=[0], parse_dates=[\"DATETIME\"]\n    )\n\n    result = df.groupby(\"ID3\")[\"DATETIME\"].transform(lambda x: x.diff())\n    assert is_timedelta64_dtype(result.dtype)\n\n    result = df[[\"ID3\", \"DATETIME\"]].groupby(\"ID3\").transform(lambda x: x.diff())\n    assert is_timedelta64_dtype(result.DATETIME.dtype)",
        "begin_line": 275,
        "end_line": 299,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_multiple#302",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_multiple(ts)",
        "snippet": "def test_transform_multiple(ts):\n    grouped = ts.groupby([lambda x: x.year, lambda x: x.month])\n\n    grouped.transform(lambda x: x * 2)\n    grouped.transform(np.mean)",
        "begin_line": 302,
        "end_line": 306,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_dispatch_transform#309",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_dispatch_transform(tsframe)",
        "snippet": "def test_dispatch_transform(tsframe):\n    df = tsframe[::5].reindex(tsframe.index)\n\n    grouped = df.groupby(lambda x: x.month)\n\n    filled = grouped.fillna(method=\"pad\")\n    fillit = lambda x: x.fillna(method=\"pad\")\n    expected = df.groupby(lambda x: x.month).transform(fillit)\n    tm.assert_frame_equal(filled, expected)",
        "begin_line": 309,
        "end_line": 317,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_select_columns#320",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_select_columns(df)",
        "snippet": "def test_transform_select_columns(df):\n    f = lambda x: x.mean()\n    result = df.groupby(\"A\")[\"C\", \"D\"].transform(f)\n\n    selection = df[[\"C\", \"D\"]]\n    expected = selection.groupby(df[\"A\"]).transform(f)\n\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 320,
        "end_line": 327,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_exclude_nuisance#330",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_exclude_nuisance(df)",
        "snippet": "def test_transform_exclude_nuisance(df):\n\n    # this also tests orderings in transform between\n    # series/frame to make sure it's consistent\n    expected = {}\n    grouped = df.groupby(\"A\")\n    expected[\"C\"] = grouped[\"C\"].transform(np.mean)\n    expected[\"D\"] = grouped[\"D\"].transform(np.mean)\n    expected = DataFrame(expected)\n    result = df.groupby(\"A\").transform(np.mean)\n\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 330,
        "end_line": 341,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_function_aliases#344",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_function_aliases(df)",
        "snippet": "def test_transform_function_aliases(df):\n    result = df.groupby(\"A\").transform(\"mean\")\n    expected = df.groupby(\"A\").transform(np.mean)\n    tm.assert_frame_equal(result, expected)\n\n    result = df.groupby(\"A\")[\"C\"].transform(\"mean\")\n    expected = df.groupby(\"A\")[\"C\"].transform(np.mean)\n    tm.assert_series_equal(result, expected)",
        "begin_line": 344,
        "end_line": 351,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_series_fast_transform_date#354",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_series_fast_transform_date()",
        "snippet": "def test_series_fast_transform_date():\n    # GH 13191\n    df = pd.DataFrame(\n        {\"grouping\": [np.nan, 1, 1, 3], \"d\": pd.date_range(\"2014-1-1\", \"2014-1-4\")}\n    )\n    result = df.groupby(\"grouping\")[\"d\"].transform(\"first\")\n    dates = [\n        pd.NaT,\n        pd.Timestamp(\"2014-1-2\"),\n        pd.Timestamp(\"2014-1-2\"),\n        pd.Timestamp(\"2014-1-4\"),\n    ]\n    expected = pd.Series(dates, name=\"d\")\n    tm.assert_series_equal(result, expected)",
        "begin_line": 354,
        "end_line": 367,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_length#370",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_length()",
        "snippet": "def test_transform_length():\n    # GH 9697\n    df = pd.DataFrame({\"col1\": [1, 1, 2, 2], \"col2\": [1, 2, 3, np.nan]})\n    expected = pd.Series([3.0] * 4)\n\n    def nsum(x):\n        return np.nansum(x)\n\n    results = [\n        df.groupby(\"col1\").transform(sum)[\"col2\"],\n        df.groupby(\"col1\")[\"col2\"].transform(sum),\n        df.groupby(\"col1\").transform(nsum)[\"col2\"],\n        df.groupby(\"col1\")[\"col2\"].transform(nsum),\n    ]\n    for result in results:\n        tm.assert_series_equal(result, expected, check_names=False)",
        "begin_line": 370,
        "end_line": 385,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.nsum#375",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.nsum(x)",
        "snippet": "    def nsum(x):\n        return np.nansum(x)",
        "begin_line": 375,
        "end_line": 376,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_coercion#388",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_coercion()",
        "snippet": "def test_transform_coercion():\n\n    # 14457\n    # when we are transforming be sure to not coerce\n    # via assignment\n    df = pd.DataFrame(dict(A=[\"a\", \"a\"], B=[0, 1]))\n    g = df.groupby(\"A\")\n\n    expected = g.transform(np.mean)\n    result = g.transform(lambda x: np.mean(x))\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 388,
        "end_line": 398,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_groupby_transform_with_int#401",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_groupby_transform_with_int()",
        "snippet": "def test_groupby_transform_with_int():\n\n    # GH 3740, make sure that we might upcast on item-by-item transform\n\n    # floats\n    df = DataFrame(\n        dict(\n            A=[1, 1, 1, 2, 2, 2],\n            B=Series(1, dtype=\"float64\"),\n            C=Series([1, 2, 3, 1, 2, 3], dtype=\"float64\"),\n            D=\"foo\",\n        )\n    )\n    with np.errstate(all=\"ignore\"):\n        result = df.groupby(\"A\").transform(lambda x: (x - x.mean()) / x.std())\n    expected = DataFrame(\n        dict(B=np.nan, C=Series([-1, 0, 1, -1, 0, 1], dtype=\"float64\"))\n    )\n    tm.assert_frame_equal(result, expected)\n\n    # int case\n    df = DataFrame(dict(A=[1, 1, 1, 2, 2, 2], B=1, C=[1, 2, 3, 1, 2, 3], D=\"foo\"))\n    with np.errstate(all=\"ignore\"):\n        result = df.groupby(\"A\").transform(lambda x: (x - x.mean()) / x.std())\n    expected = DataFrame(dict(B=np.nan, C=[-1, 0, 1, -1, 0, 1]))\n    tm.assert_frame_equal(result, expected)\n\n    # int that needs float conversion\n    s = Series([2, 3, 4, 10, 5, -1])\n    df = DataFrame(dict(A=[1, 1, 1, 2, 2, 2], B=1, C=s, D=\"foo\"))\n    with np.errstate(all=\"ignore\"):\n        result = df.groupby(\"A\").transform(lambda x: (x - x.mean()) / x.std())\n\n    s1 = s.iloc[0:3]\n    s1 = (s1 - s1.mean()) / s1.std()\n    s2 = s.iloc[3:6]\n    s2 = (s2 - s2.mean()) / s2.std()\n    expected = DataFrame(dict(B=np.nan, C=concat([s1, s2])))\n    tm.assert_frame_equal(result, expected)\n\n    # int downcasting\n    result = df.groupby(\"A\").transform(lambda x: x * 2 / 2)\n    expected = DataFrame(dict(B=1, C=[2, 3, 4, 10, 5, -1]))\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 401,
        "end_line": 444,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_groupby_transform_with_nan_group#447",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_groupby_transform_with_nan_group()",
        "snippet": "def test_groupby_transform_with_nan_group():\n    # GH 9941\n    df = pd.DataFrame({\"a\": range(10), \"b\": [1, 1, 2, 3, np.nan, 4, 4, 5, 5, 5]})\n    result = df.groupby(df.b)[\"a\"].transform(max)\n    expected = pd.Series(\n        [1.0, 1.0, 2.0, 3.0, np.nan, 6.0, 6.0, 9.0, 9.0, 9.0], name=\"a\"\n    )\n    tm.assert_series_equal(result, expected)",
        "begin_line": 447,
        "end_line": 454,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_mixed_type#457",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_mixed_type()",
        "snippet": "def test_transform_mixed_type():\n    index = MultiIndex.from_arrays([[0, 0, 0, 1, 1, 1], [1, 2, 3, 1, 2, 3]])\n    df = DataFrame(\n        {\n            \"d\": [1.0, 1.0, 1.0, 2.0, 2.0, 2.0],\n            \"c\": np.tile([\"a\", \"b\", \"c\"], 2),\n            \"v\": np.arange(1.0, 7.0),\n        },\n        index=index,\n    )\n\n    def f(group):\n        group[\"g\"] = group[\"d\"] * 2\n        return group[:1]\n\n    grouped = df.groupby(\"c\")\n    result = grouped.apply(f)\n\n    assert result[\"d\"].dtype == np.float64\n\n    # this is by definition a mutating operation!\n    with pd.option_context(\"mode.chained_assignment\", None):\n        for key, group in grouped:\n            res = f(group)\n            tm.assert_frame_equal(res, result.loc[key])",
        "begin_line": 457,
        "end_line": 481,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.f#468",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.f(group)",
        "snippet": "    def f(group):\n        group[\"g\"] = group[\"d\"] * 2\n        return group[:1]",
        "begin_line": 468,
        "end_line": 470,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform._check_cython_group_transform_cumulative#484",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform._check_cython_group_transform_cumulative(pd_op, np_op, dtype)",
        "snippet": "def _check_cython_group_transform_cumulative(pd_op, np_op, dtype):\n    \"\"\"\n    Check a group transform that executes a cumulative function.\n\n    Parameters\n    ----------\n    pd_op : callable\n        The pandas cumulative function.\n    np_op : callable\n        The analogous one in NumPy.\n    dtype : type\n        The specified dtype of the data.\n    \"\"\"\n\n    is_datetimelike = False\n\n    data = np.array([[1], [2], [3], [4]], dtype=dtype)\n    ans = np.zeros_like(data)\n\n    labels = np.array([0, 0, 0, 0], dtype=np.int64)\n    ngroups = 1\n    pd_op(ans, data, labels, ngroups, is_datetimelike)\n\n    tm.assert_numpy_array_equal(np_op(data), ans[:, 0], check_dtype=False)",
        "begin_line": 484,
        "end_line": 507,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_cython_group_transform_cumsum#510",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_cython_group_transform_cumsum(any_real_dtype)",
        "snippet": "def test_cython_group_transform_cumsum(any_real_dtype):\n    # see gh-4095\n    dtype = np.dtype(any_real_dtype).type\n    pd_op, np_op = groupby.group_cumsum, np.cumsum\n    _check_cython_group_transform_cumulative(pd_op, np_op, dtype)",
        "begin_line": 510,
        "end_line": 514,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_cython_group_transform_cumprod#517",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_cython_group_transform_cumprod()",
        "snippet": "def test_cython_group_transform_cumprod():\n    # see gh-4095\n    dtype = np.float64\n    pd_op, np_op = groupby.group_cumprod_float64, np.cumproduct\n    _check_cython_group_transform_cumulative(pd_op, np_op, dtype)",
        "begin_line": 517,
        "end_line": 521,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_cython_group_transform_algos#524",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_cython_group_transform_algos()",
        "snippet": "def test_cython_group_transform_algos():\n    # see gh-4095\n    is_datetimelike = False\n\n    # with nans\n    labels = np.array([0, 0, 0, 0, 0], dtype=np.int64)\n    ngroups = 1\n\n    data = np.array([[1], [2], [3], [np.nan], [4]], dtype=\"float64\")\n    actual = np.zeros_like(data)\n    actual.fill(np.nan)\n    groupby.group_cumprod_float64(actual, data, labels, ngroups, is_datetimelike)\n    expected = np.array([1, 2, 6, np.nan, 24], dtype=\"float64\")\n    tm.assert_numpy_array_equal(actual[:, 0], expected)\n\n    actual = np.zeros_like(data)\n    actual.fill(np.nan)\n    groupby.group_cumsum(actual, data, labels, ngroups, is_datetimelike)\n    expected = np.array([1, 3, 6, np.nan, 10], dtype=\"float64\")\n    tm.assert_numpy_array_equal(actual[:, 0], expected)\n\n    # timedelta\n    is_datetimelike = True\n    data = np.array([np.timedelta64(1, \"ns\")] * 5, dtype=\"m8[ns]\")[:, None]\n    actual = np.zeros_like(data, dtype=\"int64\")\n    groupby.group_cumsum(actual, data.view(\"int64\"), labels, ngroups, is_datetimelike)\n    expected = np.array(\n        [\n            np.timedelta64(1, \"ns\"),\n            np.timedelta64(2, \"ns\"),\n            np.timedelta64(3, \"ns\"),\n            np.timedelta64(4, \"ns\"),\n            np.timedelta64(5, \"ns\"),\n        ]\n    )\n    tm.assert_numpy_array_equal(actual[:, 0].view(\"m8[ns]\"), expected)",
        "begin_line": 524,
        "end_line": 559,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_cython_transform_series#571",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_cython_transform_series(op, args, targop)",
        "snippet": "def test_cython_transform_series(op, args, targop):\n    # GH 4095\n    s = Series(np.random.randn(1000))\n    s_missing = s.copy()\n    s_missing.iloc[2:10] = np.nan\n    labels = np.random.randint(0, 50, size=1000).astype(float)\n\n    # series\n    for data in [s, s_missing]:\n        # print(data.head())\n        expected = data.groupby(labels).transform(targop)\n\n        tm.assert_series_equal(expected, data.groupby(labels).transform(op, *args))\n        tm.assert_series_equal(expected, getattr(data.groupby(labels), op)(*args))",
        "begin_line": 571,
        "end_line": 584,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_groupby_cum_skipna#632",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_groupby_cum_skipna(op, skipna, input, exp)",
        "snippet": "def test_groupby_cum_skipna(op, skipna, input, exp):\n    df = pd.DataFrame(input)\n    result = df.groupby(\"key\")[\"value\"].transform(op, skipna=skipna)\n    if isinstance(exp, dict):\n        expected = exp[(op, skipna)]\n    else:\n        expected = exp\n    expected = pd.Series(expected, name=\"value\")\n    tm.assert_series_equal(expected, result)",
        "begin_line": 632,
        "end_line": 640,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_cython_transform_frame#652",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_cython_transform_frame(op, args, targop)",
        "snippet": "def test_cython_transform_frame(op, args, targop):\n    s = Series(np.random.randn(1000))\n    s_missing = s.copy()\n    s_missing.iloc[2:10] = np.nan\n    labels = np.random.randint(0, 50, size=1000).astype(float)\n    strings = list(\"qwertyuiopasdfghjklz\")\n    strings_missing = strings[:]\n    strings_missing[5] = np.nan\n    df = DataFrame(\n        {\n            \"float\": s,\n            \"float_missing\": s_missing,\n            \"int\": [1, 1, 1, 1, 2] * 200,\n            \"datetime\": pd.date_range(\"1990-1-1\", periods=1000),\n            \"timedelta\": pd.timedelta_range(1, freq=\"s\", periods=1000),\n            \"string\": strings * 50,\n            \"string_missing\": strings_missing * 50,\n        },\n        columns=[\n            \"float\",\n            \"float_missing\",\n            \"int\",\n            \"datetime\",\n            \"timedelta\",\n            \"string\",\n            \"string_missing\",\n        ],\n    )\n    df[\"cat\"] = df[\"string\"].astype(\"category\")\n\n    df2 = df.copy()\n    df2.index = pd.MultiIndex.from_product([range(100), range(10)])\n\n    # DataFrame - Single and MultiIndex,\n    # group by values, index level, columns\n    for df in [df, df2]:\n        for gb_target in [\n            dict(by=labels),\n            dict(level=0),\n            dict(by=\"string\"),\n        ]:  # dict(by='string_missing')]:\n            # dict(by=['int','string'])]:\n\n            gb = df.groupby(**gb_target)\n            # whitelisted methods set the selection before applying\n            # bit a of hack to make sure the cythonized shift\n            # is equivalent to pre 0.17.1 behavior\n            if op == \"shift\":\n                gb._set_group_selection()\n\n            if op != \"shift\" and \"int\" not in gb_target:\n                # numeric apply fastpath promotes dtype so have\n                # to apply separately and concat\n                i = gb[[\"int\"]].apply(targop)\n                f = gb[[\"float\", \"float_missing\"]].apply(targop)\n                expected = pd.concat([f, i], axis=1)\n            else:\n                expected = gb.apply(targop)\n\n            expected = expected.sort_index(axis=1)\n            tm.assert_frame_equal(expected, gb.transform(op, *args).sort_index(axis=1))\n            tm.assert_frame_equal(expected, getattr(gb, op)(*args).sort_index(axis=1))\n            # individual columns\n            for c in df:\n                if c not in [\"float\", \"int\", \"float_missing\"] and op != \"shift\":\n                    msg = \"No numeric types to aggregate\"\n                    with pytest.raises(DataError, match=msg):\n                        gb[c].transform(op)\n                    with pytest.raises(DataError, match=msg):\n                        getattr(gb[c], op)()\n                else:\n                    expected = gb[c].apply(targop)\n                    expected.name = c\n                    tm.assert_series_equal(expected, gb[c].transform(op, *args))\n                    tm.assert_series_equal(expected, getattr(gb[c], op)(*args))",
        "begin_line": 652,
        "end_line": 726,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_with_non_scalar_group#729",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_with_non_scalar_group()",
        "snippet": "def test_transform_with_non_scalar_group():\n    # GH 10165\n    cols = pd.MultiIndex.from_tuples(\n        [\n            (\"syn\", \"A\"),\n            (\"mis\", \"A\"),\n            (\"non\", \"A\"),\n            (\"syn\", \"C\"),\n            (\"mis\", \"C\"),\n            (\"non\", \"C\"),\n            (\"syn\", \"T\"),\n            (\"mis\", \"T\"),\n            (\"non\", \"T\"),\n            (\"syn\", \"G\"),\n            (\"mis\", \"G\"),\n            (\"non\", \"G\"),\n        ]\n    )\n    df = pd.DataFrame(\n        np.random.randint(1, 10, (4, 12)), columns=cols, index=[\"A\", \"C\", \"G\", \"T\"]\n    )\n\n    msg = \"transform must return a scalar value for each group.*\"\n    with pytest.raises(ValueError, match=msg):\n        df.groupby(axis=1, level=1).transform(lambda z: z.div(z.sum(axis=1), axis=0))",
        "begin_line": 729,
        "end_line": 753,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_numeric_ret#768",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_numeric_ret(cols, exp, comp_func, agg_func, request)",
        "snippet": "def test_transform_numeric_ret(cols, exp, comp_func, agg_func, request):\n    if agg_func == \"size\" and isinstance(cols, list):\n        # https://github.com/pytest-dev/pytest/issues/6300\n        # workaround to xfail fixture/param permutations\n        reason = \"'size' transformation not supported with NDFrameGroupy\"\n        request.node.add_marker(pytest.mark.xfail(reason=reason))\n\n    # GH 19200\n    df = pd.DataFrame(\n        {\"a\": pd.date_range(\"2018-01-01\", periods=3), \"b\": range(3), \"c\": range(7, 10)}\n    )\n\n    result = df.groupby(\"b\")[cols].transform(agg_func)\n\n    if agg_func == \"rank\":\n        exp = exp.astype(\"float\")\n\n    comp_func(result, exp)",
        "begin_line": 768,
        "end_line": 785,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_group_fill_methods#808",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_group_fill_methods(mix_groupings, as_series, val1, val2, fill_method, limit, exp_vals)",
        "snippet": "def test_group_fill_methods(\n    mix_groupings, as_series, val1, val2, fill_method, limit, exp_vals\n):\n    vals = [np.nan, np.nan, val1, np.nan, np.nan, val2, np.nan, np.nan]\n    _exp_vals = list(exp_vals)\n    # Overwrite placeholder values\n    for index, exp_val in enumerate(_exp_vals):\n        if exp_val == \"val1\":\n            _exp_vals[index] = val1\n        elif exp_val == \"val2\":\n            _exp_vals[index] = val2\n\n    # Need to modify values and expectations depending on the\n    # Series / DataFrame that we ultimately want to generate\n    if mix_groupings:  # ['a', 'b', 'a, 'b', ...]\n        keys = [\"a\", \"b\"] * len(vals)\n\n        def interweave(list_obj):\n            temp = list()\n            for x in list_obj:\n                temp.extend([x, x])\n\n            return temp\n\n        _exp_vals = interweave(_exp_vals)\n        vals = interweave(vals)\n    else:  # ['a', 'a', 'a', ... 'b', 'b', 'b']\n        keys = [\"a\"] * len(vals) + [\"b\"] * len(vals)\n        _exp_vals = _exp_vals * 2\n        vals = vals * 2\n\n    df = DataFrame({\"key\": keys, \"val\": vals})\n    if as_series:\n        result = getattr(df.groupby(\"key\")[\"val\"], fill_method)(limit=limit)\n        exp = Series(_exp_vals, name=\"val\")\n        tm.assert_series_equal(result, exp)\n    else:\n        result = getattr(df.groupby(\"key\"), fill_method)(limit=limit)\n        exp = DataFrame({\"val\": _exp_vals})\n        tm.assert_frame_equal(result, exp)",
        "begin_line": 808,
        "end_line": 847,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.interweave#825",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.interweave(list_obj)",
        "snippet": "        def interweave(list_obj):\n            temp = list()\n            for x in list_obj:\n                temp.extend([x, x])\n\n            return temp",
        "begin_line": 825,
        "end_line": 830,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_pad_stable_sorting#851",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_pad_stable_sorting(fill_method)",
        "snippet": "def test_pad_stable_sorting(fill_method):\n    # GH 21207\n    x = [0] * 20\n    y = [np.nan] * 10 + [1] * 10\n\n    if fill_method == \"bfill\":\n        y = y[::-1]\n\n    df = pd.DataFrame({\"x\": x, \"y\": y})\n    expected = df.drop(\"x\", 1)\n\n    result = getattr(df.groupby(\"x\"), fill_method)()\n\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 851,
        "end_line": 864,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_pct_change#883",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_pct_change(test_series, freq, periods, fill_method, limit)",
        "snippet": "def test_pct_change(test_series, freq, periods, fill_method, limit):\n    # GH  21200, 21621, 30463\n    vals = [3, np.nan, np.nan, np.nan, 1, 2, 4, 10, np.nan, 4]\n    keys = [\"a\", \"b\"]\n    key_v = np.repeat(keys, len(vals))\n    df = DataFrame({\"key\": key_v, \"vals\": vals * 2})\n\n    df_g = df\n    if fill_method is not None:\n        df_g = getattr(df.groupby(\"key\"), fill_method)(limit=limit)\n    grp = df_g.groupby(df.key)\n\n    expected = grp[\"vals\"].obj / grp[\"vals\"].shift(periods) - 1\n\n    if test_series:\n        result = df.groupby(\"key\")[\"vals\"].pct_change(\n            periods=periods, fill_method=fill_method, limit=limit, freq=freq\n        )\n        tm.assert_series_equal(result, expected)\n    else:\n        result = df.groupby(\"key\").pct_change(\n            periods=periods, fill_method=fill_method, limit=limit, freq=freq\n        )\n        tm.assert_frame_equal(result, expected.to_frame(\"vals\"))",
        "begin_line": 883,
        "end_line": 906,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_ffill_bfill_non_unique_multilevel#916",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_ffill_bfill_non_unique_multilevel(func, expected_status)",
        "snippet": "def test_ffill_bfill_non_unique_multilevel(func, expected_status):\n    # GH 19437\n    date = pd.to_datetime(\n        [\n            \"2018-01-01\",\n            \"2018-01-01\",\n            \"2018-01-01\",\n            \"2018-01-01\",\n            \"2018-01-02\",\n            \"2018-01-01\",\n            \"2018-01-02\",\n        ]\n    )\n    symbol = [\"MSFT\", \"MSFT\", \"MSFT\", \"AAPL\", \"AAPL\", \"TSLA\", \"TSLA\"]\n    status = [\"shrt\", np.nan, \"lng\", np.nan, \"shrt\", \"ntrl\", np.nan]\n\n    df = DataFrame({\"date\": date, \"symbol\": symbol, \"status\": status})\n    df = df.set_index([\"date\", \"symbol\"])\n    result = getattr(df.groupby(\"symbol\")[\"status\"], func)()\n\n    index = MultiIndex.from_tuples(\n        tuples=list(zip(*[date, symbol])), names=[\"date\", \"symbol\"]\n    )\n    expected = Series(expected_status, index=index, name=\"status\")\n\n    tm.assert_series_equal(result, expected)",
        "begin_line": 916,
        "end_line": 941,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_any_all_np_func#945",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_any_all_np_func(func)",
        "snippet": "def test_any_all_np_func(func):\n    # GH 20653\n    df = pd.DataFrame(\n        [[\"foo\", True], [np.nan, True], [\"foo\", True]], columns=[\"key\", \"val\"]\n    )\n\n    exp = pd.Series([True, np.nan, True], name=\"val\")\n\n    res = df.groupby(\"key\")[\"val\"].transform(func)\n    tm.assert_series_equal(res, exp)",
        "begin_line": 945,
        "end_line": 954,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_groupby_transform_rename#957",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_groupby_transform_rename()",
        "snippet": "def test_groupby_transform_rename():\n    # https://github.com/pandas-dev/pandas/issues/23461\n    def demean_rename(x):\n        result = x - x.mean()\n\n        if isinstance(x, pd.Series):\n            return result\n\n        result = result.rename(\n            columns={c: \"{}_demeaned\".format(c) for c in result.columns}\n        )\n\n        return result\n\n    df = pd.DataFrame({\"group\": list(\"ababa\"), \"value\": [1, 1, 1, 2, 2]})\n    expected = pd.DataFrame({\"value\": [-1.0 / 3, -0.5, -1.0 / 3, 0.5, 2.0 / 3]})\n\n    result = df.groupby(\"group\").transform(demean_rename)\n    tm.assert_frame_equal(result, expected)\n    result_single = df.groupby(\"group\").value.transform(demean_rename)\n    tm.assert_series_equal(result_single, expected[\"value\"])",
        "begin_line": 957,
        "end_line": 977,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.demean_rename#959",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.demean_rename(x)",
        "snippet": "    def demean_rename(x):\n        result = x - x.mean()\n\n        if isinstance(x, pd.Series):\n            return result\n\n        result = result.rename(\n            columns={c: \"{}_demeaned\".format(c) for c in result.columns}\n        )\n\n        return result",
        "begin_line": 959,
        "end_line": 969,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_groupby_transform_timezone_column#981",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_groupby_transform_timezone_column(func)",
        "snippet": "def test_groupby_transform_timezone_column(func):\n    # GH 24198\n    ts = pd.to_datetime(\"now\", utc=True).tz_convert(\"Asia/Singapore\")\n    result = pd.DataFrame({\"end_time\": [ts], \"id\": [1]})\n    result[\"max_end_time\"] = result.groupby(\"id\").end_time.transform(func)\n    expected = pd.DataFrame([[ts, 1, ts]], columns=[\"end_time\", \"id\", \"max_end_time\"])\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 981,
        "end_line": 987,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_groupby_transform_with_datetimes#997",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_groupby_transform_with_datetimes(func, values)",
        "snippet": "def test_groupby_transform_with_datetimes(func, values):\n    # GH 15306\n    dates = pd.date_range(\"1/1/2011\", periods=10, freq=\"D\")\n\n    stocks = pd.DataFrame({\"price\": np.arange(10.0)}, index=dates)\n    stocks[\"week_id\"] = pd.to_datetime(stocks.index).week\n\n    result = stocks.groupby(stocks[\"week_id\"])[\"price\"].transform(func)\n\n    expected = pd.Series(data=pd.to_datetime(values), index=dates, name=\"price\")\n\n    tm.assert_series_equal(result, expected)",
        "begin_line": 997,
        "end_line": 1008,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_absent_categories#1012",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_absent_categories(func)",
        "snippet": "def test_transform_absent_categories(func):\n    # GH 16771\n    # cython transforms with more groups than rows\n    x_vals = [1]\n    x_cats = range(2)\n    y = [1]\n    df = DataFrame(dict(x=Categorical(x_vals, x_cats), y=y))\n    result = getattr(df.y.groupby(df.x), func)()\n    expected = df.y\n    tm.assert_series_equal(result, expected)",
        "begin_line": 1012,
        "end_line": 1021,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_ffill_not_in_axis#1026",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_ffill_not_in_axis(func, key, val)",
        "snippet": "def test_ffill_not_in_axis(func, key, val):\n    # GH 21521\n    df = pd.DataFrame([[np.nan]])\n    result = getattr(df.groupby(**{key: val}), func)()\n    expected = df\n\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 1026,
        "end_line": 1032,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_invalid_name_raises#1035",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_invalid_name_raises()",
        "snippet": "def test_transform_invalid_name_raises():\n    # GH#27486\n    df = DataFrame(dict(a=[0, 1, 1, 2]))\n    g = df.groupby([\"a\", \"b\", \"b\", \"c\"])\n    with pytest.raises(ValueError, match=\"not a valid function name\"):\n        g.transform(\"some_arbitrary_name\")\n\n    # method exists on the object, but is not a valid transformation/agg\n    assert hasattr(g, \"aggregate\")  # make sure the method exists\n    with pytest.raises(ValueError, match=\"not a valid function name\"):\n        g.transform(\"aggregate\")\n\n    # Test SeriesGroupBy\n    g = df[\"a\"].groupby([\"a\", \"b\", \"b\", \"c\"])\n    with pytest.raises(ValueError, match=\"not a valid function name\"):\n        g.transform(\"some_arbitrary_name\")",
        "begin_line": 1035,
        "end_line": 1050,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_agg_by_name#1062",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_agg_by_name(reduction_func, obj)",
        "snippet": "def test_transform_agg_by_name(reduction_func, obj):\n    func = reduction_func\n    g = obj.groupby(np.repeat([0, 1], 3))\n\n    if func == \"ngroup\":  # GH#27468\n        pytest.xfail(\"TODO: g.transform('ngroup') doesn't work\")\n    if func == \"size\":  # GH#27469\n        pytest.xfail(\"TODO: g.transform('size') doesn't work\")\n\n    args = {\"nth\": [0], \"quantile\": [0.5]}.get(func, [])\n\n    result = g.transform(func, *args)\n\n    # this is the *definition* of a transformation\n    tm.assert_index_equal(result.index, obj.index)\n    if hasattr(obj, \"columns\"):\n        tm.assert_index_equal(result.columns, obj.columns)\n\n    # verify that values were broadcasted across each group\n    assert len(set(DataFrame(result).iloc[-3:, -1])) == 1",
        "begin_line": 1062,
        "end_line": 1081,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_lambda_with_datetimetz#1084",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_lambda_with_datetimetz()",
        "snippet": "def test_transform_lambda_with_datetimetz():\n    # GH 27496\n    df = DataFrame(\n        {\n            \"time\": [\n                Timestamp(\"2010-07-15 03:14:45\"),\n                Timestamp(\"2010-11-19 18:47:06\"),\n            ],\n            \"timezone\": [\"Etc/GMT+4\", \"US/Eastern\"],\n        }\n    )\n    result = df.groupby([\"timezone\"])[\"time\"].transform(\n        lambda x: x.dt.tz_localize(x.name)\n    )\n    expected = Series(\n        [\n            Timestamp(\"2010-07-15 03:14:45\", tz=\"Etc/GMT+4\"),\n            Timestamp(\"2010-11-19 18:47:06\", tz=\"US/Eastern\"),\n        ],\n        name=\"time\",\n    )\n    tm.assert_series_equal(result, expected)",
        "begin_line": 1084,
        "end_line": 1105,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.test_transform_fastpath_raises#1108",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.test_transform_fastpath_raises()",
        "snippet": "def test_transform_fastpath_raises():\n    # GH#29631 case where fastpath defined in groupby.generic _choose_path\n    #  raises, but slow_path does not\n\n    df = pd.DataFrame({\"A\": [1, 1, 2, 2], \"B\": [1, -1, 1, 2]})\n    gb = df.groupby(\"A\")\n\n    def func(grp):\n        # we want a function such that func(frame) fails but func.apply(frame)\n        #  works\n        if grp.ndim == 2:\n            # Ensure that fast_path fails\n            raise NotImplementedError(\"Don't cross the streams\")\n        return grp * 2\n\n    # Check that the fastpath raises, see _transform_general\n    obj = gb._obj_with_exclusions\n    gen = gb.grouper.get_iterator(obj, axis=gb.axis)\n    fast_path, slow_path = gb._define_paths(func)\n    _, group = next(gen)\n\n    with pytest.raises(NotImplementedError, match=\"Don't cross the streams\"):\n        fast_path(group)\n\n    result = gb.transform(func)\n\n    expected = pd.DataFrame([2, -2, 2, 4], columns=[\"B\"])\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 1108,
        "end_line": 1135,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_transform.func#1115",
        "src_path": "pandas/tests/groupby/test_transform.py",
        "class_name": "pandas.tests.groupby.test_transform",
        "signature": "pandas.tests.groupby.test_transform.func(grp)",
        "snippet": "    def func(grp):\n        # we want a function such that func(frame) fails but func.apply(frame)\n        #  works\n        if grp.ndim == 2:\n            # Ensure that fast_path fails\n            raise NotImplementedError(\"Don't cross the streams\")\n        return grp * 2",
        "begin_line": 1115,
        "end_line": 1121,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.mframe#10",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.mframe()",
        "snippet": "def mframe():\n    index = MultiIndex(\n        levels=[[\"foo\", \"bar\", \"baz\", \"qux\"], [\"one\", \"two\", \"three\"]],\n        codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],\n        names=[\"first\", \"second\"],\n    )\n    return DataFrame(np.random.randn(10, 3), index=index, columns=[\"A\", \"B\", \"C\"])",
        "begin_line": 10,
        "end_line": 16,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.df#20",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.df()",
        "snippet": "def df():\n    return DataFrame(\n        {\n            \"A\": [\"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"foo\"],\n            \"B\": [\"one\", \"one\", \"two\", \"three\", \"two\", \"two\", \"one\", \"three\"],\n            \"C\": np.random.randn(8),\n            \"D\": np.random.randn(8),\n        }\n    )",
        "begin_line": 20,
        "end_line": 28,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.ts#32",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.ts()",
        "snippet": "def ts():\n    return tm.makeTimeSeries()",
        "begin_line": 32,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.tsd#37",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.tsd()",
        "snippet": "def tsd():\n    return tm.getTimeSeriesData()",
        "begin_line": 37,
        "end_line": 38,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.tsframe#42",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.tsframe(tsd)",
        "snippet": "def tsframe(tsd):\n    return DataFrame(tsd)",
        "begin_line": 42,
        "end_line": 43,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.df_mixed_floats#47",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.df_mixed_floats()",
        "snippet": "def df_mixed_floats():\n    return DataFrame(\n        {\n            \"A\": [\"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"foo\"],\n            \"B\": [\"one\", \"one\", \"two\", \"three\", \"two\", \"two\", \"one\", \"three\"],\n            \"C\": np.random.randn(8),\n            \"D\": np.array(np.random.randn(8), dtype=\"float32\"),\n        }\n    )",
        "begin_line": 47,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.three_group#59",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.three_group()",
        "snippet": "def three_group():\n    return DataFrame(\n        {\n            \"A\": [\n                \"foo\",\n                \"foo\",\n                \"foo\",\n                \"foo\",\n                \"bar\",\n                \"bar\",\n                \"bar\",\n                \"bar\",\n                \"foo\",\n                \"foo\",\n                \"foo\",\n            ],\n            \"B\": [\n                \"one\",\n                \"one\",\n                \"one\",\n                \"two\",\n                \"one\",\n                \"one\",\n                \"one\",\n                \"two\",\n                \"two\",\n                \"two\",\n                \"one\",\n            ],\n            \"C\": [\n                \"dull\",\n                \"dull\",\n                \"shiny\",\n                \"dull\",\n                \"dull\",\n                \"shiny\",\n                \"shiny\",\n                \"dull\",\n                \"shiny\",\n                \"shiny\",\n                \"shiny\",\n            ],\n            \"D\": np.random.randn(11),\n            \"E\": np.random.randn(11),\n            \"F\": np.random.randn(11),\n        }\n    )",
        "begin_line": 59,
        "end_line": 105,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.reduction_func#109",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.reduction_func(request)",
        "snippet": "def reduction_func(request):\n    \"\"\"yields the string names of all groupby reduction functions, one at a time.\n    \"\"\"\n    return request.param",
        "begin_line": 109,
        "end_line": 112,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.groupby_func#122",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.groupby_func(request)",
        "snippet": "def groupby_func(request):\n    \"\"\"yields both aggregation and transformation functions.\"\"\"\n    return request.param",
        "begin_line": 122,
        "end_line": 124,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalDtype.__init__#22",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalDtype",
        "signature": "pandas.tests.extension.decimal.array.DecimalDtype.__init__(self, context=None)",
        "snippet": "    def __init__(self, context=None):\n        self.context = context or decimal.getcontext()",
        "begin_line": 22,
        "end_line": 23,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalDtype.__repr__#25",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalDtype",
        "signature": "pandas.tests.extension.decimal.array.DecimalDtype.__repr__(self)",
        "snippet": "    def __repr__(self) -> str:\n        return f\"DecimalDtype(context={self.context})\"",
        "begin_line": 25,
        "end_line": 26,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalDtype.construct_array_type#29",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalDtype",
        "signature": "pandas.tests.extension.decimal.array.DecimalDtype.construct_array_type(cls)",
        "snippet": "    def construct_array_type(cls):\n        \"\"\"\n        Return the array type associated with this dtype.\n\n        Returns\n        -------\n        type\n        \"\"\"\n        return DecimalArray",
        "begin_line": 29,
        "end_line": 37,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalDtype.construct_from_string#40",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalDtype",
        "signature": "pandas.tests.extension.decimal.array.DecimalDtype.construct_from_string(cls, string)",
        "snippet": "    def construct_from_string(cls, string):\n        if string == cls.name:\n            return cls()\n        else:\n            raise TypeError(f\"Cannot construct a '{cls.__name__}' from '{string}'\")",
        "begin_line": 40,
        "end_line": 44,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalDtype._is_numeric#47",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalDtype",
        "signature": "pandas.tests.extension.decimal.array.DecimalDtype._is_numeric(self)",
        "snippet": "    def _is_numeric(self):\n        return True",
        "begin_line": 47,
        "end_line": 48,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__init__#54",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__init__(self, values, dtype=None, copy=False, context=None)",
        "snippet": "    def __init__(self, values, dtype=None, copy=False, context=None):\n        for val in values:\n            if not isinstance(val, decimal.Decimal):\n                raise TypeError(\"All values must be of type \" + str(decimal.Decimal))\n        values = np.asarray(values, dtype=object)\n\n        self._data = values\n        # Some aliases for common attribute names to ensure pandas supports\n        # these\n        self._items = self.data = self._data\n        # those aliases are currently not working due to assumptions\n        # in internal code (GH-20735)\n        # self._values = self.values = self.data\n        self._dtype = DecimalDtype(context)",
        "begin_line": 54,
        "end_line": 67,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.dtype#70",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.dtype(self)",
        "snippet": "    def dtype(self):\n        return self._dtype",
        "begin_line": 70,
        "end_line": 71,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray._from_sequence#74",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray._from_sequence(cls, scalars, dtype=None, copy=False)",
        "snippet": "    def _from_sequence(cls, scalars, dtype=None, copy=False):\n        return cls(scalars)",
        "begin_line": 74,
        "end_line": 75,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray._from_sequence_of_strings#78",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray._from_sequence_of_strings(cls, strings, dtype=None, copy=False)",
        "snippet": "    def _from_sequence_of_strings(cls, strings, dtype=None, copy=False):\n        return cls._from_sequence([decimal.Decimal(x) for x in strings], dtype, copy)",
        "begin_line": 78,
        "end_line": 79,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray._from_factorized#82",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray._from_factorized(cls, values, original)",
        "snippet": "    def _from_factorized(cls, values, original):\n        return cls(values)",
        "begin_line": 82,
        "end_line": 83,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__array_ufunc__#87",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__array_ufunc__(self, ufunc, method, *inputs, **kwargs)",
        "snippet": "    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        #\n        if not all(\n            isinstance(t, self._HANDLED_TYPES + (DecimalArray,)) for t in inputs\n        ):\n            return NotImplemented\n\n        inputs = tuple(x._data if isinstance(x, DecimalArray) else x for x in inputs)\n        result = getattr(ufunc, method)(*inputs, **kwargs)\n\n        def reconstruct(x):\n            if isinstance(x, (decimal.Decimal, numbers.Number)):\n                return x\n            else:\n                return DecimalArray._from_sequence(x)\n\n        if isinstance(result, tuple):\n            return tuple(reconstruct(x) for x in result)\n        else:\n            return reconstruct(result)",
        "begin_line": 87,
        "end_line": 106,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__getitem__#108",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__getitem__(self, item)",
        "snippet": "    def __getitem__(self, item):\n        if isinstance(item, numbers.Integral):\n            return self._data[item]\n        else:\n            return type(self)(self._data[item])",
        "begin_line": 108,
        "end_line": 112,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.take#114",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.take(self, indexer, allow_fill=False, fill_value=None)",
        "snippet": "    def take(self, indexer, allow_fill=False, fill_value=None):\n        from pandas.api.extensions import take\n\n        data = self._data\n        if allow_fill and fill_value is None:\n            fill_value = self.dtype.na_value\n\n        result = take(data, indexer, fill_value=fill_value, allow_fill=allow_fill)\n        return self._from_sequence(result)",
        "begin_line": 114,
        "end_line": 122,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.copy#124",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.copy(self)",
        "snippet": "    def copy(self):\n        return type(self)(self._data.copy())",
        "begin_line": 124,
        "end_line": 125,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.astype#127",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.astype(self, dtype, copy=True)",
        "snippet": "    def astype(self, dtype, copy=True):\n        if isinstance(dtype, type(self.dtype)):\n            return type(self)(self._data, context=dtype.context)\n        return np.asarray(self, dtype=dtype)",
        "begin_line": 127,
        "end_line": 130,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__setitem__#132",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__setitem__(self, key, value)",
        "snippet": "    def __setitem__(self, key, value):\n        if pd.api.types.is_list_like(value):\n            if pd.api.types.is_scalar(key):\n                raise ValueError(\"setting an array element with a sequence.\")\n            value = [decimal.Decimal(v) for v in value]\n        else:\n            value = decimal.Decimal(value)\n        self._data[key] = value",
        "begin_line": 132,
        "end_line": 139,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__len__#141",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__len__(self)",
        "snippet": "    def __len__(self) -> int:\n        return len(self._data)",
        "begin_line": 141,
        "end_line": 142,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.nbytes#145",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.nbytes(self)",
        "snippet": "    def nbytes(self) -> int:\n        n = len(self)\n        if n:\n            return n * sys.getsizeof(self[0])\n        return 0",
        "begin_line": 145,
        "end_line": 149,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.isna#151",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.isna(self)",
        "snippet": "    def isna(self):\n        return np.array([x.is_nan() for x in self._data], dtype=bool)",
        "begin_line": 151,
        "end_line": 152,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray._na_value#155",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray._na_value(self)",
        "snippet": "    def _na_value(self):\n        return decimal.Decimal(\"NaN\")",
        "begin_line": 155,
        "end_line": 156,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray._formatter#158",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray._formatter(self, boxed=False)",
        "snippet": "    def _formatter(self, boxed=False):\n        if boxed:\n            return \"Decimal: {0}\".format\n        return repr",
        "begin_line": 158,
        "end_line": 161,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray._concat_same_type#164",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray._concat_same_type(cls, to_concat)",
        "snippet": "    def _concat_same_type(cls, to_concat):\n        return cls(np.concatenate([x._data for x in to_concat]))",
        "begin_line": 164,
        "end_line": 165,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray._reduce#167",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray._reduce(self, name, skipna=True, **kwargs)",
        "snippet": "    def _reduce(self, name, skipna=True, **kwargs):\n\n        if skipna:\n            # If we don't have any NAs, we can ignore skipna\n            if self.isna().any():\n                other = self[~self.isna()]\n                return other._reduce(name, **kwargs)\n\n        if name == \"sum\" and len(self) == 0:\n            # GH#29630 avoid returning int 0 or np.bool_(False) on old numpy\n            return decimal.Decimal(0)\n\n        try:\n            op = getattr(self.data, name)\n        except AttributeError:\n            raise NotImplementedError(f\"decimal does not support the {name} operation\")\n        return op(axis=0)",
        "begin_line": 167,
        "end_line": 183,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.to_decimal#186",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array",
        "signature": "pandas.tests.extension.decimal.array.to_decimal(values, context=None)",
        "snippet": "def to_decimal(values, context=None):\n    return DecimalArray([decimal.Decimal(x) for x in values], context=context)",
        "begin_line": 186,
        "end_line": 187,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.make_data#190",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array",
        "signature": "pandas.tests.extension.decimal.array.make_data()",
        "snippet": "def make_data():\n    return [decimal.Decimal(random.random()) for _ in range(100)]",
        "begin_line": 190,
        "end_line": 191,
        "comment": "",
        "is_bug": false
    }
]