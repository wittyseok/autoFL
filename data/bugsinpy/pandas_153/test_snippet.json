[
    {
        "name": "pandas.tests.io.excel.conftest.frame#9",
        "src_path": "pandas/tests/io/excel/conftest.py",
        "class_name": "pandas.tests.io.excel.conftest",
        "signature": "pandas.tests.io.excel.conftest.frame(float_frame)",
        "snippet": "def frame(float_frame):\n    return float_frame[:10]",
        "begin_line": 9,
        "end_line": 10,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.conftest.tsframe#14",
        "src_path": "pandas/tests/io/excel/conftest.py",
        "class_name": "pandas.tests.io.excel.conftest",
        "signature": "pandas.tests.io.excel.conftest.tsframe()",
        "snippet": "def tsframe():\n    return tm.makeTimeDataFrame()[:5]",
        "begin_line": 14,
        "end_line": 15,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.conftest.merge_cells#19",
        "src_path": "pandas/tests/io/excel/conftest.py",
        "class_name": "pandas.tests.io.excel.conftest",
        "signature": "pandas.tests.io.excel.conftest.merge_cells(request)",
        "snippet": "def merge_cells(request):\n    return request.param",
        "begin_line": 19,
        "end_line": 20,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.conftest.df_ref#24",
        "src_path": "pandas/tests/io/excel/conftest.py",
        "class_name": "pandas.tests.io.excel.conftest",
        "signature": "pandas.tests.io.excel.conftest.df_ref()",
        "snippet": "def df_ref():\n    \"\"\"\n    Obtain the reference data from read_csv with the Python engine.\n    \"\"\"\n    df_ref = read_csv(\"test1.csv\", index_col=0, parse_dates=True, engine=\"python\")\n    return df_ref",
        "begin_line": 24,
        "end_line": 29,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.conftest.read_ext#33",
        "src_path": "pandas/tests/io/excel/conftest.py",
        "class_name": "pandas.tests.io.excel.conftest",
        "signature": "pandas.tests.io.excel.conftest.read_ext(request)",
        "snippet": "def read_ext(request):\n    \"\"\"\n    Valid extensions for reading Excel files.\n    \"\"\"\n    return request.param",
        "begin_line": 33,
        "end_line": 37,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.conftest.salaries_table#23",
        "src_path": "pandas/tests/io/conftest.py",
        "class_name": "pandas.tests.io.conftest",
        "signature": "pandas.tests.io.conftest.salaries_table(datapath)",
        "snippet": "def salaries_table(datapath):\n    \"\"\"DataFrame with the salaries dataset\"\"\"\n    return read_csv(datapath(\"io\", \"parser\", \"data\", \"salaries.csv\"), sep=\"\\t\")",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_with_single_column#17",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_with_single_column(self)",
        "snippet": "    def test_to_csv_with_single_column(self):\n        # see gh-18676, https://bugs.python.org/issue32255\n        #\n        # Python's CSV library adds an extraneous '\"\"'\n        # before the newline when the NaN-value is in\n        # the first row. Otherwise, only the newline\n        # character is added. This behavior is inconsistent\n        # and was patched in https://bugs.python.org/pull_request4672.\n        df1 = DataFrame([None, 1])\n        expected1 = \"\"\"\\\n\"\"\n1.0\n\"\"\"\n        with tm.ensure_clean(\"test.csv\") as path:\n            df1.to_csv(path, header=None, index=None)\n            with open(path, \"r\") as f:\n                assert f.read() == expected1\n\n        df2 = DataFrame([1, None])\n        expected2 = \"\"\"\\\n1.0\n\"\"\n\"\"\"\n        with tm.ensure_clean(\"test.csv\") as path:\n            df2.to_csv(path, header=None, index=None)\n            with open(path, \"r\") as f:\n                assert f.read() == expected2",
        "begin_line": 17,
        "end_line": 43,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_defualt_encoding#45",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_defualt_encoding(self)",
        "snippet": "    def test_to_csv_defualt_encoding(self):\n        # GH17097\n        df = DataFrame({\"col\": [\"AAAAA\", \"\u00c4\u00c4\u00c4\u00c4\u00c4\", \"\u00df\u00df\u00df\u00df\u00df\", \"\u805e\u805e\u805e\u805e\u805e\"]})\n\n        with tm.ensure_clean(\"test.csv\") as path:\n            # the default to_csv encoding is uft-8.\n            df.to_csv(path)\n            tm.assert_frame_equal(pd.read_csv(path, index_col=0), df)",
        "begin_line": 45,
        "end_line": 52,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_quotechar#54",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_quotechar(self)",
        "snippet": "    def test_to_csv_quotechar(self):\n        df = DataFrame({\"col\": [1, 2]})\n        expected = \"\"\"\\\n\"\",\"col\"\n\"0\",\"1\"\n\"1\",\"2\"\n\"\"\"\n\n        with tm.ensure_clean(\"test.csv\") as path:\n            df.to_csv(path, quoting=1)  # 1=QUOTE_ALL\n            with open(path, \"r\") as f:\n                assert f.read() == expected\n\n        expected = \"\"\"\\\n$$,$col$\n$0$,$1$\n$1$,$2$\n\"\"\"\n\n        with tm.ensure_clean(\"test.csv\") as path:\n            df.to_csv(path, quoting=1, quotechar=\"$\")\n            with open(path, \"r\") as f:\n                assert f.read() == expected\n\n        with tm.ensure_clean(\"test.csv\") as path:\n            with pytest.raises(TypeError, match=\"quotechar\"):\n                df.to_csv(path, quoting=1, quotechar=None)",
        "begin_line": 54,
        "end_line": 80,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_doublequote#82",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_doublequote(self)",
        "snippet": "    def test_to_csv_doublequote(self):\n        df = DataFrame({\"col\": ['a\"a', '\"bb\"']})\n        expected = '''\\\n\"\",\"col\"\n\"0\",\"a\"\"a\"\n\"1\",\"\"\"bb\"\"\"\n'''\n\n        with tm.ensure_clean(\"test.csv\") as path:\n            df.to_csv(path, quoting=1, doublequote=True)  # QUOTE_ALL\n            with open(path, \"r\") as f:\n                assert f.read() == expected\n\n        from _csv import Error\n\n        with tm.ensure_clean(\"test.csv\") as path:\n            with pytest.raises(Error, match=\"escapechar\"):\n                df.to_csv(path, doublequote=False)  # no escapechar set",
        "begin_line": 82,
        "end_line": 99,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_escapechar#101",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_escapechar(self)",
        "snippet": "    def test_to_csv_escapechar(self):\n        df = DataFrame({\"col\": ['a\"a', '\"bb\"']})\n        expected = \"\"\"\\\n\"\",\"col\"\n\"0\",\"a\\\\\"a\"\n\"1\",\"\\\\\"bb\\\\\"\"\n\"\"\"\n\n        with tm.ensure_clean(\"test.csv\") as path:  # QUOTE_ALL\n            df.to_csv(path, quoting=1, doublequote=False, escapechar=\"\\\\\")\n            with open(path, \"r\") as f:\n                assert f.read() == expected\n\n        df = DataFrame({\"col\": [\"a,a\", \",bb,\"]})\n        expected = \"\"\"\\\n,col\n0,a\\\\,a\n1,\\\\,bb\\\\,\n\"\"\"\n\n        with tm.ensure_clean(\"test.csv\") as path:\n            df.to_csv(path, quoting=3, escapechar=\"\\\\\")  # QUOTE_NONE\n            with open(path, \"r\") as f:\n                assert f.read() == expected",
        "begin_line": 101,
        "end_line": 124,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_csv_to_string#126",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_csv_to_string(self)",
        "snippet": "    def test_csv_to_string(self):\n        df = DataFrame({\"col\": [1, 2]})\n        expected_rows = [\",col\", \"0,1\", \"1,2\"]\n        expected = tm.convert_rows_list_to_csv_str(expected_rows)\n        assert df.to_csv() == expected",
        "begin_line": 126,
        "end_line": 130,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_decimal#132",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_decimal(self)",
        "snippet": "    def test_to_csv_decimal(self):\n        # see gh-781\n        df = DataFrame({\"col1\": [1], \"col2\": [\"a\"], \"col3\": [10.1]})\n\n        expected_rows = [\",col1,col2,col3\", \"0,1,a,10.1\"]\n        expected_default = tm.convert_rows_list_to_csv_str(expected_rows)\n        assert df.to_csv() == expected_default\n\n        expected_rows = [\";col1;col2;col3\", \"0;1;a;10,1\"]\n        expected_european_excel = tm.convert_rows_list_to_csv_str(expected_rows)\n        assert df.to_csv(decimal=\",\", sep=\";\") == expected_european_excel\n\n        expected_rows = [\",col1,col2,col3\", \"0,1,a,10.10\"]\n        expected_float_format_default = tm.convert_rows_list_to_csv_str(expected_rows)\n        assert df.to_csv(float_format=\"%.2f\") == expected_float_format_default\n\n        expected_rows = [\";col1;col2;col3\", \"0;1;a;10,10\"]\n        expected_float_format = tm.convert_rows_list_to_csv_str(expected_rows)\n        assert (\n            df.to_csv(decimal=\",\", sep=\";\", float_format=\"%.2f\")\n            == expected_float_format\n        )\n\n        # see gh-11553: testing if decimal is taken into account for '0.0'\n        df = pd.DataFrame({\"a\": [0, 1.1], \"b\": [2.2, 3.3], \"c\": 1})\n\n        expected_rows = [\"a,b,c\", \"0^0,2^2,1\", \"1^1,3^3,1\"]\n        expected = tm.convert_rows_list_to_csv_str(expected_rows)\n        assert df.to_csv(index=False, decimal=\"^\") == expected\n\n        # same but for an index\n        assert df.set_index(\"a\").to_csv(decimal=\"^\") == expected\n\n        # same for a multi-index\n        assert df.set_index([\"a\", \"b\"]).to_csv(decimal=\"^\") == expected",
        "begin_line": 132,
        "end_line": 166,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_float_format#168",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_float_format(self)",
        "snippet": "    def test_to_csv_float_format(self):\n        # testing if float_format is taken into account for the index\n        # GH 11553\n        df = pd.DataFrame({\"a\": [0, 1], \"b\": [2.2, 3.3], \"c\": 1})\n\n        expected_rows = [\"a,b,c\", \"0,2.20,1\", \"1,3.30,1\"]\n        expected = tm.convert_rows_list_to_csv_str(expected_rows)\n        assert df.set_index(\"a\").to_csv(float_format=\"%.2f\") == expected\n\n        # same for a multi-index\n        assert df.set_index([\"a\", \"b\"]).to_csv(float_format=\"%.2f\") == expected",
        "begin_line": 168,
        "end_line": 178,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_na_rep#180",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_na_rep(self)",
        "snippet": "    def test_to_csv_na_rep(self):\n        # see gh-11553\n        #\n        # Testing if NaN values are correctly represented in the index.\n        df = DataFrame({\"a\": [0, np.NaN], \"b\": [0, 1], \"c\": [2, 3]})\n        expected_rows = [\"a,b,c\", \"0.0,0,2\", \"_,1,3\"]\n        expected = tm.convert_rows_list_to_csv_str(expected_rows)\n\n        assert df.set_index(\"a\").to_csv(na_rep=\"_\") == expected\n        assert df.set_index([\"a\", \"b\"]).to_csv(na_rep=\"_\") == expected\n\n        # now with an index containing only NaNs\n        df = DataFrame({\"a\": np.NaN, \"b\": [0, 1], \"c\": [2, 3]})\n        expected_rows = [\"a,b,c\", \"_,0,2\", \"_,1,3\"]\n        expected = tm.convert_rows_list_to_csv_str(expected_rows)\n\n        assert df.set_index(\"a\").to_csv(na_rep=\"_\") == expected\n        assert df.set_index([\"a\", \"b\"]).to_csv(na_rep=\"_\") == expected\n\n        # check if na_rep parameter does not break anything when no NaN\n        df = DataFrame({\"a\": 0, \"b\": [0, 1], \"c\": [2, 3]})\n        expected_rows = [\"a,b,c\", \"0,0,2\", \"0,1,3\"]\n        expected = tm.convert_rows_list_to_csv_str(expected_rows)\n\n        assert df.set_index(\"a\").to_csv(na_rep=\"_\") == expected\n        assert df.set_index([\"a\", \"b\"]).to_csv(na_rep=\"_\") == expected",
        "begin_line": 180,
        "end_line": 205,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_date_format#207",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_date_format(self)",
        "snippet": "    def test_to_csv_date_format(self):\n        # GH 10209\n        df_sec = DataFrame({\"A\": pd.date_range(\"20130101\", periods=5, freq=\"s\")})\n        df_day = DataFrame({\"A\": pd.date_range(\"20130101\", periods=5, freq=\"d\")})\n\n        expected_rows = [\n            \",A\",\n            \"0,2013-01-01 00:00:00\",\n            \"1,2013-01-01 00:00:01\",\n            \"2,2013-01-01 00:00:02\",\n            \"3,2013-01-01 00:00:03\",\n            \"4,2013-01-01 00:00:04\",\n        ]\n        expected_default_sec = tm.convert_rows_list_to_csv_str(expected_rows)\n        assert df_sec.to_csv() == expected_default_sec\n\n        expected_rows = [\n            \",A\",\n            \"0,2013-01-01 00:00:00\",\n            \"1,2013-01-02 00:00:00\",\n            \"2,2013-01-03 00:00:00\",\n            \"3,2013-01-04 00:00:00\",\n            \"4,2013-01-05 00:00:00\",\n        ]\n        expected_ymdhms_day = tm.convert_rows_list_to_csv_str(expected_rows)\n        assert df_day.to_csv(date_format=\"%Y-%m-%d %H:%M:%S\") == expected_ymdhms_day\n\n        expected_rows = [\n            \",A\",\n            \"0,2013-01-01\",\n            \"1,2013-01-01\",\n            \"2,2013-01-01\",\n            \"3,2013-01-01\",\n            \"4,2013-01-01\",\n        ]\n        expected_ymd_sec = tm.convert_rows_list_to_csv_str(expected_rows)\n        assert df_sec.to_csv(date_format=\"%Y-%m-%d\") == expected_ymd_sec\n\n        expected_rows = [\n            \",A\",\n            \"0,2013-01-01\",\n            \"1,2013-01-02\",\n            \"2,2013-01-03\",\n            \"3,2013-01-04\",\n            \"4,2013-01-05\",\n        ]\n        expected_default_day = tm.convert_rows_list_to_csv_str(expected_rows)\n        assert df_day.to_csv() == expected_default_day\n        assert df_day.to_csv(date_format=\"%Y-%m-%d\") == expected_default_day\n\n        # see gh-7791\n        #\n        # Testing if date_format parameter is taken into account\n        # for multi-indexed DataFrames.\n        df_sec[\"B\"] = 0\n        df_sec[\"C\"] = 1\n\n        expected_rows = [\"A,B,C\", \"2013-01-01,0,1\"]\n        expected_ymd_sec = tm.convert_rows_list_to_csv_str(expected_rows)\n\n        df_sec_grouped = df_sec.groupby([pd.Grouper(key=\"A\", freq=\"1h\"), \"B\"])\n        assert df_sec_grouped.mean().to_csv(date_format=\"%Y-%m-%d\") == expected_ymd_sec",
        "begin_line": 207,
        "end_line": 268,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_multi_index#270",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_multi_index(self)",
        "snippet": "    def test_to_csv_multi_index(self):\n        # see gh-6618\n        df = DataFrame([1], columns=pd.MultiIndex.from_arrays([[1], [2]]))\n\n        exp_rows = [\",1\", \",2\", \"0,1\"]\n        exp = tm.convert_rows_list_to_csv_str(exp_rows)\n        assert df.to_csv() == exp\n\n        exp_rows = [\"1\", \"2\", \"1\"]\n        exp = tm.convert_rows_list_to_csv_str(exp_rows)\n        assert df.to_csv(index=False) == exp\n\n        df = DataFrame(\n            [1],\n            columns=pd.MultiIndex.from_arrays([[1], [2]]),\n            index=pd.MultiIndex.from_arrays([[1], [2]]),\n        )\n\n        exp_rows = [\",,1\", \",,2\", \"1,2,1\"]\n        exp = tm.convert_rows_list_to_csv_str(exp_rows)\n        assert df.to_csv() == exp\n\n        exp_rows = [\"1\", \"2\", \"1\"]\n        exp = tm.convert_rows_list_to_csv_str(exp_rows)\n        assert df.to_csv(index=False) == exp\n\n        df = DataFrame([1], columns=pd.MultiIndex.from_arrays([[\"foo\"], [\"bar\"]]))\n\n        exp_rows = [\",foo\", \",bar\", \"0,1\"]\n        exp = tm.convert_rows_list_to_csv_str(exp_rows)\n        assert df.to_csv() == exp\n\n        exp_rows = [\"foo\", \"bar\", \"1\"]\n        exp = tm.convert_rows_list_to_csv_str(exp_rows)\n        assert df.to_csv(index=False) == exp",
        "begin_line": 270,
        "end_line": 304,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_single_level_multi_index#322",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_single_level_multi_index(self, ind, expected, klass)",
        "snippet": "    def test_to_csv_single_level_multi_index(self, ind, expected, klass):\n        # see gh-19589\n        result = klass(pd.Series([1], ind, name=\"data\")).to_csv(\n            line_terminator=\"\\n\", header=True\n        )\n        assert result == expected",
        "begin_line": 322,
        "end_line": 327,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_string_array_ascii#329",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_string_array_ascii(self)",
        "snippet": "    def test_to_csv_string_array_ascii(self):\n        # GH 10813\n        str_array = [{\"names\": [\"foo\", \"bar\"]}, {\"names\": [\"baz\", \"qux\"]}]\n        df = pd.DataFrame(str_array)\n        expected_ascii = \"\"\"\\\n,names\n0,\"['foo', 'bar']\"\n1,\"['baz', 'qux']\"\n\"\"\"\n        with tm.ensure_clean(\"str_test.csv\") as path:\n            df.to_csv(path, encoding=\"ascii\")\n            with open(path, \"r\") as f:\n                assert f.read() == expected_ascii",
        "begin_line": 329,
        "end_line": 341,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_string_array_utf8#343",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_string_array_utf8(self)",
        "snippet": "    def test_to_csv_string_array_utf8(self):\n        # GH 10813\n        str_array = [{\"names\": [\"foo\", \"bar\"]}, {\"names\": [\"baz\", \"qux\"]}]\n        df = pd.DataFrame(str_array)\n        expected_utf8 = \"\"\"\\\n,names\n0,\"['foo', 'bar']\"\n1,\"['baz', 'qux']\"\n\"\"\"\n        with tm.ensure_clean(\"unicode_test.csv\") as path:\n            df.to_csv(path, encoding=\"utf-8\")\n            with open(path, \"r\") as f:\n                assert f.read() == expected_utf8",
        "begin_line": 343,
        "end_line": 355,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_string_with_lf#357",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_string_with_lf(self)",
        "snippet": "    def test_to_csv_string_with_lf(self):\n        # GH 20353\n        data = {\"int\": [1, 2, 3], \"str_lf\": [\"abc\", \"d\\nef\", \"g\\nh\\n\\ni\"]}\n        df = pd.DataFrame(data)\n        with tm.ensure_clean(\"lf_test.csv\") as path:\n            # case 1: The default line terminator(=os.linesep)(PR 21406)\n            os_linesep = os.linesep.encode(\"utf-8\")\n            expected_noarg = (\n                b\"int,str_lf\"\n                + os_linesep\n                + b\"1,abc\"\n                + os_linesep\n                + b'2,\"d\\nef\"'\n                + os_linesep\n                + b'3,\"g\\nh\\n\\ni\"'\n                + os_linesep\n            )\n            df.to_csv(path, index=False)\n            with open(path, \"rb\") as f:\n                assert f.read() == expected_noarg\n        with tm.ensure_clean(\"lf_test.csv\") as path:\n            # case 2: LF as line terminator\n            expected_lf = b\"int,str_lf\\n\" b\"1,abc\\n\" b'2,\"d\\nef\"\\n' b'3,\"g\\nh\\n\\ni\"\\n'\n            df.to_csv(path, line_terminator=\"\\n\", index=False)\n            with open(path, \"rb\") as f:\n                assert f.read() == expected_lf\n        with tm.ensure_clean(\"lf_test.csv\") as path:\n            # case 3: CRLF as line terminator\n            # 'line_terminator' should not change inner element\n            expected_crlf = (\n                b\"int,str_lf\\r\\n\" b\"1,abc\\r\\n\" b'2,\"d\\nef\"\\r\\n' b'3,\"g\\nh\\n\\ni\"\\r\\n'\n            )\n            df.to_csv(path, line_terminator=\"\\r\\n\", index=False)\n            with open(path, \"rb\") as f:\n                assert f.read() == expected_crlf",
        "begin_line": 357,
        "end_line": 391,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_string_with_crlf#393",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_string_with_crlf(self)",
        "snippet": "    def test_to_csv_string_with_crlf(self):\n        # GH 20353\n        data = {\"int\": [1, 2, 3], \"str_crlf\": [\"abc\", \"d\\r\\nef\", \"g\\r\\nh\\r\\n\\r\\ni\"]}\n        df = pd.DataFrame(data)\n        with tm.ensure_clean(\"crlf_test.csv\") as path:\n            # case 1: The default line terminator(=os.linesep)(PR 21406)\n            os_linesep = os.linesep.encode(\"utf-8\")\n            expected_noarg = (\n                b\"int,str_crlf\"\n                + os_linesep\n                + b\"1,abc\"\n                + os_linesep\n                + b'2,\"d\\r\\nef\"'\n                + os_linesep\n                + b'3,\"g\\r\\nh\\r\\n\\r\\ni\"'\n                + os_linesep\n            )\n            df.to_csv(path, index=False)\n            with open(path, \"rb\") as f:\n                assert f.read() == expected_noarg\n        with tm.ensure_clean(\"crlf_test.csv\") as path:\n            # case 2: LF as line terminator\n            expected_lf = (\n                b\"int,str_crlf\\n\" b\"1,abc\\n\" b'2,\"d\\r\\nef\"\\n' b'3,\"g\\r\\nh\\r\\n\\r\\ni\"\\n'\n            )\n            df.to_csv(path, line_terminator=\"\\n\", index=False)\n            with open(path, \"rb\") as f:\n                assert f.read() == expected_lf\n        with tm.ensure_clean(\"crlf_test.csv\") as path:\n            # case 3: CRLF as line terminator\n            # 'line_terminator' should not change inner element\n            expected_crlf = (\n                b\"int,str_crlf\\r\\n\"\n                b\"1,abc\\r\\n\"\n                b'2,\"d\\r\\nef\"\\r\\n'\n                b'3,\"g\\r\\nh\\r\\n\\r\\ni\"\\r\\n'\n            )\n            df.to_csv(path, line_terminator=\"\\r\\n\", index=False)\n            with open(path, \"rb\") as f:\n                assert f.read() == expected_crlf",
        "begin_line": 393,
        "end_line": 432,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_stdout_file#434",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_stdout_file(self, capsys)",
        "snippet": "    def test_to_csv_stdout_file(self, capsys):\n        # GH 21561\n        df = pd.DataFrame(\n            [[\"foo\", \"bar\"], [\"baz\", \"qux\"]], columns=[\"name_1\", \"name_2\"]\n        )\n        expected_rows = [\",name_1,name_2\", \"0,foo,bar\", \"1,baz,qux\"]\n        expected_ascii = tm.convert_rows_list_to_csv_str(expected_rows)\n\n        df.to_csv(sys.stdout, encoding=\"ascii\")\n        captured = capsys.readouterr()\n\n        assert captured.out == expected_ascii\n        assert not sys.stdout.closed",
        "begin_line": 434,
        "end_line": 446,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_write_to_open_file#456",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_write_to_open_file(self)",
        "snippet": "    def test_to_csv_write_to_open_file(self):\n        # GH 21696\n        df = pd.DataFrame({\"a\": [\"x\", \"y\", \"z\"]})\n        expected = \"\"\"\\\nmanual header\nx\ny\nz\n\"\"\"\n        with tm.ensure_clean(\"test.txt\") as path:\n            with open(path, \"w\") as f:\n                f.write(\"manual header\\n\")\n                df.to_csv(f, header=None, index=None)\n            with open(path, \"r\") as f:\n                assert f.read() == expected",
        "begin_line": 456,
        "end_line": 470,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_write_to_open_file_with_newline_py3#472",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_write_to_open_file_with_newline_py3(self)",
        "snippet": "    def test_to_csv_write_to_open_file_with_newline_py3(self):\n        # see gh-21696\n        # see gh-20353\n        df = pd.DataFrame({\"a\": [\"x\", \"y\", \"z\"]})\n        expected_rows = [\"x\", \"y\", \"z\"]\n        expected = \"manual header\\n\" + tm.convert_rows_list_to_csv_str(expected_rows)\n        with tm.ensure_clean(\"test.txt\") as path:\n            with open(path, \"w\", newline=\"\") as f:\n                f.write(\"manual header\\n\")\n                df.to_csv(f, header=None, index=None)\n\n            with open(path, \"rb\") as f:\n                assert f.read() == bytes(expected, \"utf-8\")",
        "begin_line": 472,
        "end_line": 484,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_compression#488",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_compression(self, compression_only, read_infer, to_infer)",
        "snippet": "    def test_to_csv_compression(self, compression_only, read_infer, to_infer):\n        # see gh-15008\n        compression = compression_only\n\n        if compression == \"zip\":\n            pytest.skip(\n                \"{compression} is not supported \"\n                \"for to_csv\".format(compression=compression)\n            )\n\n        # We'll complete file extension subsequently.\n        filename = \"test.\"\n\n        if compression == \"gzip\":\n            filename += \"gz\"\n        else:\n            # xz --> .xz\n            # bz2 --> .bz2\n            filename += compression\n\n        df = DataFrame({\"A\": [1]})\n\n        to_compression = \"infer\" if to_infer else compression\n        read_compression = \"infer\" if read_infer else compression\n\n        with tm.ensure_clean(filename) as path:\n            df.to_csv(path, compression=to_compression)\n            result = pd.read_csv(path, index_col=0, compression=read_compression)\n            tm.assert_frame_equal(result, df)",
        "begin_line": 488,
        "end_line": 516,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_compression_dict#518",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_compression_dict(self, compression_only)",
        "snippet": "    def test_to_csv_compression_dict(self, compression_only):\n        # GH 26023\n        method = compression_only\n        df = DataFrame({\"ABC\": [1]})\n        filename = \"to_csv_compress_as_dict.\"\n        filename += \"gz\" if method == \"gzip\" else method\n        with tm.ensure_clean(filename) as path:\n            df.to_csv(path, compression={\"method\": method})\n            read_df = pd.read_csv(path, index_col=0)\n            tm.assert_frame_equal(read_df, df)",
        "begin_line": 518,
        "end_line": 527,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_compression_dict_no_method_raises#529",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_compression_dict_no_method_raises(self)",
        "snippet": "    def test_to_csv_compression_dict_no_method_raises(self):\n        # GH 26023\n        df = DataFrame({\"ABC\": [1]})\n        compression = {\"some_option\": True}\n        msg = \"must have key 'method'\"\n\n        with tm.ensure_clean(\"out.zip\") as path:\n            with pytest.raises(ValueError, match=msg):\n                df.to_csv(path, compression=compression)",
        "begin_line": 529,
        "end_line": 537,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_zip_arguments#543",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_zip_arguments(self, compression, archive_name)",
        "snippet": "    def test_to_csv_zip_arguments(self, compression, archive_name):\n        # GH 26023\n        from zipfile import ZipFile\n\n        df = DataFrame({\"ABC\": [1]})\n        with tm.ensure_clean(\"to_csv_archive_name.zip\") as path:\n            df.to_csv(\n                path, compression={\"method\": compression, \"archive_name\": archive_name}\n            )\n            zp = ZipFile(path)\n            expected_arcname = path if archive_name is None else archive_name\n            expected_arcname = os.path.basename(expected_arcname)\n            assert len(zp.filelist) == 1\n            archived_file = os.path.basename(zp.filelist[0].filename)\n            assert archived_file == expected_arcname",
        "begin_line": 543,
        "end_line": 557,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_na_rep_long_string#560",
        "src_path": "pandas/tests/io/formats/test_to_csv.py",
        "class_name": "pandas.tests.io.formats.test_to_csv.TestToCSV",
        "signature": "pandas.tests.io.formats.test_to_csv.TestToCSV.test_to_csv_na_rep_long_string(self, df_new_type)",
        "snippet": "    def test_to_csv_na_rep_long_string(self, df_new_type):\n        # see gh-25099\n        df = pd.DataFrame({\"c\": [float(\"nan\")] * 3})\n        df = df.astype(df_new_type)\n        expected_rows = [\"c\", \"mynull\", \"mynull\", \"mynull\"]\n        expected = tm.convert_rows_list_to_csv_str(expected_rows)\n\n        result = df.to_csv(index=False, na_rep=\"mynull\", encoding=\"ascii\")\n\n        assert expected == result",
        "begin_line": 560,
        "end_line": 569,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.BaseParser.update_kwargs#13",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest.BaseParser",
        "signature": "pandas.tests.io.parser.conftest.BaseParser.update_kwargs(self, kwargs)",
        "snippet": "    def update_kwargs(self, kwargs):\n        kwargs = kwargs.copy()\n        kwargs.update(dict(engine=self.engine, low_memory=self.low_memory))\n\n        return kwargs",
        "begin_line": 13,
        "end_line": 17,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.BaseParser.read_csv#19",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest.BaseParser",
        "signature": "pandas.tests.io.parser.conftest.BaseParser.read_csv(self, *args, **kwargs)",
        "snippet": "    def read_csv(self, *args, **kwargs):\n        kwargs = self.update_kwargs(kwargs)\n        return read_csv(*args, **kwargs)",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.BaseParser.read_table#23",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest.BaseParser",
        "signature": "pandas.tests.io.parser.conftest.BaseParser.read_table(self, *args, **kwargs)",
        "snippet": "    def read_table(self, *args, **kwargs):\n        kwargs = self.update_kwargs(kwargs)\n        return read_table(*args, **kwargs)",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.csv_dir_path#47",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.csv_dir_path(datapath)",
        "snippet": "def csv_dir_path(datapath):\n    return datapath(\"io\", \"parser\", \"data\")",
        "begin_line": 47,
        "end_line": 48,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.csv1#52",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.csv1(csv_dir_path)",
        "snippet": "def csv1(csv_dir_path):\n    return os.path.join(csv_dir_path, \"test1.csv\")",
        "begin_line": 52,
        "end_line": 53,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.all_parsers#70",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.all_parsers(request)",
        "snippet": "def all_parsers(request):\n    return request.param",
        "begin_line": 70,
        "end_line": 71,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.c_parser_only#75",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.c_parser_only(request)",
        "snippet": "def c_parser_only(request):\n    return request.param",
        "begin_line": 75,
        "end_line": 76,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.python_parser_only#80",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.python_parser_only(request)",
        "snippet": "def python_parser_only(request):\n    return request.param",
        "begin_line": 80,
        "end_line": 81,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files._create_sp_series#92",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files._create_sp_series()",
        "snippet": "def _create_sp_series():\n    nan = np.nan\n\n    # nan-based\n    arr = np.arange(15, dtype=np.float64)\n    arr[7:12] = nan\n    arr[-1:] = nan\n\n    bseries = SparseSeries(arr, kind=\"block\")\n    bseries.name = \"bseries\"\n    return bseries",
        "begin_line": 92,
        "end_line": 102,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files._create_sp_tsseries#105",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files._create_sp_tsseries()",
        "snippet": "def _create_sp_tsseries():\n    nan = np.nan\n\n    # nan-based\n    arr = np.arange(15, dtype=np.float64)\n    arr[7:12] = nan\n    arr[-1:] = nan\n\n    date_index = bdate_range(\"1/1/2011\", periods=len(arr))\n    bseries = SparseSeries(arr, index=date_index, kind=\"block\")\n    bseries.name = \"btsseries\"\n    return bseries",
        "begin_line": 105,
        "end_line": 116,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files._create_sp_frame#119",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files._create_sp_frame()",
        "snippet": "def _create_sp_frame():\n    nan = np.nan\n\n    data = {\n        \"A\": [nan, nan, nan, 0, 1, 2, 3, 4, 5, 6],\n        \"B\": [0, 1, 2, nan, nan, nan, 3, 4, 5, 6],\n        \"C\": np.arange(10).astype(np.int64),\n        \"D\": [0, 1, 2, 3, 4, 5, nan, nan, nan, nan],\n    }\n\n    dates = bdate_range(\"1/1/2011\", periods=10)\n    return SparseDataFrame(data, index=dates)",
        "begin_line": 119,
        "end_line": 130,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.create_data#133",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.create_data()",
        "snippet": "def create_data():\n    \"\"\" create the pickle/msgpack data \"\"\"\n\n    data = {\n        \"A\": [0.0, 1.0, 2.0, 3.0, np.nan],\n        \"B\": [0, 1, 0, 1, 0],\n        \"C\": [\"foo1\", \"foo2\", \"foo3\", \"foo4\", \"foo5\"],\n        \"D\": date_range(\"1/1/2009\", periods=5),\n        \"E\": [0.0, 1, Timestamp(\"20100101\"), \"foo\", 2.0],\n    }\n\n    scalars = dict(timestamp=Timestamp(\"20130101\"), period=Period(\"2012\", \"M\"))\n\n    index = dict(\n        int=Index(np.arange(10)),\n        date=date_range(\"20130101\", periods=10),\n        period=period_range(\"2013-01-01\", freq=\"M\", periods=10),\n        float=Index(np.arange(10, dtype=np.float64)),\n        uint=Index(np.arange(10, dtype=np.uint64)),\n        timedelta=timedelta_range(\"00:00:00\", freq=\"30T\", periods=10),\n    )\n\n    index[\"range\"] = RangeIndex(10)\n\n    if _loose_version >= LooseVersion(\"0.21\"):\n        from pandas import interval_range\n\n        index[\"interval\"] = interval_range(0, periods=10)\n\n    mi = dict(\n        reg2=MultiIndex.from_tuples(\n            tuple(\n                zip(\n                    *[\n                        [\"bar\", \"bar\", \"baz\", \"baz\", \"foo\", \"foo\", \"qux\", \"qux\"],\n                        [\"one\", \"two\", \"one\", \"two\", \"one\", \"two\", \"one\", \"two\"],\n                    ]\n                )\n            ),\n            names=[\"first\", \"second\"],\n        )\n    )\n\n    series = dict(\n        float=Series(data[\"A\"]),\n        int=Series(data[\"B\"]),\n        mixed=Series(data[\"E\"]),\n        ts=Series(\n            np.arange(10).astype(np.int64), index=date_range(\"20130101\", periods=10)\n        ),\n        mi=Series(\n            np.arange(5).astype(np.float64),\n            index=MultiIndex.from_tuples(\n                tuple(zip(*[[1, 1, 2, 2, 2], [3, 4, 3, 4, 5]])), names=[\"one\", \"two\"]\n            ),\n        ),\n        dup=Series(np.arange(5).astype(np.float64), index=[\"A\", \"B\", \"C\", \"D\", \"A\"]),\n        cat=Series(Categorical([\"foo\", \"bar\", \"baz\"])),\n        dt=Series(date_range(\"20130101\", periods=5)),\n        dt_tz=Series(date_range(\"20130101\", periods=5, tz=\"US/Eastern\")),\n        period=Series([Period(\"2000Q1\")] * 5),\n    )\n\n    mixed_dup_df = DataFrame(data)\n    mixed_dup_df.columns = list(\"ABCDA\")\n    frame = dict(\n        float=DataFrame({\"A\": series[\"float\"], \"B\": series[\"float\"] + 1}),\n        int=DataFrame({\"A\": series[\"int\"], \"B\": series[\"int\"] + 1}),\n        mixed=DataFrame({k: data[k] for k in [\"A\", \"B\", \"C\", \"D\"]}),\n        mi=DataFrame(\n            {\"A\": np.arange(5).astype(np.float64), \"B\": np.arange(5).astype(np.int64)},\n            index=MultiIndex.from_tuples(\n                tuple(\n                    zip(\n                        *[\n                            [\"bar\", \"bar\", \"baz\", \"baz\", \"baz\"],\n                            [\"one\", \"two\", \"one\", \"two\", \"three\"],\n                        ]\n                    )\n                ),\n                names=[\"first\", \"second\"],\n            ),\n        ),\n        dup=DataFrame(\n            np.arange(15).reshape(5, 3).astype(np.float64), columns=[\"A\", \"B\", \"A\"]\n        ),\n        cat_onecol=DataFrame({\"A\": Categorical([\"foo\", \"bar\"])}),\n        cat_and_float=DataFrame(\n            {\n                \"A\": Categorical([\"foo\", \"bar\", \"baz\"]),\n                \"B\": np.arange(3).astype(np.int64),\n            }\n        ),\n        mixed_dup=mixed_dup_df,\n        dt_mixed_tzs=DataFrame(\n            {\n                \"A\": Timestamp(\"20130102\", tz=\"US/Eastern\"),\n                \"B\": Timestamp(\"20130603\", tz=\"CET\"),\n            },\n            index=range(5),\n        ),\n        dt_mixed2_tzs=DataFrame(\n            {\n                \"A\": Timestamp(\"20130102\", tz=\"US/Eastern\"),\n                \"B\": Timestamp(\"20130603\", tz=\"CET\"),\n                \"C\": Timestamp(\"20130603\", tz=\"UTC\"),\n            },\n            index=range(5),\n        ),\n    )\n\n    cat = dict(\n        int8=Categorical(list(\"abcdefg\")),\n        int16=Categorical(np.arange(1000)),\n        int32=Categorical(np.arange(10000)),\n    )\n\n    timestamp = dict(\n        normal=Timestamp(\"2011-01-01\"),\n        nat=NaT,\n        tz=Timestamp(\"2011-01-01\", tz=\"US/Eastern\"),\n    )\n\n    timestamp[\"freq\"] = Timestamp(\"2011-01-01\", freq=\"D\")\n    timestamp[\"both\"] = Timestamp(\"2011-01-01\", tz=\"Asia/Tokyo\", freq=\"M\")\n\n    off = {\n        \"DateOffset\": DateOffset(years=1),\n        \"DateOffset_h_ns\": DateOffset(hour=6, nanoseconds=5824),\n        \"BusinessDay\": BusinessDay(offset=timedelta(seconds=9)),\n        \"BusinessHour\": BusinessHour(normalize=True, n=6, end=\"15:14\"),\n        \"CustomBusinessDay\": CustomBusinessDay(weekmask=\"Mon Fri\"),\n        \"SemiMonthBegin\": SemiMonthBegin(day_of_month=9),\n        \"SemiMonthEnd\": SemiMonthEnd(day_of_month=24),\n        \"MonthBegin\": MonthBegin(1),\n        \"MonthEnd\": MonthEnd(1),\n        \"QuarterBegin\": QuarterBegin(1),\n        \"QuarterEnd\": QuarterEnd(1),\n        \"Day\": Day(1),\n        \"YearBegin\": YearBegin(1),\n        \"YearEnd\": YearEnd(1),\n        \"Week\": Week(1),\n        \"Week_Tues\": Week(2, normalize=False, weekday=1),\n        \"WeekOfMonth\": WeekOfMonth(week=3, weekday=4),\n        \"LastWeekOfMonth\": LastWeekOfMonth(n=1, weekday=3),\n        \"FY5253\": FY5253(n=2, weekday=6, startingMonth=7, variation=\"last\"),\n        \"Easter\": Easter(),\n        \"Hour\": Hour(1),\n        \"Minute\": Minute(1),\n    }\n\n    return dict(\n        series=series,\n        frame=frame,\n        index=index,\n        scalars=scalars,\n        mi=mi,\n        sp_series=dict(float=_create_sp_series(), ts=_create_sp_tsseries()),\n        sp_frame=dict(float=_create_sp_frame()),\n        cat=cat,\n        timestamp=timestamp,\n        offsets=off,\n    )",
        "begin_line": 133,
        "end_line": 295,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.create_pickle_data#298",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.create_pickle_data()",
        "snippet": "def create_pickle_data():\n    data = create_data()\n\n    return data",
        "begin_line": 298,
        "end_line": 301,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files._u#304",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files._u(x)",
        "snippet": "def _u(x):\n    return {k: _u(x[k]) for k in x} if isinstance(x, dict) else x",
        "begin_line": 304,
        "end_line": 305,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.create_msgpack_data#308",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.create_msgpack_data()",
        "snippet": "def create_msgpack_data():\n    data = create_data()\n    # Not supported\n    del data[\"sp_series\"]\n    del data[\"sp_frame\"]\n    del data[\"series\"][\"cat\"]\n    del data[\"series\"][\"period\"]\n    del data[\"frame\"][\"cat_onecol\"]\n    del data[\"frame\"][\"cat_and_float\"]\n    del data[\"scalars\"][\"period\"]\n    if _loose_version >= LooseVersion(\"0.21\") and (\n        _loose_version < LooseVersion(\"0.23.0\")\n    ):\n        del data[\"index\"][\"interval\"]\n    del data[\"offsets\"]\n    return _u(data)",
        "begin_line": 308,
        "end_line": 323,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.platform_name#326",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.platform_name()",
        "snippet": "def platform_name():\n    return \"_\".join(\n        [\n            str(pandas.__version__),\n            str(pl.machine()),\n            str(pl.system().lower()),\n            str(pl.python_version()),\n        ]\n    )",
        "begin_line": 326,
        "end_line": 334,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.write_legacy_pickles#337",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.write_legacy_pickles(output_dir)",
        "snippet": "def write_legacy_pickles(output_dir):\n\n    version = pandas.__version__\n\n    print(\n        \"This script generates a storage file for the current arch, system, \"\n        \"and python version\"\n    )\n    print(\"  pandas version: {0}\".format(version))\n    print(\"  output dir    : {0}\".format(output_dir))\n    print(\"  storage format: pickle\")\n\n    pth = \"{0}.pickle\".format(platform_name())\n\n    fh = open(os.path.join(output_dir, pth), \"wb\")\n    pickle.dump(create_pickle_data(), fh, pickle.HIGHEST_PROTOCOL)\n    fh.close()\n\n    print(\"created pickle file: {pth}\".format(pth=pth))",
        "begin_line": 337,
        "end_line": 355,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.write_legacy_msgpack#358",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.write_legacy_msgpack(output_dir, compress)",
        "snippet": "def write_legacy_msgpack(output_dir, compress):\n\n    version = pandas.__version__\n\n    print(\n        \"This script generates a storage file for the current arch, \"\n        \"system, and python version\"\n    )\n    print(\"  pandas version: {0}\".format(version))\n    print(\"  output dir    : {0}\".format(output_dir))\n    print(\"  storage format: msgpack\")\n    pth = \"{0}.msgpack\".format(platform_name())\n    to_msgpack(os.path.join(output_dir, pth), create_msgpack_data(), compress=compress)\n\n    print(\"created msgpack file: {pth}\".format(pth=pth))",
        "begin_line": 358,
        "end_line": 372,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.write_legacy_file#375",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.write_legacy_file()",
        "snippet": "def write_legacy_file():\n    # force our cwd to be the first searched\n    sys.path.insert(0, \".\")\n\n    if not (3 <= len(sys.argv) <= 4):\n        exit(\n            \"Specify output directory and storage type: generate_legacy_\"\n            \"storage_files.py <output_dir> <storage_type> \"\n            \"<msgpack_compress_type>\"\n        )\n\n    output_dir = str(sys.argv[1])\n    storage_type = str(sys.argv[2])\n    try:\n        compress_type = str(sys.argv[3])\n    except IndexError:\n        compress_type = None\n\n    if storage_type == \"pickle\":\n        write_legacy_pickles(output_dir=output_dir)\n    elif storage_type == \"msgpack\":\n        write_legacy_msgpack(output_dir=output_dir, compress=compress_type)\n    else:\n        exit(\"storage_type must be one of {'pickle', 'msgpack'}\")",
        "begin_line": 375,
        "end_line": 398,
        "comment": "",
        "is_bug": false
    }
]