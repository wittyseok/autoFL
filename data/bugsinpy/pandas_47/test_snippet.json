[
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_int#16",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_int(self)",
        "snippet": "    def test_loc_getitem_int(self):\n\n        # int label\n        self.check_result(\"loc\", 2, typs=[\"labels\"], fails=KeyError)",
        "begin_line": 16,
        "end_line": 19,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label#21",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label(self)",
        "snippet": "    def test_loc_getitem_label(self):\n\n        # label\n        self.check_result(\"loc\", \"c\", typs=[\"empty\"], fails=KeyError)",
        "begin_line": 21,
        "end_line": 24,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_out_of_range#26",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_out_of_range(self)",
        "snippet": "    def test_loc_getitem_label_out_of_range(self):\n\n        # out of range label\n        self.check_result(\n            \"loc\", \"f\", typs=[\"ints\", \"uints\", \"labels\", \"mixed\", \"ts\"], fails=KeyError,\n        )\n        self.check_result(\"loc\", \"f\", typs=[\"floats\"], fails=KeyError)\n        self.check_result(\"loc\", \"f\", typs=[\"floats\"], fails=KeyError)\n        self.check_result(\n            \"loc\", 20, typs=[\"ints\", \"uints\", \"mixed\"], fails=KeyError,\n        )\n        self.check_result(\"loc\", 20, typs=[\"labels\"], fails=KeyError)\n        self.check_result(\"loc\", 20, typs=[\"ts\"], axes=0, fails=KeyError)\n        self.check_result(\"loc\", 20, typs=[\"floats\"], axes=0, fails=KeyError)",
        "begin_line": 26,
        "end_line": 39,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_list#41",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_list(self)",
        "snippet": "    def test_loc_getitem_label_list(self):\n        # TODO: test something here?\n        # list of labels\n        pass",
        "begin_line": 41,
        "end_line": 44,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_list_with_missing#46",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_list_with_missing(self)",
        "snippet": "    def test_loc_getitem_label_list_with_missing(self):\n        self.check_result(\n            \"loc\", [0, 1, 2], typs=[\"empty\"], fails=KeyError,\n        )\n        self.check_result(\n            \"loc\", [0, 2, 10], typs=[\"ints\", \"uints\", \"floats\"], axes=0, fails=KeyError,\n        )\n\n        self.check_result(\n            \"loc\", [3, 6, 7], typs=[\"ints\", \"uints\", \"floats\"], axes=1, fails=KeyError,\n        )\n\n        # GH 17758 - MultiIndex and missing keys\n        self.check_result(\n            \"loc\", [(1, 3), (1, 4), (2, 5)], typs=[\"multi\"], axes=0, fails=KeyError,\n        )",
        "begin_line": 46,
        "end_line": 61,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_list_fails#63",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_list_fails(self)",
        "snippet": "    def test_loc_getitem_label_list_fails(self):\n        # fails\n        self.check_result(\n            \"loc\", [20, 30, 40], typs=[\"ints\", \"uints\"], axes=1, fails=KeyError,\n        )",
        "begin_line": 63,
        "end_line": 67,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_array_like#69",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_array_like(self)",
        "snippet": "    def test_loc_getitem_label_array_like(self):\n        # TODO: test something?\n        # array like\n        pass",
        "begin_line": 69,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_bool#74",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_bool(self)",
        "snippet": "    def test_loc_getitem_bool(self):\n        # boolean indexers\n        b = [True, False, True, False]\n\n        self.check_result(\"loc\", b, typs=[\"empty\"], fails=IndexError)",
        "begin_line": 74,
        "end_line": 78,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_slice#80",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc",
        "signature": "pandas.tests.indexing.test_loc.TestLoc.test_loc_getitem_label_slice(self)",
        "snippet": "    def test_loc_getitem_label_slice(self):\n\n        # label slices (with ints)\n\n        # real label slices\n\n        # GH 14316\n\n        self.check_result(\n            \"loc\",\n            slice(1, 3),\n            typs=[\"labels\", \"mixed\", \"empty\", \"ts\", \"floats\"],\n            fails=TypeError,\n        )\n\n        self.check_result(\n            \"loc\", slice(\"20130102\", \"20130104\"), typs=[\"ts\"], axes=1, fails=TypeError,\n        )\n\n        self.check_result(\n            \"loc\", slice(2, 8), typs=[\"mixed\"], axes=0, fails=TypeError,\n        )\n        self.check_result(\n            \"loc\", slice(2, 8), typs=[\"mixed\"], axes=1, fails=KeyError,\n        )\n\n        self.check_result(\n            \"loc\", slice(2, 4, 2), typs=[\"mixed\"], axes=0, fails=TypeError,\n        )",
        "begin_line": 80,
        "end_line": 108,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_dups#114",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_dups(self)",
        "snippet": "    def test_loc_getitem_dups(self):\n        # GH 5678\n        # repeated getitems on a dup index returning a ndarray\n        df = DataFrame(\n            np.random.random_sample((20, 5)), index=[\"ABCDE\"[x % 5] for x in range(20)]\n        )\n        expected = df.loc[\"A\", 0]\n        result = df.loc[:, 0].loc[\"A\"]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 114,
        "end_line": 122,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_dups2#124",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_dups2(self)",
        "snippet": "    def test_loc_getitem_dups2(self):\n\n        # GH4726\n        # dup indexing with iloc/loc\n        df = DataFrame(\n            [[1, 2, \"foo\", \"bar\", Timestamp(\"20130101\")]],\n            columns=[\"a\", \"a\", \"a\", \"a\", \"a\"],\n            index=[1],\n        )\n        expected = Series(\n            [1, 2, \"foo\", \"bar\", Timestamp(\"20130101\")],\n            index=[\"a\", \"a\", \"a\", \"a\", \"a\"],\n            name=1,\n        )\n\n        result = df.iloc[0]\n        tm.assert_series_equal(result, expected)\n\n        result = df.loc[1]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 124,
        "end_line": 143,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_dups#145",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_dups(self)",
        "snippet": "    def test_loc_setitem_dups(self):\n\n        # GH 6541\n        df_orig = DataFrame(\n            {\n                \"me\": list(\"rttti\"),\n                \"foo\": list(\"aaade\"),\n                \"bar\": np.arange(5, dtype=\"float64\") * 1.34 + 2,\n                \"bar2\": np.arange(5, dtype=\"float64\") * -0.34 + 2,\n            }\n        ).set_index(\"me\")\n\n        indexer = tuple([\"r\", [\"bar\", \"bar2\"]])\n        df = df_orig.copy()\n        df.loc[indexer] *= 2.0\n        tm.assert_series_equal(df.loc[indexer], 2.0 * df_orig.loc[indexer])\n\n        indexer = tuple([\"r\", \"bar\"])\n        df = df_orig.copy()\n        df.loc[indexer] *= 2.0\n        assert df.loc[indexer] == 2.0 * df_orig.loc[indexer]\n\n        indexer = tuple([\"t\", [\"bar\", \"bar2\"]])\n        df = df_orig.copy()\n        df.loc[indexer] *= 2.0\n        tm.assert_frame_equal(df.loc[indexer], 2.0 * df_orig.loc[indexer])",
        "begin_line": 145,
        "end_line": 170,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_slice#172",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_slice(self)",
        "snippet": "    def test_loc_setitem_slice(self):\n        # GH10503\n\n        # assigning the same type should not change the type\n        df1 = DataFrame({\"a\": [0, 1, 1], \"b\": Series([100, 200, 300], dtype=\"uint32\")})\n        ix = df1[\"a\"] == 1\n        newb1 = df1.loc[ix, \"b\"] + 1\n        df1.loc[ix, \"b\"] = newb1\n        expected = DataFrame(\n            {\"a\": [0, 1, 1], \"b\": Series([100, 201, 301], dtype=\"uint32\")}\n        )\n        tm.assert_frame_equal(df1, expected)\n\n        # assigning a new type should get the inferred type\n        df2 = DataFrame({\"a\": [0, 1, 1], \"b\": [100, 200, 300]}, dtype=\"uint64\")\n        ix = df1[\"a\"] == 1\n        newb2 = df2.loc[ix, \"b\"]\n        df1.loc[ix, \"b\"] = newb2\n        expected = DataFrame({\"a\": [0, 1, 1], \"b\": [100, 200, 300]}, dtype=\"uint64\")\n        tm.assert_frame_equal(df2, expected)",
        "begin_line": 172,
        "end_line": 191,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_dtype#193",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_dtype(self)",
        "snippet": "    def test_loc_setitem_dtype(self):\n        # GH31340\n        df = DataFrame({\"id\": [\"A\"], \"a\": [1.2], \"b\": [0.0], \"c\": [-2.5]})\n        cols = [\"a\", \"b\", \"c\"]\n        df.loc[:, cols] = df.loc[:, cols].astype(\"float32\")\n\n        expected = DataFrame(\n            {\"id\": [\"A\"], \"a\": [1.2], \"b\": [0.0], \"c\": [-2.5]}, dtype=\"float32\"\n        )  # id is inferred as object\n\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 193,
        "end_line": 203,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_getitem_label_list_with_missing#205",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_getitem_label_list_with_missing(self)",
        "snippet": "    def test_getitem_label_list_with_missing(self):\n        s = Series(range(3), index=[\"a\", \"b\", \"c\"])\n\n        # consistency\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            s[[\"a\", \"d\"]]\n\n        s = Series(range(3))\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            s[[0, 3]]",
        "begin_line": 205,
        "end_line": 214,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_bool_diff_len#217",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_bool_diff_len(self, index)",
        "snippet": "    def test_loc_getitem_bool_diff_len(self, index):\n        # GH26658\n        s = Series([1, 2, 3])\n        msg = f\"Boolean index has wrong length: {len(index)} instead of {len(s)}\"\n        with pytest.raises(IndexError, match=msg):\n            _ = s.loc[index]",
        "begin_line": 217,
        "end_line": 222,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_int_slice#224",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_int_slice(self)",
        "snippet": "    def test_loc_getitem_int_slice(self):\n        # TODO: test something here?\n        pass",
        "begin_line": 224,
        "end_line": 226,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_to_fail#228",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_to_fail(self)",
        "snippet": "    def test_loc_to_fail(self):\n\n        # GH3449\n        df = DataFrame(\n            np.random.random((3, 3)), index=[\"a\", \"b\", \"c\"], columns=[\"e\", \"f\", \"g\"]\n        )\n\n        # raise a KeyError?\n        msg = (\n            r\"\\\"None of \\[Int64Index\\(\\[1, 2\\], dtype='int64'\\)\\] are \"\n            r\"in the \\[index\\]\\\"\"\n        )\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[1, 2], [1, 2]]\n\n        # GH  7496\n        # loc should not fallback\n\n        s = Series(dtype=object)\n        s.loc[1] = 1\n        s.loc[\"a\"] = 2\n\n        with pytest.raises(KeyError, match=r\"^-1$\"):\n            s.loc[-1]\n\n        msg = (\n            r\"\\\"None of \\[Int64Index\\(\\[-1, -2\\], dtype='int64'\\)\\] are \"\n            r\"in the \\[index\\]\\\"\"\n        )\n        with pytest.raises(KeyError, match=msg):\n            s.loc[[-1, -2]]\n\n        msg = r\"\\\"None of \\[Index\\(\\['4'\\], dtype='object'\\)\\] are in the \\[index\\]\\\"\"\n        with pytest.raises(KeyError, match=msg):\n            s.loc[[\"4\"]]\n\n        s.loc[-1] = 3\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            s.loc[[-1, -2]]\n\n        s[\"a\"] = 2\n        msg = (\n            r\"\\\"None of \\[Int64Index\\(\\[-2\\], dtype='int64'\\)\\] are \"\n            r\"in the \\[index\\]\\\"\"\n        )\n        with pytest.raises(KeyError, match=msg):\n            s.loc[[-2]]\n\n        del s[\"a\"]\n\n        with pytest.raises(KeyError, match=msg):\n            s.loc[[-2]] = 0\n\n        # inconsistency between .loc[values] and .loc[values,:]\n        # GH 7999\n        df = DataFrame([[\"a\"], [\"b\"]], index=[1, 2], columns=[\"value\"])\n\n        msg = (\n            r\"\\\"None of \\[Int64Index\\(\\[3\\], dtype='int64'\\)\\] are \"\n            r\"in the \\[index\\]\\\"\"\n        )\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[3], :]\n\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[3]]",
        "begin_line": 228,
        "end_line": 293,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_list_with_fail#295",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_getitem_list_with_fail(self)",
        "snippet": "    def test_loc_getitem_list_with_fail(self):\n        # 15747\n        # should KeyError if *any* missing labels\n\n        s = Series([1, 2, 3])\n\n        s.loc[[2]]\n\n        with pytest.raises(\n            KeyError,\n            match=re.escape(\n                \"\\\"None of [Int64Index([3], dtype='int64')] are in the [index]\\\"\"\n            ),\n        ):\n            s.loc[[3]]\n\n        # a non-match and a match\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            s.loc[[2, 3]]",
        "begin_line": 295,
        "end_line": 313,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_index#315",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_index(self)",
        "snippet": "    def test_loc_index(self):\n        # gh-17131\n        # a boolean index should index like a boolean numpy array\n\n        df = DataFrame(\n            np.random.random(size=(5, 10)),\n            index=[\"alpha_0\", \"alpha_1\", \"alpha_2\", \"beta_0\", \"beta_1\"],\n        )\n\n        mask = df.index.map(lambda x: \"alpha\" in x)\n        expected = df.loc[np.array(mask)]\n\n        result = df.loc[mask]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[mask.values]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[pd.array(mask, dtype=\"boolean\")]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 315,
        "end_line": 334,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_general#336",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_general(self)",
        "snippet": "    def test_loc_general(self):\n\n        df = DataFrame(\n            np.random.rand(4, 4),\n            columns=[\"A\", \"B\", \"C\", \"D\"],\n            index=[\"A\", \"B\", \"C\", \"D\"],\n        )\n\n        # want this to work\n        result = df.loc[:, \"A\":\"B\"].iloc[0:2, :]\n        assert (result.columns == [\"A\", \"B\"]).all()\n        assert (result.index == [\"A\", \"B\"]).all()\n\n        # mixed type\n        result = DataFrame({\"a\": [Timestamp(\"20130101\")], \"b\": [1]}).iloc[0]\n        expected = Series([Timestamp(\"20130101\"), 1], index=[\"a\", \"b\"], name=0)\n        tm.assert_series_equal(result, expected)\n        assert result.dtype == object",
        "begin_line": 336,
        "end_line": 353,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_consistency#355",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_consistency(self)",
        "snippet": "    def test_loc_setitem_consistency(self):\n        # GH 6149\n        # coerce similarly for setitem and loc when rows have a null-slice\n        expected = DataFrame(\n            {\n                \"date\": Series(0, index=range(5), dtype=np.int64),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n\n        df = DataFrame(\n            {\n                \"date\": date_range(\"2000-01-01\", \"2000-01-5\"),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df.loc[:, \"date\"] = 0\n        tm.assert_frame_equal(df, expected)\n\n        df = DataFrame(\n            {\n                \"date\": date_range(\"2000-01-01\", \"2000-01-5\"),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df.loc[:, \"date\"] = np.array(0, dtype=np.int64)\n        tm.assert_frame_equal(df, expected)\n\n        df = DataFrame(\n            {\n                \"date\": date_range(\"2000-01-01\", \"2000-01-5\"),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df.loc[:, \"date\"] = np.array([0, 0, 0, 0, 0], dtype=np.int64)\n        tm.assert_frame_equal(df, expected)\n\n        expected = DataFrame(\n            {\n                \"date\": Series(\"foo\", index=range(5)),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df = DataFrame(\n            {\n                \"date\": date_range(\"2000-01-01\", \"2000-01-5\"),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df.loc[:, \"date\"] = \"foo\"\n        tm.assert_frame_equal(df, expected)\n\n        expected = DataFrame(\n            {\n                \"date\": Series(1.0, index=range(5)),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df = DataFrame(\n            {\n                \"date\": date_range(\"2000-01-01\", \"2000-01-5\"),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        df.loc[:, \"date\"] = 1.0\n        tm.assert_frame_equal(df, expected)\n\n        # GH 15494\n        # setting on frame with single row\n        df = DataFrame({\"date\": Series([Timestamp(\"20180101\")])})\n        df.loc[:, \"date\"] = \"string\"\n        expected = DataFrame({\"date\": Series([\"string\"])})\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 355,
        "end_line": 427,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_consistency_empty#429",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_consistency_empty(self)",
        "snippet": "    def test_loc_setitem_consistency_empty(self):\n        # empty (essentially noops)\n        expected = DataFrame(columns=[\"x\", \"y\"])\n        expected[\"x\"] = expected[\"x\"].astype(np.int64)\n        df = DataFrame(columns=[\"x\", \"y\"])\n        df.loc[:, \"x\"] = 1\n        tm.assert_frame_equal(df, expected)\n\n        df = DataFrame(columns=[\"x\", \"y\"])\n        df[\"x\"] = 1\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 429,
        "end_line": 439,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_consistency_slice_column_len#441",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_consistency_slice_column_len(self)",
        "snippet": "    def test_loc_setitem_consistency_slice_column_len(self):\n        # .loc[:,column] setting with slice == len of the column\n        # GH10408\n        data = \"\"\"Level_0,,,Respondent,Respondent,Respondent,OtherCat,OtherCat\nLevel_1,,,Something,StartDate,EndDate,Yes/No,SomethingElse\nRegion,Site,RespondentID,,,,,\nRegion_1,Site_1,3987227376,A,5/25/2015 10:59,5/25/2015 11:22,Yes,\nRegion_1,Site_1,3980680971,A,5/21/2015 9:40,5/21/2015 9:52,Yes,Yes\nRegion_1,Site_2,3977723249,A,5/20/2015 8:27,5/20/2015 8:41,Yes,\nRegion_1,Site_2,3977723089,A,5/20/2015 8:33,5/20/2015 9:09,Yes,No\"\"\"\n\n        df = pd.read_csv(StringIO(data), header=[0, 1], index_col=[0, 1, 2])\n        df.loc[:, (\"Respondent\", \"StartDate\")] = pd.to_datetime(\n            df.loc[:, (\"Respondent\", \"StartDate\")]\n        )\n        df.loc[:, (\"Respondent\", \"EndDate\")] = pd.to_datetime(\n            df.loc[:, (\"Respondent\", \"EndDate\")]\n        )\n        df.loc[:, (\"Respondent\", \"Duration\")] = (\n            df.loc[:, (\"Respondent\", \"EndDate\")]\n            - df.loc[:, (\"Respondent\", \"StartDate\")]\n        )\n\n        df.loc[:, (\"Respondent\", \"Duration\")] = df.loc[\n            :, (\"Respondent\", \"Duration\")\n        ].astype(\"timedelta64[s]\")\n        expected = Series(\n            [1380, 720, 840, 2160.0], index=df.index, name=(\"Respondent\", \"Duration\")\n        )\n        tm.assert_series_equal(df[(\"Respondent\", \"Duration\")], expected)",
        "begin_line": 441,
        "end_line": 470,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_assign_non_ns_datetime#473",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_assign_non_ns_datetime(self, unit)",
        "snippet": "    def test_loc_assign_non_ns_datetime(self, unit):\n        # GH 27395, non-ns dtype assignment via .loc should work\n        # and return the same result when using simple assignment\n        df = DataFrame(\n            {\n                \"timestamp\": [\n                    np.datetime64(\"2017-02-11 12:41:29\"),\n                    np.datetime64(\"1991-11-07 04:22:37\"),\n                ]\n            }\n        )\n\n        df.loc[:, unit] = df.loc[:, \"timestamp\"].values.astype(f\"datetime64[{unit}]\")\n        df[\"expected\"] = df.loc[:, \"timestamp\"].values.astype(f\"datetime64[{unit}]\")\n        expected = Series(df.loc[:, \"expected\"], name=unit)\n        tm.assert_series_equal(df.loc[:, unit], expected)",
        "begin_line": 473,
        "end_line": 488,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_modify_datetime#490",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_modify_datetime(self)",
        "snippet": "    def test_loc_modify_datetime(self):\n        # see gh-28837\n        df = DataFrame.from_dict(\n            {\"date\": [1485264372711, 1485265925110, 1540215845888, 1540282121025]}\n        )\n\n        df[\"date_dt\"] = pd.to_datetime(df[\"date\"], unit=\"ms\", cache=True)\n\n        df.loc[:, \"date_dt_cp\"] = df.loc[:, \"date_dt\"]\n        df.loc[[2, 3], \"date_dt_cp\"] = df.loc[[2, 3], \"date_dt\"]\n\n        expected = DataFrame(\n            [\n                [1485264372711, \"2017-01-24 13:26:12.711\", \"2017-01-24 13:26:12.711\"],\n                [1485265925110, \"2017-01-24 13:52:05.110\", \"2017-01-24 13:52:05.110\"],\n                [1540215845888, \"2018-10-22 13:44:05.888\", \"2018-10-22 13:44:05.888\"],\n                [1540282121025, \"2018-10-23 08:08:41.025\", \"2018-10-23 08:08:41.025\"],\n            ],\n            columns=[\"date\", \"date_dt\", \"date_dt_cp\"],\n        )\n\n        columns = [\"date_dt\", \"date_dt_cp\"]\n        expected[columns] = expected[columns].apply(pd.to_datetime)\n\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 490,
        "end_line": 514,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_frame#516",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_frame(self)",
        "snippet": "    def test_loc_setitem_frame(self):\n        df = DataFrame(np.random.randn(4, 4), index=list(\"abcd\"), columns=list(\"ABCD\"))\n\n        result = df.iloc[0, 0]\n\n        df.loc[\"a\", \"A\"] = 1\n        result = df.loc[\"a\", \"A\"]\n        assert result == 1\n\n        result = df.iloc[0, 0]\n        assert result == 1\n\n        df.loc[:, \"B\":\"D\"] = 0\n        expected = df.loc[:, \"B\":\"D\"]\n        result = df.iloc[:, 1:]\n        tm.assert_frame_equal(result, expected)\n\n        # GH 6254\n        # setting issue\n        df = DataFrame(index=[3, 5, 4], columns=[\"A\"])\n        df.loc[[4, 3, 5], \"A\"] = np.array([1, 2, 3], dtype=\"int64\")\n        expected = DataFrame(dict(A=Series([1, 2, 3], index=[4, 3, 5]))).reindex(\n            index=[3, 5, 4]\n        )\n        tm.assert_frame_equal(df, expected)\n\n        # GH 6252\n        # setting with an empty frame\n        keys1 = [\"@\" + str(i) for i in range(5)]\n        val1 = np.arange(5, dtype=\"int64\")\n\n        keys2 = [\"@\" + str(i) for i in range(4)]\n        val2 = np.arange(4, dtype=\"int64\")\n\n        index = list(set(keys1).union(keys2))\n        df = DataFrame(index=index)\n        df[\"A\"] = np.nan\n        df.loc[keys1, \"A\"] = val1\n\n        df[\"B\"] = np.nan\n        df.loc[keys2, \"B\"] = val2\n\n        expected = DataFrame(\n            dict(A=Series(val1, index=keys1), B=Series(val2, index=keys2))\n        ).reindex(index=index)\n        tm.assert_frame_equal(df, expected)\n\n        # GH 8669\n        # invalid coercion of nan -> int\n        df = DataFrame({\"A\": [1, 2, 3], \"B\": np.nan})\n        df.loc[df.B > df.A, \"B\"] = df.A\n        expected = DataFrame({\"A\": [1, 2, 3], \"B\": np.nan})\n        tm.assert_frame_equal(df, expected)\n\n        # GH 6546\n        # setting with mixed labels\n        df = DataFrame({1: [1, 2], 2: [3, 4], \"a\": [\"a\", \"b\"]})\n\n        result = df.loc[0, [1, 2]]\n        expected = Series([1, 3], index=[1, 2], dtype=object, name=0)\n        tm.assert_series_equal(result, expected)\n\n        expected = DataFrame({1: [5, 2], 2: [6, 4], \"a\": [\"a\", \"b\"]})\n        df.loc[0, [1, 2]] = [5, 6]\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 516,
        "end_line": 580,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_frame_multiples#582",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_frame_multiples(self)",
        "snippet": "    def test_loc_setitem_frame_multiples(self):\n        # multiple setting\n        df = DataFrame(\n            {\"A\": [\"foo\", \"bar\", \"baz\"], \"B\": Series(range(3), dtype=np.int64)}\n        )\n        rhs = df.loc[1:2]\n        rhs.index = df.index[0:2]\n        df.loc[0:1] = rhs\n        expected = DataFrame(\n            {\"A\": [\"bar\", \"baz\", \"baz\"], \"B\": Series([1, 2, 2], dtype=np.int64)}\n        )\n        tm.assert_frame_equal(df, expected)\n\n        # multiple setting with frame on rhs (with M8)\n        df = DataFrame(\n            {\n                \"date\": date_range(\"2000-01-01\", \"2000-01-5\"),\n                \"val\": Series(range(5), dtype=np.int64),\n            }\n        )\n        expected = DataFrame(\n            {\n                \"date\": [\n                    Timestamp(\"20000101\"),\n                    Timestamp(\"20000102\"),\n                    Timestamp(\"20000101\"),\n                    Timestamp(\"20000102\"),\n                    Timestamp(\"20000103\"),\n                ],\n                \"val\": Series([0, 1, 0, 1, 2], dtype=np.int64),\n            }\n        )\n        rhs = df.loc[0:2]\n        rhs.index = df.index[2:5]\n        df.loc[2:4] = rhs\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 582,
        "end_line": 617,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_with_scalar_index#623",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_with_scalar_index(self, indexer, value)",
        "snippet": "    def test_loc_setitem_with_scalar_index(self, indexer, value):\n        # GH #19474\n        # assigning like \"df.loc[0, ['A']] = ['Z']\" should be evaluated\n        # elementwisely, not using \"setter('A', ['Z'])\".\n\n        df = pd.DataFrame([[1, 2], [3, 4]], columns=[\"A\", \"B\"])\n        df.loc[0, indexer] = value\n        result = df.loc[0, \"A\"]\n\n        assert is_scalar(result) and result == \"Z\"",
        "begin_line": 623,
        "end_line": 632,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_missing_columns#686",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_missing_columns(self, index, box, expected)",
        "snippet": "    def test_loc_setitem_missing_columns(self, index, box, expected):\n        # GH 29334\n        df = pd.DataFrame([[1, 2], [3, 4], [5, 6]], columns=[\"A\", \"B\"])\n        df.loc[index] = box\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 686,
        "end_line": 690,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_coercion#692",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_coercion(self)",
        "snippet": "    def test_loc_coercion(self):\n\n        # 12411\n        df = DataFrame({\"date\": [Timestamp(\"20130101\").tz_localize(\"UTC\"), pd.NaT]})\n        expected = df.dtypes\n\n        result = df.iloc[[0]]\n        tm.assert_series_equal(result.dtypes, expected)\n\n        result = df.iloc[[1]]\n        tm.assert_series_equal(result.dtypes, expected)\n\n        # 12045\n        import datetime\n\n        df = DataFrame(\n            {\"date\": [datetime.datetime(2012, 1, 1), datetime.datetime(1012, 1, 2)]}\n        )\n        expected = df.dtypes\n\n        result = df.iloc[[0]]\n        tm.assert_series_equal(result.dtypes, expected)\n\n        result = df.iloc[[1]]\n        tm.assert_series_equal(result.dtypes, expected)\n\n        # 11594\n        df = DataFrame({\"text\": [\"some words\"] + [None] * 9})\n        expected = df.dtypes\n\n        result = df.iloc[0:2]\n        tm.assert_series_equal(result.dtypes, expected)\n\n        result = df.iloc[3:]\n        tm.assert_series_equal(result.dtypes, expected)",
        "begin_line": 692,
        "end_line": 726,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_setitem_new_key_tz#728",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_setitem_new_key_tz(self)",
        "snippet": "    def test_setitem_new_key_tz(self):\n        # GH#12862 should not raise on assigning the second value\n        vals = [\n            pd.to_datetime(42).tz_localize(\"UTC\"),\n            pd.to_datetime(666).tz_localize(\"UTC\"),\n        ]\n        expected = pd.Series(vals, index=[\"foo\", \"bar\"])\n\n        ser = pd.Series(dtype=object)\n        ser[\"foo\"] = vals[0]\n        ser[\"bar\"] = vals[1]\n\n        tm.assert_series_equal(ser, expected)\n\n        ser = pd.Series(dtype=object)\n        ser.loc[\"foo\"] = vals[0]\n        ser.loc[\"bar\"] = vals[1]\n\n        tm.assert_series_equal(ser, expected)",
        "begin_line": 728,
        "end_line": 746,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_non_unique#748",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_non_unique(self)",
        "snippet": "    def test_loc_non_unique(self):\n        # GH3659\n        # non-unique indexer with loc slice\n        # https://groups.google.com/forum/?fromgroups#!topic/pydata/zTm2No0crYs\n\n        # these are going to raise because the we are non monotonic\n        df = DataFrame(\n            {\"A\": [1, 2, 3, 4, 5, 6], \"B\": [3, 4, 5, 6, 7, 8]}, index=[0, 1, 0, 1, 2, 3]\n        )\n        msg = \"'Cannot get left slice bound for non-unique label: 1'\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[1:]\n        msg = \"'Cannot get left slice bound for non-unique label: 0'\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[0:]\n        msg = \"'Cannot get left slice bound for non-unique label: 1'\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[1:2]\n\n        # monotonic are ok\n        df = DataFrame(\n            {\"A\": [1, 2, 3, 4, 5, 6], \"B\": [3, 4, 5, 6, 7, 8]}, index=[0, 1, 0, 1, 2, 3]\n        ).sort_index(axis=0)\n        result = df.loc[1:]\n        expected = DataFrame({\"A\": [2, 4, 5, 6], \"B\": [4, 6, 7, 8]}, index=[1, 1, 2, 3])\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[0:]\n        tm.assert_frame_equal(result, df)\n\n        result = df.loc[1:2]\n        expected = DataFrame({\"A\": [2, 4, 5], \"B\": [4, 6, 7]}, index=[1, 1, 2])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 748,
        "end_line": 780,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_non_unique_memory_error#782",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_non_unique_memory_error(self)",
        "snippet": "    def test_loc_non_unique_memory_error(self):\n\n        # GH 4280\n        # non_unique index with a large selection triggers a memory error\n\n        columns = list(\"ABCDEFG\")\n\n        def gen_test(l, l2):\n            return pd.concat(\n                [\n                    DataFrame(\n                        np.random.randn(l, len(columns)),\n                        index=np.arange(l),\n                        columns=columns,\n                    ),\n                    DataFrame(\n                        np.ones((l2, len(columns))), index=[0] * l2, columns=columns\n                    ),\n                ]\n            )\n\n        def gen_expected(df, mask):\n            len_mask = len(mask)\n            return pd.concat(\n                [\n                    df.take([0]),\n                    DataFrame(\n                        np.ones((len_mask, len(columns))),\n                        index=[0] * len_mask,\n                        columns=columns,\n                    ),\n                    df.take(mask[1:]),\n                ]\n            )\n\n        df = gen_test(900, 100)\n        assert df.index.is_unique is False\n\n        mask = np.arange(100)\n        result = df.loc[mask]\n        expected = gen_expected(df, mask)\n        tm.assert_frame_equal(result, expected)\n\n        df = gen_test(900000, 100000)\n        assert df.index.is_unique is False\n\n        mask = np.arange(100000)\n        result = df.loc[mask]\n        expected = gen_expected(df, mask)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 782,
        "end_line": 831,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.gen_test#789",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.gen_test(l, l2)",
        "snippet": "        def gen_test(l, l2):\n            return pd.concat(\n                [\n                    DataFrame(\n                        np.random.randn(l, len(columns)),\n                        index=np.arange(l),\n                        columns=columns,\n                    ),\n                    DataFrame(\n                        np.ones((l2, len(columns))), index=[0] * l2, columns=columns\n                    ),\n                ]\n            )",
        "begin_line": 789,
        "end_line": 801,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.gen_expected#803",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.gen_expected(df, mask)",
        "snippet": "        def gen_expected(df, mask):\n            len_mask = len(mask)\n            return pd.concat(\n                [\n                    df.take([0]),\n                    DataFrame(\n                        np.ones((len_mask, len(columns))),\n                        index=[0] * len_mask,\n                        columns=columns,\n                    ),\n                    df.take(mask[1:]),\n                ]\n            )",
        "begin_line": 803,
        "end_line": 815,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_name#833",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_name(self)",
        "snippet": "    def test_loc_name(self):\n        # GH 3880\n        df = DataFrame([[1, 1], [1, 1]])\n        df.index.name = \"index_name\"\n        result = df.iloc[[0, 1]].index.name\n        assert result == \"index_name\"\n\n        result = df.loc[[0, 1]].index.name\n        assert result == \"index_name\"",
        "begin_line": 833,
        "end_line": 841,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_empty_list_indexer_is_ok#843",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_empty_list_indexer_is_ok(self)",
        "snippet": "    def test_loc_empty_list_indexer_is_ok(self):\n\n        df = tm.makeCustomDataframe(5, 2)\n        # vertical empty\n        tm.assert_frame_equal(\n            df.loc[:, []], df.iloc[:, :0], check_index_type=True, check_column_type=True\n        )\n        # horizontal empty\n        tm.assert_frame_equal(\n            df.loc[[], :], df.iloc[:0, :], check_index_type=True, check_column_type=True\n        )\n        # horizontal empty\n        tm.assert_frame_equal(\n            df.loc[[]], df.iloc[:0, :], check_index_type=True, check_column_type=True\n        )",
        "begin_line": 843,
        "end_line": 857,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_identity_slice_returns_new_object#859",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_identity_slice_returns_new_object(self)",
        "snippet": "    def test_identity_slice_returns_new_object(self):\n        # GH13873\n        original_df = DataFrame({\"a\": [1, 2, 3]})\n        sliced_df = original_df.loc[:]\n        assert sliced_df is not original_df\n        assert original_df[:] is not original_df\n\n        # should be a shallow copy\n        original_df[\"a\"] = [4, 4, 4]\n        assert (sliced_df[\"a\"] == 4).all()\n\n        # These should not return copies\n        assert original_df is original_df.loc[:, :]\n        df = DataFrame(np.random.randn(10, 4))\n        assert df[0] is df.loc[:, 0]\n\n        # Same tests for Series\n        original_series = Series([1, 2, 3, 4, 5, 6])\n        sliced_series = original_series.loc[:]\n        assert sliced_series is not original_series\n        assert original_series[:] is not original_series\n\n        original_series[:3] = [7, 8, 9]\n        assert all(sliced_series[:3] == [7, 8, 9])",
        "begin_line": 859,
        "end_line": 882,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_uint64#884",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_uint64(self)",
        "snippet": "    def test_loc_uint64(self):\n        # GH20722\n        # Test whether loc accept uint64 max value as index.\n        s = pd.Series(\n            [1, 2], index=[np.iinfo(\"uint64\").max - 1, np.iinfo(\"uint64\").max]\n        )\n\n        result = s.loc[np.iinfo(\"uint64\").max - 1]\n        expected = s.iloc[0]\n        assert result == expected\n\n        result = s.loc[[np.iinfo(\"uint64\").max - 1]]\n        expected = s.iloc[[0]]\n        tm.assert_series_equal(result, expected)\n\n        result = s.loc[[np.iinfo(\"uint64\").max - 1, np.iinfo(\"uint64\").max]]\n        tm.assert_series_equal(result, s)",
        "begin_line": 884,
        "end_line": 900,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_empty_append#902",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_empty_append(self)",
        "snippet": "    def test_loc_setitem_empty_append(self):\n        # GH6173, various appends to an empty dataframe\n\n        data = [1, 2, 3]\n        expected = DataFrame({\"x\": data, \"y\": [None] * len(data)})\n\n        # appends to fit length of data\n        df = DataFrame(columns=[\"x\", \"y\"])\n        df.loc[:, \"x\"] = data\n        tm.assert_frame_equal(df, expected)\n\n        # only appends one value\n        expected = DataFrame({\"x\": [1.0], \"y\": [np.nan]})\n        df = DataFrame(columns=[\"x\", \"y\"], dtype=np.float)\n        df.loc[0, \"x\"] = expected.loc[0, \"x\"]\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 902,
        "end_line": 917,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_empty_append_raises#919",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_setitem_empty_append_raises(self)",
        "snippet": "    def test_loc_setitem_empty_append_raises(self):\n        # GH6173, various appends to an empty dataframe\n\n        data = [1, 2]\n        df = DataFrame(columns=[\"x\", \"y\"])\n        df.index = df.index.astype(np.int64)\n        msg = (\n            r\"None of \\[Int64Index\\(\\[0, 1\\], dtype='int64'\\)\\] \"\n            r\"are in the \\[index\\]\"\n        )\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[0, 1], \"x\"] = data\n\n        msg = \"cannot copy sequence with size 2 to array axis with dimension 0\"\n        with pytest.raises(ValueError, match=msg):\n            df.loc[0:2, \"x\"] = data",
        "begin_line": 919,
        "end_line": 934,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_indexing_zerodim_np_array#936",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_indexing_zerodim_np_array(self)",
        "snippet": "    def test_indexing_zerodim_np_array(self):\n        # GH24924\n        df = DataFrame([[1, 2], [3, 4]])\n        result = df.loc[np.array(0)]\n        s = pd.Series([1, 2], name=0)\n        tm.assert_series_equal(result, s)",
        "begin_line": 936,
        "end_line": 941,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_series_indexing_zerodim_np_array#943",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_series_indexing_zerodim_np_array(self)",
        "snippet": "    def test_series_indexing_zerodim_np_array(self):\n        # GH24924\n        s = Series([1, 2])\n        result = s.loc[np.array(0)]\n        assert result == 1",
        "begin_line": 943,
        "end_line": 947,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_reverse_assignment#949",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc.TestLoc2",
        "signature": "pandas.tests.indexing.test_loc.TestLoc2.test_loc_reverse_assignment(self)",
        "snippet": "    def test_loc_reverse_assignment(self):\n        # GH26939\n        data = [1, 2, 3, 4, 5, 6] + [None] * 4\n        expected = Series(data, index=range(2010, 2020))\n\n        result = pd.Series(index=range(2010, 2020), dtype=np.float64)\n        result.loc[2015:2010:-1] = [6, 5, 4, 3, 2, 1]\n\n        tm.assert_series_equal(result, expected)",
        "begin_line": 949,
        "end_line": 957,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_series_loc_getitem_label_list_missing_values#960",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_series_loc_getitem_label_list_missing_values()",
        "snippet": "def test_series_loc_getitem_label_list_missing_values():\n    # gh-11428\n    key = np.array(\n        [\"2001-01-04\", \"2001-01-02\", \"2001-01-04\", \"2001-01-14\"], dtype=\"datetime64\"\n    )\n    s = Series([2, 5, 8, 11], date_range(\"2001-01-01\", freq=\"D\", periods=4))\n    with pytest.raises(KeyError, match=\"with any missing labels\"):\n        s.loc[key]",
        "begin_line": 960,
        "end_line": 967,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_getitem_label_list_integer_labels#978",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_getitem_label_list_integer_labels(columns, column_key, expected_columns, check_column_type)",
        "snippet": "def test_loc_getitem_label_list_integer_labels(\n    columns, column_key, expected_columns, check_column_type\n):\n    # gh-14836\n    df = DataFrame(np.random.rand(3, 3), columns=columns, index=list(\"ABC\"))\n    expected = df.iloc[:, expected_columns]\n    result = df.loc[[\"A\", \"B\", \"C\"], column_key]\n    tm.assert_frame_equal(result, expected, check_column_type=check_column_type)",
        "begin_line": 978,
        "end_line": 985,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_setitem_float_intindex#988",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_setitem_float_intindex()",
        "snippet": "def test_loc_setitem_float_intindex():\n    # GH 8720\n    rand_data = np.random.randn(8, 4)\n    result = pd.DataFrame(rand_data)\n    result.loc[:, 0.5] = np.nan\n    expected_data = np.hstack((rand_data, np.array([np.nan] * 8).reshape(8, 1)))\n    expected = pd.DataFrame(expected_data, columns=[0.0, 1.0, 2.0, 3.0, 0.5])\n    tm.assert_frame_equal(result, expected)\n\n    result = pd.DataFrame(rand_data)\n    result.loc[:, 0.5] = np.nan\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 988,
        "end_line": 999,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_axis_1_slice#1002",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_axis_1_slice()",
        "snippet": "def test_loc_axis_1_slice():\n    # GH 10586\n    cols = [(yr, m) for yr in [2014, 2015] for m in [7, 8, 9, 10]]\n    df = pd.DataFrame(\n        np.ones((10, 8)),\n        index=tuple(\"ABCDEFGHIJ\"),\n        columns=pd.MultiIndex.from_tuples(cols),\n    )\n    result = df.loc(axis=1)[(2014, 9):(2015, 8)]\n    expected = pd.DataFrame(\n        np.ones((10, 4)),\n        index=tuple(\"ABCDEFGHIJ\"),\n        columns=pd.MultiIndex.from_tuples(\n            [(2014, 9), (2014, 10), (2015, 7), (2015, 8)]\n        ),\n    )\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 1002,
        "end_line": 1018,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_set_dataframe_multiindex#1021",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_set_dataframe_multiindex()",
        "snippet": "def test_loc_set_dataframe_multiindex():\n    # GH 14592\n    expected = pd.DataFrame(\n        \"a\", index=range(2), columns=pd.MultiIndex.from_product([range(2), range(2)])\n    )\n    result = expected.copy()\n    result.loc[0, [(0, 1)]] = result.loc[0, [(0, 1)]]\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 1021,
        "end_line": 1028,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_mixed_int_float#1031",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_mixed_int_float()",
        "snippet": "def test_loc_mixed_int_float():\n    # GH#19456\n    ser = pd.Series(range(2), pd.Index([1, 2.0], dtype=object))\n\n    result = ser.loc[1]\n    assert result == 0",
        "begin_line": 1031,
        "end_line": 1036,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_with_positional_slice_deprecation#1039",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_with_positional_slice_deprecation()",
        "snippet": "def test_loc_with_positional_slice_deprecation():\n    # GH#31840\n    ser = pd.Series(range(4), index=[\"A\", \"B\", \"C\", \"D\"])\n\n    with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n        ser.loc[:3] = 2\n\n    expected = pd.Series([2, 2, 2, 3], index=[\"A\", \"B\", \"C\", \"D\"])\n    tm.assert_series_equal(ser, expected)",
        "begin_line": 1039,
        "end_line": 1047,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_loc.test_loc_slice_disallows_positional#1050",
        "src_path": "pandas/tests/indexing/test_loc.py",
        "class_name": "pandas.tests.indexing.test_loc",
        "signature": "pandas.tests.indexing.test_loc.test_loc_slice_disallows_positional()",
        "snippet": "def test_loc_slice_disallows_positional():\n    # GH#16121, GH#24612, GH#31810\n    dti = pd.date_range(\"2016-01-01\", periods=3)\n    df = pd.DataFrame(np.random.random((3, 2)), index=dti)\n\n    ser = df[0]\n\n    msg = (\n        \"cannot do slice indexing on DatetimeIndex with these \"\n        r\"indexers \\[1\\] of type int\"\n    )\n\n    for obj in [df, ser]:\n        with pytest.raises(TypeError, match=msg):\n            obj.loc[1:3]\n\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            # GH#31840 deprecated incorrect behavior\n            obj.loc[1:3] = 1\n\n    with pytest.raises(TypeError, match=msg):\n        df.loc[1:3, 1]\n\n    with tm.assert_produces_warning(FutureWarning):\n        # GH#31840 deprecated incorrect behavior\n        df.loc[1:3, 1] = 2",
        "begin_line": 1050,
        "end_line": 1075,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestGet.test_get#35",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestGet",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestGet.test_get(self, float_frame)",
        "snippet": "    def test_get(self, float_frame):\n        b = float_frame.get(\"B\")\n        tm.assert_series_equal(b, float_frame[\"B\"])\n\n        assert float_frame.get(\"foo\") is None\n        tm.assert_series_equal(\n            float_frame.get(\"foo\", float_frame[\"B\"]), float_frame[\"B\"]\n        )",
        "begin_line": 35,
        "end_line": 42,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestGet.test_get_none#52",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestGet",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestGet.test_get_none(self, df)",
        "snippet": "    def test_get_none(self, df):\n        # see gh-5652\n        assert df.get(None) is None",
        "begin_line": 52,
        "end_line": 54,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem#58",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem(self, float_frame)",
        "snippet": "    def test_getitem(self, float_frame):\n        # Slicing\n        sl = float_frame[:20]\n        assert len(sl.index) == 20\n\n        # Column access\n        for _, series in sl.items():\n            assert len(series.index) == 20\n            assert tm.equalContents(series.index, sl.index)\n\n        for key, _ in float_frame._series.items():\n            assert float_frame[key] is not None\n\n        assert \"random\" not in float_frame\n        with pytest.raises(KeyError, match=\"random\"):\n            float_frame[\"random\"]\n\n        df = float_frame.copy()\n        df[\"$10\"] = np.random.randn(len(df))\n\n        ad = np.random.randn(len(df))\n        df[\"@awesome_domain\"] = ad\n\n        with pytest.raises(KeyError, match=re.escape(\"'df[\\\"$10\\\"]'\")):\n            df.__getitem__('df[\"$10\"]')\n\n        res = df[\"@awesome_domain\"]\n        tm.assert_numpy_array_equal(ad, res.values)",
        "begin_line": 58,
        "end_line": 85,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_dupe_cols#87",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_dupe_cols(self)",
        "snippet": "    def test_getitem_dupe_cols(self):\n        df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=[\"a\", \"a\", \"b\"])\n        msg = \"\\\"None of [Index(['baf'], dtype='object')] are in the [columns]\\\"\"\n        with pytest.raises(KeyError, match=re.escape(msg)):\n            df[[\"baf\"]]",
        "begin_line": 87,
        "end_line": 91,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_loc_iterable#94",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_loc_iterable(self, float_frame, key_type)",
        "snippet": "    def test_loc_iterable(self, float_frame, key_type):\n        idx = key_type([\"A\", \"B\", \"C\"])\n        result = float_frame.loc[:, idx]\n        expected = float_frame.loc[:, [\"A\", \"B\", \"C\"]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 94,
        "end_line": 98,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_loc_timedelta_0seconds#100",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_loc_timedelta_0seconds(self)",
        "snippet": "    def test_loc_timedelta_0seconds(self):\n        # GH#10583\n        df = pd.DataFrame(np.random.normal(size=(10, 4)))\n        df.index = pd.timedelta_range(start=\"0s\", periods=10, freq=\"s\")\n        expected = df.loc[pd.Timedelta(\"0s\") :, :]\n        result = df.loc[\"0s\":, :]\n        tm.assert_frame_equal(expected, result)",
        "begin_line": 100,
        "end_line": 106,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_listlike#121",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_listlike(self, idx_type, levels, float_frame)",
        "snippet": "    def test_getitem_listlike(self, idx_type, levels, float_frame):\n        # GH 21294\n\n        if levels == 1:\n            frame, missing = float_frame, \"food\"\n        else:\n            # MultiIndex columns\n            frame = DataFrame(\n                np.random.randn(8, 3),\n                columns=Index(\n                    [(\"foo\", \"bar\"), (\"baz\", \"qux\"), (\"peek\", \"aboo\")],\n                    name=(\"sth\", \"sth2\"),\n                ),\n            )\n            missing = (\"good\", \"food\")\n\n        keys = [frame.columns[1], frame.columns[0]]\n        idx = idx_type(keys)\n        idx_check = list(idx_type(keys))\n\n        result = frame[idx]\n\n        expected = frame.loc[:, idx_check]\n        expected.columns.names = frame.columns.names\n\n        tm.assert_frame_equal(result, expected)\n\n        idx = idx_type(keys + [missing])\n        with pytest.raises(KeyError, match=\"not in index\"):\n            frame[idx]",
        "begin_line": 121,
        "end_line": 150,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_loc_uint64#155",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_loc_uint64(self, val, expected)",
        "snippet": "    def test_loc_uint64(self, val, expected):\n        # see gh-19399\n        df = DataFrame([1, 2], index=[2 ** 63 - 1, 2 ** 63])\n        result = df.loc[val]\n\n        expected.name = val\n        tm.assert_series_equal(result, expected)",
        "begin_line": 155,
        "end_line": 161,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_callable#163",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_callable(self, float_frame)",
        "snippet": "    def test_getitem_callable(self, float_frame):\n        # GH 12533\n        result = float_frame[lambda x: \"A\"]\n        tm.assert_series_equal(result, float_frame.loc[:, \"A\"])\n\n        result = float_frame[lambda x: [\"A\", \"B\"]]\n        tm.assert_frame_equal(result, float_frame.loc[:, [\"A\", \"B\"]])\n\n        df = float_frame[:3]\n        result = df[lambda x: [True, False, True]]\n        tm.assert_frame_equal(result, float_frame.iloc[[0, 2], :])",
        "begin_line": 163,
        "end_line": 173,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_list#175",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_list(self, float_frame)",
        "snippet": "    def test_setitem_list(self, float_frame):\n\n        float_frame[\"E\"] = \"foo\"\n        data = float_frame[[\"A\", \"B\"]]\n        float_frame[[\"B\", \"A\"]] = data\n\n        tm.assert_series_equal(float_frame[\"B\"], data[\"A\"], check_names=False)\n        tm.assert_series_equal(float_frame[\"A\"], data[\"B\"], check_names=False)\n\n        msg = \"Columns must be same length as key\"\n        with pytest.raises(ValueError, match=msg):\n            data[[\"A\"]] = float_frame[[\"A\", \"B\"]]\n\n        msg = \"Length of values does not match length of index\"\n        with pytest.raises(ValueError, match=msg):\n            data[\"A\"] = range(len(data.index) - 1)\n\n        df = DataFrame(0, index=range(3), columns=[\"tt1\", \"tt2\"], dtype=np.int_)\n        df.loc[1, [\"tt1\", \"tt2\"]] = [1, 2]\n\n        result = df.loc[df.index[1], [\"tt1\", \"tt2\"]]\n        expected = Series([1, 2], df.columns, dtype=np.int_, name=1)\n        tm.assert_series_equal(result, expected)\n\n        df[\"tt1\"] = df[\"tt2\"] = \"0\"\n        df.loc[df.index[1], [\"tt1\", \"tt2\"]] = [\"1\", \"2\"]\n        result = df.loc[df.index[1], [\"tt1\", \"tt2\"]]\n        expected = Series([\"1\", \"2\"], df.columns, name=1)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 175,
        "end_line": 203,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_list_not_dataframe#205",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_list_not_dataframe(self, float_frame)",
        "snippet": "    def test_setitem_list_not_dataframe(self, float_frame):\n        data = np.random.randn(len(float_frame), 2)\n        float_frame[[\"A\", \"B\"]] = data\n        tm.assert_almost_equal(float_frame[[\"A\", \"B\"]].values, data)",
        "begin_line": 205,
        "end_line": 208,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_list_of_tuples#210",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_list_of_tuples(self, float_frame)",
        "snippet": "    def test_setitem_list_of_tuples(self, float_frame):\n        tuples = list(zip(float_frame[\"A\"], float_frame[\"B\"]))\n        float_frame[\"tuples\"] = tuples\n\n        result = float_frame[\"tuples\"]\n        expected = Series(tuples, index=float_frame.index, name=\"tuples\")\n        tm.assert_series_equal(result, expected)",
        "begin_line": 210,
        "end_line": 216,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_list_missing_columns#269",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_list_missing_columns(self, columns, box, expected)",
        "snippet": "    def test_setitem_list_missing_columns(self, columns, box, expected):\n        # GH 29334\n        df = pd.DataFrame([[1, 2], [3, 4], [5, 6]], columns=[\"A\", \"B\"])\n        df[columns] = box\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 269,
        "end_line": 273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_multi_index#275",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_multi_index(self)",
        "snippet": "    def test_setitem_multi_index(self):\n        # GH7655, test that assigning to a sub-frame of a frame\n        # with multi-index columns aligns both rows and columns\n        it = [\"jim\", \"joe\", \"jolie\"], [\"first\", \"last\"], [\"left\", \"center\", \"right\"]\n\n        cols = MultiIndex.from_product(it)\n        index = pd.date_range(\"20141006\", periods=20)\n        vals = np.random.randint(1, 1000, (len(index), len(cols)))\n        df = pd.DataFrame(vals, columns=cols, index=index)\n\n        i, j = df.index.values.copy(), it[-1][:]\n\n        np.random.shuffle(i)\n        df[\"jim\"] = df[\"jolie\"].loc[i, ::-1]\n        tm.assert_frame_equal(df[\"jim\"], df[\"jolie\"])\n\n        np.random.shuffle(j)\n        df[(\"joe\", \"first\")] = df[(\"jolie\", \"last\")].loc[i, j]\n        tm.assert_frame_equal(df[(\"joe\", \"first\")], df[(\"jolie\", \"last\")])\n\n        np.random.shuffle(j)\n        df[(\"joe\", \"last\")] = df[(\"jolie\", \"first\")].loc[i, j]\n        tm.assert_frame_equal(df[(\"joe\", \"last\")], df[(\"jolie\", \"first\")])",
        "begin_line": 275,
        "end_line": 297,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_callable#299",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_callable(self)",
        "snippet": "    def test_setitem_callable(self):\n        # GH 12533\n        df = pd.DataFrame({\"A\": [1, 2, 3, 4], \"B\": [5, 6, 7, 8]})\n        df[lambda x: \"A\"] = [11, 12, 13, 14]\n\n        exp = pd.DataFrame({\"A\": [11, 12, 13, 14], \"B\": [5, 6, 7, 8]})\n        tm.assert_frame_equal(df, exp)",
        "begin_line": 299,
        "end_line": 305,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_other_callable#307",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_other_callable(self)",
        "snippet": "    def test_setitem_other_callable(self):\n        # GH 13299\n        def inc(x):\n            return x + 1\n\n        df = pd.DataFrame([[-1, 1], [1, -1]])\n        df[df > 0] = inc\n\n        expected = pd.DataFrame([[-1, inc], [inc, -1]])\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 307,
        "end_line": 316,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.inc#309",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.inc(x)",
        "snippet": "        def inc(x):\n            return x + 1",
        "begin_line": 309,
        "end_line": 310,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_boolean#318",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_boolean(self, float_string_frame, mixed_float_frame, mixed_int_frame, datetime_frame)",
        "snippet": "    def test_getitem_boolean(\n        self, float_string_frame, mixed_float_frame, mixed_int_frame, datetime_frame\n    ):\n        # boolean indexing\n        d = datetime_frame.index[10]\n        indexer = datetime_frame.index > d\n        indexer_obj = indexer.astype(object)\n\n        subindex = datetime_frame.index[indexer]\n        subframe = datetime_frame[indexer]\n\n        tm.assert_index_equal(subindex, subframe.index)\n        with pytest.raises(ValueError, match=\"Item wrong length\"):\n            datetime_frame[indexer[:-1]]\n\n        subframe_obj = datetime_frame[indexer_obj]\n        tm.assert_frame_equal(subframe_obj, subframe)\n\n        with pytest.raises(ValueError, match=\"Boolean array expected\"):\n            datetime_frame[datetime_frame]\n\n        # test that Series work\n        indexer_obj = Series(indexer_obj, datetime_frame.index)\n\n        subframe_obj = datetime_frame[indexer_obj]\n        tm.assert_frame_equal(subframe_obj, subframe)\n\n        # test that Series indexers reindex\n        # we are producing a warning that since the passed boolean\n        # key is not the same as the given index, we will reindex\n        # not sure this is really necessary\n        with tm.assert_produces_warning(UserWarning, check_stacklevel=False):\n            indexer_obj = indexer_obj.reindex(datetime_frame.index[::-1])\n            subframe_obj = datetime_frame[indexer_obj]\n            tm.assert_frame_equal(subframe_obj, subframe)\n\n        # test df[df > 0]\n        for df in [\n            datetime_frame,\n            float_string_frame,\n            mixed_float_frame,\n            mixed_int_frame,\n        ]:\n            if df is float_string_frame:\n                continue\n\n            data = df._get_numeric_data()\n            bif = df[df > 0]\n            bifw = DataFrame(\n                {c: np.where(data[c] > 0, data[c], np.nan) for c in data.columns},\n                index=data.index,\n                columns=data.columns,\n            )\n\n            # add back other columns to compare\n            for c in df.columns:\n                if c not in bifw:\n                    bifw[c] = df[c]\n            bifw = bifw.reindex(columns=df.columns)\n\n            tm.assert_frame_equal(bif, bifw, check_dtype=False)\n            for c in df.columns:\n                if bif[c].dtype != bifw[c].dtype:\n                    assert bif[c].dtype == df[c].dtype",
        "begin_line": 318,
        "end_line": 381,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_boolean_casting#383",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_boolean_casting(self, datetime_frame)",
        "snippet": "    def test_getitem_boolean_casting(self, datetime_frame):\n\n        # don't upcast if we don't need to\n        df = datetime_frame.copy()\n        df[\"E\"] = 1\n        df[\"E\"] = df[\"E\"].astype(\"int32\")\n        df[\"E1\"] = df[\"E\"].copy()\n        df[\"F\"] = 1\n        df[\"F\"] = df[\"F\"].astype(\"int64\")\n        df[\"F1\"] = df[\"F\"].copy()\n\n        casted = df[df > 0]\n        result = casted.dtypes\n        expected = Series(\n            [np.dtype(\"float64\")] * 4\n            + [np.dtype(\"int32\")] * 2\n            + [np.dtype(\"int64\")] * 2,\n            index=[\"A\", \"B\", \"C\", \"D\", \"E\", \"E1\", \"F\", \"F1\"],\n        )\n        tm.assert_series_equal(result, expected)\n\n        # int block splitting\n        df.loc[df.index[1:3], [\"E1\", \"F1\"]] = 0\n        casted = df[df > 0]\n        result = casted.dtypes\n        expected = Series(\n            [np.dtype(\"float64\")] * 4\n            + [np.dtype(\"int32\")]\n            + [np.dtype(\"float64\")]\n            + [np.dtype(\"int64\")]\n            + [np.dtype(\"float64\")],\n            index=[\"A\", \"B\", \"C\", \"D\", \"E\", \"E1\", \"F\", \"F1\"],\n        )\n        tm.assert_series_equal(result, expected)\n\n        # where dtype conversions\n        # GH 3733\n        df = DataFrame(data=np.random.randn(100, 50))\n        df = df.where(df > 0)  # create nans\n        bools = df > 0\n        mask = isna(df)\n        expected = bools.astype(float).mask(mask)\n        result = bools.mask(mask)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 383,
        "end_line": 426,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_boolean_list#428",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_boolean_list(self)",
        "snippet": "    def test_getitem_boolean_list(self):\n        df = DataFrame(np.arange(12).reshape(3, 4))\n\n        def _checkit(lst):\n            result = df[lst]\n            expected = df.loc[df.index[lst]]\n            tm.assert_frame_equal(result, expected)\n\n        _checkit([True, False, True])\n        _checkit([True, True, True])\n        _checkit([False, False, False])",
        "begin_line": 428,
        "end_line": 438,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing._checkit#431",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing._checkit(lst)",
        "snippet": "        def _checkit(lst):\n            result = df[lst]\n            expected = df.loc[df.index[lst]]\n            tm.assert_frame_equal(result, expected)",
        "begin_line": 431,
        "end_line": 434,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_boolean_iadd#440",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_boolean_iadd(self)",
        "snippet": "    def test_getitem_boolean_iadd(self):\n        arr = np.random.randn(5, 5)\n\n        df = DataFrame(arr.copy(), columns=[\"A\", \"B\", \"C\", \"D\", \"E\"])\n\n        df[df < 0] += 1\n        arr[arr < 0] += 1\n\n        tm.assert_almost_equal(df.values, arr)",
        "begin_line": 440,
        "end_line": 448,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_boolean_index_empty_corner#450",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_boolean_index_empty_corner(self)",
        "snippet": "    def test_boolean_index_empty_corner(self):\n        # #2096\n        blah = DataFrame(np.empty([0, 1]), columns=[\"A\"], index=DatetimeIndex([]))\n\n        # both of these should succeed trivially\n        k = np.array([], bool)\n\n        blah[k]\n        blah[k] = 0",
        "begin_line": 450,
        "end_line": 458,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_ix_mixed_integer#460",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_ix_mixed_integer(self)",
        "snippet": "    def test_getitem_ix_mixed_integer(self):\n        df = DataFrame(\n            np.random.randn(4, 3), index=[1, 10, \"C\", \"E\"], columns=[1, 2, 3]\n        )\n\n        result = df.iloc[:-1]\n        expected = df.loc[df.index[:-1]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[[1, 10]]\n        expected = df.loc[Index([1, 10])]\n        tm.assert_frame_equal(result, expected)\n\n        # 11320\n        df = pd.DataFrame(\n            {\n                \"rna\": (1.5, 2.2, 3.2, 4.5),\n                -1000: [11, 21, 36, 40],\n                0: [10, 22, 43, 34],\n                1000: [0, 10, 20, 30],\n            },\n            columns=[\"rna\", -1000, 0, 1000],\n        )\n        result = df[[1000]]\n        expected = df.iloc[:, [3]]\n        tm.assert_frame_equal(result, expected)\n        result = df[[-1000]]\n        expected = df.iloc[:, [1]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 460,
        "end_line": 488,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getattr#490",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getattr(self, float_frame)",
        "snippet": "    def test_getattr(self, float_frame):\n        tm.assert_series_equal(float_frame.A, float_frame[\"A\"])\n        msg = \"'DataFrame' object has no attribute 'NONEXISTENT_NAME'\"\n        with pytest.raises(AttributeError, match=msg):\n            float_frame.NONEXISTENT_NAME",
        "begin_line": 490,
        "end_line": 494,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setattr_column#496",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setattr_column(self)",
        "snippet": "    def test_setattr_column(self):\n        df = DataFrame({\"foobar\": 1}, index=range(10))\n\n        df.foobar = 5\n        assert (df.foobar == 5).all()",
        "begin_line": 496,
        "end_line": 500,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem#502",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem(self, float_frame)",
        "snippet": "    def test_setitem(self, float_frame):\n        # not sure what else to do here\n        series = float_frame[\"A\"][::2]\n        float_frame[\"col5\"] = series\n        assert \"col5\" in float_frame\n\n        assert len(series) == 15\n        assert len(float_frame) == 30\n\n        exp = np.ravel(np.column_stack((series.values, [np.nan] * 15)))\n        exp = Series(exp, index=float_frame.index, name=\"col5\")\n        tm.assert_series_equal(float_frame[\"col5\"], exp)\n\n        series = float_frame[\"A\"]\n        float_frame[\"col6\"] = series\n        tm.assert_series_equal(series, float_frame[\"col6\"], check_names=False)\n\n        # set ndarray\n        arr = np.random.randn(len(float_frame))\n        float_frame[\"col9\"] = arr\n        assert (float_frame[\"col9\"] == arr).all()\n\n        float_frame[\"col7\"] = 5\n        assert (float_frame[\"col7\"] == 5).all()\n\n        float_frame[\"col0\"] = 3.14\n        assert (float_frame[\"col0\"] == 3.14).all()\n\n        float_frame[\"col8\"] = \"foo\"\n        assert (float_frame[\"col8\"] == \"foo\").all()\n\n        # this is partially a view (e.g. some blocks are view)\n        # so raise/warn\n        smaller = float_frame[:2]\n\n        msg = r\"\\nA value is trying to be set on a copy of a slice from a DataFrame\"\n        with pytest.raises(com.SettingWithCopyError, match=msg):\n            smaller[\"col10\"] = [\"1\", \"2\"]\n\n        assert smaller[\"col10\"].dtype == np.object_\n        assert (smaller[\"col10\"] == [\"1\", \"2\"]).all()\n\n        # dtype changing GH4204\n        df = DataFrame([[0, 0]])\n        df.iloc[0] = np.nan\n        expected = DataFrame([[np.nan, np.nan]])\n        tm.assert_frame_equal(df, expected)\n\n        df = DataFrame([[0, 0]])\n        df.loc[0] = np.nan\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 502,
        "end_line": 552,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_dtype#555",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_dtype(self, dtype, float_frame)",
        "snippet": "    def test_setitem_dtype(self, dtype, float_frame):\n        arr = np.random.randn(len(float_frame))\n\n        float_frame[dtype] = np.array(arr, dtype=dtype)\n        assert float_frame[dtype].dtype.name == dtype",
        "begin_line": 555,
        "end_line": 559,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_tuple#561",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_tuple(self, float_frame)",
        "snippet": "    def test_setitem_tuple(self, float_frame):\n        float_frame[\"A\", \"B\"] = float_frame[\"A\"]\n        tm.assert_series_equal(\n            float_frame[\"A\", \"B\"], float_frame[\"A\"], check_names=False\n        )",
        "begin_line": 561,
        "end_line": 565,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_always_copy#567",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_always_copy(self, float_frame)",
        "snippet": "    def test_setitem_always_copy(self, float_frame):\n        s = float_frame[\"A\"].copy()\n        float_frame[\"E\"] = s\n\n        float_frame[\"E\"][5:10] = np.nan\n        assert notna(s[5:10]).all()",
        "begin_line": 567,
        "end_line": 572,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_boolean#574",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_boolean(self, float_frame)",
        "snippet": "    def test_setitem_boolean(self, float_frame):\n        df = float_frame.copy()\n        values = float_frame.values\n\n        df[df[\"A\"] > 0] = 4\n        values[values[:, 0] > 0] = 4\n        tm.assert_almost_equal(df.values, values)\n\n        # test that column reindexing works\n        series = df[\"A\"] == 4\n        series = series.reindex(df.index[::-1])\n        df[series] = 1\n        values[values[:, 0] == 4] = 1\n        tm.assert_almost_equal(df.values, values)\n\n        df[df > 0] = 5\n        values[values > 0] = 5\n        tm.assert_almost_equal(df.values, values)\n\n        df[df == 5] = 0\n        values[values == 5] = 0\n        tm.assert_almost_equal(df.values, values)\n\n        # a df that needs alignment first\n        df[df[:-1] < 0] = 2\n        np.putmask(values[:-1], values[:-1] < 0, 2)\n        tm.assert_almost_equal(df.values, values)\n\n        # indexed with same shape but rows-reversed df\n        df[df[::-1] == 2] = 3\n        values[values == 2] = 3\n        tm.assert_almost_equal(df.values, values)\n\n        msg = \"Must pass DataFrame or 2-d ndarray with boolean values only\"\n        with pytest.raises(TypeError, match=msg):\n            df[df * 0] = 2\n\n        # index with DataFrame\n        mask = df > np.abs(df)\n        expected = df.copy()\n        df[df > np.abs(df)] = np.nan\n        expected.values[mask.values] = np.nan\n        tm.assert_frame_equal(df, expected)\n\n        # set from DataFrame\n        expected = df.copy()\n        df[df > np.abs(df)] = df * 2\n        np.putmask(expected.values, mask.values, df.values * 2)\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 574,
        "end_line": 622,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_boolean_mask#629",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_boolean_mask(self, mask_type, float_frame)",
        "snippet": "    def test_setitem_boolean_mask(self, mask_type, float_frame):\n\n        # Test for issue #18582\n        df = float_frame.copy()\n        mask = mask_type(df)\n\n        # index with boolean mask\n        result = df.copy()\n        result[mask] = np.nan\n\n        expected = df.copy()\n        expected.values[np.array(mask)] = np.nan\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 629,
        "end_line": 641,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_cast#643",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_cast(self, float_frame)",
        "snippet": "    def test_setitem_cast(self, float_frame):\n        float_frame[\"D\"] = float_frame[\"D\"].astype(\"i8\")\n        assert float_frame[\"D\"].dtype == np.int64\n\n        # #669, should not cast?\n        # this is now set to int64, which means a replacement of the column to\n        # the value dtype (and nothing to do with the existing dtype)\n        float_frame[\"B\"] = 0\n        assert float_frame[\"B\"].dtype == np.int64\n\n        # cast if pass array of course\n        float_frame[\"B\"] = np.arange(len(float_frame))\n        assert issubclass(float_frame[\"B\"].dtype.type, np.integer)\n\n        float_frame[\"foo\"] = \"bar\"\n        float_frame[\"foo\"] = 0\n        assert float_frame[\"foo\"].dtype == np.int64\n\n        float_frame[\"foo\"] = \"bar\"\n        float_frame[\"foo\"] = 2.5\n        assert float_frame[\"foo\"].dtype == np.float64\n\n        float_frame[\"something\"] = 0\n        assert float_frame[\"something\"].dtype == np.int64\n        float_frame[\"something\"] = 2\n        assert float_frame[\"something\"].dtype == np.int64\n        float_frame[\"something\"] = 2.5\n        assert float_frame[\"something\"].dtype == np.float64\n\n        # GH 7704\n        # dtype conversion on setting\n        df = DataFrame(np.random.rand(30, 3), columns=tuple(\"ABC\"))\n        df[\"event\"] = np.nan\n        df.loc[10, \"event\"] = \"foo\"\n        result = df.dtypes\n        expected = Series(\n            [np.dtype(\"float64\")] * 3 + [np.dtype(\"object\")],\n            index=[\"A\", \"B\", \"C\", \"event\"],\n        )\n        tm.assert_series_equal(result, expected)\n\n        # Test that data type is preserved . #5782\n        df = DataFrame({\"one\": np.arange(6, dtype=np.int8)})\n        df.loc[1, \"one\"] = 6\n        assert df.dtypes.one == np.dtype(np.int8)\n        df.one = np.int8(7)\n        assert df.dtypes.one == np.dtype(np.int8)",
        "begin_line": 643,
        "end_line": 689,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_boolean_column#691",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_boolean_column(self, float_frame)",
        "snippet": "    def test_setitem_boolean_column(self, float_frame):\n        expected = float_frame.copy()\n        mask = float_frame[\"A\"] > 0\n\n        float_frame.loc[mask, \"B\"] = 0\n        expected.values[mask.values, 1] = 0\n\n        tm.assert_frame_equal(float_frame, expected)",
        "begin_line": 691,
        "end_line": 698,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_frame_setitem_timestamp#700",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_frame_setitem_timestamp(self)",
        "snippet": "    def test_frame_setitem_timestamp(self):\n        # GH#2155\n        columns = date_range(start=\"1/1/2012\", end=\"2/1/2012\", freq=BDay())\n        data = DataFrame(columns=columns, index=range(10))\n        t = datetime(2012, 11, 1)\n        ts = Timestamp(t)\n        data[ts] = np.nan  # works, mostly a smoke-test\n        assert np.isnan(data[ts]).all()",
        "begin_line": 700,
        "end_line": 707,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_corner#709",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_corner(self, float_frame)",
        "snippet": "    def test_setitem_corner(self, float_frame):\n        # corner case\n        df = DataFrame({\"B\": [1.0, 2.0, 3.0], \"C\": [\"a\", \"b\", \"c\"]}, index=np.arange(3))\n        del df[\"B\"]\n        df[\"B\"] = [1.0, 2.0, 3.0]\n        assert \"B\" in df\n        assert len(df.columns) == 2\n\n        df[\"A\"] = \"beginning\"\n        df[\"E\"] = \"foo\"\n        df[\"D\"] = \"bar\"\n        df[datetime.now()] = \"date\"\n        df[datetime.now()] = 5.0\n\n        # what to do when empty frame with index\n        dm = DataFrame(index=float_frame.index)\n        dm[\"A\"] = \"foo\"\n        dm[\"B\"] = \"bar\"\n        assert len(dm.columns) == 2\n        assert dm.values.dtype == np.object_\n\n        # upcast\n        dm[\"C\"] = 1\n        assert dm[\"C\"].dtype == np.int64\n\n        dm[\"E\"] = 1.0\n        assert dm[\"E\"].dtype == np.float64\n\n        # set existing column\n        dm[\"A\"] = \"bar\"\n        assert \"bar\" == dm[\"A\"][0]\n\n        dm = DataFrame(index=np.arange(3))\n        dm[\"A\"] = 1\n        dm[\"foo\"] = \"bar\"\n        del dm[\"foo\"]\n        dm[\"foo\"] = \"bar\"\n        assert dm[\"foo\"].dtype == np.object_\n\n        dm[\"coercable\"] = [\"1\", \"2\", \"3\"]\n        assert dm[\"coercable\"].dtype == np.object_",
        "begin_line": 709,
        "end_line": 749,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_corner2#751",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_corner2(self)",
        "snippet": "    def test_setitem_corner2(self):\n        data = {\n            \"title\": [\"foobar\", \"bar\", \"foobar\"] + [\"foobar\"] * 17,\n            \"cruft\": np.random.random(20),\n        }\n\n        df = DataFrame(data)\n        ix = df[df[\"title\"] == \"bar\"].index\n\n        df.loc[ix, [\"title\"]] = \"foobar\"\n        df.loc[ix, [\"cruft\"]] = 0\n\n        assert df.loc[1, \"title\"] == \"foobar\"\n        assert df.loc[1, \"cruft\"] == 0",
        "begin_line": 751,
        "end_line": 764,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_ambig#766",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_ambig(self)",
        "snippet": "    def test_setitem_ambig(self):\n        # Difficulties with mixed-type data\n        from decimal import Decimal\n\n        # Created as float type\n        dm = DataFrame(index=range(3), columns=range(3))\n\n        coercable_series = Series([Decimal(1) for _ in range(3)], index=range(3))\n        uncoercable_series = Series([\"foo\", \"bzr\", \"baz\"], index=range(3))\n\n        dm[0] = np.ones(3)\n        assert len(dm.columns) == 3\n\n        dm[1] = coercable_series\n        assert len(dm.columns) == 3\n\n        dm[2] = uncoercable_series\n        assert len(dm.columns) == 3\n        assert dm[2].dtype == np.object_",
        "begin_line": 766,
        "end_line": 784,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_clear_caches#786",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_clear_caches(self)",
        "snippet": "    def test_setitem_clear_caches(self):\n        # see gh-304\n        df = DataFrame(\n            {\"x\": [1.1, 2.1, 3.1, 4.1], \"y\": [5.1, 6.1, 7.1, 8.1]}, index=[0, 1, 2, 3]\n        )\n        df.insert(2, \"z\", np.nan)\n\n        # cache it\n        foo = df[\"z\"]\n        df.loc[df.index[2:], \"z\"] = 42\n\n        expected = Series([np.nan, np.nan, 42, 42], index=df.index, name=\"z\")\n\n        assert df[\"z\"] is not foo\n        tm.assert_series_equal(df[\"z\"], expected)",
        "begin_line": 786,
        "end_line": 800,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_None#802",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_None(self, float_frame)",
        "snippet": "    def test_setitem_None(self, float_frame):\n        # GH #766\n        float_frame[None] = float_frame[\"A\"]\n        tm.assert_series_equal(\n            float_frame.iloc[:, -1], float_frame[\"A\"], check_names=False\n        )\n        tm.assert_series_equal(\n            float_frame.loc[:, None], float_frame[\"A\"], check_names=False\n        )\n        tm.assert_series_equal(float_frame[None], float_frame[\"A\"], check_names=False)\n        repr(float_frame)",
        "begin_line": 802,
        "end_line": 812,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_empty#814",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_empty(self)",
        "snippet": "    def test_setitem_empty(self):\n        # GH 9596\n        df = pd.DataFrame(\n            {\"a\": [\"1\", \"2\", \"3\"], \"b\": [\"11\", \"22\", \"33\"], \"c\": [\"111\", \"222\", \"333\"]}\n        )\n\n        result = df.copy()\n        result.loc[result.b.isna(), \"a\"] = result.a\n        tm.assert_frame_equal(result, df)",
        "begin_line": 814,
        "end_line": 822,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_empty_frame_with_boolean#826",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_empty_frame_with_boolean(self, dtype, kwargs)",
        "snippet": "    def test_setitem_empty_frame_with_boolean(self, dtype, kwargs):\n        # see gh-10126\n        kwargs[\"dtype\"] = dtype\n        df = DataFrame(**kwargs)\n\n        df2 = df.copy()\n        df[df > df2] = 47\n        tm.assert_frame_equal(df, df2)",
        "begin_line": 826,
        "end_line": 833,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_with_empty_listlike#835",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_with_empty_listlike(self)",
        "snippet": "    def test_setitem_with_empty_listlike(self):\n        # GH #17101\n        index = pd.Index([], name=\"idx\")\n        result = pd.DataFrame(columns=[\"A\"], index=index)\n        result[\"A\"] = []\n        expected = pd.DataFrame(columns=[\"A\"], index=index)\n        tm.assert_index_equal(result.index, expected.index)",
        "begin_line": 835,
        "end_line": 841,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_scalars_no_index#843",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_scalars_no_index(self)",
        "snippet": "    def test_setitem_scalars_no_index(self):\n        # GH16823 / 17894\n        df = DataFrame()\n        df[\"foo\"] = 1\n        expected = DataFrame(columns=[\"foo\"]).astype(np.int64)\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 843,
        "end_line": 848,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_empty_frame_with_boolean#850",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_empty_frame_with_boolean(self)",
        "snippet": "    def test_getitem_empty_frame_with_boolean(self):\n        # Test for issue #11859\n\n        df = pd.DataFrame()\n        df2 = df[df > 0]\n        tm.assert_frame_equal(df, df2)",
        "begin_line": 850,
        "end_line": 855,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_delitem_corner#857",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_delitem_corner(self, float_frame)",
        "snippet": "    def test_delitem_corner(self, float_frame):\n        f = float_frame.copy()\n        del f[\"D\"]\n        assert len(f.columns) == 3\n        with pytest.raises(KeyError, match=r\"^'D'$\"):\n            del f[\"D\"]\n        del f[\"B\"]\n        assert len(f.columns) == 2",
        "begin_line": 857,
        "end_line": 864,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_slice_floats#866",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_slice_floats(self)",
        "snippet": "    def test_slice_floats(self):\n        index = [52195.504153, 52196.303147, 52198.369883]\n        df = DataFrame(np.random.rand(3, 2), index=index)\n\n        s1 = df.loc[52195.1:52196.5]\n        assert len(s1) == 2\n\n        s1 = df.loc[52195.1:52196.6]\n        assert len(s1) == 2\n\n        s1 = df.loc[52195.1:52198.9]\n        assert len(s1) == 3",
        "begin_line": 866,
        "end_line": 877,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_fancy_slice_integers_step#879",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_fancy_slice_integers_step(self)",
        "snippet": "    def test_getitem_fancy_slice_integers_step(self):\n        df = DataFrame(np.random.randn(10, 5))\n\n        # this is OK\n        result = df.iloc[:8:2]  # noqa\n        df.iloc[:8:2] = np.nan\n        assert isna(df.iloc[:8:2]).values.all()",
        "begin_line": 879,
        "end_line": 885,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_integer_slice_keyerrors#887",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_integer_slice_keyerrors(self)",
        "snippet": "    def test_getitem_setitem_integer_slice_keyerrors(self):\n        df = DataFrame(np.random.randn(10, 5), index=range(0, 20, 2))\n\n        # this is OK\n        cp = df.copy()\n        cp.iloc[4:10] = 0\n        assert (cp.iloc[4:10] == 0).values.all()\n\n        # so is this\n        cp = df.copy()\n        cp.iloc[3:11] = 0\n        assert (cp.iloc[3:11] == 0).values.all()\n\n        result = df.iloc[2:6]\n        result2 = df.loc[3:11]\n        expected = df.reindex([4, 6, 8, 10])\n\n        tm.assert_frame_equal(result, expected)\n        tm.assert_frame_equal(result2, expected)\n\n        # non-monotonic, raise KeyError\n        df2 = df.iloc[list(range(5)) + list(range(5, 10))[::-1]]\n        with pytest.raises(KeyError, match=r\"^3$\"):\n            df2.loc[3:11]\n        with pytest.raises(KeyError, match=r\"^3$\"):\n            df2.loc[3:11] = 0",
        "begin_line": 887,
        "end_line": 912,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_fancy_getitem_slice_mixed#914",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_fancy_getitem_slice_mixed(self, float_frame, float_string_frame)",
        "snippet": "    def test_fancy_getitem_slice_mixed(self, float_frame, float_string_frame):\n        sliced = float_string_frame.iloc[:, -3:]\n        assert sliced[\"D\"].dtype == np.float64\n\n        # get view with single block\n        # setting it triggers setting with copy\n        sliced = float_frame.iloc[:, -3:]\n\n        msg = r\"\\nA value is trying to be set on a copy of a slice from a DataFrame\"\n        with pytest.raises(com.SettingWithCopyError, match=msg):\n            sliced[\"C\"] = 4.0\n\n        assert (float_frame[\"C\"] == 4).all()",
        "begin_line": 914,
        "end_line": 926,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_slice_position#928",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_slice_position(self)",
        "snippet": "    def test_setitem_slice_position(self):\n        # GH#31469\n        df = pd.DataFrame(np.zeros((100, 1)))\n        df[-4:] = 1\n        arr = np.zeros((100, 1))\n        arr[-4:] = 1\n        expected = pd.DataFrame(arr)\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 928,
        "end_line": 935,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_non_ix_labels#937",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_non_ix_labels(self)",
        "snippet": "    def test_getitem_setitem_non_ix_labels(self):\n        df = tm.makeTimeDataFrame()\n\n        start, end = df.index[[5, 10]]\n\n        result = df.loc[start:end]\n        result2 = df[start:end]\n        expected = df[5:11]\n        tm.assert_frame_equal(result, expected)\n        tm.assert_frame_equal(result2, expected)\n\n        result = df.copy()\n        result.loc[start:end] = 0\n        result2 = df.copy()\n        result2[start:end] = 0\n        expected = df.copy()\n        expected[5:11] = 0\n        tm.assert_frame_equal(result, expected)\n        tm.assert_frame_equal(result2, expected)",
        "begin_line": 937,
        "end_line": 955,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_ix_multi_take#957",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_ix_multi_take(self)",
        "snippet": "    def test_ix_multi_take(self):\n        df = DataFrame(np.random.randn(3, 2))\n        rs = df.loc[df.index == 0, :]\n        xp = df.reindex([0])\n        tm.assert_frame_equal(rs, xp)\n\n        # FIXME: dont leave commented-out\n        \"\"\" #1321\n        df = DataFrame(np.random.randn(3, 2))\n        rs = df.loc[df.index==0, df.columns==1]\n        xp = df.reindex([0], [1])\n        tm.assert_frame_equal(rs, xp)\n        \"\"\"",
        "begin_line": 957,
        "end_line": 969,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_fancy_scalar#971",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_fancy_scalar(self, float_frame)",
        "snippet": "    def test_getitem_fancy_scalar(self, float_frame):\n        f = float_frame\n        ix = f.loc\n\n        # individual value\n        for col in f.columns:\n            ts = f[col]\n            for idx in f.index[::5]:\n                assert ix[idx, col] == ts[idx]",
        "begin_line": 971,
        "end_line": 979,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_fancy_scalar#981",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_fancy_scalar(self, float_frame)",
        "snippet": "    def test_setitem_fancy_scalar(self, float_frame):\n        f = float_frame\n        expected = float_frame.copy()\n        ix = f.loc\n\n        # individual value\n        for j, col in enumerate(f.columns):\n            ts = f[col]  # noqa\n            for idx in f.index[::5]:\n                i = f.index.get_loc(idx)\n                val = np.random.randn()\n                expected.values[i, j] = val\n\n                ix[idx, col] = val\n                tm.assert_frame_equal(f, expected)",
        "begin_line": 981,
        "end_line": 995,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_fancy_boolean#997",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_fancy_boolean(self, float_frame)",
        "snippet": "    def test_getitem_fancy_boolean(self, float_frame):\n        f = float_frame\n        ix = f.loc\n\n        expected = f.reindex(columns=[\"B\", \"D\"])\n        result = ix[:, [False, True, False, True]]\n        tm.assert_frame_equal(result, expected)\n\n        expected = f.reindex(index=f.index[5:10], columns=[\"B\", \"D\"])\n        result = ix[f.index[5:10], [False, True, False, True]]\n        tm.assert_frame_equal(result, expected)\n\n        boolvec = f.index > f.index[7]\n        expected = f.reindex(index=f.index[boolvec])\n        result = ix[boolvec]\n        tm.assert_frame_equal(result, expected)\n        result = ix[boolvec, :]\n        tm.assert_frame_equal(result, expected)\n\n        result = ix[boolvec, f.columns[2:]]\n        expected = f.reindex(index=f.index[boolvec], columns=[\"C\", \"D\"])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 997,
        "end_line": 1018,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_fancy_boolean#1020",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_fancy_boolean(self, float_frame)",
        "snippet": "    def test_setitem_fancy_boolean(self, float_frame):\n        # from 2d, set with booleans\n        frame = float_frame.copy()\n        expected = float_frame.copy()\n\n        mask = frame[\"A\"] > 0\n        frame.loc[mask] = 0.0\n        expected.values[mask.values] = 0.0\n        tm.assert_frame_equal(frame, expected)\n\n        frame = float_frame.copy()\n        expected = float_frame.copy()\n        frame.loc[mask, [\"A\", \"B\"]] = 0.0\n        expected.values[mask.values, :2] = 0.0\n        tm.assert_frame_equal(frame, expected)",
        "begin_line": 1020,
        "end_line": 1034,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_fancy_ints#1036",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_fancy_ints(self, float_frame)",
        "snippet": "    def test_getitem_fancy_ints(self, float_frame):\n        result = float_frame.iloc[[1, 4, 7]]\n        expected = float_frame.loc[float_frame.index[[1, 4, 7]]]\n        tm.assert_frame_equal(result, expected)\n\n        result = float_frame.iloc[:, [2, 0, 1]]\n        expected = float_frame.loc[:, float_frame.columns[[2, 0, 1]]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1036,
        "end_line": 1043,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_fancy_exceptions#1045",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_fancy_exceptions(self, float_frame)",
        "snippet": "    def test_getitem_setitem_fancy_exceptions(self, float_frame):\n        ix = float_frame.iloc\n        with pytest.raises(IndexingError, match=\"Too many indexers\"):\n            ix[:, :, :]\n\n        with pytest.raises(IndexError, match=\"too many indices for array\"):\n            # GH#32257 we let numpy do validation, get their exception\n            ix[:, :, :] = 1",
        "begin_line": 1045,
        "end_line": 1052,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_boolean_misaligned#1054",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_boolean_misaligned(self, float_frame)",
        "snippet": "    def test_getitem_setitem_boolean_misaligned(self, float_frame):\n        # boolean index misaligned labels\n        mask = float_frame[\"A\"][::-1] > 1\n\n        result = float_frame.loc[mask]\n        expected = float_frame.loc[mask[::-1]]\n        tm.assert_frame_equal(result, expected)\n\n        cp = float_frame.copy()\n        expected = float_frame.copy()\n        cp.loc[mask] = 0\n        expected.loc[mask] = 0\n        tm.assert_frame_equal(cp, expected)",
        "begin_line": 1054,
        "end_line": 1066,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_boolean_multi#1068",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_boolean_multi(self)",
        "snippet": "    def test_getitem_setitem_boolean_multi(self):\n        df = DataFrame(np.random.randn(3, 2))\n\n        # get\n        k1 = np.array([True, False, True])\n        k2 = np.array([False, True])\n        result = df.loc[k1, k2]\n        expected = df.loc[[0, 2], [1]]\n        tm.assert_frame_equal(result, expected)\n\n        expected = df.copy()\n        df.loc[np.array([True, False, True]), np.array([False, True])] = 5\n        expected.loc[[0, 2], [1]] = 5\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 1068,
        "end_line": 1081,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_float_labels#1083",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_float_labels(self)",
        "snippet": "    def test_getitem_setitem_float_labels(self):\n        index = Index([1.5, 2, 3, 4, 5])\n        df = DataFrame(np.random.randn(5, 5), index=index)\n\n        result = df.loc[1.5:4]\n        expected = df.reindex([1.5, 2, 3, 4])\n        tm.assert_frame_equal(result, expected)\n        assert len(result) == 4\n\n        result = df.loc[4:5]\n        expected = df.reindex([4, 5])  # reindex with int\n        tm.assert_frame_equal(result, expected, check_index_type=False)\n        assert len(result) == 2\n\n        result = df.loc[4:5]\n        expected = df.reindex([4.0, 5.0])  # reindex with float\n        tm.assert_frame_equal(result, expected)\n        assert len(result) == 2\n\n        # loc_float changes this to work properly\n        result = df.loc[1:2]\n        expected = df.iloc[0:2]\n        tm.assert_frame_equal(result, expected)\n\n        df.loc[1:2] = 0\n        result = df[1:2]\n        assert (result == 0).all().all()\n\n        # #2727\n        index = Index([1.0, 2.5, 3.5, 4.5, 5.0])\n        df = DataFrame(np.random.randn(5, 5), index=index)\n\n        # positional slicing only via iloc!\n        msg = (\n            \"cannot do positional indexing on Float64Index with \"\n            r\"these indexers \\[1.0\\] of type float\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            df.iloc[1.0:5]\n\n        result = df.iloc[4:5]\n        expected = df.reindex([5.0])\n        tm.assert_frame_equal(result, expected)\n        assert len(result) == 1\n\n        cp = df.copy()\n\n        with pytest.raises(TypeError, match=_slice_msg):\n            cp.iloc[1.0:5] = 0\n\n        with pytest.raises(TypeError, match=msg):\n            result = cp.iloc[1.0:5] == 0  # noqa\n\n        assert result.values.all()\n        assert (cp.iloc[0:1] == df.iloc[0:1]).values.all()\n\n        cp = df.copy()\n        cp.iloc[4:5] = 0\n        assert (cp.iloc[4:5] == 0).values.all()\n        assert (cp.iloc[0:4] == df.iloc[0:4]).values.all()\n\n        # float slicing\n        result = df.loc[1.0:5]\n        expected = df\n        tm.assert_frame_equal(result, expected)\n        assert len(result) == 5\n\n        result = df.loc[1.1:5]\n        expected = df.reindex([2.5, 3.5, 4.5, 5.0])\n        tm.assert_frame_equal(result, expected)\n        assert len(result) == 4\n\n        result = df.loc[4.51:5]\n        expected = df.reindex([5.0])\n        tm.assert_frame_equal(result, expected)\n        assert len(result) == 1\n\n        result = df.loc[1.0:5.0]\n        expected = df.reindex([1.0, 2.5, 3.5, 4.5, 5.0])\n        tm.assert_frame_equal(result, expected)\n        assert len(result) == 5\n\n        cp = df.copy()\n        cp.loc[1.0:5.0] = 0\n        result = cp.loc[1.0:5.0]\n        assert (result == 0).values.all()",
        "begin_line": 1083,
        "end_line": 1168,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_single_column_mixed#1170",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_single_column_mixed(self)",
        "snippet": "    def test_setitem_single_column_mixed(self):\n        df = DataFrame(\n            np.random.randn(5, 3),\n            index=[\"a\", \"b\", \"c\", \"d\", \"e\"],\n            columns=[\"foo\", \"bar\", \"baz\"],\n        )\n        df[\"str\"] = \"qux\"\n        df.loc[df.index[::2], \"str\"] = np.nan\n        expected = np.array([np.nan, \"qux\", np.nan, \"qux\", np.nan], dtype=object)\n        tm.assert_almost_equal(df[\"str\"].values, expected)",
        "begin_line": 1170,
        "end_line": 1179,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_single_column_mixed_datetime#1181",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_single_column_mixed_datetime(self)",
        "snippet": "    def test_setitem_single_column_mixed_datetime(self):\n        df = DataFrame(\n            np.random.randn(5, 3),\n            index=[\"a\", \"b\", \"c\", \"d\", \"e\"],\n            columns=[\"foo\", \"bar\", \"baz\"],\n        )\n\n        df[\"timestamp\"] = Timestamp(\"20010102\")\n\n        # check our dtypes\n        result = df.dtypes\n        expected = Series(\n            [np.dtype(\"float64\")] * 3 + [np.dtype(\"datetime64[ns]\")],\n            index=[\"foo\", \"bar\", \"baz\", \"timestamp\"],\n        )\n        tm.assert_series_equal(result, expected)\n\n        # GH#16674 iNaT is treated as an integer when given by the user\n        df.loc[\"b\", \"timestamp\"] = iNaT\n        assert not isna(df.loc[\"b\", \"timestamp\"])\n        assert df[\"timestamp\"].dtype == np.object_\n        assert df.loc[\"b\", \"timestamp\"] == iNaT\n\n        # allow this syntax\n        df.loc[\"c\", \"timestamp\"] = np.nan\n        assert isna(df.loc[\"c\", \"timestamp\"])\n\n        # allow this syntax\n        df.loc[\"d\", :] = np.nan\n        assert not isna(df.loc[\"c\", :]).all()",
        "begin_line": 1181,
        "end_line": 1210,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_mixed_datetime#1218",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_mixed_datetime(self)",
        "snippet": "    def test_setitem_mixed_datetime(self):\n        # GH 9336\n        expected = DataFrame(\n            {\n                \"a\": [0, 0, 0, 0, 13, 14],\n                \"b\": [\n                    datetime(2012, 1, 1),\n                    1,\n                    \"x\",\n                    \"y\",\n                    datetime(2013, 1, 1),\n                    datetime(2014, 1, 1),\n                ],\n            }\n        )\n        df = pd.DataFrame(0, columns=list(\"ab\"), index=range(6))\n        df[\"b\"] = pd.NaT\n        df.loc[0, \"b\"] = datetime(2012, 1, 1)\n        df.loc[1, \"b\"] = 1\n        df.loc[[2, 3], \"b\"] = \"x\", \"y\"\n        A = np.array(\n            [\n                [13, np.datetime64(\"2013-01-01T00:00:00\")],\n                [14, np.datetime64(\"2014-01-01T00:00:00\")],\n            ]\n        )\n        df.loc[[4, 5], [\"a\", \"b\"]] = A\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 1218,
        "end_line": 1245,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_frame_float#1247",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_frame_float(self, float_frame)",
        "snippet": "    def test_setitem_frame_float(self, float_frame):\n        piece = float_frame.loc[float_frame.index[:2], [\"A\", \"B\"]]\n        float_frame.loc[float_frame.index[-2] :, [\"A\", \"B\"]] = piece.values\n        result = float_frame.loc[float_frame.index[-2:], [\"A\", \"B\"]].values\n        expected = piece.values\n        tm.assert_almost_equal(result, expected)",
        "begin_line": 1247,
        "end_line": 1252,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_frame_mixed#1254",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_frame_mixed(self, float_string_frame)",
        "snippet": "    def test_setitem_frame_mixed(self, float_string_frame):\n        # GH 3216\n\n        # already aligned\n        f = float_string_frame.copy()\n        piece = DataFrame(\n            [[1.0, 2.0], [3.0, 4.0]], index=f.index[0:2], columns=[\"A\", \"B\"]\n        )\n        key = (f.index[slice(None, 2)], [\"A\", \"B\"])\n        f.loc[key] = piece\n        tm.assert_almost_equal(f.loc[f.index[0:2], [\"A\", \"B\"]].values, piece.values)\n\n        # rows unaligned\n        f = float_string_frame.copy()\n        piece = DataFrame(\n            [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0], [7.0, 8.0]],\n            index=list(f.index[0:2]) + [\"foo\", \"bar\"],\n            columns=[\"A\", \"B\"],\n        )\n        key = (f.index[slice(None, 2)], [\"A\", \"B\"])\n        f.loc[key] = piece\n        tm.assert_almost_equal(\n            f.loc[f.index[0:2:], [\"A\", \"B\"]].values, piece.values[0:2]\n        )\n\n        # key is unaligned with values\n        f = float_string_frame.copy()\n        piece = f.loc[f.index[:2], [\"A\"]]\n        piece.index = f.index[-2:]\n        key = (f.index[slice(-2, None)], [\"A\", \"B\"])\n        f.loc[key] = piece\n        piece[\"B\"] = np.nan\n        tm.assert_almost_equal(f.loc[f.index[-2:], [\"A\", \"B\"]].values, piece.values)\n\n        # ndarray\n        f = float_string_frame.copy()\n        piece = float_string_frame.loc[f.index[:2], [\"A\", \"B\"]]\n        key = (f.index[slice(-2, None)], [\"A\", \"B\"])\n        f.loc[key] = piece.values\n        tm.assert_almost_equal(f.loc[f.index[-2:], [\"A\", \"B\"]].values, piece.values)",
        "begin_line": 1254,
        "end_line": 1293,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_frame_upcast#1295",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_frame_upcast(self)",
        "snippet": "    def test_setitem_frame_upcast(self):\n        # needs upcasting\n        df = DataFrame([[1, 2, \"foo\"], [3, 4, \"bar\"]], columns=[\"A\", \"B\", \"C\"])\n        df2 = df.copy()\n        df2.loc[:, [\"A\", \"B\"]] = df.loc[:, [\"A\", \"B\"]] + 0.5\n        expected = df.reindex(columns=[\"A\", \"B\"])\n        expected += 0.5\n        expected[\"C\"] = df[\"C\"]\n        tm.assert_frame_equal(df2, expected)",
        "begin_line": 1295,
        "end_line": 1303,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_frame_align#1305",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_frame_align(self, float_frame)",
        "snippet": "    def test_setitem_frame_align(self, float_frame):\n        piece = float_frame.loc[float_frame.index[:2], [\"A\", \"B\"]]\n        piece.index = float_frame.index[-2:]\n        piece.columns = [\"A\", \"B\"]\n        float_frame.loc[float_frame.index[-2:], [\"A\", \"B\"]] = piece\n        result = float_frame.loc[float_frame.index[-2:], [\"A\", \"B\"]].values\n        expected = piece.values\n        tm.assert_almost_equal(result, expected)",
        "begin_line": 1305,
        "end_line": 1312,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_ix_duplicates#1314",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_ix_duplicates(self)",
        "snippet": "    def test_getitem_setitem_ix_duplicates(self):\n        # #1201\n        df = DataFrame(np.random.randn(5, 3), index=[\"foo\", \"foo\", \"bar\", \"baz\", \"bar\"])\n\n        result = df.loc[\"foo\"]\n        expected = df[:2]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[\"bar\"]\n        expected = df.iloc[[2, 4]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[\"baz\"]\n        expected = df.iloc[3]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1314,
        "end_line": 1328,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_ix_boolean_duplicates_multiple#1330",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_ix_boolean_duplicates_multiple(self)",
        "snippet": "    def test_getitem_ix_boolean_duplicates_multiple(self):\n        # #1201\n        df = DataFrame(np.random.randn(5, 3), index=[\"foo\", \"foo\", \"bar\", \"baz\", \"bar\"])\n\n        result = df.loc[[\"bar\"]]\n        exp = df.iloc[[2, 4]]\n        tm.assert_frame_equal(result, exp)\n\n        result = df.loc[df[1] > 0]\n        exp = df[df[1] > 0]\n        tm.assert_frame_equal(result, exp)\n\n        result = df.loc[df[0] > 0]\n        exp = df[df[0] > 0]\n        tm.assert_frame_equal(result, exp)",
        "begin_line": 1330,
        "end_line": 1344,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_ix_bool_keyerror#1346",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_setitem_ix_bool_keyerror(self)",
        "snippet": "    def test_getitem_setitem_ix_bool_keyerror(self):\n        # #2199\n        df = DataFrame({\"a\": [1, 2, 3]})\n\n        with pytest.raises(KeyError, match=r\"^False$\"):\n            df.loc[False]\n        with pytest.raises(KeyError, match=r\"^True$\"):\n            df.loc[True]\n\n        msg = \"cannot use a single bool to index into setitem\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[False] = 0\n        with pytest.raises(KeyError, match=msg):\n            df.loc[True] = 0",
        "begin_line": 1346,
        "end_line": 1359,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_list_duplicates#1361",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_list_duplicates(self)",
        "snippet": "    def test_getitem_list_duplicates(self):\n        # #1943\n        df = DataFrame(np.random.randn(4, 4), columns=list(\"AABC\"))\n        df.columns.name = \"foo\"\n\n        result = df[[\"B\", \"C\"]]\n        assert result.columns.name == \"foo\"\n\n        expected = df.iloc[:, 2:]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1361,
        "end_line": 1370,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_get_value#1372",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_get_value(self, float_frame)",
        "snippet": "    def test_get_value(self, float_frame):\n        for idx in float_frame.index:\n            for col in float_frame.columns:\n                result = float_frame._get_value(idx, col)\n                expected = float_frame[col][idx]\n                assert result == expected",
        "begin_line": 1372,
        "end_line": 1377,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_lookup_float#1379",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_lookup_float(self, float_frame)",
        "snippet": "    def test_lookup_float(self, float_frame):\n        df = float_frame\n        rows = list(df.index) * len(df.columns)\n        cols = list(df.columns) * len(df.index)\n        result = df.lookup(rows, cols)\n\n        expected = np.array([df.loc[r, c] for r, c in zip(rows, cols)])\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 1379,
        "end_line": 1386,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_lookup_mixed#1388",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_lookup_mixed(self, float_string_frame)",
        "snippet": "    def test_lookup_mixed(self, float_string_frame):\n        df = float_string_frame\n        rows = list(df.index) * len(df.columns)\n        cols = list(df.columns) * len(df.index)\n        result = df.lookup(rows, cols)\n\n        expected = np.array(\n            [df.loc[r, c] for r, c in zip(rows, cols)], dtype=np.object_\n        )\n        tm.assert_almost_equal(result, expected)",
        "begin_line": 1388,
        "end_line": 1397,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_lookup_bool#1399",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_lookup_bool(self)",
        "snippet": "    def test_lookup_bool(self):\n        df = DataFrame(\n            {\n                \"label\": [\"a\", \"b\", \"a\", \"c\"],\n                \"mask_a\": [True, True, False, True],\n                \"mask_b\": [True, False, False, False],\n                \"mask_c\": [False, True, False, True],\n            }\n        )\n        df[\"mask\"] = df.lookup(df.index, \"mask_\" + df[\"label\"])\n\n        exp_mask = np.array(\n            [df.loc[r, c] for r, c in zip(df.index, \"mask_\" + df[\"label\"])]\n        )\n\n        tm.assert_series_equal(df[\"mask\"], pd.Series(exp_mask, name=\"mask\"))\n        assert df[\"mask\"].dtype == np.bool_",
        "begin_line": 1399,
        "end_line": 1415,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_lookup_raises#1417",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_lookup_raises(self, float_frame)",
        "snippet": "    def test_lookup_raises(self, float_frame):\n        with pytest.raises(KeyError, match=\"'One or more row labels was not found'\"):\n            float_frame.lookup([\"xyz\"], [\"A\"])\n\n        with pytest.raises(KeyError, match=\"'One or more column labels was not found'\"):\n            float_frame.lookup([float_frame.index[0]], [\"xyz\"])\n\n        with pytest.raises(ValueError, match=\"same size\"):\n            float_frame.lookup([\"a\", \"b\", \"c\"], [\"a\"])",
        "begin_line": 1417,
        "end_line": 1425,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_set_value#1427",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_set_value(self, float_frame)",
        "snippet": "    def test_set_value(self, float_frame):\n        for idx in float_frame.index:\n            for col in float_frame.columns:\n                float_frame._set_value(idx, col, 1)\n                assert float_frame[col][idx] == 1",
        "begin_line": 1427,
        "end_line": 1431,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_set_value_resize#1433",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_set_value_resize(self, float_frame)",
        "snippet": "    def test_set_value_resize(self, float_frame):\n\n        res = float_frame._set_value(\"foobar\", \"B\", 0)\n        assert res is None\n        assert float_frame.index[-1] == \"foobar\"\n        assert float_frame._get_value(\"foobar\", \"B\") == 0\n\n        float_frame.loc[\"foobar\", \"qux\"] = 0\n        assert float_frame._get_value(\"foobar\", \"qux\") == 0\n\n        res = float_frame.copy()\n        res._set_value(\"foobar\", \"baz\", \"sam\")\n        assert res[\"baz\"].dtype == np.object_\n\n        res = float_frame.copy()\n        res._set_value(\"foobar\", \"baz\", True)\n        assert res[\"baz\"].dtype == np.object_\n\n        res = float_frame.copy()\n        res._set_value(\"foobar\", \"baz\", 5)\n        assert is_float_dtype(res[\"baz\"])\n        assert isna(res[\"baz\"].drop([\"foobar\"])).all()\n        msg = \"could not convert string to float: 'sam'\"\n        with pytest.raises(ValueError, match=msg):\n            res._set_value(\"foobar\", \"baz\", \"sam\")",
        "begin_line": 1433,
        "end_line": 1457,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_set_value_with_index_dtype_change#1459",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_set_value_with_index_dtype_change(self)",
        "snippet": "    def test_set_value_with_index_dtype_change(self):\n        df_orig = DataFrame(np.random.randn(3, 3), index=range(3), columns=list(\"ABC\"))\n\n        # this is actually ambiguous as the 2 is interpreted as a positional\n        # so column is not created\n        df = df_orig.copy()\n        df._set_value(\"C\", 2, 1.0)\n        assert list(df.index) == list(df_orig.index) + [\"C\"]\n        # assert list(df.columns) == list(df_orig.columns) + [2]\n\n        df = df_orig.copy()\n        df.loc[\"C\", 2] = 1.0\n        assert list(df.index) == list(df_orig.index) + [\"C\"]\n        # assert list(df.columns) == list(df_orig.columns) + [2]\n\n        # create both new\n        df = df_orig.copy()\n        df._set_value(\"C\", \"D\", 1.0)\n        assert list(df.index) == list(df_orig.index) + [\"C\"]\n        assert list(df.columns) == list(df_orig.columns) + [\"D\"]\n\n        df = df_orig.copy()\n        df.loc[\"C\", \"D\"] = 1.0\n        assert list(df.index) == list(df_orig.index) + [\"C\"]\n        assert list(df.columns) == list(df_orig.columns) + [\"D\"]",
        "begin_line": 1459,
        "end_line": 1483,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_get_set_value_no_partial_indexing#1485",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_get_set_value_no_partial_indexing(self)",
        "snippet": "    def test_get_set_value_no_partial_indexing(self):\n        # partial w/ MultiIndex raise exception\n        index = MultiIndex.from_tuples([(0, 1), (0, 2), (1, 1), (1, 2)])\n        df = DataFrame(index=index, columns=range(4))\n        with pytest.raises(KeyError, match=r\"^0$\"):\n            df._get_value(0, 1)",
        "begin_line": 1485,
        "end_line": 1490,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_single_element_ix_dont_upcast#1493",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_single_element_ix_dont_upcast(self, float_frame)",
        "snippet": "    def test_single_element_ix_dont_upcast(self, float_frame):\n        float_frame[\"E\"] = 1\n        assert issubclass(float_frame[\"E\"].dtype.type, (int, np.integer))\n\n        result = float_frame.loc[float_frame.index[5], \"E\"]\n        assert is_integer(result)\n\n        # GH 11617\n        df = pd.DataFrame(dict(a=[1.23]))\n        df[\"b\"] = 666\n\n        result = df.loc[0, \"b\"]\n        assert is_integer(result)\n\n        expected = Series([666], [0], name=\"b\")\n        result = df.loc[[0], \"b\"]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1493,
        "end_line": 1509,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_iloc_row#1511",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_iloc_row(self)",
        "snippet": "    def test_iloc_row(self):\n        df = DataFrame(np.random.randn(10, 4), index=range(0, 20, 2))\n\n        result = df.iloc[1]\n        exp = df.loc[2]\n        tm.assert_series_equal(result, exp)\n\n        result = df.iloc[2]\n        exp = df.loc[4]\n        tm.assert_series_equal(result, exp)\n\n        # slice\n        result = df.iloc[slice(4, 8)]\n        expected = df.loc[8:14]\n        tm.assert_frame_equal(result, expected)\n\n        # verify slice is view\n        # setting it makes it raise/warn\n        msg = r\"\\nA value is trying to be set on a copy of a slice from a DataFrame\"\n        with pytest.raises(com.SettingWithCopyError, match=msg):\n            result[2] = 0.0\n\n        exp_col = df[2].copy()\n        exp_col[4:8] = 0.0\n        tm.assert_series_equal(df[2], exp_col)\n\n        # list of integers\n        result = df.iloc[[1, 2, 4, 6]]\n        expected = df.reindex(df.index[[1, 2, 4, 6]])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1511,
        "end_line": 1540,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_iloc_col#1542",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_iloc_col(self)",
        "snippet": "    def test_iloc_col(self):\n\n        df = DataFrame(np.random.randn(4, 10), columns=range(0, 20, 2))\n\n        result = df.iloc[:, 1]\n        exp = df.loc[:, 2]\n        tm.assert_series_equal(result, exp)\n\n        result = df.iloc[:, 2]\n        exp = df.loc[:, 4]\n        tm.assert_series_equal(result, exp)\n\n        # slice\n        result = df.iloc[:, slice(4, 8)]\n        expected = df.loc[:, 8:14]\n        tm.assert_frame_equal(result, expected)\n\n        # verify slice is view\n        # and that we are setting a copy\n        msg = r\"\\nA value is trying to be set on a copy of a slice from a DataFrame\"\n        with pytest.raises(com.SettingWithCopyError, match=msg):\n            result[8] = 0.0\n\n        assert (df[8] == 0).all()\n\n        # list of integers\n        result = df.iloc[:, [1, 2, 4, 6]]\n        expected = df.reindex(columns=df.columns[[1, 2, 4, 6]])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1542,
        "end_line": 1570,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_iloc_duplicates#1572",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_iloc_duplicates(self)",
        "snippet": "    def test_iloc_duplicates(self):\n\n        df = DataFrame(np.random.rand(3, 3), columns=list(\"ABC\"), index=list(\"aab\"))\n\n        result = df.iloc[0]\n        assert isinstance(result, Series)\n        tm.assert_almost_equal(result.values, df.values[0])\n\n        result = df.T.iloc[:, 0]\n        assert isinstance(result, Series)\n        tm.assert_almost_equal(result.values, df.values[0])\n\n        # #2259\n        df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=[1, 1, 2])\n        result = df.iloc[:, [0]]\n        expected = df.take([0], axis=1)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1572,
        "end_line": 1588,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_loc_duplicates#1590",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_loc_duplicates(self)",
        "snippet": "    def test_loc_duplicates(self):\n        # gh-17105\n\n        # insert a duplicate element to the index\n        trange = pd.date_range(\n            start=pd.Timestamp(year=2017, month=1, day=1),\n            end=pd.Timestamp(year=2017, month=1, day=5),\n        )\n\n        trange = trange.insert(loc=5, item=pd.Timestamp(year=2017, month=1, day=5))\n\n        df = pd.DataFrame(0, index=trange, columns=[\"A\", \"B\"])\n        bool_idx = np.array([False, False, False, False, False, True])\n\n        # assignment\n        df.loc[trange[bool_idx], \"A\"] = 6\n\n        expected = pd.DataFrame(\n            {\"A\": [0, 0, 0, 0, 6, 6], \"B\": [0, 0, 0, 0, 0, 0]}, index=trange\n        )\n        tm.assert_frame_equal(df, expected)\n\n        # in-place\n        df = pd.DataFrame(0, index=trange, columns=[\"A\", \"B\"])\n        df.loc[trange[bool_idx], \"A\"] += 6\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 1590,
        "end_line": 1615,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_methods#1625",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_methods(self, method, expected_values)",
        "snippet": "    def test_reindex_methods(self, method, expected_values):\n        df = pd.DataFrame({\"x\": list(range(5))})\n        target = np.array([-0.1, 0.9, 1.1, 1.5])\n\n        expected = pd.DataFrame({\"x\": expected_values}, index=target)\n        actual = df.reindex(target, method=method)\n        tm.assert_frame_equal(expected, actual)\n\n        actual = df.reindex_like(df, method=method, tolerance=0)\n        tm.assert_frame_equal(df, actual)\n        actual = df.reindex_like(df, method=method, tolerance=[0, 0, 0, 0])\n        tm.assert_frame_equal(df, actual)\n\n        actual = df.reindex(target, method=method, tolerance=1)\n        tm.assert_frame_equal(expected, actual)\n        actual = df.reindex(target, method=method, tolerance=[1, 1, 1, 1])\n        tm.assert_frame_equal(expected, actual)\n\n        e2 = expected[::-1]\n        actual = df.reindex(target[::-1], method=method)\n        tm.assert_frame_equal(e2, actual)\n\n        new_order = [3, 0, 2, 1]\n        e2 = expected.iloc[new_order]\n        actual = df.reindex(target[new_order], method=method)\n        tm.assert_frame_equal(e2, actual)\n\n        switched_method = (\n            \"pad\" if method == \"backfill\" else \"backfill\" if method == \"pad\" else method\n        )\n        actual = df[::-1].reindex(target, method=switched_method)\n        tm.assert_frame_equal(expected, actual)",
        "begin_line": 1625,
        "end_line": 1656,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_subclass#1658",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_subclass(self)",
        "snippet": "    def test_reindex_subclass(self):\n        # https://github.com/pandas-dev/pandas/issues/31925\n        class MyDataFrame(DataFrame):\n            pass\n\n        expected = DataFrame()\n        df = MyDataFrame()\n        result = df.reindex_like(expected)\n\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1658,
        "end_line": 1667,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.MyDataFrame.test_reindex_subclass#1658",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.MyDataFrame",
        "signature": "pandas.tests.frame.indexing.test_indexing.MyDataFrame.test_reindex_subclass(self)",
        "snippet": "    def test_reindex_subclass(self):\n        # https://github.com/pandas-dev/pandas/issues/31925\n        class MyDataFrame(DataFrame):\n            pass\n\n        expected = DataFrame()\n        df = MyDataFrame()\n        result = df.reindex_like(expected)\n\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1658,
        "end_line": 1667,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_methods_nearest_special#1669",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_methods_nearest_special(self)",
        "snippet": "    def test_reindex_methods_nearest_special(self):\n        df = pd.DataFrame({\"x\": list(range(5))})\n        target = np.array([-0.1, 0.9, 1.1, 1.5])\n\n        expected = pd.DataFrame({\"x\": [0, 1, 1, np.nan]}, index=target)\n        actual = df.reindex(target, method=\"nearest\", tolerance=0.2)\n        tm.assert_frame_equal(expected, actual)\n\n        expected = pd.DataFrame({\"x\": [0, np.nan, 1, np.nan]}, index=target)\n        actual = df.reindex(target, method=\"nearest\", tolerance=[0.5, 0.01, 0.4, 0.1])\n        tm.assert_frame_equal(expected, actual)",
        "begin_line": 1669,
        "end_line": 1679,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_nearest_tz#1681",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_nearest_tz(self, tz_aware_fixture)",
        "snippet": "    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n\n        expected = df.head(3)\n        actual = df.reindex(idx[:3], method=\"nearest\")\n        tm.assert_frame_equal(expected, actual)",
        "begin_line": 1681,
        "end_line": 1689,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_nearest_tz_empty_frame#1691",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_nearest_tz_empty_frame(self)",
        "snippet": "    def test_reindex_nearest_tz_empty_frame(self):\n        # https://github.com/pandas-dev/pandas/issues/31964\n        dti = pd.DatetimeIndex([\"2016-06-26 14:27:26+00:00\"])\n        df = pd.DataFrame(index=pd.DatetimeIndex([\"2016-07-04 14:00:59+00:00\"]))\n        expected = pd.DataFrame(index=dti)\n        result = df.reindex(dti, method=\"nearest\")\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1691,
        "end_line": 1697,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_frame_add_nat#1699",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_frame_add_nat(self)",
        "snippet": "    def test_reindex_frame_add_nat(self):\n        rng = date_range(\"1/1/2000 00:00:00\", periods=10, freq=\"10s\")\n        df = DataFrame({\"A\": np.random.randn(len(rng)), \"B\": rng})\n\n        result = df.reindex(range(15))\n        assert np.issubdtype(result[\"B\"].dtype, np.dtype(\"M8[ns]\"))\n\n        mask = com.isna(result)[\"B\"]\n        assert mask[-5:].all()\n        assert not mask[:-5].any()",
        "begin_line": 1699,
        "end_line": 1708,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_limit#1710",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_limit(self)",
        "snippet": "    def test_reindex_limit(self):\n        # GH 28631\n        data = [[\"A\", \"A\", \"A\"], [\"B\", \"B\", \"B\"], [\"C\", \"C\", \"C\"], [\"D\", \"D\", \"D\"]]\n        exp_data = [\n            [\"A\", \"A\", \"A\"],\n            [\"B\", \"B\", \"B\"],\n            [\"C\", \"C\", \"C\"],\n            [\"D\", \"D\", \"D\"],\n            [\"D\", \"D\", \"D\"],\n            [np.nan, np.nan, np.nan],\n        ]\n        df = DataFrame(data)\n        result = df.reindex([0, 1, 2, 3, 4, 5], method=\"ffill\", limit=1)\n        expected = DataFrame(exp_data)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1710,
        "end_line": 1724,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_set_dataframe_column_ns_dtype#1726",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_set_dataframe_column_ns_dtype(self)",
        "snippet": "    def test_set_dataframe_column_ns_dtype(self):\n        x = DataFrame([datetime.now(), datetime.now()])\n        assert x[0].dtype == np.dtype(\"M8[ns]\")",
        "begin_line": 1726,
        "end_line": 1728,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_non_monotonic_reindex_methods#1730",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_non_monotonic_reindex_methods(self)",
        "snippet": "    def test_non_monotonic_reindex_methods(self):\n        dr = pd.date_range(\"2013-08-01\", periods=6, freq=\"B\")\n        data = np.random.randn(6, 1)\n        df = pd.DataFrame(data, index=dr, columns=list(\"A\"))\n        df_rev = pd.DataFrame(data, index=dr[[3, 4, 5] + [0, 1, 2]], columns=list(\"A\"))\n        # index is not monotonic increasing or decreasing\n        msg = \"index must be monotonic increasing or decreasing\"\n        with pytest.raises(ValueError, match=msg):\n            df_rev.reindex(df.index, method=\"pad\")\n        with pytest.raises(ValueError, match=msg):\n            df_rev.reindex(df.index, method=\"ffill\")\n        with pytest.raises(ValueError, match=msg):\n            df_rev.reindex(df.index, method=\"bfill\")\n        with pytest.raises(ValueError, match=msg):\n            df_rev.reindex(df.index, method=\"nearest\")",
        "begin_line": 1730,
        "end_line": 1744,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_level#1746",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_reindex_level(self)",
        "snippet": "    def test_reindex_level(self):\n        from itertools import permutations\n\n        icol = [\"jim\", \"joe\", \"jolie\"]\n\n        def verify_first_level(df, level, idx, check_index_type=True):\n            def f(val):\n                return np.nonzero((df[level] == val).to_numpy())[0]\n\n            i = np.concatenate(list(map(f, idx)))\n            left = df.set_index(icol).reindex(idx, level=level)\n            right = df.iloc[i].set_index(icol)\n            tm.assert_frame_equal(left, right, check_index_type=check_index_type)\n\n        def verify(df, level, idx, indexer, check_index_type=True):\n            left = df.set_index(icol).reindex(idx, level=level)\n            right = df.iloc[indexer].set_index(icol)\n            tm.assert_frame_equal(left, right, check_index_type=check_index_type)\n\n        df = pd.DataFrame(\n            {\n                \"jim\": list(\"B\" * 4 + \"A\" * 2 + \"C\" * 3),\n                \"joe\": list(\"abcdeabcd\")[::-1],\n                \"jolie\": [10, 20, 30] * 3,\n                \"joline\": np.random.randint(0, 1000, 9),\n            }\n        )\n\n        target = [\n            [\"C\", \"B\", \"A\"],\n            [\"F\", \"C\", \"A\", \"D\"],\n            [\"A\"],\n            [\"A\", \"B\", \"C\"],\n            [\"C\", \"A\", \"B\"],\n            [\"C\", \"B\"],\n            [\"C\", \"A\"],\n            [\"A\", \"B\"],\n            [\"B\", \"A\", \"C\"],\n        ]\n\n        for idx in target:\n            verify_first_level(df, \"jim\", idx)\n\n        # reindex by these causes different MultiIndex levels\n        for idx in [[\"D\", \"F\"], [\"A\", \"C\", \"B\"]]:\n            verify_first_level(df, \"jim\", idx, check_index_type=False)\n\n        verify(df, \"joe\", list(\"abcde\"), [3, 2, 1, 0, 5, 4, 8, 7, 6])\n        verify(df, \"joe\", list(\"abcd\"), [3, 2, 1, 0, 5, 8, 7, 6])\n        verify(df, \"joe\", list(\"abc\"), [3, 2, 1, 8, 7, 6])\n        verify(df, \"joe\", list(\"eca\"), [1, 3, 4, 6, 8])\n        verify(df, \"joe\", list(\"edc\"), [0, 1, 4, 5, 6])\n        verify(df, \"joe\", list(\"eadbc\"), [3, 0, 2, 1, 4, 5, 8, 7, 6])\n        verify(df, \"joe\", list(\"edwq\"), [0, 4, 5])\n        verify(df, \"joe\", list(\"wq\"), [], check_index_type=False)\n\n        df = DataFrame(\n            {\n                \"jim\": [\"mid\"] * 5 + [\"btm\"] * 8 + [\"top\"] * 7,\n                \"joe\": [\"3rd\"] * 2\n                + [\"1st\"] * 3\n                + [\"2nd\"] * 3\n                + [\"1st\"] * 2\n                + [\"3rd\"] * 3\n                + [\"1st\"] * 2\n                + [\"3rd\"] * 3\n                + [\"2nd\"] * 2,\n                # this needs to be jointly unique with jim and joe or\n                # reindexing will fail ~1.5% of the time, this works\n                # out to needing unique groups of same size as joe\n                \"jolie\": np.concatenate(\n                    [\n                        np.random.choice(1000, x, replace=False)\n                        for x in [2, 3, 3, 2, 3, 2, 3, 2]\n                    ]\n                ),\n                \"joline\": np.random.randn(20).round(3) * 10,\n            }\n        )\n\n        for idx in permutations(df[\"jim\"].unique()):\n            for i in range(3):\n                verify_first_level(df, \"jim\", idx[: i + 1])\n\n        i = [2, 3, 4, 0, 1, 8, 9, 5, 6, 7, 10, 11, 12, 13, 14, 18, 19, 15, 16, 17]\n        verify(df, \"joe\", [\"1st\", \"2nd\", \"3rd\"], i)\n\n        i = [0, 1, 2, 3, 4, 10, 11, 12, 5, 6, 7, 8, 9, 15, 16, 17, 18, 19, 13, 14]\n        verify(df, \"joe\", [\"3rd\", \"2nd\", \"1st\"], i)\n\n        i = [0, 1, 5, 6, 7, 10, 11, 12, 18, 19, 15, 16, 17]\n        verify(df, \"joe\", [\"2nd\", \"3rd\"], i)\n\n        i = [0, 1, 2, 3, 4, 10, 11, 12, 8, 9, 15, 16, 17, 13, 14]\n        verify(df, \"joe\", [\"3rd\", \"1st\"], i)",
        "begin_line": 1746,
        "end_line": 1840,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.verify_first_level#1751",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.verify_first_level(df, level, idx, check_index_type=True)",
        "snippet": "        def verify_first_level(df, level, idx, check_index_type=True):\n            def f(val):\n                return np.nonzero((df[level] == val).to_numpy())[0]\n\n            i = np.concatenate(list(map(f, idx)))\n            left = df.set_index(icol).reindex(idx, level=level)\n            right = df.iloc[i].set_index(icol)\n            tm.assert_frame_equal(left, right, check_index_type=check_index_type)",
        "begin_line": 1751,
        "end_line": 1758,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.f#1752",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.f(val)",
        "snippet": "            def f(val):\n                return np.nonzero((df[level] == val).to_numpy())[0]",
        "begin_line": 1752,
        "end_line": 1753,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.verify#1760",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.verify(df, level, idx, indexer, check_index_type=True)",
        "snippet": "        def verify(df, level, idx, indexer, check_index_type=True):\n            left = df.set_index(icol).reindex(idx, level=level)\n            right = df.iloc[indexer].set_index(icol)\n            tm.assert_frame_equal(left, right, check_index_type=check_index_type)",
        "begin_line": 1760,
        "end_line": 1763,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_ix_float_duplicates#1842",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_ix_float_duplicates(self)",
        "snippet": "    def test_getitem_ix_float_duplicates(self):\n        df = pd.DataFrame(\n            np.random.randn(3, 3), index=[0.1, 0.2, 0.2], columns=list(\"abc\")\n        )\n        expect = df.iloc[1:]\n        tm.assert_frame_equal(df.loc[0.2], expect)\n\n        expect = df.iloc[1:, 0]\n        tm.assert_series_equal(df.loc[0.2, \"a\"], expect)\n\n        df.index = [1, 0.2, 0.2]\n        expect = df.iloc[1:]\n        tm.assert_frame_equal(df.loc[0.2], expect)\n\n        expect = df.iloc[1:, 0]\n        tm.assert_series_equal(df.loc[0.2, \"a\"], expect)\n\n        df = pd.DataFrame(\n            np.random.randn(4, 3), index=[1, 0.2, 0.2, 1], columns=list(\"abc\")\n        )\n        expect = df.iloc[1:-1]\n        tm.assert_frame_equal(df.loc[0.2], expect)\n\n        expect = df.iloc[1:-1, 0]\n        tm.assert_series_equal(df.loc[0.2, \"a\"], expect)\n\n        df.index = [0.1, 0.2, 2, 0.2]\n        expect = df.iloc[[1, -1]]\n        tm.assert_frame_equal(df.loc[0.2], expect)\n\n        expect = df.iloc[[1, -1], 0]\n        tm.assert_series_equal(df.loc[0.2, \"a\"], expect)",
        "begin_line": 1842,
        "end_line": 1873,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_sparse_column#1875",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_getitem_sparse_column(self)",
        "snippet": "    def test_getitem_sparse_column(self):\n        # https://github.com/pandas-dev/pandas/issues/23559\n        data = SparseArray([0, 1])\n        df = pd.DataFrame({\"A\": data})\n        expected = pd.Series(data, name=\"A\")\n        result = df[\"A\"]\n        tm.assert_series_equal(result, expected)\n\n        result = df.iloc[:, 0]\n        tm.assert_series_equal(result, expected)\n\n        result = df.loc[:, \"A\"]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1875,
        "end_line": 1887,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_with_sparse_value#1889",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_with_sparse_value(self)",
        "snippet": "    def test_setitem_with_sparse_value(self):\n        # GH8131\n        df = pd.DataFrame({\"c_1\": [\"a\", \"b\", \"c\"], \"n_1\": [1.0, 2.0, 3.0]})\n        sp_array = SparseArray([0, 0, 1])\n        df[\"new_column\"] = sp_array\n        tm.assert_series_equal(\n            df[\"new_column\"], pd.Series(sp_array, name=\"new_column\"), check_names=False\n        )",
        "begin_line": 1889,
        "end_line": 1896,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_with_unaligned_sparse_value#1898",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_with_unaligned_sparse_value(self)",
        "snippet": "    def test_setitem_with_unaligned_sparse_value(self):\n        df = pd.DataFrame({\"c_1\": [\"a\", \"b\", \"c\"], \"n_1\": [1.0, 2.0, 3.0]})\n        sp_series = pd.Series(SparseArray([0, 0, 1]), index=[2, 1, 0])\n        df[\"new_column\"] = sp_series\n        exp = pd.Series(SparseArray([1, 0, 0]), name=\"new_column\")\n        tm.assert_series_equal(df[\"new_column\"], exp)",
        "begin_line": 1898,
        "end_line": 1903,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_with_unaligned_tz_aware_datetime_column#1905",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_with_unaligned_tz_aware_datetime_column(self)",
        "snippet": "    def test_setitem_with_unaligned_tz_aware_datetime_column(self):\n        # GH 12981\n        # Assignment of unaligned offset-aware datetime series.\n        # Make sure timezone isn't lost\n        column = pd.Series(\n            pd.date_range(\"2015-01-01\", periods=3, tz=\"utc\"), name=\"dates\"\n        )\n        df = pd.DataFrame({\"dates\": column})\n        df[\"dates\"] = column[[1, 0, 2]]\n        tm.assert_series_equal(df[\"dates\"], column)\n\n        df = pd.DataFrame({\"dates\": column})\n        df.loc[[0, 1, 2], \"dates\"] = column[[1, 0, 2]]\n        tm.assert_series_equal(df[\"dates\"], column)",
        "begin_line": 1905,
        "end_line": 1918,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_datetime_coercion#1920",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_datetime_coercion(self)",
        "snippet": "    def test_setitem_datetime_coercion(self):\n        # gh-1048\n        df = pd.DataFrame({\"c\": [pd.Timestamp(\"2010-10-01\")] * 3})\n        df.loc[0:1, \"c\"] = np.datetime64(\"2008-08-08\")\n        assert pd.Timestamp(\"2008-08-08\") == df.loc[0, \"c\"]\n        assert pd.Timestamp(\"2008-08-08\") == df.loc[1, \"c\"]\n        df.loc[2, \"c\"] = date(2005, 5, 5)\n        assert pd.Timestamp(\"2005-05-05\") == df.loc[2, \"c\"]",
        "begin_line": 1920,
        "end_line": 1927,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_datetimelike_with_inference#1929",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_datetimelike_with_inference(self)",
        "snippet": "    def test_setitem_datetimelike_with_inference(self):\n        # GH 7592\n        # assignment of timedeltas with NaT\n\n        one_hour = timedelta(hours=1)\n        df = DataFrame(index=date_range(\"20130101\", periods=4))\n        df[\"A\"] = np.array([1 * one_hour] * 4, dtype=\"m8[ns]\")\n        df.loc[:, \"B\"] = np.array([2 * one_hour] * 4, dtype=\"m8[ns]\")\n        df.loc[df.index[:3], \"C\"] = np.array([3 * one_hour] * 3, dtype=\"m8[ns]\")\n        df.loc[:, \"D\"] = np.array([4 * one_hour] * 4, dtype=\"m8[ns]\")\n        df.loc[df.index[:3], \"E\"] = np.array([5 * one_hour] * 3, dtype=\"m8[ns]\")\n        df[\"F\"] = np.timedelta64(\"NaT\")\n        df.loc[df.index[:-1], \"F\"] = np.array([6 * one_hour] * 3, dtype=\"m8[ns]\")\n        df.loc[df.index[-3] :, \"G\"] = date_range(\"20130101\", periods=3)\n        df[\"H\"] = np.datetime64(\"NaT\")\n        result = df.dtypes\n        expected = Series(\n            [np.dtype(\"timedelta64[ns]\")] * 6 + [np.dtype(\"datetime64[ns]\")] * 2,\n            index=list(\"ABCDEFGH\"),\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1929,
        "end_line": 1949,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_datetimeindex_tz#1952",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_setitem_datetimeindex_tz(self, idxer, tz_naive_fixture)",
        "snippet": "    def test_setitem_datetimeindex_tz(self, idxer, tz_naive_fixture):\n        # GH 11365\n        tz = tz_naive_fixture\n        idx = date_range(start=\"2015-07-12\", periods=3, freq=\"H\", tz=tz)\n        expected = DataFrame(1.2, index=idx, columns=[\"var\"])\n        result = DataFrame(index=idx, columns=[\"var\"])\n        result.loc[:, idxer] = expected\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1952,
        "end_line": 1959,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_at_time_between_time_datetimeindex#1961",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_at_time_between_time_datetimeindex(self)",
        "snippet": "    def test_at_time_between_time_datetimeindex(self):\n        index = date_range(\"2012-01-01\", \"2012-01-05\", freq=\"30min\")\n        df = DataFrame(np.random.randn(len(index), 5), index=index)\n        akey = time(12, 0, 0)\n        bkey = slice(time(13, 0, 0), time(14, 0, 0))\n        ainds = [24, 72, 120, 168]\n        binds = [26, 27, 28, 74, 75, 76, 122, 123, 124, 170, 171, 172]\n\n        result = df.at_time(akey)\n        expected = df.loc[akey]\n        expected2 = df.iloc[ainds]\n        tm.assert_frame_equal(result, expected)\n        tm.assert_frame_equal(result, expected2)\n        assert len(result) == 4\n\n        result = df.between_time(bkey.start, bkey.stop)\n        expected = df.loc[bkey]\n        expected2 = df.iloc[binds]\n        tm.assert_frame_equal(result, expected)\n        tm.assert_frame_equal(result, expected2)\n        assert len(result) == 12\n\n        result = df.copy()\n        result.loc[akey] = 0\n        result = result.loc[akey]\n        expected = df.loc[akey].copy()\n        expected.loc[:] = 0\n        tm.assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.loc[akey] = 0\n        result.loc[akey] = df.iloc[ainds]\n        tm.assert_frame_equal(result, df)\n\n        result = df.copy()\n        result.loc[bkey] = 0\n        result = result.loc[bkey]\n        expected = df.loc[bkey].copy()\n        expected.loc[:] = 0\n        tm.assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.loc[bkey] = 0\n        result.loc[bkey] = df.iloc[binds]\n        tm.assert_frame_equal(result, df)",
        "begin_line": 1961,
        "end_line": 2005,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_index_namedtuple#2007",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_index_namedtuple(self)",
        "snippet": "    def test_index_namedtuple(self):\n        from collections import namedtuple\n\n        IndexType = namedtuple(\"IndexType\", [\"a\", \"b\"])\n        idx1 = IndexType(\"foo\", \"bar\")\n        idx2 = IndexType(\"baz\", \"bof\")\n        index = Index([idx1, idx2], name=\"composite_index\", tupleize_cols=False)\n        df = DataFrame([(1, 2), (3, 4)], index=index, columns=[\"A\", \"B\"])\n\n        result = df.loc[IndexType(\"foo\", \"bar\")][\"A\"]\n        assert result == 1",
        "begin_line": 2007,
        "end_line": 2017,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_index_single_double_tuples#2020",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_index_single_double_tuples(self, tpl)",
        "snippet": "    def test_index_single_double_tuples(self, tpl):\n        # GH 20991\n        idx = pd.Index([tuple([1]), tuple([1, 2])], name=\"A\", tupleize_cols=False)\n        df = DataFrame(index=idx)\n\n        result = df.loc[[tpl]]\n        idx = pd.Index([tpl], name=\"A\", tupleize_cols=False)\n        expected = DataFrame(index=idx)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2020,
        "end_line": 2028,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_boolean_indexing#2030",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_boolean_indexing(self)",
        "snippet": "    def test_boolean_indexing(self):\n        idx = list(range(3))\n        cols = [\"A\", \"B\", \"C\"]\n        df1 = DataFrame(\n            index=idx,\n            columns=cols,\n            data=np.array(\n                [[0.0, 0.5, 1.0], [1.5, 2.0, 2.5], [3.0, 3.5, 4.0]], dtype=float\n            ),\n        )\n        df2 = DataFrame(index=idx, columns=cols, data=np.ones((len(idx), len(cols))))\n\n        expected = DataFrame(\n            index=idx,\n            columns=cols,\n            data=np.array([[0.0, 0.5, 1.0], [1.5, 2.0, -1], [-1, -1, -1]], dtype=float),\n        )\n\n        df1[df1 > 2.0 * df2] = -1\n        tm.assert_frame_equal(df1, expected)\n        with pytest.raises(ValueError, match=\"Item wrong length\"):\n            df1[df1.index[:-1] > 2] = -1",
        "begin_line": 2030,
        "end_line": 2051,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_boolean_indexing_mixed#2053",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_boolean_indexing_mixed(self)",
        "snippet": "    def test_boolean_indexing_mixed(self):\n        df = DataFrame(\n            {\n                0: {35: np.nan, 40: np.nan, 43: np.nan, 49: np.nan, 50: np.nan},\n                1: {\n                    35: np.nan,\n                    40: 0.32632316859446198,\n                    43: np.nan,\n                    49: 0.32632316859446198,\n                    50: 0.39114724480578139,\n                },\n                2: {\n                    35: np.nan,\n                    40: np.nan,\n                    43: 0.29012581014105987,\n                    49: np.nan,\n                    50: np.nan,\n                },\n                3: {35: np.nan, 40: np.nan, 43: np.nan, 49: np.nan, 50: np.nan},\n                4: {\n                    35: 0.34215328467153283,\n                    40: np.nan,\n                    43: np.nan,\n                    49: np.nan,\n                    50: np.nan,\n                },\n                \"y\": {35: 0, 40: 0, 43: 0, 49: 0, 50: 1},\n            }\n        )\n\n        # mixed int/float ok\n        df2 = df.copy()\n        df2[df2 > 0.3] = 1\n        expected = df.copy()\n        expected.loc[40, 1] = 1\n        expected.loc[49, 1] = 1\n        expected.loc[50, 1] = 1\n        expected.loc[35, 4] = 1\n        tm.assert_frame_equal(df2, expected)\n\n        df[\"foo\"] = \"test\"\n        msg = \"not supported between instances|unorderable types\"\n\n        with pytest.raises(TypeError, match=msg):\n            df[df > 0.3] = 1",
        "begin_line": 2053,
        "end_line": 2097,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_mask#2099",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_mask(self)",
        "snippet": "    def test_mask(self):\n        df = DataFrame(np.random.randn(5, 3))\n        cond = df > 0\n\n        rs = df.where(cond, np.nan)\n        tm.assert_frame_equal(rs, df.mask(df <= 0))\n        tm.assert_frame_equal(rs, df.mask(~cond))\n\n        other = DataFrame(np.random.randn(5, 3))\n        rs = df.where(cond, other)\n        tm.assert_frame_equal(rs, df.mask(df <= 0, other))\n        tm.assert_frame_equal(rs, df.mask(~cond, other))\n\n        # see gh-21891\n        df = DataFrame([1, 2])\n        res = df.mask([[True], [False]])\n\n        exp = DataFrame([np.nan, 2])\n        tm.assert_frame_equal(res, exp)",
        "begin_line": 2099,
        "end_line": 2117,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_mask_inplace#2119",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_mask_inplace(self)",
        "snippet": "    def test_mask_inplace(self):\n        # GH8801\n        df = DataFrame(np.random.randn(5, 3))\n        cond = df > 0\n\n        rdf = df.copy()\n\n        rdf.where(cond, inplace=True)\n        tm.assert_frame_equal(rdf, df.where(cond))\n        tm.assert_frame_equal(rdf, df.mask(~cond))\n\n        rdf = df.copy()\n        rdf.where(cond, -df, inplace=True)\n        tm.assert_frame_equal(rdf, df.where(cond, -df))\n        tm.assert_frame_equal(rdf, df.mask(~cond, -df))",
        "begin_line": 2119,
        "end_line": 2133,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_mask_edge_case_1xN_frame#2135",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_mask_edge_case_1xN_frame(self)",
        "snippet": "    def test_mask_edge_case_1xN_frame(self):\n        # GH4071\n        df = DataFrame([[1, 2]])\n        res = df.mask(DataFrame([[True, False]]))\n        expec = DataFrame([[np.nan, 2]])\n        tm.assert_frame_equal(res, expec)",
        "begin_line": 2135,
        "end_line": 2140,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_mask_callable#2142",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_mask_callable(self)",
        "snippet": "    def test_mask_callable(self):\n        # GH 12533\n        df = DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        result = df.mask(lambda x: x > 4, lambda x: x + 1)\n        exp = DataFrame([[1, 2, 3], [4, 6, 7], [8, 9, 10]])\n        tm.assert_frame_equal(result, exp)\n        tm.assert_frame_equal(result, df.mask(df > 4, df + 1))\n\n        # return ndarray and scalar\n        result = df.mask(lambda x: (x % 2 == 0).values, lambda x: 99)\n        exp = DataFrame([[1, 99, 3], [99, 5, 99], [7, 99, 9]])\n        tm.assert_frame_equal(result, exp)\n        tm.assert_frame_equal(result, df.mask(df % 2 == 0, 99))\n\n        # chain\n        result = (df + 2).mask(lambda x: x > 8, lambda x: x + 10)\n        exp = DataFrame([[3, 4, 5], [6, 7, 8], [19, 20, 21]])\n        tm.assert_frame_equal(result, exp)\n        tm.assert_frame_equal(result, (df + 2).mask((df + 2) > 8, (df + 2) + 10))",
        "begin_line": 2142,
        "end_line": 2160,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_type_error_multiindex#2162",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_type_error_multiindex(self)",
        "snippet": "    def test_type_error_multiindex(self):\n        # See gh-12218\n        df = DataFrame(\n            columns=[\"i\", \"c\", \"x\", \"y\"],\n            data=[[0, 0, 1, 2], [1, 0, 3, 4], [0, 1, 1, 2], [1, 1, 3, 4]],\n        )\n        dg = df.pivot_table(index=\"i\", columns=\"c\", values=[\"x\", \"y\"])\n\n        with pytest.raises(TypeError, match=\"is an invalid key\"):\n            dg[:, 0]\n\n        index = Index(range(2), name=\"i\")\n        columns = MultiIndex(\n            levels=[[\"x\", \"y\"], [0, 1]], codes=[[0, 1], [0, 0]], names=[None, \"c\"]\n        )\n        expected = DataFrame([[1, 2], [3, 4]], columns=columns, index=index)\n\n        result = dg.loc[:, (slice(None), 0)]\n        tm.assert_frame_equal(result, expected)\n\n        name = (\"x\", 0)\n        index = Index(range(2), name=\"i\")\n        expected = Series([1, 3], index=index, name=name)\n\n        result = dg[\"x\", 0]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 2162,
        "end_line": 2187,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_interval_index#2189",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexing.test_interval_index(self)",
        "snippet": "    def test_interval_index(self):\n        # GH 19977\n        index = pd.interval_range(start=0, periods=3)\n        df = pd.DataFrame(\n            [[1, 2, 3], [4, 5, 6], [7, 8, 9]], index=index, columns=[\"A\", \"B\", \"C\"]\n        )\n\n        expected = 1\n        result = df.loc[0.5, \"A\"]\n        tm.assert_almost_equal(result, expected)\n\n        index = pd.interval_range(start=0, periods=3, closed=\"both\")\n        df = pd.DataFrame(\n            [[1, 2, 3], [4, 5, 6], [7, 8, 9]], index=index, columns=[\"A\", \"B\", \"C\"]\n        )\n\n        index_exp = pd.interval_range(start=0, periods=2, freq=1, closed=\"both\")\n        expected = pd.Series([1, 4], index=index_exp, name=\"A\")\n        result = df.loc[1, \"A\"]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 2189,
        "end_line": 2208,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexingUInt64.test_setitem#2212",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexingUInt64",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexingUInt64.test_setitem(self, uint64_frame)",
        "snippet": "    def test_setitem(self, uint64_frame):\n\n        df = uint64_frame\n        idx = df[\"A\"].rename(\"foo\")\n\n        # setitem\n        df[\"C\"] = idx\n        tm.assert_series_equal(df[\"C\"], Series(idx, name=\"C\"))\n\n        df[\"D\"] = \"foo\"\n        df[\"D\"] = idx\n        tm.assert_series_equal(df[\"D\"], Series(idx, name=\"D\"))\n        del df[\"D\"]\n\n        # With NaN: because uint64 has no NaN element,\n        # the column should be cast to object.\n        df2 = df.copy()\n        df2.iloc[1, 1] = pd.NaT\n        df2.iloc[1, 2] = pd.NaT\n        result = df2[\"B\"]\n        tm.assert_series_equal(notna(result), Series([True, False, True], name=\"B\"))\n        tm.assert_series_equal(\n            df2.dtypes,\n            Series(\n                [np.dtype(\"uint64\"), np.dtype(\"O\"), np.dtype(\"O\")],\n                index=[\"A\", \"B\", \"C\"],\n            ),\n        )",
        "begin_line": 2212,
        "end_line": 2239,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexingUInt64.test_set_reset#2241",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexingUInt64",
        "signature": "pandas.tests.frame.indexing.test_indexing.TestDataFrameIndexingUInt64.test_set_reset(self)",
        "snippet": "    def test_set_reset(self):\n\n        idx = Index([2 ** 63, 2 ** 63 + 5, 2 ** 63 + 10], name=\"foo\")\n\n        # set/reset\n        df = DataFrame({\"A\": [0, 1, 2]}, index=idx)\n        result = df.reset_index()\n        assert result[\"foo\"].dtype == np.dtype(\"uint64\")\n\n        df = result.set_index(\"foo\")\n        tm.assert_index_equal(df.index, idx)",
        "begin_line": 2241,
        "end_line": 2251,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.indexing.test_indexing.test_object_casting_indexing_wraps_datetimelike#2254",
        "src_path": "pandas/tests/frame/indexing/test_indexing.py",
        "class_name": "pandas.tests.frame.indexing.test_indexing",
        "signature": "pandas.tests.frame.indexing.test_indexing.test_object_casting_indexing_wraps_datetimelike()",
        "snippet": "def test_object_casting_indexing_wraps_datetimelike():\n    # GH#31649, check the indexing methods all the way down the stack\n    df = pd.DataFrame(\n        {\n            \"A\": [1, 2],\n            \"B\": pd.date_range(\"2000\", periods=2),\n            \"C\": pd.timedelta_range(\"1 Day\", periods=2),\n        }\n    )\n\n    ser = df.loc[0]\n    assert isinstance(ser.values[1], pd.Timestamp)\n    assert isinstance(ser.values[2], pd.Timedelta)\n\n    ser = df.iloc[0]\n    assert isinstance(ser.values[1], pd.Timestamp)\n    assert isinstance(ser.values[2], pd.Timedelta)\n\n    ser = df.xs(0, axis=0)\n    assert isinstance(ser.values[1], pd.Timestamp)\n    assert isinstance(ser.values[2], pd.Timedelta)\n\n    mgr = df._data\n    mgr._rebuild_blknos_and_blklocs()\n    arr = mgr.fast_xs(0)\n    assert isinstance(arr[1], pd.Timestamp)\n    assert isinstance(arr[2], pd.Timedelta)\n\n    blk = mgr.blocks[mgr.blknos[1]]\n    assert blk.dtype == \"M8[ns]\"  # we got the right block\n    val = blk.iget((0, 0))\n    assert isinstance(val, pd.Timestamp)\n\n    blk = mgr.blocks[mgr.blknos[2]]\n    assert blk.dtype == \"m8[ns]\"  # we got the right block\n    val = blk.iget((0, 0))\n    assert isinstance(val, pd.Timedelta)",
        "begin_line": 2254,
        "end_line": 2290,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.conftest.multiindex_dataframe_random_data#8",
        "src_path": "pandas/tests/indexing/multiindex/conftest.py",
        "class_name": "pandas.tests.indexing.multiindex.conftest",
        "signature": "pandas.tests.indexing.multiindex.conftest.multiindex_dataframe_random_data()",
        "snippet": "def multiindex_dataframe_random_data():\n    \"\"\"DataFrame with 2 level MultiIndex with random data\"\"\"\n    index = MultiIndex(\n        levels=[[\"foo\", \"bar\", \"baz\", \"qux\"], [\"one\", \"two\", \"three\"]],\n        codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],\n        names=[\"first\", \"second\"],\n    )\n    return DataFrame(\n        np.random.randn(10, 3), index=index, columns=Index([\"A\", \"B\", \"C\"], name=\"exp\")\n    )",
        "begin_line": 8,
        "end_line": 17,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common._mklbl#10",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common",
        "signature": "pandas.tests.indexing.common._mklbl(prefix, n)",
        "snippet": "def _mklbl(prefix, n):\n    return [f\"{prefix}{i}\" for i in range(n)]",
        "begin_line": 10,
        "end_line": 11,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common._axify#14",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common",
        "signature": "pandas.tests.indexing.common._axify(obj, key, axis)",
        "snippet": "def _axify(obj, key, axis):\n    # create a tuple accessor\n    axes = [slice(None)] * obj.ndim\n    axes[axis] = key\n    return tuple(axes)",
        "begin_line": 14,
        "end_line": 18,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.setup_method#37",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n\n        self.series_ints = Series(np.random.rand(4), index=np.arange(0, 8, 2))\n        self.frame_ints = DataFrame(\n            np.random.randn(4, 4), index=np.arange(0, 8, 2), columns=np.arange(0, 12, 3)\n        )\n\n        self.series_uints = Series(\n            np.random.rand(4), index=UInt64Index(np.arange(0, 8, 2))\n        )\n        self.frame_uints = DataFrame(\n            np.random.randn(4, 4),\n            index=UInt64Index(range(0, 8, 2)),\n            columns=UInt64Index(range(0, 12, 3)),\n        )\n\n        self.series_floats = Series(\n            np.random.rand(4), index=Float64Index(range(0, 8, 2))\n        )\n        self.frame_floats = DataFrame(\n            np.random.randn(4, 4),\n            index=Float64Index(range(0, 8, 2)),\n            columns=Float64Index(range(0, 12, 3)),\n        )\n\n        m_idces = [\n            MultiIndex.from_product([[1, 2], [3, 4]]),\n            MultiIndex.from_product([[5, 6], [7, 8]]),\n            MultiIndex.from_product([[9, 10], [11, 12]]),\n        ]\n\n        self.series_multi = Series(np.random.rand(4), index=m_idces[0])\n        self.frame_multi = DataFrame(\n            np.random.randn(4, 4), index=m_idces[0], columns=m_idces[1]\n        )\n\n        self.series_labels = Series(np.random.randn(4), index=list(\"abcd\"))\n        self.frame_labels = DataFrame(\n            np.random.randn(4, 4), index=list(\"abcd\"), columns=list(\"ABCD\")\n        )\n\n        self.series_mixed = Series(np.random.randn(4), index=[2, 4, \"null\", 8])\n        self.frame_mixed = DataFrame(np.random.randn(4, 4), index=[2, 4, \"null\", 8])\n\n        self.series_ts = Series(\n            np.random.randn(4), index=date_range(\"20130101\", periods=4)\n        )\n        self.frame_ts = DataFrame(\n            np.random.randn(4, 4), index=date_range(\"20130101\", periods=4)\n        )\n\n        dates_rev = date_range(\"20130101\", periods=4).sort_values(ascending=False)\n        self.series_ts_rev = Series(np.random.randn(4), index=dates_rev)\n        self.frame_ts_rev = DataFrame(np.random.randn(4, 4), index=dates_rev)\n\n        self.frame_empty = DataFrame()\n        self.series_empty = Series(dtype=object)\n\n        # form agglomerates\n        for kind in self._kinds:\n            d = dict()\n            for typ in self._typs:\n                d[typ] = getattr(self, f\"{kind}_{typ}\")\n\n            setattr(self, kind, d)",
        "begin_line": 37,
        "end_line": 101,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.generate_indices#103",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.generate_indices(self, f, values=False)",
        "snippet": "    def generate_indices(self, f, values=False):\n        \"\"\"\n        generate the indices\n        if values is True , use the axis values\n        is False, use the range\n        \"\"\"\n        axes = f.axes\n        if values:\n            axes = (list(range(len(ax))) for ax in axes)\n\n        return itertools.product(*axes)",
        "begin_line": 103,
        "end_line": 113,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.get_value#115",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.get_value(self, name, f, i, values=False)",
        "snippet": "    def get_value(self, name, f, i, values=False):\n        \"\"\" return the value for the location i \"\"\"\n        # check against values\n        if values:\n            return f.values[i]\n\n        elif name == \"iat\":\n            return f.iloc[i]\n        else:\n            assert name == \"at\"\n            return f.loc[i]",
        "begin_line": 115,
        "end_line": 125,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.check_values#127",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.check_values(self, f, func, values=False)",
        "snippet": "    def check_values(self, f, func, values=False):\n\n        if f is None:\n            return\n        axes = f.axes\n        indicies = itertools.product(*axes)\n\n        for i in indicies:\n            result = getattr(f, func)[i]\n\n            # check against values\n            if values:\n                expected = f.values[i]\n            else:\n                expected = f\n                for a in reversed(i):\n                    expected = expected.__getitem__(a)\n\n            tm.assert_almost_equal(result, expected)",
        "begin_line": 127,
        "end_line": 145,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.check_result#147",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.check_result(self, method, key, typs=None, axes=None, fails=None)",
        "snippet": "    def check_result(\n        self, method, key, typs=None, axes=None, fails=None,\n    ):\n        def _eq(axis, obj, key):\n            \"\"\" compare equal for these 2 keys \"\"\"\n            axified = _axify(obj, key, axis)\n            try:\n                getattr(obj, method).__getitem__(axified)\n\n            except (IndexError, TypeError, KeyError) as detail:\n\n                # if we are in fails, the ok, otherwise raise it\n                if fails is not None:\n                    if isinstance(detail, fails):\n                        return\n                raise\n\n        if typs is None:\n            typs = self._typs\n\n        if axes is None:\n            axes = [0, 1]\n        else:\n            assert axes in [0, 1]\n            axes = [axes]\n\n        # check\n        for kind in self._kinds:\n\n            d = getattr(self, kind)\n            for ax in axes:\n                for typ in typs:\n                    assert typ in self._typs\n\n                    obj = d[typ]\n                    if ax < obj.ndim:\n                        _eq(axis=ax, obj=obj, key=key)",
        "begin_line": 147,
        "end_line": 183,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base._eq#150",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base._eq(axis, obj, key)",
        "snippet": "        def _eq(axis, obj, key):\n            \"\"\" compare equal for these 2 keys \"\"\"\n            axified = _axify(obj, key, axis)\n            try:\n                getattr(obj, method).__getitem__(axified)\n\n            except (IndexError, TypeError, KeyError) as detail:\n\n                # if we are in fails, the ok, otherwise raise it\n                if fails is not None:\n                    if isinstance(detail, fails):\n                        return\n                raise",
        "begin_line": 150,
        "end_line": 162,
        "comment": "",
        "is_bug": false
    }
]