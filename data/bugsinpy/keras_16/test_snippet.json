[
    {
        "name": "tests.keras.backend.reference_operations.wrapper#13",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.wrapper(*args, **kwargs)",
        "snippet": "    def wrapper(*args, **kwargs):\n        x = args[0]\n        w = args[1]\n        if x.ndim == 3:\n            w = np.flipud(w)\n            w = np.transpose(w, (1, 2, 0))\n            if kwargs['data_format'] == 'channels_last':\n                x = np.transpose(x, (0, 2, 1))\n        elif x.ndim == 4:\n            w = np.fliplr(np.flipud(w))\n            w = np.transpose(w, (2, 3, 0, 1))\n            if kwargs['data_format'] == 'channels_last':\n                x = np.transpose(x, (0, 3, 1, 2))\n        else:\n            w = np.flip(np.fliplr(np.flipud(w)), axis=2)\n            w = np.transpose(w, (3, 4, 0, 1, 2))\n            if kwargs['data_format'] == 'channels_last':\n                x = np.transpose(x, (0, 4, 1, 2, 3))\n\n        y = func(x, w, **kwargs)\n\n        if kwargs['data_format'] == 'channels_last':\n            if y.ndim == 3:\n                y = np.transpose(y, (0, 2, 1))\n            elif y.ndim == 4:\n                y = np.transpose(y, (0, 2, 3, 1))\n            else:\n                y = np.transpose(y, (0, 2, 3, 4, 1))\n\n        return y",
        "begin_line": 13,
        "end_line": 42,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.conv#48",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.conv(x, w, padding, data_format)",
        "snippet": "def conv(x, w, padding, data_format):\n    y = []\n    for i in range(x.shape[0]):\n        _y = []\n        for j in range(w.shape[1]):\n            __y = []\n            for k in range(w.shape[0]):\n                __y.append(signal.convolve(x[i, k], w[k, j], mode=padding))\n            _y.append(np.sum(np.stack(__y, axis=-1), axis=-1))\n        y.append(_y)\n    y = np.array(y)\n    return y",
        "begin_line": 48,
        "end_line": 59,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.depthwise_conv#63",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.depthwise_conv(x, w, padding, data_format)",
        "snippet": "def depthwise_conv(x, w, padding, data_format):\n    y = []\n    for i in range(x.shape[0]):\n        _y = []\n        for j in range(w.shape[0]):\n            __y = []\n            for k in range(w.shape[1]):\n                __y.append(signal.convolve(x[i, j], w[j, k], mode=padding))\n            _y.append(np.stack(__y, axis=0))\n        y.append(np.concatenate(_y, axis=0))\n    y = np.array(y)\n    return y",
        "begin_line": 63,
        "end_line": 74,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.separable_conv#77",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.separable_conv(x, w1, w2, padding, data_format)",
        "snippet": "def separable_conv(x, w1, w2, padding, data_format):\n    x2 = depthwise_conv(x, w1, padding=padding, data_format=data_format)\n    return conv(x2, w2, padding=padding, data_format=data_format)",
        "begin_line": 77,
        "end_line": 79,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.pool#90",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.pool(x, pool_size, strides, padding, data_format, pool_mode)",
        "snippet": "def pool(x, pool_size, strides, padding, data_format, pool_mode):\n    if data_format == 'channels_last':\n        if x.ndim == 3:\n            x = np.transpose(x, (0, 2, 1))\n        elif x.ndim == 4:\n            x = np.transpose(x, (0, 3, 1, 2))\n        else:\n            x = np.transpose(x, (0, 4, 1, 2, 3))\n\n    if padding == 'same':\n        pad = [(0, 0), (0, 0)] + [(s // 2, s // 2) for s in pool_size]\n        x = np.pad(x, pad, 'constant', constant_values=-np.inf)\n\n    # indexing trick\n    x = np.pad(x, [(0, 0), (0, 0)] + [(0, 1) for _ in pool_size],\n               'constant', constant_values=0)\n\n    if x.ndim == 3:\n        y = [x[:, :, k:k1:strides[0]]\n             for (k, k1) in zip(range(pool_size[0]), range(-pool_size[0], 0))]\n    elif x.ndim == 4:\n        y = []\n        for (k, k1) in zip(range(pool_size[0]), range(-pool_size[0], 0)):\n            for (l, l1) in zip(range(pool_size[1]), range(-pool_size[1], 0)):\n                y.append(x[:, :, k:k1:strides[0], l:l1:strides[1]])\n    else:\n        y = []\n        for (k, k1) in zip(range(pool_size[0]), range(-pool_size[0], 0)):\n            for (l, l1) in zip(range(pool_size[1]), range(-pool_size[1], 0)):\n                for (m, m1) in zip(range(pool_size[2]), range(-pool_size[2], 0)):\n                    y.append(x[:,\n                               :,\n                               k:k1:strides[0],\n                               l:l1:strides[1],\n                               m:m1:strides[2]])\n    y = np.stack(y, axis=-1)\n    if pool_mode == 'avg':\n        y = np.mean(np.ma.masked_invalid(y), axis=-1).data\n    elif pool_mode == 'max':\n        y = np.max(y, axis=-1)\n\n    if data_format == 'channels_last':\n        if y.ndim == 3:\n            y = np.transpose(y, (0, 2, 1))\n        elif y.ndim == 4:\n            y = np.transpose(y, (0, 2, 3, 1))\n        else:\n            y = np.transpose(y, (0, 2, 3, 4, 1))\n\n    return y",
        "begin_line": 90,
        "end_line": 139,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.bias_add#146",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.bias_add(x, y, data_format)",
        "snippet": "def bias_add(x, y, data_format):\n    if data_format == 'channels_first':\n        if y.ndim > 1:\n            y = np.reshape(y, y.shape[::-1])\n        for _ in range(x.ndim - y.ndim - 1):\n            y = np.expand_dims(y, -1)\n    else:\n        for _ in range(x.ndim - y.ndim - 1):\n            y = np.expand_dims(y, 0)\n    return x + y",
        "begin_line": 146,
        "end_line": 155,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.rnn#158",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.rnn(x, w, init, go_backwards=False, mask=None, unroll=False, input_length=None)",
        "snippet": "def rnn(x, w, init, go_backwards=False, mask=None, unroll=False, input_length=None):\n    w_i, w_h, w_o = w\n    h = []\n    o = []\n\n    if go_backwards:\n        t_list = range(x.shape[1] - 1, -1, -1)\n    else:\n        t_list = range(x.shape[1])\n\n    if mask is not None:\n        from keras import backend as K\n        np_mask = K.eval(mask)\n    else:\n        np_mask = None\n\n    for (i, t) in enumerate(t_list):\n        h_t = np.dot(x[:, t], w_i)\n\n        if w_h is not None:\n            prev = h[i - 1] if i > 0 else init\n            h_t1 = np.dot(prev, w_h)\n            if np_mask is not None:\n                h_t1[np_mask[:, t] == 0] = prev[np_mask[:, t] == 0]\n        else:\n            h_t1 = 0\n\n        o_t = h_t + h_t1\n        if w_o is not None:\n            o_t = np.dot(o_t, w_o)\n        o.append(o_t)\n\n        if np_mask is not None:\n            h_t = h_t * np_mask[:, t].reshape(-1, 1)\n        h.append(h_t + h_t1)\n\n    return o[-1], np.stack(o, axis=1), np.stack(h, axis=1)",
        "begin_line": 158,
        "end_line": 194,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.in_train_phase#209",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.in_train_phase(x, alt, training=None)",
        "snippet": "def in_train_phase(x, alt, training=None):\n    if training is None:\n        training = learning_phase()\n\n    if training is 1 or training is True:\n        if callable(x):\n            return x()\n        else:\n            return x\n    else:\n        if callable(alt):\n            return alt()\n        else:\n            return alt",
        "begin_line": 209,
        "end_line": 222,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.in_test_phase#225",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.in_test_phase(x, alt, training=None)",
        "snippet": "def in_test_phase(x, alt, training=None):\n    return in_train_phase(alt, x, training=training)",
        "begin_line": 225,
        "end_line": 226,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.relu#229",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.relu(x, alpha=0.0, max_value=None)",
        "snippet": "def relu(x, alpha=0., max_value=None):\n    y = x * (x > 0) + alpha * x * (x < 0)\n    if max_value is not None:\n        y = np.minimum(y, max_value)\n    return y",
        "begin_line": 229,
        "end_line": 233,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.switch#236",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.switch(condition, then_expression, else_expression)",
        "snippet": "def switch(condition, then_expression, else_expression):\n    cond_float = condition.astype(floatx())\n    while cond_float.ndim < then_expression.ndim:\n        cond_float = cond_float[..., None]\n    return cond_float * then_expression + (1 - cond_float) * else_expression",
        "begin_line": 236,
        "end_line": 240,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.softplus#243",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.softplus(x)",
        "snippet": "def softplus(x):\n    return np.log(1. + np.exp(x))",
        "begin_line": 243,
        "end_line": 244,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.elu#247",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.elu(x, alpha=1.0)",
        "snippet": "def elu(x, alpha=1.):\n    return x * (x > 0) + alpha * (np.exp(x) - 1.) * (x < 0)",
        "begin_line": 247,
        "end_line": 248,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.sigmoid#251",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.sigmoid(x)",
        "snippet": "def sigmoid(x):\n    return 1. / (1. + np.exp(-x))",
        "begin_line": 251,
        "end_line": 252,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.hard_sigmoid#255",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.hard_sigmoid(x)",
        "snippet": "def hard_sigmoid(x):\n    y = 0.2 * x + 0.5\n    y = np.minimum(y, 1.)\n    y = np.maximum(y, 0.)\n    return y",
        "begin_line": 255,
        "end_line": 259,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.tanh#262",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.tanh(x)",
        "snippet": "def tanh(x):\n    return np.tanh(x)",
        "begin_line": 262,
        "end_line": 263,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.softmax#266",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.softmax(x, axis=-1)",
        "snippet": "def softmax(x, axis=-1):\n    y = np.exp(x - np.max(x, axis, keepdims=True))\n    return y / np.sum(y, axis, keepdims=True)",
        "begin_line": 266,
        "end_line": 268,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.l2_normalize#271",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.l2_normalize(x, axis=-1)",
        "snippet": "def l2_normalize(x, axis=-1):\n    y = np.max(np.sum(x ** 2, axis, keepdims=True), axis, keepdims=True)\n    return x / np.sqrt(y)",
        "begin_line": 271,
        "end_line": 273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.binary_crossentropy#276",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.binary_crossentropy(target, output, from_logits=False)",
        "snippet": "def binary_crossentropy(target, output, from_logits=False):\n    if not from_logits:\n        output = np.clip(output, 1e-7, 1 - 1e-7)\n        output = np.log(output / (1 - output))\n    return (target * -np.log(sigmoid(output)) +\n            (1 - target) * -np.log(1 - sigmoid(output)))",
        "begin_line": 276,
        "end_line": 281,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.categorical_crossentropy#284",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.categorical_crossentropy(target, output, from_logits=False)",
        "snippet": "def categorical_crossentropy(target, output, from_logits=False):\n    if from_logits:\n        output = softmax(output)\n    else:\n        output /= output.sum(axis=-1, keepdims=True)\n    output = np.clip(output, 1e-7, 1 - 1e-7)\n    return np.sum(target * -np.log(output), axis=-1, keepdims=False)",
        "begin_line": 284,
        "end_line": 290,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.max#293",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.max(x, axis=None, keepdims=False)",
        "snippet": "def max(x, axis=None, keepdims=False):\n    if isinstance(axis, list):\n        axis = tuple(axis)\n    return np.max(x, axis=axis, keepdims=keepdims)",
        "begin_line": 293,
        "end_line": 296,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.min#299",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.min(x, axis=None, keepdims=False)",
        "snippet": "def min(x, axis=None, keepdims=False):\n    if isinstance(axis, list):\n        axis = tuple(axis)\n    return np.min(x, axis=axis, keepdims=keepdims)",
        "begin_line": 299,
        "end_line": 302,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.mean#305",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.mean(x, axis=None, keepdims=False)",
        "snippet": "def mean(x, axis=None, keepdims=False):\n    if isinstance(axis, list):\n        axis = tuple(axis)\n    return np.mean(x, axis=axis, keepdims=keepdims)",
        "begin_line": 305,
        "end_line": 308,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.var#311",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.var(x, axis=None, keepdims=False)",
        "snippet": "def var(x, axis=None, keepdims=False):\n    if isinstance(axis, list):\n        axis = tuple(axis)\n    return np.var(x, axis=axis, keepdims=keepdims)",
        "begin_line": 311,
        "end_line": 314,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.std#317",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.std(x, axis=None, keepdims=False)",
        "snippet": "def std(x, axis=None, keepdims=False):\n    if isinstance(axis, list):\n        axis = tuple(axis)\n    return np.std(x, axis=axis, keepdims=keepdims)",
        "begin_line": 317,
        "end_line": 320,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.logsumexp#323",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.logsumexp(x, axis=None, keepdims=False)",
        "snippet": "def logsumexp(x, axis=None, keepdims=False):\n    if isinstance(axis, list):\n        axis = tuple(axis)\n    return sp.misc.logsumexp(x, axis=axis, keepdims=keepdims)",
        "begin_line": 323,
        "end_line": 326,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.cumsum#341",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.cumsum(x, axis=0)",
        "snippet": "def cumsum(x, axis=0):\n    return np.cumsum(x, axis=axis)",
        "begin_line": 341,
        "end_line": 342,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.cumprod#345",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.cumprod(x, axis=0)",
        "snippet": "def cumprod(x, axis=0):\n    return np.cumprod(x, axis=axis)",
        "begin_line": 345,
        "end_line": 346,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.concatenate#383",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.concatenate(tensors, axis=-1)",
        "snippet": "def concatenate(tensors, axis=-1):\n    return np.concatenate(tensors, axis)",
        "begin_line": 383,
        "end_line": 384,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.permute_dimensions#387",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.permute_dimensions(x, pattern)",
        "snippet": "def permute_dimensions(x, pattern):\n    return np.transpose(x, pattern)",
        "begin_line": 387,
        "end_line": 388,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.reshape#391",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.reshape(x, shape)",
        "snippet": "def reshape(x, shape):\n    return np.reshape(x, shape)",
        "begin_line": 391,
        "end_line": 392,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.repeat_elements#395",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.repeat_elements(x, rep, axis)",
        "snippet": "def repeat_elements(x, rep, axis):\n    return np.repeat(x, rep, axis=axis)",
        "begin_line": 395,
        "end_line": 396,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.repeat#399",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.repeat(x, n)",
        "snippet": "def repeat(x, n):\n    y = np.expand_dims(x, 1)\n    y = np.repeat(y, n, axis=1)\n    return y",
        "begin_line": 399,
        "end_line": 402,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.arange#405",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.arange(start, stop=None, step=1, dtype='int32')",
        "snippet": "def arange(start, stop=None, step=1, dtype='int32'):\n    return np.arange(start, stop, step, dtype)",
        "begin_line": 405,
        "end_line": 406,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.flatten#409",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.flatten(x)",
        "snippet": "def flatten(x):\n    return np.reshape(x, (-1,))",
        "begin_line": 409,
        "end_line": 410,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.batch_flatten#413",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.batch_flatten(x)",
        "snippet": "def batch_flatten(x):\n    return np.reshape(x, (x.shape[0], -1))",
        "begin_line": 413,
        "end_line": 414,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.eval#417",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.eval(x)",
        "snippet": "def eval(x):\n    return x",
        "begin_line": 417,
        "end_line": 418,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.dtype#421",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.dtype(x)",
        "snippet": "def dtype(x):\n    return x.dtype.name",
        "begin_line": 421,
        "end_line": 422,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.constant#425",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.constant(value, dtype=None, shape=None, name=None)",
        "snippet": "def constant(value, dtype=None, shape=None, name=None):\n    if dtype is None:\n        dtype = floatx()\n    if shape is None:\n        shape = ()\n    np_value = value * np.ones(shape)\n    np_value.astype(dtype)\n    return np_value",
        "begin_line": 425,
        "end_line": 432,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.print_tensor#435",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.print_tensor(x, message='')",
        "snippet": "def print_tensor(x, message=''):\n    print(x, message)\n    return x",
        "begin_line": 435,
        "end_line": 437,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.eye#440",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.eye(size, dtype=None, name=None)",
        "snippet": "def eye(size, dtype=None, name=None):\n    return np.eye(size, dtype=dtype)",
        "begin_line": 440,
        "end_line": 441,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.dot#444",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.dot(x, y)",
        "snippet": "def dot(x, y):\n    return np.dot(x, y)",
        "begin_line": 444,
        "end_line": 445,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.transpose#448",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.transpose(x)",
        "snippet": "def transpose(x):\n    return np.transpose(x)",
        "begin_line": 448,
        "end_line": 449,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.reverse#452",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.reverse(x, axes)",
        "snippet": "def reverse(x, axes):\n    if isinstance(axes, int):\n        axes = [axes]\n    for a in axes:\n        x = np.flip(x, a)\n    return x",
        "begin_line": 452,
        "end_line": 457,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.variable#460",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.variable(value, dtype=None, name=None, constraint=None)",
        "snippet": "def variable(value, dtype=None, name=None, constraint=None):\n    if constraint is not None:\n        raise TypeError(\"Constraint must be None when \"\n                        \"using the NumPy backend.\")\n    return np.array(value, dtype)",
        "begin_line": 460,
        "end_line": 464,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.greater_equal#479",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.greater_equal(x, y)",
        "snippet": "def greater_equal(x, y):\n    return x >= y",
        "begin_line": 479,
        "end_line": 480,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.random_uniform_variable#499",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.random_uniform_variable(shape, low, high, dtype=None, name=None, seed=None)",
        "snippet": "def random_uniform_variable(shape, low, high, dtype=None, name=None, seed=None):\n    return (high - low) * np.random.random(shape).astype(dtype) + low",
        "begin_line": 499,
        "end_line": 500,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.random_normal_variable#503",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.random_normal_variable(shape, mean, scale, dtype=None, name=None, seed=None)",
        "snippet": "def random_normal_variable(shape, mean, scale, dtype=None, name=None, seed=None):\n    return scale * np.random.randn(*shape).astype(dtype) + mean",
        "begin_line": 503,
        "end_line": 504,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.resize_images#507",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.resize_images(x, height_factor, width_factor, data_format)",
        "snippet": "def resize_images(x, height_factor, width_factor, data_format):\n    if data_format == 'channels_first':\n        x = repeat_elements(x, height_factor, axis=2)\n        x = repeat_elements(x, width_factor, axis=3)\n    elif data_format == 'channels_last':\n        x = repeat_elements(x, height_factor, axis=1)\n        x = repeat_elements(x, width_factor, axis=2)\n    return x",
        "begin_line": 507,
        "end_line": 514,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.resize_volumes#517",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.resize_volumes(x, depth_factor, height_factor, width_factor, data_format)",
        "snippet": "def resize_volumes(x, depth_factor, height_factor, width_factor, data_format):\n    if data_format == 'channels_first':\n        x = repeat_elements(x, depth_factor, axis=2)\n        x = repeat_elements(x, height_factor, axis=3)\n        x = repeat_elements(x, width_factor, axis=4)\n    elif data_format == 'channels_last':\n        x = repeat_elements(x, depth_factor, axis=1)\n        x = repeat_elements(x, height_factor, axis=2)\n        x = repeat_elements(x, width_factor, axis=3)\n    return x",
        "begin_line": 517,
        "end_line": 526,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.test_sequential_model.in_tmpdir#27",
        "src_path": "tests/keras/test_sequential_model.py",
        "class_name": "tests.keras.test_sequential_model",
        "signature": "tests.keras.test_sequential_model.in_tmpdir(tmpdir)",
        "snippet": "def in_tmpdir(tmpdir):\n    \"\"\"Runs a function in a temporary directory.\n\n    Checks that the directory is empty afterwards.\n    \"\"\"\n    with tmpdir.as_cwd():\n        yield None\n    assert not tmpdir.listdir()",
        "begin_line": 27,
        "end_line": 34,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.test_sequential_model.test_sequential_pop#38",
        "src_path": "tests/keras/test_sequential_model.py",
        "class_name": "tests.keras.test_sequential_model",
        "signature": "tests.keras.test_sequential_model.test_sequential_pop()",
        "snippet": "def test_sequential_pop():\n    model = Sequential()\n    model.add(Dense(num_hidden, input_dim=input_dim))\n    model.add(Dense(num_classes))\n    model.compile(loss='mse', optimizer='sgd')\n    x = np.random.random((batch_size, input_dim))\n    y = np.random.random((batch_size, num_classes))\n    model.fit(x, y, epochs=1)\n    model.pop()\n    assert len(model.layers) == 1\n    assert model.output_shape == (None, num_hidden)\n    model.compile(loss='mse', optimizer='sgd')\n    y = np.random.random((batch_size, num_hidden))\n    model.fit(x, y, epochs=1)",
        "begin_line": 38,
        "end_line": 51,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.test_sequential_model._get_test_data#54",
        "src_path": "tests/keras/test_sequential_model.py",
        "class_name": "tests.keras.test_sequential_model",
        "signature": "tests.keras.test_sequential_model._get_test_data()",
        "snippet": "def _get_test_data():\n    np.random.seed(1234)\n\n    train_samples = 100\n    test_samples = 50\n\n    (x_train, y_train), (x_test, y_test) = get_test_data(num_train=train_samples,\n                                                         num_test=test_samples,\n                                                         input_shape=(input_dim,),\n                                                         classification=True,\n                                                         num_classes=num_classes)\n    y_test = np_utils.to_categorical(y_test)\n    y_train = np_utils.to_categorical(y_train)\n    return (x_train, y_train), (x_test, y_test)",
        "begin_line": 54,
        "end_line": 67,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.test_sequential_model.test_sequential_fit_generator#71",
        "src_path": "tests/keras/test_sequential_model.py",
        "class_name": "tests.keras.test_sequential_model",
        "signature": "tests.keras.test_sequential_model.test_sequential_fit_generator()",
        "snippet": "def test_sequential_fit_generator():\n    (x_train, y_train), (x_test, y_test) = _get_test_data()\n\n    def data_generator(train):\n        if train:\n            max_batch_index = len(x_train) // batch_size\n        else:\n            max_batch_index = len(x_test) // batch_size\n        i = 0\n        while 1:\n            if train:\n                yield (x_train[i * batch_size: (i + 1) * batch_size],\n                       y_train[i * batch_size: (i + 1) * batch_size])\n            else:\n                yield (x_test[i * batch_size: (i + 1) * batch_size],\n                       y_test[i * batch_size: (i + 1) * batch_size])\n            i += 1\n            i = i % max_batch_index\n\n    model = Sequential()\n    model.add(Dense(num_hidden, input_shape=(input_dim,)))\n    model.add(Activation('relu'))\n    model.add(Dense(num_classes))\n    model.pop()\n    model.add(Dense(num_classes))\n    model.add(Activation('softmax'))\n    model.compile(loss='categorical_crossentropy', optimizer='rmsprop')\n\n    model.fit_generator(data_generator(True), 5, epochs)\n    model.fit_generator(data_generator(True), 5, epochs,\n                        validation_data=(x_test, y_test))\n    model.fit_generator(data_generator(True), 5, epochs,\n                        validation_data=data_generator(False),\n                        validation_steps=3)\n    model.fit_generator(data_generator(True), 5, epochs, max_queue_size=2)\n    model.evaluate(x_train, y_train)",
        "begin_line": 71,
        "end_line": 106,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.test_sequential_model.data_generator#74",
        "src_path": "tests/keras/test_sequential_model.py",
        "class_name": "tests.keras.test_sequential_model",
        "signature": "tests.keras.test_sequential_model.data_generator(train)",
        "snippet": "    def data_generator(train):\n        if train:\n            max_batch_index = len(x_train) // batch_size\n        else:\n            max_batch_index = len(x_test) // batch_size\n        i = 0\n        while 1:\n            if train:\n                yield (x_train[i * batch_size: (i + 1) * batch_size],\n                       y_train[i * batch_size: (i + 1) * batch_size])\n            else:\n                yield (x_test[i * batch_size: (i + 1) * batch_size],\n                       y_test[i * batch_size: (i + 1) * batch_size])\n            i += 1\n            i = i % max_batch_index",
        "begin_line": 74,
        "end_line": 88,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.test_sequential_model.test_sequential#110",
        "src_path": "tests/keras/test_sequential_model.py",
        "class_name": "tests.keras.test_sequential_model",
        "signature": "tests.keras.test_sequential_model.test_sequential(in_tmpdir)",
        "snippet": "def test_sequential(in_tmpdir):\n    (x_train, y_train), (x_test, y_test) = _get_test_data()\n\n    # TODO: factor out\n    def data_generator(x, y, batch_size=50):\n        index_array = np.arange(len(x))\n        while 1:\n            batches = make_batches(len(x_test), batch_size)\n            for batch_index, (batch_start, batch_end) in enumerate(batches):\n                batch_ids = index_array[batch_start:batch_end]\n                x_batch = x[batch_ids]\n                y_batch = y[batch_ids]\n                yield (x_batch, y_batch)\n\n    model = Sequential()\n    model.add(Dense(num_hidden, input_shape=(input_dim,)))\n    model.add(Activation('relu'))\n    model.add(Dense(num_classes))\n    model.add(Activation('softmax'))\n    model.compile(loss='categorical_crossentropy', optimizer='rmsprop')\n\n    model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=1,\n              validation_data=(x_test, y_test))\n    model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=2,\n              validation_split=0.1)\n    model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=0)\n    model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=1,\n              shuffle=False)\n\n    model.train_on_batch(x_train[:32], y_train[:32])\n\n    loss = model.evaluate(x_test, y_test)\n\n    prediction = model.predict_generator(data_generator(x_test, y_test), 1,\n                                         max_queue_size=2, verbose=1)\n    gen_loss = model.evaluate_generator(data_generator(x_test, y_test, 50), 1,\n                                        max_queue_size=2)\n    pred_loss = K.eval(K.mean(losses.get(model.loss)(K.variable(y_test),\n                                                     K.variable(prediction))))\n\n    assert(np.isclose(pred_loss, loss))\n    assert(np.isclose(gen_loss, loss))\n\n    model.predict(x_test, verbose=0)\n    model.predict_classes(x_test, verbose=0)\n    model.predict_proba(x_test, verbose=0)\n\n    fname = 'test_sequential_temp.h5'\n    model.save_weights(fname, overwrite=True)\n    model = Sequential()\n    model.add(Dense(num_hidden, input_shape=(input_dim,)))\n    model.add(Activation('relu'))\n    model.add(Dense(num_classes))\n    model.add(Activation('softmax'))\n    model.compile(loss='categorical_crossentropy', optimizer='rmsprop')\n    model.load_weights(fname)\n    os.remove(fname)\n\n    nloss = model.evaluate(x_test, y_test, verbose=0)\n    assert(loss == nloss)\n\n    # Test serialization\n    config = model.get_config()\n    assert 'name' in config\n    new_model = Sequential.from_config(config)\n    assert new_model.weights  # Model should be built.\n\n    model.summary()\n    json_str = model.to_json()\n    model_from_json(json_str)\n\n    yaml_str = model.to_yaml()\n    model_from_yaml(yaml_str)",
        "begin_line": 110,
        "end_line": 182,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.test_sequential_model.data_generator#114",
        "src_path": "tests/keras/test_sequential_model.py",
        "class_name": "tests.keras.test_sequential_model",
        "signature": "tests.keras.test_sequential_model.data_generator(x, y, batch_size=50)",
        "snippet": "    def data_generator(x, y, batch_size=50):\n        index_array = np.arange(len(x))\n        while 1:\n            batches = make_batches(len(x_test), batch_size)\n            for batch_index, (batch_start, batch_end) in enumerate(batches):\n                batch_ids = index_array[batch_start:batch_end]\n                x_batch = x[batch_ids]\n                y_batch = y[batch_ids]\n                yield (x_batch, y_batch)",
        "begin_line": 114,
        "end_line": 122,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.test_sequential_model.test_nested_sequential#186",
        "src_path": "tests/keras/test_sequential_model.py",
        "class_name": "tests.keras.test_sequential_model",
        "signature": "tests.keras.test_sequential_model.test_nested_sequential(in_tmpdir)",
        "snippet": "def test_nested_sequential(in_tmpdir):\n    (x_train, y_train), (x_test, y_test) = _get_test_data()\n\n    inner = Sequential()\n    inner.add(Dense(num_hidden, input_shape=(input_dim,)))\n    inner.add(Activation('relu'))\n    inner.add(Dense(num_classes))\n\n    middle = Sequential()\n    middle.add(inner)\n\n    model = Sequential()\n    model.add(middle)\n    model.add(Activation('softmax'))\n    model.compile(loss='categorical_crossentropy', optimizer='rmsprop')\n\n    model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=1,\n              validation_data=(x_test, y_test))\n    model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=2,\n              validation_split=0.1)\n    model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=0)\n    model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=1,\n              shuffle=False)\n\n    model.train_on_batch(x_train[:32], y_train[:32])\n\n    loss = model.evaluate(x_test, y_test, verbose=0)\n\n    model.predict(x_test, verbose=0)\n    model.predict_classes(x_test, verbose=0)\n    model.predict_proba(x_test, verbose=0)\n\n    fname = 'test_nested_sequential_temp.h5'\n    model.save_weights(fname, overwrite=True)\n\n    inner = Sequential()\n    inner.add(Dense(num_hidden, input_shape=(input_dim,)))\n    inner.add(Activation('relu'))\n    inner.add(Dense(num_classes))\n\n    middle = Sequential()\n    middle.add(inner)\n\n    model = Sequential()\n    model.add(middle)\n    model.add(Activation('softmax'))\n    model.compile(loss='categorical_crossentropy', optimizer='rmsprop')\n    model.load_weights(fname)\n    os.remove(fname)\n\n    nloss = model.evaluate(x_test, y_test, verbose=0)\n    assert(loss == nloss)\n\n    # Test serialization\n    config = model.get_config()\n    Sequential.from_config(config)\n\n    model.summary()\n    json_str = model.to_json()\n    model_from_json(json_str)\n\n    yaml_str = model.to_yaml()\n    model_from_yaml(yaml_str)",
        "begin_line": 186,
        "end_line": 248,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.test_sequential_model.test_sequential_count_params#252",
        "src_path": "tests/keras/test_sequential_model.py",
        "class_name": "tests.keras.test_sequential_model",
        "signature": "tests.keras.test_sequential_model.test_sequential_count_params()",
        "snippet": "def test_sequential_count_params():\n    input_dim = 20\n    num_units = 10\n    num_classes = 2\n\n    n = input_dim * num_units + num_units\n    n += num_units * num_units + num_units\n    n += num_units * num_classes + num_classes\n\n    model = Sequential()\n    model.add(Dense(num_units, input_shape=(input_dim,)))\n    model.add(Dense(num_units))\n    model.add(Dense(num_classes))\n    model.add(Activation('softmax'))\n    model.build()\n\n    assert(n == model.count_params())\n\n    model.compile('sgd', 'binary_crossentropy')\n    assert(n == model.count_params())",
        "begin_line": 252,
        "end_line": 271,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.test_sequential_model.test_nested_sequential_trainability#275",
        "src_path": "tests/keras/test_sequential_model.py",
        "class_name": "tests.keras.test_sequential_model",
        "signature": "tests.keras.test_sequential_model.test_nested_sequential_trainability()",
        "snippet": "def test_nested_sequential_trainability():\n    input_dim = 20\n    num_units = 10\n    num_classes = 2\n\n    inner_model = Sequential()\n    inner_model.add(Dense(num_units, input_shape=(input_dim,)))\n\n    model = Sequential()\n    model.add(inner_model)\n    model.add(Dense(num_classes))\n\n    assert len(model.trainable_weights) == 4\n    inner_model.trainable = False\n    assert len(model.trainable_weights) == 2\n    inner_model.trainable = True\n    assert len(model.trainable_weights) == 4",
        "begin_line": 275,
        "end_line": 291,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.test_sequential_model.test_rebuild_model#295",
        "src_path": "tests/keras/test_sequential_model.py",
        "class_name": "tests.keras.test_sequential_model",
        "signature": "tests.keras.test_sequential_model.test_rebuild_model()",
        "snippet": "def test_rebuild_model():\n    model = Sequential()\n    model.add(Dense(128, input_shape=(784,)))\n    model.add(Dense(64))\n    assert(model.get_layer(index=-1).output_shape == (None, 64))\n\n    model.add(Dense(32))\n    assert(model.get_layer(index=-1).output_shape == (None, 32))",
        "begin_line": 295,
        "end_line": 302,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.test_sequential_model.test_clone_functional_model#306",
        "src_path": "tests/keras/test_sequential_model.py",
        "class_name": "tests.keras.test_sequential_model",
        "signature": "tests.keras.test_sequential_model.test_clone_functional_model()",
        "snippet": "def test_clone_functional_model():\n    val_a = np.random.random((10, 4))\n    val_b = np.random.random((10, 4))\n    val_out = np.random.random((10, 4))\n\n    input_a = keras.Input(shape=(4,))\n    input_b = keras.Input(shape=(4,))\n    dense_1 = keras.layers.Dense(4)\n    dense_2 = keras.layers.Dense(4)\n\n    x_a = dense_1(input_a)\n    x_a = keras.layers.Dropout(0.5)(x_a)\n    x_a = keras.layers.BatchNormalization()(x_a)\n    x_b = dense_1(input_b)\n    x_a = dense_2(x_a)\n    outputs = keras.layers.add([x_a, x_b])\n    model = keras.models.Model([input_a, input_b], outputs)\n\n    if K.backend() == 'tensorflow':\n        # Everything should work in a new session.\n        K.clear_session()\n\n    # With placeholder creation\n    new_model = keras.models.clone_model(model)\n    new_model.compile('rmsprop', 'mse')\n    new_model.train_on_batch([val_a, val_b], val_out)\n\n    # On top of new tensors\n    input_a = keras.Input(shape=(4,), name='a')\n    input_b = keras.Input(shape=(4,), name='b')\n    new_model = keras.models.clone_model(\n        model, input_tensors=[input_a, input_b])\n    new_model.compile('rmsprop', 'mse')\n    new_model.train_on_batch([val_a, val_b], val_out)\n\n    # On top of new, non-Keras tensors\n    input_a = keras.backend.variable(val_a)\n    input_b = keras.backend.variable(val_b)\n    new_model = keras.models.clone_model(\n        model, input_tensors=[input_a, input_b])\n    new_model.compile('rmsprop', 'mse')\n    new_model.train_on_batch(None, val_out)",
        "begin_line": 306,
        "end_line": 347,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.test_sequential_model.test_clone_sequential_model#351",
        "src_path": "tests/keras/test_sequential_model.py",
        "class_name": "tests.keras.test_sequential_model",
        "signature": "tests.keras.test_sequential_model.test_clone_sequential_model()",
        "snippet": "def test_clone_sequential_model():\n    val_a = np.random.random((10, 4))\n    val_out = np.random.random((10, 4))\n\n    model = keras.models.Sequential()\n    model.add(keras.layers.Dense(4, input_shape=(4,)))\n    model.add(keras.layers.BatchNormalization())\n    model.add(keras.layers.Dropout(0.5))\n    model.add(keras.layers.Dense(4))\n\n    if K.backend() == 'tensorflow':\n        # Everything should work in a new session.\n        K.clear_session()\n\n    # With placeholder creation\n    new_model = keras.models.clone_model(model)\n    new_model.compile('rmsprop', 'mse')\n    new_model.train_on_batch(val_a, val_out)\n\n    # On top of new tensor\n    input_a = keras.Input(shape=(4,))\n    new_model = keras.models.clone_model(\n        model, input_tensors=input_a)\n    new_model.compile('rmsprop', 'mse')\n    new_model.train_on_batch(val_a, val_out)\n\n    # On top of new, non-Keras tensor\n    input_a = keras.backend.variable(val_a)\n    new_model = keras.models.clone_model(\n        model, input_tensors=input_a)\n    new_model.compile('rmsprop', 'mse')\n    new_model.train_on_batch(None, val_out)",
        "begin_line": 351,
        "end_line": 382,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.test_sequential_model.test_sequential_update_disabling#386",
        "src_path": "tests/keras/test_sequential_model.py",
        "class_name": "tests.keras.test_sequential_model",
        "signature": "tests.keras.test_sequential_model.test_sequential_update_disabling()",
        "snippet": "def test_sequential_update_disabling():\n    val_a = np.random.random((10, 4))\n    val_out = np.random.random((10, 4))\n\n    model = keras.models.Sequential()\n    model.add(keras.layers.BatchNormalization(input_shape=(4,)))\n\n    model.trainable = False\n    assert not model.updates\n\n    model.compile('sgd', 'mse')\n    assert not model.updates\n\n    x1 = model.predict(val_a)\n    model.train_on_batch(val_a, val_out)\n    x2 = model.predict(val_a)\n    assert_allclose(x1, x2, atol=1e-7)\n\n    model.trainable = True\n    model.compile('sgd', 'mse')\n    assert model.updates\n\n    model.train_on_batch(val_a, val_out)\n    x2 = model.predict(val_a)\n    assert np.abs(np.sum(x1 - x2)) > 1e-5",
        "begin_line": 386,
        "end_line": 410,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.test_sequential_model.test_sequential_deferred_build#414",
        "src_path": "tests/keras/test_sequential_model.py",
        "class_name": "tests.keras.test_sequential_model",
        "signature": "tests.keras.test_sequential_model.test_sequential_deferred_build()",
        "snippet": "def test_sequential_deferred_build():\n    model = keras.models.Sequential()\n    model.add(keras.layers.Dense(3))\n    model.add(keras.layers.Dense(3))\n    model.compile('sgd', 'mse')\n\n    assert model.built is False\n    assert len(model.layers) == 2\n    assert len(model.weights) == 0\n\n    model.train_on_batch(\n        np.random.random((2, 4)), np.random.random((2, 3)))\n\n    assert model.built is True\n    assert len(model.layers) == 2\n    assert len(model.weights) == 4\n\n    # Test serialization\n    config = model.get_config()\n    assert 'name' in config\n    new_model = Sequential.from_config(config)\n    assert new_model.built is True\n    assert len(new_model.layers) == 2\n    assert len(new_model.weights) == 4",
        "begin_line": 414,
        "end_line": 437,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.test_sequential_model.test_nested_sequential_deferred_build#441",
        "src_path": "tests/keras/test_sequential_model.py",
        "class_name": "tests.keras.test_sequential_model",
        "signature": "tests.keras.test_sequential_model.test_nested_sequential_deferred_build()",
        "snippet": "def test_nested_sequential_deferred_build():\n    inner_model = keras.models.Sequential()\n    inner_model.add(keras.layers.Dense(3))\n    inner_model.add(keras.layers.Dense(3))\n\n    model = keras.models.Sequential()\n    model.add(inner_model)\n    model.add(keras.layers.Dense(5))\n    model.compile('sgd', 'mse')\n\n    assert inner_model.built is False\n    assert len(inner_model.layers) == 2\n    assert len(inner_model.weights) == 0\n    assert model.built is False\n    assert len(model.layers) == 2\n    assert len(model.weights) == 0\n\n    model.train_on_batch(\n        np.random.random((2, 4)), np.random.random((2, 5)))\n\n    assert inner_model.built is True\n    assert len(inner_model.layers) == 2\n    assert len(inner_model.weights) == 4\n    assert model.built is True\n    assert len(model.layers) == 2\n    assert len(model.weights) == 6\n\n    config = model.get_config()\n    new_model = keras.models.Sequential.from_config(config)\n    assert new_model.built is True\n    assert len(new_model.layers) == 2\n    assert len(new_model.weights) == 6\n\n    new_inner_model = new_model.layers[0]\n    assert new_inner_model.built is True\n    assert len(new_inner_model.layers) == 2\n    assert len(new_inner_model.weights) == 4",
        "begin_line": 441,
        "end_line": 477,
        "comment": "",
        "is_bug": false
    }
]