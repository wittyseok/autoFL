[
    {
        "name": "tqdm.contrib.__init__.DummyTqdmFile.write#7",
        "src_path": "tqdm/contrib/__init__.py",
        "class_name": "tqdm.contrib.__init__.DummyTqdmFile",
        "signature": "tqdm.contrib.__init__.DummyTqdmFile.write(self, x, nolock=False)",
        "snippet": "    def write(self, x, nolock=False):\n        # Avoid print() second call (useless \\n)\n        if len(x.rstrip()) > 0:\n            tqdm.write(x, file=self._wrapped, nolock=nolock)",
        "begin_line": 7,
        "end_line": 10,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils.FormatReplace.__init__#135",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils.FormatReplace",
        "signature": "tqdm.utils.FormatReplace.__init__(self, replace='')",
        "snippet": "    def __init__(self, replace=''):\n        self.replace = replace\n        self.format_called = 0",
        "begin_line": 135,
        "end_line": 137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.022727272727272728,
            "pseudo_dstar_susp": 0.05,
            "pseudo_tarantula_susp": 0.0026954177897574125,
            "pseudo_op2_susp": 0.05,
            "pseudo_barinel_susp": 0.0026954177897574125
        }
    },
    {
        "name": "tqdm.utils.FormatReplace.__format__#139",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils.FormatReplace",
        "signature": "tqdm.utils.FormatReplace.__format__(self, _)",
        "snippet": "    def __format__(self, _):\n        self.format_called += 1\n        return self.replace",
        "begin_line": 139,
        "end_line": 141,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.3333333333333333,
            "pseudo_dstar_susp": 0.058823529411764705,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.058823529411764705,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils.Comparable.__lt__#146",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils.Comparable",
        "signature": "tqdm.utils.Comparable.__lt__(self, other)",
        "snippet": "    def __lt__(self, other):\n        return self._comparable < other._comparable",
        "begin_line": 146,
        "end_line": 147,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils.Comparable.__le__#149",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils.Comparable",
        "signature": "tqdm.utils.Comparable.__le__(self, other)",
        "snippet": "    def __le__(self, other):\n        return (self < other) or (self == other)",
        "begin_line": 149,
        "end_line": 150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils.Comparable.__eq__#152",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils.Comparable",
        "signature": "tqdm.utils.Comparable.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        return self._comparable == other._comparable",
        "begin_line": 152,
        "end_line": 153,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001466275659824047,
            "pseudo_dstar_susp": 0.0034129692832764505,
            "pseudo_tarantula_susp": 0.0012690355329949238,
            "pseudo_op2_susp": 0.0034129692832764505,
            "pseudo_barinel_susp": 0.0012690355329949238
        }
    },
    {
        "name": "tqdm.utils.Comparable.__ne__#155",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils.Comparable",
        "signature": "tqdm.utils.Comparable.__ne__(self, other)",
        "snippet": "    def __ne__(self, other):\n        return not self == other",
        "begin_line": 155,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils.Comparable.__gt__#158",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils.Comparable",
        "signature": "tqdm.utils.Comparable.__gt__(self, other)",
        "snippet": "    def __gt__(self, other):\n        return not self <= other",
        "begin_line": 158,
        "end_line": 159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils.Comparable.__ge__#161",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils.Comparable",
        "signature": "tqdm.utils.Comparable.__ge__(self, other)",
        "snippet": "    def __ge__(self, other):\n        return not self < other",
        "begin_line": 161,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils.ObjectWrapper.__getattr__#166",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils.ObjectWrapper",
        "signature": "tqdm.utils.ObjectWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        return getattr(self._wrapped, name)",
        "begin_line": 166,
        "end_line": 167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0034965034965034965,
            "pseudo_dstar_susp": 0.003389830508474576,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.003389830508474576,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils.ObjectWrapper.__setattr__#169",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils.ObjectWrapper",
        "signature": "tqdm.utils.ObjectWrapper.__setattr__(self, name, value)",
        "snippet": "    def __setattr__(self, name, value):\n        return setattr(self._wrapped, name, value)",
        "begin_line": 169,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils.ObjectWrapper.wrapper_getattr#172",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils.ObjectWrapper",
        "signature": "tqdm.utils.ObjectWrapper.wrapper_getattr(self, name)",
        "snippet": "    def wrapper_getattr(self, name):\n        \"\"\"Actual `self.getattr` rather than self._wrapped.getattr\"\"\"\n        try:\n            return object.__getattr__(self, name)\n        except AttributeError:  # py2\n            return getattr(self, name)",
        "begin_line": 172,
        "end_line": 177,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002967359050445104,
            "pseudo_dstar_susp": 0.00267379679144385,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.00267379679144385,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils.ObjectWrapper.wrapper_setattr#179",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils.ObjectWrapper",
        "signature": "tqdm.utils.ObjectWrapper.wrapper_setattr(self, name, value)",
        "snippet": "    def wrapper_setattr(self, name, value):\n        \"\"\"Actual `self.setattr` rather than self._wrapped.setattr\"\"\"\n        return object.__setattr__(self, name, value)",
        "begin_line": 179,
        "end_line": 181,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0033444816053511705,
            "pseudo_dstar_susp": 0.003257328990228013,
            "pseudo_tarantula_susp": 0.001841620626151013,
            "pseudo_op2_susp": 0.003257328990228013,
            "pseudo_barinel_susp": 0.0018450184501845018
        }
    },
    {
        "name": "tqdm.utils.ObjectWrapper.__init__#183",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils.ObjectWrapper",
        "signature": "tqdm.utils.ObjectWrapper.__init__(self, wrapped)",
        "snippet": "    def __init__(self, wrapped):\n        \"\"\"\n        Thin wrapper around a given object\n        \"\"\"\n        self.wrapper_setattr('_wrapped', wrapped)",
        "begin_line": 183,
        "end_line": 187,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0033444816053511705,
            "pseudo_dstar_susp": 0.003257328990228013,
            "pseudo_tarantula_susp": 0.001841620626151013,
            "pseudo_op2_susp": 0.003257328990228013,
            "pseudo_barinel_susp": 0.0018450184501845018
        }
    },
    {
        "name": "tqdm.utils.SimpleTextIOWrapper.__init__#196",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils.SimpleTextIOWrapper",
        "signature": "tqdm.utils.SimpleTextIOWrapper.__init__(self, wrapped, encoding)",
        "snippet": "    def __init__(self, wrapped, encoding):\n        super(SimpleTextIOWrapper, self).__init__(wrapped)\n        self.wrapper_setattr('encoding', encoding)",
        "begin_line": 196,
        "end_line": 198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002967359050445104,
            "pseudo_dstar_susp": 0.00267379679144385,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.00267379679144385,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils.SimpleTextIOWrapper.write#200",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils.SimpleTextIOWrapper",
        "signature": "tqdm.utils.SimpleTextIOWrapper.write(self, s)",
        "snippet": "    def write(self, s):\n        \"\"\"\n        Encode `s` and pass to the wrapped object's `.write()` method.\n        \"\"\"\n        return self._wrapped.write(s.encode(self.wrapper_getattr('encoding')))",
        "begin_line": 200,
        "end_line": 204,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002967359050445104,
            "pseudo_dstar_susp": 0.00267379679144385,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.00267379679144385,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils.CallbackIOWrapper.__init__#208",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils.CallbackIOWrapper",
        "signature": "tqdm.utils.CallbackIOWrapper.__init__(self, callback, stream, method='read')",
        "snippet": "    def __init__(self, callback, stream, method=\"read\"):\n        \"\"\"\n        Wrap a given `file`-like object's `read()` or `write()` to report\n        lengths to the given `callback`\n        \"\"\"\n        super(CallbackIOWrapper, self).__init__(stream)\n        func = getattr(stream, method)\n        if method == \"write\":\n            @wraps(func)\n            def write(data, *args, **kwargs):\n                res = func(data, *args, **kwargs)\n                callback(len(data))\n                return res\n            self.wrapper_setattr('write', write)\n        elif method == \"read\":\n            @wraps(func)\n            def read(*args, **kwargs):\n                data = func(*args, **kwargs)\n                callback(len(data))\n                return data\n            self.wrapper_setattr('read', read)\n        else:\n            raise KeyError(\"Can only wrap read/write methods\")",
        "begin_line": 208,
        "end_line": 230,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013908205841446453,
            "pseudo_dstar_susp": 0.0013831258644536654,
            "pseudo_tarantula_susp": 0.0014903129657228018,
            "pseudo_op2_susp": 0.0013831258644536654,
            "pseudo_barinel_susp": 0.001483679525222552
        }
    },
    {
        "name": "tqdm.utils.CallbackIOWrapper.write#217",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils.CallbackIOWrapper",
        "signature": "tqdm.utils.CallbackIOWrapper.write(data, *args, **kwargs)",
        "snippet": "            def write(data, *args, **kwargs):\n                res = func(data, *args, **kwargs)\n                callback(len(data))\n                return res",
        "begin_line": 217,
        "end_line": 220,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011534025374855825,
            "pseudo_dstar_susp": 0.0011534025374855825,
            "pseudo_tarantula_susp": 0.0011534025374855825,
            "pseudo_op2_susp": 0.0011750881316098707,
            "pseudo_barinel_susp": 0.0011534025374855825
        }
    },
    {
        "name": "tqdm.utils._is_utf#233",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils",
        "signature": "tqdm.utils._is_utf(encoding)",
        "snippet": "def _is_utf(encoding):\n    try:\n        u'\\u2588\\u2589'.encode(encoding)\n    except UnicodeEncodeError:  # pragma: no cover\n        return False\n    except Exception:  # pragma: no cover\n        try:\n            return encoding.lower().startswith('utf-') or ('U8' == encoding)\n        except:\n            return False\n    else:\n        return True",
        "begin_line": 233,
        "end_line": 244,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005494505494505495,
            "pseudo_dstar_susp": 0.004878048780487805,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.004878048780487805,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils._supports_unicode#247",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils",
        "signature": "tqdm.utils._supports_unicode(fp)",
        "snippet": "def _supports_unicode(fp):\n    try:\n        return _is_utf(fp.encoding)\n    except AttributeError:\n        return False",
        "begin_line": 247,
        "end_line": 251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006756756756756757,
            "pseudo_dstar_susp": 0.006535947712418301,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.006535947712418301,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils._is_ascii#254",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils",
        "signature": "tqdm.utils._is_ascii(s)",
        "snippet": "def _is_ascii(s):\n    if isinstance(s, str):\n        for c in s:\n            if ord(c) > 255:\n                return False\n        return True\n    return _supports_unicode(s)",
        "begin_line": 254,
        "end_line": 260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.125,
            "pseudo_dstar_susp": 0.01694915254237288,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.01694915254237288,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils._environ_cols_wrapper#263",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils",
        "signature": "tqdm.utils._environ_cols_wrapper()",
        "snippet": "def _environ_cols_wrapper():  # pragma: no cover\n    \"\"\"\n    Return a function which gets width and height of console\n    (linux,osx,windows,cygwin).\n    \"\"\"\n    _environ_cols = None\n    if IS_WIN:\n        _environ_cols = _environ_cols_windows\n        if _environ_cols is None:\n            _environ_cols = _environ_cols_tput\n    if IS_NIX:\n        _environ_cols = _environ_cols_linux\n    return _environ_cols",
        "begin_line": 263,
        "end_line": 275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035335689045936395,
            "pseudo_dstar_susp": 0.0035087719298245615,
            "pseudo_tarantula_susp": 0.001937984496124031,
            "pseudo_op2_susp": 0.0035087719298245615,
            "pseudo_barinel_susp": 0.0019267822736030828
        }
    },
    {
        "name": "tqdm.utils._environ_cols_windows#278",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils",
        "signature": "tqdm.utils._environ_cols_windows(fp)",
        "snippet": "def _environ_cols_windows(fp):  # pragma: no cover\n    try:\n        from ctypes import windll, create_string_buffer\n        import struct\n        from sys import stdin, stdout\n\n        io_handle = -12  # assume stderr\n        if fp == stdin:\n            io_handle = -10\n        elif fp == stdout:\n            io_handle = -11\n\n        h = windll.kernel32.GetStdHandle(io_handle)\n        csbi = create_string_buffer(22)\n        res = windll.kernel32.GetConsoleScreenBufferInfo(h, csbi)\n        if res:\n            (_bufx, _bufy, _curx, _cury, _wattr, left, _top, right, _bottom,\n             _maxx, _maxy) = struct.unpack(\"hhhhHhhhhhh\", csbi.raw)\n            # nlines = bottom - top + 1\n            return right - left  # +1\n    except:\n        pass\n    return None",
        "begin_line": 278,
        "end_line": 300,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils._environ_cols_tput#303",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils",
        "signature": "tqdm.utils._environ_cols_tput(*_)",
        "snippet": "def _environ_cols_tput(*_):  # pragma: no cover\n    \"\"\"cygwin xterm (windows)\"\"\"\n    try:\n        import shlex\n        cols = int(subprocess.check_call(shlex.split('tput cols')))\n        # rows = int(subprocess.check_call(shlex.split('tput lines')))\n        return cols\n    except:\n        pass\n    return None",
        "begin_line": 303,
        "end_line": 312,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils._environ_cols_linux#315",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils",
        "signature": "tqdm.utils._environ_cols_linux(fp)",
        "snippet": "def _environ_cols_linux(fp):  # pragma: no cover\n\n    try:\n        from termios import TIOCGWINSZ\n        from fcntl import ioctl\n        from array import array\n    except ImportError:\n        return None\n    else:\n        try:\n            return array('h', ioctl(fp, TIOCGWINSZ, '\\0' * 8))[1]\n        except:\n            try:\n                return int(os.environ[\"COLUMNS\"]) - 1\n            except KeyError:\n                return None",
        "begin_line": 315,
        "end_line": 330,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035335689045936395,
            "pseudo_dstar_susp": 0.0035087719298245615,
            "pseudo_tarantula_susp": 0.001937984496124031,
            "pseudo_op2_susp": 0.0035087719298245615,
            "pseudo_barinel_susp": 0.0019267822736030828
        }
    },
    {
        "name": "tqdm.utils._term_move_up#333",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils",
        "signature": "tqdm.utils._term_move_up()",
        "snippet": "def _term_move_up():  # pragma: no cover\n    return '' if (os.name == 'nt') and (colorama is None) else '\\x1b[A'",
        "begin_line": 333,
        "end_line": 334,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001443001443001443,
            "pseudo_dstar_susp": 0.0023752969121140144,
            "pseudo_tarantula_susp": 0.0014144271570014145,
            "pseudo_op2_susp": 0.0023752969121140144,
            "pseudo_barinel_susp": 0.0014144271570014145
        }
    },
    {
        "name": "tqdm.utils._text_width#343",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils",
        "signature": "tqdm.utils._text_width(s)",
        "snippet": "    def _text_width(s):\n        return sum(\n            2 if east_asian_width(ch) in 'FW' else 1 for ch in _unicode(s))",
        "begin_line": 343,
        "end_line": 345,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002967359050445104,
            "pseudo_dstar_susp": 0.00267379679144385,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.00267379679144385,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils.disp_len#348",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils",
        "signature": "tqdm.utils.disp_len(data)",
        "snippet": "def disp_len(data):\n    \"\"\"\n    Returns the real on-screen length of a string which may contain\n    ANSI control codes and wide chars.\n    \"\"\"\n    return _text_width(RE_ANSI.sub('', data))",
        "begin_line": 348,
        "end_line": 353,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002967359050445104,
            "pseudo_dstar_susp": 0.00267379679144385,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.00267379679144385,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.utils.disp_trim#356",
        "src_path": "tqdm/utils.py",
        "class_name": "tqdm.utils",
        "signature": "tqdm.utils.disp_trim(data, length)",
        "snippet": "def disp_trim(data, length):\n    \"\"\"\n    Trim a string which may contain ANSI control characters.\n    \"\"\"\n    if len(data) == disp_len(data):\n        return data[:length]\n\n    while disp_len(data) > length:  # carefully delete one char at a time\n        data = data[:-1]\n    if RE_ANSI.search(data):  # assume ANSI reset is required\n        return data + \"\\033[0m\"\n    return data",
        "begin_line": 356,
        "end_line": 367,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.002967359050445104,
            "pseudo_dstar_susp": 0.00267379679144385,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.00267379679144385,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm._monitor.TMonitor.__init__#32",
        "src_path": "tqdm/_monitor.py",
        "class_name": "tqdm._monitor.TMonitor",
        "signature": "tqdm._monitor.TMonitor.__init__(self, tqdm_cls, sleep_interval)",
        "snippet": "    def __init__(self, tqdm_cls, sleep_interval):\n        Thread.__init__(self)\n        self.daemon = True  # kill thread when main killed (KeyboardInterrupt)\n        self.was_killed = Event()\n        self.woken = 0  # last time woken up, to sync with monitor\n        self.tqdm_cls = tqdm_cls\n        self.sleep_interval = sleep_interval\n        if TMonitor._time is not None:\n            self._time = TMonitor._time\n        else:\n            self._time = time\n        if TMonitor._event is not None:\n            self._event = TMonitor._event\n        else:\n            self._event = Event\n        atexit.register(self.exit)\n        self.start()",
        "begin_line": 32,
        "end_line": 48,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004081632653061225,
            "pseudo_dstar_susp": 0.004132231404958678,
            "pseudo_tarantula_susp": 0.0016722408026755853,
            "pseudo_op2_susp": 0.004132231404958678,
            "pseudo_barinel_susp": 0.0016722408026755853
        }
    },
    {
        "name": "tqdm._monitor.TMonitor.exit#50",
        "src_path": "tqdm/_monitor.py",
        "class_name": "tqdm._monitor.TMonitor",
        "signature": "tqdm._monitor.TMonitor.exit(self)",
        "snippet": "    def exit(self):\n        self.was_killed.set()\n        if self is not current_thread():\n            self.join()\n        return self.report()",
        "begin_line": 50,
        "end_line": 54,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003816793893129771,
            "pseudo_dstar_susp": 0.003861003861003861,
            "pseudo_tarantula_susp": 0.0016750418760469012,
            "pseudo_op2_susp": 0.003861003861003861,
            "pseudo_barinel_susp": 0.0016750418760469012
        }
    },
    {
        "name": "tqdm._monitor.TMonitor.get_instances#56",
        "src_path": "tqdm/_monitor.py",
        "class_name": "tqdm._monitor.TMonitor",
        "signature": "tqdm._monitor.TMonitor.get_instances(self)",
        "snippet": "    def get_instances(self):\n        # returns a copy of started `tqdm_cls` instances\n        return [i for i in self.tqdm_cls._instances.copy()\n                # Avoid race by checking that the instance started\n                if hasattr(i, 'start_t')]",
        "begin_line": 56,
        "end_line": 60,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm._monitor.TMonitor.run#62",
        "src_path": "tqdm/_monitor.py",
        "class_name": "tqdm._monitor.TMonitor",
        "signature": "tqdm._monitor.TMonitor.run(self)",
        "snippet": "    def run(self):\n        cur_t = self._time()\n        while True:\n            # After processing and before sleeping, notify that we woke\n            # Need to be done just before sleeping\n            self.woken = cur_t\n            # Sleep some time...\n            self.was_killed.wait(self.sleep_interval)\n            # Quit if killed\n            if self.was_killed.is_set():\n                return\n            # Then monitor!\n            # Acquire lock (to access _instances)\n            with self.tqdm_cls.get_lock():\n                cur_t = self._time()\n                # Check tqdm instances are waiting too long to print\n                instances = self.get_instances()\n                for instance in instances:\n                    # Check event in loop to reduce blocking time on exit\n                    if self.was_killed.is_set():\n                        return\n                    # Only if mininterval > 1 (else iterations are just slow)\n                    # and last refresh exceeded maxinterval\n                    if instance.miniters > 1 and \\\n                            (cur_t - instance.last_print_t) >= \\\n                            instance.maxinterval:\n                        # force bypassing miniters on next iteration\n                        # (dynamic_miniters adjusts mininterval automatically)\n                        instance.miniters = 1\n                        # Refresh now! (works only for manual tqdm)\n                        instance.refresh(nolock=True)\n                if instances != self.get_instances():  # pragma: nocover\n                    warn(\"Set changed size during iteration\" +\n                         \" (see https://github.com/tqdm/tqdm/issues/481)\",\n                         TqdmSynchronisationWarning, stacklevel=2)",
        "begin_line": 62,
        "end_line": 96,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004608294930875576,
            "pseudo_dstar_susp": 0.004651162790697674,
            "pseudo_tarantula_susp": 0.0017035775127768314,
            "pseudo_op2_susp": 0.004651162790697674,
            "pseudo_barinel_susp": 0.0017035775127768314
        }
    },
    {
        "name": "tqdm._monitor.TMonitor.report#98",
        "src_path": "tqdm/_monitor.py",
        "class_name": "tqdm._monitor.TMonitor",
        "signature": "tqdm._monitor.TMonitor.report(self)",
        "snippet": "    def report(self):\n        return not self.was_killed.is_set()",
        "begin_line": 98,
        "end_line": 99,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005555555555555556,
            "pseudo_dstar_susp": 0.005555555555555556,
            "pseudo_tarantula_susp": 0.001893939393939394,
            "pseudo_op2_susp": 0.005555555555555556,
            "pseudo_barinel_susp": 0.001893939393939394
        }
    },
    {
        "name": "tqdm.std.TqdmWarning.__init__#47",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.TqdmWarning",
        "signature": "tqdm.std.TqdmWarning.__init__(self, msg, fp_write=None, *a, **k)",
        "snippet": "    def __init__(self, msg, fp_write=None, *a, **k):\n        if fp_write is not None:\n            fp_write(\"\\n\" + self.__class__.__name__ + \": \" +\n                     str(msg).rstrip() + '\\n')\n        else:\n            super(TqdmWarning, self).__init__(msg, *a, **k)",
        "begin_line": 47,
        "end_line": 52,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.002421307506053269,
            "pseudo_tarantula_susp": 0.0014903129657228018,
            "pseudo_op2_susp": 0.002421307506053269,
            "pseudo_barinel_susp": 0.001483679525222552
        }
    },
    {
        "name": "tqdm.std.TqdmDefaultWriteLock.__init__#79",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.TqdmDefaultWriteLock",
        "signature": "tqdm.std.TqdmDefaultWriteLock.__init__(self)",
        "snippet": "    def __init__(self):\n        # Create global parallelism locks to avoid racing issues with parallel\n        # bars works only if fork available (Linux/MacOSX, but not Windows)\n        self.create_mp_lock()\n        self.create_th_lock()\n        cls = type(self)\n        self.locks = [lk for lk in [cls.mp_lock, cls.th_lock] if lk is not None]",
        "begin_line": 79,
        "end_line": 85,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002967359050445104,
            "pseudo_dstar_susp": 0.00267379679144385,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.00267379679144385,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.TqdmDefaultWriteLock.acquire#87",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.TqdmDefaultWriteLock",
        "signature": "tqdm.std.TqdmDefaultWriteLock.acquire(self, *a, **k)",
        "snippet": "    def acquire(self, *a, **k):\n        for lock in self.locks:\n            lock.acquire(*a, **k)",
        "begin_line": 87,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.025,
            "pseudo_dstar_susp": 0.16666666666666666,
            "pseudo_tarantula_susp": 0.0019646365422396855,
            "pseudo_op2_susp": 0.16666666666666666,
            "pseudo_barinel_susp": 0.0019646365422396855
        }
    },
    {
        "name": "tqdm.std.TqdmDefaultWriteLock.release#91",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.TqdmDefaultWriteLock",
        "signature": "tqdm.std.TqdmDefaultWriteLock.release(self)",
        "snippet": "    def release(self):\n        for lock in self.locks[::-1]:  # Release in inverse order of acquisition\n            lock.release()",
        "begin_line": 91,
        "end_line": 93,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.025,
            "pseudo_dstar_susp": 0.16666666666666666,
            "pseudo_tarantula_susp": 0.0019646365422396855,
            "pseudo_op2_susp": 0.16666666666666666,
            "pseudo_barinel_susp": 0.0019646365422396855
        }
    },
    {
        "name": "tqdm.std.TqdmDefaultWriteLock.__enter__#95",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.TqdmDefaultWriteLock",
        "signature": "tqdm.std.TqdmDefaultWriteLock.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self.acquire()",
        "begin_line": 95,
        "end_line": 96,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.025,
            "pseudo_dstar_susp": 0.16666666666666666,
            "pseudo_tarantula_susp": 0.0019646365422396855,
            "pseudo_op2_susp": 0.16666666666666666,
            "pseudo_barinel_susp": 0.0019646365422396855
        }
    },
    {
        "name": "tqdm.std.TqdmDefaultWriteLock.__exit__#98",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.TqdmDefaultWriteLock",
        "signature": "tqdm.std.TqdmDefaultWriteLock.__exit__(self, *exc)",
        "snippet": "    def __exit__(self, *exc):\n        self.release()",
        "begin_line": 98,
        "end_line": 99,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.025,
            "pseudo_dstar_susp": 0.16666666666666666,
            "pseudo_tarantula_susp": 0.0019646365422396855,
            "pseudo_op2_susp": 0.16666666666666666,
            "pseudo_barinel_susp": 0.0019646365422396855
        }
    },
    {
        "name": "tqdm.std.TqdmDefaultWriteLock.create_mp_lock#102",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.TqdmDefaultWriteLock",
        "signature": "tqdm.std.TqdmDefaultWriteLock.create_mp_lock(cls)",
        "snippet": "    def create_mp_lock(cls):\n        if not hasattr(cls, 'mp_lock'):\n            try:\n                from multiprocessing import RLock\n                cls.mp_lock = RLock()  # multiprocessing lock\n            except ImportError:  # pragma: no cover\n                cls.mp_lock = None\n            except OSError:  # pragma: no cover\n                cls.mp_lock = None",
        "begin_line": 102,
        "end_line": 110,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.TqdmDefaultWriteLock.create_th_lock#113",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.TqdmDefaultWriteLock",
        "signature": "tqdm.std.TqdmDefaultWriteLock.create_th_lock(cls)",
        "snippet": "    def create_th_lock(cls):\n        if not hasattr(cls, 'th_lock'):\n            try:\n                cls.th_lock = th.RLock()  # thread lock\n            except OSError:  # pragma: no cover\n                cls.th_lock = None",
        "begin_line": 113,
        "end_line": 118,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.Bar.__init__#145",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.Bar",
        "signature": "tqdm.std.Bar.__init__(self, frac, default_len=10, charset=UTF)",
        "snippet": "    def __init__(self, frac, default_len=10, charset=UTF):\n        if not (0 <= frac <= 1):\n            warn(\"clamping frac to range [0, 1]\", TqdmWarning, stacklevel=2)\n            frac = max(0, min(1, frac))\n        assert default_len > 0\n        self.frac = frac\n        self.default_len = default_len\n        self.charset = charset",
        "begin_line": 145,
        "end_line": 152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.25,
            "pseudo_dstar_susp": 0.05555555555555555,
            "pseudo_tarantula_susp": 0.002824858757062147,
            "pseudo_op2_susp": 0.05555555555555555,
            "pseudo_barinel_susp": 0.002824858757062147
        }
    },
    {
        "name": "tqdm.std.Bar.__format__#154",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.Bar",
        "signature": "tqdm.std.Bar.__format__(self, format_spec)",
        "snippet": "    def __format__(self, format_spec):\n        if format_spec:\n            _type = format_spec[-1].lower()\n            try:\n                charset = dict(a=self.ASCII, u=self.UTF, b=self.BLANK)[_type]\n            except KeyError:\n                charset = self.charset\n            else:\n                format_spec = format_spec[:-1]\n            if format_spec:\n                N_BARS = int(format_spec)\n                if N_BARS < 0:\n                    N_BARS += self.default_len\n            else:\n                N_BARS = self.default_len\n        else:\n            charset = self.charset\n            N_BARS = self.default_len\n\n        nsyms = len(charset) - 1\n        bar_length, frac_bar_length = divmod(\n            int(self.frac * N_BARS * nsyms), nsyms)\n\n        bar = charset[-1] * bar_length\n        frac_bar = charset[frac_bar_length]\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            return bar + frac_bar + \\\n                charset[0] * (N_BARS - bar_length - 1)\n        return bar",
        "begin_line": 154,
        "end_line": 184,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.25,
            "pseudo_dstar_susp": 0.05555555555555555,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.05555555555555555,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.format_sizeof#198",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.format_sizeof(num, suffix='', divisor=1000)",
        "snippet": "    def format_sizeof(num, suffix='', divisor=1000):\n        \"\"\"\n        Formats a number (greater than unity) with SI Order of Magnitude\n        prefixes.\n\n        Parameters\n        ----------\n        num  : float\n            Number ( >= 1) to format.\n        suffix  : str, optional\n            Post-postfix [default: ''].\n        divisor  : float, optional\n            Divisor between prefixes [default: 1000].\n\n        Returns\n        -------\n        out  : str\n            Number with Order of Magnitude SI unit postfix.\n        \"\"\"\n        for unit in ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z']:\n            if abs(num) < 999.5:\n                if abs(num) < 99.95:\n                    if abs(num) < 9.995:\n                        return '{0:1.2f}'.format(num) + unit + suffix\n                    return '{0:2.1f}'.format(num) + unit + suffix\n                return '{0:3.0f}'.format(num) + unit + suffix\n            num /= divisor\n        return '{0:3.1f}Y'.format(num) + suffix",
        "begin_line": 198,
        "end_line": 225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.format_interval#228",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.format_interval(t)",
        "snippet": "    def format_interval(t):\n        \"\"\"\n        Formats a number of seconds as a clock time, [H:]MM:SS\n\n        Parameters\n        ----------\n        t  : int\n            Number of seconds.\n\n        Returns\n        -------\n        out  : str\n            [H:]MM:SS\n        \"\"\"\n        mins, s = divmod(int(t), 60)\n        h, m = divmod(mins, 60)\n        if h:\n            return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n        else:\n            return '{0:02d}:{1:02d}'.format(m, s)",
        "begin_line": 228,
        "end_line": 247,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010101010101010102,
            "pseudo_dstar_susp": 0.018518518518518517,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.018518518518518517,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.format_num#250",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.format_num(n)",
        "snippet": "    def format_num(n):\n        \"\"\"\n        Intelligent scientific notation (.3g).\n\n        Parameters\n        ----------\n        n  : int or float or Numeric\n            A Number.\n\n        Returns\n        -------\n        out  : str\n            Formatted number.\n        \"\"\"\n        f = '{0:.3g}'.format(n).replace('+0', '+').replace('-0', '-')\n        n = str(n)\n        return f if len(f) < len(n) else n",
        "begin_line": 250,
        "end_line": 266,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.ema#269",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.ema(x, mu=None, alpha=0.3)",
        "snippet": "    def ema(x, mu=None, alpha=0.3):\n        \"\"\"\n        Exponential moving average: smoothing to give progressively lower\n        weights to older values.\n\n        Parameters\n        ----------\n        x  : float\n            New value to include in EMA.\n        mu  : float, optional\n            Previous EMA value.\n        alpha  : float, optional\n            Smoothing factor in range [0, 1], [default: 0.3].\n            Increase to give more weight to recent values.\n            Ranges from 0 (yields mu) to 1 (yields x).\n        \"\"\"\n        return x if mu is None else (alpha * x) + (1 - alpha) * mu",
        "begin_line": 269,
        "end_line": 285,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.status_printer#288",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.status_printer(file)",
        "snippet": "    def status_printer(file):\n        \"\"\"\n        Manage the printing and in-place updating of a line of characters.\n        Note that if the string is longer than a line, then in-place\n        updating may not work (it will print a new line at each refresh).\n        \"\"\"\n        fp = file\n        fp_flush = getattr(fp, 'flush', lambda: None)  # pragma: no cover\n\n        def fp_write(s):\n            fp.write(_unicode(s))\n            fp_flush()\n\n        last_len = [0]\n\n        def print_status(s):\n            len_s = len(s)\n            fp_write('\\r' + s + (' ' * max(last_len[0] - len_s, 0)))\n            last_len[0] = len_s\n\n        return print_status",
        "begin_line": 288,
        "end_line": 308,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006756756756756757,
            "pseudo_dstar_susp": 0.006535947712418301,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.006535947712418301,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.fp_write#297",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.fp_write(s)",
        "snippet": "        def fp_write(s):\n            fp.write(_unicode(s))\n            fp_flush()",
        "begin_line": 297,
        "end_line": 299,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00558659217877095,
            "pseudo_dstar_susp": 0.0125,
            "pseudo_tarantula_susp": 0.001692047377326565,
            "pseudo_op2_susp": 0.0125,
            "pseudo_barinel_susp": 0.001692047377326565
        }
    },
    {
        "name": "tqdm.std.tqdm.print_status#303",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.print_status(s)",
        "snippet": "        def print_status(s):\n            len_s = len(s)\n            fp_write('\\r' + s + (' ' * max(last_len[0] - len_s, 0)))\n            last_len[0] = len_s",
        "begin_line": 303,
        "end_line": 306,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 1.0,
            "pseudo_dstar_susp": 1.0,
            "pseudo_tarantula_susp": 0.002320185614849188,
            "pseudo_op2_susp": 1.0,
            "pseudo_barinel_susp": 0.002320185614849188
        }
    },
    {
        "name": "tqdm.std.tqdm.format_meter#311",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None, postfix=None, unit_divisor=1000, **extra_kwargs)",
        "snippet": "    def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                     unit='it', unit_scale=False, rate=None, bar_format=None,\n                     postfix=None, unit_divisor=1000, **extra_kwargs):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int or float\n            Number of finished iterations.\n        total  : int or float\n            The expected total number of iterations. If meaningless (None),\n            only basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes `{bar}` to stay within this bound\n            [default: None]. If `0`, will not print any bar (only stats).\n            The fallback is `{bar:10}`.\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n            Use as {desc} in bar_format string.\n        ascii  : bool, optional or str, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            \" 123456789#\".\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool or int or float, optional\n            If 1 or True, the number of iterations will be printed with an\n            appropriate SI metric prefix (k = 10^3, M = 10^6, etc.)\n            [default: False]. If any other non-zero number, will scale\n            `total` and `n`.\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where\n            l_bar='{desc}: {percentage:3.0f}%|' and\n            r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n              '{rate_fmt}{postfix}]'\n            Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n              percentage, elapsed, elapsed_s, ncols, desc, unit,\n              rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n              rate_inv, rate_inv_fmt, postfix, unit_divisor,\n              remaining, remaining_s.\n            Note that a trailing \": \" is automatically removed after {desc}\n            if the latter is empty.\n        postfix  : *, optional\n            Similar to `prefix`, but placed at the end\n            (e.g. for additional stats).\n            Note: postfix is usually a string (not a dict) for this method,\n            and will if possible be set to postfix = ', ' + postfix.\n            However other types are supported (#382).\n        unit_divisor  : float, optional\n            [default: 1000], ignored unless `unit_scale` is True.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n >= (total + 0.5):  # allow float imprecision (#849)\n            total = None\n\n        # apply custom scale if necessary\n        if unit_scale and unit_scale not in (True, 1):\n            if total:\n                total *= unit_scale\n            n *= unit_scale\n            if rate:\n                rate *= unit_scale  # by default rate = 1 / self.avg_time\n            unit_scale = False\n\n        elapsed_str = tqdm.format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = n / elapsed\n        inv_rate = 1 / rate if rate else None\n        format_sizeof = tqdm.format_sizeof\n        rate_noinv_fmt = ((format_sizeof(rate) if unit_scale else\n                           '{0:5.2f}'.format(rate))\n                          if rate else '?') + unit + '/s'\n        rate_inv_fmt = ((format_sizeof(inv_rate) if unit_scale else\n                         '{0:5.2f}'.format(inv_rate))\n                        if inv_rate else '?') + 's/' + unit\n        rate_fmt = rate_inv_fmt if inv_rate and inv_rate > 1 else rate_noinv_fmt\n\n        if unit_scale:\n            n_fmt = format_sizeof(n, divisor=unit_divisor)\n            total_fmt = format_sizeof(total, divisor=unit_divisor) \\\n                if total is not None else '?'\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total) if total is not None else '?'\n\n        try:\n            postfix = ', ' + postfix if postfix else ''\n        except TypeError:\n            pass\n\n        remaining = (total - n) / rate if rate and total else 0\n        remaining_str = tqdm.format_interval(remaining) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        if prefix:\n            # old prefix setup work around\n            bool_prefix_colon_already = (prefix[-2:] == \": \")\n            l_bar = prefix if bool_prefix_colon_already else prefix + \": \"\n        else:\n            l_bar = ''\n\n        r_bar = '| {0}/{1} [{2}<{3}, {4}{5}]'.format(\n            n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt, postfix)\n\n        # Custom bar formatting\n        # Populate a dict with all available progress indicators\n        format_dict = dict(\n            # slight extension of self.format_dict\n            n=n, n_fmt=n_fmt, total=total, total_fmt=total_fmt,\n            elapsed=elapsed_str, elapsed_s=elapsed,\n            ncols=ncols, desc=prefix or '', unit=unit,\n            rate=inv_rate if inv_rate and inv_rate > 1 else rate,\n            rate_fmt=rate_fmt, rate_noinv=rate,\n            rate_noinv_fmt=rate_noinv_fmt, rate_inv=inv_rate,\n            rate_inv_fmt=rate_inv_fmt,\n            postfix=postfix, unit_divisor=unit_divisor,\n            # plus more useful definitions\n            remaining=remaining_str, remaining_s=remaining,\n            l_bar=l_bar, r_bar=r_bar,\n            **extra_kwargs)\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            l_bar += '{0:3.0f}%|'.format(percentage)\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            format_dict.update(l_bar=l_bar)\n            if bar_format:\n                format_dict.update(percentage=percentage)\n\n                # auto-remove colon for empty `desc`\n                if not prefix:\n                    bar_format = bar_format.replace(\"{desc}: \", '')\n            else:\n                bar_format = \"{l_bar}{bar}{r_bar}\"\n\n            full_bar = FormatReplace()\n            try:\n                nobar = bar_format.format(bar=full_bar, **format_dict)\n            except UnicodeEncodeError:\n                bar_format = _unicode(bar_format)\n                nobar = bar_format.format(bar=full_bar, **format_dict)\n            if not full_bar.format_called:\n                # no {bar}, we can just format and return\n                return nobar\n\n            # Formatting progress bar space available for bar's display\n            full_bar = Bar(\n                frac,\n                max(1, ncols - disp_len(nobar))\n                if ncols else 10,\n                charset=Bar.ASCII if ascii is True else ascii or Bar.UTF)\n            if not _is_ascii(full_bar.charset) and _is_ascii(bar_format):\n                bar_format = _unicode(bar_format)\n            res = bar_format.format(bar=full_bar, **format_dict)\n            if ncols:\n                return disp_trim(res, ncols)\n\n        elif bar_format:\n            # user-specified bar_format but no total\n            l_bar += '|'\n            format_dict.update(l_bar=l_bar, percentage=0)\n            full_bar = FormatReplace()\n            nobar = bar_format.format(bar=full_bar, **format_dict)\n            if not full_bar.format_called:\n                return nobar\n            full_bar = Bar(\n                0,\n                max(1, ncols - disp_len(nobar))\n                if ncols else 10,\n                charset=Bar.BLANK)\n            res = bar_format.format(bar=full_bar, **format_dict)\n            if ncols:\n                return disp_trim(res, ncols)\n        else:\n            # no total: no progressbar, ETA, just progress stats\n            return ((prefix + \": \") if prefix else '') + \\\n                '{0}{1} [{2}, {3}{4}]'.format(\n                    n_fmt, unit, elapsed_str, rate_fmt, postfix)",
        "begin_line": 311,
        "end_line": 511,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.03225806451612903,
            "pseudo_dstar_susp": 0.027777777777777776,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.027777777777777776,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.__new__#513",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.__new__(cls, *args, **kwargs)",
        "snippet": "    def __new__(cls, *args, **kwargs):\n        # Create a new instance\n        instance = object.__new__(cls)\n        # Construct the lock if it does not exist\n        with cls.get_lock():\n            # Add to the list of instances\n            if not hasattr(cls, '_instances'):\n                cls._instances = WeakSet()\n            cls._instances.add(instance)\n            # Create the monitoring thread\n            if cls.monitor_interval and (cls.monitor is None or not\n                                         cls.monitor.report()):\n                try:\n                    cls.monitor = TMonitor(cls, cls.monitor_interval)\n                except Exception as e:  # pragma: nocover\n                    warn(\"tqdm:disabling monitor support\"\n                         \" (monitor_interval = 0) due to:\\n\" + str(e),\n                         TqdmMonitorWarning, stacklevel=2)\n                    cls.monitor_interval = 0\n        # Return the instance\n        return instance",
        "begin_line": 513,
        "end_line": 533,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005434782608695652,
            "pseudo_dstar_susp": 0.0078125,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0078125,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm._get_free_pos#536",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm._get_free_pos(cls, instance=None)",
        "snippet": "    def _get_free_pos(cls, instance=None):\n        \"\"\"Skips specified instance.\"\"\"\n        positions = set(abs(inst.pos) for inst in cls._instances\n                        if inst is not instance and hasattr(inst, \"pos\"))\n        return min(set(range(len(positions) + 1)).difference(positions))",
        "begin_line": 536,
        "end_line": 540,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.5,
            "pseudo_dstar_susp": 0.5,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.5,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm._decr_instances#543",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm._decr_instances(cls, instance)",
        "snippet": "    def _decr_instances(cls, instance):\n        \"\"\"\n        Remove from list and reposition other bars\n        so that newer bars won't overlap previous bars\n        \"\"\"\n        with cls._lock:\n            try:\n                cls._instances.remove(instance)\n            except KeyError:\n                # if not instance.gui:  # pragma: no cover\n                #     raise\n                pass  # py2: maybe magically removed already\n            # else:\n            if not instance.gui:\n                for inst in cls._instances:\n                    # negative `pos` means fixed\n                    if hasattr(inst, \"pos\") and inst.pos > abs(instance.pos):\n                        inst.clear(nolock=True)\n                        inst.pos -= 1\n                        # TODO: check this doesn't overwrite another fixed bar\n            # Kill monitor if no instances are left\n            if not cls._instances and cls.monitor:\n                try:\n                    cls.monitor.exit()\n                    del cls.monitor\n                except AttributeError:  # pragma: nocover\n                    pass\n                else:\n                    cls.monitor = None",
        "begin_line": 543,
        "end_line": 571,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0045662100456621,
            "pseudo_dstar_susp": 0.0043859649122807015,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0043859649122807015,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.write#574",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.write(cls, s, file=None, end='\\n', nolock=False)",
        "snippet": "    def write(cls, s, file=None, end=\"\\n\", nolock=False):\n        \"\"\"Print a message via tqdm (without overlap with bars).\"\"\"\n        fp = file if file is not None else sys.stdout\n        with cls.external_write_mode(file=file, nolock=nolock):\n            # Write the message\n            fp.write(s)\n            fp.write(end)",
        "begin_line": 574,
        "end_line": 580,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.external_write_mode#584",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.external_write_mode(cls, file=None, nolock=False)",
        "snippet": "    def external_write_mode(cls, file=None, nolock=False):\n        \"\"\"\n        Disable tqdm within context and refresh tqdm when exits.\n        Useful when writing to standard output stream\n        \"\"\"\n        fp = file if file is not None else sys.stdout\n\n        if not nolock:\n            cls.get_lock().acquire()\n        # Clear all bars\n        inst_cleared = []\n        for inst in getattr(cls, '_instances', []):\n            # Clear instance if in the target output file\n            # or if write output + tqdm output are both either\n            # sys.stdout or sys.stderr (because both are mixed in terminal)\n            if hasattr(inst, \"start_t\") and (inst.fp == fp or all(\n                    f in (sys.stdout, sys.stderr) for f in (fp, inst.fp))):\n                inst.clear(nolock=True)\n                inst_cleared.append(inst)\n        yield\n        # Force refresh display of bars we cleared\n        for inst in inst_cleared:\n            inst.refresh(nolock=True)\n        if not nolock:\n            cls._lock.release()",
        "begin_line": 584,
        "end_line": 608,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.set_lock#611",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.set_lock(cls, lock)",
        "snippet": "    def set_lock(cls, lock):\n        \"\"\"Set the global lock.\"\"\"\n        cls._lock = lock",
        "begin_line": 611,
        "end_line": 613,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.get_lock#616",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.get_lock(cls)",
        "snippet": "    def get_lock(cls):\n        \"\"\"Get the global lock. Construct it if it does not exist.\"\"\"\n        if not hasattr(cls, '_lock'):\n            cls._lock = TqdmDefaultWriteLock()\n        return cls._lock",
        "begin_line": 616,
        "end_line": 620,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005076142131979695,
            "pseudo_dstar_susp": 0.005319148936170213,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.005319148936170213,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.pandas#623",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.pandas(tclass, *targs, **tkwargs)",
        "snippet": "    def pandas(tclass, *targs, **tkwargs):\n        \"\"\"\n        Registers the given `tqdm` class with\n            pandas.core.\n            ( frame.DataFrame\n            | series.Series\n            | groupby.(generic.)DataFrameGroupBy\n            | groupby.(generic.)SeriesGroupBy\n            ).progress_apply\n\n        A new instance will be create every time `progress_apply` is called,\n        and each instance will automatically close() upon completion.\n\n        Parameters\n        ----------\n        targs, tkwargs  : arguments for the tqdm instance\n\n        Examples\n        --------\n        >>> import pandas as pd\n        >>> import numpy as np\n        >>> from tqdm import tqdm\n        >>> from tqdm.gui import tqdm as tqdm_gui\n        >>>\n        >>> df = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))\n        >>> tqdm.pandas(ncols=50)  # can use tqdm_gui, optional kwargs, etc\n        >>> # Now you can use `progress_apply` instead of `apply`\n        >>> df.groupby(0).progress_apply(lambda x: x**2)\n\n        References\n        ----------\n        https://stackoverflow.com/questions/18603270/\n        progress-indicator-during-pandas-operations-python\n        \"\"\"\n        from pandas.core.frame import DataFrame\n        from pandas.core.series import Series\n        try:\n            from pandas import Panel\n        except ImportError:  # TODO: pandas>0.25.2\n            Panel = None\n        try:  # pandas>=0.18.0\n            from pandas.core.window import _Rolling_and_Expanding\n        except ImportError:  # pragma: no cover\n            _Rolling_and_Expanding = None\n        try:  # pandas>=0.25.0\n            from pandas.core.groupby.generic import DataFrameGroupBy, \\\n                SeriesGroupBy  # , NDFrameGroupBy\n        except ImportError:\n            try:  # pandas>=0.23.0\n                from pandas.core.groupby.groupby import DataFrameGroupBy, \\\n                    SeriesGroupBy\n            except ImportError:\n                from pandas.core.groupby import DataFrameGroupBy, \\\n                    SeriesGroupBy\n        try:  # pandas>=0.23.0\n            from pandas.core.groupby.groupby import GroupBy\n        except ImportError:\n            from pandas.core.groupby import GroupBy\n\n        try:  # pandas>=0.23.0\n            from pandas.core.groupby.groupby import PanelGroupBy\n        except ImportError:\n            try:\n                from pandas.core.groupby import PanelGroupBy\n            except ImportError:  # pandas>=0.25.0\n                PanelGroupBy = None\n\n        deprecated_t = [tkwargs.pop('deprecated_t', None)]\n\n        def inner_generator(df_function='apply'):\n            def inner(df, func, *args, **kwargs):\n                \"\"\"\n                Parameters\n                ----------\n                df  : (DataFrame|Series)[GroupBy]\n                    Data (may be grouped).\n                func  : function\n                    To be applied on the (grouped) data.\n                **kwargs  : optional\n                    Transmitted to `df.apply()`.\n                \"\"\"\n\n                # Precompute total iterations\n                total = tkwargs.pop(\"total\", getattr(df, 'ngroups', None))\n                if total is None:  # not grouped\n                    if df_function == 'applymap':\n                        total = df.size\n                    elif isinstance(df, Series):\n                        total = len(df)\n                    elif _Rolling_and_Expanding is None or \\\n                            not isinstance(df, _Rolling_and_Expanding):\n                        # DataFrame or Panel\n                        axis = kwargs.get('axis', 0)\n                        if axis == 'index':\n                            axis = 0\n                        elif axis == 'columns':\n                            axis = 1\n                        # when axis=0, total is shape[axis1]\n                        total = df.size // df.shape[axis]\n\n                # Init bar\n                if deprecated_t[0] is not None:\n                    t = deprecated_t[0]\n                    deprecated_t[0] = None\n                else:\n                    t = tclass(*targs, total=total, **tkwargs)\n\n                if len(args) > 0:\n                    # *args intentionally not supported (see #244, #299)\n                    TqdmDeprecationWarning(\n                        \"Except func, normal arguments are intentionally\" +\n                        \" not supported by\" +\n                        \" `(DataFrame|Series|GroupBy).progress_apply`.\" +\n                        \" Use keyword arguments instead.\",\n                        fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n                try:\n                    func = df._is_builtin_func(func)\n                except TypeError:\n                    pass\n\n                # Define bar updating wrapper\n                def wrapper(*args, **kwargs):\n                    # update tbar correctly\n                    # it seems `pandas apply` calls `func` twice\n                    # on the first column/row to decide whether it can\n                    # take a fast or slow code path; so stop when t.total==t.n\n                    t.update(n=1 if not t.total or t.n < t.total else 0)\n                    return func(*args, **kwargs)\n\n                # Apply the provided function (in **kwargs)\n                # on the df using our wrapper (which provides bar updating)\n                result = getattr(df, df_function)(wrapper, **kwargs)\n\n                # Close bar and return pandas calculation result\n                t.close()\n                return result\n\n            return inner\n\n        # Monkeypatch pandas to provide easy methods\n        # Enable custom tqdm progress in pandas!\n        Series.progress_apply = inner_generator()\n        SeriesGroupBy.progress_apply = inner_generator()\n        Series.progress_map = inner_generator('map')\n        SeriesGroupBy.progress_map = inner_generator('map')\n\n        DataFrame.progress_apply = inner_generator()\n        DataFrameGroupBy.progress_apply = inner_generator()\n        DataFrame.progress_applymap = inner_generator('applymap')\n\n        if Panel is not None:\n            Panel.progress_apply = inner_generator()\n        if PanelGroupBy is not None:\n            PanelGroupBy.progress_apply = inner_generator()\n\n        GroupBy.progress_apply = inner_generator()\n        GroupBy.progress_aggregate = inner_generator('aggregate')\n        GroupBy.progress_transform = inner_generator('transform')\n\n        if _Rolling_and_Expanding is not None:  # pragma: no cover\n            _Rolling_and_Expanding.progress_apply = inner_generator()",
        "begin_line": 623,
        "end_line": 784,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.__init__#786",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.__init__(self, iterable=None, desc=None, total=None, leave=True, file=None, ncols=None, mininterval=0.1, maxinterval=10.0, miniters=None, ascii=None, disable=False, unit='it', unit_scale=False, dynamic_ncols=False, smoothing=0.3, bar_format=None, initial=0, position=None, postfix=None, unit_divisor=1000, write_bytes=None, lock_args=None, gui=False, **kwargs)",
        "snippet": "    def __init__(self, iterable=None, desc=None, total=None, leave=True,\n                 file=None, ncols=None, mininterval=0.1, maxinterval=10.0,\n                 miniters=None, ascii=None, disable=False, unit='it',\n                 unit_scale=False, dynamic_ncols=False, smoothing=0.3,\n                 bar_format=None, initial=0, position=None, postfix=None,\n                 unit_divisor=1000, write_bytes=None, lock_args=None,\n                 gui=False, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar.\n        total  : int or float, optional\n            The number of expected iterations. If unspecified,\n            len(iterable) is used if possible. If float(\"inf\") or as a last\n            resort, only basic progress statistics are displayed\n            (no ETA, no progressbar).\n            If `gui` is True and this parameter needs subsequent updating,\n            specify an initial arbitrary large positive number,\n            e.g. 9e9.\n        leave  : bool, optional\n            If [default: True], keeps all traces of the progressbar\n            upon termination of iteration.\n            If `None`, will leave only if `position` is `0`.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            (default: sys.stderr). Uses `file.write(str)` and `file.flush()`\n            methods.  For encoding, see `write_bytes`.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If unspecified, attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress display update interval [default: 0.1] seconds.\n        maxinterval  : float, optional\n            Maximum progress display update interval [default: 10] seconds.\n            Automatically adjusts `miniters` to correspond to `mininterval`\n            after long display update lag. Only works if `dynamic_miniters`\n            or monitor thread is enabled.\n        miniters  : int or float, optional\n            Minimum progress display update interval, in iterations.\n            If 0 and `dynamic_miniters`, will automatically adjust to equal\n            `mininterval` (more CPU efficient, good for tight loops).\n            If > 0, will skip display of specified number of iterations.\n            Tweak this and `mininterval` to get very efficient loops.\n            If your progress is erratic with both fast and slow iterations\n            (network, skipping items, etc) you should set miniters=1.\n        ascii  : bool or str, optional\n            If unspecified or False, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters \" 123456789#\".\n        disable  : bool, optional\n            Whether to disable the entire progressbar wrapper\n            [default: False]. If set to None, disable on non-TTY.\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: it].\n        unit_scale  : bool or int or float, optional\n            If 1 or True, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False]. If any other non-zero\n            number, will scale `total` and `n`.\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float, optional\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where\n            l_bar='{desc}: {percentage:3.0f}%|' and\n            r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n              '{rate_fmt}{postfix}]'\n            Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n              percentage, elapsed, elapsed_s, ncols, desc, unit,\n              rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n              rate_inv, rate_inv_fmt, postfix, unit_divisor,\n              remaining, remaining_s.\n            Note that a trailing \": \" is automatically removed after {desc}\n            if the latter is empty.\n        initial  : int or float, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0]. If using float, consider specifying `{n:.3f}`\n            or similar in `bar_format`, or specifying `unit_scale`.\n        position  : int, optional\n            Specify the line offset to print this bar (starting from 0)\n            Automatic if unspecified.\n            Useful to manage multiple bars at once (eg, from threads).\n        postfix  : dict or *, optional\n            Specify additional stats to display at the end of the bar.\n            Calls `set_postfix(**postfix)` if possible (dict).\n        unit_divisor  : float, optional\n            [default: 1000], ignored unless `unit_scale` is True.\n        write_bytes  : bool, optional\n            If (default: None) and `file` is unspecified,\n            bytes will be written in Python 2. If `True` will also write\n            bytes. In all other cases will default to unicode.\n        lock_args  : tuple, optional\n            Passed to `refresh` for intermediate output\n            (initialisation, iterating, and updating).\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm.gui.tqdm(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: False].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        if write_bytes is None:\n            write_bytes = file is None and sys.version_info < (3,)\n\n        if file is None:\n            file = sys.stderr\n\n        if write_bytes:\n            # Despite coercing unicode into bytes, py2 sys.std* streams\n            # should have bytes written to them.\n            file = SimpleTextIOWrapper(\n                file, encoding=getattr(file, 'encoding', None) or 'utf-8')\n\n        if disable is None and hasattr(file, \"isatty\") and not file.isatty():\n            disable = True\n\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n        if total == float(\"inf\"):\n            # Infinite iterations, behave same as unknown\n            total = None\n\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            with self._lock:\n                self.pos = self._get_free_pos(self)\n                self._instances.remove(self)\n            self.n = initial\n            self.total = total\n            return\n\n        if kwargs:\n            self.disable = True\n            with self._lock:\n                self.pos = self._get_free_pos(self)\n                self._instances.remove(self)\n            raise (\n                TqdmDeprecationWarning(\n                    \"`nested` is deprecated and automated.\\n\"\n                    \"Use `position` instead for manual control.\\n\",\n                    fp_write=getattr(file, 'write', sys.stderr.write))\n                if \"nested\" in kwargs else\n                TqdmKeyError(\"Unknown argument(s): \" + str(kwargs)))\n\n        # Preprocess the arguments\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:  # pragma: no cover\n            if dynamic_ncols:\n                dynamic_ncols = _environ_cols_wrapper()\n                if dynamic_ncols:\n                    ncols = dynamic_ncols(file)\n            else:\n                _dynamic_ncols = _environ_cols_wrapper()\n                if _dynamic_ncols:\n                    ncols = _dynamic_ncols(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if bar_format and not ((ascii is True) or _is_ascii(ascii)):\n            # Convert bar format into unicode since terminal uses unicode\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc or ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.unit_divisor = unit_divisor\n        self.lock_args = lock_args\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        self._time = time\n        self.bar_format = bar_format\n        self.postfix = None\n        if postfix:\n            try:\n                self.set_postfix(refresh=False, **postfix)\n            except TypeError:\n                self.postfix = postfix\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        with self._lock:\n            if position is None:\n                self.pos = self._get_free_pos(self)\n            else:  # mark fixed positions as negative\n                self.pos = -position\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            self.refresh(lock_args=self.lock_args)\n\n        # Init the time counter\n        self.last_print_t = self._time()\n        # NB: Avoid race conditions by setting start_t at the very end of init\n        self.start_t = self.last_print_t",
        "begin_line": 786,
        "end_line": 1033,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006756756756756757,
            "pseudo_dstar_susp": 0.0078125,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0078125,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.__bool__#1035",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.__bool__(self)",
        "snippet": "    def __bool__(self):\n        if self.total is not None:\n            return self.total > 0\n        if self.iterable is None:\n            raise TypeError('bool() undefined when iterable == total == None')\n        return bool(self.iterable)",
        "begin_line": 1035,
        "end_line": 1040,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.__nonzero__#1042",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.__nonzero__(self)",
        "snippet": "    def __nonzero__(self):\n        return self.__bool__()",
        "begin_line": 1042,
        "end_line": 1043,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.__len__#1045",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.__len__(self)",
        "snippet": "    def __len__(self):\n        return self.total if self.iterable is None else \\\n            (self.iterable.shape[0] if hasattr(self.iterable, \"shape\")\n             else len(self.iterable) if hasattr(self.iterable, \"__len__\")\n             else getattr(self, \"total\", None))",
        "begin_line": 1045,
        "end_line": 1049,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.__enter__#1051",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.__enter__(self)",
        "snippet": "    def __enter__(self):\n        return self",
        "begin_line": 1051,
        "end_line": 1052,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.002976190476190476,
            "pseudo_tarantula_susp": 0.001310615989515072,
            "pseudo_op2_susp": 0.002976190476190476,
            "pseudo_barinel_susp": 0.0013568521031207597
        }
    },
    {
        "name": "tqdm.std.tqdm.__exit__#1054",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.__exit__(self, exc_type, exc_value, traceback)",
        "snippet": "    def __exit__(self, exc_type, exc_value, traceback):\n        try:\n            self.close()\n        except AttributeError:\n            # maybe eager thread cleanup upon external error\n            if (exc_type, exc_value, traceback) == (None, None, None):\n                raise\n            warn(\"AttributeError ignored\", TqdmWarning, stacklevel=2)",
        "begin_line": 1054,
        "end_line": 1061,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.002976190476190476,
            "pseudo_tarantula_susp": 0.001310615989515072,
            "pseudo_op2_susp": 0.002976190476190476,
            "pseudo_barinel_susp": 0.0013568521031207597
        }
    },
    {
        "name": "tqdm.std.tqdm.__del__#1063",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.__del__(self)",
        "snippet": "    def __del__(self):\n        self.close()",
        "begin_line": 1063,
        "end_line": 1064,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004149377593360996,
            "pseudo_dstar_susp": 0.0045045045045045045,
            "pseudo_tarantula_susp": 0.001584786053882726,
            "pseudo_op2_susp": 0.0045045045045045045,
            "pseudo_barinel_susp": 0.001584786053882726
        }
    },
    {
        "name": "tqdm.std.tqdm.__repr__#1066",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return self.format_meter(**self.format_dict)",
        "begin_line": 1066,
        "end_line": 1067,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009523809523809525,
            "pseudo_dstar_susp": 0.009523809523809525,
            "pseudo_tarantula_susp": 0.002369668246445498,
            "pseudo_op2_susp": 0.009523809523809525,
            "pseudo_barinel_susp": 0.002369668246445498
        }
    },
    {
        "name": "tqdm.std.tqdm._comparable#1070",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm._comparable(self)",
        "snippet": "    def _comparable(self):\n        return abs(getattr(self, \"pos\", 1 << 31))",
        "begin_line": 1070,
        "end_line": 1071,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.002881844380403458,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.002881844380403458,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.__hash__#1073",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.__hash__(self)",
        "snippet": "    def __hash__(self):\n        return id(self)",
        "begin_line": 1073,
        "end_line": 1074,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.09090909090909091,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.001937984496124031,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.0019267822736030828
        }
    },
    {
        "name": "tqdm.std.tqdm.__iter__#1076",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.__iter__(self)",
        "snippet": "    def __iter__(self):\n        \"\"\"Backward-compatibility to use: for x in tqdm(iterable)\"\"\"\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n            return\n\n        mininterval = self.mininterval\n        maxinterval = self.maxinterval\n        miniters = self.miniters\n        dynamic_miniters = self.dynamic_miniters\n        last_print_t = self.last_print_t\n        last_print_n = self.last_print_n\n        n = self.n\n        smoothing = self.smoothing\n        avg_time = self.avg_time\n        time = self._time\n\n        if not hasattr(self, 'sp'):\n            raise TqdmDeprecationWarning(\n                \"Please use `tqdm.gui.tqdm(...)` instead of\"\n                \" `tqdm(..., gui=True)`\\n\",\n                fp_write=getattr(self.fp, 'write', sys.stderr.write))\n\n        for obj in iterable:\n            yield obj\n            # Update and possibly print the progressbar.\n            # Note: does not call self.update(1) for speed optimisation.\n            n += 1\n            # check counter first to avoid calls to time()\n            if n - last_print_n >= self.miniters:\n                miniters = self.miniters  # watch monitoring thread changes\n                delta_t = time() - last_print_t\n                if delta_t >= mininterval:\n                    cur_t = time()\n                    delta_it = n - last_print_n\n                    # EMA (not just overall average)\n                    if smoothing and delta_t and delta_it:\n                        rate = delta_t / delta_it\n                        avg_time = self.ema(rate, avg_time, smoothing)\n                        self.avg_time = avg_time\n\n                    self.n = n\n                    self.refresh(lock_args=self.lock_args)\n\n                    # If no `miniters` was specified, adjust automatically\n                    # to the max iteration rate seen so far between 2 prints\n                    if dynamic_miniters:\n                        if maxinterval and delta_t >= maxinterval:\n                            # Adjust miniters to time interval by rule of 3\n                            if mininterval:\n                                # Set miniters to correspond to mininterval\n                                miniters = delta_it * mininterval / delta_t\n                            else:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                        elif smoothing:\n                            # EMA-weight miniters to converge\n                            # towards the timeframe of mininterval\n                            rate = delta_it\n                            if mininterval and delta_t:\n                                rate *= mininterval / delta_t\n                            miniters = self.ema(rate, miniters, smoothing)\n                        else:\n                            # Maximum nb of iterations between 2 prints\n                            miniters = max(miniters, delta_it)\n\n                    # Store old values for next call\n                    self.n = self.last_print_n = last_print_n = n\n                    self.last_print_t = last_print_t = cur_t\n                    self.miniters = miniters\n\n        # Closing the progress bar.\n        # Update some internal variables for close().\n        self.last_print_n = last_print_n\n        self.n = n\n        self.miniters = miniters\n        self.close()",
        "begin_line": 1076,
        "end_line": 1159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003472222222222222,
            "pseudo_dstar_susp": 0.003484320557491289,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.003484320557491289,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.update#1161",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.update(self, n=1)",
        "snippet": "    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int or float, optional\n            Increment to add to the internal counter of iterations\n            [default: 1]. If using float, consider specifying `{n:.3f}`\n            or similar in `bar_format`, or specifying `unit_scale`.\n        \"\"\"\n        # N.B.: see __iter__() for more comments.\n        if self.disable:\n            return\n\n        if n < 0:\n            self.last_print_n += n  # for auto-refresh logic to work\n        self.n += n\n\n        # check counter first to reduce calls to time()\n        if self.n - self.last_print_n >= self.miniters:\n            delta_t = self._time() - self.last_print_t\n            if delta_t >= self.mininterval:\n                cur_t = self._time()\n                delta_it = self.n - self.last_print_n  # >= n\n                # elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t and delta_it:\n                    rate = delta_t / delta_it\n                    self.avg_time = self.ema(\n                        rate, self.avg_time, self.smoothing)\n\n                if not hasattr(self, \"sp\"):\n                    raise TqdmDeprecationWarning(\n                        \"Please use `tqdm.gui.tqdm(...)`\"\n                        \" instead of `tqdm(..., gui=True)`\\n\",\n                        fp_write=getattr(self.fp, 'write', sys.stderr.write))\n\n                self.refresh(lock_args=self.lock_args)\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far between two prints.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t >= self.maxinterval:\n                        if self.mininterval:\n                            self.miniters = delta_it * self.mininterval \\\n                                / delta_t\n                        else:\n                            self.miniters = delta_it * self.maxinterval \\\n                                / delta_t\n                    elif self.smoothing:\n                        self.miniters = self.smoothing * delta_it * \\\n                            (self.mininterval / delta_t\n                             if self.mininterval and delta_t\n                             else 1) + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = max(self.miniters, delta_it)\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t",
        "begin_line": 1161,
        "end_line": 1235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0023094688221709007,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0023094688221709007,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.close#1237",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.close(self)",
        "snippet": "    def close(self):\n        \"\"\"Cleanup and (if leave=False) close the progressbar.\"\"\"\n        if self.disable:\n            return\n\n        # Prevent multiple closures\n        self.disable = True\n\n        # decrement instance pos and remove from internal set\n        pos = abs(self.pos)\n        self._decr_instances(self)\n\n        # GUI mode\n        if not hasattr(self, \"sp\"):\n            return\n\n        # annoyingly, _supports_unicode isn't good enough\n        def fp_write(s):\n            self.fp.write(_unicode(s))\n\n        try:\n            fp_write('')\n        except ValueError as e:\n            if 'closed' in str(e):\n                return\n            raise  # pragma: no cover\n\n        leave = pos == 0 if self.leave is None else self.leave\n\n        with self._lock:\n            if leave:\n                # stats for overall rate (no weighted average)\n                self.avg_time = None\n                self.display(pos=0)\n                fp_write('\\n')\n            else:\n                self.display(msg='', pos=pos)\n                if not pos:\n                    fp_write('\\r')",
        "begin_line": 1237,
        "end_line": 1275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0043859649122807015,
            "pseudo_dstar_susp": 0.0045045045045045045,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0045045045045045045,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.fp_write#1254",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.fp_write(s)",
        "snippet": "        def fp_write(s):\n            self.fp.write(_unicode(s))",
        "begin_line": 1254,
        "end_line": 1255,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00558659217877095,
            "pseudo_dstar_susp": 0.0125,
            "pseudo_tarantula_susp": 0.001692047377326565,
            "pseudo_op2_susp": 0.0125,
            "pseudo_barinel_susp": 0.001692047377326565
        }
    },
    {
        "name": "tqdm.std.tqdm.clear#1277",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.clear(self, nolock=False)",
        "snippet": "    def clear(self, nolock=False):\n        \"\"\"Clear current bar display.\"\"\"\n        if self.disable:\n            return\n\n        if not nolock:\n            self._lock.acquire()\n        self.moveto(abs(self.pos))\n        self.sp('')\n        self.fp.write('\\r')  # place cursor back at the beginning of line\n        self.moveto(-abs(self.pos))\n        if not nolock:\n            self._lock.release()",
        "begin_line": 1277,
        "end_line": 1289,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012594458438287153,
            "pseudo_dstar_susp": 0.0012594458438287153,
            "pseudo_tarantula_susp": 0.0012626262626262627,
            "pseudo_op2_susp": 0.0012594458438287153,
            "pseudo_barinel_susp": 0.0012626262626262627
        }
    },
    {
        "name": "tqdm.std.tqdm.refresh#1291",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.refresh(self, nolock=False, lock_args=None)",
        "snippet": "    def refresh(self, nolock=False, lock_args=None):\n        \"\"\"\n        Force refresh the display of this bar.\n\n        Parameters\n        ----------\n        nolock  : bool, optional\n            If `True`, does not lock.\n            If [default: `False`]: calls `acquire()` on internal lock.\n        lock_args  : tuple, optional\n            Passed to internal lock's `acquire()`.\n            If specified, will only `display()` if `acquire()` returns `True`.\n        \"\"\"\n        if self.disable:\n            return\n\n        if not nolock:\n            if lock_args:\n                if not self._lock.acquire(*lock_args):\n                    return False\n            else:\n                self._lock.acquire()\n        self.display()\n        if not nolock:\n            self._lock.release()\n        return True",
        "begin_line": 1291,
        "end_line": 1316,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008064516129032258,
            "pseudo_dstar_susp": 0.007936507936507936,
            "pseudo_tarantula_susp": 0.002127659574468085,
            "pseudo_op2_susp": 0.007936507936507936,
            "pseudo_barinel_susp": 0.002127659574468085
        }
    },
    {
        "name": "tqdm.std.tqdm.unpause#1318",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.unpause(self)",
        "snippet": "    def unpause(self):\n        \"\"\"Restart tqdm timer from last print time.\"\"\"\n        cur_t = self._time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t",
        "begin_line": 1318,
        "end_line": 1322,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.reset#1324",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.reset(self, total=None)",
        "snippet": "    def reset(self, total=None):\n        \"\"\"\n        Resets to 0 iterations for repeated use.\n\n        Consider combining with `leave=True`.\n\n        Parameters\n        ----------\n        total  : int or float, optional. Total to use for the new bar.\n        \"\"\"\n        self.last_print_n = self.n = 0\n        self.last_print_t = self.start_t = self._time()\n        if total is not None:\n            self.total = total\n        self.refresh()",
        "begin_line": 1324,
        "end_line": 1338,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.set_description#1340",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.set_description(self, desc=None, refresh=True)",
        "snippet": "    def set_description(self, desc=None, refresh=True):\n        \"\"\"\n        Set/modify description of the progress bar.\n\n        Parameters\n        ----------\n        desc  : str, optional\n        refresh  : bool, optional\n            Forces refresh [default: True].\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''\n        if refresh:\n            self.refresh()",
        "begin_line": 1340,
        "end_line": 1352,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002967359050445104,
            "pseudo_dstar_susp": 0.00267379679144385,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.00267379679144385,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.set_description_str#1354",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.set_description_str(self, desc=None, refresh=True)",
        "snippet": "    def set_description_str(self, desc=None, refresh=True):\n        \"\"\"Set/modify description without ': ' appended.\"\"\"\n        self.desc = desc or ''\n        if refresh:\n            self.refresh()",
        "begin_line": 1354,
        "end_line": 1358,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002967359050445104,
            "pseudo_dstar_susp": 0.00267379679144385,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.00267379679144385,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.set_postfix#1360",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.set_postfix(self, ordered_dict=None, refresh=True, **kwargs)",
        "snippet": "    def set_postfix(self, ordered_dict=None, refresh=True, **kwargs):\n        \"\"\"\n        Set/modify postfix (additional stats)\n        with automatic formatting based on datatype.\n\n        Parameters\n        ----------\n        ordered_dict  : dict or OrderedDict, optional\n        refresh  : bool, optional\n            Forces refresh [default: True].\n        kwargs  : dict, optional\n        \"\"\"\n        # Sort in alphabetical order to be more deterministic\n        postfix = _OrderedDict([] if ordered_dict is None else ordered_dict)\n        for key in sorted(kwargs.keys()):\n            postfix[key] = kwargs[key]\n        # Preprocess stats according to datatype\n        for key in postfix.keys():\n            # Number: limit the length of the string\n            if isinstance(postfix[key], Number):\n                postfix[key] = self.format_num(postfix[key])\n            # Else for any other type, try to get the string conversion\n            elif not isinstance(postfix[key], _basestring):\n                postfix[key] = str(postfix[key])\n            # Else if it's a string, don't need to preprocess anything\n        # Stitch together to get the final postfix\n        self.postfix = ', '.join(key + '=' + postfix[key].strip()\n                                 for key in postfix.keys())\n        if refresh:\n            self.refresh()",
        "begin_line": 1360,
        "end_line": 1389,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013908205841446453,
            "pseudo_dstar_susp": 0.0013831258644536654,
            "pseudo_tarantula_susp": 0.0014903129657228018,
            "pseudo_op2_susp": 0.0013831258644536654,
            "pseudo_barinel_susp": 0.001483679525222552
        }
    },
    {
        "name": "tqdm.std.tqdm.set_postfix_str#1391",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.set_postfix_str(self, s='', refresh=True)",
        "snippet": "    def set_postfix_str(self, s='', refresh=True):\n        \"\"\"\n        Postfix without dictionary expansion, similar to prefix handling.\n        \"\"\"\n        self.postfix = str(s)\n        if refresh:\n            self.refresh()",
        "begin_line": 1391,
        "end_line": 1397,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013908205841446453,
            "pseudo_dstar_susp": 0.0013831258644536654,
            "pseudo_tarantula_susp": 0.0014903129657228018,
            "pseudo_op2_susp": 0.0013831258644536654,
            "pseudo_barinel_susp": 0.001483679525222552
        }
    },
    {
        "name": "tqdm.std.tqdm.moveto#1399",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.moveto(self, n)",
        "snippet": "    def moveto(self, n):\n        # TODO: private method\n        self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n        self.fp.flush()",
        "begin_line": 1399,
        "end_line": 1402,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001443001443001443,
            "pseudo_dstar_susp": 0.0023752969121140144,
            "pseudo_tarantula_susp": 0.0014144271570014145,
            "pseudo_op2_susp": 0.0023752969121140144,
            "pseudo_barinel_susp": 0.0014144271570014145
        }
    },
    {
        "name": "tqdm.std.tqdm.format_dict#1405",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.format_dict(self)",
        "snippet": "    def format_dict(self):\n        \"\"\"Public API for read-only member access.\"\"\"\n        return dict(\n            n=self.n, total=self.total,\n            elapsed=self._time() - self.start_t\n            if hasattr(self, 'start_t') else 0,\n            ncols=self.dynamic_ncols(self.fp)\n            if self.dynamic_ncols else self.ncols,\n            prefix=self.desc, ascii=self.ascii, unit=self.unit,\n            unit_scale=self.unit_scale,\n            rate=1 / self.avg_time if self.avg_time else None,\n            bar_format=self.bar_format, postfix=self.postfix,\n            unit_divisor=self.unit_divisor)",
        "begin_line": 1405,
        "end_line": 1417,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008771929824561403,
            "pseudo_dstar_susp": 0.008695652173913044,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.008695652173913044,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.tqdm.display#1419",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.display(self, msg=None, pos=None)",
        "snippet": "    def display(self, msg=None, pos=None):\n        \"\"\"\n        Use `self.sp` to display `msg` in the specified `pos`.\n\n        Consider overloading this function when inheriting to use e.g.:\n        `self.some_frontend(**self.format_dict)` instead of `self.sp`.\n\n        Parameters\n        ----------\n        msg  : str, optional. What to display (default: `repr(self)`).\n        pos  : int, optional. Position to `moveto`\n          (default: `abs(self.pos)`).\n        \"\"\"\n        if pos is None:\n            pos = abs(self.pos)\n\n        if pos:\n            self.moveto(pos)\n        self.sp(self.__repr__() if msg is None else msg)\n        if pos:\n            self.moveto(-pos)",
        "begin_line": 1419,
        "end_line": 1439,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009523809523809525,
            "pseudo_dstar_susp": 0.009523809523809525,
            "pseudo_tarantula_susp": 0.002369668246445498,
            "pseudo_op2_susp": 0.009523809523809525,
            "pseudo_barinel_susp": 0.002369668246445498
        }
    },
    {
        "name": "tqdm.std.tqdm.wrapattr#1443",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std.tqdm",
        "signature": "tqdm.std.tqdm.wrapattr(tclass, stream, method, total=None, bytes=True, **tkwargs)",
        "snippet": "    def wrapattr(tclass, stream, method, total=None, bytes=True, **tkwargs):\n        \"\"\"\n        stream  : file-like object.\n        method  : str, \"read\" or \"write\". The result of `read()` and\n            the first argument of `write()` should have a `len()`.\n\n        >>> with tqdm.wrapattr(file_obj, \"read\", total=file_obj.size) as fobj:\n        ...     while True:\n        ...         chunk = fobj.read(chunk_size)\n        ...         if not chunk:\n        ...             break\n        \"\"\"\n        with tclass(total=total, **tkwargs) as t:\n            if bytes:\n                t.unit = \"B\"\n                t.unit_scale = True\n                t.unit_divisor = 1024\n            yield CallbackIOWrapper(t.update, stream, method)",
        "begin_line": 1443,
        "end_line": 1460,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.std.trange#1463",
        "src_path": "tqdm/std.py",
        "class_name": "tqdm.std",
        "signature": "tqdm.std.trange(*args, **kwargs)",
        "snippet": "def trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)",
        "begin_line": 1463,
        "end_line": 1468,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036363636363636364,
            "pseudo_dstar_susp": 0.003663003663003663,
            "pseudo_tarantula_susp": 0.0017035775127768314,
            "pseudo_op2_susp": 0.003663003663003663,
            "pseudo_barinel_susp": 0.0017035775127768314
        }
    },
    {
        "name": "tqdm.gui.tqdm_gui.__init__#32",
        "src_path": "tqdm/gui.py",
        "class_name": "tqdm.gui.tqdm_gui",
        "signature": "tqdm.gui.tqdm_gui.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        import matplotlib as mpl\n        import matplotlib.pyplot as plt\n        from collections import deque\n        kwargs['gui'] = True\n\n        super(tqdm_gui, self).__init__(*args, **kwargs)\n\n        # Initialize the GUI display\n        if self.disable or not kwargs['gui']:\n            return\n\n        warn('GUI is experimental/alpha', TqdmExperimentalWarning, stacklevel=2)\n        self.mpl = mpl\n        self.plt = plt\n        self.sp = None\n\n        # Remember if external environment uses toolbars\n        self.toolbar = self.mpl.rcParams['toolbar']\n        self.mpl.rcParams['toolbar'] = 'None'\n\n        self.mininterval = max(self.mininterval, 0.5)\n        self.fig, ax = plt.subplots(figsize=(9, 2.2))\n        # self.fig.subplots_adjust(bottom=0.2)\n        total = len(self)\n        if total is not None:\n            self.xdata = []\n            self.ydata = []\n            self.zdata = []\n        else:\n            self.xdata = deque([])\n            self.ydata = deque([])\n            self.zdata = deque([])\n        self.line1, = ax.plot(self.xdata, self.ydata, color='b')\n        self.line2, = ax.plot(self.xdata, self.zdata, color='k')\n        ax.set_ylim(0, 0.001)\n        if total is not None:\n            ax.set_xlim(0, 100)\n            ax.set_xlabel('percent')\n            self.fig.legend((self.line1, self.line2), ('cur', 'est'),\n                            loc='center right')\n            # progressbar\n            self.hspan = plt.axhspan(0, 0.001,\n                                     xmin=0, xmax=0, color='g')\n        else:\n            # ax.set_xlim(-60, 0)\n            ax.set_xlim(0, 60)\n            ax.invert_xaxis()\n            ax.set_xlabel('seconds')\n            ax.legend(('cur', 'est'), loc='lower left')\n        ax.grid()\n        # ax.set_xlabel('seconds')\n        ax.set_ylabel((self.unit if self.unit else 'it') + '/s')\n        if self.unit_scale:\n            plt.ticklabel_format(style='sci', axis='y',\n                                 scilimits=(0, 0))\n            ax.yaxis.get_offset_text().set_x(-0.15)\n\n        # Remember if external environment is interactive\n        self.wasion = plt.isinteractive()\n        plt.ion()\n        self.ax = ax",
        "begin_line": 32,
        "end_line": 93,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.gui.tqdm_gui.__iter__#95",
        "src_path": "tqdm/gui.py",
        "class_name": "tqdm.gui.tqdm_gui",
        "signature": "tqdm.gui.tqdm_gui.__iter__(self)",
        "snippet": "    def __iter__(self):\n        # TODO: somehow allow the following:\n        # if not self.gui:\n        #   return super(tqdm_gui, self).__iter__()\n        iterable = self.iterable\n        if self.disable:\n            for obj in iterable:\n                yield obj\n            return\n\n        # ncols = self.ncols\n        mininterval = self.mininterval\n        maxinterval = self.maxinterval\n        miniters = self.miniters\n        dynamic_miniters = self.dynamic_miniters\n        last_print_t = self.last_print_t\n        last_print_n = self.last_print_n\n        n = self.n\n        # dynamic_ncols = self.dynamic_ncols\n        smoothing = self.smoothing\n        avg_time = self.avg_time\n        time = self._time\n\n        for obj in iterable:\n            yield obj\n            # Update and possibly print the progressbar.\n            # Note: does not call self.update(1) for speed optimisation.\n            n += 1\n            # check counter first to avoid calls to time()\n            if n - last_print_n >= self.miniters:\n                miniters = self.miniters  # watch monitoring thread changes\n                delta_t = time() - last_print_t\n                if delta_t >= mininterval:\n                    cur_t = time()\n                    delta_it = n - last_print_n\n                    # EMA (not just overall average)\n                    if smoothing and delta_t and delta_it:\n                        rate = delta_t / delta_it\n                        avg_time = self.ema(rate, avg_time, smoothing)\n                        self.avg_time = avg_time\n\n                    self.n = n\n                    self.display()\n\n                    # If no `miniters` was specified, adjust automatically\n                    # to the max iteration rate seen so far between 2 prints\n                    if dynamic_miniters:\n                        if maxinterval and delta_t >= maxinterval:\n                            # Adjust miniters to time interval by rule of 3\n                            if mininterval:\n                                # Set miniters to correspond to mininterval\n                                miniters = delta_it * mininterval / delta_t\n                            else:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                        elif smoothing:\n                            # EMA-weight miniters to converge\n                            # towards the timeframe of mininterval\n                            rate = delta_it\n                            if mininterval and delta_t:\n                                rate *= mininterval / delta_t\n                            miniters = self.ema(rate, miniters, smoothing)\n                        else:\n                            # Maximum nb of iterations between 2 prints\n                            miniters = max(miniters, delta_it)\n\n                    # Store old values for next call\n                    self.n = self.last_print_n = last_print_n = n\n                    self.last_print_t = last_print_t = cur_t\n                    self.miniters = miniters\n\n        # Closing the progress bar.\n        # Update some internal variables for close().\n        self.last_print_n = last_print_n\n        self.n = n\n        self.miniters = miniters\n        self.close()",
        "begin_line": 95,
        "end_line": 171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.gui.tqdm_gui.update#173",
        "src_path": "tqdm/gui.py",
        "class_name": "tqdm.gui.tqdm_gui",
        "signature": "tqdm.gui.tqdm_gui.update(self, n=1)",
        "snippet": "    def update(self, n=1):\n        # if not self.gui:\n        #   return super(tqdm_gui, self).close()\n        if self.disable:\n            return\n\n        if n < 0:\n            self.last_print_n += n  # for auto-refresh logic to work\n        self.n += n\n\n        # check counter first to reduce calls to time()\n        if self.n - self.last_print_n >= self.miniters:\n            delta_t = self._time() - self.last_print_t\n            if delta_t >= self.mininterval:\n                cur_t = self._time()\n                delta_it = self.n - self.last_print_n  # >= n\n                # elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t and delta_it:\n                    rate = delta_t / delta_it\n                    self.avg_time = self.ema(\n                        rate, self.avg_time, self.smoothing)\n\n                self.display()\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far between two prints.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t >= self.maxinterval:\n                        if self.mininterval:\n                            self.miniters = delta_it * self.mininterval \\\n                                / delta_t\n                        else:\n                            self.miniters = delta_it * self.maxinterval \\\n                                / delta_t\n                    elif self.smoothing:\n                        self.miniters = self.smoothing * delta_it * \\\n                            (self.mininterval / delta_t\n                             if self.mininterval and delta_t\n                             else 1) + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = max(self.miniters, delta_it)\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t",
        "begin_line": 173,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.gui.tqdm_gui.close#224",
        "src_path": "tqdm/gui.py",
        "class_name": "tqdm.gui.tqdm_gui",
        "signature": "tqdm.gui.tqdm_gui.close(self)",
        "snippet": "    def close(self):\n        # if not self.gui:\n        #   return super(tqdm_gui, self).close()\n        if self.disable:\n            return\n\n        self.disable = True\n\n        with self.get_lock():\n            self._instances.remove(self)\n\n        # Restore toolbars\n        self.mpl.rcParams['toolbar'] = self.toolbar\n        # Return to non-interactive mode\n        if not self.wasion:\n            self.plt.ioff()\n        if not self.leave:\n            self.plt.close(self.fig)",
        "begin_line": 224,
        "end_line": 241,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.gui.tqdm_gui.display#243",
        "src_path": "tqdm/gui.py",
        "class_name": "tqdm.gui.tqdm_gui",
        "signature": "tqdm.gui.tqdm_gui.display(self)",
        "snippet": "    def display(self):\n        n = self.n\n        cur_t = self._time()\n        elapsed = cur_t - self.start_t\n        delta_it = n - self.last_print_n\n        delta_t = cur_t - self.last_print_t\n\n        # Inline due to multiple calls\n        total = self.total\n        xdata = self.xdata\n        ydata = self.ydata\n        zdata = self.zdata\n        ax = self.ax\n        line1 = self.line1\n        line2 = self.line2\n        # instantaneous rate\n        y = delta_it / delta_t\n        # overall rate\n        z = n / elapsed\n        # update line data\n        xdata.append(n * 100.0 / total if total else cur_t)\n        ydata.append(y)\n        zdata.append(z)\n\n        # Discard old values\n        # xmin, xmax = ax.get_xlim()\n        # if (not total) and elapsed > xmin * 1.1:\n        if (not total) and elapsed > 66:\n            xdata.popleft()\n            ydata.popleft()\n            zdata.popleft()\n\n        ymin, ymax = ax.get_ylim()\n        if y > ymax or z > ymax:\n            ymax = 1.1 * y\n            ax.set_ylim(ymin, ymax)\n            ax.figure.canvas.draw()\n\n        if total:\n            line1.set_data(xdata, ydata)\n            line2.set_data(xdata, zdata)\n            try:\n                poly_lims = self.hspan.get_xy()\n            except AttributeError:\n                self.hspan = self.plt.axhspan(\n                    0, 0.001, xmin=0, xmax=0, color='g')\n                poly_lims = self.hspan.get_xy()\n            poly_lims[0, 1] = ymin\n            poly_lims[1, 1] = ymax\n            poly_lims[2] = [n / total, ymax]\n            poly_lims[3] = [poly_lims[2, 0], ymin]\n            if len(poly_lims) > 4:\n                poly_lims[4, 1] = ymin\n            self.hspan.set_xy(poly_lims)\n        else:\n            t_ago = [cur_t - i for i in xdata]\n            line1.set_data(t_ago, ydata)\n            line2.set_data(t_ago, zdata)\n\n        ax.set_title(self.format_meter(\n            n, total, elapsed, 0,\n            self.desc, self.ascii, self.unit, self.unit_scale,\n            1 / self.avg_time if self.avg_time else None, self.bar_format,\n            self.postfix, self.unit_divisor),\n            fontname=\"DejaVu Sans Mono\", fontsize=11)\n        self.plt.pause(1e-9)",
        "begin_line": 243,
        "end_line": 308,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.gui.tgrange#311",
        "src_path": "tqdm/gui.py",
        "class_name": "tqdm.gui",
        "signature": "tqdm.gui.tgrange(*args, **kwargs)",
        "snippet": "def tgrange(*args, **kwargs):\n    \"\"\"\n    A shortcut for `tqdm.gui.tqdm(xrange(*args), **kwargs)`.\n    On Python3+, `range` is used instead of `xrange`.\n    \"\"\"\n    return tqdm_gui(_range(*args), **kwargs)",
        "begin_line": 311,
        "end_line": 316,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.cli.cast#9",
        "src_path": "tqdm/cli.py",
        "class_name": "tqdm.cli",
        "signature": "tqdm.cli.cast(val, typ)",
        "snippet": "def cast(val, typ):\n    log = logging.getLogger(__name__)\n    log.debug((val, typ))\n    if \" or \" in typ:\n        for t in typ.split(\" or \"):\n            try:\n                return cast(val, t)\n            except TqdmTypeError:\n                pass\n        raise TqdmTypeError(val + ' : ' + typ)\n\n    # sys.stderr.write('\\ndebug | `val:type`: `' + val + ':' + typ + '`.\\n')\n    if typ == 'bool':\n        if (val == 'True') or (val == ''):\n            return True\n        elif val == 'False':\n            return False\n        else:\n            raise TqdmTypeError(val + ' : ' + typ)\n    try:\n        return eval(typ + '(\"' + val + '\")')\n    except:\n        if typ == 'chr':\n            return chr(ord(eval('\"' + val + '\"')))\n        else:\n            raise TqdmTypeError(val + ' : ' + typ)",
        "begin_line": 9,
        "end_line": 34,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.002421307506053269,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.002421307506053269,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.cli.posix_pipe#37",
        "src_path": "tqdm/cli.py",
        "class_name": "tqdm.cli",
        "signature": "tqdm.cli.posix_pipe(fin, fout, delim='\\n', buf_size=256, callback=lambda int: None)",
        "snippet": "def posix_pipe(fin, fout, delim='\\n', buf_size=256,\n               callback=lambda int: None  # pragma: no cover\n               ):\n    \"\"\"\n    Params\n    ------\n    fin  : file with `read(buf_size : int)` method\n    fout  : file with `write` (and optionally `flush`) methods.\n    callback  : function(int), e.g.: `tqdm.update`\n    \"\"\"\n    fp_write = fout.write\n\n    # tmp = ''\n    if not delim:\n        while True:\n            tmp = fin.read(buf_size)\n\n            # flush at EOF\n            if not tmp:\n                getattr(fout, 'flush', lambda: None)()  # pragma: no cover\n                return\n\n            fp_write(tmp)\n            callback(len(tmp))\n        # return\n\n    buf = ''\n    # n = 0\n    while True:\n        tmp = fin.read(buf_size)\n\n        # flush at EOF\n        if not tmp:\n            if buf:\n                fp_write(buf)\n                callback(1 + buf.count(delim))  # n += 1 + buf.count(delim)\n            getattr(fout, 'flush', lambda: None)()  # pragma: no cover\n            return  # n\n\n        while True:\n            try:\n                i = tmp.index(delim)\n            except ValueError:\n                buf += tmp\n                break\n            else:\n                fp_write(buf + tmp[:i + len(delim)])\n                callback(1)  # n += 1\n                buf = ''\n                tmp = tmp[i + len(delim):]",
        "begin_line": 37,
        "end_line": 86,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002967359050445104,
            "pseudo_dstar_susp": 0.00267379679144385,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.00267379679144385,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.cli.main#119",
        "src_path": "tqdm/cli.py",
        "class_name": "tqdm.cli",
        "signature": "tqdm.cli.main(fp=sys.stderr, argv=None)",
        "snippet": "def main(fp=sys.stderr, argv=None):\n    \"\"\"\n    Parameters (internal use only)\n    ---------\n    fp  : file-like object for tqdm\n    argv  : list (default: sys.argv[1:])\n    \"\"\"\n    if argv is None:\n        argv = sys.argv[1:]\n    try:\n        log = argv.index('--log')\n    except ValueError:\n        for i in argv:\n            if i.startswith('--log='):\n                logLevel = i[len('--log='):]\n                break\n        else:\n            logLevel = 'INFO'\n    else:\n        # argv.pop(log)\n        # logLevel = argv.pop(log)\n        logLevel = argv[log + 1]\n    logging.basicConfig(\n        level=getattr(logging, logLevel),\n        format=\"%(levelname)s:%(module)s:%(lineno)d:%(message)s\")\n    log = logging.getLogger(__name__)\n\n    d = tqdm.__init__.__doc__ + CLI_EXTRA_DOC\n\n    opt_types = dict(RE_OPTS.findall(d))\n    # opt_types['delim'] = 'chr'\n\n    for o in UNSUPPORTED_OPTS:\n        opt_types.pop(o)\n\n    log.debug(sorted(opt_types.items()))\n\n    # d = RE_OPTS.sub(r'  --\\1=<\\1>  : \\2', d)\n    split = RE_OPTS.split(d)\n    opt_types_desc = zip(split[1::3], split[2::3], split[3::3])\n    d = ''.join('\\n  --{0}=<{0}>  : {1}{2}'.format(*otd)\n                for otd in opt_types_desc if otd[0] not in UNSUPPORTED_OPTS)\n\n    d = \"\"\"Usage:\n  tqdm [--help | options]\n\nOptions:\n  -h, --help     Print this help and exit\n  -v, --version  Print version and exit\n\n\"\"\" + d.strip('\\n') + '\\n'\n\n    # opts = docopt(d, version=__version__)\n    if any(v in argv for v in ('-v', '--version')):\n        sys.stdout.write(__version__ + '\\n')\n        sys.exit(0)\n    elif any(v in argv for v in ('-h', '--help')):\n        sys.stdout.write(d + '\\n')\n        sys.exit(0)\n\n    argv = RE_SHLEX.split(' '.join([\"tqdm\"] + argv))\n    opts = dict(zip(argv[1::3], argv[3::3]))\n\n    log.debug(opts)\n    opts.pop('log', True)\n\n    tqdm_args = {'file': fp}\n    try:\n        for (o, v) in opts.items():\n            try:\n                tqdm_args[o] = cast(v, opt_types[o])\n            except KeyError as e:\n                raise TqdmKeyError(str(e))\n        log.debug('args:' + str(tqdm_args))\n    except:\n        fp.write('\\nError:\\nUsage:\\n  tqdm [--help | options]\\n')\n        for i in sys.stdin:\n            sys.stdout.write(i)\n        raise\n    else:\n        buf_size = tqdm_args.pop('buf_size', 256)\n        delim = tqdm_args.pop('delim', '\\n')\n        delim_per_char = tqdm_args.pop('bytes', False)\n        manpath = tqdm_args.pop('manpath', None)\n        stdin = getattr(sys.stdin, 'buffer', sys.stdin)\n        stdout = getattr(sys.stdout, 'buffer', sys.stdout)\n        if manpath is not None:\n            from os import path\n            from shutil import copyfile\n            from pkg_resources import resource_filename, Requirement\n            fi = resource_filename(Requirement.parse('tqdm'), 'tqdm/tqdm.1')\n            fo = path.join(manpath, 'tqdm.1')\n            copyfile(fi, fo)\n            log.info(\"written:\" + fo)\n            sys.exit(0)\n        if delim_per_char:\n            tqdm_args.setdefault('unit', 'B')\n            tqdm_args.setdefault('unit_scale', True)\n            tqdm_args.setdefault('unit_divisor', 1024)\n            log.debug(tqdm_args)\n            with tqdm(**tqdm_args) as t:\n                posix_pipe(stdin, stdout, '', buf_size, t.update)\n        elif delim == '\\n':\n            log.debug(tqdm_args)\n            for i in tqdm(stdin, **tqdm_args):\n                stdout.write(i)\n        else:\n            log.debug(tqdm_args)\n            with tqdm(**tqdm_args) as t:\n                posix_pipe(stdin, stdout, delim, buf_size, t.update)",
        "begin_line": 119,
        "end_line": 228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.002421307506053269,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.002421307506053269,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm._tqdm_pandas.tqdm_pandas#7",
        "src_path": "tqdm/_tqdm_pandas.py",
        "class_name": "tqdm._tqdm_pandas",
        "signature": "tqdm._tqdm_pandas.tqdm_pandas(tclass, *targs, **tkwargs)",
        "snippet": "def tqdm_pandas(tclass, *targs, **tkwargs):\n    \"\"\"\n    Registers the given `tqdm` instance with\n    `pandas.core.groupby.DataFrameGroupBy.progress_apply`.\n    It will even close() the `tqdm` instance upon completion.\n\n    Parameters\n    ----------\n    tclass  : tqdm class you want to use (eg, tqdm, tqdm_notebook, etc)\n    targs and tkwargs  : arguments for the tqdm instance\n\n    Examples\n    --------\n    >>> import pandas as pd\n    >>> import numpy as np\n    >>> from tqdm import tqdm, tqdm_pandas\n    >>>\n    >>> df = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))\n    >>> tqdm_pandas(tqdm, leave=True)  # can use tqdm_gui, optional kwargs, etc\n    >>> # Now you can use `progress_apply` instead of `apply`\n    >>> df.groupby(0).progress_apply(lambda x: x**2)\n\n    References\n    ----------\n    https://stackoverflow.com/questions/18603270/\n    progress-indicator-during-pandas-operations-python\n    \"\"\"\n    from tqdm import TqdmDeprecationWarning\n\n    if isinstance(tclass, type) or (getattr(tclass, '__name__', '').startswith(\n            'tqdm_')):  # delayed adapter case\n        TqdmDeprecationWarning(\"\"\"\\\nPlease use `tqdm.pandas(...)` instead of `tqdm_pandas(tqdm, ...)`.\n\"\"\", fp_write=getattr(tkwargs.get('file', None), 'write', sys.stderr.write))\n        tclass.pandas(*targs, **tkwargs)\n    else:\n        TqdmDeprecationWarning(\"\"\"\\\nPlease use `tqdm.pandas(...)` instead of `tqdm_pandas(tqdm(...))`.\n\"\"\", fp_write=getattr(tclass.fp, 'write', sys.stderr.write))\n        type(tclass).pandas(deprecated_t=tclass)",
        "begin_line": 7,
        "end_line": 46,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.__init__.tqdm_notebook#21",
        "src_path": "tqdm/__init__.py",
        "class_name": "tqdm.__init__",
        "signature": "tqdm.__init__.tqdm_notebook(*args, **kwargs)",
        "snippet": "def tqdm_notebook(*args, **kwargs):  # pragma: no cover\n    \"\"\"See tqdm.notebook.tqdm for full documentation\"\"\"\n    from .notebook import tqdm as _tqdm_notebook\n    from warnings import warn\n    warn(\"This function will be removed in tqdm==5.0.0\\n\"\n         \"Please use `tqdm.notebook.tqdm` instead of `tqdm.tqdm_notebook`\",\n         TqdmDeprecationWarning, stacklevel=2)\n    return _tqdm_notebook(*args, **kwargs)",
        "begin_line": 21,
        "end_line": 28,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "tqdm.__init__.tnrange#31",
        "src_path": "tqdm/__init__.py",
        "class_name": "tqdm.__init__",
        "signature": "tqdm.__init__.tnrange(*args, **kwargs)",
        "snippet": "def tnrange(*args, **kwargs):  # pragma: no cover\n    \"\"\"\n    A shortcut for `tqdm.notebook.tqdm(xrange(*args), **kwargs)`.\n    On Python3+, `range` is used instead of `xrange`.\n    \"\"\"\n    from .notebook import trange as _tnrange\n    from warnings import warn\n    warn(\"Please use `tqdm.notebook.trange` instead of `tqdm.tnrange`\",\n         TqdmDeprecationWarning, stacklevel=2)\n    return _tnrange(*args, **kwargs)",
        "begin_line": 31,
        "end_line": 40,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001869158878504673,
            "pseudo_dstar_susp": 0.0017543859649122807,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0017543859649122807,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    }
]