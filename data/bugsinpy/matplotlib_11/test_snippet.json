[
    {
        "name": "lib.matplotlib.tests.test_text.test_font_styles#23",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_font_styles()",
        "snippet": "def test_font_styles():\n\n    def find_matplotlib_font(**kw):\n        prop = FontProperties(**kw)\n        path = findfont(prop, directory=matplotlib.get_data_path())\n        return FontProperties(fname=path)\n\n    from matplotlib.font_manager import FontProperties, findfont\n    warnings.filterwarnings(\n        'ignore',\n        r\"findfont: Font family \\[u?'Foo'\\] not found. Falling back to .\",\n        UserWarning,\n        module='matplotlib.font_manager')\n\n    plt.figure()\n    ax = plt.subplot(1, 1, 1)\n\n    normalFont = find_matplotlib_font(\n        family=\"sans-serif\",\n        style=\"normal\",\n        variant=\"normal\",\n        size=14)\n    ax.annotate(\n        \"Normal Font\",\n        (0.1, 0.1),\n        xycoords='axes fraction',\n        fontproperties=normalFont)\n\n    boldFont = find_matplotlib_font(\n        family=\"Foo\",\n        style=\"normal\",\n        variant=\"normal\",\n        weight=\"bold\",\n        stretch=500,\n        size=14)\n    ax.annotate(\n        \"Bold Font\",\n        (0.1, 0.2),\n        xycoords='axes fraction',\n        fontproperties=boldFont)\n\n    boldItemFont = find_matplotlib_font(\n        family=\"sans serif\",\n        style=\"italic\",\n        variant=\"normal\",\n        weight=750,\n        stretch=500,\n        size=14)\n    ax.annotate(\n        \"Bold Italic Font\",\n        (0.1, 0.3),\n        xycoords='axes fraction',\n        fontproperties=boldItemFont)\n\n    lightFont = find_matplotlib_font(\n        family=\"sans-serif\",\n        style=\"normal\",\n        variant=\"normal\",\n        weight=200,\n        stretch=500,\n        size=14)\n    ax.annotate(\n        \"Light Font\",\n        (0.1, 0.4),\n        xycoords='axes fraction',\n        fontproperties=lightFont)\n\n    condensedFont = find_matplotlib_font(\n        family=\"sans-serif\",\n        style=\"normal\",\n        variant=\"normal\",\n        weight=500,\n        stretch=100,\n        size=14)\n    ax.annotate(\n        \"Condensed Font\",\n        (0.1, 0.5),\n        xycoords='axes fraction',\n        fontproperties=condensedFont)\n\n    ax.set_xticks([])\n    ax.set_yticks([])",
        "begin_line": 23,
        "end_line": 104,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.find_matplotlib_font#25",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.find_matplotlib_font(**kw)",
        "snippet": "    def find_matplotlib_font(**kw):\n        prop = FontProperties(**kw)\n        path = findfont(prop, directory=matplotlib.get_data_path())\n        return FontProperties(fname=path)",
        "begin_line": 25,
        "end_line": 28,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_multiline#108",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_multiline()",
        "snippet": "def test_multiline():\n    plt.figure()\n    ax = plt.subplot(1, 1, 1)\n    ax.set_title(\"multiline\\ntext alignment\")\n\n    plt.text(\n        0.2, 0.5, \"TpTpTp\\n$M$\\nTpTpTp\", size=20, ha=\"center\", va=\"top\")\n\n    plt.text(\n        0.5, 0.5, \"TpTpTp\\n$M^{M^{M^{M}}}$\\nTpTpTp\", size=20,\n        ha=\"center\", va=\"top\")\n\n    plt.text(\n        0.8, 0.5, \"TpTpTp\\n$M_{q_{q_{q}}}$\\nTpTpTp\", size=20,\n        ha=\"center\", va=\"top\")\n\n    plt.xlim(0, 1)\n    plt.ylim(0, 0.8)\n\n    ax.set_xticks([])\n    ax.set_yticks([])",
        "begin_line": 108,
        "end_line": 128,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_multiline2#132",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_multiline2()",
        "snippet": "def test_multiline2():\n    # Remove this line when this test image is regenerated.\n    plt.rcParams['text.kerning_factor'] = 6\n\n    fig, ax = plt.subplots()\n\n    ax.set_xlim([0, 1.4])\n    ax.set_ylim([0, 2])\n    ax.axhline(0.5, color='C2', linewidth=0.3)\n    sts = ['Line', '2 Lineg\\n 2 Lg', '$\\\\sum_i x $', 'hi $\\\\sum_i x $\\ntest',\n           'test\\n $\\\\sum_i x $', '$\\\\sum_i x $\\n $\\\\sum_i x $']\n    renderer = fig.canvas.get_renderer()\n\n    def draw_box(ax, tt):\n        bb = tt.get_window_extent(renderer)\n        bbt = bb.inverse_transformed(ax.transAxes)\n        r = mpatches.Rectangle((0, 0), 1, 1, clip_on=False,\n                               transform=ax.transAxes)\n        r.set_bounds(bbt.bounds)\n        ax.add_patch(r)\n\n    horal = 'left'\n    for nn, st in enumerate(sts):\n        tt = ax.text(0.2 * nn + 0.1, 0.5, st, horizontalalignment=horal,\n                     verticalalignment='bottom')\n        draw_box(ax, tt)\n    ax.text(1.2, 0.5, 'Bottom align', color='C2')\n\n    ax.axhline(1.3, color='C2', linewidth=0.3)\n    for nn, st in enumerate(sts):\n        tt = ax.text(0.2 * nn + 0.1, 1.3, st, horizontalalignment=horal,\n                     verticalalignment='top')\n        draw_box(ax, tt)\n    ax.text(1.2, 1.3, 'Top align', color='C2')\n\n    ax.axhline(1.8, color='C2', linewidth=0.3)\n    for nn, st in enumerate(sts):\n        tt = ax.text(0.2 * nn + 0.1, 1.8, st, horizontalalignment=horal,\n                     verticalalignment='baseline')\n        draw_box(ax, tt)\n    ax.text(1.2, 1.8, 'Baseline align', color='C2')\n\n    ax.axhline(0.1, color='C2', linewidth=0.3)\n    for nn, st in enumerate(sts):\n        tt = ax.text(0.2 * nn + 0.1, 0.1, st, horizontalalignment=horal,\n                     verticalalignment='bottom', rotation=20)\n        draw_box(ax, tt)\n    ax.text(1.2, 0.1, 'Bot align, rot20', color='C2')",
        "begin_line": 132,
        "end_line": 179,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.draw_box#145",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.draw_box(ax, tt)",
        "snippet": "    def draw_box(ax, tt):\n        bb = tt.get_window_extent(renderer)\n        bbt = bb.inverse_transformed(ax.transAxes)\n        r = mpatches.Rectangle((0, 0), 1, 1, clip_on=False,\n                               transform=ax.transAxes)\n        r.set_bounds(bbt.bounds)\n        ax.add_patch(r)",
        "begin_line": 145,
        "end_line": 151,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_antialiasing#183",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_antialiasing()",
        "snippet": "def test_antialiasing():\n    matplotlib.rcParams['text.antialiased'] = True\n\n    fig = plt.figure(figsize=(5.25, 0.75))\n    fig.text(0.5, 0.75, \"antialiased\", horizontalalignment='center',\n             verticalalignment='center')\n    fig.text(0.5, 0.25, r\"$\\sqrt{x}$\", horizontalalignment='center',\n             verticalalignment='center')",
        "begin_line": 183,
        "end_line": 190,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_afm_kerning#197",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_afm_kerning()",
        "snippet": "def test_afm_kerning():\n    fn = mpl.font_manager.findfont(\"Helvetica\", fontext=\"afm\")\n    with open(fn, 'rb') as fh:\n        afm = mpl.afm.AFM(fh)\n    assert afm.string_width_height('VAVAVAVAVAVA') == (7174.0, 718)",
        "begin_line": 197,
        "end_line": 201,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_contains#205",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_contains()",
        "snippet": "def test_contains():\n    fig = plt.figure()\n    ax = plt.axes()\n\n    mevent = MouseEvent('button_press_event', fig.canvas, 0.5, 0.5, 1, None)\n\n    xs = np.linspace(0.25, 0.75, 30)\n    ys = np.linspace(0.25, 0.75, 30)\n    xs, ys = np.meshgrid(xs, ys)\n\n    txt = plt.text(\n        0.5, 0.4, 'hello world', ha='center', fontsize=30, rotation=30)\n    # uncomment to draw the text's bounding box\n    # txt.set_bbox(dict(edgecolor='black', facecolor='none'))\n\n    # draw the text. This is important, as the contains method can only work\n    # when a renderer exists.\n    fig.canvas.draw()\n\n    for x, y in zip(xs.flat, ys.flat):\n        mevent.x, mevent.y = plt.gca().transAxes.transform([x, y])\n        contains, _ = txt.contains(mevent)\n        color = 'yellow' if contains else 'red'\n\n        # capture the viewLim, plot a point, and reset the viewLim\n        vl = ax.viewLim.frozen()\n        ax.plot(x, y, 'o', color=color)\n        ax.viewLim.set(vl)",
        "begin_line": 205,
        "end_line": 232,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_annotation_contains#235",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_annotation_contains()",
        "snippet": "def test_annotation_contains():\n    # Check that Annotation.contains looks at the bboxes of the text and the\n    # arrow separately, not at the joint bbox.\n    fig, ax = plt.subplots()\n    ann = ax.annotate(\n        \"hello\", xy=(.4, .4), xytext=(.6, .6), arrowprops={\"arrowstyle\": \"->\"})\n    fig.canvas.draw()   # Needed for the same reason as in test_contains.\n    event = MouseEvent(\n        \"button_press_event\", fig.canvas, *ax.transData.transform((.5, .6)))\n    assert ann.contains(event) == (False, {})",
        "begin_line": 235,
        "end_line": 244,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_titles#248",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_titles()",
        "snippet": "def test_titles():\n    # left and right side titles\n    plt.figure()\n    ax = plt.subplot(1, 1, 1)\n    ax.set_title(\"left title\", loc=\"left\")\n    ax.set_title(\"right title\", loc=\"right\")\n    ax.set_xticks([])\n    ax.set_yticks([])",
        "begin_line": 248,
        "end_line": 255,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_alignment#259",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_alignment()",
        "snippet": "def test_alignment():\n    plt.figure()\n    ax = plt.subplot(1, 1, 1)\n\n    x = 0.1\n    for rotation in (0, 30):\n        for alignment in ('top', 'bottom', 'baseline', 'center'):\n            ax.text(\n                x, 0.5, alignment + \" Tj\", va=alignment, rotation=rotation,\n                bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))\n            ax.text(\n                x, 1.0, r'$\\sum_{i=0}^{j}$', va=alignment, rotation=rotation)\n            x += 0.1\n\n    ax.plot([0, 1], [0.5, 0.5])\n    ax.plot([0, 1], [1.0, 1.0])\n\n    ax.set_xlim([0, 1])\n    ax.set_ylim([0, 1.5])\n    ax.set_xticks([])\n    ax.set_yticks([])",
        "begin_line": 259,
        "end_line": 279,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_axes_titles#283",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_axes_titles()",
        "snippet": "def test_axes_titles():\n    # Related to issue #3327\n    plt.figure()\n    ax = plt.subplot(1, 1, 1)\n    ax.set_title('center', loc='center', fontsize=20, fontweight=700)\n    ax.set_title('left', loc='left', fontsize=12, fontweight=400)\n    ax.set_title('right', loc='right', fontsize=12, fontweight=400)",
        "begin_line": 283,
        "end_line": 289,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_set_position#292",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_set_position()",
        "snippet": "def test_set_position():\n    fig, ax = plt.subplots()\n\n    # test set_position\n    ann = ax.annotate(\n        'test', (0, 0), xytext=(0, 0), textcoords='figure pixels')\n    fig.canvas.draw()\n\n    init_pos = ann.get_window_extent(fig.canvas.renderer)\n    shift_val = 15\n    ann.set_position((shift_val, shift_val))\n    fig.canvas.draw()\n    post_pos = ann.get_window_extent(fig.canvas.renderer)\n\n    for a, b in zip(init_pos.min, post_pos.min):\n        assert a + shift_val == b\n\n    # test xyann\n    ann = ax.annotate(\n        'test', (0, 0), xytext=(0, 0), textcoords='figure pixels')\n    fig.canvas.draw()\n\n    init_pos = ann.get_window_extent(fig.canvas.renderer)\n    shift_val = 15\n    ann.xyann = (shift_val, shift_val)\n    fig.canvas.draw()\n    post_pos = ann.get_window_extent(fig.canvas.renderer)\n\n    for a, b in zip(init_pos.min, post_pos.min):\n        assert a + shift_val == b",
        "begin_line": 292,
        "end_line": 321,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_non_default_dpi#325",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_non_default_dpi(text)",
        "snippet": "def test_non_default_dpi(text):\n    fig, ax = plt.subplots()\n\n    t1 = ax.text(0.5, 0.5, text, ha='left', va='bottom')\n    fig.canvas.draw()\n    dpi = fig.dpi\n\n    bbox1 = t1.get_window_extent()\n    bbox2 = t1.get_window_extent(dpi=dpi * 10)\n    np.testing.assert_allclose(bbox2.get_points(), bbox1.get_points() * 10,\n                               rtol=5e-2)\n    # Text.get_window_extent should not permanently change dpi.\n    assert fig.dpi == dpi",
        "begin_line": 325,
        "end_line": 337,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_get_rotation_string#340",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_get_rotation_string()",
        "snippet": "def test_get_rotation_string():\n    assert mpl.text.get_rotation('horizontal') == 0.\n    assert mpl.text.get_rotation('vertical') == 90.\n    assert mpl.text.get_rotation('15.') == 15.",
        "begin_line": 340,
        "end_line": 343,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_get_rotation_float#346",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_get_rotation_float()",
        "snippet": "def test_get_rotation_float():\n    for i in [15., 16.70, 77.4]:\n        assert mpl.text.get_rotation(i) == i",
        "begin_line": 346,
        "end_line": 348,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_get_rotation_int#351",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_get_rotation_int()",
        "snippet": "def test_get_rotation_int():\n    for i in [67, 16, 41]:\n        assert mpl.text.get_rotation(i) == float(i)",
        "begin_line": 351,
        "end_line": 353,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_get_rotation_raises#356",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_get_rotation_raises()",
        "snippet": "def test_get_rotation_raises():\n    with pytest.raises(ValueError):\n        mpl.text.get_rotation('hozirontal')",
        "begin_line": 356,
        "end_line": 358,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_get_rotation_none#361",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_get_rotation_none()",
        "snippet": "def test_get_rotation_none():\n    assert mpl.text.get_rotation(None) == 0.0",
        "begin_line": 361,
        "end_line": 362,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_get_rotation_mod360#365",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_get_rotation_mod360()",
        "snippet": "def test_get_rotation_mod360():\n    for i, j in zip([360., 377., 720+177.2], [0., 17., 177.2]):\n        assert_almost_equal(mpl.text.get_rotation(i), j)",
        "begin_line": 365,
        "end_line": 367,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_null_rotation_with_rotation_mode#373",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_null_rotation_with_rotation_mode(ha, va)",
        "snippet": "def test_null_rotation_with_rotation_mode(ha, va):\n    fig, ax = plt.subplots()\n    kw = dict(rotation=0, va=va, ha=ha)\n    t0 = ax.text(.5, .5, 'test', rotation_mode='anchor', **kw)\n    t1 = ax.text(.5, .5, 'test', rotation_mode='default', **kw)\n    fig.canvas.draw()\n    assert_almost_equal(t0.get_window_extent(fig.canvas.renderer).get_points(),\n                        t1.get_window_extent(fig.canvas.renderer).get_points())",
        "begin_line": 373,
        "end_line": 380,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_bbox_clipping#384",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_bbox_clipping()",
        "snippet": "def test_bbox_clipping():\n    plt.text(0.9, 0.2, 'Is bbox clipped?', backgroundcolor='r', clip_on=True)\n    t = plt.text(0.9, 0.5, 'Is fancy bbox clipped?', clip_on=True)\n    t.set_bbox({\"boxstyle\": \"round, pad=0.1\"})",
        "begin_line": 384,
        "end_line": 387,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_annotation_negative_ax_coords#391",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_annotation_negative_ax_coords()",
        "snippet": "def test_annotation_negative_ax_coords():\n    fig, ax = plt.subplots()\n\n    ax.annotate('+ pts',\n                xytext=[30, 20], textcoords='axes points',\n                xy=[30, 20], xycoords='axes points', fontsize=32)\n    ax.annotate('- pts',\n                xytext=[30, -20], textcoords='axes points',\n                xy=[30, -20], xycoords='axes points', fontsize=32,\n                va='top')\n    ax.annotate('+ frac',\n                xytext=[0.75, 0.05], textcoords='axes fraction',\n                xy=[0.75, 0.05], xycoords='axes fraction', fontsize=32)\n    ax.annotate('- frac',\n                xytext=[0.75, -0.05], textcoords='axes fraction',\n                xy=[0.75, -0.05], xycoords='axes fraction', fontsize=32,\n                va='top')\n\n    ax.annotate('+ pixels',\n                xytext=[160, 25], textcoords='axes pixels',\n                xy=[160, 25], xycoords='axes pixels', fontsize=32)\n    ax.annotate('- pixels',\n                xytext=[160, -25], textcoords='axes pixels',\n                xy=[160, -25], xycoords='axes pixels', fontsize=32,\n                va='top')",
        "begin_line": 391,
        "end_line": 415,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_annotation_negative_fig_coords#419",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_annotation_negative_fig_coords()",
        "snippet": "def test_annotation_negative_fig_coords():\n    fig, ax = plt.subplots()\n\n    ax.annotate('+ pts',\n                xytext=[10, 120], textcoords='figure points',\n                xy=[10, 120], xycoords='figure points', fontsize=32)\n    ax.annotate('- pts',\n                xytext=[-10, 180], textcoords='figure points',\n                xy=[-10, 180], xycoords='figure points', fontsize=32,\n                va='top')\n    ax.annotate('+ frac',\n                xytext=[0.05, 0.55], textcoords='figure fraction',\n                xy=[0.05, 0.55], xycoords='figure fraction', fontsize=32)\n    ax.annotate('- frac',\n                xytext=[-0.05, 0.5], textcoords='figure fraction',\n                xy=[-0.05, 0.5], xycoords='figure fraction', fontsize=32,\n                va='top')\n\n    ax.annotate('+ pixels',\n                xytext=[50, 50], textcoords='figure pixels',\n                xy=[50, 50], xycoords='figure pixels', fontsize=32)\n    ax.annotate('- pixels',\n                xytext=[-50, 100], textcoords='figure pixels',\n                xy=[-50, 100], xycoords='figure pixels', fontsize=32,\n                va='top')",
        "begin_line": 419,
        "end_line": 443,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_text_stale#446",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_text_stale()",
        "snippet": "def test_text_stale():\n    fig, (ax1, ax2) = plt.subplots(1, 2)\n    plt.draw_all()\n    assert not ax1.stale\n    assert not ax2.stale\n    assert not fig.stale\n\n    txt1 = ax1.text(.5, .5, 'aardvark')\n    assert ax1.stale\n    assert txt1.stale\n    assert fig.stale\n\n    ann1 = ax2.annotate('aardvark', xy=[.5, .5])\n    assert ax2.stale\n    assert ann1.stale\n    assert fig.stale\n\n    plt.draw_all()\n    assert not ax1.stale\n    assert not ax2.stale\n    assert not fig.stale",
        "begin_line": 446,
        "end_line": 466,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_agg_text_clip#470",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_agg_text_clip()",
        "snippet": "def test_agg_text_clip():\n    np.random.seed(1)\n    fig, (ax1, ax2) = plt.subplots(2)\n    for x, y in np.random.rand(10, 2):\n        ax1.text(x, y, \"foo\", clip_on=True)\n        ax2.text(x, y, \"foo\")",
        "begin_line": 470,
        "end_line": 475,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_text_size_binding#478",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_text_size_binding()",
        "snippet": "def test_text_size_binding():\n    matplotlib.rcParams['font.size'] = 10\n    fp = mpl.font_manager.FontProperties(size='large')\n    sz1 = fp.get_size_in_points()\n    matplotlib.rcParams['font.size'] = 100\n\n    assert sz1 == fp.get_size_in_points()",
        "begin_line": 478,
        "end_line": 484,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_font_scaling#488",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_font_scaling()",
        "snippet": "def test_font_scaling():\n    matplotlib.rcParams['pdf.fonttype'] = 42\n    fig, ax = plt.subplots(figsize=(6.4, 12.4))\n    ax.xaxis.set_major_locator(plt.NullLocator())\n    ax.yaxis.set_major_locator(plt.NullLocator())\n    ax.set_ylim(-10, 600)\n\n    for i, fs in enumerate(range(4, 43, 2)):\n        ax.text(0.1, i*30, \"{fs} pt font size\".format(fs=fs), fontsize=fs)",
        "begin_line": 488,
        "end_line": 496,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_two_2line_texts#500",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_two_2line_texts(spacing1, spacing2)",
        "snippet": "def test_two_2line_texts(spacing1, spacing2):\n    text_string = 'line1\\nline2'\n    fig = plt.figure()\n    renderer = fig.canvas.get_renderer()\n\n    text1 = plt.text(0.25, 0.5, text_string, linespacing=spacing1)\n    text2 = plt.text(0.25, 0.5, text_string, linespacing=spacing2)\n    fig.canvas.draw()\n\n    box1 = text1.get_window_extent(renderer=renderer)\n    box2 = text2.get_window_extent(renderer=renderer)\n\n    # line spacing only affects height\n    assert box1.width == box2.width\n    if spacing1 == spacing2:\n        assert box1.height == box2.height\n    else:\n        assert box1.height != box2.height",
        "begin_line": 500,
        "end_line": 517,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_nonfinite_pos#520",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_nonfinite_pos()",
        "snippet": "def test_nonfinite_pos():\n    fig, ax = plt.subplots()\n    ax.text(0, np.nan, 'nan')\n    ax.text(np.inf, 0, 'inf')\n    fig.canvas.draw()",
        "begin_line": 520,
        "end_line": 524,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_hinting_factor_backends#527",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_hinting_factor_backends()",
        "snippet": "def test_hinting_factor_backends():\n    plt.rcParams['text.hinting_factor'] = 1\n    fig = plt.figure()\n    t = fig.text(0.5, 0.5, 'some text')\n\n    fig.savefig(io.BytesIO(), format='svg')\n    expected = t.get_window_extent().intervalx\n\n    fig.savefig(io.BytesIO(), format='png')\n    # Backends should apply hinting_factor consistently (within 10%).\n    np.testing.assert_allclose(t.get_window_extent().intervalx, expected,\n                               rtol=0.1)",
        "begin_line": 527,
        "end_line": 538,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_usetex_is_copied#542",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_usetex_is_copied()",
        "snippet": "def test_usetex_is_copied():\n    # Indirectly tests that update_from (which is used to copy tick label\n    # properties) copies usetex state.\n    fig = plt.figure()\n    plt.rcParams[\"text.usetex\"] = False\n    ax1 = fig.add_subplot(121)\n    plt.rcParams[\"text.usetex\"] = True\n    ax2 = fig.add_subplot(122)\n    fig.canvas.draw()\n    for ax, usetex in [(ax1, False), (ax2, True)]:\n        for t in ax.xaxis.majorTicks:\n            assert t.label1.get_usetex() == usetex",
        "begin_line": 542,
        "end_line": 553,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_single_artist_usetex#557",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_single_artist_usetex()",
        "snippet": "def test_single_artist_usetex():\n    # Check that a single artist marked with usetex does not get passed through\n    # the mathtext parser at all (for the Agg backend) (the mathtext parser\n    # currently fails to parse \\frac12, requiring \\frac{1}{2} instead).\n    fig, ax = plt.subplots()\n    ax.text(.5, .5, r\"$\\frac12$\", usetex=True)\n    fig.canvas.draw()",
        "begin_line": 557,
        "end_line": 563,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_text_as_path_opacity#567",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_text_as_path_opacity()",
        "snippet": "def test_text_as_path_opacity():\n    plt.figure()\n    plt.gca().set_axis_off()\n    plt.text(0.25, 0.25, 'c', color=(0, 0, 0, 0.5))\n    plt.text(0.25, 0.5, 'a', alpha=0.5)\n    plt.text(0.25, 0.75, 'x', alpha=0.5, color=(0, 0, 0, 1))",
        "begin_line": 567,
        "end_line": 572,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_text_as_text_opacity#576",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_text_as_text_opacity()",
        "snippet": "def test_text_as_text_opacity():\n    matplotlib.rcParams['svg.fonttype'] = 'none'\n    plt.figure()\n    plt.gca().set_axis_off()\n    plt.text(0.25, 0.25, '50% using `color`', color=(0, 0, 0, 0.5))\n    plt.text(0.25, 0.5, '50% using `alpha`', alpha=0.5)\n    plt.text(0.25, 0.75, '50% using `alpha` and 100% `color`', alpha=0.5,\n             color=(0, 0, 0, 1))",
        "begin_line": 576,
        "end_line": 583,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_text_repr#586",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_text_repr()",
        "snippet": "def test_text_repr():\n    # smoketest to make sure text repr doesn't error for category\n    plt.plot(['A', 'B'], [1, 2])\n    txt = plt.text(['A'], 0.5, 'Boo')\n    print(txt)",
        "begin_line": 586,
        "end_line": 590,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_annotation_update#593",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_annotation_update()",
        "snippet": "def test_annotation_update():\n    fig, ax = plt.subplots(1, 1)\n    an = ax.annotate('annotation', xy=(0.5, 0.5))\n    extent1 = an.get_window_extent(fig.canvas.get_renderer())\n    fig.tight_layout()\n    extent2 = an.get_window_extent(fig.canvas.get_renderer())\n\n    assert not np.allclose(extent1.get_points(), extent2.get_points(),\n                           rtol=1e-6)",
        "begin_line": 593,
        "end_line": 601,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_annotation_units#605",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_annotation_units(fig_test, fig_ref)",
        "snippet": "def test_annotation_units(fig_test, fig_ref):\n    ax = fig_test.add_subplot()\n    ax.plot(datetime.now(), 1, \"o\")  # Implicitly set axes extents.\n    ax.annotate(\"x\", (datetime.now(), 0.5), xycoords=(\"data\", \"axes fraction\"),\n                # This used to crash before.\n                xytext=(0, 0), textcoords=\"offset points\")\n    ax = fig_ref.add_subplot()\n    ax.plot(datetime.now(), 1, \"o\")\n    ax.annotate(\"x\", (datetime.now(), 0.5), xycoords=(\"data\", \"axes fraction\"))",
        "begin_line": 605,
        "end_line": 613,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_large_subscript_title#617",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_large_subscript_title()",
        "snippet": "def test_large_subscript_title():\n    # Remove this line when this test image is regenerated.\n    plt.rcParams['text.kerning_factor'] = 6\n\n    fig, axs = plt.subplots(1, 2, figsize=(9, 2.5), constrained_layout=True)\n    ax = axs[0]\n    ax.set_title(r'$\\sum_{i} x_i$')\n    ax.set_title('New way', loc='left')\n    ax.set_xticklabels('')\n\n    ax = axs[1]\n    tt = ax.set_title(r'$\\sum_{i} x_i$')\n    x, y = tt.get_position()\n    tt.set_position((x, 1.01))\n    ax.set_title('Old Way', loc='left')\n    ax.set_xticklabels('')",
        "begin_line": 617,
        "end_line": 632,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_wrap#635",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_wrap()",
        "snippet": "def test_wrap():\n    fig = plt.figure(figsize=(6, 4))\n    s = 'This is a very long text that should be wrapped multiple times.'\n    text = fig.text(0.7, 0.5, s, wrap=True)\n    fig.canvas.draw()\n    assert text._get_wrapped_text() == ('This is a very long\\n'\n                                        'text that should be\\n'\n                                        'wrapped multiple\\n'\n                                        'times.')",
        "begin_line": 635,
        "end_line": 643,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_long_word_wrap#646",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_long_word_wrap()",
        "snippet": "def test_long_word_wrap():\n    fig = plt.figure(figsize=(6, 4))\n    text = fig.text(9.5, 8, 'Alonglineoftexttowrap', wrap=True)\n    fig.canvas.draw()\n    assert text._get_wrapped_text() == 'Alonglineoftexttowrap'",
        "begin_line": 646,
        "end_line": 650,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_wrap_no_wrap#653",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_wrap_no_wrap()",
        "snippet": "def test_wrap_no_wrap():\n    fig = plt.figure(figsize=(6, 4))\n    text = fig.text(0, 0, 'non wrapped text', wrap=True)\n    fig.canvas.draw()\n    assert text._get_wrapped_text() == 'non wrapped text'",
        "begin_line": 653,
        "end_line": 657,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_buffer_size#661",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_buffer_size(fig_test, fig_ref)",
        "snippet": "def test_buffer_size(fig_test, fig_ref):\n    # On old versions of the Agg renderer, large non-ascii single-character\n    # strings (here, \"\u20ac\") would be rendered clipped because the rendering\n    # buffer would be set by the physical size of the smaller \"a\" character.\n    ax = fig_test.add_subplot()\n    ax.set_yticks([0, 1])\n    ax.set_yticklabels([\"\u20ac\", \"a\"])\n    ax.yaxis.majorTicks[1].label1.set_color(\"w\")\n    ax = fig_ref.add_subplot()\n    ax.set_yticks([0, 1])\n    ax.set_yticklabels([\"\u20ac\", \"\"])",
        "begin_line": 661,
        "end_line": 671,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_text.test_fontproperties_kwarg_precedence#674",
        "src_path": "lib/matplotlib/tests/test_text.py",
        "class_name": "lib.matplotlib.tests.test_text",
        "signature": "lib.matplotlib.tests.test_text.test_fontproperties_kwarg_precedence()",
        "snippet": "def test_fontproperties_kwarg_precedence():\n    \"\"\"Test that kwargs take precedence over fontproperties defaults.\"\"\"\n    plt.figure()\n    text1 = plt.xlabel(\"value\", fontproperties='Times New Roman', size=40.0)\n    text2 = plt.ylabel(\"counts\", size=40.0, fontproperties='Times New Roman')\n    assert text1.get_size() == 40.0\n    assert text2.get_size() == 40.0",
        "begin_line": 674,
        "end_line": 680,
        "comment": "",
        "is_bug": false
    }
]