[
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_describe#28",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_describe(self)",
        "snippet": "    def test_describe(self):\n        s = Series([0, 1, 2, 3, 4], name=\"int_data\")\n        result = s.describe()\n        expected = Series(\n            [5, 2, s.std(), 0, 1, 2, 3, 4],\n            name=\"int_data\",\n            index=[\"count\", \"mean\", \"std\", \"min\", \"25%\", \"50%\", \"75%\", \"max\"],\n        )\n        tm.assert_series_equal(result, expected)\n\n        s = Series([True, True, False, False, False], name=\"bool_data\")\n        result = s.describe()\n        expected = Series(\n            [5, 2, False, 3], name=\"bool_data\", index=[\"count\", \"unique\", \"top\", \"freq\"]\n        )\n        tm.assert_series_equal(result, expected)\n\n        s = Series([\"a\", \"a\", \"b\", \"c\", \"d\"], name=\"str_data\")\n        result = s.describe()\n        expected = Series(\n            [5, 4, \"a\", 2], name=\"str_data\", index=[\"count\", \"unique\", \"top\", \"freq\"]\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 28,
        "end_line": 50,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_describe_empty_object#52",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_describe_empty_object(self)",
        "snippet": "    def test_describe_empty_object(self):\n        # https://github.com/pandas-dev/pandas/issues/27183\n        s = pd.Series([None, None], dtype=object)\n        result = s.describe()\n        expected = pd.Series(\n            [0, 0, np.nan, np.nan],\n            dtype=object,\n            index=[\"count\", \"unique\", \"top\", \"freq\"],\n        )\n        tm.assert_series_equal(result, expected)\n\n        result = s[:0].describe()\n        tm.assert_series_equal(result, expected)\n        # ensure NaN, not None\n        assert np.isnan(result.iloc[2])\n        assert np.isnan(result.iloc[3])",
        "begin_line": 52,
        "end_line": 67,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_describe_with_tz#69",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_describe_with_tz(self, tz_naive_fixture)",
        "snippet": "    def test_describe_with_tz(self, tz_naive_fixture):\n        # GH 21332\n        tz = tz_naive_fixture\n        name = str(tz_naive_fixture)\n        start = Timestamp(2018, 1, 1)\n        end = Timestamp(2018, 1, 5)\n        s = Series(date_range(start, end, tz=tz), name=name)\n        result = s.describe()\n        expected = Series(\n            [\n                5,\n                5,\n                s.value_counts().index[0],\n                1,\n                start.tz_localize(tz),\n                end.tz_localize(tz),\n            ],\n            name=name,\n            index=[\"count\", \"unique\", \"top\", \"freq\", \"first\", \"last\"],\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 69,
        "end_line": 89,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_argsort#91",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_argsort(self, datetime_series)",
        "snippet": "    def test_argsort(self, datetime_series):\n        self._check_accum_op(\"argsort\", datetime_series, check_dtype=False)\n        argsorted = datetime_series.argsort()\n        assert issubclass(argsorted.dtype.type, np.integer)\n\n        # GH 2967 (introduced bug in 0.11-dev I think)\n        s = Series([Timestamp(\"201301{i:02d}\".format(i=i)) for i in range(1, 6)])\n        assert s.dtype == \"datetime64[ns]\"\n        shifted = s.shift(-1)\n        assert shifted.dtype == \"datetime64[ns]\"\n        assert isna(shifted[4])\n\n        result = s.argsort()\n        expected = Series(range(5), dtype=\"int64\")\n        tm.assert_series_equal(result, expected)\n\n        result = shifted.argsort()\n        expected = Series(list(range(4)) + [-1], dtype=\"int64\")\n        tm.assert_series_equal(result, expected)",
        "begin_line": 91,
        "end_line": 109,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_argsort_stable#111",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_argsort_stable(self)",
        "snippet": "    def test_argsort_stable(self):\n        s = Series(np.random.randint(0, 100, size=10000))\n        mindexer = s.argsort(kind=\"mergesort\")\n        qindexer = s.argsort()\n\n        mexpected = np.argsort(s.values, kind=\"mergesort\")\n        qexpected = np.argsort(s.values, kind=\"quicksort\")\n\n        tm.assert_series_equal(mindexer, Series(mexpected), check_dtype=False)\n        tm.assert_series_equal(qindexer, Series(qexpected), check_dtype=False)\n        msg = (\n            r\"ndarray Expected type <class 'numpy\\.ndarray'>,\"\n            r\" found <class 'pandas\\.core\\.series\\.Series'> instead\"\n        )\n        with pytest.raises(AssertionError, match=msg):\n            tm.assert_numpy_array_equal(qindexer, mindexer)",
        "begin_line": 111,
        "end_line": 126,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cumsum#128",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cumsum(self, datetime_series)",
        "snippet": "    def test_cumsum(self, datetime_series):\n        self._check_accum_op(\"cumsum\", datetime_series)",
        "begin_line": 128,
        "end_line": 129,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cumprod#131",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cumprod(self, datetime_series)",
        "snippet": "    def test_cumprod(self, datetime_series):\n        self._check_accum_op(\"cumprod\", datetime_series)",
        "begin_line": 131,
        "end_line": 132,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cummin#134",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cummin(self, datetime_series)",
        "snippet": "    def test_cummin(self, datetime_series):\n        tm.assert_numpy_array_equal(\n            datetime_series.cummin().values,\n            np.minimum.accumulate(np.array(datetime_series)),\n        )\n        ts = datetime_series.copy()\n        ts[::2] = np.NaN\n        result = ts.cummin()[1::2]\n        expected = np.minimum.accumulate(ts.dropna())\n\n        tm.assert_series_equal(result, expected)",
        "begin_line": 134,
        "end_line": 144,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cummax#146",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cummax(self, datetime_series)",
        "snippet": "    def test_cummax(self, datetime_series):\n        tm.assert_numpy_array_equal(\n            datetime_series.cummax().values,\n            np.maximum.accumulate(np.array(datetime_series)),\n        )\n        ts = datetime_series.copy()\n        ts[::2] = np.NaN\n        result = ts.cummax()[1::2]\n        expected = np.maximum.accumulate(ts.dropna())\n\n        tm.assert_series_equal(result, expected)",
        "begin_line": 146,
        "end_line": 156,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cummin_datetime64#161",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cummin_datetime64(self)",
        "snippet": "    def test_cummin_datetime64(self):\n        s = pd.Series(\n            pd.to_datetime([\"NaT\", \"2000-1-2\", \"NaT\", \"2000-1-1\", \"NaT\", \"2000-1-3\"])\n        )\n\n        expected = pd.Series(\n            pd.to_datetime([\"NaT\", \"2000-1-2\", \"NaT\", \"2000-1-1\", \"NaT\", \"2000-1-1\"])\n        )\n        result = s.cummin(skipna=True)\n        tm.assert_series_equal(expected, result)\n\n        expected = pd.Series(\n            pd.to_datetime(\n                [\"NaT\", \"2000-1-2\", \"2000-1-2\", \"2000-1-1\", \"2000-1-1\", \"2000-1-1\"]\n            )\n        )\n        result = s.cummin(skipna=False)\n        tm.assert_series_equal(expected, result)",
        "begin_line": 161,
        "end_line": 178,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cummax_datetime64#183",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cummax_datetime64(self)",
        "snippet": "    def test_cummax_datetime64(self):\n        s = pd.Series(\n            pd.to_datetime([\"NaT\", \"2000-1-2\", \"NaT\", \"2000-1-1\", \"NaT\", \"2000-1-3\"])\n        )\n\n        expected = pd.Series(\n            pd.to_datetime([\"NaT\", \"2000-1-2\", \"NaT\", \"2000-1-2\", \"NaT\", \"2000-1-3\"])\n        )\n        result = s.cummax(skipna=True)\n        tm.assert_series_equal(expected, result)\n\n        expected = pd.Series(\n            pd.to_datetime(\n                [\"NaT\", \"2000-1-2\", \"2000-1-2\", \"2000-1-2\", \"2000-1-2\", \"2000-1-3\"]\n            )\n        )\n        result = s.cummax(skipna=False)\n        tm.assert_series_equal(expected, result)",
        "begin_line": 183,
        "end_line": 200,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cummin_timedelta64#205",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cummin_timedelta64(self)",
        "snippet": "    def test_cummin_timedelta64(self):\n        s = pd.Series(pd.to_timedelta([\"NaT\", \"2 min\", \"NaT\", \"1 min\", \"NaT\", \"3 min\"]))\n\n        expected = pd.Series(\n            pd.to_timedelta([\"NaT\", \"2 min\", \"NaT\", \"1 min\", \"NaT\", \"1 min\"])\n        )\n        result = s.cummin(skipna=True)\n        tm.assert_series_equal(expected, result)\n\n        expected = pd.Series(\n            pd.to_timedelta([\"NaT\", \"2 min\", \"2 min\", \"1 min\", \"1 min\", \"1 min\"])\n        )\n        result = s.cummin(skipna=False)\n        tm.assert_series_equal(expected, result)",
        "begin_line": 205,
        "end_line": 218,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cummax_timedelta64#223",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cummax_timedelta64(self)",
        "snippet": "    def test_cummax_timedelta64(self):\n        s = pd.Series(pd.to_timedelta([\"NaT\", \"2 min\", \"NaT\", \"1 min\", \"NaT\", \"3 min\"]))\n\n        expected = pd.Series(\n            pd.to_timedelta([\"NaT\", \"2 min\", \"NaT\", \"2 min\", \"NaT\", \"3 min\"])\n        )\n        result = s.cummax(skipna=True)\n        tm.assert_series_equal(expected, result)\n\n        expected = pd.Series(\n            pd.to_timedelta([\"NaT\", \"2 min\", \"2 min\", \"2 min\", \"2 min\", \"3 min\"])\n        )\n        result = s.cummax(skipna=False)\n        tm.assert_series_equal(expected, result)",
        "begin_line": 223,
        "end_line": 236,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_np_diff#238",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_np_diff(self)",
        "snippet": "    def test_np_diff(self):\n        pytest.skip(\"skipping due to Series no longer being an ndarray\")\n\n        # no longer works as the return type of np.diff is now nd.array\n        s = Series(np.arange(5))\n\n        r = np.diff(s)\n        tm.assert_series_equal(Series([np.nan, 0, 0, 0, np.nan]), r)",
        "begin_line": 238,
        "end_line": 245,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_int_diff#247",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_int_diff(self)",
        "snippet": "    def test_int_diff(self):\n        # int dtype\n        a = 10000000000000000\n        b = a + 1\n        s = Series([a, b])\n\n        result = s.diff()\n        assert result[1] == 1",
        "begin_line": 247,
        "end_line": 254,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_tz_diff#256",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_tz_diff(self)",
        "snippet": "    def test_tz_diff(self):\n        # Combined datetime diff, normal diff and boolean diff test\n        ts = tm.makeTimeSeries(name=\"ts\")\n        ts.diff()\n\n        # neg n\n        result = ts.diff(-1)\n        expected = ts - ts.shift(-1)\n        tm.assert_series_equal(result, expected)\n\n        # 0\n        result = ts.diff(0)\n        expected = ts - ts\n        tm.assert_series_equal(result, expected)\n\n        # datetime diff (GH3100)\n        s = Series(date_range(\"20130102\", periods=5))\n        result = s.diff()\n        expected = s - s.shift(1)\n        tm.assert_series_equal(result, expected)\n\n        # timedelta diff\n        result = result - result.shift(1)  # previous result\n        expected = expected.diff()  # previously expected\n        tm.assert_series_equal(result, expected)\n\n        # with tz\n        s = Series(\n            date_range(\"2000-01-01 09:00:00\", periods=5, tz=\"US/Eastern\"), name=\"foo\"\n        )\n        result = s.diff()\n        expected = Series(TimedeltaIndex([\"NaT\"] + [\"1 days\"] * 4), name=\"foo\")\n        tm.assert_series_equal(result, expected)",
        "begin_line": 256,
        "end_line": 288,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_bool_diff#294",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_bool_diff(self, input, output, diff)",
        "snippet": "    def test_bool_diff(self, input, output, diff):\n        # boolean series (test for fixing #17294)\n        s = Series(input)\n        result = s.diff()\n        expected = Series(output)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 294,
        "end_line": 299,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_obj_diff#301",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_obj_diff(self)",
        "snippet": "    def test_obj_diff(self):\n        # object series\n        s = Series([False, True, 5.0, np.nan, True, False])\n        result = s.diff()\n        expected = s - s.shift(1)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 301,
        "end_line": 306,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics._check_accum_op#308",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics._check_accum_op(self, name, datetime_series_, check_dtype=True)",
        "snippet": "    def _check_accum_op(self, name, datetime_series_, check_dtype=True):\n        func = getattr(np, name)\n        tm.assert_numpy_array_equal(\n            func(datetime_series_).values,\n            func(np.array(datetime_series_)),\n            check_dtype=check_dtype,\n        )\n\n        # with missing values\n        ts = datetime_series_.copy()\n        ts[::2] = np.NaN\n\n        result = func(ts)[1::2]\n        expected = func(np.array(ts.dropna()))\n\n        tm.assert_numpy_array_equal(result.values, expected, check_dtype=False)",
        "begin_line": 308,
        "end_line": 323,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_compress#325",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_compress(self)",
        "snippet": "    def test_compress(self):\n        cond = [True, False, True, False, False]\n        s = Series([1, -1, 5, 8, 7], index=list(\"abcde\"), name=\"foo\")\n        expected = Series(s.values.compress(cond), index=list(\"ac\"), name=\"foo\")\n        with tm.assert_produces_warning(FutureWarning):\n            result = s.compress(cond)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 325,
        "end_line": 331,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_numpy_compress#333",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_numpy_compress(self)",
        "snippet": "    def test_numpy_compress(self):\n        cond = [True, False, True, False, False]\n        s = Series([1, -1, 5, 8, 7], index=list(\"abcde\"), name=\"foo\")\n        expected = Series(s.values.compress(cond), index=list(\"ac\"), name=\"foo\")\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            tm.assert_series_equal(np.compress(cond, s), expected)\n\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            msg = \"the 'axis' parameter is not supported\"\n            with pytest.raises(ValueError, match=msg):\n                np.compress(cond, s, axis=1)\n\n            msg = \"the 'out' parameter is not supported\"\n            with pytest.raises(ValueError, match=msg):\n                np.compress(cond, s, out=s)",
        "begin_line": 333,
        "end_line": 347,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_round#349",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_round(self, datetime_series)",
        "snippet": "    def test_round(self, datetime_series):\n        datetime_series.index.name = \"index_name\"\n        result = datetime_series.round(2)\n        expected = Series(\n            np.round(datetime_series.values, 2), index=datetime_series.index, name=\"ts\"\n        )\n        tm.assert_series_equal(result, expected)\n        assert result.name == datetime_series.name",
        "begin_line": 349,
        "end_line": 356,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_numpy_round#358",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_numpy_round(self)",
        "snippet": "    def test_numpy_round(self):\n        # See gh-12600\n        s = Series([1.53, 1.36, 0.06])\n        out = np.round(s, decimals=0)\n        expected = Series([2.0, 1.0, 0.0])\n        tm.assert_series_equal(out, expected)\n\n        msg = \"the 'out' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            np.round(s, decimals=0, out=s)",
        "begin_line": 358,
        "end_line": 367,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_numpy_round_nan#369",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_numpy_round_nan(self)",
        "snippet": "    def test_numpy_round_nan(self):\n        # See gh-14197\n        s = Series([1.53, np.nan, 0.06])\n        with tm.assert_produces_warning(None):\n            result = s.round()\n        expected = Series([2.0, np.nan, 0.0])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 369,
        "end_line": 375,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_built_in_round#377",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_built_in_round(self)",
        "snippet": "    def test_built_in_round(self):\n        s = Series([1.123, 2.123, 3.123], index=range(3))\n        result = round(s)\n        expected_rounded0 = Series([1.0, 2.0, 3.0], index=range(3))\n        tm.assert_series_equal(result, expected_rounded0)\n\n        decimals = 2\n        expected_rounded = Series([1.12, 2.12, 3.12], index=range(3))\n        result = round(s, decimals)\n        tm.assert_series_equal(result, expected_rounded)",
        "begin_line": 377,
        "end_line": 386,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_prod_numpy16_bug#388",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_prod_numpy16_bug(self)",
        "snippet": "    def test_prod_numpy16_bug(self):\n        s = Series([1.0, 1.0, 1.0], index=range(3))\n        result = s.prod()\n\n        assert not isinstance(result, Series)",
        "begin_line": 388,
        "end_line": 392,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_corr#395",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_corr(self, datetime_series)",
        "snippet": "    def test_corr(self, datetime_series):\n        import scipy.stats as stats\n\n        # full overlap\n        tm.assert_almost_equal(datetime_series.corr(datetime_series), 1)\n\n        # partial overlap\n        tm.assert_almost_equal(datetime_series[:15].corr(datetime_series[5:]), 1)\n\n        assert isna(datetime_series[:15].corr(datetime_series[5:], min_periods=12))\n\n        ts1 = datetime_series[:15].reindex(datetime_series.index)\n        ts2 = datetime_series[5:].reindex(datetime_series.index)\n        assert isna(ts1.corr(ts2, min_periods=12))\n\n        # No overlap\n        assert np.isnan(datetime_series[::2].corr(datetime_series[1::2]))\n\n        # all NA\n        cp = datetime_series[:10].copy()\n        cp[:] = np.nan\n        assert isna(cp.corr(cp))\n\n        A = tm.makeTimeSeries()\n        B = tm.makeTimeSeries()\n        result = A.corr(B)\n        expected, _ = stats.pearsonr(A, B)\n        tm.assert_almost_equal(result, expected)",
        "begin_line": 395,
        "end_line": 422,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_corr_rank#425",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_corr_rank(self)",
        "snippet": "    def test_corr_rank(self):\n        import scipy.stats as stats\n\n        # kendall and spearman\n        A = tm.makeTimeSeries()\n        B = tm.makeTimeSeries()\n        A[-5:] = A[:5]\n        result = A.corr(B, method=\"kendall\")\n        expected = stats.kendalltau(A, B)[0]\n        tm.assert_almost_equal(result, expected)\n\n        result = A.corr(B, method=\"spearman\")\n        expected = stats.spearmanr(A, B)[0]\n        tm.assert_almost_equal(result, expected)\n\n        # results from R\n        A = Series(\n            [\n                -0.89926396,\n                0.94209606,\n                -1.03289164,\n                -0.95445587,\n                0.76910310,\n                -0.06430576,\n                -2.09704447,\n                0.40660407,\n                -0.89926396,\n                0.94209606,\n            ]\n        )\n        B = Series(\n            [\n                -1.01270225,\n                -0.62210117,\n                -1.56895827,\n                0.59592943,\n                -0.01680292,\n                1.17258718,\n                -1.06009347,\n                -0.10222060,\n                -0.89076239,\n                0.89372375,\n            ]\n        )\n        kexp = 0.4319297\n        sexp = 0.5853767\n        tm.assert_almost_equal(A.corr(B, method=\"kendall\"), kexp)\n        tm.assert_almost_equal(A.corr(B, method=\"spearman\"), sexp)",
        "begin_line": 425,
        "end_line": 472,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_corr_invalid_method#474",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_corr_invalid_method(self)",
        "snippet": "    def test_corr_invalid_method(self):\n        # GH PR #22298\n        s1 = pd.Series(np.random.randn(10))\n        s2 = pd.Series(np.random.randn(10))\n        msg = \"method must be either 'pearson', 'spearman', 'kendall', or a callable, \"\n        with pytest.raises(ValueError, match=msg):\n            s1.corr(s2, method=\"____\")",
        "begin_line": 474,
        "end_line": 480,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_corr_callable_method#482",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_corr_callable_method(self, datetime_series)",
        "snippet": "    def test_corr_callable_method(self, datetime_series):\n        # simple correlation example\n        # returns 1 if exact equality, 0 otherwise\n        my_corr = lambda a, b: 1.0 if (a == b).all() else 0.0\n\n        # simple example\n        s1 = Series([1, 2, 3, 4, 5])\n        s2 = Series([5, 4, 3, 2, 1])\n        expected = 0\n        tm.assert_almost_equal(s1.corr(s2, method=my_corr), expected)\n\n        # full overlap\n        tm.assert_almost_equal(\n            datetime_series.corr(datetime_series, method=my_corr), 1.0\n        )\n\n        # partial overlap\n        tm.assert_almost_equal(\n            datetime_series[:15].corr(datetime_series[5:], method=my_corr), 1.0\n        )\n\n        # No overlap\n        assert np.isnan(\n            datetime_series[::2].corr(datetime_series[1::2], method=my_corr)\n        )\n\n        # dataframe example\n        df = pd.DataFrame([s1, s2])\n        expected = pd.DataFrame([{0: 1.0, 1: 0}, {0: 0, 1: 1.0}])\n        tm.assert_almost_equal(df.transpose().corr(method=my_corr), expected)",
        "begin_line": 482,
        "end_line": 511,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cov#513",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cov(self, datetime_series)",
        "snippet": "    def test_cov(self, datetime_series):\n        # full overlap\n        tm.assert_almost_equal(\n            datetime_series.cov(datetime_series), datetime_series.std() ** 2\n        )\n\n        # partial overlap\n        tm.assert_almost_equal(\n            datetime_series[:15].cov(datetime_series[5:]),\n            datetime_series[5:15].std() ** 2,\n        )\n\n        # No overlap\n        assert np.isnan(datetime_series[::2].cov(datetime_series[1::2]))\n\n        # all NA\n        cp = datetime_series[:10].copy()\n        cp[:] = np.nan\n        assert isna(cp.cov(cp))\n\n        # min_periods\n        assert isna(datetime_series[:15].cov(datetime_series[5:], min_periods=12))\n\n        ts1 = datetime_series[:15].reindex(datetime_series.index)\n        ts2 = datetime_series[5:].reindex(datetime_series.index)\n        assert isna(ts1.cov(ts2, min_periods=12))",
        "begin_line": 513,
        "end_line": 538,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_count#540",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_count(self, datetime_series)",
        "snippet": "    def test_count(self, datetime_series):\n        assert datetime_series.count() == len(datetime_series)\n\n        datetime_series[::2] = np.NaN\n\n        assert datetime_series.count() == np.isfinite(datetime_series).sum()\n\n        mi = MultiIndex.from_arrays([list(\"aabbcc\"), [1, 2, 2, np.nan, 1, 2]])\n        ts = Series(np.arange(len(mi)), index=mi)\n\n        left = ts.count(level=1)\n        right = Series([2, 3, 1], index=[1, 2, np.nan])\n        tm.assert_series_equal(left, right)\n\n        ts.iloc[[0, 3, 5]] = np.nan\n        tm.assert_series_equal(ts.count(level=1), right - 1)\n\n        # GH29478\n        with pd.option_context(\"use_inf_as_na\", True):\n            assert pd.Series([pd.Timestamp(\"1990/1/1\")]).count() == 1",
        "begin_line": 540,
        "end_line": 559,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_dot#561",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_dot(self)",
        "snippet": "    def test_dot(self):\n        a = Series(np.random.randn(4), index=[\"p\", \"q\", \"r\", \"s\"])\n        b = DataFrame(\n            np.random.randn(3, 4), index=[\"1\", \"2\", \"3\"], columns=[\"p\", \"q\", \"r\", \"s\"]\n        ).T\n\n        result = a.dot(b)\n        expected = Series(np.dot(a.values, b.values), index=[\"1\", \"2\", \"3\"])\n        tm.assert_series_equal(result, expected)\n\n        # Check index alignment\n        b2 = b.reindex(index=reversed(b.index))\n        result = a.dot(b)\n        tm.assert_series_equal(result, expected)\n\n        # Check ndarray argument\n        result = a.dot(b.values)\n        assert np.all(result == expected.values)\n        tm.assert_almost_equal(a.dot(b[\"2\"].values), expected[\"2\"])\n\n        # Check series argument\n        tm.assert_almost_equal(a.dot(b[\"1\"]), expected[\"1\"])\n        tm.assert_almost_equal(a.dot(b2[\"1\"]), expected[\"1\"])\n\n        msg = r\"Dot product shape mismatch, \\(4,\\) vs \\(3,\\)\"\n        # exception raised is of type Exception\n        with pytest.raises(Exception, match=msg):\n            a.dot(a.values[:3])\n        msg = \"matrices are not aligned\"\n        with pytest.raises(ValueError, match=msg):\n            a.dot(b.T)",
        "begin_line": 561,
        "end_line": 591,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_matmul#593",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_matmul(self)",
        "snippet": "    def test_matmul(self):\n        # matmul test is for GH #10259\n        a = Series(np.random.randn(4), index=[\"p\", \"q\", \"r\", \"s\"])\n        b = DataFrame(\n            np.random.randn(3, 4), index=[\"1\", \"2\", \"3\"], columns=[\"p\", \"q\", \"r\", \"s\"]\n        ).T\n\n        # Series @ DataFrame -> Series\n        result = operator.matmul(a, b)\n        expected = Series(np.dot(a.values, b.values), index=[\"1\", \"2\", \"3\"])\n        tm.assert_series_equal(result, expected)\n\n        # DataFrame @ Series -> Series\n        result = operator.matmul(b.T, a)\n        expected = Series(np.dot(b.T.values, a.T.values), index=[\"1\", \"2\", \"3\"])\n        tm.assert_series_equal(result, expected)\n\n        # Series @ Series -> scalar\n        result = operator.matmul(a, a)\n        expected = np.dot(a.values, a.values)\n        tm.assert_almost_equal(result, expected)\n\n        # GH 21530\n        # vector (1D np.array) @ Series (__rmatmul__)\n        result = operator.matmul(a.values, a)\n        expected = np.dot(a.values, a.values)\n        tm.assert_almost_equal(result, expected)\n\n        # GH 21530\n        # vector (1D list) @ Series (__rmatmul__)\n        result = operator.matmul(a.values.tolist(), a)\n        expected = np.dot(a.values, a.values)\n        tm.assert_almost_equal(result, expected)\n\n        # GH 21530\n        # matrix (2D np.array) @ Series (__rmatmul__)\n        result = operator.matmul(b.T.values, a)\n        expected = np.dot(b.T.values, a.values)\n        tm.assert_almost_equal(result, expected)\n\n        # GH 21530\n        # matrix (2D nested lists) @ Series (__rmatmul__)\n        result = operator.matmul(b.T.values.tolist(), a)\n        expected = np.dot(b.T.values, a.values)\n        tm.assert_almost_equal(result, expected)\n\n        # mixed dtype DataFrame @ Series\n        a[\"p\"] = int(a.p)\n        result = operator.matmul(b.T, a)\n        expected = Series(np.dot(b.T.values, a.T.values), index=[\"1\", \"2\", \"3\"])\n        tm.assert_series_equal(result, expected)\n\n        # different dtypes DataFrame @ Series\n        a = a.astype(int)\n        result = operator.matmul(b.T, a)\n        expected = Series(np.dot(b.T.values, a.T.values), index=[\"1\", \"2\", \"3\"])\n        tm.assert_series_equal(result, expected)\n\n        msg = r\"Dot product shape mismatch, \\(4,\\) vs \\(3,\\)\"\n        # exception raised is of type Exception\n        with pytest.raises(Exception, match=msg):\n            a.dot(a.values[:3])\n        msg = \"matrices are not aligned\"\n        with pytest.raises(ValueError, match=msg):\n            a.dot(b.T)",
        "begin_line": 593,
        "end_line": 657,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_clip#659",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_clip(self, datetime_series)",
        "snippet": "    def test_clip(self, datetime_series):\n        val = datetime_series.median()\n\n        assert datetime_series.clip(lower=val).min() == val\n        assert datetime_series.clip(upper=val).max() == val\n\n        result = datetime_series.clip(-0.5, 0.5)\n        expected = np.clip(datetime_series, -0.5, 0.5)\n        tm.assert_series_equal(result, expected)\n        assert isinstance(expected, Series)",
        "begin_line": 659,
        "end_line": 668,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_clip_types_and_nulls#670",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_clip_types_and_nulls(self)",
        "snippet": "    def test_clip_types_and_nulls(self):\n\n        sers = [\n            Series([np.nan, 1.0, 2.0, 3.0]),\n            Series([None, \"a\", \"b\", \"c\"]),\n            Series(pd.to_datetime([np.nan, 1, 2, 3], unit=\"D\")),\n        ]\n\n        for s in sers:\n            thresh = s[2]\n            lower = s.clip(lower=thresh)\n            upper = s.clip(upper=thresh)\n            assert lower[notna(lower)].min() == thresh\n            assert upper[notna(upper)].max() == thresh\n            assert list(isna(s)) == list(isna(lower))\n            assert list(isna(s)) == list(isna(upper))",
        "begin_line": 670,
        "end_line": 685,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_clip_with_na_args#687",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_clip_with_na_args(self)",
        "snippet": "    def test_clip_with_na_args(self):\n        \"\"\"Should process np.nan argument as None \"\"\"\n        # GH # 17276\n        s = Series([1, 2, 3])\n\n        tm.assert_series_equal(s.clip(np.nan), Series([1, 2, 3]))\n        tm.assert_series_equal(s.clip(upper=np.nan, lower=np.nan), Series([1, 2, 3]))\n\n        # GH #19992\n        tm.assert_series_equal(s.clip(lower=[0, 4, np.nan]), Series([1, 4, np.nan]))\n        tm.assert_series_equal(s.clip(upper=[1, np.nan, 1]), Series([1, np.nan, 1]))",
        "begin_line": 687,
        "end_line": 697,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_clip_against_series#699",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_clip_against_series(self)",
        "snippet": "    def test_clip_against_series(self):\n        # GH #6966\n\n        s = Series([1.0, 1.0, 4.0])\n\n        lower = Series([1.0, 2.0, 3.0])\n        upper = Series([1.5, 2.5, 3.5])\n\n        tm.assert_series_equal(s.clip(lower, upper), Series([1.0, 2.0, 3.5]))\n        tm.assert_series_equal(s.clip(1.5, upper), Series([1.5, 1.5, 3.5]))",
        "begin_line": 699,
        "end_line": 708,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_clip_against_list_like#712",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_clip_against_list_like(self, inplace, upper)",
        "snippet": "    def test_clip_against_list_like(self, inplace, upper):\n        # GH #15390\n        original = pd.Series([5, 6, 7])\n        result = original.clip(upper=upper, inplace=inplace)\n        expected = pd.Series([1, 2, 3])\n\n        if inplace:\n            result = original\n        tm.assert_series_equal(result, expected, check_exact=True)",
        "begin_line": 712,
        "end_line": 720,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_clip_with_datetimes#722",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_clip_with_datetimes(self)",
        "snippet": "    def test_clip_with_datetimes(self):\n\n        # GH 11838\n        # naive and tz-aware datetimes\n\n        t = Timestamp(\"2015-12-01 09:30:30\")\n        s = Series([Timestamp(\"2015-12-01 09:30:00\"), Timestamp(\"2015-12-01 09:31:00\")])\n        result = s.clip(upper=t)\n        expected = Series(\n            [Timestamp(\"2015-12-01 09:30:00\"), Timestamp(\"2015-12-01 09:30:30\")]\n        )\n        tm.assert_series_equal(result, expected)\n\n        t = Timestamp(\"2015-12-01 09:30:30\", tz=\"US/Eastern\")\n        s = Series(\n            [\n                Timestamp(\"2015-12-01 09:30:00\", tz=\"US/Eastern\"),\n                Timestamp(\"2015-12-01 09:31:00\", tz=\"US/Eastern\"),\n            ]\n        )\n        result = s.clip(upper=t)\n        expected = Series(\n            [\n                Timestamp(\"2015-12-01 09:30:00\", tz=\"US/Eastern\"),\n                Timestamp(\"2015-12-01 09:30:30\", tz=\"US/Eastern\"),\n            ]\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 722,
        "end_line": 749,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cummethods_bool#751",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_cummethods_bool(self)",
        "snippet": "    def test_cummethods_bool(self):\n        # GH 6270\n\n        a = pd.Series([False, False, False, True, True, False, False])\n        b = ~a\n        c = pd.Series([False] * len(b))\n        d = ~c\n        methods = {\n            \"cumsum\": np.cumsum,\n            \"cumprod\": np.cumprod,\n            \"cummin\": np.minimum.accumulate,\n            \"cummax\": np.maximum.accumulate,\n        }\n        args = product((a, b, c, d), methods)\n        for s, method in args:\n            expected = Series(methods[method](s.values))\n            result = getattr(s, method)()\n            tm.assert_series_equal(result, expected)\n\n        e = pd.Series([False, True, np.nan, False])\n        cse = pd.Series([0, 1, np.nan, 1], dtype=object)\n        cpe = pd.Series([False, 0, np.nan, 0])\n        cmin = pd.Series([False, False, np.nan, False])\n        cmax = pd.Series([False, True, np.nan, True])\n        expecteds = {\"cumsum\": cse, \"cumprod\": cpe, \"cummin\": cmin, \"cummax\": cmax}\n\n        for method in methods:\n            res = getattr(e, method)()\n            tm.assert_series_equal(res, expecteds[method])",
        "begin_line": 751,
        "end_line": 779,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_isin#781",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_isin(self)",
        "snippet": "    def test_isin(self):\n        s = Series([\"A\", \"B\", \"C\", \"a\", \"B\", \"B\", \"A\", \"C\"])\n\n        result = s.isin([\"A\", \"C\"])\n        expected = Series([True, False, True, False, False, False, True, True])\n        tm.assert_series_equal(result, expected)\n\n        # GH: 16012\n        # This specific issue has to have a series over 1e6 in len, but the\n        # comparison array (in_list) must be large enough so that numpy doesn't\n        # do a manual masking trick that will avoid this issue altogether\n        s = Series(list(\"abcdefghijk\" * 10 ** 5))\n        # If numpy doesn't do the manual comparison/mask, these\n        # unorderable mixed types are what cause the exception in numpy\n        in_list = [-1, \"a\", \"b\", \"G\", \"Y\", \"Z\", \"E\", \"K\", \"E\", \"S\", \"I\", \"R\", \"R\"] * 6\n\n        assert s.isin(in_list).sum() == 200000",
        "begin_line": 781,
        "end_line": 797,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_isin_with_string_scalar#799",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_isin_with_string_scalar(self)",
        "snippet": "    def test_isin_with_string_scalar(self):\n        # GH4763\n        s = Series([\"A\", \"B\", \"C\", \"a\", \"B\", \"B\", \"A\", \"C\"])\n        msg = (\n            r\"only list-like objects are allowed to be passed to isin\\(\\),\"\n            r\" you passed a \\[str\\]\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            s.isin(\"a\")\n\n        s = Series([\"aaa\", \"b\", \"c\"])\n        with pytest.raises(TypeError, match=msg):\n            s.isin(\"aaa\")",
        "begin_line": 799,
        "end_line": 811,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_isin_with_i8#813",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_isin_with_i8(self)",
        "snippet": "    def test_isin_with_i8(self):\n        # GH 5021\n\n        expected = Series([True, True, False, False, False])\n        expected2 = Series([False, True, False, False, False])\n\n        # datetime64[ns]\n        s = Series(date_range(\"jan-01-2013\", \"jan-05-2013\"))\n\n        result = s.isin(s[0:2])\n        tm.assert_series_equal(result, expected)\n\n        result = s.isin(s[0:2].values)\n        tm.assert_series_equal(result, expected)\n\n        # fails on dtype conversion in the first place\n        result = s.isin(s[0:2].values.astype(\"datetime64[D]\"))\n        tm.assert_series_equal(result, expected)\n\n        result = s.isin([s[1]])\n        tm.assert_series_equal(result, expected2)\n\n        result = s.isin([np.datetime64(s[1])])\n        tm.assert_series_equal(result, expected2)\n\n        result = s.isin(set(s[0:2]))\n        tm.assert_series_equal(result, expected)\n\n        # timedelta64[ns]\n        s = Series(pd.to_timedelta(range(5), unit=\"d\"))\n        result = s.isin(s[0:2])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 813,
        "end_line": 844,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_isin_empty#847",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_isin_empty(self, empty)",
        "snippet": "    def test_isin_empty(self, empty):\n        # see gh-16991\n        s = Series([\"a\", \"b\"])\n        expected = Series([False, False])\n\n        result = s.isin(empty)\n        tm.assert_series_equal(expected, result)",
        "begin_line": 847,
        "end_line": 853,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_ptp#855",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_ptp(self)",
        "snippet": "    def test_ptp(self):\n        # GH21614\n        N = 1000\n        arr = np.random.randn(N)\n        ser = Series(arr)\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            assert np.ptp(ser) == np.ptp(arr)\n\n        # GH11163\n        s = Series([3, 5, np.nan, -3, 10])\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            assert s.ptp() == 13\n            assert pd.isna(s.ptp(skipna=False))\n\n        mi = pd.MultiIndex.from_product([[\"a\", \"b\"], [1, 2, 3]])\n        s = pd.Series([1, np.nan, 7, 3, 5, np.nan], index=mi)\n\n        expected = pd.Series([6, 2], index=[\"a\", \"b\"], dtype=np.float64)\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            tm.assert_series_equal(s.ptp(level=0), expected)\n\n        expected = pd.Series([np.nan, np.nan], index=[\"a\", \"b\"])\n        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n            tm.assert_series_equal(s.ptp(level=0, skipna=False), expected)\n\n        msg = \"No axis named 1 for object type <class 'pandas.core.series.Series'>\"\n        with pytest.raises(ValueError, match=msg):\n            with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n                s.ptp(axis=1)\n\n        s = pd.Series([\"a\", \"b\", \"c\", \"d\", \"e\"])\n        msg = r\"unsupported operand type\\(s\\) for -: 'str' and 'str'\"\n        with pytest.raises(TypeError, match=msg):\n            with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n                s.ptp()\n\n        msg = r\"Series\\.ptp does not implement numeric_only\\.\"\n        with pytest.raises(NotImplementedError, match=msg):\n            with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):\n                s.ptp(numeric_only=True)",
        "begin_line": 855,
        "end_line": 894,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_repeat#896",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_repeat(self)",
        "snippet": "    def test_repeat(self):\n        s = Series(np.random.randn(3), index=[\"a\", \"b\", \"c\"])\n\n        reps = s.repeat(5)\n        exp = Series(s.values.repeat(5), index=s.index.values.repeat(5))\n        tm.assert_series_equal(reps, exp)\n\n        to_rep = [2, 3, 4]\n        reps = s.repeat(to_rep)\n        exp = Series(s.values.repeat(to_rep), index=s.index.values.repeat(to_rep))\n        tm.assert_series_equal(reps, exp)",
        "begin_line": 896,
        "end_line": 906,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_numpy_repeat#908",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_numpy_repeat(self)",
        "snippet": "    def test_numpy_repeat(self):\n        s = Series(np.arange(3), name=\"x\")\n        expected = Series(s.values.repeat(2), name=\"x\", index=s.index.values.repeat(2))\n        tm.assert_series_equal(np.repeat(s, 2), expected)\n\n        msg = \"the 'axis' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            np.repeat(s, 2, axis=0)",
        "begin_line": 908,
        "end_line": 915,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_searchsorted#917",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_searchsorted(self)",
        "snippet": "    def test_searchsorted(self):\n        s = Series([1, 2, 3])\n\n        result = s.searchsorted(1, side=\"left\")\n        assert is_scalar(result)\n        assert result == 0\n\n        result = s.searchsorted(1, side=\"right\")\n        assert is_scalar(result)\n        assert result == 1",
        "begin_line": 917,
        "end_line": 926,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_searchsorted_numeric_dtypes_scalar#928",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_searchsorted_numeric_dtypes_scalar(self)",
        "snippet": "    def test_searchsorted_numeric_dtypes_scalar(self):\n        s = Series([1, 2, 90, 1000, 3e9])\n        r = s.searchsorted(30)\n        assert is_scalar(r)\n        assert r == 2\n\n        r = s.searchsorted([30])\n        e = np.array([2], dtype=np.intp)\n        tm.assert_numpy_array_equal(r, e)",
        "begin_line": 928,
        "end_line": 936,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_searchsorted_numeric_dtypes_vector#938",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_searchsorted_numeric_dtypes_vector(self)",
        "snippet": "    def test_searchsorted_numeric_dtypes_vector(self):\n        s = Series([1, 2, 90, 1000, 3e9])\n        r = s.searchsorted([91, 2e6])\n        e = np.array([3, 4], dtype=np.intp)\n        tm.assert_numpy_array_equal(r, e)",
        "begin_line": 938,
        "end_line": 942,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_search_sorted_datetime64_scalar#944",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_search_sorted_datetime64_scalar(self)",
        "snippet": "    def test_search_sorted_datetime64_scalar(self):\n        s = Series(pd.date_range(\"20120101\", periods=10, freq=\"2D\"))\n        v = pd.Timestamp(\"20120102\")\n        r = s.searchsorted(v)\n        assert is_scalar(r)\n        assert r == 1",
        "begin_line": 944,
        "end_line": 949,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_search_sorted_datetime64_list#951",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_search_sorted_datetime64_list(self)",
        "snippet": "    def test_search_sorted_datetime64_list(self):\n        s = Series(pd.date_range(\"20120101\", periods=10, freq=\"2D\"))\n        v = [pd.Timestamp(\"20120102\"), pd.Timestamp(\"20120104\")]\n        r = s.searchsorted(v)\n        e = np.array([1, 2], dtype=np.intp)\n        tm.assert_numpy_array_equal(r, e)",
        "begin_line": 951,
        "end_line": 956,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_searchsorted_sorter#958",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_searchsorted_sorter(self)",
        "snippet": "    def test_searchsorted_sorter(self):\n        # GH8490\n        s = Series([3, 1, 2])\n        r = s.searchsorted([0, 3], sorter=np.argsort(s))\n        e = np.array([0, 2], dtype=np.intp)\n        tm.assert_numpy_array_equal(r, e)",
        "begin_line": 958,
        "end_line": 963,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_is_monotonic#965",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_is_monotonic(self)",
        "snippet": "    def test_is_monotonic(self):\n\n        s = Series(np.random.randint(0, 10, size=1000))\n        assert not s.is_monotonic\n        s = Series(np.arange(1000))\n        assert s.is_monotonic is True\n        assert s.is_monotonic_increasing is True\n        s = Series(np.arange(1000, 0, -1))\n        assert s.is_monotonic_decreasing is True\n\n        s = Series(pd.date_range(\"20130101\", periods=10))\n        assert s.is_monotonic is True\n        assert s.is_monotonic_increasing is True\n        s = Series(list(reversed(s.tolist())))\n        assert s.is_monotonic is False\n        assert s.is_monotonic_decreasing is True",
        "begin_line": 965,
        "end_line": 980,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_sort_index_level#982",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_sort_index_level(self)",
        "snippet": "    def test_sort_index_level(self):\n        mi = MultiIndex.from_tuples([[1, 1, 3], [1, 1, 1]], names=list(\"ABC\"))\n        s = Series([1, 2], mi)\n        backwards = s.iloc[[1, 0]]\n\n        res = s.sort_index(level=\"A\")\n        tm.assert_series_equal(backwards, res)\n\n        res = s.sort_index(level=[\"A\", \"B\"])\n        tm.assert_series_equal(backwards, res)\n\n        res = s.sort_index(level=\"A\", sort_remaining=False)\n        tm.assert_series_equal(s, res)\n\n        res = s.sort_index(level=[\"A\", \"B\"], sort_remaining=False)\n        tm.assert_series_equal(s, res)",
        "begin_line": 982,
        "end_line": 997,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_apply_categorical#999",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_apply_categorical(self)",
        "snippet": "    def test_apply_categorical(self):\n        values = pd.Categorical(list(\"ABBABCD\"), categories=list(\"DCBA\"), ordered=True)\n        s = pd.Series(values, name=\"XX\", index=list(\"abcdefg\"))\n        result = s.apply(lambda x: x.lower())\n\n        # should be categorical dtype when the number of categories are\n        # the same\n        values = pd.Categorical(list(\"abbabcd\"), categories=list(\"dcba\"), ordered=True)\n        exp = pd.Series(values, name=\"XX\", index=list(\"abcdefg\"))\n        tm.assert_series_equal(result, exp)\n        tm.assert_categorical_equal(result.values, exp.values)\n\n        result = s.apply(lambda x: \"A\")\n        exp = pd.Series([\"A\"] * 7, name=\"XX\", index=list(\"abcdefg\"))\n        tm.assert_series_equal(result, exp)\n        assert result.dtype == np.object",
        "begin_line": 999,
        "end_line": 1014,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_shift_int#1016",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_shift_int(self, datetime_series)",
        "snippet": "    def test_shift_int(self, datetime_series):\n        ts = datetime_series.astype(int)\n        shifted = ts.shift(1)\n        expected = ts.astype(float).shift(1)\n        tm.assert_series_equal(shifted, expected)",
        "begin_line": 1016,
        "end_line": 1020,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_shift_object_non_scalar_fill#1022",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_shift_object_non_scalar_fill(self)",
        "snippet": "    def test_shift_object_non_scalar_fill(self):\n        # shift requires scalar fill_value except for object dtype\n        ser = Series(range(3))\n        with pytest.raises(ValueError, match=\"fill_value must be a scalar\"):\n            ser.shift(1, fill_value=[])\n\n        df = ser.to_frame()\n        with pytest.raises(ValueError, match=\"fill_value must be a scalar\"):\n            df.shift(1, fill_value=np.arange(3))\n\n        obj_ser = ser.astype(object)\n        result = obj_ser.shift(1, fill_value={})\n        assert result[0] == {}\n\n        obj_df = obj_ser.to_frame()\n        result = obj_df.shift(1, fill_value={})\n        assert result.iloc[0, 0] == {}",
        "begin_line": 1022,
        "end_line": 1038,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_shift_categorical#1040",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_shift_categorical(self)",
        "snippet": "    def test_shift_categorical(self):\n        # GH 9416\n        s = pd.Series([\"a\", \"b\", \"c\", \"d\"], dtype=\"category\")\n\n        tm.assert_series_equal(s.iloc[:-1], s.shift(1).shift(-1).dropna())\n\n        sp1 = s.shift(1)\n        tm.assert_index_equal(s.index, sp1.index)\n        assert np.all(sp1.values.codes[:1] == -1)\n        assert np.all(s.values.codes[:-1] == sp1.values.codes[1:])\n\n        sn2 = s.shift(-2)\n        tm.assert_index_equal(s.index, sn2.index)\n        assert np.all(sn2.values.codes[-2:] == -1)\n        assert np.all(s.values.codes[2:] == sn2.values.codes[:-2])\n\n        tm.assert_index_equal(s.values.categories, sp1.values.categories)\n        tm.assert_index_equal(s.values.categories, sn2.values.categories)",
        "begin_line": 1040,
        "end_line": 1057,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_unstack#1059",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_unstack(self)",
        "snippet": "    def test_unstack(self):\n\n        index = MultiIndex(\n            levels=[[\"bar\", \"foo\"], [\"one\", \"three\", \"two\"]],\n            codes=[[1, 1, 0, 0], [0, 1, 0, 2]],\n        )\n\n        s = Series(np.arange(4.0), index=index)\n        unstacked = s.unstack()\n\n        expected = DataFrame(\n            [[2.0, np.nan, 3.0], [0.0, 1.0, np.nan]],\n            index=[\"bar\", \"foo\"],\n            columns=[\"one\", \"three\", \"two\"],\n        )\n\n        tm.assert_frame_equal(unstacked, expected)\n\n        unstacked = s.unstack(level=0)\n        tm.assert_frame_equal(unstacked, expected.T)\n\n        index = MultiIndex(\n            levels=[[\"bar\"], [\"one\", \"two\", \"three\"], [0, 1]],\n            codes=[[0, 0, 0, 0, 0, 0], [0, 1, 2, 0, 1, 2], [0, 1, 0, 1, 0, 1]],\n        )\n        s = Series(np.random.randn(6), index=index)\n        exp_index = MultiIndex(\n            levels=[[\"one\", \"two\", \"three\"], [0, 1]],\n            codes=[[0, 1, 2, 0, 1, 2], [0, 1, 0, 1, 0, 1]],\n        )\n        expected = DataFrame({\"bar\": s.values}, index=exp_index).sort_index(level=0)\n        unstacked = s.unstack(0).sort_index()\n        tm.assert_frame_equal(unstacked, expected)\n\n        # GH5873\n        idx = pd.MultiIndex.from_arrays([[101, 102], [3.5, np.nan]])\n        ts = pd.Series([1, 2], index=idx)\n        left = ts.unstack()\n        right = DataFrame(\n            [[np.nan, 1], [2, np.nan]], index=[101, 102], columns=[np.nan, 3.5]\n        )\n        tm.assert_frame_equal(left, right)\n\n        idx = pd.MultiIndex.from_arrays(\n            [\n                [\"cat\", \"cat\", \"cat\", \"dog\", \"dog\"],\n                [\"a\", \"a\", \"b\", \"a\", \"b\"],\n                [1, 2, 1, 1, np.nan],\n            ]\n        )\n        ts = pd.Series([1.0, 1.1, 1.2, 1.3, 1.4], index=idx)\n        right = DataFrame(\n            [[1.0, 1.3], [1.1, np.nan], [np.nan, 1.4], [1.2, np.nan]],\n            columns=[\"cat\", \"dog\"],\n        )\n        tpls = [(\"a\", 1), (\"a\", 2), (\"b\", np.nan), (\"b\", 1)]\n        right.index = pd.MultiIndex.from_tuples(tpls)\n        tm.assert_frame_equal(ts.unstack(level=0), right)",
        "begin_line": 1059,
        "end_line": 1116,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_value_counts_datetime#1118",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_value_counts_datetime(self)",
        "snippet": "    def test_value_counts_datetime(self):\n        # most dtypes are tested in test_base.py\n        values = [\n            pd.Timestamp(\"2011-01-01 09:00\"),\n            pd.Timestamp(\"2011-01-01 10:00\"),\n            pd.Timestamp(\"2011-01-01 11:00\"),\n            pd.Timestamp(\"2011-01-01 09:00\"),\n            pd.Timestamp(\"2011-01-01 09:00\"),\n            pd.Timestamp(\"2011-01-01 11:00\"),\n        ]\n\n        exp_idx = pd.DatetimeIndex(\n            [\"2011-01-01 09:00\", \"2011-01-01 11:00\", \"2011-01-01 10:00\"]\n        )\n        exp = pd.Series([3, 2, 1], index=exp_idx, name=\"xxx\")\n\n        s = pd.Series(values, name=\"xxx\")\n        tm.assert_series_equal(s.value_counts(), exp)\n        # check DatetimeIndex outputs the same result\n        idx = pd.DatetimeIndex(values, name=\"xxx\")\n        tm.assert_series_equal(idx.value_counts(), exp)\n\n        # normalize\n        exp = pd.Series(np.array([3.0, 2.0, 1]) / 6.0, index=exp_idx, name=\"xxx\")\n        tm.assert_series_equal(s.value_counts(normalize=True), exp)\n        tm.assert_series_equal(idx.value_counts(normalize=True), exp)",
        "begin_line": 1118,
        "end_line": 1143,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_value_counts_datetime_tz#1145",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_value_counts_datetime_tz(self)",
        "snippet": "    def test_value_counts_datetime_tz(self):\n        values = [\n            pd.Timestamp(\"2011-01-01 09:00\", tz=\"US/Eastern\"),\n            pd.Timestamp(\"2011-01-01 10:00\", tz=\"US/Eastern\"),\n            pd.Timestamp(\"2011-01-01 11:00\", tz=\"US/Eastern\"),\n            pd.Timestamp(\"2011-01-01 09:00\", tz=\"US/Eastern\"),\n            pd.Timestamp(\"2011-01-01 09:00\", tz=\"US/Eastern\"),\n            pd.Timestamp(\"2011-01-01 11:00\", tz=\"US/Eastern\"),\n        ]\n\n        exp_idx = pd.DatetimeIndex(\n            [\"2011-01-01 09:00\", \"2011-01-01 11:00\", \"2011-01-01 10:00\"],\n            tz=\"US/Eastern\",\n        )\n        exp = pd.Series([3, 2, 1], index=exp_idx, name=\"xxx\")\n\n        s = pd.Series(values, name=\"xxx\")\n        tm.assert_series_equal(s.value_counts(), exp)\n        idx = pd.DatetimeIndex(values, name=\"xxx\")\n        tm.assert_series_equal(idx.value_counts(), exp)\n\n        exp = pd.Series(np.array([3.0, 2.0, 1]) / 6.0, index=exp_idx, name=\"xxx\")\n        tm.assert_series_equal(s.value_counts(normalize=True), exp)\n        tm.assert_series_equal(idx.value_counts(normalize=True), exp)",
        "begin_line": 1145,
        "end_line": 1168,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_value_counts_period#1170",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_value_counts_period(self)",
        "snippet": "    def test_value_counts_period(self):\n        values = [\n            pd.Period(\"2011-01\", freq=\"M\"),\n            pd.Period(\"2011-02\", freq=\"M\"),\n            pd.Period(\"2011-03\", freq=\"M\"),\n            pd.Period(\"2011-01\", freq=\"M\"),\n            pd.Period(\"2011-01\", freq=\"M\"),\n            pd.Period(\"2011-03\", freq=\"M\"),\n        ]\n\n        exp_idx = pd.PeriodIndex([\"2011-01\", \"2011-03\", \"2011-02\"], freq=\"M\")\n        exp = pd.Series([3, 2, 1], index=exp_idx, name=\"xxx\")\n\n        s = pd.Series(values, name=\"xxx\")\n        tm.assert_series_equal(s.value_counts(), exp)\n        # check DatetimeIndex outputs the same result\n        idx = pd.PeriodIndex(values, name=\"xxx\")\n        tm.assert_series_equal(idx.value_counts(), exp)\n\n        # normalize\n        exp = pd.Series(np.array([3.0, 2.0, 1]) / 6.0, index=exp_idx, name=\"xxx\")\n        tm.assert_series_equal(s.value_counts(normalize=True), exp)\n        tm.assert_series_equal(idx.value_counts(normalize=True), exp)",
        "begin_line": 1170,
        "end_line": 1192,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_value_counts_categorical_ordered#1194",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_value_counts_categorical_ordered(self)",
        "snippet": "    def test_value_counts_categorical_ordered(self):\n        # most dtypes are tested in test_base.py\n        values = pd.Categorical([1, 2, 3, 1, 1, 3], ordered=True)\n\n        exp_idx = pd.CategoricalIndex([1, 3, 2], categories=[1, 2, 3], ordered=True)\n        exp = pd.Series([3, 2, 1], index=exp_idx, name=\"xxx\")\n\n        s = pd.Series(values, name=\"xxx\")\n        tm.assert_series_equal(s.value_counts(), exp)\n        # check CategoricalIndex outputs the same result\n        idx = pd.CategoricalIndex(values, name=\"xxx\")\n        tm.assert_series_equal(idx.value_counts(), exp)\n\n        # normalize\n        exp = pd.Series(np.array([3.0, 2.0, 1]) / 6.0, index=exp_idx, name=\"xxx\")\n        tm.assert_series_equal(s.value_counts(normalize=True), exp)\n        tm.assert_series_equal(idx.value_counts(normalize=True), exp)",
        "begin_line": 1194,
        "end_line": 1210,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_value_counts_categorical_not_ordered#1212",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_value_counts_categorical_not_ordered(self)",
        "snippet": "    def test_value_counts_categorical_not_ordered(self):\n        values = pd.Categorical([1, 2, 3, 1, 1, 3], ordered=False)\n\n        exp_idx = pd.CategoricalIndex([1, 3, 2], categories=[1, 2, 3], ordered=False)\n        exp = pd.Series([3, 2, 1], index=exp_idx, name=\"xxx\")\n\n        s = pd.Series(values, name=\"xxx\")\n        tm.assert_series_equal(s.value_counts(), exp)\n        # check CategoricalIndex outputs the same result\n        idx = pd.CategoricalIndex(values, name=\"xxx\")\n        tm.assert_series_equal(idx.value_counts(), exp)\n\n        # normalize\n        exp = pd.Series(np.array([3.0, 2.0, 1]) / 6.0, index=exp_idx, name=\"xxx\")\n        tm.assert_series_equal(s.value_counts(normalize=True), exp)\n        tm.assert_series_equal(idx.value_counts(normalize=True), exp)",
        "begin_line": 1212,
        "end_line": 1227,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_validate_any_all_out_keepdims_raises#1232",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_validate_any_all_out_keepdims_raises(self, kwargs, func)",
        "snippet": "    def test_validate_any_all_out_keepdims_raises(self, kwargs, func):\n        s = pd.Series([1, 2])\n        param = list(kwargs)[0]\n        name = func.__name__\n\n        msg = (\n            r\"the '{arg}' parameter is not \"\n            r\"supported in the pandas \"\n            r\"implementation of {fname}\\(\\)\"\n        ).format(arg=param, fname=name)\n        with pytest.raises(ValueError, match=msg):\n            func(s, **kwargs)",
        "begin_line": 1232,
        "end_line": 1243,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_validate_sum_initial#1246",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_validate_sum_initial(self)",
        "snippet": "    def test_validate_sum_initial(self):\n        s = pd.Series([1, 2])\n        msg = (\n            r\"the 'initial' parameter is not \"\n            r\"supported in the pandas \"\n            r\"implementation of sum\\(\\)\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            np.sum(s, initial=10)",
        "begin_line": 1246,
        "end_line": 1254,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_validate_median_initial#1256",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_validate_median_initial(self)",
        "snippet": "    def test_validate_median_initial(self):\n        s = pd.Series([1, 2])\n        msg = (\n            r\"the 'overwrite_input' parameter is not \"\n            r\"supported in the pandas \"\n            r\"implementation of median\\(\\)\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            # It seems like np.median doesn't dispatch, so we use the\n            # method instead of the ufunc.\n            s.median(overwrite_input=True)",
        "begin_line": 1256,
        "end_line": 1266,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_validate_stat_keepdims#1269",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_validate_stat_keepdims(self)",
        "snippet": "    def test_validate_stat_keepdims(self):\n        s = pd.Series([1, 2])\n        msg = (\n            r\"the 'keepdims' parameter is not \"\n            r\"supported in the pandas \"\n            r\"implementation of sum\\(\\)\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            np.sum(s, keepdims=True)",
        "begin_line": 1269,
        "end_line": 1277,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_compound_deprecated#1279",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestSeriesAnalytics.test_compound_deprecated(self)",
        "snippet": "    def test_compound_deprecated(self):\n        s = Series([0.1, 0.2, 0.3, 0.4])\n        with tm.assert_produces_warning(FutureWarning):\n            s.compound()\n\n        df = pd.DataFrame({\"s\": s})\n        with tm.assert_produces_warning(FutureWarning):\n            df.compound()",
        "begin_line": 1279,
        "end_line": 1286,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.s_main_dtypes#1307",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics",
        "signature": "pandas.tests.series.test_analytics.s_main_dtypes()",
        "snippet": "def s_main_dtypes():\n    \"\"\"A DataFrame with many dtypes\n\n    * datetime\n    * datetimetz\n    * timedelta\n    * [u]int{8,16,32,64}\n    * float{32,64}\n\n    The columns are the name of the dtype.\n    \"\"\"\n    df = pd.DataFrame(\n        {\n            \"datetime\": pd.to_datetime([\"2003\", \"2002\", \"2001\", \"2002\", \"2005\"]),\n            \"datetimetz\": pd.to_datetime(\n                [\"2003\", \"2002\", \"2001\", \"2002\", \"2005\"]\n            ).tz_localize(\"US/Eastern\"),\n            \"timedelta\": pd.to_timedelta([\"3d\", \"2d\", \"1d\", \"2d\", \"5d\"]),\n        }\n    )\n\n    for dtype in [\n        \"int8\",\n        \"int16\",\n        \"int32\",\n        \"int64\",\n        \"float32\",\n        \"float64\",\n        \"uint8\",\n        \"uint16\",\n        \"uint32\",\n        \"uint64\",\n    ]:\n        df[dtype] = Series([3, 2, 1, 2, 5], dtype=dtype)\n\n    return df",
        "begin_line": 1307,
        "end_line": 1342,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.s_main_dtypes_split#1346",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics",
        "signature": "pandas.tests.series.test_analytics.s_main_dtypes_split(request, s_main_dtypes)",
        "snippet": "def s_main_dtypes_split(request, s_main_dtypes):\n    \"\"\"Each series in s_main_dtypes.\"\"\"\n    return s_main_dtypes[request.param]",
        "begin_line": 1346,
        "end_line": 1348,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.assert_check_nselect_boundary#1351",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics",
        "signature": "pandas.tests.series.test_analytics.assert_check_nselect_boundary(vals, dtype, method)",
        "snippet": "def assert_check_nselect_boundary(vals, dtype, method):\n    # helper function for 'test_boundary_{dtype}' tests\n    s = Series(vals, dtype=dtype)\n    result = getattr(s, method)(3)\n    expected_idxr = [0, 1, 2] if method == \"nsmallest\" else [3, 2, 1]\n    expected = s.loc[expected_idxr]\n    tm.assert_series_equal(result, expected)",
        "begin_line": 1351,
        "end_line": 1357,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestNLargestNSmallest.test_error#1373",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.series.test_analytics.TestNLargestNSmallest.test_error(self, r)",
        "snippet": "    def test_error(self, r):\n        dt = r.dtype\n        msg = \"Cannot use method 'n(larg|small)est' with dtype {dt}\".format(dt=dt)\n        args = 2, len(r), 0, -1\n        methods = r.nlargest, r.nsmallest\n        for method, arg in product(methods, args):\n            with pytest.raises(TypeError, match=msg):\n                method(arg)",
        "begin_line": 1373,
        "end_line": 1380,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestNLargestNSmallest.test_nsmallest_nlargest#1382",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.series.test_analytics.TestNLargestNSmallest.test_nsmallest_nlargest(self, s_main_dtypes_split)",
        "snippet": "    def test_nsmallest_nlargest(self, s_main_dtypes_split):\n        # float, int, datetime64 (use i8), timedelts64 (same),\n        # object that are numbers, object that are strings\n        s = s_main_dtypes_split\n\n        tm.assert_series_equal(s.nsmallest(2), s.iloc[[2, 1]])\n        tm.assert_series_equal(s.nsmallest(2, keep=\"last\"), s.iloc[[2, 3]])\n\n        empty = s.iloc[0:0]\n        tm.assert_series_equal(s.nsmallest(0), empty)\n        tm.assert_series_equal(s.nsmallest(-1), empty)\n        tm.assert_series_equal(s.nlargest(0), empty)\n        tm.assert_series_equal(s.nlargest(-1), empty)\n\n        tm.assert_series_equal(s.nsmallest(len(s)), s.sort_values())\n        tm.assert_series_equal(s.nsmallest(len(s) + 1), s.sort_values())\n        tm.assert_series_equal(s.nlargest(len(s)), s.iloc[[4, 0, 1, 3, 2]])\n        tm.assert_series_equal(s.nlargest(len(s) + 1), s.iloc[[4, 0, 1, 3, 2]])",
        "begin_line": 1382,
        "end_line": 1399,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestNLargestNSmallest.test_misc#1401",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.series.test_analytics.TestNLargestNSmallest.test_misc(self)",
        "snippet": "    def test_misc(self):\n\n        s = Series([3.0, np.nan, 1, 2, 5])\n        tm.assert_series_equal(s.nlargest(), s.iloc[[4, 0, 3, 2]])\n        tm.assert_series_equal(s.nsmallest(), s.iloc[[2, 3, 0, 4]])\n\n        msg = 'keep must be either \"first\", \"last\"'\n        with pytest.raises(ValueError, match=msg):\n            s.nsmallest(keep=\"invalid\")\n        with pytest.raises(ValueError, match=msg):\n            s.nlargest(keep=\"invalid\")\n\n        # GH 15297\n        s = Series([1] * 5, index=[1, 2, 3, 4, 5])\n        expected_first = Series([1] * 3, index=[1, 2, 3])\n        expected_last = Series([1] * 3, index=[5, 4, 3])\n\n        result = s.nsmallest(3)\n        tm.assert_series_equal(result, expected_first)\n\n        result = s.nsmallest(3, keep=\"last\")\n        tm.assert_series_equal(result, expected_last)\n\n        result = s.nlargest(3)\n        tm.assert_series_equal(result, expected_first)\n\n        result = s.nlargest(3, keep=\"last\")\n        tm.assert_series_equal(result, expected_last)",
        "begin_line": 1401,
        "end_line": 1428,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestNLargestNSmallest.test_n#1431",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.series.test_analytics.TestNLargestNSmallest.test_n(self, n)",
        "snippet": "    def test_n(self, n):\n\n        # GH 13412\n        s = Series([1, 4, 3, 2], index=[0, 0, 1, 1])\n        result = s.nlargest(n)\n        expected = s.sort_values(ascending=False).head(n)\n        tm.assert_series_equal(result, expected)\n\n        result = s.nsmallest(n)\n        expected = s.sort_values().head(n)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1431,
        "end_line": 1441,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestNLargestNSmallest.test_boundary_integer#1443",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.series.test_analytics.TestNLargestNSmallest.test_boundary_integer(self, nselect_method, any_int_dtype)",
        "snippet": "    def test_boundary_integer(self, nselect_method, any_int_dtype):\n        # GH 21426\n        dtype_info = np.iinfo(any_int_dtype)\n        min_val, max_val = dtype_info.min, dtype_info.max\n        vals = [min_val, min_val + 1, max_val - 1, max_val]\n        assert_check_nselect_boundary(vals, any_int_dtype, nselect_method)",
        "begin_line": 1443,
        "end_line": 1448,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestNLargestNSmallest.test_boundary_float#1450",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.series.test_analytics.TestNLargestNSmallest.test_boundary_float(self, nselect_method, float_dtype)",
        "snippet": "    def test_boundary_float(self, nselect_method, float_dtype):\n        # GH 21426\n        dtype_info = np.finfo(float_dtype)\n        min_val, max_val = dtype_info.min, dtype_info.max\n        min_2nd, max_2nd = np.nextafter([min_val, max_val], 0, dtype=float_dtype)\n        vals = [min_val, min_2nd, max_2nd, max_val]\n        assert_check_nselect_boundary(vals, float_dtype, nselect_method)",
        "begin_line": 1450,
        "end_line": 1456,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestNLargestNSmallest.test_boundary_datetimelike#1459",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.series.test_analytics.TestNLargestNSmallest.test_boundary_datetimelike(self, nselect_method, dtype)",
        "snippet": "    def test_boundary_datetimelike(self, nselect_method, dtype):\n        # GH 21426\n        # use int64 bounds and +1 to min_val since true minimum is NaT\n        # (include min_val/NaT at end to maintain same expected_idxr)\n        dtype_info = np.iinfo(\"int64\")\n        min_val, max_val = dtype_info.min, dtype_info.max\n        vals = [min_val + 1, min_val + 2, max_val - 1, max_val, min_val]\n        assert_check_nselect_boundary(vals, dtype, nselect_method)",
        "begin_line": 1459,
        "end_line": 1466,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestNLargestNSmallest.test_duplicate_keep_all_ties#1468",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.series.test_analytics.TestNLargestNSmallest.test_duplicate_keep_all_ties(self)",
        "snippet": "    def test_duplicate_keep_all_ties(self):\n        # see gh-16818\n        s = Series([10, 9, 8, 7, 7, 7, 7, 6])\n        result = s.nlargest(4, keep=\"all\")\n        expected = Series([10, 9, 8, 7, 7, 7, 7])\n        tm.assert_series_equal(result, expected)\n\n        result = s.nsmallest(2, keep=\"all\")\n        expected = Series([6, 7, 7, 7, 7], index=[7, 3, 4, 5, 6])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1468,
        "end_line": 1477,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestNLargestNSmallest.test_boolean#1482",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestNLargestNSmallest",
        "signature": "pandas.tests.series.test_analytics.TestNLargestNSmallest.test_boolean(self, data, expected)",
        "snippet": "    def test_boolean(self, data, expected):\n        # GH 26154 : ensure True > False\n        s = Series(data)\n        result = s.nlargest(1)\n        expected = Series(expected)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1482,
        "end_line": 1487,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestCategoricalSeriesAnalytics.test_count#1491",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestCategoricalSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestCategoricalSeriesAnalytics.test_count(self)",
        "snippet": "    def test_count(self):\n\n        s = Series(\n            Categorical(\n                [np.nan, 1, 2, np.nan], categories=[5, 4, 3, 2, 1], ordered=True\n            )\n        )\n        result = s.count()\n        assert result == 2",
        "begin_line": 1491,
        "end_line": 1499,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestCategoricalSeriesAnalytics.test_value_counts#1501",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestCategoricalSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestCategoricalSeriesAnalytics.test_value_counts(self)",
        "snippet": "    def test_value_counts(self):\n        # GH 12835\n        cats = Categorical(list(\"abcccb\"), categories=list(\"cabd\"))\n        s = Series(cats, name=\"xxx\")\n        res = s.value_counts(sort=False)\n\n        exp_index = CategoricalIndex(list(\"cabd\"), categories=cats.categories)\n        exp = Series([3, 1, 2, 0], name=\"xxx\", index=exp_index)\n        tm.assert_series_equal(res, exp)\n\n        res = s.value_counts(sort=True)\n\n        exp_index = CategoricalIndex(list(\"cbad\"), categories=cats.categories)\n        exp = Series([3, 2, 1, 0], name=\"xxx\", index=exp_index)\n        tm.assert_series_equal(res, exp)\n\n        # check object dtype handles the Series.name as the same\n        # (tested in test_base.py)\n        s = Series([\"a\", \"b\", \"c\", \"c\", \"c\", \"b\"], name=\"xxx\")\n        res = s.value_counts()\n        exp = Series([3, 2, 1], name=\"xxx\", index=[\"c\", \"b\", \"a\"])\n        tm.assert_series_equal(res, exp)",
        "begin_line": 1501,
        "end_line": 1522,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestCategoricalSeriesAnalytics.test_value_counts_with_nan#1524",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestCategoricalSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestCategoricalSeriesAnalytics.test_value_counts_with_nan(self)",
        "snippet": "    def test_value_counts_with_nan(self):\n        # see gh-9443\n\n        # sanity check\n        s = Series([\"a\", \"b\", \"a\"], dtype=\"category\")\n        exp = Series([2, 1], index=CategoricalIndex([\"a\", \"b\"]))\n\n        res = s.value_counts(dropna=True)\n        tm.assert_series_equal(res, exp)\n\n        res = s.value_counts(dropna=True)\n        tm.assert_series_equal(res, exp)\n\n        # same Series via two different constructions --> same behaviour\n        series = [\n            Series([\"a\", \"b\", None, \"a\", None, None], dtype=\"category\"),\n            Series(\n                Categorical([\"a\", \"b\", None, \"a\", None, None], categories=[\"a\", \"b\"])\n            ),\n        ]\n\n        for s in series:\n            # None is a NaN value, so we exclude its count here\n            exp = Series([2, 1], index=CategoricalIndex([\"a\", \"b\"]))\n            res = s.value_counts(dropna=True)\n            tm.assert_series_equal(res, exp)\n\n            # we don't exclude the count of None and sort by counts\n            exp = Series([3, 2, 1], index=CategoricalIndex([np.nan, \"a\", \"b\"]))\n            res = s.value_counts(dropna=False)\n            tm.assert_series_equal(res, exp)\n\n            # When we aren't sorting by counts, and np.nan isn't a\n            # category, it should be last.\n            exp = Series([2, 1, 3], index=CategoricalIndex([\"a\", \"b\", np.nan]))\n            res = s.value_counts(dropna=False, sort=False)\n            tm.assert_series_equal(res, exp)",
        "begin_line": 1524,
        "end_line": 1560,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestCategoricalSeriesAnalytics.test_drop_duplicates_categorical_non_bool#1566",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestCategoricalSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestCategoricalSeriesAnalytics.test_drop_duplicates_categorical_non_bool(self, dtype, ordered_fixture)",
        "snippet": "    def test_drop_duplicates_categorical_non_bool(self, dtype, ordered_fixture):\n        cat_array = np.array([1, 2, 3, 4, 5], dtype=np.dtype(dtype))\n\n        # Test case 1\n        input1 = np.array([1, 2, 3, 3], dtype=np.dtype(dtype))\n        tc1 = Series(Categorical(input1, categories=cat_array, ordered=ordered_fixture))\n        if dtype == \"datetime64[D]\":\n            # pre-empty flaky xfail, tc1 values are seemingly-random\n            if not (np.array(tc1) == input1).all():\n                pytest.xfail(reason=\"GH#7996\")\n\n        expected = Series([False, False, False, True])\n        tm.assert_series_equal(tc1.duplicated(), expected)\n        tm.assert_series_equal(tc1.drop_duplicates(), tc1[~expected])\n        sc = tc1.copy()\n        sc.drop_duplicates(inplace=True)\n        tm.assert_series_equal(sc, tc1[~expected])\n\n        expected = Series([False, False, True, False])\n        tm.assert_series_equal(tc1.duplicated(keep=\"last\"), expected)\n        tm.assert_series_equal(tc1.drop_duplicates(keep=\"last\"), tc1[~expected])\n        sc = tc1.copy()\n        sc.drop_duplicates(keep=\"last\", inplace=True)\n        tm.assert_series_equal(sc, tc1[~expected])\n\n        expected = Series([False, False, True, True])\n        tm.assert_series_equal(tc1.duplicated(keep=False), expected)\n        tm.assert_series_equal(tc1.drop_duplicates(keep=False), tc1[~expected])\n        sc = tc1.copy()\n        sc.drop_duplicates(keep=False, inplace=True)\n        tm.assert_series_equal(sc, tc1[~expected])\n\n        # Test case 2\n        input2 = np.array([1, 2, 3, 5, 3, 2, 4], dtype=np.dtype(dtype))\n        tc2 = Series(Categorical(input2, categories=cat_array, ordered=ordered_fixture))\n        if dtype == \"datetime64[D]\":\n            # pre-empty flaky xfail, tc2 values are seemingly-random\n            if not (np.array(tc2) == input2).all():\n                pytest.xfail(reason=\"GH#7996\")\n\n        expected = Series([False, False, False, False, True, True, False])\n        tm.assert_series_equal(tc2.duplicated(), expected)\n        tm.assert_series_equal(tc2.drop_duplicates(), tc2[~expected])\n        sc = tc2.copy()\n        sc.drop_duplicates(inplace=True)\n        tm.assert_series_equal(sc, tc2[~expected])\n\n        expected = Series([False, True, True, False, False, False, False])\n        tm.assert_series_equal(tc2.duplicated(keep=\"last\"), expected)\n        tm.assert_series_equal(tc2.drop_duplicates(keep=\"last\"), tc2[~expected])\n        sc = tc2.copy()\n        sc.drop_duplicates(keep=\"last\", inplace=True)\n        tm.assert_series_equal(sc, tc2[~expected])\n\n        expected = Series([False, True, True, False, True, True, False])\n        tm.assert_series_equal(tc2.duplicated(keep=False), expected)\n        tm.assert_series_equal(tc2.drop_duplicates(keep=False), tc2[~expected])\n        sc = tc2.copy()\n        sc.drop_duplicates(keep=False, inplace=True)\n        tm.assert_series_equal(sc, tc2[~expected])",
        "begin_line": 1566,
        "end_line": 1625,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_analytics.TestCategoricalSeriesAnalytics.test_drop_duplicates_categorical_bool#1627",
        "src_path": "pandas/tests/series/test_analytics.py",
        "class_name": "pandas.tests.series.test_analytics.TestCategoricalSeriesAnalytics",
        "signature": "pandas.tests.series.test_analytics.TestCategoricalSeriesAnalytics.test_drop_duplicates_categorical_bool(self, ordered_fixture)",
        "snippet": "    def test_drop_duplicates_categorical_bool(self, ordered_fixture):\n        tc = Series(\n            Categorical(\n                [True, False, True, False],\n                categories=[True, False],\n                ordered=ordered_fixture,\n            )\n        )\n\n        expected = Series([False, False, True, True])\n        tm.assert_series_equal(tc.duplicated(), expected)\n        tm.assert_series_equal(tc.drop_duplicates(), tc[~expected])\n        sc = tc.copy()\n        sc.drop_duplicates(inplace=True)\n        tm.assert_series_equal(sc, tc[~expected])\n\n        expected = Series([True, True, False, False])\n        tm.assert_series_equal(tc.duplicated(keep=\"last\"), expected)\n        tm.assert_series_equal(tc.drop_duplicates(keep=\"last\"), tc[~expected])\n        sc = tc.copy()\n        sc.drop_duplicates(keep=\"last\", inplace=True)\n        tm.assert_series_equal(sc, tc[~expected])\n\n        expected = Series([True, True, True, True])\n        tm.assert_series_equal(tc.duplicated(keep=False), expected)\n        tm.assert_series_equal(tc.drop_duplicates(keep=False), tc[~expected])\n        sc = tc.copy()\n        sc.drop_duplicates(keep=False, inplace=True)\n        tm.assert_series_equal(sc, tc[~expected])",
        "begin_line": 1627,
        "end_line": 1655,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.conftest.datetime_series#7",
        "src_path": "pandas/tests/series/conftest.py",
        "class_name": "pandas.tests.series.conftest",
        "signature": "pandas.tests.series.conftest.datetime_series()",
        "snippet": "def datetime_series():\n    \"\"\"\n    Fixture for Series of floats with DatetimeIndex\n    \"\"\"\n    s = tm.makeTimeSeries()\n    s.name = \"ts\"\n    return s",
        "begin_line": 7,
        "end_line": 13,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.conftest.string_series#17",
        "src_path": "pandas/tests/series/conftest.py",
        "class_name": "pandas.tests.series.conftest",
        "signature": "pandas.tests.series.conftest.string_series()",
        "snippet": "def string_series():\n    \"\"\"\n    Fixture for Series of floats with Index of unique strings\n    \"\"\"\n    s = tm.makeStringSeries()\n    s.name = \"series\"\n    return s",
        "begin_line": 17,
        "end_line": 23,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.conftest.object_series#27",
        "src_path": "pandas/tests/series/conftest.py",
        "class_name": "pandas.tests.series.conftest",
        "signature": "pandas.tests.series.conftest.object_series()",
        "snippet": "def object_series():\n    \"\"\"\n    Fixture for Series of dtype object with Index of unique strings\n    \"\"\"\n    s = tm.makeObjectSeries()\n    s.name = \"objects\"\n    return s",
        "begin_line": 27,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    }
]