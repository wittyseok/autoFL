[
    {
        "name": "pandas.tests.indexes.conftest.sort#5",
        "src_path": "pandas/tests/indexes/conftest.py",
        "class_name": "pandas.tests.indexes.conftest",
        "signature": "pandas.tests.indexes.conftest.sort(request)",
        "snippet": "def sort(request):\n    \"\"\"\n    Valid values for the 'sort' parameter used in the Index\n    setops methods (intersection, union, etc.)\n\n    Caution:\n        Don't confuse this one with the \"sort\" fixture used\n        for DataFrame.append or concat. That one has\n        parameters [True, False].\n\n        We can't combine them as sort=True is not permitted\n        in in the Index setops methods.\n    \"\"\"\n    return request.param",
        "begin_line": 5,
        "end_line": 18,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.conftest.freq_sample#22",
        "src_path": "pandas/tests/indexes/conftest.py",
        "class_name": "pandas.tests.indexes.conftest",
        "signature": "pandas.tests.indexes.conftest.freq_sample(request)",
        "snippet": "def freq_sample(request):\n    \"\"\"\n    Valid values for 'freq' parameter used to create date_range and\n    timedelta_range..\n    \"\"\"\n    return request.param",
        "begin_line": 22,
        "end_line": 27,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_roundtrip_pickle_with_tz#15",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_roundtrip_pickle_with_tz(self)",
        "snippet": "    def test_roundtrip_pickle_with_tz(self):\n\n        # GH 8367\n        # round-trip of timezone\n        index = date_range(\"20130101\", periods=3, tz=\"US/Eastern\", name=\"foo\")\n        unpickled = tm.round_trip_pickle(index)\n        tm.assert_index_equal(index, unpickled)",
        "begin_line": 15,
        "end_line": 21,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_pickle#23",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_pickle(self)",
        "snippet": "    def test_pickle(self):\n\n        # GH#4606\n        p = tm.round_trip_pickle(NaT)\n        assert p is NaT\n\n        idx = pd.to_datetime([\"2013-01-01\", NaT, \"2014-01-06\"])\n        idx_p = tm.round_trip_pickle(idx)\n        assert idx_p[0] == idx[0]\n        assert idx_p[1] is NaT\n        assert idx_p[2] == idx[2]\n\n        # GH#11002\n        # don't infer freq\n        idx = date_range(\"1750-1-1\", \"2050-1-1\", freq=\"7D\")\n        idx_p = tm.round_trip_pickle(idx)\n        tm.assert_index_equal(idx, idx_p)",
        "begin_line": 23,
        "end_line": 39,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_pickle_after_set_freq#41",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_pickle_after_set_freq(self)",
        "snippet": "    def test_pickle_after_set_freq(self):\n        dti = date_range(\"20130101\", periods=3, tz=\"US/Eastern\", name=\"foo\")\n        dti = dti._with_freq(None)\n\n        res = tm.round_trip_pickle(dti)\n        tm.assert_index_equal(res, dti)",
        "begin_line": 41,
        "end_line": 46,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_reindex_preserves_tz_if_target_is_empty_list_or_array#48",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_reindex_preserves_tz_if_target_is_empty_list_or_array(self)",
        "snippet": "    def test_reindex_preserves_tz_if_target_is_empty_list_or_array(self):\n        # GH7774\n        index = date_range(\"20130101\", periods=3, tz=\"US/Eastern\")\n        assert str(index.reindex([])[0].tz) == \"US/Eastern\"\n        assert str(index.reindex(np.array([]))[0].tz) == \"US/Eastern\"",
        "begin_line": 48,
        "end_line": 52,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_reindex_with_same_tz#54",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_reindex_with_same_tz(self)",
        "snippet": "    def test_reindex_with_same_tz(self):\n        # GH 32740\n        rng_a = date_range(\"2010-01-01\", \"2010-01-02\", periods=24, tz=\"utc\")\n        rng_b = date_range(\"2010-01-01\", \"2010-01-02\", periods=23, tz=\"utc\")\n        result1, result2 = rng_a.reindex(\n            rng_b, method=\"nearest\", tolerance=timedelta(seconds=20)\n        )\n        expected_list1 = [\n            \"2010-01-01 00:00:00\",\n            \"2010-01-01 01:05:27.272727272\",\n            \"2010-01-01 02:10:54.545454545\",\n            \"2010-01-01 03:16:21.818181818\",\n            \"2010-01-01 04:21:49.090909090\",\n            \"2010-01-01 05:27:16.363636363\",\n            \"2010-01-01 06:32:43.636363636\",\n            \"2010-01-01 07:38:10.909090909\",\n            \"2010-01-01 08:43:38.181818181\",\n            \"2010-01-01 09:49:05.454545454\",\n            \"2010-01-01 10:54:32.727272727\",\n            \"2010-01-01 12:00:00\",\n            \"2010-01-01 13:05:27.272727272\",\n            \"2010-01-01 14:10:54.545454545\",\n            \"2010-01-01 15:16:21.818181818\",\n            \"2010-01-01 16:21:49.090909090\",\n            \"2010-01-01 17:27:16.363636363\",\n            \"2010-01-01 18:32:43.636363636\",\n            \"2010-01-01 19:38:10.909090909\",\n            \"2010-01-01 20:43:38.181818181\",\n            \"2010-01-01 21:49:05.454545454\",\n            \"2010-01-01 22:54:32.727272727\",\n            \"2010-01-02 00:00:00\",\n        ]\n        expected1 = DatetimeIndex(\n            expected_list1, dtype=\"datetime64[ns, UTC]\", freq=None,\n        )\n        expected2 = np.array([0] + [-1] * 21 + [23], dtype=np.int64,)\n        tm.assert_index_equal(result1, expected1)\n        tm.assert_numpy_array_equal(result2, expected2)",
        "begin_line": 54,
        "end_line": 91,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_time_loc#93",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_time_loc(self)",
        "snippet": "    def test_time_loc(self):  # GH8667\n        from datetime import time\n        from pandas._libs.index import _SIZE_CUTOFF\n\n        ns = _SIZE_CUTOFF + np.array([-100, 100], dtype=np.int64)\n        key = time(15, 11, 30)\n        start = key.hour * 3600 + key.minute * 60 + key.second\n        step = 24 * 3600\n\n        for n in ns:\n            idx = pd.date_range(\"2014-11-26\", periods=n, freq=\"S\")\n            ts = pd.Series(np.random.randn(n), index=idx)\n            i = np.arange(start, n, step)\n\n            tm.assert_numpy_array_equal(ts.index.get_loc(key), i, check_dtype=False)\n            tm.assert_series_equal(ts[key], ts.iloc[i])\n\n            left, right = ts.copy(), ts.copy()\n            left[key] *= -10\n            right.iloc[i] *= -10\n            tm.assert_series_equal(left, right)",
        "begin_line": 93,
        "end_line": 113,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_time_overflow_for_32bit_machines#115",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_time_overflow_for_32bit_machines(self)",
        "snippet": "    def test_time_overflow_for_32bit_machines(self):\n        # GH8943.  On some machines NumPy defaults to np.int32 (for example,\n        # 32-bit Linux machines).  In the function _generate_regular_range\n        # found in tseries/index.py, `periods` gets multiplied by `strides`\n        # (which has value 1e9) and since the max value for np.int32 is ~2e9,\n        # and since those machines won't promote np.int32 to np.int64, we get\n        # overflow.\n        periods = np.int_(1000)\n\n        idx1 = pd.date_range(start=\"2000\", periods=periods, freq=\"S\")\n        assert len(idx1) == periods\n\n        idx2 = pd.date_range(end=\"2000\", periods=periods, freq=\"S\")\n        assert len(idx2) == periods",
        "begin_line": 115,
        "end_line": 128,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_nat#130",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_nat(self)",
        "snippet": "    def test_nat(self):\n        assert DatetimeIndex([np.nan])[0] is pd.NaT",
        "begin_line": 130,
        "end_line": 131,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_week_of_month_frequency#133",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_week_of_month_frequency(self)",
        "snippet": "    def test_week_of_month_frequency(self):\n        # GH 5348: \"ValueError: Could not evaluate WOM-1SUN\" shouldn't raise\n        d1 = date(2002, 9, 1)\n        d2 = date(2013, 10, 27)\n        d3 = date(2012, 9, 30)\n        idx1 = DatetimeIndex([d1, d2])\n        idx2 = DatetimeIndex([d3])\n        result_append = idx1.append(idx2)\n        expected = DatetimeIndex([d1, d2, d3])\n        tm.assert_index_equal(result_append, expected)\n        result_union = idx1.union(idx2)\n        expected = DatetimeIndex([d1, d3, d2])\n        tm.assert_index_equal(result_union, expected)\n\n        # GH 5115\n        result = date_range(\"2013-1-1\", periods=4, freq=\"WOM-1SAT\")\n        dates = [\"2013-01-05\", \"2013-02-02\", \"2013-03-02\", \"2013-04-06\"]\n        expected = DatetimeIndex(dates, freq=\"WOM-1SAT\")\n        tm.assert_index_equal(result, expected)",
        "begin_line": 133,
        "end_line": 151,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_stringified_slice_with_tz#153",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_stringified_slice_with_tz(self)",
        "snippet": "    def test_stringified_slice_with_tz(self):\n        # GH#2658\n        start = \"2013-01-07\"\n        idx = date_range(start=start, freq=\"1d\", periods=10, tz=\"US/Eastern\")\n        df = DataFrame(np.arange(10), index=idx)\n        df[\"2013-01-14 23:44:34.437768-05:00\":]  # no exception here",
        "begin_line": 153,
        "end_line": 158,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_append_nondatetimeindex#160",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_append_nondatetimeindex(self)",
        "snippet": "    def test_append_nondatetimeindex(self):\n        rng = date_range(\"1/1/2000\", periods=10)\n        idx = Index([\"a\", \"b\", \"c\", \"d\"])\n\n        result = rng.append(idx)\n        assert isinstance(result[0], Timestamp)",
        "begin_line": 160,
        "end_line": 165,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_map#167",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_map(self)",
        "snippet": "    def test_map(self):\n        rng = date_range(\"1/1/2000\", periods=10)\n\n        f = lambda x: x.strftime(\"%Y%m%d\")\n        result = rng.map(f)\n        exp = Index([f(x) for x in rng], dtype=\"<U8\")\n        tm.assert_index_equal(result, exp)",
        "begin_line": 167,
        "end_line": 173,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_map_fallthrough#175",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_map_fallthrough(self, capsys)",
        "snippet": "    def test_map_fallthrough(self, capsys):\n        # GH#22067, check we don't get warnings about silently ignored errors\n        dti = date_range(\"2017-01-01\", \"2018-01-01\", freq=\"B\")\n\n        dti.map(lambda x: pd.Period(year=x.year, month=x.month, freq=\"M\"))\n\n        captured = capsys.readouterr()\n        assert captured.err == \"\"",
        "begin_line": 175,
        "end_line": 182,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_iteration_preserves_tz#184",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_iteration_preserves_tz(self)",
        "snippet": "    def test_iteration_preserves_tz(self):\n        # see gh-8890\n        index = date_range(\"2012-01-01\", periods=3, freq=\"H\", tz=\"US/Eastern\")\n\n        for i, ts in enumerate(index):\n            result = ts\n            expected = index[i]\n            assert result == expected\n\n        index = date_range(\n            \"2012-01-01\", periods=3, freq=\"H\", tz=dateutil.tz.tzoffset(None, -28800)\n        )\n\n        for i, ts in enumerate(index):\n            result = ts\n            expected = index[i]\n            assert result._repr_base == expected._repr_base\n            assert result == expected\n\n        # 9100\n        index = pd.DatetimeIndex(\n            [\"2014-12-01 03:32:39.987000-08:00\", \"2014-12-01 04:12:34.987000-08:00\"]\n        )\n        for i, ts in enumerate(index):\n            result = ts\n            expected = index[i]\n            assert result._repr_base == expected._repr_base\n            assert result == expected",
        "begin_line": 184,
        "end_line": 211,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_iteration_over_chunksize#214",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_iteration_over_chunksize(self, periods)",
        "snippet": "    def test_iteration_over_chunksize(self, periods):\n        # GH21012\n\n        index = date_range(\"2000-01-01 00:00:00\", periods=periods, freq=\"min\")\n        num = 0\n        for stamp in index:\n            assert index[num] == stamp\n            num += 1\n        assert num == len(index)",
        "begin_line": 214,
        "end_line": 222,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_misc_coverage#224",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_misc_coverage(self)",
        "snippet": "    def test_misc_coverage(self):\n        rng = date_range(\"1/1/2000\", periods=5)\n        result = rng.groupby(rng.day)\n        assert isinstance(list(result.values())[0][0], Timestamp)\n\n        idx = DatetimeIndex([\"2000-01-03\", \"2000-01-01\", \"2000-01-02\"])\n        assert not idx.equals(list(idx))\n\n        non_datetime = Index(list(\"abc\"))\n        assert not idx.equals(list(non_datetime))",
        "begin_line": 224,
        "end_line": 233,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_string_index_series_name_converted#235",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_string_index_series_name_converted(self)",
        "snippet": "    def test_string_index_series_name_converted(self):\n        # #1644\n        df = DataFrame(np.random.randn(10, 4), index=date_range(\"1/1/2000\", periods=10))\n\n        result = df.loc[\"1/3/2000\"]\n        assert result.name == df.index[2]\n\n        result = df.T[\"1/3/2000\"]\n        assert result.name == df.index[2]",
        "begin_line": 235,
        "end_line": 243,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_argmin_argmax#245",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_argmin_argmax(self)",
        "snippet": "    def test_argmin_argmax(self):\n        idx = DatetimeIndex([\"2000-01-04\", \"2000-01-01\", \"2000-01-02\"])\n        assert idx.argmin() == 1\n        assert idx.argmax() == 0",
        "begin_line": 245,
        "end_line": 248,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_sort_values#250",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_sort_values(self)",
        "snippet": "    def test_sort_values(self):\n        idx = DatetimeIndex([\"2000-01-04\", \"2000-01-01\", \"2000-01-02\"])\n\n        ordered = idx.sort_values()\n        assert ordered.is_monotonic\n\n        ordered = idx.sort_values(ascending=False)\n        assert ordered[::-1].is_monotonic\n\n        ordered, dexer = idx.sort_values(return_indexer=True)\n        assert ordered.is_monotonic\n        tm.assert_numpy_array_equal(dexer, np.array([1, 2, 0], dtype=np.intp))\n\n        ordered, dexer = idx.sort_values(return_indexer=True, ascending=False)\n        assert ordered[::-1].is_monotonic\n        tm.assert_numpy_array_equal(dexer, np.array([0, 2, 1], dtype=np.intp))",
        "begin_line": 250,
        "end_line": 265,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_map_bug_1677#267",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_map_bug_1677(self)",
        "snippet": "    def test_map_bug_1677(self):\n        index = DatetimeIndex([\"2012-04-25 09:30:00.393000\"])\n        f = index.asof\n\n        result = index.map(f)\n        expected = Index([f(index[0])])\n        tm.assert_index_equal(result, expected)",
        "begin_line": 267,
        "end_line": 273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_groupby_function_tuple_1677#275",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_groupby_function_tuple_1677(self)",
        "snippet": "    def test_groupby_function_tuple_1677(self):\n        df = DataFrame(np.random.rand(100), index=date_range(\"1/1/2000\", periods=100))\n        monthly_group = df.groupby(lambda x: (x.year, x.month))\n\n        result = monthly_group.mean()\n        assert isinstance(result.index[0], tuple)",
        "begin_line": 275,
        "end_line": 280,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_append_numpy_bug_1681#282",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_append_numpy_bug_1681(self)",
        "snippet": "    def test_append_numpy_bug_1681(self):\n        # another datetime64 bug\n        dr = date_range(\"2011/1/1\", \"2012/1/1\", freq=\"W-FRI\")\n        a = DataFrame()\n        c = DataFrame({\"A\": \"foo\", \"B\": dr}, index=dr)\n\n        result = a.append(c)\n        assert (result[\"B\"] == dr).all()",
        "begin_line": 282,
        "end_line": 289,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_isin#291",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_isin(self)",
        "snippet": "    def test_isin(self):\n        index = tm.makeDateIndex(4)\n        result = index.isin(index)\n        assert result.all()\n\n        result = index.isin(list(index))\n        assert result.all()\n\n        tm.assert_almost_equal(\n            index.isin([index[2], 5]), np.array([False, False, True, False])\n        )",
        "begin_line": 291,
        "end_line": 301,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.assert_index_parameters#303",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.assert_index_parameters(self, index)",
        "snippet": "    def assert_index_parameters(self, index):\n        assert index.freq == \"40960N\"\n        assert index.inferred_freq == \"40960N\"",
        "begin_line": 303,
        "end_line": 305,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_ns_index#307",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_ns_index(self)",
        "snippet": "    def test_ns_index(self):\n        nsamples = 400\n        ns = int(1e9 / 24414)\n        dtstart = np.datetime64(\"2012-09-20T00:00:00\")\n\n        dt = dtstart + np.arange(nsamples) * np.timedelta64(ns, \"ns\")\n        freq = ns * offsets.Nano()\n        index = pd.DatetimeIndex(dt, freq=freq, name=\"time\")\n        self.assert_index_parameters(index)\n\n        new_index = pd.date_range(start=index[0], end=index[-1], freq=index.freq)\n        self.assert_index_parameters(new_index)",
        "begin_line": 307,
        "end_line": 318,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_factorize#320",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_factorize(self)",
        "snippet": "    def test_factorize(self):\n        idx1 = DatetimeIndex(\n            [\"2014-01\", \"2014-01\", \"2014-02\", \"2014-02\", \"2014-03\", \"2014-03\"]\n        )\n\n        exp_arr = np.array([0, 0, 1, 1, 2, 2], dtype=np.intp)\n        exp_idx = DatetimeIndex([\"2014-01\", \"2014-02\", \"2014-03\"])\n\n        arr, idx = idx1.factorize()\n        tm.assert_numpy_array_equal(arr, exp_arr)\n        tm.assert_index_equal(idx, exp_idx)\n\n        arr, idx = idx1.factorize(sort=True)\n        tm.assert_numpy_array_equal(arr, exp_arr)\n        tm.assert_index_equal(idx, exp_idx)\n\n        # tz must be preserved\n        idx1 = idx1.tz_localize(\"Asia/Tokyo\")\n        exp_idx = exp_idx.tz_localize(\"Asia/Tokyo\")\n\n        arr, idx = idx1.factorize()\n        tm.assert_numpy_array_equal(arr, exp_arr)\n        tm.assert_index_equal(idx, exp_idx)\n\n        idx2 = pd.DatetimeIndex(\n            [\"2014-03\", \"2014-03\", \"2014-02\", \"2014-01\", \"2014-03\", \"2014-01\"]\n        )\n\n        exp_arr = np.array([2, 2, 1, 0, 2, 0], dtype=np.intp)\n        exp_idx = DatetimeIndex([\"2014-01\", \"2014-02\", \"2014-03\"])\n        arr, idx = idx2.factorize(sort=True)\n        tm.assert_numpy_array_equal(arr, exp_arr)\n        tm.assert_index_equal(idx, exp_idx)\n\n        exp_arr = np.array([0, 0, 1, 2, 0, 2], dtype=np.intp)\n        exp_idx = DatetimeIndex([\"2014-03\", \"2014-02\", \"2014-01\"])\n        arr, idx = idx2.factorize()\n        tm.assert_numpy_array_equal(arr, exp_arr)\n        tm.assert_index_equal(idx, exp_idx)\n\n        # freq must be preserved\n        idx3 = date_range(\"2000-01\", periods=4, freq=\"M\", tz=\"Asia/Tokyo\")\n        exp_arr = np.array([0, 1, 2, 3], dtype=np.intp)\n        arr, idx = idx3.factorize()\n        tm.assert_numpy_array_equal(arr, exp_arr)\n        tm.assert_index_equal(idx, idx3)",
        "begin_line": 320,
        "end_line": 365,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_factorize_tz#367",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_factorize_tz(self, tz_naive_fixture)",
        "snippet": "    def test_factorize_tz(self, tz_naive_fixture):\n        tz = tz_naive_fixture\n        # GH#13750\n        base = pd.date_range(\"2016-11-05\", freq=\"H\", periods=100, tz=tz)\n        idx = base.repeat(5)\n\n        exp_arr = np.arange(100, dtype=np.intp).repeat(5)\n\n        for obj in [idx, pd.Series(idx)]:\n            arr, res = obj.factorize()\n            tm.assert_numpy_array_equal(arr, exp_arr)\n            expected = base._with_freq(None)\n            tm.assert_index_equal(res, expected)",
        "begin_line": 367,
        "end_line": 379,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_factorize_dst#381",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_factorize_dst(self)",
        "snippet": "    def test_factorize_dst(self):\n        # GH 13750\n        idx = pd.date_range(\"2016-11-06\", freq=\"H\", periods=12, tz=\"US/Eastern\")\n\n        for obj in [idx, pd.Series(idx)]:\n            arr, res = obj.factorize()\n            tm.assert_numpy_array_equal(arr, np.arange(12, dtype=np.intp))\n            tm.assert_index_equal(res, idx)\n\n        idx = pd.date_range(\"2016-06-13\", freq=\"H\", periods=12, tz=\"US/Eastern\")\n\n        for obj in [idx, pd.Series(idx)]:\n            arr, res = obj.factorize()\n            tm.assert_numpy_array_equal(arr, np.arange(12, dtype=np.intp))\n            tm.assert_index_equal(res, idx)",
        "begin_line": 381,
        "end_line": 395,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_unique#407",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_unique(self, arr, expected)",
        "snippet": "    def test_unique(self, arr, expected):\n        result = arr.unique()\n        tm.assert_index_equal(result, expected)\n        # GH 21737\n        # Ensure the underlying data is consistent\n        assert result[0] == expected[0]",
        "begin_line": 407,
        "end_line": 412,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_asarray_tz_naive#414",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_asarray_tz_naive(self)",
        "snippet": "    def test_asarray_tz_naive(self):\n        # This shouldn't produce a warning.\n        idx = pd.date_range(\"2000\", periods=2)\n        # M8[ns] by default\n        result = np.asarray(idx)\n\n        expected = np.array([\"2000-01-01\", \"2000-01-02\"], dtype=\"M8[ns]\")\n        tm.assert_numpy_array_equal(result, expected)\n\n        # optionally, object\n        result = np.asarray(idx, dtype=object)\n\n        expected = np.array([pd.Timestamp(\"2000-01-01\"), pd.Timestamp(\"2000-01-02\")])\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 414,
        "end_line": 427,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_asarray_tz_aware#429",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_asarray_tz_aware(self)",
        "snippet": "    def test_asarray_tz_aware(self):\n        tz = \"US/Central\"\n        idx = pd.date_range(\"2000\", periods=2, tz=tz)\n        expected = np.array([\"2000-01-01T06\", \"2000-01-02T06\"], dtype=\"M8[ns]\")\n        result = np.asarray(idx, dtype=\"datetime64[ns]\")\n\n        tm.assert_numpy_array_equal(result, expected)\n\n        # Old behavior with no warning\n        result = np.asarray(idx, dtype=\"M8[ns]\")\n\n        tm.assert_numpy_array_equal(result, expected)\n\n        # Future behavior with no warning\n        expected = np.array(\n            [pd.Timestamp(\"2000-01-01\", tz=tz), pd.Timestamp(\"2000-01-02\", tz=tz)]\n        )\n        result = np.asarray(idx, dtype=object)\n\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 429,
        "end_line": 448,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_to_frame_datetime_tz#450",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_to_frame_datetime_tz(self)",
        "snippet": "    def test_to_frame_datetime_tz(self):\n        # GH 25809\n        idx = date_range(start=\"2019-01-01\", end=\"2019-01-30\", freq=\"D\", tz=\"UTC\")\n        result = idx.to_frame()\n        expected = DataFrame(idx, index=idx)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 450,
        "end_line": 455,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_index_map#458",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_index_map(self, name)",
        "snippet": "    def test_index_map(self, name):\n        # see GH20990\n        count = 6\n        index = pd.date_range(\"2018-01-01\", periods=count, freq=\"M\", name=name).map(\n            lambda x: (x.year, x.month)\n        )\n        exp_index = pd.MultiIndex.from_product(\n            ((2018,), range(1, 7)), names=[name, name]\n        )\n        tm.assert_index_equal(index, exp_index)",
        "begin_line": 458,
        "end_line": 467,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_split_non_utc#469",
        "src_path": "pandas/tests/indexes/datetimes/test_datetime.py",
        "class_name": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex",
        "signature": "pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex.test_split_non_utc(self)",
        "snippet": "    def test_split_non_utc(self):\n        # GH 14042\n        indices = pd.date_range(\"2016-01-01 00:00:00+0200\", freq=\"S\", periods=10)\n        result = np.split(indices, indices_or_sections=[])[0]\n        expected = indices._with_freq(None)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 469,
        "end_line": 474,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_pickle_compat_construction#41",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_pickle_compat_construction(self)",
        "snippet": "    def test_pickle_compat_construction(self):\n        # need an object to create with\n        msg = (\n            r\"Index\\(\\.\\.\\.\\) must be called with a collection of some \"\n            r\"kind, None was passed|\"\n            r\"__new__\\(\\) missing 1 required positional argument: 'data'|\"\n            r\"__new__\\(\\) takes at least 2 arguments \\(1 given\\)\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            self._holder()",
        "begin_line": 41,
        "end_line": 50,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_frame#53",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_frame(self, name)",
        "snippet": "    def test_to_frame(self, name):\n        # see GH-15230, GH-22580\n        idx = self.create_index()\n\n        if name:\n            idx_name = name\n        else:\n            idx_name = idx.name or 0\n\n        df = idx.to_frame(name=idx_name)\n\n        assert df.index is idx\n        assert len(df.columns) == 1\n        assert df.columns[0] == idx_name\n        assert df[idx_name].values is not idx.values\n\n        df = idx.to_frame(index=False, name=idx_name)\n        assert df.index is not idx",
        "begin_line": 53,
        "end_line": 70,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_shift#72",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_shift(self)",
        "snippet": "    def test_shift(self):\n\n        # GH8083 test the base class for shift\n        idx = self.create_index()\n        msg = f\"Not supported for type {type(idx).__name__}\"\n        with pytest.raises(NotImplementedError, match=msg):\n            idx.shift(1)\n        with pytest.raises(NotImplementedError, match=msg):\n            idx.shift(1, 2)",
        "begin_line": 72,
        "end_line": 80,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_constructor_name_unhashable#82",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_constructor_name_unhashable(self)",
        "snippet": "    def test_constructor_name_unhashable(self):\n        # GH#29069 check that name is hashable\n        # See also same-named test in tests.series.test_constructors\n        idx = self.create_index()\n        with pytest.raises(TypeError, match=\"Index.name must be a hashable type\"):\n            type(idx)(idx, name=[])",
        "begin_line": 82,
        "end_line": 87,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_create_index_existing_name#89",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_create_index_existing_name(self)",
        "snippet": "    def test_create_index_existing_name(self):\n\n        # GH11193, when an existing index is passed, and a new name is not\n        # specified, the new index should inherit the previous object name\n        expected = self.create_index()\n        if not isinstance(expected, MultiIndex):\n            expected.name = \"foo\"\n            result = pd.Index(expected)\n            tm.assert_index_equal(result, expected)\n\n            result = pd.Index(expected, name=\"bar\")\n            expected.name = \"bar\"\n            tm.assert_index_equal(result, expected)\n        else:\n            expected.names = [\"foo\", \"bar\"]\n            result = pd.Index(expected)\n            tm.assert_index_equal(\n                result,\n                Index(\n                    Index(\n                        [\n                            (\"foo\", \"one\"),\n                            (\"foo\", \"two\"),\n                            (\"bar\", \"one\"),\n                            (\"baz\", \"two\"),\n                            (\"qux\", \"one\"),\n                            (\"qux\", \"two\"),\n                        ],\n                        dtype=\"object\",\n                    ),\n                    names=[\"foo\", \"bar\"],\n                ),\n            )\n\n            result = pd.Index(expected, names=[\"A\", \"B\"])\n            tm.assert_index_equal(\n                result,\n                Index(\n                    Index(\n                        [\n                            (\"foo\", \"one\"),\n                            (\"foo\", \"two\"),\n                            (\"bar\", \"one\"),\n                            (\"baz\", \"two\"),\n                            (\"qux\", \"one\"),\n                            (\"qux\", \"two\"),\n                        ],\n                        dtype=\"object\",\n                    ),\n                    names=[\"A\", \"B\"],\n                ),\n            )",
        "begin_line": 89,
        "end_line": 140,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numeric_compat#142",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numeric_compat(self)",
        "snippet": "    def test_numeric_compat(self):\n\n        idx = self.create_index()\n        # Check that this doesn't cover MultiIndex case, if/when it does,\n        #  we can remove multi.test_compat.test_numeric_compat\n        assert not isinstance(idx, MultiIndex)\n\n        with pytest.raises(TypeError, match=\"cannot perform __mul__\"):\n            idx * 1\n        with pytest.raises(TypeError, match=\"cannot perform __rmul__\"):\n            1 * idx\n\n        div_err = \"cannot perform __truediv__\"\n        with pytest.raises(TypeError, match=div_err):\n            idx / 1\n\n        div_err = div_err.replace(\" __\", \" __r\")\n        with pytest.raises(TypeError, match=div_err):\n            1 / idx\n        with pytest.raises(TypeError, match=\"cannot perform __floordiv__\"):\n            idx // 1\n        with pytest.raises(TypeError, match=\"cannot perform __rfloordiv__\"):\n            1 // idx",
        "begin_line": 142,
        "end_line": 164,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_logical_compat#166",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_logical_compat(self)",
        "snippet": "    def test_logical_compat(self):\n        idx = self.create_index()\n        with pytest.raises(TypeError, match=\"cannot perform all\"):\n            idx.all()\n        with pytest.raises(TypeError, match=\"cannot perform any\"):\n            idx.any()",
        "begin_line": 166,
        "end_line": 171,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_reindex_base#173",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_reindex_base(self)",
        "snippet": "    def test_reindex_base(self):\n        idx = self.create_index()\n        expected = np.arange(idx.size, dtype=np.intp)\n\n        actual = idx.get_indexer(idx)\n        tm.assert_numpy_array_equal(expected, actual)\n\n        with pytest.raises(ValueError, match=\"Invalid fill method\"):\n            idx.get_indexer(idx, method=\"invalid\")",
        "begin_line": 173,
        "end_line": 181,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_get_indexer_consistency#183",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_get_indexer_consistency(self, indices)",
        "snippet": "    def test_get_indexer_consistency(self, indices):\n        # See GH 16819\n        if isinstance(indices, IntervalIndex):\n            return\n\n        if indices.is_unique or isinstance(indices, CategoricalIndex):\n            indexer = indices.get_indexer(indices[0:2])\n            assert isinstance(indexer, np.ndarray)\n            assert indexer.dtype == np.intp\n        else:\n            e = \"Reindexing only valid with uniquely valued Index objects\"\n            with pytest.raises(InvalidIndexError, match=e):\n                indices.get_indexer(indices[0:2])\n\n        indexer, _ = indices.get_indexer_non_unique(indices[0:2])\n        assert isinstance(indexer, np.ndarray)\n        assert indexer.dtype == np.intp",
        "begin_line": 183,
        "end_line": 199,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_ndarray_compat_properties#201",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_ndarray_compat_properties(self)",
        "snippet": "    def test_ndarray_compat_properties(self):\n        idx = self.create_index()\n        assert idx.T.equals(idx)\n        assert idx.transpose().equals(idx)\n\n        values = idx.values\n        for prop in self._compat_props:\n            assert getattr(idx, prop) == getattr(values, prop)\n\n        # test for validity\n        idx.nbytes\n        idx.values.nbytes",
        "begin_line": 201,
        "end_line": 212,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repr_roundtrip#214",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repr_roundtrip(self)",
        "snippet": "    def test_repr_roundtrip(self):\n\n        idx = self.create_index()\n        tm.assert_index_equal(eval(repr(idx)), idx)",
        "begin_line": 214,
        "end_line": 217,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repr_max_seq_item_setting#219",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repr_max_seq_item_setting(self)",
        "snippet": "    def test_repr_max_seq_item_setting(self):\n        # GH10182\n        idx = self.create_index()\n        idx = idx.repeat(50)\n        with pd.option_context(\"display.max_seq_items\", None):\n            repr(idx)\n            assert \"...\" not in str(idx)",
        "begin_line": 219,
        "end_line": 225,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_copy_name#227",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_copy_name(self, indices)",
        "snippet": "    def test_copy_name(self, indices):\n        # gh-12309: Check that the \"name\" argument\n        # passed at initialization is honored.\n        if isinstance(indices, MultiIndex):\n            return\n\n        first = type(indices)(indices, copy=True, name=\"mario\")\n        second = type(first)(first, copy=False)\n\n        # Even though \"copy=False\", we want a new object.\n        assert first is not second\n\n        # Not using tm.assert_index_equal() since names differ.\n        assert indices.equals(first)\n\n        assert first.name == \"mario\"\n        assert second.name == \"mario\"\n\n        s1 = Series(2, index=first)\n        s2 = Series(3, index=second[:-1])\n\n        if not isinstance(indices, CategoricalIndex):\n            # See gh-13365\n            s3 = s1 * s2\n            assert s3.index.name == \"mario\"",
        "begin_line": 227,
        "end_line": 251,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_ensure_copied_data#253",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_ensure_copied_data(self, indices)",
        "snippet": "    def test_ensure_copied_data(self, indices):\n        # Check the \"copy\" argument of each Index.__new__ is honoured\n        # GH12309\n        init_kwargs = {}\n        if isinstance(indices, PeriodIndex):\n            # Needs \"freq\" specification:\n            init_kwargs[\"freq\"] = indices.freq\n        elif isinstance(indices, (RangeIndex, MultiIndex, CategoricalIndex)):\n            # RangeIndex cannot be initialized from data\n            # MultiIndex and CategoricalIndex are tested separately\n            return\n\n        index_type = type(indices)\n        result = index_type(indices.values, copy=True, **init_kwargs)\n        if is_datetime64tz_dtype(indices.dtype):\n            result = result.tz_localize(\"UTC\").tz_convert(indices.tz)\n        if isinstance(indices, (DatetimeIndex, TimedeltaIndex)):\n            indices = indices._with_freq(None)\n\n        tm.assert_index_equal(indices, result)\n\n        if isinstance(indices, PeriodIndex):\n            # .values an object array of Period, thus copied\n            result = index_type(ordinal=indices.asi8, copy=False, **init_kwargs)\n            tm.assert_numpy_array_equal(indices.asi8, result.asi8, check_same=\"same\")\n        elif isinstance(indices, IntervalIndex):\n            # checked in test_interval.py\n            pass\n        else:\n            result = index_type(indices.values, copy=False, **init_kwargs)\n            tm.assert_numpy_array_equal(\n                indices.values, result.values, check_same=\"same\"\n            )",
        "begin_line": 253,
        "end_line": 285,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_memory_usage#287",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_memory_usage(self, indices)",
        "snippet": "    def test_memory_usage(self, indices):\n        indices._engine.clear_mapping()\n        result = indices.memory_usage()\n        if indices.empty:\n            # we report 0 for no-length\n            assert result == 0\n            return\n\n        # non-zero length\n        indices.get_loc(indices[0])\n        result2 = indices.memory_usage()\n        result3 = indices.memory_usage(deep=True)\n\n        # RangeIndex, IntervalIndex\n        # don't have engines\n        if not isinstance(indices, (RangeIndex, IntervalIndex)):\n            assert result2 > result\n\n        if indices.inferred_type == \"object\":\n            assert result3 > result2",
        "begin_line": 287,
        "end_line": 306,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_argsort#308",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_argsort(self, request, indices)",
        "snippet": "    def test_argsort(self, request, indices):\n        # separately tested\n        if isinstance(indices, CategoricalIndex):\n            return\n\n        result = indices.argsort()\n        expected = np.array(indices).argsort()\n        tm.assert_numpy_array_equal(result, expected, check_dtype=False)",
        "begin_line": 308,
        "end_line": 315,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numpy_argsort#317",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numpy_argsort(self, indices)",
        "snippet": "    def test_numpy_argsort(self, indices):\n        result = np.argsort(indices)\n        expected = indices.argsort()\n        tm.assert_numpy_array_equal(result, expected)\n\n        # these are the only two types that perform\n        # pandas compatibility input validation - the\n        # rest already perform separate (or no) such\n        # validation via their 'values' attribute as\n        # defined in pandas.core.indexes/base.py - they\n        # cannot be changed at the moment due to\n        # backwards compatibility concerns\n        if isinstance(type(indices), (CategoricalIndex, RangeIndex)):\n            msg = \"the 'axis' parameter is not supported\"\n            with pytest.raises(ValueError, match=msg):\n                np.argsort(indices, axis=1)\n\n            msg = \"the 'kind' parameter is not supported\"\n            with pytest.raises(ValueError, match=msg):\n                np.argsort(indices, kind=\"mergesort\")\n\n            msg = \"the 'order' parameter is not supported\"\n            with pytest.raises(ValueError, match=msg):\n                np.argsort(indices, order=(\"a\", \"b\"))",
        "begin_line": 317,
        "end_line": 340,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_take#342",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_take(self, indices)",
        "snippet": "    def test_take(self, indices):\n        indexer = [4, 3, 0, 2]\n        if len(indices) < 5:\n            # not enough elements; ignore\n            return\n\n        result = indices.take(indexer)\n        expected = indices[indexer]\n        assert result.equals(expected)\n\n        if not isinstance(indices, (DatetimeIndex, PeriodIndex, TimedeltaIndex)):\n            # GH 10791\n            msg = r\"'(.*Index)' object has no attribute 'freq'\"\n            with pytest.raises(AttributeError, match=msg):\n                indices.freq",
        "begin_line": 342,
        "end_line": 356,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_take_invalid_kwargs#358",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_take_invalid_kwargs(self)",
        "snippet": "    def test_take_invalid_kwargs(self):\n        idx = self.create_index()\n        indices = [1, 2]\n\n        msg = r\"take\\(\\) got an unexpected keyword argument 'foo'\"\n        with pytest.raises(TypeError, match=msg):\n            idx.take(indices, foo=2)\n\n        msg = \"the 'out' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            idx.take(indices, out=indices)\n\n        msg = \"the 'mode' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            idx.take(indices, mode=\"clip\")",
        "begin_line": 358,
        "end_line": 372,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repeat#374",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repeat(self)",
        "snippet": "    def test_repeat(self):\n        rep = 2\n        i = self.create_index()\n        expected = pd.Index(i.values.repeat(rep), name=i.name)\n        tm.assert_index_equal(i.repeat(rep), expected)\n\n        i = self.create_index()\n        rep = np.arange(len(i))\n        expected = pd.Index(i.values.repeat(rep), name=i.name)\n        tm.assert_index_equal(i.repeat(rep), expected)",
        "begin_line": 374,
        "end_line": 383,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numpy_repeat#385",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numpy_repeat(self)",
        "snippet": "    def test_numpy_repeat(self):\n        rep = 2\n        i = self.create_index()\n        expected = i.repeat(rep)\n        tm.assert_index_equal(np.repeat(i, rep), expected)\n\n        msg = \"the 'axis' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            np.repeat(i, rep, axis=0)",
        "begin_line": 385,
        "end_line": 393,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_where#396",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_where(self, klass)",
        "snippet": "    def test_where(self, klass):\n        i = self.create_index()\n        if isinstance(i, (pd.DatetimeIndex, pd.TimedeltaIndex)):\n            # where does not preserve freq\n            i = i._with_freq(None)\n\n        cond = [True] * len(i)\n        result = i.where(klass(cond))\n        expected = i\n        tm.assert_index_equal(result, expected)\n\n        cond = [False] + [True] * len(i[1:])\n        expected = pd.Index([i._na_value] + i[1:].tolist(), dtype=i.dtype)\n        result = i.where(klass(cond))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 396,
        "end_line": 410,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_set_ops_error_cases#416",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_set_ops_error_cases(self, case, method, indices)",
        "snippet": "    def test_set_ops_error_cases(self, case, method, indices):\n        # non-iterable input\n        msg = \"Input must be Index or array-like\"\n        with pytest.raises(TypeError, match=msg):\n            getattr(indices, method)(case)",
        "begin_line": 416,
        "end_line": 420,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_intersection_base#422",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_intersection_base(self, indices)",
        "snippet": "    def test_intersection_base(self, indices):\n        if isinstance(indices, CategoricalIndex):\n            return\n\n        first = indices[:5]\n        second = indices[:3]\n        intersect = first.intersection(second)\n        assert tm.equalContents(intersect, second)\n\n        if is_datetime64tz_dtype(indices.dtype):\n            # The second.values below will drop tz, so the rest of this test\n            #  is not applicable.\n            return\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            result = first.intersection(case)\n            assert tm.equalContents(result, second)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.intersection([1, 2, 3])",
        "begin_line": 422,
        "end_line": 445,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_union_base#447",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_union_base(self, indices)",
        "snippet": "    def test_union_base(self, indices):\n        first = indices[3:]\n        second = indices[:5]\n        everything = indices\n        union = first.union(second)\n        assert tm.equalContents(union, everything)\n\n        if is_datetime64tz_dtype(indices.dtype):\n            # The second.values below will drop tz, so the rest of this test\n            #  is not applicable.\n            return\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            if not isinstance(indices, CategoricalIndex):\n                result = first.union(case)\n                assert tm.equalContents(result, everything)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.union([1, 2, 3])",
        "begin_line": 447,
        "end_line": 469,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_difference_base#471",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_difference_base(self, sort, indices)",
        "snippet": "    def test_difference_base(self, sort, indices):\n        first = indices[2:]\n        second = indices[:4]\n        if isinstance(indices, CategoricalIndex) or indices.is_boolean():\n            answer = []\n        else:\n            answer = indices[4:]\n        result = first.difference(second, sort)\n        assert tm.equalContents(result, answer)\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            if isinstance(indices, (DatetimeIndex, TimedeltaIndex)):\n                assert type(result) == type(answer)\n                tm.assert_numpy_array_equal(\n                    result.sort_values().asi8, answer.sort_values().asi8\n                )\n            else:\n                result = first.difference(case, sort)\n                assert tm.equalContents(result, answer)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.difference([1, 2, 3], sort)",
        "begin_line": 471,
        "end_line": 496,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_symmetric_difference#498",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_symmetric_difference(self, indices)",
        "snippet": "    def test_symmetric_difference(self, indices):\n        if isinstance(indices, CategoricalIndex):\n            return\n\n        first = indices[1:]\n        second = indices[:-1]\n        answer = indices[[0, -1]]\n        result = first.symmetric_difference(second)\n        assert tm.equalContents(result, answer)\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            result = first.symmetric_difference(case)\n            assert tm.equalContents(result, answer)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.symmetric_difference([1, 2, 3])",
        "begin_line": 498,
        "end_line": 517,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_insert_base#519",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_insert_base(self, indices)",
        "snippet": "    def test_insert_base(self, indices):\n        result = indices[1:4]\n\n        if not len(indices):\n            return\n\n        # test 0th element\n        assert indices[0:4].equals(result.insert(0, indices[0]))",
        "begin_line": 519,
        "end_line": 526,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_delete_base#528",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_delete_base(self, indices)",
        "snippet": "    def test_delete_base(self, indices):\n        if not len(indices):\n            return\n\n        if isinstance(indices, RangeIndex):\n            # tested in class\n            return\n\n        expected = indices[1:]\n        result = indices.delete(0)\n        assert result.equals(expected)\n        assert result.name == expected.name\n\n        expected = indices[:-1]\n        result = indices.delete(-1)\n        assert result.equals(expected)\n        assert result.name == expected.name\n\n        length = len(indices)\n        msg = f\"index {length} is out of bounds for axis 0 with size {length}\"\n        with pytest.raises(IndexError, match=msg):\n            indices.delete(length)",
        "begin_line": 528,
        "end_line": 549,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_equals#551",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_equals(self, indices)",
        "snippet": "    def test_equals(self, indices):\n        if isinstance(indices, IntervalIndex):\n            # IntervalIndex tested separately\n            return\n\n        assert indices.equals(indices)\n        assert indices.equals(indices.copy())\n        assert indices.equals(indices.astype(object))\n\n        assert not indices.equals(list(indices))\n        assert not indices.equals(np.array(indices))\n\n        # Cannot pass in non-int64 dtype to RangeIndex\n        if not isinstance(indices, (RangeIndex, CategoricalIndex)):\n            # TODO: CategoricalIndex can be re-allowed following GH#32167\n            same_values = Index(indices, dtype=object)\n            assert indices.equals(same_values)\n            assert same_values.equals(indices)\n\n        if indices.nlevels == 1:\n            # do not test MultiIndex\n            assert not indices.equals(Series(indices))",
        "begin_line": 551,
        "end_line": 572,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_equals_op#574",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_equals_op(self)",
        "snippet": "    def test_equals_op(self):\n        # GH9947, GH10637\n        index_a = self.create_index()\n        if isinstance(index_a, PeriodIndex):\n            pytest.skip(\"Skip check for PeriodIndex\")\n\n        n = len(index_a)\n        index_b = index_a[0:-1]\n        index_c = index_a[0:-1].append(index_a[-2:-1])\n        index_d = index_a[0:1]\n\n        msg = \"Lengths must match|could not be broadcast\"\n        with pytest.raises(ValueError, match=msg):\n            index_a == index_b\n        expected1 = np.array([True] * n)\n        expected2 = np.array([True] * (n - 1) + [False])\n        tm.assert_numpy_array_equal(index_a == index_a, expected1)\n        tm.assert_numpy_array_equal(index_a == index_c, expected2)\n\n        # test comparisons with numpy arrays\n        array_a = np.array(index_a)\n        array_b = np.array(index_a[0:-1])\n        array_c = np.array(index_a[0:-1].append(index_a[-2:-1]))\n        array_d = np.array(index_a[0:1])\n        with pytest.raises(ValueError, match=msg):\n            index_a == array_b\n        tm.assert_numpy_array_equal(index_a == array_a, expected1)\n        tm.assert_numpy_array_equal(index_a == array_c, expected2)\n\n        # test comparisons with Series\n        series_a = Series(array_a)\n        series_b = Series(array_b)\n        series_c = Series(array_c)\n        series_d = Series(array_d)\n        with pytest.raises(ValueError, match=msg):\n            index_a == series_b\n\n        tm.assert_numpy_array_equal(index_a == series_a, expected1)\n        tm.assert_numpy_array_equal(index_a == series_c, expected2)\n\n        # cases where length is 1 for one of them\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == index_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == series_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == array_d\n        msg = \"Can only compare identically-labeled Series objects\"\n        with pytest.raises(ValueError, match=msg):\n            series_a == series_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            series_a == array_d\n\n        # comparing with a scalar should broadcast; note that we are excluding\n        # MultiIndex because in this case each item in the index is a tuple of\n        # length 2, and therefore is considered an array of length 2 in the\n        # comparison instead of a scalar\n        if not isinstance(index_a, MultiIndex):\n            expected3 = np.array([False] * (len(index_a) - 2) + [True, False])\n            # assuming the 2nd to last item is unique in the data\n            item = index_a[-2]\n            tm.assert_numpy_array_equal(index_a == item, expected3)\n            tm.assert_series_equal(series_a == item, Series(expected3))",
        "begin_line": 574,
        "end_line": 636,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_hasnans_isnans#638",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_hasnans_isnans(self, indices)",
        "snippet": "    def test_hasnans_isnans(self, indices):\n        # GH 11343, added tests for hasnans / isnans\n        if isinstance(indices, MultiIndex):\n            return\n\n        # cases in indices doesn't include NaN\n        idx = indices.copy(deep=True)\n        expected = np.array([False] * len(idx), dtype=bool)\n        tm.assert_numpy_array_equal(idx._isnan, expected)\n        assert idx.hasnans is False\n\n        idx = indices.copy(deep=True)\n        values = np.asarray(idx.values)\n\n        if len(indices) == 0:\n            return\n        elif isinstance(indices, DatetimeIndexOpsMixin):\n            values[1] = iNaT\n        elif isinstance(indices, (Int64Index, UInt64Index)):\n            return\n        else:\n            values[1] = np.nan\n\n        if isinstance(indices, PeriodIndex):\n            idx = type(indices)(values, freq=indices.freq)\n        else:\n            idx = type(indices)(values)\n\n            expected = np.array([False] * len(idx), dtype=bool)\n            expected[1] = True\n            tm.assert_numpy_array_equal(idx._isnan, expected)\n            assert idx.hasnans is True",
        "begin_line": 638,
        "end_line": 669,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_fillna#671",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_fillna(self, indices)",
        "snippet": "    def test_fillna(self, indices):\n        # GH 11343\n        if len(indices) == 0:\n            pass\n        elif isinstance(indices, MultiIndex):\n            idx = indices.copy(deep=True)\n            msg = \"isna is not defined for MultiIndex\"\n            with pytest.raises(NotImplementedError, match=msg):\n                idx.fillna(idx[0])\n        else:\n            idx = indices.copy(deep=True)\n            result = idx.fillna(idx[0])\n            tm.assert_index_equal(result, idx)\n            assert result is not idx\n\n            msg = \"'value' must be a scalar, passed: \"\n            with pytest.raises(TypeError, match=msg):\n                idx.fillna([idx[0]])\n\n            idx = indices.copy(deep=True)\n            values = np.asarray(idx.values)\n\n            if isinstance(indices, DatetimeIndexOpsMixin):\n                values[1] = iNaT\n            elif isinstance(indices, (Int64Index, UInt64Index)):\n                return\n            else:\n                values[1] = np.nan\n\n            if isinstance(indices, PeriodIndex):\n                idx = type(indices)(values, freq=indices.freq)\n            else:\n                idx = type(indices)(values)\n\n            expected = np.array([False] * len(idx), dtype=bool)\n            expected[1] = True\n            tm.assert_numpy_array_equal(idx._isnan, expected)\n            assert idx.hasnans is True",
        "begin_line": 671,
        "end_line": 708,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_nulls#710",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_nulls(self, indices)",
        "snippet": "    def test_nulls(self, indices):\n        # this is really a smoke test for the methods\n        # as these are adequately tested for function elsewhere\n        if len(indices) == 0:\n            tm.assert_numpy_array_equal(indices.isna(), np.array([], dtype=bool))\n        elif isinstance(indices, MultiIndex):\n            idx = indices.copy()\n            msg = \"isna is not defined for MultiIndex\"\n            with pytest.raises(NotImplementedError, match=msg):\n                idx.isna()\n        elif not indices.hasnans:\n            tm.assert_numpy_array_equal(\n                indices.isna(), np.zeros(len(indices), dtype=bool)\n            )\n            tm.assert_numpy_array_equal(\n                indices.notna(), np.ones(len(indices), dtype=bool)\n            )\n        else:\n            result = isna(indices)\n            tm.assert_numpy_array_equal(indices.isna(), result)\n            tm.assert_numpy_array_equal(indices.notna(), ~result)",
        "begin_line": 710,
        "end_line": 730,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_empty#732",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_empty(self)",
        "snippet": "    def test_empty(self):\n        # GH 15270\n        index = self.create_index()\n        assert not index.empty\n        assert index[:0].empty",
        "begin_line": 732,
        "end_line": 736,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_join_self_unique#738",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_join_self_unique(self, join_type)",
        "snippet": "    def test_join_self_unique(self, join_type):\n        index = self.create_index()\n        if index.is_unique:\n            joined = index.join(index, how=join_type)\n            assert (index == joined).all()",
        "begin_line": 738,
        "end_line": 742,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_map#744",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_map(self)",
        "snippet": "    def test_map(self):\n        # callable\n        index = self.create_index()\n\n        # we don't infer UInt64\n        if isinstance(index, pd.UInt64Index):\n            expected = index.astype(\"int64\")\n        else:\n            expected = index\n\n        result = index.map(lambda x: x)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 744,
        "end_line": 755,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_map_dictlike#764",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_map_dictlike(self, mapper)",
        "snippet": "    def test_map_dictlike(self, mapper):\n\n        index = self.create_index()\n        if isinstance(index, (pd.CategoricalIndex, pd.IntervalIndex)):\n            pytest.skip(f\"skipping tests for {type(index)}\")\n\n        identity = mapper(index.values, index)\n\n        # we don't infer to UInt64 for a dict\n        if isinstance(index, pd.UInt64Index) and isinstance(identity, dict):\n            expected = index.astype(\"int64\")\n        else:\n            expected = index\n\n        result = index.map(identity)\n        tm.assert_index_equal(result, expected)\n\n        # empty mappable\n        expected = pd.Index([np.nan] * len(index))\n        result = index.map(mapper(expected, index))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 764,
        "end_line": 784,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_map_str#786",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_map_str(self)",
        "snippet": "    def test_map_str(self):\n        # GH 31202\n        index = self.create_index()\n        result = index.map(str)\n        expected = Index([str(x) for x in index], dtype=object)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 786,
        "end_line": 791,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_putmask_with_wrong_mask#793",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_putmask_with_wrong_mask(self)",
        "snippet": "    def test_putmask_with_wrong_mask(self):\n        # GH18368\n        index = self.create_index()\n\n        msg = \"putmask: mask and data must be the same size\"\n        with pytest.raises(ValueError, match=msg):\n            index.putmask(np.ones(len(index) + 1, np.bool), 1)\n\n        with pytest.raises(ValueError, match=msg):\n            index.putmask(np.ones(len(index) - 1, np.bool), 1)\n\n        with pytest.raises(ValueError, match=msg):\n            index.putmask(\"foo\", 1)",
        "begin_line": 793,
        "end_line": 805,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_astype_category#810",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_astype_category(self, copy, name, ordered)",
        "snippet": "    def test_astype_category(self, copy, name, ordered):\n        # GH 18630\n        index = self.create_index()\n        if name:\n            index = index.rename(name)\n\n        # standard categories\n        dtype = CategoricalDtype(ordered=ordered)\n        result = index.astype(dtype, copy=copy)\n        expected = CategoricalIndex(index.values, name=name, ordered=ordered)\n        tm.assert_index_equal(result, expected)\n\n        # non-standard categories\n        dtype = CategoricalDtype(index.unique().tolist()[:-1], ordered)\n        result = index.astype(dtype, copy=copy)\n        expected = CategoricalIndex(index.values, name=name, dtype=dtype)\n        tm.assert_index_equal(result, expected)\n\n        if ordered is False:\n            # dtype='category' defaults to ordered=False, so only test once\n            result = index.astype(\"category\", copy=copy)\n            expected = CategoricalIndex(index.values, name=name)\n            tm.assert_index_equal(result, expected)",
        "begin_line": 810,
        "end_line": 832,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_is_unique#834",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_is_unique(self)",
        "snippet": "    def test_is_unique(self):\n        # initialize a unique index\n        index = self.create_index().drop_duplicates()\n        assert index.is_unique is True\n\n        # empty index should be unique\n        index_empty = index[:0]\n        assert index_empty.is_unique is True\n\n        # test basic dupes\n        index_dup = index.insert(0, index[0])\n        assert index_dup.is_unique is False\n\n        # single NA should be unique\n        index_na = index.insert(0, np.nan)\n        assert index_na.is_unique is True\n\n        # multiple NA should not be unique\n        index_na_dup = index_na.insert(0, np.nan)\n        assert index_na_dup.is_unique is False",
        "begin_line": 834,
        "end_line": 853,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_engine_reference_cycle#855",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_engine_reference_cycle(self)",
        "snippet": "    def test_engine_reference_cycle(self):\n        # GH27585\n        index = self.create_index()\n        nrefs_pre = len(gc.get_referrers(index))\n        index._engine\n        assert len(gc.get_referrers(index)) == nrefs_pre",
        "begin_line": 855,
        "end_line": 860,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_getitem_2d_deprecated#862",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_getitem_2d_deprecated(self)",
        "snippet": "    def test_getitem_2d_deprecated(self):\n        # GH#30588\n        idx = self.create_index()\n        with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n            res = idx[:, None]\n\n        assert isinstance(res, np.ndarray), type(res)",
        "begin_line": 862,
        "end_line": 868,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_contains_requires_hashable_raises#870",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_contains_requires_hashable_raises(self)",
        "snippet": "    def test_contains_requires_hashable_raises(self):\n        idx = self.create_index()\n\n        msg = \"unhashable type: 'list'\"\n        with pytest.raises(TypeError, match=msg):\n            [] in idx\n\n        msg = \"|\".join(\n            [\n                r\"unhashable type: 'dict'\",\n                r\"must be real number, not dict\",\n                r\"an integer is required\",\n                r\"\\{\\}\",\n                r\"pandas\\._libs\\.interval\\.IntervalTree' is not iterable\",\n            ]\n        )\n        with pytest.raises(TypeError, match=msg):\n            {} in idx._engine",
        "begin_line": 870,
        "end_line": 887,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_copy_copies_cache#889",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_copy_copies_cache(self)",
        "snippet": "    def test_copy_copies_cache(self):\n        # GH32898\n        idx = self.create_index()\n        idx.get_loc(idx[0])  # populates the _cache.\n        copy = idx.copy()\n\n        # check that the copied cache is a copy of the original\n        assert idx._cache == copy._cache\n        assert idx._cache is not copy._cache\n        # cache values should reference the same object\n        for key, val in idx._cache.items():\n            assert copy._cache[key] is val, key",
        "begin_line": 889,
        "end_line": 900,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_shallow_copy_copies_cache#902",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_shallow_copy_copies_cache(self)",
        "snippet": "    def test_shallow_copy_copies_cache(self):\n        # GH32669\n        idx = self.create_index()\n        idx.get_loc(idx[0])  # populates the _cache.\n        shallow_copy = idx._shallow_copy()\n\n        # check that the shallow_copied cache is a copy of the original\n        assert idx._cache == shallow_copy._cache\n        assert idx._cache is not shallow_copy._cache\n        # cache values should reference the same object\n        for key, val in idx._cache.items():\n            assert shallow_copy._cache[key] is val, key",
        "begin_line": 902,
        "end_line": 913,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.idx#9",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.idx()",
        "snippet": "def idx():\n    # a MultiIndex used to test the general functionality of the\n    # general functionality of this object\n    major_axis = Index([\"foo\", \"bar\", \"baz\", \"qux\"])\n    minor_axis = Index([\"one\", \"two\"])\n\n    major_codes = np.array([0, 0, 1, 2, 3, 3])\n    minor_codes = np.array([0, 1, 0, 1, 0, 1])\n    index_names = [\"first\", \"second\"]\n    mi = MultiIndex(\n        levels=[major_axis, minor_axis],\n        codes=[major_codes, minor_codes],\n        names=index_names,\n        verify_integrity=False,\n    )\n    return mi",
        "begin_line": 9,
        "end_line": 24,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.idx_dup#28",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.idx_dup()",
        "snippet": "def idx_dup():\n    # compare tests/indexes/multi/conftest.py\n    major_axis = Index([\"foo\", \"bar\", \"baz\", \"qux\"])\n    minor_axis = Index([\"one\", \"two\"])\n\n    major_codes = np.array([0, 0, 1, 0, 1, 1])\n    minor_codes = np.array([0, 1, 0, 1, 0, 1])\n    index_names = [\"first\", \"second\"]\n    mi = MultiIndex(\n        levels=[major_axis, minor_axis],\n        codes=[major_codes, minor_codes],\n        names=index_names,\n        verify_integrity=False,\n    )\n    return mi",
        "begin_line": 28,
        "end_line": 42,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.index_names#46",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.index_names()",
        "snippet": "def index_names():\n    # names that match those in the idx fixture for testing equality of\n    # names assigned to the idx\n    return [\"first\", \"second\"]",
        "begin_line": 46,
        "end_line": 49,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.compat_props#53",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.compat_props()",
        "snippet": "def compat_props():\n    # a MultiIndex must have these properties associated with it\n    return [\"shape\", \"ndim\", \"size\"]",
        "begin_line": 53,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.narrow_multi_index#59",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.narrow_multi_index()",
        "snippet": "def narrow_multi_index():\n    \"\"\"\n    Return a MultiIndex that is narrower than the display (<80 characters).\n    \"\"\"\n    n = 1000\n    ci = pd.CategoricalIndex(list(\"a\" * n) + ([\"abc\"] * n))\n    dti = pd.date_range(\"2000-01-01\", freq=\"s\", periods=n * 2)\n    return pd.MultiIndex.from_arrays([ci, ci.codes + 9, dti], names=[\"a\", \"b\", \"dti\"])",
        "begin_line": 59,
        "end_line": 66,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.wide_multi_index#70",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.wide_multi_index()",
        "snippet": "def wide_multi_index():\n    \"\"\"\n    Return a MultiIndex that is wider than the display (>80 characters).\n    \"\"\"\n    n = 1000\n    ci = pd.CategoricalIndex(list(\"a\" * n) + ([\"abc\"] * n))\n    dti = pd.date_range(\"2000-01-01\", freq=\"s\", periods=n * 2)\n    levels = [ci, ci.codes + 9, dti, dti, dti]\n    names = [\"a\", \"b\", \"dti_1\", \"dti_2\", \"dti_3\"]\n    return pd.MultiIndex.from_arrays(levels, names=names)",
        "begin_line": 70,
        "end_line": 79,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_argmax_axis_invalid#12",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_argmax_axis_invalid(self)",
        "snippet": "    def test_argmax_axis_invalid(self):\n        # GH#23081\n        msg = r\"`axis` must be fewer than the number of dimensions \\(1\\)\"\n        rng = self.create_index()\n        with pytest.raises(ValueError, match=msg):\n            rng.argmax(axis=1)\n        with pytest.raises(ValueError, match=msg):\n            rng.argmin(axis=2)\n        with pytest.raises(ValueError, match=msg):\n            rng.min(axis=-2)\n        with pytest.raises(ValueError, match=msg):\n            rng.max(axis=-3)",
        "begin_line": 12,
        "end_line": 23,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_can_hold_identifiers#25",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_can_hold_identifiers(self)",
        "snippet": "    def test_can_hold_identifiers(self):\n        idx = self.create_index()\n        key = idx[0]\n        assert idx._can_hold_identifiers_and_holds_name(key) is False",
        "begin_line": 25,
        "end_line": 28,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_shift_identity#30",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_shift_identity(self)",
        "snippet": "    def test_shift_identity(self):\n\n        idx = self.create_index()\n        tm.assert_index_equal(idx, idx.shift(0))",
        "begin_line": 30,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_str#35",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_str(self)",
        "snippet": "    def test_str(self):\n\n        # test the string repr\n        idx = self.create_index()\n        idx.name = \"foo\"\n        assert not (f\"length={len(idx)}\" in str(idx))\n        assert \"'foo'\" in str(idx)\n        assert type(idx).__name__ in str(idx)\n\n        if hasattr(idx, \"tz\"):\n            if idx.tz is not None:\n                assert idx.tz in str(idx)\n        if hasattr(idx, \"freq\"):\n            assert f\"freq='{idx.freqstr}'\" in str(idx)",
        "begin_line": 35,
        "end_line": 48,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_view#50",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_view(self)",
        "snippet": "    def test_view(self):\n        i = self.create_index()\n\n        i_view = i.view(\"i8\")\n        result = self._holder(i)\n        tm.assert_index_equal(result, i)\n\n        i_view = i.view(self._holder)\n        result = self._holder(i)\n        tm.assert_index_equal(result, i_view)",
        "begin_line": 50,
        "end_line": 59,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_callable#61",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_callable(self)",
        "snippet": "    def test_map_callable(self):\n        index = self.create_index()\n        expected = index + index.freq\n        result = index.map(lambda x: x + x.freq)\n        tm.assert_index_equal(result, expected)\n\n        # map to NaT\n        result = index.map(lambda x: pd.NaT if x == index[0] else x)\n        expected = pd.Index([pd.NaT] + index[1:].tolist())\n        tm.assert_index_equal(result, expected)",
        "begin_line": 61,
        "end_line": 70,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_dictlike#79",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_dictlike(self, mapper)",
        "snippet": "    def test_map_dictlike(self, mapper):\n        index = self.create_index()\n        expected = index + index.freq\n\n        # don't compare the freqs\n        if isinstance(expected, (pd.DatetimeIndex, pd.TimedeltaIndex)):\n            expected = expected._with_freq(None)\n\n        result = index.map(mapper(expected, index))\n        tm.assert_index_equal(result, expected)\n\n        expected = pd.Index([pd.NaT] + index[1:].tolist())\n        result = index.map(mapper(expected, index))\n        tm.assert_index_equal(result, expected)\n\n        # empty map; these map to np.nan because we cannot know\n        # to re-infer things\n        expected = pd.Index([np.nan] * len(index))\n        result = index.map(mapper([], []))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 79,
        "end_line": 98,
        "comment": "",
        "is_bug": false
    }
]