[
    {
        "name": "pandas.tests.test_strings.assert_series_or_index_equal#15",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings",
        "signature": "pandas.tests.test_strings.assert_series_or_index_equal(left, right)",
        "snippet": "def assert_series_or_index_equal(left, right):\n    if isinstance(left, Series):\n        tm.assert_series_equal(left, right)\n    else:  # Index\n        tm.assert_index_equal(left, right)",
        "begin_line": 15,
        "end_line": 19,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.any_string_method#110",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings",
        "signature": "pandas.tests.test_strings.any_string_method(request)",
        "snippet": "def any_string_method(request):\n    \"\"\"\n    Fixture for all public methods of `StringMethods`\n\n    This fixture returns a tuple of the method name and sample arguments\n    necessary to call the method.\n\n    Returns\n    -------\n    method_name : str\n        The name of the method in `StringMethods`\n    args : tuple\n        Sample values for the positional arguments\n    kwargs : dict\n        Sample values for the keyword arguments\n\n    Examples\n    --------\n    >>> def test_something(any_string_method):\n    ...     s = pd.Series(['a', 'b', np.nan, 'd'])\n    ...\n    ...     method_name, args, kwargs = any_string_method\n    ...     method = getattr(s.str, method_name)\n    ...     # will not raise\n    ...     method(*args, **kwargs)\n    \"\"\"\n    return request.param",
        "begin_line": 110,
        "end_line": 136,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.any_allowed_skipna_inferred_dtype#151",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings",
        "signature": "pandas.tests.test_strings.any_allowed_skipna_inferred_dtype(request)",
        "snippet": "def any_allowed_skipna_inferred_dtype(request):\n    \"\"\"\n    Fixture for all (inferred) dtypes allowed in StringMethods.__init__\n\n    The covered (inferred) types are:\n    * 'string'\n    * 'empty'\n    * 'bytes'\n    * 'mixed'\n    * 'mixed-integer'\n\n    Returns\n    -------\n    inferred_dtype : str\n        The string for the inferred dtype from _libs.lib.infer_dtype\n    values : np.ndarray\n        An array of object dtype that will be inferred to have\n        `inferred_dtype`\n\n    Examples\n    --------\n    >>> import pandas._libs.lib as lib\n    >>>\n    >>> def test_something(any_allowed_skipna_inferred_dtype):\n    ...     inferred_dtype, values = any_allowed_skipna_inferred_dtype\n    ...     # will pass\n    ...     assert lib.infer_dtype(values, skipna=True) == inferred_dtype\n    ...\n    ...     # constructor for .str-accessor will also pass\n    ...     pd.Series(values).str\n    \"\"\"\n    inferred_dtype, values = request.param\n    values = np.array(values, dtype=object)  # object dtype to avoid casting\n\n    # correctness of inference tested in tests/dtypes/test_inference.py\n    return inferred_dtype, values",
        "begin_line": 151,
        "end_line": 186,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_api#190",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_api(self)",
        "snippet": "    def test_api(self):\n\n        # GH 6106, GH 9322\n        assert Series.str is strings.StringMethods\n        assert isinstance(Series([\"\"]).str, strings.StringMethods)",
        "begin_line": 190,
        "end_line": 194,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_api_mi_raises#196",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_api_mi_raises(self)",
        "snippet": "    def test_api_mi_raises(self):\n        # GH 23679\n        mi = MultiIndex.from_arrays([[\"a\", \"b\", \"c\"]])\n        msg = \"Can only use .str accessor with Index, not MultiIndex\"\n        with pytest.raises(AttributeError, match=msg):\n            mi.str\n        assert not hasattr(mi, \"str\")",
        "begin_line": 196,
        "end_line": 202,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_api_per_dtype#206",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_api_per_dtype(self, box, dtype, any_skipna_inferred_dtype)",
        "snippet": "    def test_api_per_dtype(self, box, dtype, any_skipna_inferred_dtype):\n        # one instance of parametrized fixture\n        inferred_dtype, values = any_skipna_inferred_dtype\n\n        t = box(values, dtype=dtype)  # explicit dtype to avoid casting\n\n        # TODO: get rid of these xfails\n        if dtype == \"category\" and inferred_dtype in [\"period\", \"interval\"]:\n            pytest.xfail(\n                reason=\"Conversion to numpy array fails because \"\n                \"the ._values-attribute is not a numpy array for \"\n                \"PeriodArray/IntervalArray; see GH 23553\"\n            )\n\n        types_passing_constructor = [\n            \"string\",\n            \"unicode\",\n            \"empty\",\n            \"bytes\",\n            \"mixed\",\n            \"mixed-integer\",\n        ]\n        if inferred_dtype in types_passing_constructor:\n            # GH 6106\n            assert isinstance(t.str, strings.StringMethods)\n        else:\n            # GH 9184, GH 23011, GH 23163\n            msg = \"Can only use .str accessor with string values.*\"\n            with pytest.raises(AttributeError, match=msg):\n                t.str\n            assert not hasattr(t, \"str\")",
        "begin_line": 206,
        "end_line": 236,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_api_per_method#240",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_api_per_method(self, box, dtype, any_allowed_skipna_inferred_dtype, any_string_method)",
        "snippet": "    def test_api_per_method(\n        self, box, dtype, any_allowed_skipna_inferred_dtype, any_string_method\n    ):\n        # this test does not check correctness of the different methods,\n        # just that the methods work on the specified (inferred) dtypes,\n        # and raise on all others\n\n        # one instance of each parametrized fixture\n        inferred_dtype, values = any_allowed_skipna_inferred_dtype\n        method_name, args, kwargs = any_string_method\n\n        # TODO: get rid of these xfails\n        if (\n            method_name in [\"partition\", \"rpartition\"]\n            and box == Index\n            and inferred_dtype == \"empty\"\n        ):\n            pytest.xfail(reason=\"Method cannot deal with empty Index\")\n        if (\n            method_name == \"split\"\n            and box == Index\n            and values.size == 0\n            and kwargs.get(\"expand\", None) is not None\n        ):\n            pytest.xfail(reason=\"Split fails on empty Series when expand=True\")\n        if (\n            method_name == \"get_dummies\"\n            and box == Index\n            and inferred_dtype == \"empty\"\n            and (dtype == object or values.size == 0)\n        ):\n            pytest.xfail(reason=\"Need to fortify get_dummies corner cases\")\n\n        t = box(values, dtype=dtype)  # explicit dtype to avoid casting\n        method = getattr(t.str, method_name)\n\n        bytes_allowed = method_name in [\"decode\", \"get\", \"len\", \"slice\"]\n        # as of v0.23.4, all methods except 'cat' are very lenient with the\n        # allowed data types, just returning NaN for entries that error.\n        # This could be changed with an 'errors'-kwarg to the `str`-accessor,\n        # see discussion in GH 13877\n        mixed_allowed = method_name not in [\"cat\"]\n\n        allowed_types = (\n            [\"string\", \"unicode\", \"empty\"]\n            + [\"bytes\"] * bytes_allowed\n            + [\"mixed\", \"mixed-integer\"] * mixed_allowed\n        )\n\n        if inferred_dtype in allowed_types:\n            # xref GH 23555, GH 23556\n            method(*args, **kwargs)  # works!\n        else:\n            # GH 23011, GH 23163\n            msg = (\n                \"Cannot use .str.{name} with values of inferred dtype \"\n                \"{inferred_dtype!r}.\".format(\n                    name=method_name, inferred_dtype=inferred_dtype\n                )\n            )\n            with pytest.raises(TypeError, match=msg):\n                method(*args, **kwargs)",
        "begin_line": 240,
        "end_line": 301,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_api_for_categorical#303",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_api_for_categorical(self, any_string_method)",
        "snippet": "    def test_api_for_categorical(self, any_string_method):\n        # https://github.com/pandas-dev/pandas/issues/10661\n        s = Series(list(\"aabb\"))\n        s = s + \" \" + s\n        c = s.astype(\"category\")\n        assert isinstance(c.str, strings.StringMethods)\n\n        method_name, args, kwargs = any_string_method\n\n        result = getattr(c.str, method_name)(*args, **kwargs)\n        expected = getattr(s.str, method_name)(*args, **kwargs)\n\n        if isinstance(result, DataFrame):\n            tm.assert_frame_equal(result, expected)\n        elif isinstance(result, Series):\n            tm.assert_series_equal(result, expected)\n        else:\n            # str.cat(others=None) returns string, for example\n            assert result == expected",
        "begin_line": 303,
        "end_line": 321,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_iter#323",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_iter(self)",
        "snippet": "    def test_iter(self):\n        # GH3638\n        strs = \"google\", \"wikimedia\", \"wikipedia\", \"wikitravel\"\n        ds = Series(strs)\n\n        for s in ds.str:\n            # iter must yield a Series\n            assert isinstance(s, Series)\n\n            # indices of each yielded Series should be equal to the index of\n            # the original Series\n            tm.assert_index_equal(s.index, ds.index)\n\n            for el in s:\n                # each element of the series is either a basestring/str or nan\n                assert isinstance(el, str) or isna(el)\n\n        # desired behavior is to iterate until everything would be nan on the\n        # next iter so make sure the last element of the iterator was 'l' in\n        # this case since 'wikitravel' is the longest string\n        assert s.dropna().values.item() == \"l\"",
        "begin_line": 323,
        "end_line": 343,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_iter_empty#345",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_iter_empty(self)",
        "snippet": "    def test_iter_empty(self):\n        ds = Series([], dtype=object)\n\n        i, s = 100, 1\n\n        for i, s in enumerate(ds.str):\n            pass\n\n        # nothing to iterate over so nothing defined values should remain\n        # unchanged\n        assert i == 100\n        assert s == 1",
        "begin_line": 345,
        "end_line": 356,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_iter_single_element#358",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_iter_single_element(self)",
        "snippet": "    def test_iter_single_element(self):\n        ds = Series([\"a\"])\n\n        for i, s in enumerate(ds.str):\n            pass\n\n        assert not i\n        tm.assert_series_equal(ds, s)",
        "begin_line": 358,
        "end_line": 365,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_iter_object_try_string#367",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_iter_object_try_string(self)",
        "snippet": "    def test_iter_object_try_string(self):\n        ds = Series([slice(None, randint(10), randint(10, 20)) for _ in range(4)])\n\n        i, s = 100, \"h\"\n\n        for i, s in enumerate(ds.str):\n            pass\n\n        assert i == 100\n        assert s == \"h\"",
        "begin_line": 367,
        "end_line": 376,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_str_cat_name#380",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_str_cat_name(self, box, other)",
        "snippet": "    def test_str_cat_name(self, box, other):\n        # GH 21053\n        values = [\"a\", \"b\"]\n        if other:\n            other = other(values)\n        else:\n            other = values\n        result = box(values, name=\"name\").str.cat(other, sep=\",\")\n        assert result.name == \"name\"",
        "begin_line": 380,
        "end_line": 388,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_str_cat#391",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_str_cat(self, box)",
        "snippet": "    def test_str_cat(self, box):\n        # test_cat above tests \"str_cat\" from ndarray;\n        # here testing \"str.cat\" from Series/Indext to ndarray/list\n        s = box([\"a\", \"a\", \"b\", \"b\", \"c\", np.nan])\n\n        # single array\n        result = s.str.cat()\n        expected = \"aabbc\"\n        assert result == expected\n\n        result = s.str.cat(na_rep=\"-\")\n        expected = \"aabbc-\"\n        assert result == expected\n\n        result = s.str.cat(sep=\"_\", na_rep=\"NA\")\n        expected = \"a_a_b_b_c_NA\"\n        assert result == expected\n\n        t = np.array([\"a\", np.nan, \"b\", \"d\", \"foo\", np.nan], dtype=object)\n        expected = box([\"aa\", \"a-\", \"bb\", \"bd\", \"cfoo\", \"--\"])\n\n        # Series/Index with array\n        result = s.str.cat(t, na_rep=\"-\")\n        assert_series_or_index_equal(result, expected)\n\n        # Series/Index with list\n        result = s.str.cat(list(t), na_rep=\"-\")\n        assert_series_or_index_equal(result, expected)\n\n        # errors for incorrect lengths\n        rgx = r\"If `others` contains arrays or lists \\(or other list-likes.*\"\n        z = Series([\"1\", \"2\", \"3\"])\n\n        with pytest.raises(ValueError, match=rgx):\n            s.str.cat(z.values)\n\n        with pytest.raises(ValueError, match=rgx):\n            s.str.cat(list(z))",
        "begin_line": 391,
        "end_line": 428,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_str_cat_raises_intuitive_error#431",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_str_cat_raises_intuitive_error(self, box)",
        "snippet": "    def test_str_cat_raises_intuitive_error(self, box):\n        # GH 11334\n        s = box([\"a\", \"b\", \"c\", \"d\"])\n        message = \"Did you mean to supply a `sep` keyword?\"\n        with pytest.raises(ValueError, match=message):\n            s.str.cat(\"|\")\n        with pytest.raises(ValueError, match=message):\n            s.str.cat(\"    \")",
        "begin_line": 431,
        "end_line": 438,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_str_cat_categorical#444",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_str_cat_categorical(self, box, dtype_caller, dtype_target, sep)",
        "snippet": "    def test_str_cat_categorical(self, box, dtype_caller, dtype_target, sep):\n        s = Index([\"a\", \"a\", \"b\", \"a\"], dtype=dtype_caller)\n        s = s if box == Index else Series(s, index=s)\n        t = Index([\"b\", \"a\", \"b\", \"c\"], dtype=dtype_target)\n\n        expected = Index([\"ab\", \"aa\", \"bb\", \"ac\"])\n        expected = expected if box == Index else Series(expected, index=s)\n\n        # Series/Index with unaligned Index -> t.values\n        result = s.str.cat(t.values, sep=sep)\n        assert_series_or_index_equal(result, expected)\n\n        # Series/Index with Series having matching Index\n        t = Series(t.values, index=s)\n        result = s.str.cat(t, sep=sep)\n        assert_series_or_index_equal(result, expected)\n\n        # Series/Index with Series.values\n        result = s.str.cat(t.values, sep=sep)\n        assert_series_or_index_equal(result, expected)\n\n        # Series/Index with Series having different Index\n        t = Series(t.values, index=t.values)\n        expected = Index([\"aa\", \"aa\", \"aa\", \"bb\", \"bb\"])\n        expected = (\n            expected if box == Index else Series(expected, index=expected.str[:1])\n        )\n\n        result = s.str.cat(t, sep=sep)\n        assert_series_or_index_equal(result, expected)",
        "begin_line": 444,
        "end_line": 473,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_str_cat_wrong_dtype_raises#487",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_str_cat_wrong_dtype_raises(self, box, data)",
        "snippet": "    def test_str_cat_wrong_dtype_raises(self, box, data):\n        # GH 22722\n        s = Series([\"a\", \"b\", \"c\"])\n        t = box(data)\n\n        msg = \"Concatenation requires list-likes containing only strings.*\"\n        with pytest.raises(TypeError, match=msg):\n            # need to use outer and na_rep, as otherwise Index would not raise\n            s.str.cat(t, join=\"outer\", na_rep=\"-\")",
        "begin_line": 487,
        "end_line": 495,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_str_cat_mixed_inputs#498",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_str_cat_mixed_inputs(self, box)",
        "snippet": "    def test_str_cat_mixed_inputs(self, box):\n        s = Index([\"a\", \"b\", \"c\", \"d\"])\n        s = s if box == Index else Series(s, index=s)\n\n        t = Series([\"A\", \"B\", \"C\", \"D\"], index=s.values)\n        d = concat([t, Series(s, index=s)], axis=1)\n\n        expected = Index([\"aAa\", \"bBb\", \"cCc\", \"dDd\"])\n        expected = expected if box == Index else Series(expected.values, index=s.values)\n\n        # Series/Index with DataFrame\n        result = s.str.cat(d)\n        assert_series_or_index_equal(result, expected)\n\n        # Series/Index with two-dimensional ndarray\n        result = s.str.cat(d.values)\n        assert_series_or_index_equal(result, expected)\n\n        # Series/Index with list of Series\n        result = s.str.cat([t, s])\n        assert_series_or_index_equal(result, expected)\n\n        # Series/Index with mixed list of Series/array\n        result = s.str.cat([t, s.values])\n        assert_series_or_index_equal(result, expected)\n\n        # Series/Index with list of Series; different indexes\n        t.index = [\"b\", \"c\", \"d\", \"a\"]\n        expected = box([\"aDa\", \"bAb\", \"cBc\", \"dCd\"])\n        expected = expected if box == Index else Series(expected.values, index=s.values)\n        result = s.str.cat([t, s])\n        assert_series_or_index_equal(result, expected)\n\n        # Series/Index with mixed list; different index\n        result = s.str.cat([t, s.values])\n        assert_series_or_index_equal(result, expected)\n\n        # Series/Index with DataFrame; different indexes\n        d.index = [\"b\", \"c\", \"d\", \"a\"]\n        expected = box([\"aDd\", \"bAa\", \"cBb\", \"dCc\"])\n        expected = expected if box == Index else Series(expected.values, index=s.values)\n        result = s.str.cat(d)\n        assert_series_or_index_equal(result, expected)\n\n        # errors for incorrect lengths\n        rgx = r\"If `others` contains arrays or lists \\(or other list-likes.*\"\n        z = Series([\"1\", \"2\", \"3\"])\n        e = concat([z, z], axis=1)\n\n        # two-dimensional ndarray\n        with pytest.raises(ValueError, match=rgx):\n            s.str.cat(e.values)\n\n        # list of list-likes\n        with pytest.raises(ValueError, match=rgx):\n            s.str.cat([z.values, s.values])\n\n        # mixed list of Series/list-like\n        with pytest.raises(ValueError, match=rgx):\n            s.str.cat([z.values, s])\n\n        # errors for incorrect arguments in list-like\n        rgx = \"others must be Series, Index, DataFrame,.*\"\n        # make sure None/NaN do not crash checks in _get_series_list\n        u = Series([\"a\", np.nan, \"c\", None])\n\n        # mix of string and Series\n        with pytest.raises(TypeError, match=rgx):\n            s.str.cat([u, \"u\"])\n\n        # DataFrame in list\n        with pytest.raises(TypeError, match=rgx):\n            s.str.cat([u, d])\n\n        # 2-dim ndarray in list\n        with pytest.raises(TypeError, match=rgx):\n            s.str.cat([u, d.values])\n\n        # nested lists\n        with pytest.raises(TypeError, match=rgx):\n            s.str.cat([u, [u, d]])\n\n        # forbidden input type: set\n        # GH 23009\n        with pytest.raises(TypeError, match=rgx):\n            s.str.cat(set(u))\n\n        # forbidden input type: set in list\n        # GH 23009\n        with pytest.raises(TypeError, match=rgx):\n            s.str.cat([u, set(u)])\n\n        # other forbidden input type, e.g. int\n        with pytest.raises(TypeError, match=rgx):\n            s.str.cat(1)\n\n        # nested list-likes\n        with pytest.raises(TypeError, match=rgx):\n            s.str.cat(iter([t.values, list(s)]))",
        "begin_line": 498,
        "end_line": 596,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_str_cat_align_indexed#600",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_str_cat_align_indexed(self, box, join)",
        "snippet": "    def test_str_cat_align_indexed(self, box, join):\n        # https://github.com/pandas-dev/pandas/issues/18657\n        s = Series([\"a\", \"b\", \"c\", \"d\"], index=[\"a\", \"b\", \"c\", \"d\"])\n        t = Series([\"D\", \"A\", \"E\", \"B\"], index=[\"d\", \"a\", \"e\", \"b\"])\n        sa, ta = s.align(t, join=join)\n        # result after manual alignment of inputs\n        expected = sa.str.cat(ta, na_rep=\"-\")\n\n        if box == Index:\n            s = Index(s)\n            sa = Index(sa)\n            expected = Index(expected)\n\n        result = s.str.cat(t, join=join, na_rep=\"-\")\n        assert_series_or_index_equal(result, expected)",
        "begin_line": 600,
        "end_line": 614,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_str_cat_align_mixed_inputs#617",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_str_cat_align_mixed_inputs(self, join)",
        "snippet": "    def test_str_cat_align_mixed_inputs(self, join):\n        s = Series([\"a\", \"b\", \"c\", \"d\"])\n        t = Series([\"d\", \"a\", \"e\", \"b\"], index=[3, 0, 4, 1])\n        d = concat([t, t], axis=1)\n\n        expected_outer = Series([\"aaa\", \"bbb\", \"c--\", \"ddd\", \"-ee\"])\n        expected = expected_outer.loc[s.index.join(t.index, how=join)]\n\n        # list of Series\n        result = s.str.cat([t, t], join=join, na_rep=\"-\")\n        tm.assert_series_equal(result, expected)\n\n        # DataFrame\n        result = s.str.cat(d, join=join, na_rep=\"-\")\n        tm.assert_series_equal(result, expected)\n\n        # mixed list of indexed/unindexed\n        u = np.array([\"A\", \"B\", \"C\", \"D\"])\n        expected_outer = Series([\"aaA\", \"bbB\", \"c-C\", \"ddD\", \"-e-\"])\n        # joint index of rhs [t, u]; u will be forced have index of s\n        rhs_idx = t.index & s.index if join == \"inner\" else t.index | s.index\n\n        expected = expected_outer.loc[s.index.join(rhs_idx, how=join)]\n        result = s.str.cat([t, u], join=join, na_rep=\"-\")\n        tm.assert_series_equal(result, expected)\n\n        with pytest.raises(TypeError, match=\"others must be Series,.*\"):\n            # nested lists are forbidden\n            s.str.cat([t, list(u)], join=join)\n\n        # errors for incorrect lengths\n        rgx = r\"If `others` contains arrays or lists \\(or other list-likes.*\"\n        z = Series([\"1\", \"2\", \"3\"]).values\n\n        # unindexed object of wrong length\n        with pytest.raises(ValueError, match=rgx):\n            s.str.cat(z, join=join)\n\n        # unindexed object of wrong length in list\n        with pytest.raises(ValueError, match=rgx):\n            s.str.cat([t, z], join=join)",
        "begin_line": 617,
        "end_line": 657,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_str_cat_all_na#661",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_str_cat_all_na(self, box, other)",
        "snippet": "    def test_str_cat_all_na(self, box, other):\n        # GH 24044\n\n        # check that all NaNs in caller / target work\n        s = Index([\"a\", \"b\", \"c\", \"d\"])\n        s = s if box == Index else Series(s, index=s)\n        t = other([np.nan] * 4, dtype=object)\n        # add index of s for alignment\n        t = t if other == Index else Series(t, index=s)\n\n        # all-NA target\n        if box == Series:\n            expected = Series([np.nan] * 4, index=s.index, dtype=object)\n        else:  # box == Index\n            expected = Index([np.nan] * 4, dtype=object)\n        result = s.str.cat(t, join=\"left\")\n        assert_series_or_index_equal(result, expected)\n\n        # all-NA caller (only for Series)\n        if other == Series:\n            expected = Series([np.nan] * 4, dtype=object, index=t.index)\n            result = t.str.cat(s, join=\"left\")\n            tm.assert_series_equal(result, expected)",
        "begin_line": 661,
        "end_line": 683,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_str_cat_special_cases#685",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_str_cat_special_cases(self)",
        "snippet": "    def test_str_cat_special_cases(self):\n        s = Series([\"a\", \"b\", \"c\", \"d\"])\n        t = Series([\"d\", \"a\", \"e\", \"b\"], index=[3, 0, 4, 1])\n\n        # iterator of elements with different types\n        expected = Series([\"aaa\", \"bbb\", \"c-c\", \"ddd\", \"-e-\"])\n        result = s.str.cat(iter([t, s.values]), join=\"outer\", na_rep=\"-\")\n        tm.assert_series_equal(result, expected)\n\n        # right-align with different indexes in others\n        expected = Series([\"aa-\", \"d-d\"], index=[0, 3])\n        result = s.str.cat([t.loc[[0]], t.loc[[3]]], join=\"right\", na_rep=\"-\")\n        tm.assert_series_equal(result, expected)",
        "begin_line": 685,
        "end_line": 697,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_cat_on_filtered_index#699",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_cat_on_filtered_index(self)",
        "snippet": "    def test_cat_on_filtered_index(self):\n        df = DataFrame(\n            index=MultiIndex.from_product(\n                [[2011, 2012], [1, 2, 3]], names=[\"year\", \"month\"]\n            )\n        )\n\n        df = df.reset_index()\n        df = df[df.month > 1]\n\n        str_year = df.year.astype(\"str\")\n        str_month = df.month.astype(\"str\")\n        str_both = str_year.str.cat(str_month, sep=\" \")\n\n        assert str_both.loc[1] == \"2011 2\"\n\n        str_multiple = str_year.str.cat([str_month, str_month], sep=\" \")\n\n        assert str_multiple.loc[1] == \"2011 2 2\"",
        "begin_line": 699,
        "end_line": 717,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_count#719",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_count(self)",
        "snippet": "    def test_count(self):\n        values = np.array(\n            [\"foo\", \"foofoo\", np.nan, \"foooofooofommmfoo\"], dtype=np.object_\n        )\n\n        result = strings.str_count(values, \"f[o]+\")\n        exp = np.array([1, 2, np.nan, 4])\n        tm.assert_numpy_array_equal(result, exp)\n\n        result = Series(values).str.count(\"f[o]+\")\n        exp = Series([1, 2, np.nan, 4])\n        assert isinstance(result, Series)\n        tm.assert_series_equal(result, exp)\n\n        # mixed\n        mixed = [\"a\", np.nan, \"b\", True, datetime.today(), \"foo\", None, 1, 2.0]\n        rs = strings.str_count(mixed, \"a\")\n        xp = np.array([1, np.nan, 0, np.nan, np.nan, 0, np.nan, np.nan, np.nan])\n        tm.assert_numpy_array_equal(rs, xp)\n\n        rs = Series(mixed).str.count(\"a\")\n        xp = Series([1, np.nan, 0, np.nan, np.nan, 0, np.nan, np.nan, np.nan])\n        assert isinstance(rs, Series)\n        tm.assert_series_equal(rs, xp)",
        "begin_line": 719,
        "end_line": 742,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_contains#744",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_contains(self)",
        "snippet": "    def test_contains(self):\n        values = np.array(\n            [\"foo\", np.nan, \"fooommm__foo\", \"mmm_\", \"foommm[_]+bar\"], dtype=np.object_\n        )\n        pat = \"mmm[_]+\"\n\n        result = strings.str_contains(values, pat)\n        expected = np.array([False, np.nan, True, True, False], dtype=np.object_)\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = strings.str_contains(values, pat, regex=False)\n        expected = np.array([False, np.nan, False, False, True], dtype=np.object_)\n        tm.assert_numpy_array_equal(result, expected)\n\n        values = [\"foo\", \"xyz\", \"fooommm__foo\", \"mmm_\"]\n        result = strings.str_contains(values, pat)\n        expected = np.array([False, False, True, True])\n        assert result.dtype == np.bool_\n        tm.assert_numpy_array_equal(result, expected)\n\n        # case insensitive using regex\n        values = [\"Foo\", \"xYz\", \"fOOomMm__fOo\", \"MMM_\"]\n        result = strings.str_contains(values, \"FOO|mmm\", case=False)\n        expected = np.array([True, False, True, True])\n        tm.assert_numpy_array_equal(result, expected)\n\n        # case insensitive without regex\n        result = strings.str_contains(values, \"foo\", regex=False, case=False)\n        expected = np.array([True, False, True, False])\n        tm.assert_numpy_array_equal(result, expected)\n\n        # mixed\n        mixed = [\"a\", np.nan, \"b\", True, datetime.today(), \"foo\", None, 1, 2.0]\n        rs = strings.str_contains(mixed, \"o\")\n        xp = np.array(\n            [False, np.nan, False, np.nan, np.nan, True, np.nan, np.nan, np.nan],\n            dtype=np.object_,\n        )\n        tm.assert_numpy_array_equal(rs, xp)\n\n        rs = Series(mixed).str.contains(\"o\")\n        xp = Series(\n            [False, np.nan, False, np.nan, np.nan, True, np.nan, np.nan, np.nan]\n        )\n        assert isinstance(rs, Series)\n        tm.assert_series_equal(rs, xp)\n\n        # unicode\n        values = np.array([\"foo\", np.nan, \"fooommm__foo\", \"mmm_\"], dtype=np.object_)\n        pat = \"mmm[_]+\"\n\n        result = strings.str_contains(values, pat)\n        expected = np.array([False, np.nan, True, True], dtype=np.object_)\n        tm.assert_numpy_array_equal(result, expected)\n\n        result = strings.str_contains(values, pat, na=False)\n        expected = np.array([False, False, True, True])\n        tm.assert_numpy_array_equal(result, expected)\n\n        values = np.array([\"foo\", \"xyz\", \"fooommm__foo\", \"mmm_\"], dtype=np.object_)\n        result = strings.str_contains(values, pat)\n        expected = np.array([False, False, True, True])\n        assert result.dtype == np.bool_\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 744,
        "end_line": 807,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_contains_for_object_category#809",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_contains_for_object_category(self)",
        "snippet": "    def test_contains_for_object_category(self):\n        # gh 22158\n\n        # na for category\n        values = Series([\"a\", \"b\", \"c\", \"a\", np.nan], dtype=\"category\")\n        result = values.str.contains(\"a\", na=True)\n        expected = Series([True, False, False, True, True])\n        tm.assert_series_equal(result, expected)\n\n        result = values.str.contains(\"a\", na=False)\n        expected = Series([True, False, False, True, False])\n        tm.assert_series_equal(result, expected)\n\n        # na for objects\n        values = Series([\"a\", \"b\", \"c\", \"a\", np.nan])\n        result = values.str.contains(\"a\", na=True)\n        expected = Series([True, False, False, True, True])\n        tm.assert_series_equal(result, expected)\n\n        result = values.str.contains(\"a\", na=False)\n        expected = Series([True, False, False, True, False])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 809,
        "end_line": 830,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_startswith#832",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_startswith(self)",
        "snippet": "    def test_startswith(self):\n        values = Series([\"om\", np.nan, \"foo_nom\", \"nom\", \"bar_foo\", np.nan, \"foo\"])\n\n        result = values.str.startswith(\"foo\")\n        exp = Series([False, np.nan, True, False, False, np.nan, True])\n        tm.assert_series_equal(result, exp)\n\n        result = values.str.startswith(\"foo\", na=True)\n        tm.assert_series_equal(result, exp.fillna(True).astype(bool))\n\n        # mixed\n        mixed = np.array(\n            [\"a\", np.nan, \"b\", True, datetime.today(), \"foo\", None, 1, 2.0],\n            dtype=np.object_,\n        )\n        rs = strings.str_startswith(mixed, \"f\")\n        xp = np.array(\n            [False, np.nan, False, np.nan, np.nan, True, np.nan, np.nan, np.nan],\n            dtype=np.object_,\n        )\n        tm.assert_numpy_array_equal(rs, xp)\n\n        rs = Series(mixed).str.startswith(\"f\")\n        assert isinstance(rs, Series)\n        xp = Series(\n            [False, np.nan, False, np.nan, np.nan, True, np.nan, np.nan, np.nan]\n        )\n        tm.assert_series_equal(rs, xp)",
        "begin_line": 832,
        "end_line": 859,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_endswith#861",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_endswith(self)",
        "snippet": "    def test_endswith(self):\n        values = Series([\"om\", np.nan, \"foo_nom\", \"nom\", \"bar_foo\", np.nan, \"foo\"])\n\n        result = values.str.endswith(\"foo\")\n        exp = Series([False, np.nan, False, False, True, np.nan, True])\n        tm.assert_series_equal(result, exp)\n\n        result = values.str.endswith(\"foo\", na=False)\n        tm.assert_series_equal(result, exp.fillna(False).astype(bool))\n\n        # mixed\n        mixed = [\"a\", np.nan, \"b\", True, datetime.today(), \"foo\", None, 1, 2.0]\n        rs = strings.str_endswith(mixed, \"f\")\n        xp = np.array(\n            [False, np.nan, False, np.nan, np.nan, False, np.nan, np.nan, np.nan],\n            dtype=np.object_,\n        )\n        tm.assert_numpy_array_equal(rs, xp)\n\n        rs = Series(mixed).str.endswith(\"f\")\n        xp = Series(\n            [False, np.nan, False, np.nan, np.nan, False, np.nan, np.nan, np.nan]\n        )\n        assert isinstance(rs, Series)\n        tm.assert_series_equal(rs, xp)",
        "begin_line": 861,
        "end_line": 885,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_title#887",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_title(self)",
        "snippet": "    def test_title(self):\n        values = Series([\"FOO\", \"BAR\", np.nan, \"Blah\", \"blurg\"])\n\n        result = values.str.title()\n        exp = Series([\"Foo\", \"Bar\", np.nan, \"Blah\", \"Blurg\"])\n        tm.assert_series_equal(result, exp)\n\n        # mixed\n        mixed = Series(\n            [\"FOO\", np.nan, \"bar\", True, datetime.today(), \"blah\", None, 1, 2.0]\n        )\n        mixed = mixed.str.title()\n        exp = Series(\n            [\"Foo\", np.nan, \"Bar\", np.nan, np.nan, \"Blah\", np.nan, np.nan, np.nan]\n        )\n        tm.assert_almost_equal(mixed, exp)",
        "begin_line": 887,
        "end_line": 902,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_lower_upper#904",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_lower_upper(self)",
        "snippet": "    def test_lower_upper(self):\n        values = Series([\"om\", np.nan, \"nom\", \"nom\"])\n\n        result = values.str.upper()\n        exp = Series([\"OM\", np.nan, \"NOM\", \"NOM\"])\n        tm.assert_series_equal(result, exp)\n\n        result = result.str.lower()\n        tm.assert_series_equal(result, values)\n\n        # mixed\n        mixed = Series([\"a\", np.nan, \"b\", True, datetime.today(), \"foo\", None, 1, 2.0])\n        mixed = mixed.str.upper()\n        rs = Series(mixed).str.lower()\n        xp = Series([\"a\", np.nan, \"b\", np.nan, np.nan, \"foo\", np.nan, np.nan, np.nan])\n        assert isinstance(rs, Series)\n        tm.assert_series_equal(rs, xp)",
        "begin_line": 904,
        "end_line": 920,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_capitalize#922",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_capitalize(self)",
        "snippet": "    def test_capitalize(self):\n        values = Series([\"FOO\", \"BAR\", np.nan, \"Blah\", \"blurg\"])\n        result = values.str.capitalize()\n        exp = Series([\"Foo\", \"Bar\", np.nan, \"Blah\", \"Blurg\"])\n        tm.assert_series_equal(result, exp)\n\n        # mixed\n        mixed = Series(\n            [\"FOO\", np.nan, \"bar\", True, datetime.today(), \"blah\", None, 1, 2.0]\n        )\n        mixed = mixed.str.capitalize()\n        exp = Series(\n            [\"Foo\", np.nan, \"Bar\", np.nan, np.nan, \"Blah\", np.nan, np.nan, np.nan]\n        )\n        tm.assert_almost_equal(mixed, exp)",
        "begin_line": 922,
        "end_line": 936,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_swapcase#938",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_swapcase(self)",
        "snippet": "    def test_swapcase(self):\n        values = Series([\"FOO\", \"BAR\", np.nan, \"Blah\", \"blurg\"])\n        result = values.str.swapcase()\n        exp = Series([\"foo\", \"bar\", np.nan, \"bLAH\", \"BLURG\"])\n        tm.assert_series_equal(result, exp)\n\n        # mixed\n        mixed = Series(\n            [\"FOO\", np.nan, \"bar\", True, datetime.today(), \"Blah\", None, 1, 2.0]\n        )\n        mixed = mixed.str.swapcase()\n        exp = Series(\n            [\"foo\", np.nan, \"BAR\", np.nan, np.nan, \"bLAH\", np.nan, np.nan, np.nan]\n        )\n        tm.assert_almost_equal(mixed, exp)",
        "begin_line": 938,
        "end_line": 952,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_casemethods#954",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_casemethods(self)",
        "snippet": "    def test_casemethods(self):\n        values = [\"aaa\", \"bbb\", \"CCC\", \"Dddd\", \"eEEE\"]\n        s = Series(values)\n        assert s.str.lower().tolist() == [v.lower() for v in values]\n        assert s.str.upper().tolist() == [v.upper() for v in values]\n        assert s.str.title().tolist() == [v.title() for v in values]\n        assert s.str.capitalize().tolist() == [v.capitalize() for v in values]\n        assert s.str.swapcase().tolist() == [v.swapcase() for v in values]",
        "begin_line": 954,
        "end_line": 961,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_replace#963",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_replace(self)",
        "snippet": "    def test_replace(self):\n        values = Series([\"fooBAD__barBAD\", np.nan])\n\n        result = values.str.replace(\"BAD[_]*\", \"\")\n        exp = Series([\"foobar\", np.nan])\n        tm.assert_series_equal(result, exp)\n\n        result = values.str.replace(\"BAD[_]*\", \"\", n=1)\n        exp = Series([\"foobarBAD\", np.nan])\n        tm.assert_series_equal(result, exp)\n\n        # mixed\n        mixed = Series(\n            [\"aBAD\", np.nan, \"bBAD\", True, datetime.today(), \"fooBAD\", None, 1, 2.0]\n        )\n\n        rs = Series(mixed).str.replace(\"BAD[_]*\", \"\")\n        xp = Series([\"a\", np.nan, \"b\", np.nan, np.nan, \"foo\", np.nan, np.nan, np.nan])\n        assert isinstance(rs, Series)\n        tm.assert_almost_equal(rs, xp)\n\n        # flags + unicode\n        values = Series([b\"abcd,\\xc3\\xa0\".decode(\"utf-8\")])\n        exp = Series([b\"abcd, \\xc3\\xa0\".decode(\"utf-8\")])\n        result = values.str.replace(r\"(?<=\\w),(?=\\w)\", \", \", flags=re.UNICODE)\n        tm.assert_series_equal(result, exp)\n\n        # GH 13438\n        msg = \"repl must be a string or callable\"\n        for klass in (Series, Index):\n            for repl in (None, 3, {\"a\": \"b\"}):\n                for data in ([\"a\", \"b\", None], [\"a\", \"b\", \"c\", \"ad\"]):\n                    values = klass(data)\n                    with pytest.raises(TypeError, match=msg):\n                        values.str.replace(\"a\", repl)",
        "begin_line": 963,
        "end_line": 997,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_replace_callable#999",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_replace_callable(self)",
        "snippet": "    def test_replace_callable(self):\n        # GH 15055\n        values = Series([\"fooBAD__barBAD\", np.nan])\n\n        # test with callable\n        repl = lambda m: m.group(0).swapcase()\n        result = values.str.replace(\"[a-z][A-Z]{2}\", repl, n=2)\n        exp = Series([\"foObaD__baRbaD\", np.nan])\n        tm.assert_series_equal(result, exp)\n\n        # test with wrong number of arguments, raising an error\n        p_err = (\n            r\"((takes)|(missing)) (?(2)from \\d+ to )?\\d+ \"\n            r\"(?(3)required )positional arguments?\"\n        )\n\n        repl = lambda: None\n        with pytest.raises(TypeError, match=p_err):\n            values.str.replace(\"a\", repl)\n\n        repl = lambda m, x: None\n        with pytest.raises(TypeError, match=p_err):\n            values.str.replace(\"a\", repl)\n\n        repl = lambda m, x, y=None: None\n        with pytest.raises(TypeError, match=p_err):\n            values.str.replace(\"a\", repl)\n\n        # test regex named groups\n        values = Series([\"Foo Bar Baz\", np.nan])\n        pat = r\"(?P<first>\\w+) (?P<middle>\\w+) (?P<last>\\w+)\"\n        repl = lambda m: m.group(\"middle\").swapcase()\n        result = values.str.replace(pat, repl)\n        exp = Series([\"bAR\", np.nan])\n        tm.assert_series_equal(result, exp)",
        "begin_line": 999,
        "end_line": 1033,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_replace_compiled_regex#1035",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_replace_compiled_regex(self)",
        "snippet": "    def test_replace_compiled_regex(self):\n        # GH 15446\n        values = Series([\"fooBAD__barBAD\", np.nan])\n\n        # test with compiled regex\n        pat = re.compile(r\"BAD[_]*\")\n        result = values.str.replace(pat, \"\")\n        exp = Series([\"foobar\", np.nan])\n        tm.assert_series_equal(result, exp)\n\n        result = values.str.replace(pat, \"\", n=1)\n        exp = Series([\"foobarBAD\", np.nan])\n        tm.assert_series_equal(result, exp)\n\n        # mixed\n        mixed = Series(\n            [\"aBAD\", np.nan, \"bBAD\", True, datetime.today(), \"fooBAD\", None, 1, 2.0]\n        )\n\n        rs = Series(mixed).str.replace(pat, \"\")\n        xp = Series([\"a\", np.nan, \"b\", np.nan, np.nan, \"foo\", np.nan, np.nan, np.nan])\n        assert isinstance(rs, Series)\n        tm.assert_almost_equal(rs, xp)\n\n        # flags + unicode\n        values = Series([b\"abcd,\\xc3\\xa0\".decode(\"utf-8\")])\n        exp = Series([b\"abcd, \\xc3\\xa0\".decode(\"utf-8\")])\n        pat = re.compile(r\"(?<=\\w),(?=\\w)\", flags=re.UNICODE)\n        result = values.str.replace(pat, \", \")\n        tm.assert_series_equal(result, exp)\n\n        # case and flags provided to str.replace will have no effect\n        # and will produce warnings\n        values = Series([\"fooBAD__barBAD__bad\", np.nan])\n        pat = re.compile(r\"BAD[_]*\")\n\n        with pytest.raises(ValueError, match=\"case and flags cannot be\"):\n            result = values.str.replace(pat, \"\", flags=re.IGNORECASE)\n\n        with pytest.raises(ValueError, match=\"case and flags cannot be\"):\n            result = values.str.replace(pat, \"\", case=False)\n\n        with pytest.raises(ValueError, match=\"case and flags cannot be\"):\n            result = values.str.replace(pat, \"\", case=True)\n\n        # test with callable\n        values = Series([\"fooBAD__barBAD\", np.nan])\n        repl = lambda m: m.group(0).swapcase()\n        pat = re.compile(\"[a-z][A-Z]{2}\")\n        result = values.str.replace(pat, repl, n=2)\n        exp = Series([\"foObaD__baRbaD\", np.nan])\n        tm.assert_series_equal(result, exp)",
        "begin_line": 1035,
        "end_line": 1086,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_replace_literal#1088",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_replace_literal(self)",
        "snippet": "    def test_replace_literal(self):\n        # GH16808 literal replace (regex=False vs regex=True)\n        values = Series([\"f.o\", \"foo\", np.nan])\n        exp = Series([\"bao\", \"bao\", np.nan])\n        result = values.str.replace(\"f.\", \"ba\")\n        tm.assert_series_equal(result, exp)\n\n        exp = Series([\"bao\", \"foo\", np.nan])\n        result = values.str.replace(\"f.\", \"ba\", regex=False)\n        tm.assert_series_equal(result, exp)\n\n        # Cannot do a literal replace if given a callable repl or compiled\n        # pattern\n        callable_repl = lambda m: m.group(0).swapcase()\n        compiled_pat = re.compile(\"[a-z][A-Z]{2}\")\n\n        msg = \"Cannot use a callable replacement when regex=False\"\n        with pytest.raises(ValueError, match=msg):\n            values.str.replace(\"abc\", callable_repl, regex=False)\n\n        msg = \"Cannot use a compiled regex as replacement pattern with regex=False\"\n        with pytest.raises(ValueError, match=msg):\n            values.str.replace(compiled_pat, \"\", regex=False)",
        "begin_line": 1088,
        "end_line": 1110,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_repeat#1112",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_repeat(self)",
        "snippet": "    def test_repeat(self):\n        values = Series([\"a\", \"b\", np.nan, \"c\", np.nan, \"d\"])\n\n        result = values.str.repeat(3)\n        exp = Series([\"aaa\", \"bbb\", np.nan, \"ccc\", np.nan, \"ddd\"])\n        tm.assert_series_equal(result, exp)\n\n        result = values.str.repeat([1, 2, 3, 4, 5, 6])\n        exp = Series([\"a\", \"bb\", np.nan, \"cccc\", np.nan, \"dddddd\"])\n        tm.assert_series_equal(result, exp)\n\n        # mixed\n        mixed = Series([\"a\", np.nan, \"b\", True, datetime.today(), \"foo\", None, 1, 2.0])\n\n        rs = Series(mixed).str.repeat(3)\n        xp = Series(\n            [\"aaa\", np.nan, \"bbb\", np.nan, np.nan, \"foofoofoo\", np.nan, np.nan, np.nan]\n        )\n        assert isinstance(rs, Series)\n        tm.assert_series_equal(rs, xp)",
        "begin_line": 1112,
        "end_line": 1131,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_match#1133",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_match(self)",
        "snippet": "    def test_match(self):\n        # New match behavior introduced in 0.13\n        values = Series([\"fooBAD__barBAD\", np.nan, \"foo\"])\n        result = values.str.match(\".*(BAD[_]+).*(BAD)\")\n        exp = Series([True, np.nan, False])\n        tm.assert_series_equal(result, exp)\n\n        values = Series([\"fooBAD__barBAD\", np.nan, \"foo\"])\n        result = values.str.match(\".*BAD[_]+.*BAD\")\n        exp = Series([True, np.nan, False])\n        tm.assert_series_equal(result, exp)\n\n        # mixed\n        mixed = Series(\n            [\n                \"aBAD_BAD\",\n                np.nan,\n                \"BAD_b_BAD\",\n                True,\n                datetime.today(),\n                \"foo\",\n                None,\n                1,\n                2.0,\n            ]\n        )\n        rs = Series(mixed).str.match(\".*(BAD[_]+).*(BAD)\")\n        xp = Series([True, np.nan, True, np.nan, np.nan, False, np.nan, np.nan, np.nan])\n        assert isinstance(rs, Series)\n        tm.assert_series_equal(rs, xp)\n\n        # na GH #6609\n        res = Series([\"a\", 0, np.nan]).str.match(\"a\", na=False)\n        exp = Series([True, False, False])\n        tm.assert_series_equal(exp, res)\n        res = Series([\"a\", 0, np.nan]).str.match(\"a\")\n        exp = Series([True, np.nan, np.nan])\n        tm.assert_series_equal(exp, res)",
        "begin_line": 1133,
        "end_line": 1170,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_extract_expand_None#1172",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_extract_expand_None(self)",
        "snippet": "    def test_extract_expand_None(self):\n        values = Series([\"fooBAD__barBAD\", np.nan, \"foo\"])\n        with pytest.raises(ValueError, match=\"expand must be True or False\"):\n            values.str.extract(\".*(BAD[_]+).*(BAD)\", expand=None)",
        "begin_line": 1172,
        "end_line": 1175,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_extract_expand_unspecified#1177",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_extract_expand_unspecified(self)",
        "snippet": "    def test_extract_expand_unspecified(self):\n        values = Series([\"fooBAD__barBAD\", np.nan, \"foo\"])\n        result_unspecified = values.str.extract(\".*(BAD[_]+).*\")\n        assert isinstance(result_unspecified, DataFrame)\n        result_true = values.str.extract(\".*(BAD[_]+).*\", expand=True)\n        tm.assert_frame_equal(result_unspecified, result_true)",
        "begin_line": 1177,
        "end_line": 1182,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_extract_expand_False#1184",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_extract_expand_False(self)",
        "snippet": "    def test_extract_expand_False(self):\n        # Contains tests like those in test_match and some others.\n        values = Series([\"fooBAD__barBAD\", np.nan, \"foo\"])\n        er = [np.nan, np.nan]  # empty row\n\n        result = values.str.extract(\".*(BAD[_]+).*(BAD)\", expand=False)\n        exp = DataFrame([[\"BAD__\", \"BAD\"], er, er])\n        tm.assert_frame_equal(result, exp)\n\n        # mixed\n        mixed = Series(\n            [\n                \"aBAD_BAD\",\n                np.nan,\n                \"BAD_b_BAD\",\n                True,\n                datetime.today(),\n                \"foo\",\n                None,\n                1,\n                2.0,\n            ]\n        )\n\n        rs = Series(mixed).str.extract(\".*(BAD[_]+).*(BAD)\", expand=False)\n        exp = DataFrame([[\"BAD_\", \"BAD\"], er, [\"BAD_\", \"BAD\"], er, er, er, er, er, er])\n        tm.assert_frame_equal(rs, exp)\n\n        # unicode\n        values = Series([\"fooBAD__barBAD\", np.nan, \"foo\"])\n\n        result = values.str.extract(\".*(BAD[_]+).*(BAD)\", expand=False)\n        exp = DataFrame([[\"BAD__\", \"BAD\"], er, er])\n        tm.assert_frame_equal(result, exp)\n\n        # GH9980\n        # Index only works with one regex group since\n        # multi-group would expand to a frame\n        idx = Index([\"A1\", \"A2\", \"A3\", \"A4\", \"B5\"])\n        with pytest.raises(ValueError, match=\"supported\"):\n            idx.str.extract(\"([AB])([123])\", expand=False)\n\n        # these should work for both Series and Index\n        for klass in [Series, Index]:\n            # no groups\n            s_or_idx = klass([\"A1\", \"B2\", \"C3\"])\n            msg = \"pattern contains no capture groups\"\n            with pytest.raises(ValueError, match=msg):\n                s_or_idx.str.extract(\"[ABC][123]\", expand=False)\n\n            # only non-capturing groups\n            with pytest.raises(ValueError, match=msg):\n                s_or_idx.str.extract(\"(?:[AB]).*\", expand=False)\n\n            # single group renames series/index properly\n            s_or_idx = klass([\"A1\", \"A2\"])\n            result = s_or_idx.str.extract(r\"(?P<uno>A)\\d\", expand=False)\n            assert result.name == \"uno\"\n\n            exp = klass([\"A\", \"A\"], name=\"uno\")\n            if klass == Series:\n                tm.assert_series_equal(result, exp)\n            else:\n                tm.assert_index_equal(result, exp)\n\n        s = Series([\"A1\", \"B2\", \"C3\"])\n        # one group, no matches\n        result = s.str.extract(\"(_)\", expand=False)\n        exp = Series([np.nan, np.nan, np.nan], dtype=object)\n        tm.assert_series_equal(result, exp)\n\n        # two groups, no matches\n        result = s.str.extract(\"(_)(_)\", expand=False)\n        exp = DataFrame(\n            [[np.nan, np.nan], [np.nan, np.nan], [np.nan, np.nan]], dtype=object\n        )\n        tm.assert_frame_equal(result, exp)\n\n        # one group, some matches\n        result = s.str.extract(\"([AB])[123]\", expand=False)\n        exp = Series([\"A\", \"B\", np.nan])\n        tm.assert_series_equal(result, exp)\n\n        # two groups, some matches\n        result = s.str.extract(\"([AB])([123])\", expand=False)\n        exp = DataFrame([[\"A\", \"1\"], [\"B\", \"2\"], [np.nan, np.nan]])\n        tm.assert_frame_equal(result, exp)\n\n        # one named group\n        result = s.str.extract(\"(?P<letter>[AB])\", expand=False)\n        exp = Series([\"A\", \"B\", np.nan], name=\"letter\")\n        tm.assert_series_equal(result, exp)\n\n        # two named groups\n        result = s.str.extract(\"(?P<letter>[AB])(?P<number>[123])\", expand=False)\n        exp = DataFrame(\n            [[\"A\", \"1\"], [\"B\", \"2\"], [np.nan, np.nan]], columns=[\"letter\", \"number\"]\n        )\n        tm.assert_frame_equal(result, exp)\n\n        # mix named and unnamed groups\n        result = s.str.extract(\"([AB])(?P<number>[123])\", expand=False)\n        exp = DataFrame(\n            [[\"A\", \"1\"], [\"B\", \"2\"], [np.nan, np.nan]], columns=[0, \"number\"]\n        )\n        tm.assert_frame_equal(result, exp)\n\n        # one normal group, one non-capturing group\n        result = s.str.extract(\"([AB])(?:[123])\", expand=False)\n        exp = Series([\"A\", \"B\", np.nan])\n        tm.assert_series_equal(result, exp)\n\n        # two normal groups, one non-capturing group\n        result = Series([\"A11\", \"B22\", \"C33\"]).str.extract(\n            \"([AB])([123])(?:[123])\", expand=False\n        )\n        exp = DataFrame([[\"A\", \"1\"], [\"B\", \"2\"], [np.nan, np.nan]])\n        tm.assert_frame_equal(result, exp)\n\n        # one optional group followed by one normal group\n        result = Series([\"A1\", \"B2\", \"3\"]).str.extract(\n            \"(?P<letter>[AB])?(?P<number>[123])\", expand=False\n        )\n        exp = DataFrame(\n            [[\"A\", \"1\"], [\"B\", \"2\"], [np.nan, \"3\"]], columns=[\"letter\", \"number\"]\n        )\n        tm.assert_frame_equal(result, exp)\n\n        # one normal group followed by one optional group\n        result = Series([\"A1\", \"B2\", \"C\"]).str.extract(\n            \"(?P<letter>[ABC])(?P<number>[123])?\", expand=False\n        )\n        exp = DataFrame(\n            [[\"A\", \"1\"], [\"B\", \"2\"], [\"C\", np.nan]], columns=[\"letter\", \"number\"]\n        )\n        tm.assert_frame_equal(result, exp)\n\n        # GH6348\n        # not passing index to the extractor\n        def check_index(index):\n            data = [\"A1\", \"B2\", \"C\"]\n            index = index[: len(data)]\n            s = Series(data, index=index)\n            result = s.str.extract(r\"(\\d)\", expand=False)\n            exp = Series([\"1\", \"2\", np.nan], index=index)\n            tm.assert_series_equal(result, exp)\n\n            result = Series(data, index=index).str.extract(\n                r\"(?P<letter>\\D)(?P<number>\\d)?\", expand=False\n            )\n            e_list = [[\"A\", \"1\"], [\"B\", \"2\"], [\"C\", np.nan]]\n            exp = DataFrame(e_list, columns=[\"letter\", \"number\"], index=index)\n            tm.assert_frame_equal(result, exp)\n\n        i_funs = [\n            tm.makeStringIndex,\n            tm.makeUnicodeIndex,\n            tm.makeIntIndex,\n            tm.makeDateIndex,\n            tm.makePeriodIndex,\n            tm.makeRangeIndex,\n        ]\n        for index in i_funs:\n            check_index(index())\n\n        # single_series_name_is_preserved.\n        s = Series([\"a3\", \"b3\", \"c2\"], name=\"bob\")\n        r = s.str.extract(r\"(?P<sue>[a-z])\", expand=False)\n        e = Series([\"a\", \"b\", \"c\"], name=\"sue\")\n        tm.assert_series_equal(r, e)\n        assert r.name == e.name",
        "begin_line": 1184,
        "end_line": 1354,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.check_index#1323",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.check_index(index)",
        "snippet": "        def check_index(index):\n            data = [\"A1\", \"B2\", \"C\"]\n            index = index[: len(data)]\n            s = Series(data, index=index)\n            result = s.str.extract(r\"(\\d)\", expand=False)\n            exp = Series([\"1\", \"2\", np.nan], index=index)\n            tm.assert_series_equal(result, exp)\n\n            result = Series(data, index=index).str.extract(\n                r\"(?P<letter>\\D)(?P<number>\\d)?\", expand=False\n            )\n            e_list = [[\"A\", \"1\"], [\"B\", \"2\"], [\"C\", np.nan]]\n            exp = DataFrame(e_list, columns=[\"letter\", \"number\"], index=index)\n            tm.assert_frame_equal(result, exp)",
        "begin_line": 1323,
        "end_line": 1336,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_extract_expand_True#1356",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_extract_expand_True(self)",
        "snippet": "    def test_extract_expand_True(self):\n        # Contains tests like those in test_match and some others.\n        values = Series([\"fooBAD__barBAD\", np.nan, \"foo\"])\n        er = [np.nan, np.nan]  # empty row\n\n        result = values.str.extract(\".*(BAD[_]+).*(BAD)\", expand=True)\n        exp = DataFrame([[\"BAD__\", \"BAD\"], er, er])\n        tm.assert_frame_equal(result, exp)\n\n        # mixed\n        mixed = Series(\n            [\n                \"aBAD_BAD\",\n                np.nan,\n                \"BAD_b_BAD\",\n                True,\n                datetime.today(),\n                \"foo\",\n                None,\n                1,\n                2.0,\n            ]\n        )\n\n        rs = Series(mixed).str.extract(\".*(BAD[_]+).*(BAD)\", expand=True)\n        exp = DataFrame([[\"BAD_\", \"BAD\"], er, [\"BAD_\", \"BAD\"], er, er, er, er, er, er])\n        tm.assert_frame_equal(rs, exp)\n\n        # these should work for both Series and Index\n        for klass in [Series, Index]:\n            # no groups\n            s_or_idx = klass([\"A1\", \"B2\", \"C3\"])\n            msg = \"pattern contains no capture groups\"\n            with pytest.raises(ValueError, match=msg):\n                s_or_idx.str.extract(\"[ABC][123]\", expand=True)\n\n            # only non-capturing groups\n            with pytest.raises(ValueError, match=msg):\n                s_or_idx.str.extract(\"(?:[AB]).*\", expand=True)\n\n            # single group renames series/index properly\n            s_or_idx = klass([\"A1\", \"A2\"])\n            result_df = s_or_idx.str.extract(r\"(?P<uno>A)\\d\", expand=True)\n            assert isinstance(result_df, DataFrame)\n            result_series = result_df[\"uno\"]\n            tm.assert_series_equal(result_series, Series([\"A\", \"A\"], name=\"uno\"))",
        "begin_line": 1356,
        "end_line": 1401,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_extract_series#1403",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_extract_series(self)",
        "snippet": "    def test_extract_series(self):\n        # extract should give the same result whether or not the\n        # series has a name.\n        for series_name in None, \"series_name\":\n            s = Series([\"A1\", \"B2\", \"C3\"], name=series_name)\n            # one group, no matches\n            result = s.str.extract(\"(_)\", expand=True)\n            exp = DataFrame([np.nan, np.nan, np.nan], dtype=object)\n            tm.assert_frame_equal(result, exp)\n\n            # two groups, no matches\n            result = s.str.extract(\"(_)(_)\", expand=True)\n            exp = DataFrame(\n                [[np.nan, np.nan], [np.nan, np.nan], [np.nan, np.nan]], dtype=object\n            )\n            tm.assert_frame_equal(result, exp)\n\n            # one group, some matches\n            result = s.str.extract(\"([AB])[123]\", expand=True)\n            exp = DataFrame([\"A\", \"B\", np.nan])\n            tm.assert_frame_equal(result, exp)\n\n            # two groups, some matches\n            result = s.str.extract(\"([AB])([123])\", expand=True)\n            exp = DataFrame([[\"A\", \"1\"], [\"B\", \"2\"], [np.nan, np.nan]])\n            tm.assert_frame_equal(result, exp)\n\n            # one named group\n            result = s.str.extract(\"(?P<letter>[AB])\", expand=True)\n            exp = DataFrame({\"letter\": [\"A\", \"B\", np.nan]})\n            tm.assert_frame_equal(result, exp)\n\n            # two named groups\n            result = s.str.extract(\"(?P<letter>[AB])(?P<number>[123])\", expand=True)\n            e_list = [[\"A\", \"1\"], [\"B\", \"2\"], [np.nan, np.nan]]\n            exp = DataFrame(e_list, columns=[\"letter\", \"number\"])\n            tm.assert_frame_equal(result, exp)\n\n            # mix named and unnamed groups\n            result = s.str.extract(\"([AB])(?P<number>[123])\", expand=True)\n            exp = DataFrame(e_list, columns=[0, \"number\"])\n            tm.assert_frame_equal(result, exp)\n\n            # one normal group, one non-capturing group\n            result = s.str.extract(\"([AB])(?:[123])\", expand=True)\n            exp = DataFrame([\"A\", \"B\", np.nan])\n            tm.assert_frame_equal(result, exp)",
        "begin_line": 1403,
        "end_line": 1449,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_extract_optional_groups#1451",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_extract_optional_groups(self)",
        "snippet": "    def test_extract_optional_groups(self):\n\n        # two normal groups, one non-capturing group\n        result = Series([\"A11\", \"B22\", \"C33\"]).str.extract(\n            \"([AB])([123])(?:[123])\", expand=True\n        )\n        exp = DataFrame([[\"A\", \"1\"], [\"B\", \"2\"], [np.nan, np.nan]])\n        tm.assert_frame_equal(result, exp)\n\n        # one optional group followed by one normal group\n        result = Series([\"A1\", \"B2\", \"3\"]).str.extract(\n            \"(?P<letter>[AB])?(?P<number>[123])\", expand=True\n        )\n        e_list = [[\"A\", \"1\"], [\"B\", \"2\"], [np.nan, \"3\"]]\n        exp = DataFrame(e_list, columns=[\"letter\", \"number\"])\n        tm.assert_frame_equal(result, exp)\n\n        # one normal group followed by one optional group\n        result = Series([\"A1\", \"B2\", \"C\"]).str.extract(\n            \"(?P<letter>[ABC])(?P<number>[123])?\", expand=True\n        )\n        e_list = [[\"A\", \"1\"], [\"B\", \"2\"], [\"C\", np.nan]]\n        exp = DataFrame(e_list, columns=[\"letter\", \"number\"])\n        tm.assert_frame_equal(result, exp)\n\n        # GH6348\n        # not passing index to the extractor\n        def check_index(index):\n            data = [\"A1\", \"B2\", \"C\"]\n            index = index[: len(data)]\n            result = Series(data, index=index).str.extract(r\"(\\d)\", expand=True)\n            exp = DataFrame([\"1\", \"2\", np.nan], index=index)\n            tm.assert_frame_equal(result, exp)\n\n            result = Series(data, index=index).str.extract(\n                r\"(?P<letter>\\D)(?P<number>\\d)?\", expand=True\n            )\n            e_list = [[\"A\", \"1\"], [\"B\", \"2\"], [\"C\", np.nan]]\n            exp = DataFrame(e_list, columns=[\"letter\", \"number\"], index=index)\n            tm.assert_frame_equal(result, exp)\n\n        i_funs = [\n            tm.makeStringIndex,\n            tm.makeUnicodeIndex,\n            tm.makeIntIndex,\n            tm.makeDateIndex,\n            tm.makePeriodIndex,\n            tm.makeRangeIndex,\n        ]\n        for index in i_funs:\n            check_index(index())",
        "begin_line": 1451,
        "end_line": 1501,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.check_index#1478",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.check_index(index)",
        "snippet": "        def check_index(index):\n            data = [\"A1\", \"B2\", \"C\"]\n            index = index[: len(data)]\n            result = Series(data, index=index).str.extract(r\"(\\d)\", expand=True)\n            exp = DataFrame([\"1\", \"2\", np.nan], index=index)\n            tm.assert_frame_equal(result, exp)\n\n            result = Series(data, index=index).str.extract(\n                r\"(?P<letter>\\D)(?P<number>\\d)?\", expand=True\n            )\n            e_list = [[\"A\", \"1\"], [\"B\", \"2\"], [\"C\", np.nan]]\n            exp = DataFrame(e_list, columns=[\"letter\", \"number\"], index=index)\n            tm.assert_frame_equal(result, exp)",
        "begin_line": 1478,
        "end_line": 1490,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_extract_single_group_returns_frame#1503",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_extract_single_group_returns_frame(self)",
        "snippet": "    def test_extract_single_group_returns_frame(self):\n        # GH11386 extract should always return DataFrame, even when\n        # there is only one group. Prior to v0.18.0, extract returned\n        # Series when there was only one group in the regex.\n        s = Series([\"a3\", \"b3\", \"c2\"], name=\"series_name\")\n        r = s.str.extract(r\"(?P<letter>[a-z])\", expand=True)\n        e = DataFrame({\"letter\": [\"a\", \"b\", \"c\"]})\n        tm.assert_frame_equal(r, e)",
        "begin_line": 1503,
        "end_line": 1510,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_extractall#1512",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_extractall(self)",
        "snippet": "    def test_extractall(self):\n        subject_list = [\n            \"dave@google.com\",\n            \"tdhock5@gmail.com\",\n            \"maudelaperriere@gmail.com\",\n            \"rob@gmail.com some text steve@gmail.com\",\n            \"a@b.com some text c@d.com and e@f.com\",\n            np.nan,\n            \"\",\n        ]\n        expected_tuples = [\n            (\"dave\", \"google\", \"com\"),\n            (\"tdhock5\", \"gmail\", \"com\"),\n            (\"maudelaperriere\", \"gmail\", \"com\"),\n            (\"rob\", \"gmail\", \"com\"),\n            (\"steve\", \"gmail\", \"com\"),\n            (\"a\", \"b\", \"com\"),\n            (\"c\", \"d\", \"com\"),\n            (\"e\", \"f\", \"com\"),\n        ]\n        named_pattern = r\"\"\"\n        (?P<user>[a-z0-9]+)\n        @\n        (?P<domain>[a-z]+)\n        \\.\n        (?P<tld>[a-z]{2,4})\n        \"\"\"\n        expected_columns = [\"user\", \"domain\", \"tld\"]\n        S = Series(subject_list)\n        # extractall should return a DataFrame with one row for each\n        # match, indexed by the subject from which the match came.\n        expected_index = MultiIndex.from_tuples(\n            [(0, 0), (1, 0), (2, 0), (3, 0), (3, 1), (4, 0), (4, 1), (4, 2)],\n            names=(None, \"match\"),\n        )\n        expected_df = DataFrame(expected_tuples, expected_index, expected_columns)\n        computed_df = S.str.extractall(named_pattern, re.VERBOSE)\n        tm.assert_frame_equal(computed_df, expected_df)\n\n        # The index of the input Series should be used to construct\n        # the index of the output DataFrame:\n        series_index = MultiIndex.from_tuples(\n            [\n                (\"single\", \"Dave\"),\n                (\"single\", \"Toby\"),\n                (\"single\", \"Maude\"),\n                (\"multiple\", \"robAndSteve\"),\n                (\"multiple\", \"abcdef\"),\n                (\"none\", \"missing\"),\n                (\"none\", \"empty\"),\n            ]\n        )\n        Si = Series(subject_list, series_index)\n        expected_index = MultiIndex.from_tuples(\n            [\n                (\"single\", \"Dave\", 0),\n                (\"single\", \"Toby\", 0),\n                (\"single\", \"Maude\", 0),\n                (\"multiple\", \"robAndSteve\", 0),\n                (\"multiple\", \"robAndSteve\", 1),\n                (\"multiple\", \"abcdef\", 0),\n                (\"multiple\", \"abcdef\", 1),\n                (\"multiple\", \"abcdef\", 2),\n            ],\n            names=(None, None, \"match\"),\n        )\n        expected_df = DataFrame(expected_tuples, expected_index, expected_columns)\n        computed_df = Si.str.extractall(named_pattern, re.VERBOSE)\n        tm.assert_frame_equal(computed_df, expected_df)\n\n        # MultiIndexed subject with names.\n        Sn = Series(subject_list, series_index)\n        Sn.index.names = (\"matches\", \"description\")\n        expected_index.names = (\"matches\", \"description\", \"match\")\n        expected_df = DataFrame(expected_tuples, expected_index, expected_columns)\n        computed_df = Sn.str.extractall(named_pattern, re.VERBOSE)\n        tm.assert_frame_equal(computed_df, expected_df)\n\n        # optional groups.\n        subject_list = [\"\", \"A1\", \"32\"]\n        named_pattern = \"(?P<letter>[AB])?(?P<number>[123])\"\n        computed_df = Series(subject_list).str.extractall(named_pattern)\n        expected_index = MultiIndex.from_tuples(\n            [(1, 0), (2, 0), (2, 1)], names=(None, \"match\")\n        )\n        expected_df = DataFrame(\n            [(\"A\", \"1\"), (np.nan, \"3\"), (np.nan, \"2\")],\n            expected_index,\n            columns=[\"letter\", \"number\"],\n        )\n        tm.assert_frame_equal(computed_df, expected_df)\n\n        # only one of two groups has a name.\n        pattern = \"([AB])?(?P<number>[123])\"\n        computed_df = Series(subject_list).str.extractall(pattern)\n        expected_df = DataFrame(\n            [(\"A\", \"1\"), (np.nan, \"3\"), (np.nan, \"2\")],\n            expected_index,\n            columns=[0, \"number\"],\n        )\n        tm.assert_frame_equal(computed_df, expected_df)",
        "begin_line": 1512,
        "end_line": 1612,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_extractall_single_group#1614",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_extractall_single_group(self)",
        "snippet": "    def test_extractall_single_group(self):\n        # extractall(one named group) returns DataFrame with one named\n        # column.\n        s = Series([\"a3\", \"b3\", \"d4c2\"], name=\"series_name\")\n        r = s.str.extractall(r\"(?P<letter>[a-z])\")\n        i = MultiIndex.from_tuples(\n            [(0, 0), (1, 0), (2, 0), (2, 1)], names=(None, \"match\")\n        )\n        e = DataFrame({\"letter\": [\"a\", \"b\", \"d\", \"c\"]}, i)\n        tm.assert_frame_equal(r, e)\n\n        # extractall(one un-named group) returns DataFrame with one\n        # un-named column.\n        r = s.str.extractall(r\"([a-z])\")\n        e = DataFrame([\"a\", \"b\", \"d\", \"c\"], i)\n        tm.assert_frame_equal(r, e)",
        "begin_line": 1614,
        "end_line": 1629,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_extractall_single_group_with_quantifier#1631",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_extractall_single_group_with_quantifier(self)",
        "snippet": "    def test_extractall_single_group_with_quantifier(self):\n        # extractall(one un-named group with quantifier) returns\n        # DataFrame with one un-named column (GH13382).\n        s = Series([\"ab3\", \"abc3\", \"d4cd2\"], name=\"series_name\")\n        r = s.str.extractall(r\"([a-z]+)\")\n        i = MultiIndex.from_tuples(\n            [(0, 0), (1, 0), (2, 0), (2, 1)], names=(None, \"match\")\n        )\n        e = DataFrame([\"ab\", \"abc\", \"d\", \"cd\"], i)\n        tm.assert_frame_equal(r, e)",
        "begin_line": 1631,
        "end_line": 1640,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_extractall_no_matches#1655",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_extractall_no_matches(self, data, names)",
        "snippet": "    def test_extractall_no_matches(self, data, names):\n        # GH19075 extractall with no matches should return a valid MultiIndex\n        n = len(data)\n        if len(names) == 1:\n            i = Index(range(n), name=names[0])\n        else:\n            a = (tuple([i] * (n - 1)) for i in range(n))\n            i = MultiIndex.from_tuples(a, names=names)\n        s = Series(data, name=\"series_name\", index=i, dtype=\"object\")\n        ei = MultiIndex.from_tuples([], names=(names + (\"match\",)))\n\n        # one un-named group.\n        r = s.str.extractall(\"(z)\")\n        e = DataFrame(columns=[0], index=ei)\n        tm.assert_frame_equal(r, e)\n\n        # two un-named groups.\n        r = s.str.extractall(\"(z)(z)\")\n        e = DataFrame(columns=[0, 1], index=ei)\n        tm.assert_frame_equal(r, e)\n\n        # one named group.\n        r = s.str.extractall(\"(?P<first>z)\")\n        e = DataFrame(columns=[\"first\"], index=ei)\n        tm.assert_frame_equal(r, e)\n\n        # two named groups.\n        r = s.str.extractall(\"(?P<first>z)(?P<second>z)\")\n        e = DataFrame(columns=[\"first\", \"second\"], index=ei)\n        tm.assert_frame_equal(r, e)\n\n        # one named, one un-named.\n        r = s.str.extractall(\"(z)(?P<second>z)\")\n        e = DataFrame(columns=[0, \"second\"], index=ei)\n        tm.assert_frame_equal(r, e)",
        "begin_line": 1655,
        "end_line": 1689,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_extractall_stringindex#1691",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_extractall_stringindex(self)",
        "snippet": "    def test_extractall_stringindex(self):\n        s = Series([\"a1a2\", \"b1\", \"c1\"], name=\"xxx\")\n        res = s.str.extractall(r\"[ab](?P<digit>\\d)\")\n        exp_idx = MultiIndex.from_tuples(\n            [(0, 0), (0, 1), (1, 0)], names=[None, \"match\"]\n        )\n        exp = DataFrame({\"digit\": [\"1\", \"2\", \"1\"]}, index=exp_idx)\n        tm.assert_frame_equal(res, exp)\n\n        # index should return the same result as the default index without name\n        # thus index.name doesn't affect to the result\n        for idx in [\n            Index([\"a1a2\", \"b1\", \"c1\"]),\n            Index([\"a1a2\", \"b1\", \"c1\"], name=\"xxx\"),\n        ]:\n\n            res = idx.str.extractall(r\"[ab](?P<digit>\\d)\")\n            tm.assert_frame_equal(res, exp)\n\n        s = Series(\n            [\"a1a2\", \"b1\", \"c1\"],\n            name=\"s_name\",\n            index=Index([\"XX\", \"yy\", \"zz\"], name=\"idx_name\"),\n        )\n        res = s.str.extractall(r\"[ab](?P<digit>\\d)\")\n        exp_idx = MultiIndex.from_tuples(\n            [(\"XX\", 0), (\"XX\", 1), (\"yy\", 0)], names=[\"idx_name\", \"match\"]\n        )\n        exp = DataFrame({\"digit\": [\"1\", \"2\", \"1\"]}, index=exp_idx)\n        tm.assert_frame_equal(res, exp)",
        "begin_line": 1691,
        "end_line": 1720,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_extractall_errors#1722",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_extractall_errors(self)",
        "snippet": "    def test_extractall_errors(self):\n        # Does not make sense to use extractall with a regex that has\n        # no capture groups. (it returns DataFrame with one column for\n        # each capture group)\n        s = Series([\"a3\", \"b3\", \"d4c2\"], name=\"series_name\")\n        with pytest.raises(ValueError, match=\"no capture groups\"):\n            s.str.extractall(r\"[a-z]\")",
        "begin_line": 1722,
        "end_line": 1728,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_extract_index_one_two_groups#1730",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_extract_index_one_two_groups(self)",
        "snippet": "    def test_extract_index_one_two_groups(self):\n        s = Series([\"a3\", \"b3\", \"d4c2\"], index=[\"A3\", \"B3\", \"D4\"], name=\"series_name\")\n        r = s.index.str.extract(r\"([A-Z])\", expand=True)\n        e = DataFrame([\"A\", \"B\", \"D\"])\n        tm.assert_frame_equal(r, e)\n\n        # Prior to v0.18.0, index.str.extract(regex with one group)\n        # returned Index. With more than one group, extract raised an\n        # error (GH9980). Now extract always returns DataFrame.\n        r = s.index.str.extract(r\"(?P<letter>[A-Z])(?P<digit>[0-9])\", expand=True)\n        e_list = [(\"A\", \"3\"), (\"B\", \"3\"), (\"D\", \"4\")]\n        e = DataFrame(e_list, columns=[\"letter\", \"digit\"])\n        tm.assert_frame_equal(r, e)",
        "begin_line": 1730,
        "end_line": 1742,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_extractall_same_as_extract#1744",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_extractall_same_as_extract(self)",
        "snippet": "    def test_extractall_same_as_extract(self):\n        s = Series([\"a3\", \"b3\", \"c2\"], name=\"series_name\")\n\n        pattern_two_noname = r\"([a-z])([0-9])\"\n        extract_two_noname = s.str.extract(pattern_two_noname, expand=True)\n        has_multi_index = s.str.extractall(pattern_two_noname)\n        no_multi_index = has_multi_index.xs(0, level=\"match\")\n        tm.assert_frame_equal(extract_two_noname, no_multi_index)\n\n        pattern_two_named = r\"(?P<letter>[a-z])(?P<digit>[0-9])\"\n        extract_two_named = s.str.extract(pattern_two_named, expand=True)\n        has_multi_index = s.str.extractall(pattern_two_named)\n        no_multi_index = has_multi_index.xs(0, level=\"match\")\n        tm.assert_frame_equal(extract_two_named, no_multi_index)\n\n        pattern_one_named = r\"(?P<group_name>[a-z])\"\n        extract_one_named = s.str.extract(pattern_one_named, expand=True)\n        has_multi_index = s.str.extractall(pattern_one_named)\n        no_multi_index = has_multi_index.xs(0, level=\"match\")\n        tm.assert_frame_equal(extract_one_named, no_multi_index)\n\n        pattern_one_noname = r\"([a-z])\"\n        extract_one_noname = s.str.extract(pattern_one_noname, expand=True)\n        has_multi_index = s.str.extractall(pattern_one_noname)\n        no_multi_index = has_multi_index.xs(0, level=\"match\")\n        tm.assert_frame_equal(extract_one_noname, no_multi_index)",
        "begin_line": 1744,
        "end_line": 1769,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_extractall_same_as_extract_subject_index#1771",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_extractall_same_as_extract_subject_index(self)",
        "snippet": "    def test_extractall_same_as_extract_subject_index(self):\n        # same as above tests, but s has an MultiIndex.\n        i = MultiIndex.from_tuples(\n            [(\"A\", \"first\"), (\"B\", \"second\"), (\"C\", \"third\")],\n            names=(\"capital\", \"ordinal\"),\n        )\n        s = Series([\"a3\", \"b3\", \"c2\"], i, name=\"series_name\")\n\n        pattern_two_noname = r\"([a-z])([0-9])\"\n        extract_two_noname = s.str.extract(pattern_two_noname, expand=True)\n        has_match_index = s.str.extractall(pattern_two_noname)\n        no_match_index = has_match_index.xs(0, level=\"match\")\n        tm.assert_frame_equal(extract_two_noname, no_match_index)\n\n        pattern_two_named = r\"(?P<letter>[a-z])(?P<digit>[0-9])\"\n        extract_two_named = s.str.extract(pattern_two_named, expand=True)\n        has_match_index = s.str.extractall(pattern_two_named)\n        no_match_index = has_match_index.xs(0, level=\"match\")\n        tm.assert_frame_equal(extract_two_named, no_match_index)\n\n        pattern_one_named = r\"(?P<group_name>[a-z])\"\n        extract_one_named = s.str.extract(pattern_one_named, expand=True)\n        has_match_index = s.str.extractall(pattern_one_named)\n        no_match_index = has_match_index.xs(0, level=\"match\")\n        tm.assert_frame_equal(extract_one_named, no_match_index)\n\n        pattern_one_noname = r\"([a-z])\"\n        extract_one_noname = s.str.extract(pattern_one_noname, expand=True)\n        has_match_index = s.str.extractall(pattern_one_noname)\n        no_match_index = has_match_index.xs(0, level=\"match\")\n        tm.assert_frame_equal(extract_one_noname, no_match_index)",
        "begin_line": 1771,
        "end_line": 1801,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_empty_str_methods#1803",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_empty_str_methods(self)",
        "snippet": "    def test_empty_str_methods(self):\n        empty_str = empty = Series(dtype=object)\n        empty_int = Series(dtype=int)\n        empty_bool = Series(dtype=bool)\n        empty_bytes = Series(dtype=object)\n\n        # GH7241\n        # (extract) on empty series\n\n        tm.assert_series_equal(empty_str, empty.str.cat(empty))\n        assert \"\" == empty.str.cat()\n        tm.assert_series_equal(empty_str, empty.str.title())\n        tm.assert_series_equal(empty_int, empty.str.count(\"a\"))\n        tm.assert_series_equal(empty_bool, empty.str.contains(\"a\"))\n        tm.assert_series_equal(empty_bool, empty.str.startswith(\"a\"))\n        tm.assert_series_equal(empty_bool, empty.str.endswith(\"a\"))\n        tm.assert_series_equal(empty_str, empty.str.lower())\n        tm.assert_series_equal(empty_str, empty.str.upper())\n        tm.assert_series_equal(empty_str, empty.str.replace(\"a\", \"b\"))\n        tm.assert_series_equal(empty_str, empty.str.repeat(3))\n        tm.assert_series_equal(empty_bool, empty.str.match(\"^a\"))\n        tm.assert_frame_equal(\n            DataFrame(columns=[0], dtype=str), empty.str.extract(\"()\", expand=True)\n        )\n        tm.assert_frame_equal(\n            DataFrame(columns=[0, 1], dtype=str), empty.str.extract(\"()()\", expand=True)\n        )\n        tm.assert_series_equal(empty_str, empty.str.extract(\"()\", expand=False))\n        tm.assert_frame_equal(\n            DataFrame(columns=[0, 1], dtype=str),\n            empty.str.extract(\"()()\", expand=False),\n        )\n        tm.assert_frame_equal(DataFrame(dtype=str), empty.str.get_dummies())\n        tm.assert_series_equal(empty_str, empty_str.str.join(\"\"))\n        tm.assert_series_equal(empty_int, empty.str.len())\n        tm.assert_series_equal(empty_str, empty_str.str.findall(\"a\"))\n        tm.assert_series_equal(empty_int, empty.str.find(\"a\"))\n        tm.assert_series_equal(empty_int, empty.str.rfind(\"a\"))\n        tm.assert_series_equal(empty_str, empty.str.pad(42))\n        tm.assert_series_equal(empty_str, empty.str.center(42))\n        tm.assert_series_equal(empty_str, empty.str.split(\"a\"))\n        tm.assert_series_equal(empty_str, empty.str.rsplit(\"a\"))\n        tm.assert_series_equal(empty_str, empty.str.partition(\"a\", expand=False))\n        tm.assert_series_equal(empty_str, empty.str.rpartition(\"a\", expand=False))\n        tm.assert_series_equal(empty_str, empty.str.slice(stop=1))\n        tm.assert_series_equal(empty_str, empty.str.slice(step=1))\n        tm.assert_series_equal(empty_str, empty.str.strip())\n        tm.assert_series_equal(empty_str, empty.str.lstrip())\n        tm.assert_series_equal(empty_str, empty.str.rstrip())\n        tm.assert_series_equal(empty_str, empty.str.wrap(42))\n        tm.assert_series_equal(empty_str, empty.str.get(0))\n        tm.assert_series_equal(empty_str, empty_bytes.str.decode(\"ascii\"))\n        tm.assert_series_equal(empty_bytes, empty.str.encode(\"ascii\"))\n        # ismethods should always return boolean (GH 29624)\n        tm.assert_series_equal(empty_bool, empty.str.isalnum())\n        tm.assert_series_equal(empty_bool, empty.str.isalpha())\n        tm.assert_series_equal(empty_bool, empty.str.isdigit())\n        tm.assert_series_equal(empty_bool, empty.str.isspace())\n        tm.assert_series_equal(empty_bool, empty.str.islower())\n        tm.assert_series_equal(empty_bool, empty.str.isupper())\n        tm.assert_series_equal(empty_bool, empty.str.istitle())\n        tm.assert_series_equal(empty_bool, empty.str.isnumeric())\n        tm.assert_series_equal(empty_bool, empty.str.isdecimal())\n        tm.assert_series_equal(empty_str, empty.str.capitalize())\n        tm.assert_series_equal(empty_str, empty.str.swapcase())\n        tm.assert_series_equal(empty_str, empty.str.normalize(\"NFC\"))\n\n        table = str.maketrans(\"a\", \"b\")\n        tm.assert_series_equal(empty_str, empty.str.translate(table))",
        "begin_line": 1803,
        "end_line": 1871,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_empty_str_methods_to_frame#1873",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_empty_str_methods_to_frame(self)",
        "snippet": "    def test_empty_str_methods_to_frame(self):\n        empty = Series(dtype=str)\n        empty_df = DataFrame()\n        tm.assert_frame_equal(empty_df, empty.str.partition(\"a\"))\n        tm.assert_frame_equal(empty_df, empty.str.rpartition(\"a\"))",
        "begin_line": 1873,
        "end_line": 1877,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_ismethods#1879",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_ismethods(self)",
        "snippet": "    def test_ismethods(self):\n        values = [\"A\", \"b\", \"Xy\", \"4\", \"3A\", \"\", \"TT\", \"55\", \"-\", \"  \"]\n        str_s = Series(values)\n        alnum_e = [True, True, True, True, True, False, True, True, False, False]\n        alpha_e = [True, True, True, False, False, False, True, False, False, False]\n        digit_e = [False, False, False, True, False, False, False, True, False, False]\n\n        # TODO: unused\n        num_e = [  # noqa\n            False,\n            False,\n            False,\n            True,\n            False,\n            False,\n            False,\n            True,\n            False,\n            False,\n        ]\n\n        space_e = [False, False, False, False, False, False, False, False, False, True]\n        lower_e = [False, True, False, False, False, False, False, False, False, False]\n        upper_e = [True, False, False, False, True, False, True, False, False, False]\n        title_e = [True, False, True, False, True, False, False, False, False, False]\n\n        tm.assert_series_equal(str_s.str.isalnum(), Series(alnum_e))\n        tm.assert_series_equal(str_s.str.isalpha(), Series(alpha_e))\n        tm.assert_series_equal(str_s.str.isdigit(), Series(digit_e))\n        tm.assert_series_equal(str_s.str.isspace(), Series(space_e))\n        tm.assert_series_equal(str_s.str.islower(), Series(lower_e))\n        tm.assert_series_equal(str_s.str.isupper(), Series(upper_e))\n        tm.assert_series_equal(str_s.str.istitle(), Series(title_e))\n\n        assert str_s.str.isalnum().tolist() == [v.isalnum() for v in values]\n        assert str_s.str.isalpha().tolist() == [v.isalpha() for v in values]\n        assert str_s.str.isdigit().tolist() == [v.isdigit() for v in values]\n        assert str_s.str.isspace().tolist() == [v.isspace() for v in values]\n        assert str_s.str.islower().tolist() == [v.islower() for v in values]\n        assert str_s.str.isupper().tolist() == [v.isupper() for v in values]\n        assert str_s.str.istitle().tolist() == [v.istitle() for v in values]",
        "begin_line": 1879,
        "end_line": 1919,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_isnumeric#1921",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_isnumeric(self)",
        "snippet": "    def test_isnumeric(self):\n        # 0x00bc: \u00bc VULGAR FRACTION ONE QUARTER\n        # 0x2605: \u2605 not number\n        # 0x1378: \u1378 ETHIOPIC NUMBER SEVENTY\n        # 0xFF13: \uff13 Em 3\n        values = [\"A\", \"3\", \"\u00bc\", \"\u2605\", \"\u1378\", \"\uff13\", \"four\"]\n        s = Series(values)\n        numeric_e = [False, True, True, False, True, True, False]\n        decimal_e = [False, True, False, False, False, True, False]\n        tm.assert_series_equal(s.str.isnumeric(), Series(numeric_e))\n        tm.assert_series_equal(s.str.isdecimal(), Series(decimal_e))\n\n        unicodes = [\"A\", \"3\", \"\u00bc\", \"\u2605\", \"\u1378\", \"\uff13\", \"four\"]\n        assert s.str.isnumeric().tolist() == [v.isnumeric() for v in unicodes]\n        assert s.str.isdecimal().tolist() == [v.isdecimal() for v in unicodes]\n\n        values = [\"A\", np.nan, \"\u00bc\", \"\u2605\", np.nan, \"\uff13\", \"four\"]\n        s = Series(values)\n        numeric_e = [False, np.nan, True, False, np.nan, True, False]\n        decimal_e = [False, np.nan, False, False, np.nan, True, False]\n        tm.assert_series_equal(s.str.isnumeric(), Series(numeric_e))\n        tm.assert_series_equal(s.str.isdecimal(), Series(decimal_e))",
        "begin_line": 1921,
        "end_line": 1942,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_get_dummies#1944",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_get_dummies(self)",
        "snippet": "    def test_get_dummies(self):\n        s = Series([\"a|b\", \"a|c\", np.nan])\n        result = s.str.get_dummies(\"|\")\n        expected = DataFrame([[1, 1, 0], [1, 0, 1], [0, 0, 0]], columns=list(\"abc\"))\n        tm.assert_frame_equal(result, expected)\n\n        s = Series([\"a;b\", \"a\", 7])\n        result = s.str.get_dummies(\";\")\n        expected = DataFrame([[0, 1, 1], [0, 1, 0], [1, 0, 0]], columns=list(\"7ab\"))\n        tm.assert_frame_equal(result, expected)\n\n        # GH9980, GH8028\n        idx = Index([\"a|b\", \"a|c\", \"b|c\"])\n        result = idx.str.get_dummies(\"|\")\n\n        expected = MultiIndex.from_tuples(\n            [(1, 1, 0), (1, 0, 1), (0, 1, 1)], names=(\"a\", \"b\", \"c\")\n        )\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1944,
        "end_line": 1962,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_get_dummies_with_name_dummy#1964",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_get_dummies_with_name_dummy(self)",
        "snippet": "    def test_get_dummies_with_name_dummy(self):\n        # GH 12180\n        # Dummies named 'name' should work as expected\n        s = Series([\"a\", \"b,name\", \"b\"])\n        result = s.str.get_dummies(\",\")\n        expected = DataFrame(\n            [[1, 0, 0], [0, 1, 1], [0, 1, 0]], columns=[\"a\", \"b\", \"name\"]\n        )\n        tm.assert_frame_equal(result, expected)\n\n        idx = Index([\"a|b\", \"name|c\", \"b|name\"])\n        result = idx.str.get_dummies(\"|\")\n\n        expected = MultiIndex.from_tuples(\n            [(1, 1, 0, 0), (0, 0, 1, 1), (0, 1, 0, 1)], names=(\"a\", \"b\", \"c\", \"name\")\n        )\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1964,
        "end_line": 1980,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_join#1982",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_join(self)",
        "snippet": "    def test_join(self):\n        values = Series([\"a_b_c\", \"c_d_e\", np.nan, \"f_g_h\"])\n        result = values.str.split(\"_\").str.join(\"_\")\n        tm.assert_series_equal(values, result)\n\n        # mixed\n        mixed = Series(\n            [\n                \"a_b\",\n                np.nan,\n                \"asdf_cas_asdf\",\n                True,\n                datetime.today(),\n                \"foo\",\n                None,\n                1,\n                2.0,\n            ]\n        )\n\n        rs = Series(mixed).str.split(\"_\").str.join(\"_\")\n        xp = Series(\n            [\n                \"a_b\",\n                np.nan,\n                \"asdf_cas_asdf\",\n                np.nan,\n                np.nan,\n                \"foo\",\n                np.nan,\n                np.nan,\n                np.nan,\n            ]\n        )\n\n        assert isinstance(rs, Series)\n        tm.assert_almost_equal(rs, xp)",
        "begin_line": 1982,
        "end_line": 2018,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_len#2020",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_len(self)",
        "snippet": "    def test_len(self):\n        values = Series([\"foo\", \"fooo\", \"fooooo\", np.nan, \"fooooooo\"])\n\n        result = values.str.len()\n        exp = values.map(lambda x: len(x) if notna(x) else np.nan)\n        tm.assert_series_equal(result, exp)\n\n        # mixed\n        mixed = Series(\n            [\n                \"a_b\",\n                np.nan,\n                \"asdf_cas_asdf\",\n                True,\n                datetime.today(),\n                \"foo\",\n                None,\n                1,\n                2.0,\n            ]\n        )\n\n        rs = Series(mixed).str.len()\n        xp = Series([3, np.nan, 13, np.nan, np.nan, 3, np.nan, np.nan, np.nan])\n\n        assert isinstance(rs, Series)\n        tm.assert_almost_equal(rs, xp)",
        "begin_line": 2020,
        "end_line": 2046,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_findall#2048",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_findall(self)",
        "snippet": "    def test_findall(self):\n        values = Series([\"fooBAD__barBAD\", np.nan, \"foo\", \"BAD\"])\n\n        result = values.str.findall(\"BAD[_]*\")\n        exp = Series([[\"BAD__\", \"BAD\"], np.nan, [], [\"BAD\"]])\n        tm.assert_almost_equal(result, exp)\n\n        # mixed\n        mixed = Series(\n            [\n                \"fooBAD__barBAD\",\n                np.nan,\n                \"foo\",\n                True,\n                datetime.today(),\n                \"BAD\",\n                None,\n                1,\n                2.0,\n            ]\n        )\n\n        rs = Series(mixed).str.findall(\"BAD[_]*\")\n        xp = Series(\n            [\n                [\"BAD__\", \"BAD\"],\n                np.nan,\n                [],\n                np.nan,\n                np.nan,\n                [\"BAD\"],\n                np.nan,\n                np.nan,\n                np.nan,\n            ]\n        )\n\n        assert isinstance(rs, Series)\n        tm.assert_almost_equal(rs, xp)",
        "begin_line": 2048,
        "end_line": 2086,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_find#2088",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_find(self)",
        "snippet": "    def test_find(self):\n        values = Series([\"ABCDEFG\", \"BCDEFEF\", \"DEFGHIJEF\", \"EFGHEF\", \"XXXX\"])\n        result = values.str.find(\"EF\")\n        tm.assert_series_equal(result, Series([4, 3, 1, 0, -1]))\n        expected = np.array([v.find(\"EF\") for v in values.values], dtype=np.int64)\n        tm.assert_numpy_array_equal(result.values, expected)\n\n        result = values.str.rfind(\"EF\")\n        tm.assert_series_equal(result, Series([4, 5, 7, 4, -1]))\n        expected = np.array([v.rfind(\"EF\") for v in values.values], dtype=np.int64)\n        tm.assert_numpy_array_equal(result.values, expected)\n\n        result = values.str.find(\"EF\", 3)\n        tm.assert_series_equal(result, Series([4, 3, 7, 4, -1]))\n        expected = np.array([v.find(\"EF\", 3) for v in values.values], dtype=np.int64)\n        tm.assert_numpy_array_equal(result.values, expected)\n\n        result = values.str.rfind(\"EF\", 3)\n        tm.assert_series_equal(result, Series([4, 5, 7, 4, -1]))\n        expected = np.array([v.rfind(\"EF\", 3) for v in values.values], dtype=np.int64)\n        tm.assert_numpy_array_equal(result.values, expected)\n\n        result = values.str.find(\"EF\", 3, 6)\n        tm.assert_series_equal(result, Series([4, 3, -1, 4, -1]))\n        expected = np.array([v.find(\"EF\", 3, 6) for v in values.values], dtype=np.int64)\n        tm.assert_numpy_array_equal(result.values, expected)\n\n        result = values.str.rfind(\"EF\", 3, 6)\n        tm.assert_series_equal(result, Series([4, 3, -1, 4, -1]))\n        expected = np.array(\n            [v.rfind(\"EF\", 3, 6) for v in values.values], dtype=np.int64\n        )\n        tm.assert_numpy_array_equal(result.values, expected)\n\n        with pytest.raises(TypeError, match=\"expected a string object, not int\"):\n            result = values.str.find(0)\n\n        with pytest.raises(TypeError, match=\"expected a string object, not int\"):\n            result = values.str.rfind(0)",
        "begin_line": 2088,
        "end_line": 2126,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_find_nan#2128",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_find_nan(self)",
        "snippet": "    def test_find_nan(self):\n        values = Series([\"ABCDEFG\", np.nan, \"DEFGHIJEF\", np.nan, \"XXXX\"])\n        result = values.str.find(\"EF\")\n        tm.assert_series_equal(result, Series([4, np.nan, 1, np.nan, -1]))\n\n        result = values.str.rfind(\"EF\")\n        tm.assert_series_equal(result, Series([4, np.nan, 7, np.nan, -1]))\n\n        result = values.str.find(\"EF\", 3)\n        tm.assert_series_equal(result, Series([4, np.nan, 7, np.nan, -1]))\n\n        result = values.str.rfind(\"EF\", 3)\n        tm.assert_series_equal(result, Series([4, np.nan, 7, np.nan, -1]))\n\n        result = values.str.find(\"EF\", 3, 6)\n        tm.assert_series_equal(result, Series([4, np.nan, -1, np.nan, -1]))\n\n        result = values.str.rfind(\"EF\", 3, 6)\n        tm.assert_series_equal(result, Series([4, np.nan, -1, np.nan, -1]))",
        "begin_line": 2128,
        "end_line": 2146,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_index#2148",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_index(self)",
        "snippet": "    def test_index(self):\n        def _check(result, expected):\n            if isinstance(result, Series):\n                tm.assert_series_equal(result, expected)\n            else:\n                tm.assert_index_equal(result, expected)\n\n        for klass in [Series, Index]:\n            s = klass([\"ABCDEFG\", \"BCDEFEF\", \"DEFGHIJEF\", \"EFGHEF\"])\n\n            result = s.str.index(\"EF\")\n            _check(result, klass([4, 3, 1, 0]))\n            expected = np.array([v.index(\"EF\") for v in s.values], dtype=np.int64)\n            tm.assert_numpy_array_equal(result.values, expected)\n\n            result = s.str.rindex(\"EF\")\n            _check(result, klass([4, 5, 7, 4]))\n            expected = np.array([v.rindex(\"EF\") for v in s.values], dtype=np.int64)\n            tm.assert_numpy_array_equal(result.values, expected)\n\n            result = s.str.index(\"EF\", 3)\n            _check(result, klass([4, 3, 7, 4]))\n            expected = np.array([v.index(\"EF\", 3) for v in s.values], dtype=np.int64)\n            tm.assert_numpy_array_equal(result.values, expected)\n\n            result = s.str.rindex(\"EF\", 3)\n            _check(result, klass([4, 5, 7, 4]))\n            expected = np.array([v.rindex(\"EF\", 3) for v in s.values], dtype=np.int64)\n            tm.assert_numpy_array_equal(result.values, expected)\n\n            result = s.str.index(\"E\", 4, 8)\n            _check(result, klass([4, 5, 7, 4]))\n            expected = np.array([v.index(\"E\", 4, 8) for v in s.values], dtype=np.int64)\n            tm.assert_numpy_array_equal(result.values, expected)\n\n            result = s.str.rindex(\"E\", 0, 5)\n            _check(result, klass([4, 3, 1, 4]))\n            expected = np.array([v.rindex(\"E\", 0, 5) for v in s.values], dtype=np.int64)\n            tm.assert_numpy_array_equal(result.values, expected)\n\n            with pytest.raises(ValueError, match=\"substring not found\"):\n                result = s.str.index(\"DE\")\n\n            msg = \"expected a string object, not int\"\n            with pytest.raises(TypeError, match=msg):\n                result = s.str.index(0)\n\n        # test with nan\n        s = Series([\"abcb\", \"ab\", \"bcbe\", np.nan])\n        result = s.str.index(\"b\")\n        tm.assert_series_equal(result, Series([1, 1, 0, np.nan]))\n        result = s.str.rindex(\"b\")\n        tm.assert_series_equal(result, Series([3, 1, 2, np.nan]))",
        "begin_line": 2148,
        "end_line": 2200,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods._check#2149",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods._check(result, expected)",
        "snippet": "        def _check(result, expected):\n            if isinstance(result, Series):\n                tm.assert_series_equal(result, expected)\n            else:\n                tm.assert_index_equal(result, expected)",
        "begin_line": 2149,
        "end_line": 2153,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_pad#2202",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_pad(self)",
        "snippet": "    def test_pad(self):\n        values = Series([\"a\", \"b\", np.nan, \"c\", np.nan, \"eeeeee\"])\n\n        result = values.str.pad(5, side=\"left\")\n        exp = Series([\"    a\", \"    b\", np.nan, \"    c\", np.nan, \"eeeeee\"])\n        tm.assert_almost_equal(result, exp)\n\n        result = values.str.pad(5, side=\"right\")\n        exp = Series([\"a    \", \"b    \", np.nan, \"c    \", np.nan, \"eeeeee\"])\n        tm.assert_almost_equal(result, exp)\n\n        result = values.str.pad(5, side=\"both\")\n        exp = Series([\"  a  \", \"  b  \", np.nan, \"  c  \", np.nan, \"eeeeee\"])\n        tm.assert_almost_equal(result, exp)\n\n        # mixed\n        mixed = Series([\"a\", np.nan, \"b\", True, datetime.today(), \"ee\", None, 1, 2.0])\n\n        rs = Series(mixed).str.pad(5, side=\"left\")\n        xp = Series(\n            [\"    a\", np.nan, \"    b\", np.nan, np.nan, \"   ee\", np.nan, np.nan, np.nan]\n        )\n\n        assert isinstance(rs, Series)\n        tm.assert_almost_equal(rs, xp)\n\n        mixed = Series([\"a\", np.nan, \"b\", True, datetime.today(), \"ee\", None, 1, 2.0])\n\n        rs = Series(mixed).str.pad(5, side=\"right\")\n        xp = Series(\n            [\"a    \", np.nan, \"b    \", np.nan, np.nan, \"ee   \", np.nan, np.nan, np.nan]\n        )\n\n        assert isinstance(rs, Series)\n        tm.assert_almost_equal(rs, xp)\n\n        mixed = Series([\"a\", np.nan, \"b\", True, datetime.today(), \"ee\", None, 1, 2.0])\n\n        rs = Series(mixed).str.pad(5, side=\"both\")\n        xp = Series(\n            [\"  a  \", np.nan, \"  b  \", np.nan, np.nan, \"  ee \", np.nan, np.nan, np.nan]\n        )\n\n        assert isinstance(rs, Series)\n        tm.assert_almost_equal(rs, xp)",
        "begin_line": 2202,
        "end_line": 2246,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_pad_fillchar#2248",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_pad_fillchar(self)",
        "snippet": "    def test_pad_fillchar(self):\n\n        values = Series([\"a\", \"b\", np.nan, \"c\", np.nan, \"eeeeee\"])\n\n        result = values.str.pad(5, side=\"left\", fillchar=\"X\")\n        exp = Series([\"XXXXa\", \"XXXXb\", np.nan, \"XXXXc\", np.nan, \"eeeeee\"])\n        tm.assert_almost_equal(result, exp)\n\n        result = values.str.pad(5, side=\"right\", fillchar=\"X\")\n        exp = Series([\"aXXXX\", \"bXXXX\", np.nan, \"cXXXX\", np.nan, \"eeeeee\"])\n        tm.assert_almost_equal(result, exp)\n\n        result = values.str.pad(5, side=\"both\", fillchar=\"X\")\n        exp = Series([\"XXaXX\", \"XXbXX\", np.nan, \"XXcXX\", np.nan, \"eeeeee\"])\n        tm.assert_almost_equal(result, exp)\n\n        msg = \"fillchar must be a character, not str\"\n        with pytest.raises(TypeError, match=msg):\n            result = values.str.pad(5, fillchar=\"XY\")\n\n        msg = \"fillchar must be a character, not int\"\n        with pytest.raises(TypeError, match=msg):\n            result = values.str.pad(5, fillchar=5)",
        "begin_line": 2248,
        "end_line": 2270,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_pad_width#2273",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_pad_width(self, f)",
        "snippet": "    def test_pad_width(self, f):\n        # see gh-13598\n        s = Series([\"1\", \"22\", \"a\", \"bb\"])\n        msg = \"width must be of integer type, not*\"\n\n        with pytest.raises(TypeError, match=msg):\n            getattr(s.str, f)(\"f\")",
        "begin_line": 2273,
        "end_line": 2279,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_translate#2281",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_translate(self)",
        "snippet": "    def test_translate(self):\n        def _check(result, expected):\n            if isinstance(result, Series):\n                tm.assert_series_equal(result, expected)\n            else:\n                tm.assert_index_equal(result, expected)\n\n        for klass in [Series, Index]:\n            s = klass([\"abcdefg\", \"abcc\", \"cdddfg\", \"cdefggg\"])\n            table = str.maketrans(\"abc\", \"cde\")\n            result = s.str.translate(table)\n            expected = klass([\"cdedefg\", \"cdee\", \"edddfg\", \"edefggg\"])\n            _check(result, expected)\n\n        # Series with non-string values\n        s = Series([\"a\", \"b\", \"c\", 1.2])\n        expected = Series([\"c\", \"d\", \"e\", np.nan])\n        result = s.str.translate(table)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 2281,
        "end_line": 2299,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods._check#2282",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods._check(result, expected)",
        "snippet": "        def _check(result, expected):\n            if isinstance(result, Series):\n                tm.assert_series_equal(result, expected)\n            else:\n                tm.assert_index_equal(result, expected)",
        "begin_line": 2282,
        "end_line": 2286,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_center_ljust_rjust#2301",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_center_ljust_rjust(self)",
        "snippet": "    def test_center_ljust_rjust(self):\n        values = Series([\"a\", \"b\", np.nan, \"c\", np.nan, \"eeeeee\"])\n\n        result = values.str.center(5)\n        exp = Series([\"  a  \", \"  b  \", np.nan, \"  c  \", np.nan, \"eeeeee\"])\n        tm.assert_almost_equal(result, exp)\n\n        result = values.str.ljust(5)\n        exp = Series([\"a    \", \"b    \", np.nan, \"c    \", np.nan, \"eeeeee\"])\n        tm.assert_almost_equal(result, exp)\n\n        result = values.str.rjust(5)\n        exp = Series([\"    a\", \"    b\", np.nan, \"    c\", np.nan, \"eeeeee\"])\n        tm.assert_almost_equal(result, exp)\n\n        # mixed\n        mixed = Series(\n            [\"a\", np.nan, \"b\", True, datetime.today(), \"c\", \"eee\", None, 1, 2.0]\n        )\n\n        rs = Series(mixed).str.center(5)\n        xp = Series(\n            [\n                \"  a  \",\n                np.nan,\n                \"  b  \",\n                np.nan,\n                np.nan,\n                \"  c  \",\n                \" eee \",\n                np.nan,\n                np.nan,\n                np.nan,\n            ]\n        )\n        assert isinstance(rs, Series)\n        tm.assert_almost_equal(rs, xp)\n\n        rs = Series(mixed).str.ljust(5)\n        xp = Series(\n            [\n                \"a    \",\n                np.nan,\n                \"b    \",\n                np.nan,\n                np.nan,\n                \"c    \",\n                \"eee  \",\n                np.nan,\n                np.nan,\n                np.nan,\n            ]\n        )\n        assert isinstance(rs, Series)\n        tm.assert_almost_equal(rs, xp)\n\n        rs = Series(mixed).str.rjust(5)\n        xp = Series(\n            [\n                \"    a\",\n                np.nan,\n                \"    b\",\n                np.nan,\n                np.nan,\n                \"    c\",\n                \"  eee\",\n                np.nan,\n                np.nan,\n                np.nan,\n            ]\n        )\n        assert isinstance(rs, Series)\n        tm.assert_almost_equal(rs, xp)",
        "begin_line": 2301,
        "end_line": 2373,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_center_ljust_rjust_fillchar#2375",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_center_ljust_rjust_fillchar(self)",
        "snippet": "    def test_center_ljust_rjust_fillchar(self):\n        values = Series([\"a\", \"bb\", \"cccc\", \"ddddd\", \"eeeeee\"])\n\n        result = values.str.center(5, fillchar=\"X\")\n        expected = Series([\"XXaXX\", \"XXbbX\", \"Xcccc\", \"ddddd\", \"eeeeee\"])\n        tm.assert_series_equal(result, expected)\n        expected = np.array([v.center(5, \"X\") for v in values.values], dtype=np.object_)\n        tm.assert_numpy_array_equal(result.values, expected)\n\n        result = values.str.ljust(5, fillchar=\"X\")\n        expected = Series([\"aXXXX\", \"bbXXX\", \"ccccX\", \"ddddd\", \"eeeeee\"])\n        tm.assert_series_equal(result, expected)\n        expected = np.array([v.ljust(5, \"X\") for v in values.values], dtype=np.object_)\n        tm.assert_numpy_array_equal(result.values, expected)\n\n        result = values.str.rjust(5, fillchar=\"X\")\n        expected = Series([\"XXXXa\", \"XXXbb\", \"Xcccc\", \"ddddd\", \"eeeeee\"])\n        tm.assert_series_equal(result, expected)\n        expected = np.array([v.rjust(5, \"X\") for v in values.values], dtype=np.object_)\n        tm.assert_numpy_array_equal(result.values, expected)\n\n        # If fillchar is not a charatter, normal str raises TypeError\n        # 'aaa'.ljust(5, 'XY')\n        # TypeError: must be char, not str\n        template = \"fillchar must be a character, not {dtype}\"\n\n        with pytest.raises(TypeError, match=template.format(dtype=\"str\")):\n            values.str.center(5, fillchar=\"XY\")\n\n        with pytest.raises(TypeError, match=template.format(dtype=\"str\")):\n            values.str.ljust(5, fillchar=\"XY\")\n\n        with pytest.raises(TypeError, match=template.format(dtype=\"str\")):\n            values.str.rjust(5, fillchar=\"XY\")\n\n        with pytest.raises(TypeError, match=template.format(dtype=\"int\")):\n            values.str.center(5, fillchar=1)\n\n        with pytest.raises(TypeError, match=template.format(dtype=\"int\")):\n            values.str.ljust(5, fillchar=1)\n\n        with pytest.raises(TypeError, match=template.format(dtype=\"int\")):\n            values.str.rjust(5, fillchar=1)",
        "begin_line": 2375,
        "end_line": 2417,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_zfill#2419",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_zfill(self)",
        "snippet": "    def test_zfill(self):\n        values = Series([\"1\", \"22\", \"aaa\", \"333\", \"45678\"])\n\n        result = values.str.zfill(5)\n        expected = Series([\"00001\", \"00022\", \"00aaa\", \"00333\", \"45678\"])\n        tm.assert_series_equal(result, expected)\n        expected = np.array([v.zfill(5) for v in values.values], dtype=np.object_)\n        tm.assert_numpy_array_equal(result.values, expected)\n\n        result = values.str.zfill(3)\n        expected = Series([\"001\", \"022\", \"aaa\", \"333\", \"45678\"])\n        tm.assert_series_equal(result, expected)\n        expected = np.array([v.zfill(3) for v in values.values], dtype=np.object_)\n        tm.assert_numpy_array_equal(result.values, expected)\n\n        values = Series([\"1\", np.nan, \"aaa\", np.nan, \"45678\"])\n        result = values.str.zfill(5)\n        expected = Series([\"00001\", np.nan, \"00aaa\", np.nan, \"45678\"])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 2419,
        "end_line": 2437,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_split#2439",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_split(self)",
        "snippet": "    def test_split(self):\n        values = Series([\"a_b_c\", \"c_d_e\", np.nan, \"f_g_h\"])\n\n        result = values.str.split(\"_\")\n        exp = Series([[\"a\", \"b\", \"c\"], [\"c\", \"d\", \"e\"], np.nan, [\"f\", \"g\", \"h\"]])\n        tm.assert_series_equal(result, exp)\n\n        # more than one char\n        values = Series([\"a__b__c\", \"c__d__e\", np.nan, \"f__g__h\"])\n        result = values.str.split(\"__\")\n        tm.assert_series_equal(result, exp)\n\n        result = values.str.split(\"__\", expand=False)\n        tm.assert_series_equal(result, exp)\n\n        # mixed\n        mixed = Series([\"a_b_c\", np.nan, \"d_e_f\", True, datetime.today(), None, 1, 2.0])\n        result = mixed.str.split(\"_\")\n        exp = Series(\n            [\n                [\"a\", \"b\", \"c\"],\n                np.nan,\n                [\"d\", \"e\", \"f\"],\n                np.nan,\n                np.nan,\n                np.nan,\n                np.nan,\n                np.nan,\n            ]\n        )\n        assert isinstance(result, Series)\n        tm.assert_almost_equal(result, exp)\n\n        result = mixed.str.split(\"_\", expand=False)\n        assert isinstance(result, Series)\n        tm.assert_almost_equal(result, exp)\n\n        # regex split\n        values = Series([\"a,b_c\", \"c_d,e\", np.nan, \"f,g,h\"])\n        result = values.str.split(\"[,_]\")\n        exp = Series([[\"a\", \"b\", \"c\"], [\"c\", \"d\", \"e\"], np.nan, [\"f\", \"g\", \"h\"]])\n        tm.assert_series_equal(result, exp)",
        "begin_line": 2439,
        "end_line": 2480,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_rsplit#2482",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_rsplit(self)",
        "snippet": "    def test_rsplit(self):\n        values = Series([\"a_b_c\", \"c_d_e\", np.nan, \"f_g_h\"])\n        result = values.str.rsplit(\"_\")\n        exp = Series([[\"a\", \"b\", \"c\"], [\"c\", \"d\", \"e\"], np.nan, [\"f\", \"g\", \"h\"]])\n        tm.assert_series_equal(result, exp)\n\n        # more than one char\n        values = Series([\"a__b__c\", \"c__d__e\", np.nan, \"f__g__h\"])\n        result = values.str.rsplit(\"__\")\n        tm.assert_series_equal(result, exp)\n\n        result = values.str.rsplit(\"__\", expand=False)\n        tm.assert_series_equal(result, exp)\n\n        # mixed\n        mixed = Series([\"a_b_c\", np.nan, \"d_e_f\", True, datetime.today(), None, 1, 2.0])\n        result = mixed.str.rsplit(\"_\")\n        exp = Series(\n            [\n                [\"a\", \"b\", \"c\"],\n                np.nan,\n                [\"d\", \"e\", \"f\"],\n                np.nan,\n                np.nan,\n                np.nan,\n                np.nan,\n                np.nan,\n            ]\n        )\n        assert isinstance(result, Series)\n        tm.assert_almost_equal(result, exp)\n\n        result = mixed.str.rsplit(\"_\", expand=False)\n        assert isinstance(result, Series)\n        tm.assert_almost_equal(result, exp)\n\n        # regex split is not supported by rsplit\n        values = Series([\"a,b_c\", \"c_d,e\", np.nan, \"f,g,h\"])\n        result = values.str.rsplit(\"[,_]\")\n        exp = Series([[\"a,b_c\"], [\"c_d,e\"], np.nan, [\"f,g,h\"]])\n        tm.assert_series_equal(result, exp)\n\n        # setting max number of splits, make sure it's from reverse\n        values = Series([\"a_b_c\", \"c_d_e\", np.nan, \"f_g_h\"])\n        result = values.str.rsplit(\"_\", n=1)\n        exp = Series([[\"a_b\", \"c\"], [\"c_d\", \"e\"], np.nan, [\"f_g\", \"h\"]])\n        tm.assert_series_equal(result, exp)",
        "begin_line": 2482,
        "end_line": 2528,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_split_blank_string#2530",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_split_blank_string(self)",
        "snippet": "    def test_split_blank_string(self):\n        # expand blank split GH 20067\n        values = Series([\"\"], name=\"test\")\n        result = values.str.split(expand=True)\n        exp = DataFrame([[]])  # NOTE: this is NOT an empty DataFrame\n        tm.assert_frame_equal(result, exp)\n\n        values = Series([\"a b c\", \"a b\", \"\", \" \"], name=\"test\")\n        result = values.str.split(expand=True)\n        exp = DataFrame(\n            [\n                [\"a\", \"b\", \"c\"],\n                [\"a\", \"b\", np.nan],\n                [np.nan, np.nan, np.nan],\n                [np.nan, np.nan, np.nan],\n            ]\n        )\n        tm.assert_frame_equal(result, exp)",
        "begin_line": 2530,
        "end_line": 2547,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_split_noargs#2549",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_split_noargs(self)",
        "snippet": "    def test_split_noargs(self):\n        # #1859\n        s = Series([\"Wes McKinney\", \"Travis  Oliphant\"])\n        result = s.str.split()\n        expected = [\"Travis\", \"Oliphant\"]\n        assert result[1] == expected\n        result = s.str.rsplit()\n        assert result[1] == expected",
        "begin_line": 2549,
        "end_line": 2556,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_split_maxsplit#2558",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_split_maxsplit(self)",
        "snippet": "    def test_split_maxsplit(self):\n        # re.split 0, str.split -1\n        s = Series([\"bd asdf jfg\", \"kjasdflqw asdfnfk\"])\n\n        result = s.str.split(n=-1)\n        xp = s.str.split()\n        tm.assert_series_equal(result, xp)\n\n        result = s.str.split(n=0)\n        tm.assert_series_equal(result, xp)\n\n        xp = s.str.split(\"asdf\")\n        result = s.str.split(\"asdf\", n=0)\n        tm.assert_series_equal(result, xp)\n\n        result = s.str.split(\"asdf\", n=-1)\n        tm.assert_series_equal(result, xp)",
        "begin_line": 2558,
        "end_line": 2574,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_split_no_pat_with_nonzero_n#2576",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_split_no_pat_with_nonzero_n(self)",
        "snippet": "    def test_split_no_pat_with_nonzero_n(self):\n        s = Series([\"split once\", \"split once too!\"])\n        result = s.str.split(n=1)\n        expected = Series({0: [\"split\", \"once\"], 1: [\"split\", \"once too!\"]})\n        tm.assert_series_equal(expected, result, check_index_type=False)",
        "begin_line": 2576,
        "end_line": 2580,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_split_to_dataframe#2582",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_split_to_dataframe(self)",
        "snippet": "    def test_split_to_dataframe(self):\n        s = Series([\"nosplit\", \"alsonosplit\"])\n        result = s.str.split(\"_\", expand=True)\n        exp = DataFrame({0: Series([\"nosplit\", \"alsonosplit\"])})\n        tm.assert_frame_equal(result, exp)\n\n        s = Series([\"some_equal_splits\", \"with_no_nans\"])\n        result = s.str.split(\"_\", expand=True)\n        exp = DataFrame(\n            {0: [\"some\", \"with\"], 1: [\"equal\", \"no\"], 2: [\"splits\", \"nans\"]}\n        )\n        tm.assert_frame_equal(result, exp)\n\n        s = Series([\"some_unequal_splits\", \"one_of_these_things_is_not\"])\n        result = s.str.split(\"_\", expand=True)\n        exp = DataFrame(\n            {\n                0: [\"some\", \"one\"],\n                1: [\"unequal\", \"of\"],\n                2: [\"splits\", \"these\"],\n                3: [np.nan, \"things\"],\n                4: [np.nan, \"is\"],\n                5: [np.nan, \"not\"],\n            }\n        )\n        tm.assert_frame_equal(result, exp)\n\n        s = Series([\"some_splits\", \"with_index\"], index=[\"preserve\", \"me\"])\n        result = s.str.split(\"_\", expand=True)\n        exp = DataFrame(\n            {0: [\"some\", \"with\"], 1: [\"splits\", \"index\"]}, index=[\"preserve\", \"me\"]\n        )\n        tm.assert_frame_equal(result, exp)\n\n        with pytest.raises(ValueError, match=\"expand must be\"):\n            s.str.split(\"_\", expand=\"not_a_boolean\")",
        "begin_line": 2582,
        "end_line": 2617,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_split_to_multiindex_expand#2619",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_split_to_multiindex_expand(self)",
        "snippet": "    def test_split_to_multiindex_expand(self):\n        # https://github.com/pandas-dev/pandas/issues/23677\n\n        idx = Index([\"nosplit\", \"alsonosplit\", np.nan])\n        result = idx.str.split(\"_\", expand=True)\n        exp = idx\n        tm.assert_index_equal(result, exp)\n        assert result.nlevels == 1\n\n        idx = Index([\"some_equal_splits\", \"with_no_nans\", np.nan, None])\n        result = idx.str.split(\"_\", expand=True)\n        exp = MultiIndex.from_tuples(\n            [\n                (\"some\", \"equal\", \"splits\"),\n                (\"with\", \"no\", \"nans\"),\n                [np.nan, np.nan, np.nan],\n                [None, None, None],\n            ]\n        )\n        tm.assert_index_equal(result, exp)\n        assert result.nlevels == 3\n\n        idx = Index([\"some_unequal_splits\", \"one_of_these_things_is_not\", np.nan, None])\n        result = idx.str.split(\"_\", expand=True)\n        exp = MultiIndex.from_tuples(\n            [\n                (\"some\", \"unequal\", \"splits\", np.nan, np.nan, np.nan),\n                (\"one\", \"of\", \"these\", \"things\", \"is\", \"not\"),\n                (np.nan, np.nan, np.nan, np.nan, np.nan, np.nan),\n                (None, None, None, None, None, None),\n            ]\n        )\n        tm.assert_index_equal(result, exp)\n        assert result.nlevels == 6\n\n        with pytest.raises(ValueError, match=\"expand must be\"):\n            idx.str.split(\"_\", expand=\"not_a_boolean\")",
        "begin_line": 2619,
        "end_line": 2655,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_rsplit_to_dataframe_expand#2657",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_rsplit_to_dataframe_expand(self)",
        "snippet": "    def test_rsplit_to_dataframe_expand(self):\n        s = Series([\"nosplit\", \"alsonosplit\"])\n        result = s.str.rsplit(\"_\", expand=True)\n        exp = DataFrame({0: Series([\"nosplit\", \"alsonosplit\"])})\n        tm.assert_frame_equal(result, exp)\n\n        s = Series([\"some_equal_splits\", \"with_no_nans\"])\n        result = s.str.rsplit(\"_\", expand=True)\n        exp = DataFrame(\n            {0: [\"some\", \"with\"], 1: [\"equal\", \"no\"], 2: [\"splits\", \"nans\"]}\n        )\n        tm.assert_frame_equal(result, exp)\n\n        result = s.str.rsplit(\"_\", expand=True, n=2)\n        exp = DataFrame(\n            {0: [\"some\", \"with\"], 1: [\"equal\", \"no\"], 2: [\"splits\", \"nans\"]}\n        )\n        tm.assert_frame_equal(result, exp)\n\n        result = s.str.rsplit(\"_\", expand=True, n=1)\n        exp = DataFrame({0: [\"some_equal\", \"with_no\"], 1: [\"splits\", \"nans\"]})\n        tm.assert_frame_equal(result, exp)\n\n        s = Series([\"some_splits\", \"with_index\"], index=[\"preserve\", \"me\"])\n        result = s.str.rsplit(\"_\", expand=True)\n        exp = DataFrame(\n            {0: [\"some\", \"with\"], 1: [\"splits\", \"index\"]}, index=[\"preserve\", \"me\"]\n        )\n        tm.assert_frame_equal(result, exp)",
        "begin_line": 2657,
        "end_line": 2685,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_rsplit_to_multiindex_expand#2687",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_rsplit_to_multiindex_expand(self)",
        "snippet": "    def test_rsplit_to_multiindex_expand(self):\n        idx = Index([\"nosplit\", \"alsonosplit\"])\n        result = idx.str.rsplit(\"_\", expand=True)\n        exp = idx\n        tm.assert_index_equal(result, exp)\n        assert result.nlevels == 1\n\n        idx = Index([\"some_equal_splits\", \"with_no_nans\"])\n        result = idx.str.rsplit(\"_\", expand=True)\n        exp = MultiIndex.from_tuples(\n            [(\"some\", \"equal\", \"splits\"), (\"with\", \"no\", \"nans\")]\n        )\n        tm.assert_index_equal(result, exp)\n        assert result.nlevels == 3\n\n        idx = Index([\"some_equal_splits\", \"with_no_nans\"])\n        result = idx.str.rsplit(\"_\", expand=True, n=1)\n        exp = MultiIndex.from_tuples([(\"some_equal\", \"splits\"), (\"with_no\", \"nans\")])\n        tm.assert_index_equal(result, exp)\n        assert result.nlevels == 2",
        "begin_line": 2687,
        "end_line": 2706,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_split_nan_expand#2708",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_split_nan_expand(self)",
        "snippet": "    def test_split_nan_expand(self):\n        # gh-18450\n        s = Series([\"foo,bar,baz\", np.nan])\n        result = s.str.split(\",\", expand=True)\n        exp = DataFrame([[\"foo\", \"bar\", \"baz\"], [np.nan, np.nan, np.nan]])\n        tm.assert_frame_equal(result, exp)\n\n        # check that these are actually np.nan and not None\n        # TODO see GH 18463\n        # tm.assert_frame_equal does not differentiate\n        assert all(np.isnan(x) for x in result.iloc[1])",
        "begin_line": 2708,
        "end_line": 2718,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_split_with_name#2720",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_split_with_name(self)",
        "snippet": "    def test_split_with_name(self):\n        # GH 12617\n\n        # should preserve name\n        s = Series([\"a,b\", \"c,d\"], name=\"xxx\")\n        res = s.str.split(\",\")\n        exp = Series([[\"a\", \"b\"], [\"c\", \"d\"]], name=\"xxx\")\n        tm.assert_series_equal(res, exp)\n\n        res = s.str.split(\",\", expand=True)\n        exp = DataFrame([[\"a\", \"b\"], [\"c\", \"d\"]])\n        tm.assert_frame_equal(res, exp)\n\n        idx = Index([\"a,b\", \"c,d\"], name=\"xxx\")\n        res = idx.str.split(\",\")\n        exp = Index([[\"a\", \"b\"], [\"c\", \"d\"]], name=\"xxx\")\n        assert res.nlevels == 1\n        tm.assert_index_equal(res, exp)\n\n        res = idx.str.split(\",\", expand=True)\n        exp = MultiIndex.from_tuples([(\"a\", \"b\"), (\"c\", \"d\")])\n        assert res.nlevels == 2\n        tm.assert_index_equal(res, exp)",
        "begin_line": 2720,
        "end_line": 2742,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_partition_series#2744",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_partition_series(self)",
        "snippet": "    def test_partition_series(self):\n        # https://github.com/pandas-dev/pandas/issues/23558\n\n        values = Series([\"a_b_c\", \"c_d_e\", np.nan, \"f_g_h\", None])\n\n        result = values.str.partition(\"_\", expand=False)\n        exp = Series(\n            [(\"a\", \"_\", \"b_c\"), (\"c\", \"_\", \"d_e\"), np.nan, (\"f\", \"_\", \"g_h\"), None]\n        )\n        tm.assert_series_equal(result, exp)\n\n        result = values.str.rpartition(\"_\", expand=False)\n        exp = Series(\n            [(\"a_b\", \"_\", \"c\"), (\"c_d\", \"_\", \"e\"), np.nan, (\"f_g\", \"_\", \"h\"), None]\n        )\n        tm.assert_series_equal(result, exp)\n\n        # more than one char\n        values = Series([\"a__b__c\", \"c__d__e\", np.nan, \"f__g__h\", None])\n        result = values.str.partition(\"__\", expand=False)\n        exp = Series(\n            [\n                (\"a\", \"__\", \"b__c\"),\n                (\"c\", \"__\", \"d__e\"),\n                np.nan,\n                (\"f\", \"__\", \"g__h\"),\n                None,\n            ]\n        )\n        tm.assert_series_equal(result, exp)\n\n        result = values.str.rpartition(\"__\", expand=False)\n        exp = Series(\n            [\n                (\"a__b\", \"__\", \"c\"),\n                (\"c__d\", \"__\", \"e\"),\n                np.nan,\n                (\"f__g\", \"__\", \"h\"),\n                None,\n            ]\n        )\n        tm.assert_series_equal(result, exp)\n\n        # None\n        values = Series([\"a b c\", \"c d e\", np.nan, \"f g h\", None])\n        result = values.str.partition(expand=False)\n        exp = Series(\n            [(\"a\", \" \", \"b c\"), (\"c\", \" \", \"d e\"), np.nan, (\"f\", \" \", \"g h\"), None]\n        )\n        tm.assert_series_equal(result, exp)\n\n        result = values.str.rpartition(expand=False)\n        exp = Series(\n            [(\"a b\", \" \", \"c\"), (\"c d\", \" \", \"e\"), np.nan, (\"f g\", \" \", \"h\"), None]\n        )\n        tm.assert_series_equal(result, exp)\n\n        # Not split\n        values = Series([\"abc\", \"cde\", np.nan, \"fgh\", None])\n        result = values.str.partition(\"_\", expand=False)\n        exp = Series([(\"abc\", \"\", \"\"), (\"cde\", \"\", \"\"), np.nan, (\"fgh\", \"\", \"\"), None])\n        tm.assert_series_equal(result, exp)\n\n        result = values.str.rpartition(\"_\", expand=False)\n        exp = Series([(\"\", \"\", \"abc\"), (\"\", \"\", \"cde\"), np.nan, (\"\", \"\", \"fgh\"), None])\n        tm.assert_series_equal(result, exp)\n\n        # unicode\n        values = Series([\"a_b_c\", \"c_d_e\", np.nan, \"f_g_h\"])\n\n        result = values.str.partition(\"_\", expand=False)\n        exp = Series([(\"a\", \"_\", \"b_c\"), (\"c\", \"_\", \"d_e\"), np.nan, (\"f\", \"_\", \"g_h\")])\n        tm.assert_series_equal(result, exp)\n\n        result = values.str.rpartition(\"_\", expand=False)\n        exp = Series([(\"a_b\", \"_\", \"c\"), (\"c_d\", \"_\", \"e\"), np.nan, (\"f_g\", \"_\", \"h\")])\n        tm.assert_series_equal(result, exp)\n\n        # compare to standard lib\n        values = Series([\"A_B_C\", \"B_C_D\", \"E_F_G\", \"EFGHEF\"])\n        result = values.str.partition(\"_\", expand=False).tolist()\n        assert result == [v.partition(\"_\") for v in values]\n        result = values.str.rpartition(\"_\", expand=False).tolist()\n        assert result == [v.rpartition(\"_\") for v in values]",
        "begin_line": 2744,
        "end_line": 2827,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_partition_index#2829",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_partition_index(self)",
        "snippet": "    def test_partition_index(self):\n        # https://github.com/pandas-dev/pandas/issues/23558\n\n        values = Index([\"a_b_c\", \"c_d_e\", \"f_g_h\", np.nan, None])\n\n        result = values.str.partition(\"_\", expand=False)\n        exp = Index(\n            np.array(\n                [(\"a\", \"_\", \"b_c\"), (\"c\", \"_\", \"d_e\"), (\"f\", \"_\", \"g_h\"), np.nan, None]\n            )\n        )\n        tm.assert_index_equal(result, exp)\n        assert result.nlevels == 1\n\n        result = values.str.rpartition(\"_\", expand=False)\n        exp = Index(\n            np.array(\n                [(\"a_b\", \"_\", \"c\"), (\"c_d\", \"_\", \"e\"), (\"f_g\", \"_\", \"h\"), np.nan, None]\n            )\n        )\n        tm.assert_index_equal(result, exp)\n        assert result.nlevels == 1\n\n        result = values.str.partition(\"_\")\n        exp = Index(\n            [\n                (\"a\", \"_\", \"b_c\"),\n                (\"c\", \"_\", \"d_e\"),\n                (\"f\", \"_\", \"g_h\"),\n                (np.nan, np.nan, np.nan),\n                (None, None, None),\n            ]\n        )\n        tm.assert_index_equal(result, exp)\n        assert isinstance(result, MultiIndex)\n        assert result.nlevels == 3\n\n        result = values.str.rpartition(\"_\")\n        exp = Index(\n            [\n                (\"a_b\", \"_\", \"c\"),\n                (\"c_d\", \"_\", \"e\"),\n                (\"f_g\", \"_\", \"h\"),\n                (np.nan, np.nan, np.nan),\n                (None, None, None),\n            ]\n        )\n        tm.assert_index_equal(result, exp)\n        assert isinstance(result, MultiIndex)\n        assert result.nlevels == 3",
        "begin_line": 2829,
        "end_line": 2878,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_partition_to_dataframe#2880",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_partition_to_dataframe(self)",
        "snippet": "    def test_partition_to_dataframe(self):\n        # https://github.com/pandas-dev/pandas/issues/23558\n\n        values = Series([\"a_b_c\", \"c_d_e\", np.nan, \"f_g_h\", None])\n        result = values.str.partition(\"_\")\n        exp = DataFrame(\n            {\n                0: [\"a\", \"c\", np.nan, \"f\", None],\n                1: [\"_\", \"_\", np.nan, \"_\", None],\n                2: [\"b_c\", \"d_e\", np.nan, \"g_h\", None],\n            }\n        )\n        tm.assert_frame_equal(result, exp)\n\n        result = values.str.rpartition(\"_\")\n        exp = DataFrame(\n            {\n                0: [\"a_b\", \"c_d\", np.nan, \"f_g\", None],\n                1: [\"_\", \"_\", np.nan, \"_\", None],\n                2: [\"c\", \"e\", np.nan, \"h\", None],\n            }\n        )\n        tm.assert_frame_equal(result, exp)\n\n        values = Series([\"a_b_c\", \"c_d_e\", np.nan, \"f_g_h\", None])\n        result = values.str.partition(\"_\", expand=True)\n        exp = DataFrame(\n            {\n                0: [\"a\", \"c\", np.nan, \"f\", None],\n                1: [\"_\", \"_\", np.nan, \"_\", None],\n                2: [\"b_c\", \"d_e\", np.nan, \"g_h\", None],\n            }\n        )\n        tm.assert_frame_equal(result, exp)\n\n        result = values.str.rpartition(\"_\", expand=True)\n        exp = DataFrame(\n            {\n                0: [\"a_b\", \"c_d\", np.nan, \"f_g\", None],\n                1: [\"_\", \"_\", np.nan, \"_\", None],\n                2: [\"c\", \"e\", np.nan, \"h\", None],\n            }\n        )\n        tm.assert_frame_equal(result, exp)",
        "begin_line": 2880,
        "end_line": 2923,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_partition_with_name#2925",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_partition_with_name(self)",
        "snippet": "    def test_partition_with_name(self):\n        # GH 12617\n\n        s = Series([\"a,b\", \"c,d\"], name=\"xxx\")\n        res = s.str.partition(\",\")\n        exp = DataFrame({0: [\"a\", \"c\"], 1: [\",\", \",\"], 2: [\"b\", \"d\"]})\n        tm.assert_frame_equal(res, exp)\n\n        # should preserve name\n        res = s.str.partition(\",\", expand=False)\n        exp = Series([(\"a\", \",\", \"b\"), (\"c\", \",\", \"d\")], name=\"xxx\")\n        tm.assert_series_equal(res, exp)\n\n        idx = Index([\"a,b\", \"c,d\"], name=\"xxx\")\n        res = idx.str.partition(\",\")\n        exp = MultiIndex.from_tuples([(\"a\", \",\", \"b\"), (\"c\", \",\", \"d\")])\n        assert res.nlevels == 3\n        tm.assert_index_equal(res, exp)\n\n        # should preserve name\n        res = idx.str.partition(\",\", expand=False)\n        exp = Index(np.array([(\"a\", \",\", \"b\"), (\"c\", \",\", \"d\")]), name=\"xxx\")\n        assert res.nlevels == 1\n        tm.assert_index_equal(res, exp)",
        "begin_line": 2925,
        "end_line": 2948,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_partition_deprecation#2950",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_partition_deprecation(self)",
        "snippet": "    def test_partition_deprecation(self):\n        # GH 22676; depr kwarg \"pat\" in favor of \"sep\"\n        values = Series([\"a_b_c\", \"c_d_e\", np.nan, \"f_g_h\"])\n\n        # str.partition\n        # using sep -> no warning\n        expected = values.str.partition(sep=\"_\")\n        with tm.assert_produces_warning(FutureWarning):\n            result = values.str.partition(pat=\"_\")\n            tm.assert_frame_equal(result, expected)\n\n        # str.rpartition\n        # using sep -> no warning\n        expected = values.str.rpartition(sep=\"_\")\n        with tm.assert_produces_warning(FutureWarning):\n            result = values.str.rpartition(pat=\"_\")\n            tm.assert_frame_equal(result, expected)",
        "begin_line": 2950,
        "end_line": 2966,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_pipe_failures#2968",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_pipe_failures(self)",
        "snippet": "    def test_pipe_failures(self):\n        # #2119\n        s = Series([\"A|B|C\"])\n\n        result = s.str.split(\"|\")\n        exp = Series([[\"A\", \"B\", \"C\"]])\n\n        tm.assert_series_equal(result, exp)\n\n        result = s.str.replace(\"|\", \" \")\n        exp = Series([\"A B C\"])\n\n        tm.assert_series_equal(result, exp)",
        "begin_line": 2968,
        "end_line": 2980,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_slice#2992",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_slice(self, start, stop, step, expected)",
        "snippet": "    def test_slice(self, start, stop, step, expected):\n        values = Series([\"aafootwo\", \"aabartwo\", np.nan, \"aabazqux\"])\n        result = values.str.slice(start, stop, step)\n        tm.assert_series_equal(result, expected)\n\n        # mixed\n        mixed = Series(\n            [\"aafootwo\", np.nan, \"aabartwo\", True, datetime.today(), None, 1, 2.0]\n        )\n\n        rs = Series(mixed).str.slice(2, 5)\n        xp = Series([\"foo\", np.nan, \"bar\", np.nan, np.nan, np.nan, np.nan, np.nan])\n\n        assert isinstance(rs, Series)\n        tm.assert_almost_equal(rs, xp)\n\n        rs = Series(mixed).str.slice(2, 5, -1)\n        xp = Series([\"oof\", np.nan, \"rab\", np.nan, np.nan, np.nan, np.nan, np.nan])",
        "begin_line": 2992,
        "end_line": 3009,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_slice_replace#3011",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_slice_replace(self)",
        "snippet": "    def test_slice_replace(self):\n        values = Series([\"short\", \"a bit longer\", \"evenlongerthanthat\", \"\", np.nan])\n\n        exp = Series([\"shrt\", \"a it longer\", \"evnlongerthanthat\", \"\", np.nan])\n        result = values.str.slice_replace(2, 3)\n        tm.assert_series_equal(result, exp)\n\n        exp = Series([\"shzrt\", \"a zit longer\", \"evznlongerthanthat\", \"z\", np.nan])\n        result = values.str.slice_replace(2, 3, \"z\")\n        tm.assert_series_equal(result, exp)\n\n        exp = Series([\"shzort\", \"a zbit longer\", \"evzenlongerthanthat\", \"z\", np.nan])\n        result = values.str.slice_replace(2, 2, \"z\")\n        tm.assert_series_equal(result, exp)\n\n        exp = Series([\"shzort\", \"a zbit longer\", \"evzenlongerthanthat\", \"z\", np.nan])\n        result = values.str.slice_replace(2, 1, \"z\")\n        tm.assert_series_equal(result, exp)\n\n        exp = Series([\"shorz\", \"a bit longez\", \"evenlongerthanthaz\", \"z\", np.nan])\n        result = values.str.slice_replace(-1, None, \"z\")\n        tm.assert_series_equal(result, exp)\n\n        exp = Series([\"zrt\", \"zer\", \"zat\", \"z\", np.nan])\n        result = values.str.slice_replace(None, -2, \"z\")\n        tm.assert_series_equal(result, exp)\n\n        exp = Series([\"shortz\", \"a bit znger\", \"evenlozerthanthat\", \"z\", np.nan])\n        result = values.str.slice_replace(6, 8, \"z\")\n        tm.assert_series_equal(result, exp)\n\n        exp = Series([\"zrt\", \"a zit longer\", \"evenlongzerthanthat\", \"z\", np.nan])\n        result = values.str.slice_replace(-10, 3, \"z\")\n        tm.assert_series_equal(result, exp)",
        "begin_line": 3011,
        "end_line": 3044,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_strip_lstrip_rstrip#3046",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_strip_lstrip_rstrip(self)",
        "snippet": "    def test_strip_lstrip_rstrip(self):\n        values = Series([\"  aa   \", \" bb \\n\", np.nan, \"cc  \"])\n\n        result = values.str.strip()\n        exp = Series([\"aa\", \"bb\", np.nan, \"cc\"])\n        tm.assert_series_equal(result, exp)\n\n        result = values.str.lstrip()\n        exp = Series([\"aa   \", \"bb \\n\", np.nan, \"cc  \"])\n        tm.assert_series_equal(result, exp)\n\n        result = values.str.rstrip()\n        exp = Series([\"  aa\", \" bb\", np.nan, \"cc\"])\n        tm.assert_series_equal(result, exp)",
        "begin_line": 3046,
        "end_line": 3059,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_strip_lstrip_rstrip_mixed#3061",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_strip_lstrip_rstrip_mixed(self)",
        "snippet": "    def test_strip_lstrip_rstrip_mixed(self):\n        # mixed\n        mixed = Series(\n            [\"  aa  \", np.nan, \" bb \\t\\n\", True, datetime.today(), None, 1, 2.0]\n        )\n\n        rs = Series(mixed).str.strip()\n        xp = Series([\"aa\", np.nan, \"bb\", np.nan, np.nan, np.nan, np.nan, np.nan])\n\n        assert isinstance(rs, Series)\n        tm.assert_almost_equal(rs, xp)\n\n        rs = Series(mixed).str.lstrip()\n        xp = Series([\"aa  \", np.nan, \"bb \\t\\n\", np.nan, np.nan, np.nan, np.nan, np.nan])\n\n        assert isinstance(rs, Series)\n        tm.assert_almost_equal(rs, xp)\n\n        rs = Series(mixed).str.rstrip()\n        xp = Series([\"  aa\", np.nan, \" bb\", np.nan, np.nan, np.nan, np.nan, np.nan])\n\n        assert isinstance(rs, Series)\n        tm.assert_almost_equal(rs, xp)",
        "begin_line": 3061,
        "end_line": 3083,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_strip_lstrip_rstrip_args#3085",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_strip_lstrip_rstrip_args(self)",
        "snippet": "    def test_strip_lstrip_rstrip_args(self):\n        values = Series([\"xxABCxx\", \"xx BNSD\", \"LDFJH xx\"])\n\n        rs = values.str.strip(\"x\")\n        xp = Series([\"ABC\", \" BNSD\", \"LDFJH \"])\n        tm.assert_series_equal(rs, xp)\n\n        rs = values.str.lstrip(\"x\")\n        xp = Series([\"ABCxx\", \" BNSD\", \"LDFJH xx\"])\n        tm.assert_series_equal(rs, xp)\n\n        rs = values.str.rstrip(\"x\")\n        xp = Series([\"xxABC\", \"xx BNSD\", \"LDFJH \"])\n        tm.assert_series_equal(rs, xp)",
        "begin_line": 3085,
        "end_line": 3098,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_wrap#3100",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_wrap(self)",
        "snippet": "    def test_wrap(self):\n        # test values are: two words less than width, two words equal to width,\n        # two words greater than width, one word less than width, one word\n        # equal to width, one word greater than width, multiple tokens with\n        # trailing whitespace equal to width\n        values = Series(\n            [\n                \"hello world\",\n                \"hello world!\",\n                \"hello world!!\",\n                \"abcdefabcde\",\n                \"abcdefabcdef\",\n                \"abcdefabcdefa\",\n                \"ab ab ab ab \",\n                \"ab ab ab ab a\",\n                \"\\t\",\n            ]\n        )\n\n        # expected values\n        xp = Series(\n            [\n                \"hello world\",\n                \"hello world!\",\n                \"hello\\nworld!!\",\n                \"abcdefabcde\",\n                \"abcdefabcdef\",\n                \"abcdefabcdef\\na\",\n                \"ab ab ab ab\",\n                \"ab ab ab ab\\na\",\n                \"\",\n            ]\n        )\n\n        rs = values.str.wrap(12, break_long_words=True)\n        tm.assert_series_equal(rs, xp)\n\n        # test with pre and post whitespace (non-unicode), NaN, and non-ascii\n        # Unicode\n        values = Series([\"  pre  \", np.nan, \"\\xac\\u20ac\\U00008000 abadcafe\"])\n        xp = Series([\"  pre\", np.nan, \"\\xac\\u20ac\\U00008000 ab\\nadcafe\"])\n        rs = values.str.wrap(6)\n        tm.assert_series_equal(rs, xp)",
        "begin_line": 3100,
        "end_line": 3142,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_get#3144",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_get(self)",
        "snippet": "    def test_get(self):\n        values = Series([\"a_b_c\", \"c_d_e\", np.nan, \"f_g_h\"])\n\n        result = values.str.split(\"_\").str.get(1)\n        expected = Series([\"b\", \"d\", np.nan, \"g\"])\n        tm.assert_series_equal(result, expected)\n\n        # mixed\n        mixed = Series([\"a_b_c\", np.nan, \"c_d_e\", True, datetime.today(), None, 1, 2.0])\n\n        rs = Series(mixed).str.split(\"_\").str.get(1)\n        xp = Series([\"b\", np.nan, \"d\", np.nan, np.nan, np.nan, np.nan, np.nan])\n\n        assert isinstance(rs, Series)\n        tm.assert_almost_equal(rs, xp)\n\n        # bounds testing\n        values = Series([\"1_2_3_4_5\", \"6_7_8_9_10\", \"11_12\"])\n\n        # positive index\n        result = values.str.split(\"_\").str.get(2)\n        expected = Series([\"3\", \"8\", np.nan])\n        tm.assert_series_equal(result, expected)\n\n        # negative index\n        result = values.str.split(\"_\").str.get(-3)\n        expected = Series([\"3\", \"8\", np.nan])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 3144,
        "end_line": 3171,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_get_complex#3173",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_get_complex(self)",
        "snippet": "    def test_get_complex(self):\n        # GH 20671, getting value not in dict raising `KeyError`\n        values = Series([(1, 2, 3), [1, 2, 3], {1, 2, 3}, {1: \"a\", 2: \"b\", 3: \"c\"}])\n\n        result = values.str.get(1)\n        expected = Series([2, 2, np.nan, \"a\"])\n        tm.assert_series_equal(result, expected)\n\n        result = values.str.get(-1)\n        expected = Series([3, 3, np.nan, np.nan])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 3173,
        "end_line": 3183,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_get_complex_nested#3186",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_get_complex_nested(self, to_type)",
        "snippet": "    def test_get_complex_nested(self, to_type):\n        values = Series([to_type([to_type([1, 2])])])\n\n        result = values.str.get(0)\n        expected = Series([to_type([1, 2])])\n        tm.assert_series_equal(result, expected)\n\n        result = values.str.get(1)\n        expected = Series([np.nan])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 3186,
        "end_line": 3195,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_contains_moar#3197",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_contains_moar(self)",
        "snippet": "    def test_contains_moar(self):\n        # PR #1179\n        s = Series([\"A\", \"B\", \"C\", \"Aaba\", \"Baca\", \"\", np.nan, \"CABA\", \"dog\", \"cat\"])\n\n        result = s.str.contains(\"a\")\n        expected = Series(\n            [False, False, False, True, True, False, np.nan, False, False, True]\n        )\n        tm.assert_series_equal(result, expected)\n\n        result = s.str.contains(\"a\", case=False)\n        expected = Series(\n            [True, False, False, True, True, False, np.nan, True, False, True]\n        )\n        tm.assert_series_equal(result, expected)\n\n        result = s.str.contains(\"Aa\")\n        expected = Series(\n            [False, False, False, True, False, False, np.nan, False, False, False]\n        )\n        tm.assert_series_equal(result, expected)\n\n        result = s.str.contains(\"ba\")\n        expected = Series(\n            [False, False, False, True, False, False, np.nan, False, False, False]\n        )\n        tm.assert_series_equal(result, expected)\n\n        result = s.str.contains(\"ba\", case=False)\n        expected = Series(\n            [False, False, False, True, True, False, np.nan, True, False, False]\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 3197,
        "end_line": 3229,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_contains_nan#3231",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_contains_nan(self)",
        "snippet": "    def test_contains_nan(self):\n        # PR #14171\n        s = Series([np.nan, np.nan, np.nan], dtype=np.object_)\n\n        result = s.str.contains(\"foo\", na=False)\n        expected = Series([False, False, False], dtype=np.bool_)\n        tm.assert_series_equal(result, expected)\n\n        result = s.str.contains(\"foo\", na=True)\n        expected = Series([True, True, True], dtype=np.bool_)\n        tm.assert_series_equal(result, expected)\n\n        result = s.str.contains(\"foo\", na=\"foo\")\n        expected = Series([\"foo\", \"foo\", \"foo\"], dtype=np.object_)\n        tm.assert_series_equal(result, expected)\n\n        result = s.str.contains(\"foo\")\n        expected = Series([np.nan, np.nan, np.nan], dtype=np.object_)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 3231,
        "end_line": 3249,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_replace_moar#3251",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_replace_moar(self)",
        "snippet": "    def test_replace_moar(self):\n        # PR #1179\n        s = Series([\"A\", \"B\", \"C\", \"Aaba\", \"Baca\", \"\", np.nan, \"CABA\", \"dog\", \"cat\"])\n\n        result = s.str.replace(\"A\", \"YYY\")\n        expected = Series(\n            [\"YYY\", \"B\", \"C\", \"YYYaba\", \"Baca\", \"\", np.nan, \"CYYYBYYY\", \"dog\", \"cat\"]\n        )\n        tm.assert_series_equal(result, expected)\n\n        result = s.str.replace(\"A\", \"YYY\", case=False)\n        expected = Series(\n            [\n                \"YYY\",\n                \"B\",\n                \"C\",\n                \"YYYYYYbYYY\",\n                \"BYYYcYYY\",\n                \"\",\n                np.nan,\n                \"CYYYBYYY\",\n                \"dog\",\n                \"cYYYt\",\n            ]\n        )\n        tm.assert_series_equal(result, expected)\n\n        result = s.str.replace(\"^.a|dog\", \"XX-XX \", case=False)\n        expected = Series(\n            [\n                \"A\",\n                \"B\",\n                \"C\",\n                \"XX-XX ba\",\n                \"XX-XX ca\",\n                \"\",\n                np.nan,\n                \"XX-XX BA\",\n                \"XX-XX \",\n                \"XX-XX t\",\n            ]\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 3251,
        "end_line": 3293,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_string_slice_get_syntax#3295",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_string_slice_get_syntax(self)",
        "snippet": "    def test_string_slice_get_syntax(self):\n        s = Series(\n            [\n                \"YYY\",\n                \"B\",\n                \"C\",\n                \"YYYYYYbYYY\",\n                \"BYYYcYYY\",\n                np.nan,\n                \"CYYYBYYY\",\n                \"dog\",\n                \"cYYYt\",\n            ]\n        )\n\n        result = s.str[0]\n        expected = s.str.get(0)\n        tm.assert_series_equal(result, expected)\n\n        result = s.str[:3]\n        expected = s.str.slice(stop=3)\n        tm.assert_series_equal(result, expected)\n\n        result = s.str[2::-1]\n        expected = s.str.slice(start=2, step=-1)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 3295,
        "end_line": 3320,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_string_slice_out_of_bounds#3322",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_string_slice_out_of_bounds(self)",
        "snippet": "    def test_string_slice_out_of_bounds(self):\n        s = Series([(1, 2), (1,), (3, 4, 5)])\n\n        result = s.str[1]\n        expected = Series([2, np.nan, 4])\n\n        tm.assert_series_equal(result, expected)\n\n        s = Series([\"foo\", \"b\", \"ba\"])\n        result = s.str[1]\n        expected = Series([\"o\", np.nan, \"a\"])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 3322,
        "end_line": 3333,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_match_findall_flags#3335",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_match_findall_flags(self)",
        "snippet": "    def test_match_findall_flags(self):\n        data = {\n            \"Dave\": \"dave@google.com\",\n            \"Steve\": \"steve@gmail.com\",\n            \"Rob\": \"rob@gmail.com\",\n            \"Wes\": np.nan,\n        }\n        data = Series(data)\n\n        pat = r\"([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\\.([A-Z]{2,4})\"\n\n        result = data.str.extract(pat, flags=re.IGNORECASE, expand=True)\n        assert result.iloc[0].tolist() == [\"dave\", \"google\", \"com\"]\n\n        result = data.str.match(pat, flags=re.IGNORECASE)\n        assert result[0]\n\n        result = data.str.findall(pat, flags=re.IGNORECASE)\n        assert result[0][0] == (\"dave\", \"google\", \"com\")\n\n        result = data.str.count(pat, flags=re.IGNORECASE)\n        assert result[0] == 1\n\n        with tm.assert_produces_warning(UserWarning):\n            result = data.str.contains(pat, flags=re.IGNORECASE)\n        assert result[0]",
        "begin_line": 3335,
        "end_line": 3360,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_encode_decode#3362",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_encode_decode(self)",
        "snippet": "    def test_encode_decode(self):\n        base = Series([\"a\", \"b\", \"a\\xe4\"])\n        series = base.str.encode(\"utf-8\")\n\n        f = lambda x: x.decode(\"utf-8\")\n        result = series.str.decode(\"utf-8\")\n        exp = series.map(f)\n\n        tm.assert_series_equal(result, exp)",
        "begin_line": 3362,
        "end_line": 3370,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_encode_decode_errors#3372",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_encode_decode_errors(self)",
        "snippet": "    def test_encode_decode_errors(self):\n        encodeBase = Series([\"a\", \"b\", \"a\\x9d\"])\n\n        msg = (\n            r\"'charmap' codec can't encode character '\\\\x9d' in position 1:\"\n            \" character maps to <undefined>\"\n        )\n        with pytest.raises(UnicodeEncodeError, match=msg):\n            encodeBase.str.encode(\"cp1252\")\n\n        f = lambda x: x.encode(\"cp1252\", \"ignore\")\n        result = encodeBase.str.encode(\"cp1252\", \"ignore\")\n        exp = encodeBase.map(f)\n        tm.assert_series_equal(result, exp)\n\n        decodeBase = Series([b\"a\", b\"b\", b\"a\\x9d\"])\n\n        msg = (\n            \"'charmap' codec can't decode byte 0x9d in position 1:\"\n            \" character maps to <undefined>\"\n        )\n        with pytest.raises(UnicodeDecodeError, match=msg):\n            decodeBase.str.decode(\"cp1252\")\n\n        f = lambda x: x.decode(\"cp1252\", \"ignore\")\n        result = decodeBase.str.decode(\"cp1252\", \"ignore\")\n        exp = decodeBase.map(f)\n\n        tm.assert_series_equal(result, exp)",
        "begin_line": 3372,
        "end_line": 3400,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_normalize#3402",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_normalize(self)",
        "snippet": "    def test_normalize(self):\n        values = [\"ABC\", \"\uff21\uff22\uff23\", \"\uff11\uff12\uff13\", np.nan, \"\uff71\uff72\uff74\"]\n        s = Series(values, index=[\"a\", \"b\", \"c\", \"d\", \"e\"])\n\n        normed = [\"ABC\", \"ABC\", \"123\", np.nan, \"\u30a2\u30a4\u30a8\"]\n        expected = Series(normed, index=[\"a\", \"b\", \"c\", \"d\", \"e\"])\n\n        result = s.str.normalize(\"NFKC\")\n        tm.assert_series_equal(result, expected)\n\n        expected = Series(\n            [\"ABC\", \"\uff21\uff22\uff23\", \"\uff11\uff12\uff13\", np.nan, \"\uff71\uff72\uff74\"], index=[\"a\", \"b\", \"c\", \"d\", \"e\"]\n        )\n\n        result = s.str.normalize(\"NFC\")\n        tm.assert_series_equal(result, expected)\n\n        with pytest.raises(ValueError, match=\"invalid normalization form\"):\n            s.str.normalize(\"xxx\")\n\n        s = Index([\"\uff21\uff22\uff23\", \"\uff11\uff12\uff13\", \"\uff71\uff72\uff74\"])\n        expected = Index([\"ABC\", \"123\", \"\u30a2\u30a4\u30a8\"])\n        result = s.str.normalize(\"NFKC\")\n        tm.assert_index_equal(result, expected)",
        "begin_line": 3402,
        "end_line": 3425,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_index_str_accessor_visibility#3427",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_index_str_accessor_visibility(self)",
        "snippet": "    def test_index_str_accessor_visibility(self):\n        from pandas.core.strings import StringMethods\n\n        cases = [\n            ([\"a\", \"b\"], \"string\"),\n            ([\"a\", \"b\", 1], \"mixed-integer\"),\n            ([\"a\", \"b\", 1.3], \"mixed\"),\n            ([\"a\", \"b\", 1.3, 1], \"mixed-integer\"),\n            ([\"aa\", datetime(2011, 1, 1)], \"mixed\"),\n        ]\n        for values, tp in cases:\n            idx = Index(values)\n            assert isinstance(Series(values).str, StringMethods)\n            assert isinstance(idx.str, StringMethods)\n            assert idx.inferred_type == tp\n\n        for values, tp in cases:\n            idx = Index(values)\n            assert isinstance(Series(values).str, StringMethods)\n            assert isinstance(idx.str, StringMethods)\n            assert idx.inferred_type == tp\n\n        cases = [\n            ([1, np.nan], \"floating\"),\n            ([datetime(2011, 1, 1)], \"datetime64\"),\n            ([timedelta(1)], \"timedelta64\"),\n        ]\n        for values, tp in cases:\n            idx = Index(values)\n            message = \"Can only use .str accessor with string values\"\n            with pytest.raises(AttributeError, match=message):\n                Series(values).str\n            with pytest.raises(AttributeError, match=message):\n                idx.str\n            assert idx.inferred_type == tp\n\n        # MultiIndex has mixed dtype, but not allow to use accessor\n        idx = MultiIndex.from_tuples([(\"a\", \"b\"), (\"a\", \"b\")])\n        assert idx.inferred_type == \"mixed\"\n        message = \"Can only use .str accessor with Index, not MultiIndex\"\n        with pytest.raises(AttributeError, match=message):\n            idx.str",
        "begin_line": 3427,
        "end_line": 3468,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_str_accessor_no_new_attributes#3470",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_str_accessor_no_new_attributes(self)",
        "snippet": "    def test_str_accessor_no_new_attributes(self):\n        # https://github.com/pandas-dev/pandas/issues/10673\n        s = Series(list(\"aabbcde\"))\n        with pytest.raises(AttributeError, match=\"You cannot add any new attribute\"):\n            s.str.xlabel = \"a\"",
        "begin_line": 3470,
        "end_line": 3474,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_method_on_bytes#3476",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_method_on_bytes(self)",
        "snippet": "    def test_method_on_bytes(self):\n        lhs = Series(np.array(list(\"abc\"), \"S1\").astype(object))\n        rhs = Series(np.array(list(\"def\"), \"S1\").astype(object))\n        with pytest.raises(TypeError, match=\"Cannot use .str.cat with values of.*\"):\n            lhs.str.cat(rhs)",
        "begin_line": 3476,
        "end_line": 3480,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.TestStringMethods.test_casefold#3482",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings.TestStringMethods",
        "signature": "pandas.tests.test_strings.TestStringMethods.test_casefold(self)",
        "snippet": "    def test_casefold(self):\n        # GH25405\n        expected = Series([\"ss\", np.nan, \"case\", \"ssd\"])\n        s = Series([\"\u00df\", np.nan, \"case\", \"\u00dfd\"])\n        result = s.str.casefold()\n\n        tm.assert_series_equal(result, expected)",
        "begin_line": 3482,
        "end_line": 3488,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.test_strings.test_string_array#3491",
        "src_path": "pandas/tests/test_strings.py",
        "class_name": "pandas.tests.test_strings",
        "signature": "pandas.tests.test_strings.test_string_array(any_string_method)",
        "snippet": "def test_string_array(any_string_method):\n    data = [\"a\", \"bb\", np.nan, \"ccc\"]\n    a = Series(data, dtype=object)\n    b = Series(data, dtype=\"string\")\n    method_name, args, kwargs = any_string_method\n\n    expected = getattr(a.str, method_name)(*args, **kwargs)\n    result = getattr(b.str, method_name)(*args, **kwargs)\n\n    if isinstance(expected, Series):\n        if expected.dtype == \"object\" and lib.is_string_array(\n            expected.values, skipna=True\n        ):\n            assert result.dtype == \"string\"\n            result = result.astype(object)\n    elif isinstance(expected, DataFrame):\n        columns = expected.select_dtypes(include=\"object\").columns\n        assert all(result[columns].dtypes == \"string\")\n        result[columns] = result[columns].astype(object)\n    tm.assert_equal(result, expected)",
        "begin_line": 3491,
        "end_line": 3510,
        "comment": "",
        "is_bug": false
    }
]