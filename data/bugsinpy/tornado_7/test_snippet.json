[
    {
        "name": "tornado.test.ioloop_test.FakeTimeSelect.__init__#42",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.FakeTimeSelect",
        "signature": "tornado.test.ioloop_test.FakeTimeSelect.__init__(self)",
        "snippet": "    def __init__(self):\n        self._time = 1000\n        super(FakeTimeSelect, self).__init__()",
        "begin_line": 42,
        "end_line": 44,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.FakeTimeSelect.time#46",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.FakeTimeSelect",
        "signature": "tornado.test.ioloop_test.FakeTimeSelect.time(self)",
        "snippet": "    def time(self):\n        return self._time",
        "begin_line": 46,
        "end_line": 47,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.FakeTimeSelect.sleep#49",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.FakeTimeSelect",
        "signature": "tornado.test.ioloop_test.FakeTimeSelect.sleep(self, t)",
        "snippet": "    def sleep(self, t):\n        self._time += t",
        "begin_line": 49,
        "end_line": 50,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.FakeTimeSelect.poll#52",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.FakeTimeSelect",
        "signature": "tornado.test.ioloop_test.FakeTimeSelect.poll(self, timeout)",
        "snippet": "    def poll(self, timeout):\n        events = super(FakeTimeSelect, self).poll(0)\n        if events:\n            return events\n        self._time += timeout\n        return []",
        "begin_line": 52,
        "end_line": 57,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.FakeTimeIOLoop.initialize#67",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.FakeTimeIOLoop",
        "signature": "tornado.test.ioloop_test.FakeTimeIOLoop.initialize(self)",
        "snippet": "    def initialize(self):\n        self.fts = FakeTimeSelect()\n        super(FakeTimeIOLoop, self).initialize(impl=self.fts,\n                                               time_func=self.fts.time)",
        "begin_line": 67,
        "end_line": 70,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.FakeTimeIOLoop.sleep#72",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.FakeTimeIOLoop",
        "signature": "tornado.test.ioloop_test.FakeTimeIOLoop.sleep(self, t)",
        "snippet": "    def sleep(self, t):\n        \"\"\"Simulate a blocking sleep by advancing the clock.\"\"\"\n        self.fts.sleep(t)",
        "begin_line": 72,
        "end_line": 74,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_return_sequence#78",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_return_sequence(self)",
        "snippet": "    def test_add_callback_return_sequence(self):\n        # A callback returning {} or [] shouldn't spin the CPU, see Issue #1803.\n        self.calls = 0\n\n        loop = self.io_loop\n        test = self\n        old_add_callback = loop.add_callback\n\n        def add_callback(self, callback, *args, **kwargs):\n            test.calls += 1\n            old_add_callback(callback, *args, **kwargs)\n\n        loop.add_callback = types.MethodType(add_callback, loop)\n        loop.add_callback(lambda: {})\n        loop.add_callback(lambda: [])\n        loop.add_timeout(datetime.timedelta(milliseconds=50), loop.stop)\n        loop.start()\n        self.assertLess(self.calls, 10)",
        "begin_line": 78,
        "end_line": 95,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.add_callback#86",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.add_callback(self, callback, *args, **kwargs)",
        "snippet": "        def add_callback(self, callback, *args, **kwargs):\n            test.calls += 1\n            old_add_callback(callback, *args, **kwargs)",
        "begin_line": 86,
        "end_line": 88,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_wakeup#98",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_wakeup(self)",
        "snippet": "    def test_add_callback_wakeup(self):\n        # Make sure that add_callback from inside a running IOLoop\n        # wakes up the IOLoop immediately instead of waiting for a timeout.\n        def callback():\n            self.called = True\n            self.stop()\n\n        def schedule_callback():\n            self.called = False\n            self.io_loop.add_callback(callback)\n            # Store away the time so we can check if we woke up immediately\n            self.start_time = time.time()\n        self.io_loop.add_timeout(self.io_loop.time(), schedule_callback)\n        self.wait()\n        self.assertAlmostEqual(time.time(), self.start_time, places=2)\n        self.assertTrue(self.called)",
        "begin_line": 98,
        "end_line": 113,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.callback#101",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.callback()",
        "snippet": "        def callback():\n            self.called = True\n            self.stop()",
        "begin_line": 101,
        "end_line": 103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.schedule_callback#105",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.schedule_callback()",
        "snippet": "        def schedule_callback():\n            self.called = False\n            self.io_loop.add_callback(callback)\n            # Store away the time so we can check if we woke up immediately\n            self.start_time = time.time()",
        "begin_line": 105,
        "end_line": 109,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_wakeup_other_thread#116",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_wakeup_other_thread(self)",
        "snippet": "    def test_add_callback_wakeup_other_thread(self):\n        def target():\n            # sleep a bit to let the ioloop go into its poll loop\n            time.sleep(0.01)\n            self.stop_time = time.time()\n            self.io_loop.add_callback(self.stop)\n        thread = threading.Thread(target=target)\n        self.io_loop.add_callback(thread.start)\n        self.wait()\n        delta = time.time() - self.stop_time\n        self.assertLess(delta, 0.1)\n        thread.join()",
        "begin_line": 116,
        "end_line": 127,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.target#117",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.target()",
        "snippet": "        def target():\n            # sleep a bit to let the ioloop go into its poll loop\n            time.sleep(0.01)\n            self.stop_time = time.time()\n            self.io_loop.add_callback(self.stop)",
        "begin_line": 117,
        "end_line": 121,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_timeout_timedelta#129",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_timeout_timedelta(self)",
        "snippet": "    def test_add_timeout_timedelta(self):\n        self.io_loop.add_timeout(datetime.timedelta(microseconds=1), self.stop)\n        self.wait()",
        "begin_line": 129,
        "end_line": 131,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_multiple_add#133",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_multiple_add(self)",
        "snippet": "    def test_multiple_add(self):\n        sock, port = bind_unused_port()\n        try:\n            self.io_loop.add_handler(sock.fileno(), lambda fd, events: None,\n                                     IOLoop.READ)\n            # Attempting to add the same handler twice fails\n            # (with a platform-dependent exception)\n            self.assertRaises(Exception, self.io_loop.add_handler,\n                              sock.fileno(), lambda fd, events: None,\n                              IOLoop.READ)\n        finally:\n            self.io_loop.remove_handler(sock.fileno())\n            sock.close()",
        "begin_line": 133,
        "end_line": 145,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_remove_without_add#147",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_remove_without_add(self)",
        "snippet": "    def test_remove_without_add(self):\n        # remove_handler should not throw an exception if called on an fd\n        # was never added.\n        sock, port = bind_unused_port()\n        try:\n            self.io_loop.remove_handler(sock.fileno())\n        finally:\n            sock.close()",
        "begin_line": 147,
        "end_line": 154,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_from_signal#156",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_from_signal(self)",
        "snippet": "    def test_add_callback_from_signal(self):\n        # cheat a little bit and just run this normally, since we can't\n        # easily simulate the races that happen with real signal handlers\n        self.io_loop.add_callback_from_signal(self.stop)\n        self.wait()",
        "begin_line": 156,
        "end_line": 160,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_from_signal_other_thread#162",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_from_signal_other_thread(self)",
        "snippet": "    def test_add_callback_from_signal_other_thread(self):\n        # Very crude test, just to make sure that we cover this case.\n        # This also happens to be the first test where we run an IOLoop in\n        # a non-main thread.\n        other_ioloop = IOLoop()\n        thread = threading.Thread(target=other_ioloop.start)\n        thread.start()\n        other_ioloop.add_callback_from_signal(other_ioloop.stop)\n        thread.join()\n        other_ioloop.close()",
        "begin_line": 162,
        "end_line": 171,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_while_closing#173",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_callback_while_closing(self)",
        "snippet": "    def test_add_callback_while_closing(self):\n        # Issue #635: add_callback() should raise a clean exception\n        # if called while another thread is closing the IOLoop.\n        if IOLoop.configured_class().__name__.endswith('AsyncIOLoop'):\n            raise unittest.SkipTest(\"AsyncIOMainLoop shutdown not thread safe\")\n        closing = threading.Event()\n\n        def target():\n            other_ioloop.add_callback(other_ioloop.stop)\n            other_ioloop.start()\n            closing.set()\n            other_ioloop.close(all_fds=True)\n        other_ioloop = IOLoop()\n        thread = threading.Thread(target=target)\n        thread.start()\n        closing.wait()\n        for i in range(1000):\n            try:\n                other_ioloop.add_callback(lambda: None)\n            except RuntimeError as e:\n                self.assertEqual(\"IOLoop is closing\", str(e))\n                break",
        "begin_line": 173,
        "end_line": 194,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.target#180",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.target()",
        "snippet": "        def target():\n            other_ioloop.add_callback(other_ioloop.stop)\n            other_ioloop.start()\n            closing.set()\n            other_ioloop.close(all_fds=True)",
        "begin_line": 180,
        "end_line": 184,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_handle_callback_exception#196",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_handle_callback_exception(self)",
        "snippet": "    def test_handle_callback_exception(self):\n        # IOLoop.handle_callback_exception can be overridden to catch\n        # exceptions in callbacks.\n        def handle_callback_exception(callback):\n            self.assertIs(sys.exc_info()[0], ZeroDivisionError)\n            self.stop()\n        self.io_loop.handle_callback_exception = handle_callback_exception\n        with NullContext():\n            # remove the test StackContext that would see this uncaught\n            # exception as a test failure.\n            self.io_loop.add_callback(lambda: 1 / 0)\n        self.wait()",
        "begin_line": 196,
        "end_line": 207,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.handle_callback_exception#199",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.handle_callback_exception(callback)",
        "snippet": "        def handle_callback_exception(callback):\n            self.assertIs(sys.exc_info()[0], ZeroDivisionError)\n            self.stop()",
        "begin_line": 199,
        "end_line": 201,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_read_while_writeable#210",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_read_while_writeable(self)",
        "snippet": "    def test_read_while_writeable(self):\n        # Ensure that write events don't come in while we're waiting for\n        # a read and haven't asked for writeability. (the reverse is\n        # difficult to test for)\n        client, server = socket.socketpair()\n        try:\n            def handler(fd, events):\n                self.assertEqual(events, IOLoop.READ)\n                self.stop()\n            self.io_loop.add_handler(client.fileno(), handler, IOLoop.READ)\n            self.io_loop.add_timeout(self.io_loop.time() + 0.01,\n                                     functools.partial(server.send, b'asdf'))\n            self.wait()\n            self.io_loop.remove_handler(client.fileno())\n        finally:\n            client.close()\n            server.close()",
        "begin_line": 210,
        "end_line": 226,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.handler#216",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.handler(fd, events)",
        "snippet": "            def handler(fd, events):\n                self.assertEqual(events, IOLoop.READ)\n                self.stop()",
        "begin_line": 216,
        "end_line": 218,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_remove_timeout_after_fire#228",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_remove_timeout_after_fire(self)",
        "snippet": "    def test_remove_timeout_after_fire(self):\n        # It is not an error to call remove_timeout after it has run.\n        handle = self.io_loop.add_timeout(self.io_loop.time(), self.stop)\n        self.wait()\n        self.io_loop.remove_timeout(handle)",
        "begin_line": 228,
        "end_line": 232,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_remove_timeout_cleanup#234",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_remove_timeout_cleanup(self)",
        "snippet": "    def test_remove_timeout_cleanup(self):\n        # Add and remove enough callbacks to trigger cleanup.\n        # Not a very thorough test, but it ensures that the cleanup code\n        # gets executed and doesn't blow up.  This test is only really useful\n        # on PollIOLoop subclasses, but it should run silently on any\n        # implementation.\n        for i in range(2000):\n            timeout = self.io_loop.add_timeout(self.io_loop.time() + 3600,\n                                               lambda: None)\n            self.io_loop.remove_timeout(timeout)\n        # HACK: wait two IOLoop iterations for the GC to happen.\n        self.io_loop.add_callback(lambda: self.io_loop.add_callback(self.stop))\n        self.wait()",
        "begin_line": 234,
        "end_line": 246,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_remove_timeout_from_timeout#248",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_remove_timeout_from_timeout(self)",
        "snippet": "    def test_remove_timeout_from_timeout(self):\n        calls = [False, False]\n\n        # Schedule several callbacks and wait for them all to come due at once.\n        # t2 should be cancelled by t1, even though it is already scheduled to\n        # be run before the ioloop even looks at it.\n        now = self.io_loop.time()\n\n        def t1():\n            calls[0] = True\n            self.io_loop.remove_timeout(t2_handle)\n        self.io_loop.add_timeout(now + 0.01, t1)\n\n        def t2():\n            calls[1] = True\n        t2_handle = self.io_loop.add_timeout(now + 0.02, t2)\n        self.io_loop.add_timeout(now + 0.03, self.stop)\n        time.sleep(0.03)\n        self.wait()\n        self.assertEqual(calls, [True, False])",
        "begin_line": 248,
        "end_line": 267,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.t1#256",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.t1()",
        "snippet": "        def t1():\n            calls[0] = True\n            self.io_loop.remove_timeout(t2_handle)",
        "begin_line": 256,
        "end_line": 258,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.t2#261",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.t2()",
        "snippet": "        def t2():\n            calls[1] = True",
        "begin_line": 261,
        "end_line": 262,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_timeout_with_arguments#269",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_timeout_with_arguments(self)",
        "snippet": "    def test_timeout_with_arguments(self):\n        # This tests that all the timeout methods pass through *args correctly.\n        results = []\n        self.io_loop.add_timeout(self.io_loop.time(), results.append, 1)\n        self.io_loop.add_timeout(datetime.timedelta(seconds=0),\n                                 results.append, 2)\n        self.io_loop.call_at(self.io_loop.time(), results.append, 3)\n        self.io_loop.call_later(0, results.append, 4)\n        self.io_loop.call_later(0, self.stop)\n        self.wait()\n        # The asyncio event loop does not guarantee the order of these\n        # callbacks, but PollIOLoop does.\n        self.assertEqual(sorted(results), [1, 2, 3, 4])",
        "begin_line": 269,
        "end_line": 281,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_add_timeout_return#283",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_add_timeout_return(self)",
        "snippet": "    def test_add_timeout_return(self):\n        # All the timeout methods return non-None handles that can be\n        # passed to remove_timeout.\n        handle = self.io_loop.add_timeout(self.io_loop.time(), lambda: None)\n        self.assertFalse(handle is None)\n        self.io_loop.remove_timeout(handle)",
        "begin_line": 283,
        "end_line": 288,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_call_at_return#290",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_call_at_return(self)",
        "snippet": "    def test_call_at_return(self):\n        handle = self.io_loop.call_at(self.io_loop.time(), lambda: None)\n        self.assertFalse(handle is None)\n        self.io_loop.remove_timeout(handle)",
        "begin_line": 290,
        "end_line": 293,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_call_later_return#295",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_call_later_return(self)",
        "snippet": "    def test_call_later_return(self):\n        handle = self.io_loop.call_later(0, lambda: None)\n        self.assertFalse(handle is None)\n        self.io_loop.remove_timeout(handle)",
        "begin_line": 295,
        "end_line": 298,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_close_file_object#300",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_close_file_object(self)",
        "snippet": "    def test_close_file_object(self):\n        \"\"\"When a file object is used instead of a numeric file descriptor,\n        the object should be closed (by IOLoop.close(all_fds=True),\n        not just the fd.\n        \"\"\"\n        # Use a socket since they are supported by IOLoop on all platforms.\n        # Unfortunately, sockets don't support the .closed attribute for\n        # inspecting their close status, so we must use a wrapper.\n        class SocketWrapper(object):\n            def __init__(self, sockobj):\n                self.sockobj = sockobj\n                self.closed = False\n\n            def fileno(self):\n                return self.sockobj.fileno()\n\n            def close(self):\n                self.closed = True\n                self.sockobj.close()\n        sockobj, port = bind_unused_port()\n        socket_wrapper = SocketWrapper(sockobj)\n        io_loop = IOLoop()\n        io_loop.add_handler(socket_wrapper, lambda fd, events: None,\n                            IOLoop.READ)\n        io_loop.close(all_fds=True)\n        self.assertTrue(socket_wrapper.closed)",
        "begin_line": 300,
        "end_line": 325,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.SocketWrapper.test_close_file_object#300",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.SocketWrapper",
        "signature": "tornado.test.ioloop_test.SocketWrapper.test_close_file_object(self)",
        "snippet": "    def test_close_file_object(self):\n        \"\"\"When a file object is used instead of a numeric file descriptor,\n        the object should be closed (by IOLoop.close(all_fds=True),\n        not just the fd.\n        \"\"\"\n        # Use a socket since they are supported by IOLoop on all platforms.\n        # Unfortunately, sockets don't support the .closed attribute for\n        # inspecting their close status, so we must use a wrapper.\n        class SocketWrapper(object):\n            def __init__(self, sockobj):\n                self.sockobj = sockobj\n                self.closed = False\n\n            def fileno(self):\n                return self.sockobj.fileno()\n\n            def close(self):\n                self.closed = True\n                self.sockobj.close()\n        sockobj, port = bind_unused_port()\n        socket_wrapper = SocketWrapper(sockobj)\n        io_loop = IOLoop()\n        io_loop.add_handler(socket_wrapper, lambda fd, events: None,\n                            IOLoop.READ)\n        io_loop.close(all_fds=True)\n        self.assertTrue(socket_wrapper.closed)",
        "begin_line": 300,
        "end_line": 325,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.SocketWrapper.__init__#309",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.SocketWrapper",
        "signature": "tornado.test.ioloop_test.SocketWrapper.__init__(self, sockobj)",
        "snippet": "            def __init__(self, sockobj):\n                self.sockobj = sockobj\n                self.closed = False",
        "begin_line": 309,
        "end_line": 311,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.SocketWrapper.fileno#313",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.SocketWrapper",
        "signature": "tornado.test.ioloop_test.SocketWrapper.fileno(self)",
        "snippet": "            def fileno(self):\n                return self.sockobj.fileno()",
        "begin_line": 313,
        "end_line": 314,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.SocketWrapper.close#316",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.SocketWrapper",
        "signature": "tornado.test.ioloop_test.SocketWrapper.close(self)",
        "snippet": "            def close(self):\n                self.closed = True\n                self.sockobj.close()",
        "begin_line": 316,
        "end_line": 318,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_handler_callback_file_object#327",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_handler_callback_file_object(self)",
        "snippet": "    def test_handler_callback_file_object(self):\n        \"\"\"The handler callback receives the same fd object it passed in.\"\"\"\n        server_sock, port = bind_unused_port()\n        fds = []\n\n        def handle_connection(fd, events):\n            fds.append(fd)\n            conn, addr = server_sock.accept()\n            conn.close()\n            self.stop()\n        self.io_loop.add_handler(server_sock, handle_connection, IOLoop.READ)\n        with contextlib.closing(socket.socket()) as client_sock:\n            client_sock.connect(('127.0.0.1', port))\n            self.wait()\n        self.io_loop.remove_handler(server_sock)\n        self.io_loop.add_handler(server_sock.fileno(), handle_connection,\n                                 IOLoop.READ)\n        with contextlib.closing(socket.socket()) as client_sock:\n            client_sock.connect(('127.0.0.1', port))\n            self.wait()\n        self.assertIs(fds[0], server_sock)\n        self.assertEqual(fds[1], server_sock.fileno())\n        self.io_loop.remove_handler(server_sock.fileno())\n        server_sock.close()",
        "begin_line": 327,
        "end_line": 350,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.handle_connection#332",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.handle_connection(fd, events)",
        "snippet": "        def handle_connection(fd, events):\n            fds.append(fd)\n            conn, addr = server_sock.accept()\n            conn.close()\n            self.stop()",
        "begin_line": 332,
        "end_line": 336,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_mixed_fd_fileobj#352",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_mixed_fd_fileobj(self)",
        "snippet": "    def test_mixed_fd_fileobj(self):\n        server_sock, port = bind_unused_port()\n\n        def f(fd, events):\n            pass\n        self.io_loop.add_handler(server_sock, f, IOLoop.READ)\n        with self.assertRaises(Exception):\n            # The exact error is unspecified - some implementations use\n            # IOError, others use ValueError.\n            self.io_loop.add_handler(server_sock.fileno(), f, IOLoop.READ)\n        self.io_loop.remove_handler(server_sock.fileno())\n        server_sock.close()",
        "begin_line": 352,
        "end_line": 363,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.f#355",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.f(fd, events)",
        "snippet": "        def f(fd, events):\n            pass",
        "begin_line": 355,
        "end_line": 356,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_reentrant#365",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_reentrant(self)",
        "snippet": "    def test_reentrant(self):\n        \"\"\"Calling start() twice should raise an error, not deadlock.\"\"\"\n        returned_from_start = [False]\n        got_exception = [False]\n\n        def callback():\n            try:\n                self.io_loop.start()\n                returned_from_start[0] = True\n            except Exception:\n                got_exception[0] = True\n            self.stop()\n        self.io_loop.add_callback(callback)\n        self.wait()\n        self.assertTrue(got_exception[0])\n        self.assertFalse(returned_from_start[0])",
        "begin_line": 365,
        "end_line": 380,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.callback#370",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.callback()",
        "snippet": "        def callback():\n            try:\n                self.io_loop.start()\n                returned_from_start[0] = True\n            except Exception:\n                got_exception[0] = True\n            self.stop()",
        "begin_line": 370,
        "end_line": 376,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_exception_logging#382",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_exception_logging(self)",
        "snippet": "    def test_exception_logging(self):\n        \"\"\"Uncaught exceptions get logged by the IOLoop.\"\"\"\n        # Use a NullContext to keep the exception from being caught by\n        # AsyncTestCase.\n        with NullContext():\n            self.io_loop.add_callback(lambda: 1 / 0)\n            self.io_loop.add_callback(self.stop)\n            with ExpectLog(app_log, \"Exception in callback\"):\n                self.wait()",
        "begin_line": 382,
        "end_line": 390,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_exception_logging_future#392",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_exception_logging_future(self)",
        "snippet": "    def test_exception_logging_future(self):\n        \"\"\"The IOLoop examines exceptions from Futures and logs them.\"\"\"\n        with NullContext():\n            @gen.coroutine\n            def callback():\n                self.io_loop.add_callback(self.stop)\n                1 / 0\n            self.io_loop.add_callback(callback)\n            with ExpectLog(app_log, \"Exception in callback\"):\n                self.wait()",
        "begin_line": 392,
        "end_line": 401,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.callback#396",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.callback()",
        "snippet": "            def callback():\n                self.io_loop.add_callback(self.stop)\n                1 / 0",
        "begin_line": 396,
        "end_line": 398,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_exception_logging_native_coro#404",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_exception_logging_native_coro(self)",
        "snippet": "    def test_exception_logging_native_coro(self):\n        \"\"\"The IOLoop examines exceptions from awaitables and logs them.\"\"\"\n        namespace = exec_test(globals(), locals(), \"\"\"\n        async def callback():\n            self.io_loop.add_callback(self.stop)\n            1 / 0\n        \"\"\")\n        with NullContext():\n            self.io_loop.add_callback(namespace[\"callback\"])\n            with ExpectLog(app_log, \"Exception in callback\"):\n                self.wait()",
        "begin_line": 404,
        "end_line": 414,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_spawn_callback#416",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_spawn_callback(self)",
        "snippet": "    def test_spawn_callback(self):\n        # An added callback runs in the test's stack_context, so will be\n        # re-raised in wait().\n        self.io_loop.add_callback(lambda: 1 / 0)\n        with self.assertRaises(ZeroDivisionError):\n            self.wait()\n        # A spawned callback is run directly on the IOLoop, so it will be\n        # logged without stopping the test.\n        self.io_loop.spawn_callback(lambda: 1 / 0)\n        self.io_loop.add_callback(self.stop)\n        with ExpectLog(app_log, \"Exception in callback\"):\n            self.wait()",
        "begin_line": 416,
        "end_line": 427,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.test_remove_handler_from_handler#430",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.test_remove_handler_from_handler(self)",
        "snippet": "    def test_remove_handler_from_handler(self):\n        # Create two sockets with simultaneous read events.\n        client, server = socket.socketpair()\n        try:\n            client.send(b'abc')\n            server.send(b'abc')\n\n            # After reading from one fd, remove the other from the IOLoop.\n            chunks = []\n\n            def handle_read(fd, events):\n                chunks.append(fd.recv(1024))\n                if fd is client:\n                    self.io_loop.remove_handler(server)\n                else:\n                    self.io_loop.remove_handler(client)\n            self.io_loop.add_handler(client, handle_read, self.io_loop.READ)\n            self.io_loop.add_handler(server, handle_read, self.io_loop.READ)\n            self.io_loop.call_later(0.1, self.stop)\n            self.wait()\n\n            # Only one fd was read; the other was cleanly removed.\n            self.assertEqual(chunks, [b'abc'])\n        finally:\n            client.close()\n            server.close()",
        "begin_line": 430,
        "end_line": 455,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoop.handle_read#440",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoop",
        "signature": "tornado.test.ioloop_test.TestIOLoop.handle_read(fd, events)",
        "snippet": "            def handle_read(fd, events):\n                chunks.append(fd.recv(1024))\n                if fd is client:\n                    self.io_loop.remove_handler(server)\n                else:\n                    self.io_loop.remove_handler(client)",
        "begin_line": 440,
        "end_line": 445,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrent.setUp#461",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrent",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrent.setUp(self)",
        "snippet": "    def setUp(self):\n        self.io_loop = None\n        IOLoop.clear_current()",
        "begin_line": 461,
        "end_line": 463,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrent.tearDown#465",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrent",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrent.tearDown(self)",
        "snippet": "    def tearDown(self):\n        if self.io_loop is not None:\n            self.io_loop.close()",
        "begin_line": 465,
        "end_line": 467,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrent.test_default_current#469",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrent",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrent.test_default_current(self)",
        "snippet": "    def test_default_current(self):\n        self.io_loop = IOLoop()\n        # The first IOLoop with default arguments is made current.\n        self.assertIs(self.io_loop, IOLoop.current())\n        # A second IOLoop can be created but is not made current.\n        io_loop2 = IOLoop()\n        self.assertIs(self.io_loop, IOLoop.current())\n        io_loop2.close()",
        "begin_line": 469,
        "end_line": 476,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrent.test_non_current#478",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrent",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrent.test_non_current(self)",
        "snippet": "    def test_non_current(self):\n        self.io_loop = IOLoop(make_current=False)\n        # The new IOLoop is not initially made current.\n        self.assertIsNone(IOLoop.current(instance=False))\n        # Starting the IOLoop makes it current, and stopping the loop\n        # makes it non-current. This process is repeatable.\n        for i in range(3):\n            def f():\n                self.current_io_loop = IOLoop.current()\n                self.io_loop.stop()\n            self.io_loop.add_callback(f)\n            self.io_loop.start()\n            self.assertIs(self.current_io_loop, self.io_loop)\n            # Now that the loop is stopped, it is no longer current.\n            self.assertIsNone(IOLoop.current(instance=False))",
        "begin_line": 478,
        "end_line": 492,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrent.f#485",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrent",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrent.f()",
        "snippet": "            def f():\n                self.current_io_loop = IOLoop.current()\n                self.io_loop.stop()",
        "begin_line": 485,
        "end_line": 487,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopCurrent.test_force_current#494",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopCurrent",
        "signature": "tornado.test.ioloop_test.TestIOLoopCurrent.test_force_current(self)",
        "snippet": "    def test_force_current(self):\n        self.io_loop = IOLoop(make_current=True)\n        self.assertIs(self.io_loop, IOLoop.current())\n        with self.assertRaises(RuntimeError):\n            # A second make_current=True construction cannot succeed.\n            IOLoop(make_current=True)\n        # current() was not affected by the failed construction.\n        self.assertIs(self.io_loop, IOLoop.current())",
        "begin_line": 494,
        "end_line": 501,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.setUp#505",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.setUp(self)",
        "snippet": "    def setUp(self):\n        super(TestIOLoopAddCallback, self).setUp()\n        self.active_contexts = []",
        "begin_line": 505,
        "end_line": 507,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.add_callback#509",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.add_callback(self, callback, *args, **kwargs)",
        "snippet": "    def add_callback(self, callback, *args, **kwargs):\n        self.io_loop.add_callback(callback, *args, **kwargs)",
        "begin_line": 509,
        "end_line": 510,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.context#513",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.context(self, name)",
        "snippet": "    def context(self, name):\n        self.active_contexts.append(name)\n        yield\n        self.assertEqual(self.active_contexts.pop(), name)",
        "begin_line": 513,
        "end_line": 516,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.test_pre_wrap#518",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.test_pre_wrap(self)",
        "snippet": "    def test_pre_wrap(self):\n        # A pre-wrapped callback is run in the context in which it was\n        # wrapped, not when it was added to the IOLoop.\n        def f1():\n            self.assertIn('c1', self.active_contexts)\n            self.assertNotIn('c2', self.active_contexts)\n            self.stop()\n\n        with StackContext(functools.partial(self.context, 'c1')):\n            wrapped = wrap(f1)\n\n        with StackContext(functools.partial(self.context, 'c2')):\n            self.add_callback(wrapped)\n\n        self.wait()",
        "begin_line": 518,
        "end_line": 532,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.f1#521",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.f1()",
        "snippet": "        def f1():\n            self.assertIn('c1', self.active_contexts)\n            self.assertNotIn('c2', self.active_contexts)\n            self.stop()",
        "begin_line": 521,
        "end_line": 524,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.test_pre_wrap_with_args#534",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.test_pre_wrap_with_args(self)",
        "snippet": "    def test_pre_wrap_with_args(self):\n        # Same as test_pre_wrap, but the function takes arguments.\n        # Implementation note: The function must not be wrapped in a\n        # functools.partial until after it has been passed through\n        # stack_context.wrap\n        def f1(foo, bar):\n            self.assertIn('c1', self.active_contexts)\n            self.assertNotIn('c2', self.active_contexts)\n            self.stop((foo, bar))\n\n        with StackContext(functools.partial(self.context, 'c1')):\n            wrapped = wrap(f1)\n\n        with StackContext(functools.partial(self.context, 'c2')):\n            self.add_callback(wrapped, 1, bar=2)\n\n        result = self.wait()\n        self.assertEqual(result, (1, 2))",
        "begin_line": 534,
        "end_line": 551,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallback.f1#539",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallback",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallback.f1(foo, bar)",
        "snippet": "        def f1(foo, bar):\n            self.assertIn('c1', self.active_contexts)\n            self.assertNotIn('c2', self.active_contexts)\n            self.stop((foo, bar))",
        "begin_line": 539,
        "end_line": 542,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopAddCallbackFromSignal.add_callback#556",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopAddCallbackFromSignal",
        "signature": "tornado.test.ioloop_test.TestIOLoopAddCallbackFromSignal.add_callback(self, callback, *args, **kwargs)",
        "snippet": "    def add_callback(self, callback, *args, **kwargs):\n        self.io_loop.add_callback_from_signal(callback, *args, **kwargs)",
        "begin_line": 556,
        "end_line": 557,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.test_add_future_threads#562",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.test_add_future_threads(self)",
        "snippet": "    def test_add_future_threads(self):\n        with futures.ThreadPoolExecutor(1) as pool:\n            self.io_loop.add_future(pool.submit(lambda: None),\n                                    lambda future: self.stop(future))\n            future = self.wait()\n            self.assertTrue(future.done())\n            self.assertTrue(future.result() is None)",
        "begin_line": 562,
        "end_line": 568,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.test_add_future_stack_context#570",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.test_add_future_stack_context(self)",
        "snippet": "    def test_add_future_stack_context(self):\n        ready = threading.Event()\n\n        def task():\n            # we must wait for the ioloop callback to be scheduled before\n            # the task completes to ensure that add_future adds the callback\n            # asynchronously (which is the scenario in which capturing\n            # the stack_context matters)\n            ready.wait(1)\n            assert ready.isSet(), \"timed out\"\n            raise Exception(\"worker\")\n\n        def callback(future):\n            self.future = future\n            raise Exception(\"callback\")\n\n        def handle_exception(typ, value, traceback):\n            self.exception = value\n            self.stop()\n            return True\n\n        # stack_context propagates to the ioloop callback, but the worker\n        # task just has its exceptions caught and saved in the Future.\n        with futures.ThreadPoolExecutor(1) as pool:\n            with ExceptionStackContext(handle_exception):\n                self.io_loop.add_future(pool.submit(task), callback)\n            ready.set()\n        self.wait()\n\n        self.assertEqual(self.exception.args[0], \"callback\")\n        self.assertEqual(self.future.exception().args[0], \"worker\")",
        "begin_line": 570,
        "end_line": 600,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.task#573",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.task()",
        "snippet": "        def task():\n            # we must wait for the ioloop callback to be scheduled before\n            # the task completes to ensure that add_future adds the callback\n            # asynchronously (which is the scenario in which capturing\n            # the stack_context matters)\n            ready.wait(1)\n            assert ready.isSet(), \"timed out\"\n            raise Exception(\"worker\")",
        "begin_line": 573,
        "end_line": 580,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.callback#582",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.callback(future)",
        "snippet": "        def callback(future):\n            self.future = future\n            raise Exception(\"callback\")",
        "begin_line": 582,
        "end_line": 584,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.handle_exception#586",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.handle_exception(typ, value, traceback)",
        "snippet": "        def handle_exception(typ, value, traceback):\n            self.exception = value\n            self.stop()\n            return True",
        "begin_line": 586,
        "end_line": 589,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.test_run_in_executor_gen#603",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.test_run_in_executor_gen(self)",
        "snippet": "    def test_run_in_executor_gen(self):\n        event1 = threading.Event()\n        event2 = threading.Event()\n\n        def sync_func(self_event, other_event):\n            self_event.set()\n            other_event.wait()\n            # Note that return value doesn't actually do anything,\n            # it is just passed through to our final assertion to\n            # make sure it is passed through properly.\n            return self_event\n\n        # Run two synchronous functions, which would deadlock if not\n        # run in parallel.\n        res = yield [\n            IOLoop.current().run_in_executor(None, sync_func, event1, event2),\n            IOLoop.current().run_in_executor(None, sync_func, event2, event1)\n        ]\n\n        self.assertEqual([event1, event2], res)",
        "begin_line": 603,
        "end_line": 622,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.sync_func#607",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.sync_func(self_event, other_event)",
        "snippet": "        def sync_func(self_event, other_event):\n            self_event.set()\n            other_event.wait()\n            # Note that return value doesn't actually do anything,\n            # it is just passed through to our final assertion to\n            # make sure it is passed through properly.\n            return self_event",
        "begin_line": 607,
        "end_line": 613,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.test_run_in_executor_native#626",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.test_run_in_executor_native(self)",
        "snippet": "    def test_run_in_executor_native(self):\n        event1 = threading.Event()\n        event2 = threading.Event()\n\n        def sync_func(self_event, other_event):\n            self_event.set()\n            other_event.wait()\n            return self_event\n\n        # Go through an async wrapper to ensure that the result of\n        # run_in_executor works with await and not just gen.coroutine\n        # (simply passing the underlying concurrrent future would do that).\n        namespace = exec_test(globals(), locals(), \"\"\"\n            async def async_wrapper(self_event, other_event):\n                return await IOLoop.current().run_in_executor(\n                    None, sync_func, self_event, other_event)\n        \"\"\")\n\n        res = yield [\n            namespace[\"async_wrapper\"](event1, event2),\n            namespace[\"async_wrapper\"](event2, event1)\n            ]\n\n        self.assertEqual([event1, event2], res)",
        "begin_line": 626,
        "end_line": 649,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.sync_func#630",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.sync_func(self_event, other_event)",
        "snippet": "        def sync_func(self_event, other_event):\n            self_event.set()\n            other_event.wait()\n            return self_event",
        "begin_line": 630,
        "end_line": 633,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.test_set_default_executor#652",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.test_set_default_executor(self)",
        "snippet": "    def test_set_default_executor(self):\n        count = [0]\n\n        class MyExecutor(futures.ThreadPoolExecutor):\n            def submit(self, func, *args):\n                count[0] += 1\n                return super(MyExecutor, self).submit(func, *args)\n\n        event = threading.Event()\n\n        def sync_func():\n            event.set()\n\n        executor = MyExecutor(1)\n        loop = IOLoop.current()\n        loop.set_default_executor(executor)\n        yield loop.run_in_executor(None, sync_func)\n        self.assertEqual(1, count[0])\n        self.assertTrue(event.is_set())",
        "begin_line": 652,
        "end_line": 670,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.MyExecutor.test_set_default_executor#652",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.MyExecutor",
        "signature": "tornado.test.ioloop_test.MyExecutor.test_set_default_executor(self)",
        "snippet": "    def test_set_default_executor(self):\n        count = [0]\n\n        class MyExecutor(futures.ThreadPoolExecutor):\n            def submit(self, func, *args):\n                count[0] += 1\n                return super(MyExecutor, self).submit(func, *args)\n\n        event = threading.Event()\n\n        def sync_func():\n            event.set()\n\n        executor = MyExecutor(1)\n        loop = IOLoop.current()\n        loop.set_default_executor(executor)\n        yield loop.run_in_executor(None, sync_func)\n        self.assertEqual(1, count[0])\n        self.assertTrue(event.is_set())",
        "begin_line": 652,
        "end_line": 670,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.MyExecutor.submit#656",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.MyExecutor",
        "signature": "tornado.test.ioloop_test.MyExecutor.submit(self, func, *args)",
        "snippet": "            def submit(self, func, *args):\n                count[0] += 1\n                return super(MyExecutor, self).submit(func, *args)",
        "begin_line": 656,
        "end_line": 658,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopFutures.sync_func#662",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopFutures",
        "signature": "tornado.test.ioloop_test.TestIOLoopFutures.sync_func()",
        "snippet": "        def sync_func():\n            event.set()",
        "begin_line": 662,
        "end_line": 663,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.setUp#674",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.setUp(self)",
        "snippet": "    def setUp(self):\n        self.io_loop = IOLoop()",
        "begin_line": 674,
        "end_line": 675,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.tearDown#677",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.tearDown(self)",
        "snippet": "    def tearDown(self):\n        self.io_loop.close()",
        "begin_line": 677,
        "end_line": 678,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_sync_result#680",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_sync_result(self)",
        "snippet": "    def test_sync_result(self):\n        with self.assertRaises(gen.BadYieldError):\n            self.io_loop.run_sync(lambda: 42)",
        "begin_line": 680,
        "end_line": 682,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_sync_exception#684",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_sync_exception(self)",
        "snippet": "    def test_sync_exception(self):\n        with self.assertRaises(ZeroDivisionError):\n            self.io_loop.run_sync(lambda: 1 / 0)",
        "begin_line": 684,
        "end_line": 686,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_async_result#688",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_async_result(self)",
        "snippet": "    def test_async_result(self):\n        @gen.coroutine\n        def f():\n            yield gen.Task(self.io_loop.add_callback)\n            raise gen.Return(42)\n        self.assertEqual(self.io_loop.run_sync(f), 42)",
        "begin_line": 688,
        "end_line": 693,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.f#690",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.f()",
        "snippet": "        def f():\n            yield gen.Task(self.io_loop.add_callback)\n            raise gen.Return(42)",
        "begin_line": 690,
        "end_line": 692,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_async_exception#695",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_async_exception(self)",
        "snippet": "    def test_async_exception(self):\n        @gen.coroutine\n        def f():\n            yield gen.Task(self.io_loop.add_callback)\n            1 / 0\n        with self.assertRaises(ZeroDivisionError):\n            self.io_loop.run_sync(f)",
        "begin_line": 695,
        "end_line": 701,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.f#697",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.f()",
        "snippet": "        def f():\n            yield gen.Task(self.io_loop.add_callback)\n            1 / 0",
        "begin_line": 697,
        "end_line": 699,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_current#703",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_current(self)",
        "snippet": "    def test_current(self):\n        def f():\n            self.assertIs(IOLoop.current(), self.io_loop)\n        self.io_loop.run_sync(f)",
        "begin_line": 703,
        "end_line": 706,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.f#704",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.f()",
        "snippet": "        def f():\n            self.assertIs(IOLoop.current(), self.io_loop)",
        "begin_line": 704,
        "end_line": 705,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_timeout#708",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_timeout(self)",
        "snippet": "    def test_timeout(self):\n        @gen.coroutine\n        def f():\n            yield gen.Task(self.io_loop.add_timeout, self.io_loop.time() + 1)\n        self.assertRaises(TimeoutError, self.io_loop.run_sync, f, timeout=0.01)",
        "begin_line": 708,
        "end_line": 712,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.f#710",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.f()",
        "snippet": "        def f():\n            yield gen.Task(self.io_loop.add_timeout, self.io_loop.time() + 1)",
        "begin_line": 710,
        "end_line": 711,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopRunSync.test_native_coroutine#715",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopRunSync",
        "signature": "tornado.test.ioloop_test.TestIOLoopRunSync.test_native_coroutine(self)",
        "snippet": "    def test_native_coroutine(self):\n        namespace = exec_test(globals(), locals(), \"\"\"\n        async def f():\n            await gen.Task(self.io_loop.add_callback)\n        \"\"\")\n        self.io_loop.run_sync(namespace['f'])",
        "begin_line": 715,
        "end_line": 720,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.setUp#724",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.setUp(self)",
        "snippet": "    def setUp(self):\n        self.io_loop = FakeTimeIOLoop()\n        self.io_loop.make_current()",
        "begin_line": 724,
        "end_line": 726,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.tearDown#728",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.tearDown(self)",
        "snippet": "    def tearDown(self):\n        self.io_loop.close()",
        "begin_line": 728,
        "end_line": 729,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.test_basic#731",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.test_basic(self)",
        "snippet": "    def test_basic(self):\n        calls = []\n\n        def cb():\n            calls.append(self.io_loop.time())\n        pc = PeriodicCallback(cb, 10000)\n        pc.start()\n        self.io_loop.call_later(50, self.io_loop.stop)\n        self.io_loop.start()\n        self.assertEqual(calls, [1010, 1020, 1030, 1040, 1050])",
        "begin_line": 731,
        "end_line": 740,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.cb#734",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.cb()",
        "snippet": "        def cb():\n            calls.append(self.io_loop.time())",
        "begin_line": 734,
        "end_line": 735,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.test_overrun#742",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.test_overrun(self)",
        "snippet": "    def test_overrun(self):\n        sleep_durations = [9, 9, 10, 11, 20, 20, 35, 35, 0, 0]\n        expected = [\n            1010, 1020, 1030,  # first 3 calls on schedule\n            1050, 1070,  # next 2 delayed one cycle\n            1100, 1130,  # next 2 delayed 2 cycles\n            1170, 1210,  # next 2 delayed 3 cycles\n            1220, 1230,  # then back on schedule.\n        ]\n        calls = []\n\n        def cb():\n            calls.append(self.io_loop.time())\n            if not sleep_durations:\n                self.io_loop.stop()\n                return\n            self.io_loop.sleep(sleep_durations.pop(0))\n        pc = PeriodicCallback(cb, 10000)\n        pc.start()\n        self.io_loop.start()\n        self.assertEqual(calls, expected)",
        "begin_line": 742,
        "end_line": 762,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestPeriodicCallback.cb#753",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestPeriodicCallback",
        "signature": "tornado.test.ioloop_test.TestPeriodicCallback.cb()",
        "snippet": "        def cb():\n            calls.append(self.io_loop.time())\n            if not sleep_durations:\n                self.io_loop.stop()\n                return\n            self.io_loop.sleep(sleep_durations.pop(0))",
        "begin_line": 753,
        "end_line": 758,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopConfiguration.run_python#766",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopConfiguration",
        "signature": "tornado.test.ioloop_test.TestIOLoopConfiguration.run_python(self, *statements)",
        "snippet": "    def run_python(self, *statements):\n        statements = [\n            'from tornado.ioloop import IOLoop, PollIOLoop',\n            'classname = lambda x: x.__class__.__name__',\n        ] + list(statements)\n        args = [sys.executable, '-c', '; '.join(statements)]\n        return native_str(subprocess.check_output(args)).strip()",
        "begin_line": 766,
        "end_line": 772,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_default#774",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopConfiguration",
        "signature": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_default(self)",
        "snippet": "    def test_default(self):\n        if asyncio is not None:\n            # When asyncio is available, it is used by default.\n            cls = self.run_python('print(classname(IOLoop.current()))')\n            self.assertEqual(cls, 'AsyncIOMainLoop')\n            cls = self.run_python('print(classname(IOLoop()))')\n            self.assertEqual(cls, 'AsyncIOLoop')\n        else:\n            # Otherwise, the default is a subclass of PollIOLoop\n            is_poll = self.run_python(\n                'print(isinstance(IOLoop.current(), PollIOLoop))')\n            self.assertEqual(is_poll, 'True')",
        "begin_line": 774,
        "end_line": 785,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_explicit_select#787",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopConfiguration",
        "signature": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_explicit_select(self)",
        "snippet": "    def test_explicit_select(self):\n        # SelectIOLoop can always be configured explicitly.\n        default_class = self.run_python(\n            'IOLoop.configure(\"tornado.platform.select.SelectIOLoop\")',\n            'print(classname(IOLoop.current()))')\n        self.assertEqual(default_class, 'SelectIOLoop')",
        "begin_line": 787,
        "end_line": 792,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_asyncio#795",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopConfiguration",
        "signature": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_asyncio(self)",
        "snippet": "    def test_asyncio(self):\n        cls = self.run_python(\n            'IOLoop.configure(\"tornado.platform.asyncio.AsyncIOLoop\")',\n            'print(classname(IOLoop.current()))')\n        self.assertEqual(cls, 'AsyncIOMainLoop')",
        "begin_line": 795,
        "end_line": 799,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_asyncio_main#802",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopConfiguration",
        "signature": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_asyncio_main(self)",
        "snippet": "    def test_asyncio_main(self):\n        cls = self.run_python(\n            'from tornado.platform.asyncio import AsyncIOMainLoop',\n            'AsyncIOMainLoop().install()',\n            'print(classname(IOLoop.current()))')\n        self.assertEqual(cls, 'AsyncIOMainLoop')",
        "begin_line": 802,
        "end_line": 807,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_twisted#810",
        "src_path": "tornado/test/ioloop_test.py",
        "class_name": "tornado.test.ioloop_test.TestIOLoopConfiguration",
        "signature": "tornado.test.ioloop_test.TestIOLoopConfiguration.test_twisted(self)",
        "snippet": "    def test_twisted(self):\n        cls = self.run_python(\n            'from tornado.platform.twisted import TwistedIOLoop',\n            'TwistedIOLoop().install()',\n            'print(classname(IOLoop.current()))')\n        self.assertEqual(cls, 'TwistedIOLoop')",
        "begin_line": 810,
        "end_line": 815,
        "comment": "",
        "is_bug": false
    }
]