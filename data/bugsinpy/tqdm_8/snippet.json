[
    {
        "name": "tqdm._main.cast#8",
        "src_path": "tqdm/_main.py",
        "class_name": "tqdm._main",
        "signature": "tqdm._main.cast(val, typ)",
        "snippet": "def cast(val, typ):\n    if typ == 'bool':\n        # sys.stderr.write('\\ndebug | `val:type`: `' + val + ':' + typ + '`.\\n')\n        if (val == 'True') or (val == ''):\n            return True\n        elif val == 'False':\n            return False\n        else:\n            raise ValueError(val + ' : ' + typ)\n\n    return eval(typ + '(\"' + val + '\")')",
        "begin_line": 8,
        "end_line": 18,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.0031545741324921135,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._main.main#28",
        "src_path": "tqdm/_main.py",
        "class_name": "tqdm._main",
        "signature": "tqdm._main.main()",
        "snippet": "def main():\n    d = tqdm.__init__.__doc__\n\n    opt_types = dict(RE_OPTS.findall(d))\n\n    for o in UNSUPPORTED_OPTS:\n        opt_types.pop(o)\n\n    # d = RE_OPTS.sub(r'  --\\1=<\\1>  : \\2', d)\n    split = RE_OPTS.split(d)\n    opt_types_desc = zip(split[1::3], split[2::3], split[3::3])\n    d = ''.join('\\n  --{0}=<{0}>  : {1}{2}'.format(*otd)\n                for otd in opt_types_desc if otd[0] not in UNSUPPORTED_OPTS)\n\n    __doc__ = \"\"\"Usage:\n  tqdm [--help | options]\n\nOptions:\n  -h, --help     Print this help and exit\n  -v, --version  Print version and exit\n\n\"\"\" + d.strip('\\n') + '\\n'\n\n    # opts = docopt(__doc__, version=__version__)\n    if any(v in sys.argv for v in ('-v', '--version')):\n        sys.stdout.write(__version__ + '\\n')\n        sys.exit(0)\n    elif any(v in sys.argv for v in ('-h', '--help')):\n        sys.stdout.write(__doc__ + '\\n')\n        sys.exit(0)\n\n    argv = re.split('\\s*(--\\S+)[=\\s]*', ' '.join(sys.argv[1:]))\n    opts = dict(zip(argv[1::2], argv[2::2]))\n\n    tqdm_args = {}\n    try:\n        for (o, v) in opts.items():\n            tqdm_args[o[2:]] = cast(v, opt_types[o[2:]])\n        # sys.stderr.write('\\ndebug | args: ' + str(tqdm_args) + '\\n')\n        for i in tqdm(sys.stdin, **tqdm_args):\n            sys.stdout.write(i)\n    except:  # pragma: no cover\n        sys.stderr.write('\\nError:\\nUsage:\\n  tqdm [--help | options]\\n')\n        for i in sys.stdin:\n            sys.stdout.write(i)\n        raise",
        "begin_line": 28,
        "end_line": 73,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.0031545741324921135,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._tqdm_pandas.tqdm_pandas#10",
        "src_path": "tqdm/_tqdm_pandas.py",
        "class_name": "tqdm._tqdm_pandas",
        "signature": "tqdm._tqdm_pandas.tqdm_pandas(t)",
        "snippet": "def tqdm_pandas(t):  # pragma: no cover\n    \"\"\"\n    Registers the given `tqdm` instance with\n    `pandas.core.groupby.DataFrameGroupBy.progress_apply`.\n    It will even close() the `tqdm` instance upon completion.\n\n    Examples\n    --------\n    >>> import pandas as pd\n    >>> import numpy as np\n    >>> from tqdm import tqdm, tqdm_pandas\n    >>>\n    >>> df = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))\n    >>> tqdm_pandas(tqdm())  # can use tqdm_gui, optional kwargs, etc\n    >>> # Now you can use `progress_apply` instead of `apply`\n    >>> df.groupby(0).progress_apply(lambda x: x**2)\n\n    References\n    ----------\n    https://stackoverflow.com/questions/18603270/\n    progress-indicator-during-pandas-operations-python\n    \"\"\"\n    from pandas.core.groupby import DataFrameGroupBy\n\n    def inner(groups, func, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        groups  : DataFrameGroupBy\n            Grouped data.\n        func  : function\n            To be applied on the grouped data.\n\n        *args and *kwargs are transmitted to DataFrameGroupBy.apply()\n        \"\"\"\n        t.total = len(groups) + 1  # pandas calls update once too many\n\n        def wrapper(*args, **kwargs):\n            t.update()\n            return func(*args, **kwargs)\n\n        result = groups.apply(wrapper, *args, **kwargs)\n\n        t.close()\n\n        return result\n\n    # Enable custom tqdm progress in pandas!\n    DataFrameGroupBy.progress_apply = inner",
        "begin_line": 10,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.022222222222222223,
            "pseudo_dstar_susp": 0.004524886877828055,
            "pseudo_tarantula_susp": 0.09090909090909091,
            "pseudo_op2_susp": 0.004524886877828055,
            "pseudo_barinel_susp": 0.09090909090909091
        }
    },
    {
        "name": "tqdm._tqdm_pandas.inner#34",
        "src_path": "tqdm/_tqdm_pandas.py",
        "class_name": "tqdm._tqdm_pandas",
        "signature": "tqdm._tqdm_pandas.inner(groups, func, *args, **kwargs)",
        "snippet": "    def inner(groups, func, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        groups  : DataFrameGroupBy\n            Grouped data.\n        func  : function\n            To be applied on the grouped data.\n\n        *args and *kwargs are transmitted to DataFrameGroupBy.apply()\n        \"\"\"\n        t.total = len(groups) + 1  # pandas calls update once too many\n\n        def wrapper(*args, **kwargs):\n            t.update()\n            return func(*args, **kwargs)\n\n        result = groups.apply(wrapper, *args, **kwargs)\n\n        t.close()\n\n        return result",
        "begin_line": 34,
        "end_line": 55,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.2,
            "pseudo_dstar_susp": 0.007142857142857143,
            "pseudo_tarantula_susp": 0.09090909090909091,
            "pseudo_op2_susp": 0.007142857142857143,
            "pseudo_barinel_susp": 0.09090909090909091
        }
    },
    {
        "name": "tqdm._tqdm_pandas.wrapper#47",
        "src_path": "tqdm/_tqdm_pandas.py",
        "class_name": "tqdm._tqdm_pandas",
        "signature": "tqdm._tqdm_pandas.wrapper(*args, **kwargs)",
        "snippet": "        def wrapper(*args, **kwargs):\n            t.update()\n            return func(*args, **kwargs)",
        "begin_line": 47,
        "end_line": 49,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.2,
            "pseudo_dstar_susp": 0.007142857142857143,
            "pseudo_tarantula_susp": 0.09090909090909091,
            "pseudo_op2_susp": 0.007142857142857143,
            "pseudo_barinel_susp": 0.09090909090909091
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.format_sizeof#32",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.format_sizeof(num, suffix='')",
        "snippet": "    def format_sizeof(num, suffix=''):\n        \"\"\"\n        Formats a number (greater than unity) with SI Order of Magnitude\n        prefixes.\n\n        Parameters\n        ----------\n        num  : float\n            Number ( >= 1) to format.\n        suffix  : str, optional\n            Post-postfix [default: ''].\n\n        Returns\n        -------\n        out  : str\n            Number with Order of Magnitude SI unit postfix.\n        \"\"\"\n        for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n            if abs(num) < 999.95:\n                if abs(num) < 99.95:\n                    if abs(num) < 9.995:\n                        return '{0:1.2f}'.format(num) + unit + suffix\n                    return '{0:2.1f}'.format(num) + unit + suffix\n                return '{0:3.0f}'.format(num) + unit + suffix\n            num /= 1000.0\n        return '{0:3.1f}Y'.format(num) + suffix",
        "begin_line": 32,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.022222222222222223,
            "pseudo_dstar_susp": 0.004524886877828055,
            "pseudo_tarantula_susp": 0.09090909090909091,
            "pseudo_op2_susp": 0.004524886877828055,
            "pseudo_barinel_susp": 0.09090909090909091
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.format_interval#60",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.format_interval(t)",
        "snippet": "    def format_interval(t):\n        \"\"\"\n        Formats a number of seconds as a clock time, [H:]MM:SS\n\n        Parameters\n        ----------\n        t  : int\n            Number of seconds.\n        Returns\n        -------\n        out  : str\n            [H:]MM:SS\n        \"\"\"\n        mins, s = divmod(int(t), 60)\n        h, m = divmod(mins, 60)\n        if h:\n            return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n        else:\n            return '{0:02d}:{1:02d}'.format(m, s)",
        "begin_line": 60,
        "end_line": 78,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012048192771084338,
            "pseudo_dstar_susp": 0.022727272727272728,
            "pseudo_tarantula_susp": 0.00980392156862745,
            "pseudo_op2_susp": 0.022727272727272728,
            "pseudo_barinel_susp": 0.00980392156862745
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.status_printer#81",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.status_printer(file)",
        "snippet": "    def status_printer(file):\n        \"\"\"\n        Manage the printing and in-place updating of a line of characters.\n        Note that if the string is longer than a line, then in-place\n        updating may not work (it will print a new line at each refresh).\n        \"\"\"\n        fp = file\n        if not getattr(fp, 'flush', False):  # pragma: no cover\n            fp.flush = lambda: None\n\n        def fp_write(s):\n            fp.write(_unicode(s))\n\n        last_printed_len = [0]  # closure over mutable variable (fast)\n\n        def print_status(s):\n            len_s = len(s)\n            fp_write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n            fp.flush()\n            last_printed_len[0] = len_s\n        return print_status",
        "begin_line": 81,
        "end_line": 101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007142857142857143,
            "pseudo_dstar_susp": 0.01098901098901099,
            "pseudo_tarantula_susp": 0.0049504950495049506,
            "pseudo_op2_susp": 0.01098901098901099,
            "pseudo_barinel_susp": 0.0049504950495049506
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.fp_write#91",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.fp_write(s)",
        "snippet": "        def fp_write(s):\n            fp.write(_unicode(s))",
        "begin_line": 91,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.025,
            "pseudo_dstar_susp": 1.0,
            "pseudo_tarantula_susp": 0.005988023952095809,
            "pseudo_op2_susp": 1.0,
            "pseudo_barinel_susp": 0.005988023952095809
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.print_status#96",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.print_status(s)",
        "snippet": "        def print_status(s):\n            len_s = len(s)\n            fp_write('\\r' + s + (' ' * max(last_printed_len[0] - len_s, 0)))\n            fp.flush()\n            last_printed_len[0] = len_s",
        "begin_line": 96,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0196078431372549,
            "pseudo_dstar_susp": 0.5,
            "pseudo_tarantula_susp": 0.0049504950495049506,
            "pseudo_op2_susp": 0.5,
            "pseudo_barinel_susp": 0.0049504950495049506
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.format_meter#104",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None)",
        "snippet": "    def format_meter(n, total, elapsed, ncols=None, prefix='',\n                     ascii=False, unit='it', unit_scale=False, rate=None,\n                     bar_format=None):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n\n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool, optional\n            If set, the number of iterations will printed with an\n            appropriate SI metric prefix (K = 10^3, M = 10^6, etc.)\n            [default: False].\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n\n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n\n        # sanity check: total\n        if total and n > total:\n            total = None\n\n        format_interval = tqdm.format_interval\n        elapsed_str = format_interval(elapsed)\n\n        # if unspecified, attempt to use rate = average speed\n        # (we allow manual override since predicting time is an arcane art)\n        if rate is None and elapsed:\n            rate = n / elapsed\n        inv_rate = 1 / rate if (rate and (rate < 1)) else None\n        format_sizeof = tqdm.format_sizeof\n        rate_fmt = ((format_sizeof(inv_rate if inv_rate else rate)\n                    if unit_scale else\n                    '{0:5.2f}'.format(inv_rate if inv_rate else rate))\n                    if rate else '?') \\\n            + ('s' if inv_rate else unit) + '/' + (unit if inv_rate else 's')\n\n        if unit_scale:\n            n_fmt = format_sizeof(n)\n            total_fmt = format_sizeof(total) if total else None\n        else:\n            n_fmt = str(n)\n            total_fmt = str(total)\n\n        # total is known: we can predict some stats\n        if total:\n            # fractional and percentage progress\n            frac = n / total\n            percentage = frac * 100\n\n            remaining_str = format_interval((total - n) / rate) \\\n                if rate else '?'\n\n            # format the stats displayed to the left and right sides of the bar\n            l_bar = (prefix if prefix else '') + \\\n                '{0:3.0f}%|'.format(percentage)\n            r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                    n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt)\n\n            if ncols == 0:\n                return l_bar[:-1] + r_bar[1:]\n\n            if bar_format:\n                # Custom bar formatting\n                # Populate a dict with all available progress indicators\n                bar_args = {'n': n,\n                            'n_fmt': n_fmt,\n                            'total': total,\n                            'total_fmt': total_fmt,\n                            'percentage': percentage,\n                            'rate': rate if inv_rate is None else inv_rate,\n                            'rate_noinv': rate,\n                            'rate_noinv_fmt': ((format_sizeof(rate)\n                                                    if unit_scale else\n                                                    '{0:5.2f}'.format(rate))\n                                                    if rate else '?') + 'it/s',\n                            'rate_fmt': rate_fmt,\n                            'elapsed': elapsed_str,\n                            'remaining': remaining_str,\n                            'l_bar': l_bar,\n                            'r_bar': r_bar,\n                            'desc': prefix if prefix else '',\n                            # 'bar': full_bar  # replaced by procedure below\n                            }\n\n                # Interpolate supplied bar format with the dict\n                if '{bar}' in bar_format:\n                    # Format left/right sides of the bar, and format the bar\n                    # later in the remaining space (avoid breaking display)\n                    l_bar_user, r_bar_user = bar_format.split('{bar}')\n                    l_bar, r_bar = l_bar.format(**bar_args), r_bar.format(**bar_args)\n                else:\n                    # Else no progress bar, we can just format and return\n                    return bar_format.format(**bar_args)\n\n            # Formatting progress bar\n            # space available for bar's display\n            N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n                else 10\n\n            # format bar depending on availability of unicode/ascii chars\n            if ascii:\n                bar_length, frac_bar_length = divmod(\n                    int(frac * N_BARS * 10), 10)\n\n                bar = '#' * bar_length\n                frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                    else ' '\n\n            else:\n                bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n                bar = _unich(0x2588) * bar_length\n                frac_bar = _unich(0x2590 - frac_bar_length) \\\n                    if frac_bar_length else ' '\n\n            # whitespace padding\n            if bar_length < N_BARS:\n                full_bar = bar + frac_bar + \\\n                    ' ' * max(N_BARS - bar_length - 1, 0)\n            else:\n                full_bar = bar + \\\n                    ' ' * max(N_BARS - bar_length, 0)\n\n            # Piece together the bar parts\n            return l_bar + full_bar + r_bar\n\n        # no total: no progressbar, ETA, just progress stats\n        else:\n            return (prefix if prefix else '') + '{0}{1} [{2}, {3}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt)",
        "begin_line": 104,
        "end_line": 265,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 1.0,
            "pseudo_dstar_susp": 0.14285714285714285,
            "pseudo_tarantula_susp": 0.5,
            "pseudo_op2_susp": 0.14285714285714285,
            "pseudo_barinel_susp": 0.5
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.__new__#267",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.__new__(cls, *args, **kwargs)",
        "snippet": "    def __new__(cls, *args, **kwargs):\n        # Create a new instance\n        instance = object.__new__(cls)\n        # Add to the list of instances\n        if \"_instances\" not in cls.__dict__:\n            cls._instances = WeakSet()\n        cls._instances.add(instance)\n        # Return the instance\n        return instance",
        "begin_line": 267,
        "end_line": 275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005555555555555556,
            "pseudo_dstar_susp": 0.007751937984496124,
            "pseudo_tarantula_susp": 0.004149377593360996,
            "pseudo_op2_susp": 0.007751937984496124,
            "pseudo_barinel_susp": 0.004149377593360996
        }
    },
    {
        "name": "tqdm._tqdm.tqdm._get_free_pos#278",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm._get_free_pos(cls, instance=None)",
        "snippet": "    def _get_free_pos(cls, instance=None):\n        \"\"\" Skips specified instance \"\"\"\n        try:\n            return max(inst.pos for inst in cls._instances\n                       if inst is not instance) + 1\n        except ValueError as e:\n            if \"arg is an empty sequence\" in str(e):\n                return 0\n            raise  # pragma: no cover",
        "begin_line": 278,
        "end_line": 286,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.018867924528301886,
            "pseudo_dstar_susp": 0.25,
            "pseudo_tarantula_susp": 0.004149377593360996,
            "pseudo_op2_susp": 0.25,
            "pseudo_barinel_susp": 0.004149377593360996
        }
    },
    {
        "name": "tqdm._tqdm.tqdm._decr_instances#289",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm._decr_instances(cls, instance)",
        "snippet": "    def _decr_instances(cls, instance):\n        \"\"\"\n        Remove from list and reposition other bars\n        so that newer bars won't overlap previous bars\n        \"\"\"\n        try:  # in case instance was explicitly positioned, it won't be in set\n            cls._instances.remove(instance)\n            for inst in cls._instances:\n                if inst.pos > instance.pos:\n                    inst.pos -= 1\n        except KeyError:\n            pass",
        "begin_line": 289,
        "end_line": 300,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009523809523809525,
            "pseudo_dstar_susp": 0.017241379310344827,
            "pseudo_tarantula_susp": 0.005988023952095809,
            "pseudo_op2_susp": 0.017241379310344827,
            "pseudo_barinel_susp": 0.005988023952095809
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.write#303",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.write(cls, s, file=sys.stdout, end='\\n')",
        "snippet": "    def write(cls, s, file=sys.stdout, end=\"\\n\"):\n        \"\"\"\n        Print a message via tqdm (without overlap with bars)\n        \"\"\"\n        # Clear all bars\n        inst_cleared = []\n        for inst in cls._instances:\n            # Clear instance if in the target output file\n            # or if write output + tqdm output are both either\n            # sys.stdout or sys.stderr (because both are mixed in terminal)\n            if inst.fp == file or \\\n              (file in [sys.stdout, sys.stderr] and\n               inst.fp in [sys.stdout, sys.stderr]):\n                inst.clear()\n                inst_cleared.append(inst)\n        # Write the message\n        file.write(s)\n        file.write(end)\n        # Force refresh display of bars we cleared\n        for inst in inst_cleared:\n            inst.refresh()",
        "begin_line": 303,
        "end_line": 323,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.0031545741324921135,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.__init__#326",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.__init__(self, iterable=None, desc=None, total=None, leave=True, file=sys.stderr, ncols=None, mininterval=0.1, maxinterval=10.0, miniters=None, ascii=None, disable=False, unit='it', unit_scale=False, dynamic_ncols=False, smoothing=0.3, bar_format=None, initial=0, position=None, gui=False, **kwargs)",
        "snippet": "    def __init__(self, iterable=None, desc=None, total=None, leave=True,\n                 file=sys.stderr, ncols=None, mininterval=0.1,\n                 maxinterval=10.0, miniters=None, ascii=None, disable=False,\n                 unit='it', unit_scale=False, dynamic_ncols=False,\n                 smoothing=0.3, bar_format=None, initial=0, position=None,\n                 gui=False, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar.\n        total  : int, optional\n            The number of expected iterations. If unspecified,\n            len(iterable) is used if possible. As a last resort, only basic\n            progress statistics are displayed (no ETA, no progressbar).\n            If `gui` is True and this parameter needs subsequent updating,\n            specify an initial arbitrary large positive integer,\n            e.g. int(9e9).\n        leave  : bool, optional\n            If [default: True], keeps all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            [default: sys.stderr]. Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If unspecified, attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress update interval, in seconds [default: 10.0].\n        miniters  : int, optional\n            Minimum progress update interval, in iterations.\n            If specified, will set `mininterval` to 0.\n        ascii  : bool, optional\n            If unspecified or False, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable  : bool, optional\n            Whether to disable the entire progressbar wrapper\n            [default: False].\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: it].\n        unit_scale  : bool, optional\n            If set, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False].\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float, optional\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            If unspecified, will use '{l_bar}{bar}{r_bar}', where l_bar is\n            '{desc}{percentage:3.0f}%|' and r_bar is\n            '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n            Possible vars: bar, n, n_fmt, total, total_fmt, percentage,\n            rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n        initial  : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        position  : int, optional\n            Specify the line offset to print this bar (starting from 0)\n            Automatic if unspecified.\n            Useful to manage multiple bars at once (eg, from threads).\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: False].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            return\n\n        if kwargs:\n            self.disable = True\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            raise (DeprecationWarning(\"nested is deprecated and\"\n                                      \" automated.\\nUse position instead\"\n                                      \" for manual control\")\n                   if \"nested\" in kwargs else\n                   Warning(\"Unknown argument(s): \" + str(kwargs)))\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:\n            if dynamic_ncols:  # pragma: no cover\n                dynamic_ncols = _environ_cols_wrapper()\n                ncols = dynamic_ncols(file)\n            else:  # pragma: no cover\n                ncols = _environ_cols_wrapper()(file)\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if bar_format and not ascii:\n            # Convert bar format into unicode since terminal uses unicode\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc + ': ' if desc else ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        self._time = time\n        self.bar_format = bar_format\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        self.pos = self._get_free_pos(self) if position is None else position\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            if self.pos:\n                self.moveto(self.pos)\n            self.sp(self.format_meter(self.n, total, 0,\n                    (dynamic_ncols(file) if dynamic_ncols else ncols),\n                    self.desc, ascii, unit, unit_scale, None, bar_format))\n            if self.pos:\n                self.moveto(-self.pos)\n\n        # Init the time counter\n        self.start_t = self.last_print_t = self._time()",
        "begin_line": 326,
        "end_line": 507,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009523809523809525,
            "pseudo_dstar_susp": 0.017241379310344827,
            "pseudo_tarantula_susp": 0.006329113924050633,
            "pseudo_op2_susp": 0.017241379310344827,
            "pseudo_barinel_susp": 0.006329113924050633
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.__len__#509",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.__len__(self)",
        "snippet": "    def __len__(self):\n        return len(self.iterable) if self.iterable else self.total",
        "begin_line": 509,
        "end_line": 510,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.002570694087403599,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.__enter__#512",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.__enter__(self)",
        "snippet": "    def __enter__(self):\n        return self",
        "begin_line": 512,
        "end_line": 513,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.0022026431718061676,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.__exit__#515",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.__exit__(self, *exc)",
        "snippet": "    def __exit__(self, *exc):\n        self.close()\n        return False",
        "begin_line": 515,
        "end_line": 517,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.0022026431718061676,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.__del__#519",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.__del__(self)",
        "snippet": "    def __del__(self):\n        self.close()",
        "begin_line": 519,
        "end_line": 520,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007142857142857143,
            "pseudo_dstar_susp": 0.01098901098901099,
            "pseudo_tarantula_susp": 0.0049504950495049506,
            "pseudo_op2_susp": 0.01098901098901099,
            "pseudo_barinel_susp": 0.0049504950495049506
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.__repr__#522",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return self.format_meter(self.n, self.total,\n                                 time() - self.last_print_t,\n                                 self.ncols, self.desc, self.ascii, self.unit,\n                                 self.unit_scale, 1 / self.avg_time\n                                 if self.avg_time else None, self.bar_format)",
        "begin_line": 522,
        "end_line": 527,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.0023752969121140144,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.__lt__#529",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.__lt__(self, other)",
        "snippet": "    def __lt__(self, other):\n        # try:\n        return self.pos < other.pos",
        "begin_line": 529,
        "end_line": 531,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.0031545741324921135,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.__le__#535",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.__le__(self, other)",
        "snippet": "    def __le__(self, other):\n        return (self < other) or (self == other)",
        "begin_line": 535,
        "end_line": 536,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.0031545741324921135,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.__eq__#538",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        # try:\n        return self.pos == other.pos",
        "begin_line": 538,
        "end_line": 540,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0058823529411764705,
            "pseudo_dstar_susp": 0.008403361344537815,
            "pseudo_tarantula_susp": 0.004329004329004329,
            "pseudo_op2_susp": 0.008403361344537815,
            "pseudo_barinel_susp": 0.004329004329004329
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.__ne__#544",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.__ne__(self, other)",
        "snippet": "    def __ne__(self, other):\n        return not (self == other)",
        "begin_line": 544,
        "end_line": 545,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.0031545741324921135,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.__gt__#547",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.__gt__(self, other)",
        "snippet": "    def __gt__(self, other):\n        return not (self <= other)",
        "begin_line": 547,
        "end_line": 548,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.0031545741324921135,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.__ge__#550",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.__ge__(self, other)",
        "snippet": "    def __ge__(self, other):\n        return not (self < other)",
        "begin_line": 550,
        "end_line": 551,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.0031545741324921135,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.__hash__#553",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.__hash__(self)",
        "snippet": "    def __hash__(self):\n        return id(self)",
        "begin_line": 553,
        "end_line": 554,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005555555555555556,
            "pseudo_dstar_susp": 0.007751937984496124,
            "pseudo_tarantula_susp": 0.004149377593360996,
            "pseudo_op2_susp": 0.007751937984496124,
            "pseudo_barinel_susp": 0.004149377593360996
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.__iter__#556",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.__iter__(self)",
        "snippet": "    def __iter__(self):\n        ''' Backward-compatibility to use: for x in tqdm(iterable) '''\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            ncols = self.ncols\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            unit = self.unit\n            unit_scale = self.unit_scale\n            ascii = self.ascii\n            start_t = self.start_t\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            dynamic_ncols = self.dynamic_ncols\n            smoothing = self.smoothing\n            avg_time = self.avg_time\n            bar_format = self.bar_format\n            _time = self._time\n            format_meter = self.format_meter\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise DeprecationWarning('Please use tqdm_gui(...)'\n                                         ' instead of tqdm(..., gui=True)')\n\n            for obj in iterable:\n                yield obj\n                # Update and print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                # check the counter first (avoid calls to time())\n                if n - last_print_n >= miniters:\n                    delta_it = n - last_print_n\n                    cur_t = _time()\n                    delta_t = cur_t - last_print_t\n                    if delta_t >= mininterval:\n                        elapsed = cur_t - start_t\n                        # EMA (not just overall average)\n                        if smoothing and delta_t:\n                            avg_time = delta_t / delta_it \\\n                                if avg_time is None \\\n                                else smoothing * delta_t / delta_it + \\\n                                (1 - smoothing) * avg_time\n\n                        if self.pos:\n                            self.moveto(self.pos)\n\n                        # Printing the bar's update\n                        sp(format_meter(\n                            n, self.total, elapsed,\n                            (dynamic_ncols(self.fp) if dynamic_ncols\n                             else ncols),\n                            self.desc, ascii, unit, unit_scale,\n                            1 / avg_time if avg_time else None, bar_format))\n\n                        if self.pos:\n                            self.moveto(-self.pos)\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the maximum iteration rate seen so far.\n                        if dynamic_miniters:\n                            if maxinterval and delta_t > maxinterval:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                            elif mininterval and delta_t:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * mininterval \\\n                                    / delta_t + (1 - smoothing) * miniters\n                            else:\n                                miniters = smoothing * delta_it + \\\n                                    (1 - smoothing) * miniters\n\n                        # Store old values for next call\n                        self.n = self.last_print_n = last_print_n = n\n                        self.last_print_t = last_print_t = cur_t\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.close()",
        "begin_line": 556,
        "end_line": 649,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00510204081632653,
            "pseudo_dstar_susp": 0.005847953216374269,
            "pseudo_tarantula_susp": 0.011904761904761904,
            "pseudo_op2_susp": 0.005847953216374269,
            "pseudo_barinel_susp": 0.011904761904761904
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.update#651",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.update(self, n=1)",
        "snippet": "    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        if self.disable:\n            return\n\n        if n < 0:\n            raise ValueError(\"n ({0}) cannot be negative\".format(n))\n        self.n += n\n\n        delta_it = self.n - self.last_print_n  # should be n?\n        if delta_it >= self.miniters:\n            # We check the counter first, to reduce the overhead of time()\n            cur_t = self._time()\n            delta_t = cur_t - self.last_print_t\n            if delta_t >= self.mininterval:\n                elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t:\n                    self.avg_time = delta_t / delta_it \\\n                        if self.avg_time is None \\\n                        else self.smoothing * delta_t / delta_it + \\\n                        (1 - self.smoothing) * self.avg_time\n\n                if not hasattr(self, \"sp\"):\n                    raise DeprecationWarning('Please use tqdm_gui(...)'\n                                             ' instead of tqdm(..., gui=True)')\n\n                if self.pos:\n                    self.moveto(self.pos)\n\n                # Print bar's update\n                self.sp(self.format_meter(\n                    self.n, self.total, elapsed,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale,\n                    1 / self.avg_time if self.avg_time else None,\n                    self.bar_format))\n\n                if self.pos:\n                    self.moveto(-self.pos)\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t > self.maxinterval:\n                        self.miniters = self.miniters * self.maxinterval \\\n                            / delta_t\n                    elif self.mininterval and delta_t:\n                        self.miniters = self.smoothing * delta_it \\\n                            * self.mininterval / delta_t + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = self.smoothing * delta_it + \\\n                            (1 - self.smoothing) * self.miniters\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t",
        "begin_line": 651,
        "end_line": 730,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003861003861003861,
            "pseudo_dstar_susp": 0.003861003861003861,
            "pseudo_tarantula_susp": 0.003861003861003861,
            "pseudo_op2_susp": 0.003861003861003861,
            "pseudo_barinel_susp": 0.003861003861003861
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.close#732",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.close(self)",
        "snippet": "    def close(self):\n        \"\"\"\n        Cleanup and (if leave=False) close the progressbar.\n        \"\"\"\n        if self.disable:\n            return\n\n        # Prevent multiple closures\n        self.disable = True\n\n        # decrement instance pos and remove from internal set\n        pos = self.pos\n        self._decr_instances(self)\n\n        # GUI mode\n        if not hasattr(self, \"sp\"):\n            return\n\n        # annoyingly, _supports_unicode isn't good enough\n        def fp_write(s):\n            self.fp.write(_unicode(s))\n\n        try:\n            fp_write('')\n        except ValueError as e:\n            if 'closed' in str(e):\n                return\n            raise  # pragma: no cover\n\n        if pos:\n            self.moveto(pos)\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                cur_t = self._time()\n                # stats for overall rate (no weighted average)\n                self.sp(self.format_meter(\n                    self.n, self.total, cur_t - self.start_t,\n                    (self.dynamic_ncols(self.fp) if self.dynamic_ncols\n                     else self.ncols),\n                    self.desc, self.ascii, self.unit, self.unit_scale, None,\n                    self.bar_format))\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\n')\n        else:\n            self.sp('')  # clear up last bar\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\r')",
        "begin_line": 732,
        "end_line": 783,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010416666666666666,
            "pseudo_dstar_susp": 0.02040816326530612,
            "pseudo_tarantula_susp": 0.013513513513513514,
            "pseudo_op2_susp": 0.02040816326530612,
            "pseudo_barinel_susp": 0.013513513513513514
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.fp_write#751",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.fp_write(s)",
        "snippet": "        def fp_write(s):\n            self.fp.write(_unicode(s))",
        "begin_line": 751,
        "end_line": 752,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.025,
            "pseudo_dstar_susp": 1.0,
            "pseudo_tarantula_susp": 0.005988023952095809,
            "pseudo_op2_susp": 1.0,
            "pseudo_barinel_susp": 0.005988023952095809
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.unpause#785",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.unpause(self)",
        "snippet": "    def unpause(self):\n        \"\"\"\n        Restart tqdm timer from last print time.\n        \"\"\"\n        cur_t = self._time()\n        self.start_t += cur_t - self.last_print_t\n        self.last_print_t = cur_t",
        "begin_line": 785,
        "end_line": 791,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.0031545741324921135,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.set_description#793",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.set_description(self, desc=None)",
        "snippet": "    def set_description(self, desc=None):\n        \"\"\"\n        Set/modify description of the progress bar.\n        \"\"\"\n        self.desc = desc + ': ' if desc else ''",
        "begin_line": 793,
        "end_line": 797,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.0031545741324921135,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.moveto#799",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.moveto(self, n)",
        "snippet": "    def moveto(self, n):\n        self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))",
        "begin_line": 799,
        "end_line": 800,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.002257336343115124,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.clear#802",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.clear(self, nomove=False)",
        "snippet": "    def clear(self, nomove=False):\n        \"\"\"\n        Clear current bar display\n        \"\"\"\n        if not nomove:\n            self.moveto(self.pos)\n        # clear up the bar (can't rely on sp(''))\n        self.fp.write('\\r')\n        self.fp.write(' ' * (self.ncols if self.ncols else 10))\n        self.fp.write('\\r')  # place cursor back at the beginning of line\n        if not nomove:\n            self.moveto(-self.pos)",
        "begin_line": 802,
        "end_line": 813,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.002570694087403599,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._tqdm.tqdm.refresh#815",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm.tqdm",
        "signature": "tqdm._tqdm.tqdm.refresh(self)",
        "snippet": "    def refresh(self):\n        \"\"\"\n        Force refresh the display of this bar\n        \"\"\"\n        self.moveto(self.pos)\n        # clear up this line's content (whatever there was)\n        self.clear(nomove=True)\n        # Print current/last bar state\n        self.fp.write(self.__repr__())\n        self.moveto(-self.pos)",
        "begin_line": 815,
        "end_line": 824,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.002570694087403599,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._tqdm.trange#827",
        "src_path": "tqdm/_tqdm.py",
        "class_name": "tqdm._tqdm",
        "signature": "tqdm._tqdm.trange(*args, **kwargs)",
        "snippet": "def trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)",
        "begin_line": 827,
        "end_line": 832,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.015384615384615385,
            "pseudo_dstar_susp": 0.006211180124223602,
            "pseudo_tarantula_susp": 0.02,
            "pseudo_op2_susp": 0.006211180124223602,
            "pseudo_barinel_susp": 0.02
        }
    },
    {
        "name": "tqdm._utils._is_utf#34",
        "src_path": "tqdm/_utils.py",
        "class_name": "tqdm._utils",
        "signature": "tqdm._utils._is_utf(encoding)",
        "snippet": "def _is_utf(encoding):\n    return encoding.lower().startswith('utf-') or ('U8' == encoding)",
        "begin_line": 34,
        "end_line": 35,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.0031545741324921135,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._utils._supports_unicode#38",
        "src_path": "tqdm/_utils.py",
        "class_name": "tqdm._utils",
        "signature": "tqdm._utils._supports_unicode(file)",
        "snippet": "def _supports_unicode(file):\n    if not getattr(file, 'encoding', None):\n        return False\n    if not getattr(file, 'interface', None):  # pragma: no cover\n        # FakeStreams from things like bpython-curses can lie\n        return _is_utf(file.encoding)\n    return False  # pragma: no cover",
        "begin_line": 38,
        "end_line": 44,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00423728813559322,
            "pseudo_dstar_susp": 0.004739336492890996,
            "pseudo_tarantula_susp": 0.003937007874015748,
            "pseudo_op2_susp": 0.004739336492890996,
            "pseudo_barinel_susp": 0.003937007874015748
        }
    },
    {
        "name": "tqdm._utils._environ_cols_wrapper#47",
        "src_path": "tqdm/_utils.py",
        "class_name": "tqdm._utils",
        "signature": "tqdm._utils._environ_cols_wrapper()",
        "snippet": "def _environ_cols_wrapper():  # pragma: no cover\n    \"\"\"\n    Return a function which gets width and height of console\n    (linux,osx,windows,cygwin).\n    \"\"\"\n    import platform\n    current_os = platform.system()\n    _environ_cols = None\n    if current_os in ['Windows', 'cli']:\n        _environ_cols = _environ_cols_windows\n        if _environ_cols is None:\n            _environ_cols = _environ_cols_tput\n    if any(current_os.startswith(i) for i in\n           ['CYGWIN', 'MSYS', 'Linux', 'Darwin', 'SunOS', 'FreeBSD']):\n        _environ_cols = _environ_cols_linux\n    return _environ_cols",
        "begin_line": 47,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.002570694087403599,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._utils._environ_cols_linux#105",
        "src_path": "tqdm/_utils.py",
        "class_name": "tqdm._utils",
        "signature": "tqdm._utils._environ_cols_linux(fp)",
        "snippet": "def _environ_cols_linux(fp):  # pragma: no cover\n\n    # import os\n    # if fp is None:\n    #     try:\n    #         fp = os.open(os.ctermid(), os.O_RDONLY)\n    #     except:\n    #         pass\n    try:\n        from termios import TIOCGWINSZ\n        from fcntl import ioctl\n        from array import array\n    except ImportError:\n        return None\n    else:\n        try:\n            return array('h', ioctl(fp, TIOCGWINSZ, '\\0' * 8))[1]\n        except:\n            try:\n                from os.environ import get\n            except ImportError:\n                return None\n            else:\n                return int(get('COLUMNS', 1)) - 1",
        "begin_line": 105,
        "end_line": 128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.002570694087403599,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "tqdm._utils._term_move_up#131",
        "src_path": "tqdm/_utils.py",
        "class_name": "tqdm._utils",
        "signature": "tqdm._utils._term_move_up()",
        "snippet": "def _term_move_up():  # pragma: no cover\n    if os.name == 'nt':\n        if colorama is None:\n            return ''\n    return '\\x1b[A'",
        "begin_line": 131,
        "end_line": 135,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002702702702702703,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.002257336343115124,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    }
]