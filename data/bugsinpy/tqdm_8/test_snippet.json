[
    {
        "name": "tqdm.tests.tests_tqdm.closing#26",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.closing(arg)",
        "snippet": "    def closing(arg):\n        return arg",
        "begin_line": 26,
        "end_line": 27,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.DiscreteTimer.__init__#61",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm.DiscreteTimer",
        "signature": "tqdm.tests.tests_tqdm.DiscreteTimer.__init__(self)",
        "snippet": "    def __init__(self):\n        self.t = 0.0",
        "begin_line": 61,
        "end_line": 62,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.DiscreteTimer.sleep#64",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm.DiscreteTimer",
        "signature": "tqdm.tests.tests_tqdm.DiscreteTimer.sleep(self, t)",
        "snippet": "    def sleep(self, t):\n        '''Sleep = increment the time counter (almost no CPU used)'''\n        self.t += t",
        "begin_line": 64,
        "end_line": 66,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.DiscreteTimer.time#68",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm.DiscreteTimer",
        "signature": "tqdm.tests.tests_tqdm.DiscreteTimer.time(self)",
        "snippet": "    def time(self):\n        '''Get the current time'''\n        return self.t",
        "begin_line": 68,
        "end_line": 70,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.cpu_timify#73",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.cpu_timify(t, timer=None)",
        "snippet": "def cpu_timify(t, timer=None):\n    '''Force tqdm to use the specified timer instead of system-wide time()'''\n    if timer is None:\n        timer = DiscreteTimer()\n    t._time = timer.time\n    t.start_t = t.last_print_t = t._time()\n    return timer",
        "begin_line": 73,
        "end_line": 79,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.pretest#82",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.pretest()",
        "snippet": "def pretest():\n    if getattr(tqdm, \"_instances\", False):\n        n = len(tqdm._instances)\n        if n:\n            tqdm._instances.clear()\n            raise EnvironmentError(\n                \"{0} `tqdm` instances still in existence PRE-test\".format(n))",
        "begin_line": 82,
        "end_line": 88,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.posttest#91",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.posttest()",
        "snippet": "def posttest():\n    if getattr(tqdm, \"_instances\", False):\n        n = len(tqdm._instances)\n        if n:\n            tqdm._instances.clear()\n            raise EnvironmentError(\n                \"{0} `tqdm` instances still in existence POST-test\".format(n))",
        "begin_line": 91,
        "end_line": 97,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.UnicodeIO.__init__#103",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm.UnicodeIO",
        "signature": "tqdm.tests.tests_tqdm.UnicodeIO.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        super(UnicodeIO, self).__init__(*args, **kwargs)\n        self.encoding = 'U8'  # io.StringIO supports unicode, but no encoding\n        self.text = ''\n        self.cursor = 0",
        "begin_line": 103,
        "end_line": 107,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.UnicodeIO.seek#109",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm.UnicodeIO",
        "signature": "tqdm.tests.tests_tqdm.UnicodeIO.seek(self, offset)",
        "snippet": "    def seek(self, offset):\n        self.cursor = offset",
        "begin_line": 109,
        "end_line": 110,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.UnicodeIO.tell#112",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm.UnicodeIO",
        "signature": "tqdm.tests.tests_tqdm.UnicodeIO.tell(self)",
        "snippet": "    def tell(self):\n        return self.cursor",
        "begin_line": 112,
        "end_line": 113,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.UnicodeIO.write#115",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm.UnicodeIO",
        "signature": "tqdm.tests.tests_tqdm.UnicodeIO.write(self, s)",
        "snippet": "    def write(self, s):\n        self.text += s\n        self.cursor = len(self.text)",
        "begin_line": 115,
        "end_line": 117,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.UnicodeIO.read#119",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm.UnicodeIO",
        "signature": "tqdm.tests.tests_tqdm.UnicodeIO.read(self)",
        "snippet": "    def read(self):\n        return self.text[self.cursor:]",
        "begin_line": 119,
        "end_line": 120,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.UnicodeIO.getvalue#122",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm.UnicodeIO",
        "signature": "tqdm.tests.tests_tqdm.UnicodeIO.getvalue(self)",
        "snippet": "    def getvalue(self):\n        return self.text",
        "begin_line": 122,
        "end_line": 123,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.get_bar#126",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.get_bar(all_bars, i)",
        "snippet": "def get_bar(all_bars, i):\n    \"\"\" Get a specific update from a whole bar traceback \"\"\"\n    # Split according to any used control characters\n    bars_split = RE_ctrlchr_excl.split(all_bars)\n    bars_split = list(filter(None, bars_split))  # filter out empty splits\n    return bars_split[i]",
        "begin_line": 126,
        "end_line": 131,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.progressbar_rate#134",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.progressbar_rate(bar_str)",
        "snippet": "def progressbar_rate(bar_str):\n    return float(RE_rate.search(bar_str).group(1))",
        "begin_line": 134,
        "end_line": 135,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.squash_ctrlchars#138",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.squash_ctrlchars(s)",
        "snippet": "def squash_ctrlchars(s):\n    \"\"\" Apply control characters in a string just like a terminal display \"\"\"\n    # List of supported control codes\n    ctrlcodes = [r'\\r', r'\\n', r'\\x1b\\[A']\n\n    # Init variables\n    curline = 0  # current line in our fake terminal\n    lines = ['']  # state of our fake terminal\n\n    # Split input string by control codes\n    RE_ctrl = re.compile(\"(%s)\" % (\"|\".join(ctrlcodes)), flags=re.DOTALL)\n    s_split = RE_ctrl.split(s)\n    s_split = filter(None, s_split)  # filter out empty splits\n\n    # For each control character or message\n    for nextctrl in s_split:\n        # If it's a control character, apply it\n        if nextctrl == '\\r':\n            # Carriage return\n            # Go to the beginning of the line\n            # simplified here: we just empty the string\n            lines[curline] = ''\n        elif nextctrl == '\\n':\n            # Newline\n            # Go to the next line\n            if curline < (len(lines) - 1):\n                # If already exists, just move cursor\n                curline += 1\n            else:\n                # Else the new line is created\n                lines.append('')\n                curline += 1\n        elif nextctrl == '\\x1b[A':\n            # Move cursor up\n            if curline > 0:\n                curline -= 1\n            else:\n                raise ValueError(\"Cannot go up, anymore!\")\n        # Else, it is a message, we print it on current line\n        else:\n            lines[curline] += nextctrl\n\n    return lines",
        "begin_line": 138,
        "end_line": 180,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_format_interval#183",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_format_interval()",
        "snippet": "def test_format_interval():\n    \"\"\" Test time interval format \"\"\"\n    format_interval = tqdm.format_interval\n\n    assert format_interval(60) == '01:00'\n    assert format_interval(6160) == '1:42:40'\n    assert format_interval(238113) == '66:08:33'",
        "begin_line": 183,
        "end_line": 189,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_format_meter#192",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_format_meter()",
        "snippet": "def test_format_meter():\n    \"\"\" Test statistics and progress bar formatting \"\"\"\n    try:\n        unich = unichr\n    except NameError:\n        unich = chr\n\n    format_meter = tqdm.format_meter\n\n    assert format_meter(0, 1000, 13) == \\\n        \"  0%|          | 0/1000 [00:13<?, ?it/s]\"\n    assert format_meter(0, 1000, 13, ncols=68, prefix='desc: ') == \\\n        \"desc:   0%|                                | 0/1000 [00:13<?, ?it/s]\"\n    assert format_meter(231, 1000, 392) == \\\n        \" 23%|\" + unich(0x2588) * 2 + unich(0x258e) + \\\n        \"       | 231/1000 [06:32<21:44,  1.70s/it]\"\n    assert format_meter(10000, 1000, 13) == \\\n        \"10000it [00:13, 769.23it/s]\"\n    assert format_meter(231, 1000, 392, ncols=56, ascii=True) == \\\n        \" 23%|\" + '#' * 3 + '6' + \\\n        \"            | 231/1000 [06:32<21:44,  1.70s/it]\"\n    assert format_meter(100000, 1000, 13, unit_scale=True, unit='iB') == \\\n        \"100KiB [00:13, 7.69KiB/s]\"\n    assert format_meter(100, 1000, 12, ncols=0, rate=7.33) == \\\n        \" 10% 100/1000 [00:12<02:02,  7.33it/s]\"\n    # Check that bar_format correctly adapts {bar} size to the rest\n    assert format_meter(20, 100, 12, ncols=13, rate=8.1,\n                        bar_format=r'{l_bar}{bar}|{n_fmt}/{total_fmt}') == \\\n        \" 20%|\" + unich(0x258f) + \"|20/100\"\n    assert format_meter(20, 100, 12, ncols=14, rate=8.1,\n                        bar_format=r'{l_bar}{bar}|{n_fmt}/{total_fmt}') == \\\n        \" 20%|\" + unich(0x258d) + \" |20/100\"",
        "begin_line": 192,
        "end_line": 223,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_si_format#226",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_si_format()",
        "snippet": "def test_si_format():\n    \"\"\" Test SI unit prefixes \"\"\"\n    format_meter = tqdm.format_meter\n\n    assert '9.00 ' in format_meter(1, 9, 1, unit_scale=True, unit='B')\n    assert '99.0 ' in format_meter(1, 99, 1, unit_scale=True)\n    assert '999 ' in format_meter(1, 999, 1, unit_scale=True)\n    assert '9.99K ' in format_meter(1, 9994, 1, unit_scale=True)\n    assert '10.0K ' in format_meter(1, 9999, 1, unit_scale=True)\n    assert '99.5K ' in format_meter(1, 99499, 1, unit_scale=True)\n    assert '100K ' in format_meter(1, 99999, 1, unit_scale=True)\n    assert '1.00M ' in format_meter(1, 999999, 1, unit_scale=True)\n    assert '1.00G ' in format_meter(1, 999999999, 1, unit_scale=True)\n    assert '1.00T ' in format_meter(1, 999999999999, 1, unit_scale=True)\n    assert '1.00P ' in format_meter(1, 999999999999999, 1, unit_scale=True)\n    assert '1.00E ' in format_meter(1, 999999999999999999, 1, unit_scale=True)\n    assert '1.00Z ' in format_meter(1, 999999999999999999999, 1,\n                                    unit_scale=True)\n    assert '1.0Y ' in format_meter(1, 999999999999999999999999, 1,\n                                   unit_scale=True)\n    assert '10.0Y ' in format_meter(1, 9999999999999999999999999, 1,\n                                    unit_scale=True)\n    assert '100.0Y ' in format_meter(1, 99999999999999999999999999, 1,\n                                     unit_scale=True)\n    assert '1000.0Y ' in format_meter(1, 999999999999999999999999999, 1,\n                                      unit_scale=True)",
        "begin_line": 226,
        "end_line": 251,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_all_defaults#255",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_all_defaults()",
        "snippet": "def test_all_defaults():\n    \"\"\" Test default kwargs \"\"\"\n    with closing(UnicodeIO()) as our_file:\n        with tqdm(range(10), file=our_file) as progressbar:\n            assert len(progressbar) == 10\n            for _ in progressbar:\n                pass\n    # restore stdout/stderr output for `nosetest` interface\n    try:\n        sys.stderr.write('\\x1b[A')\n    except:\n        pass\n    sys.stderr.write('\\rTest default kwargs ... ')",
        "begin_line": 255,
        "end_line": 267,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_iterate_over_csv_rows#271",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_iterate_over_csv_rows()",
        "snippet": "def test_iterate_over_csv_rows():\n    \"\"\" Test csv iterator \"\"\"\n    # Create a test csv pseudo file\n    with closing(StringIO()) as test_csv_file:\n        writer = csv.writer(test_csv_file)\n        for _ in _range(3):\n            writer.writerow(['test'] * 3)\n        test_csv_file.seek(0)\n\n        # Test that nothing fails if we iterate over rows\n        reader = csv.DictReader(test_csv_file,\n                                fieldnames=('row1', 'row2', 'row3'))\n        with closing(StringIO()) as our_file:\n            for row in tqdm(reader, file=our_file):\n                pass",
        "begin_line": 271,
        "end_line": 285,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_file_output#289",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_file_output()",
        "snippet": "def test_file_output():\n    \"\"\" Test output to arbitrary file-like objects \"\"\"\n    with closing(StringIO()) as our_file:\n        for i in tqdm(_range(3), file=our_file):\n            if i == 1:\n                our_file.seek(0)\n                assert '0/3' in our_file.read()",
        "begin_line": 289,
        "end_line": 295,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_leave_option#299",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_leave_option()",
        "snippet": "def test_leave_option():\n    \"\"\" Test `leave=True` always prints info about the last iteration \"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(_range(3), file=our_file, leave=True):\n            pass\n        our_file.seek(0)\n        assert '| 3/3 ' in our_file.read()\n        our_file.seek(0)\n        assert '\\n' == our_file.read()[-1]  # not '\\r'\n\n    with closing(StringIO()) as our_file2:\n        for _ in tqdm(_range(3), file=our_file2, leave=False):\n            pass\n        our_file2.seek(0)\n        assert '| 3/3 ' not in our_file2.read()",
        "begin_line": 299,
        "end_line": 313,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_trange#317",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_trange()",
        "snippet": "def test_trange():\n    \"\"\" Test trange \"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in trange(3, file=our_file, leave=True):\n            pass\n        our_file.seek(0)\n        assert '| 3/3 ' in our_file.read()\n\n    with closing(StringIO()) as our_file2:\n        for _ in trange(3, file=our_file2, leave=False):\n            pass\n        our_file2.seek(0)\n        assert '| 3/3 ' not in our_file2.read()",
        "begin_line": 317,
        "end_line": 329,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_min_interval#333",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_min_interval()",
        "snippet": "def test_min_interval():\n    \"\"\" Test mininterval \"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(_range(3), file=our_file, mininterval=1e-10):\n            pass\n        our_file.seek(0)\n        assert \"  0%|          | 0/3 [00:00<\" in our_file.read()",
        "begin_line": 333,
        "end_line": 339,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_max_interval#343",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_max_interval()",
        "snippet": "def test_max_interval():\n    \"\"\" Test maxinterval \"\"\"\n    total = 100\n    bigstep = 10\n    smallstep = 5\n    timer = DiscreteTimer()\n\n    # Test without maxinterval\n    with closing(StringIO()) as our_file:\n        with closing(StringIO()) as our_file2:\n            # with maxinterval but higher than loop sleep time\n            t = tqdm(total=total, file=our_file, miniters=None, mininterval=0,\n                     smoothing=1, maxinterval=1e-2)\n            cpu_timify(t, timer)\n\n            # without maxinterval\n            t2 = tqdm(total=total, file=our_file2, miniters=None,\n                      mininterval=0, smoothing=1, maxinterval=None)\n            cpu_timify(t2, timer)\n\n            assert t.dynamic_miniters\n            assert t2.dynamic_miniters\n\n            # Increase 10 iterations at once\n            t.update(bigstep)\n            t2.update(bigstep)\n            # The next iterations should not trigger maxinterval (step 10)\n            for _ in _range(4):\n                t.update(smallstep)\n                t2.update(smallstep)\n                timer.sleep(1e-5)\n            t.close()  # because PyPy doesn't gc immediately\n            t2.close()  # as above\n\n            our_file2.seek(0)\n            assert \"25%\" not in our_file2.read()\n        our_file.seek(0)\n        assert \"25%\" not in our_file.read()\n\n    # Test with maxinterval effect\n    with closing(StringIO()) as our_file:\n        with tqdm(total=total, file=our_file, miniters=None, mininterval=0,\n                  smoothing=1, maxinterval=1e-4) as t:\n            cpu_timify(t, timer)\n\n            # Increase 10 iterations at once\n            t.update(bigstep)\n            # The next iterations should trigger maxinterval (step 5)\n            for _ in _range(4):\n                t.update(smallstep)\n                timer.sleep(1e-2)\n\n            our_file.seek(0)\n            assert \"25%\" in our_file.read()\n\n    # Test iteration based tqdm with maxinterval effect\n    with closing(StringIO()) as our_file:\n        with tqdm(_range(total), file=our_file, miniters=None,\n                  mininterval=1e-5, smoothing=1, maxinterval=1e-4) as t2:\n            cpu_timify(t2, timer)\n\n            for i in t2:\n                if i >= (bigstep - 1) and \\\n                   ((i - (bigstep - 1)) % smallstep) == 0:\n                    timer.sleep(1e-2)\n                if i >= 3 * bigstep:\n                    break\n\n        our_file.seek(0)\n        assert \"15%\" in our_file.read()",
        "begin_line": 343,
        "end_line": 412,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_min_iters#416",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_min_iters()",
        "snippet": "def test_min_iters():\n    \"\"\" Test miniters \"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(_range(3), file=our_file, leave=True, miniters=4):\n            our_file.write('blank\\n')\n        our_file.seek(0)\n        assert '\\nblank\\nblank\\n' in our_file.read()\n\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(_range(3), file=our_file, leave=True, miniters=1):\n            our_file.write('blank\\n')\n        our_file.seek(0)\n        # assume automatic mininterval = 0 means intermediate output\n        assert '| 3/3 ' in our_file.read()",
        "begin_line": 416,
        "end_line": 429,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_dynamic_min_iters#433",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_dynamic_min_iters()",
        "snippet": "def test_dynamic_min_iters():\n    \"\"\" Test purely dynamic miniters (and manual updates and __del__) \"\"\"\n    with closing(StringIO()) as our_file:\n        total = 10\n        t = tqdm(total=total, file=our_file, miniters=None, mininterval=0,\n                 smoothing=1)\n\n        t.update()\n        # Increase 3 iterations\n        t.update(3)\n        # The next two iterations should be skipped because of dynamic_miniters\n        t.update()\n        t.update()\n        # The third iteration should be displayed\n        t.update()\n\n        our_file.seek(0)\n        out = our_file.read()\n        assert t.dynamic_miniters\n        t.__del__()  # simulate immediate del gc\n\n    assert '  0%|          | 0/10 [00:00<' in out\n    assert '40%' in out\n    assert '50%' not in out\n    assert '60%' not in out\n    assert '70%' in out\n\n    with closing(StringIO()) as our_file:\n        t = tqdm(_range(10), file=our_file, miniters=None, mininterval=None)\n        for _ in t:\n            pass\n        assert t.dynamic_miniters\n\n    with closing(StringIO()) as our_file:\n        t = tqdm(_range(10), file=our_file, miniters=1, mininterval=None)\n        for _ in t:\n            pass\n        assert not t.dynamic_miniters",
        "begin_line": 433,
        "end_line": 470,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_big_min_interval#474",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_big_min_interval()",
        "snippet": "def test_big_min_interval():\n    \"\"\" Test large mininterval \"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(_range(2), file=our_file, mininterval=1E10):\n            pass\n        our_file.seek(0)\n        assert '50%' not in our_file.read()\n\n    with closing(StringIO()) as our_file:\n        with tqdm(_range(2), file=our_file, mininterval=1E10) as t:\n            t.update()\n            t.update()\n            our_file.seek(0)\n            assert '50%' not in our_file.read()",
        "begin_line": 474,
        "end_line": 487,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_smoothed_dynamic_min_iters#491",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_smoothed_dynamic_min_iters()",
        "snippet": "def test_smoothed_dynamic_min_iters():\n    \"\"\" Test smoothed dynamic miniters \"\"\"\n    timer = DiscreteTimer()\n\n    with closing(StringIO()) as our_file:\n        with tqdm(total=100, file=our_file, miniters=None, mininterval=0,\n                  smoothing=0.5, maxinterval=0) as t:\n            cpu_timify(t, timer)\n\n            # Increase 10 iterations at once\n            t.update(10)\n            # The next iterations should be partially skipped\n            for _ in _range(2):\n                t.update(4)\n            for _ in _range(20):\n                t.update()\n\n            our_file.seek(0)\n            out = our_file.read()\n            assert t.dynamic_miniters\n    assert '  0%|          | 0/100 [00:00<' in out\n    assert '10%' in out\n    assert '14%' not in out\n    assert '18%' in out\n    assert '20%' not in out\n    assert '25%' in out\n    assert '30%' not in out\n    assert '32%' in out",
        "begin_line": 491,
        "end_line": 518,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_smoothed_dynamic_min_iters_with_min_interval#522",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_smoothed_dynamic_min_iters_with_min_interval()",
        "snippet": "def test_smoothed_dynamic_min_iters_with_min_interval():\n    \"\"\" Test smoothed dynamic miniters with mininterval \"\"\"\n    timer = DiscreteTimer()\n\n    # In this test, `miniters` should gradually decline\n    total = 100\n\n    with closing(StringIO()) as our_file:\n        # Test manual updating tqdm\n        with tqdm(total=total, file=our_file, miniters=None, mininterval=1e-3,\n                  smoothing=1, maxinterval=0) as t:\n            cpu_timify(t, timer)\n\n            t.update(10)\n            timer.sleep(1e-2)\n            for _ in _range(4):\n                t.update()\n                timer.sleep(1e-2)\n            our_file.seek(0)\n            out = our_file.read()\n            assert t.dynamic_miniters\n\n    with closing(StringIO()) as our_file:\n        # Test iteration-based tqdm\n        with tqdm(_range(total), file=our_file, miniters=None,\n                  mininterval=0.01, smoothing=1, maxinterval=0) as t2:\n            cpu_timify(t2, timer)\n\n            for i in t2:\n                if i >= 10:\n                    timer.sleep(0.1)\n                if i >= 14:\n                    break\n            our_file.seek(0)\n            out2 = our_file.read()\n\n    assert t.dynamic_miniters\n    assert '  0%|          | 0/100 [00:00<' in out\n    assert '11%' in out and '11%' in out2\n    # assert '12%' not in out and '12%' in out2\n    assert '13%' in out and '13%' in out2\n    assert '14%' in out and '14%' in out2",
        "begin_line": 522,
        "end_line": 563,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_disable#567",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_disable()",
        "snippet": "def test_disable():\n    \"\"\" Test disable \"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(_range(3), file=our_file, disable=True):\n            pass\n        our_file.seek(0)\n        assert our_file.read() == ''\n\n    with closing(StringIO()) as our_file:\n        progressbar = tqdm(total=3, file=our_file, miniters=1, disable=True)\n        progressbar.update(3)\n        progressbar.close()\n        our_file.seek(0)\n        assert our_file.read() == ''",
        "begin_line": 567,
        "end_line": 580,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_unit#584",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_unit()",
        "snippet": "def test_unit():\n    \"\"\" Test SI unit prefix \"\"\"\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(_range(3), file=our_file, miniters=1, unit=\"bytes\"):\n            pass\n        our_file.seek(0)\n        assert 'bytes/s' in our_file.read()",
        "begin_line": 584,
        "end_line": 590,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_ascii#594",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_ascii()",
        "snippet": "def test_ascii():\n    \"\"\" Test ascii/unicode bar \"\"\"\n    # Test ascii autodetection\n    with closing(StringIO()) as our_file:\n        with tqdm(total=10, file=our_file, ascii=None) as t:\n            assert t.ascii  # TODO: this may fail in the future\n\n    # Test ascii bar\n    with closing(StringIO()) as our_file:\n        for _ in tqdm(_range(3), total=15, file=our_file, miniters=1,\n                      mininterval=0, ascii=True):\n            pass\n        our_file.seek(0)\n        res = our_file.read().strip(\"\\r\").split(\"\\r\")\n    assert '7%|6' in res[1]\n    assert '13%|#3' in res[2]\n    assert '20%|##' in res[3]\n\n    # Test unicode bar\n    with closing(UnicodeIO()) as our_file:\n        with tqdm(total=15, file=our_file, ascii=False, mininterval=0) as t:\n            for _ in _range(3):\n                t.update()\n        our_file.seek(0)\n        res = our_file.read().strip(\"\\r\").split(\"\\r\")\n    assert \"7%|\\u258b\" in res[1]\n    assert \"13%|\\u2588\\u258e\" in res[2]\n    assert \"20%|\\u2588\\u2588\" in res[3]",
        "begin_line": 594,
        "end_line": 621,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_update#625",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_update()",
        "snippet": "def test_update():\n    \"\"\" Test manual creation and updates \"\"\"\n    with closing(StringIO()) as our_file:\n        with tqdm(total=2, file=our_file, miniters=1, mininterval=0) \\\n                as progressbar:\n            assert len(progressbar) == 2\n            progressbar.update(2)\n            our_file.seek(0)\n            assert '| 2/2' in our_file.read()\n            progressbar.desc = 'dynamically notify of 4 increments in total'\n            progressbar.total = 4\n            try:\n                progressbar.update(-10)\n            except ValueError as e:\n                if str(e) != \"n (-10) cannot be negative\":\n                    raise\n                progressbar.update()  # should default to +1\n            else:\n                raise ValueError(\"Should not support negative updates\")\n            our_file.seek(0)\n            res = our_file.read()\n    assert '| 3/4 ' in res\n    assert 'dynamically notify of 4 increments in total' in res",
        "begin_line": 625,
        "end_line": 647,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_close#651",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_close()",
        "snippet": "def test_close():\n    \"\"\" Test manual creation and closure and n_instances \"\"\"\n\n    # With `leave` option\n    with closing(StringIO()) as our_file:\n        progressbar = tqdm(total=3, file=our_file, miniters=10)\n        progressbar.update(3)\n        assert '| 3/3 ' not in our_file.getvalue()  # Should be blank\n        assert len(tqdm._instances) == 1\n        progressbar.close()\n        assert len(tqdm._instances) == 0\n        assert '| 3/3 ' in our_file.getvalue()\n\n    # Without `leave` option\n    with closing(StringIO()) as our_file:\n        progressbar = tqdm(total=3, file=our_file, miniters=10, leave=False)\n        progressbar.update(3)\n        progressbar.close()\n        assert '| 3/3 ' not in our_file.getvalue()  # Should be blank\n\n    # With all updates\n    with closing(StringIO()) as our_file:\n        assert len(tqdm._instances) == 0\n        with tqdm(total=3, file=our_file, miniters=0, mininterval=0,\n                  leave=True) as progressbar:\n            assert len(tqdm._instances) == 1\n            progressbar.update(3)\n            res = our_file.getvalue()\n            assert '| 3/3 ' in res  # Should be blank\n        # close() called\n        assert len(tqdm._instances) == 0\n        our_file.seek(0)\n\n        exres = res + '\\n'\n        if exres != our_file.read():\n            our_file.seek(0)\n            raise AssertionError(\"\\nExpected:\\n{0}\\nGot:{1}\\n\".format(\n                exres, our_file.read()))\n\n    # Closing after the output stream has closed\n    with closing(StringIO()) as our_file:\n        t = tqdm(total=2, file=our_file)\n        t.update()\n        t.update()\n    t.close()",
        "begin_line": 651,
        "end_line": 695,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_smoothing#699",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_smoothing()",
        "snippet": "def test_smoothing():\n    \"\"\" Test exponential weighted average smoothing \"\"\"\n    timer = DiscreteTimer()\n\n    # -- Test disabling smoothing\n    with closing(StringIO()) as our_file:\n        with tqdm(_range(3), file=our_file, smoothing=None, leave=True) as t:\n            cpu_timify(t, timer)\n\n            for _ in t:\n                pass\n        our_file.seek(0)\n        assert '| 3/3 ' in our_file.read()\n\n    # -- Test smoothing\n    # Compile the regex to find the rate\n    # 1st case: no smoothing (only use average)\n    with closing(StringIO()) as our_file2:\n        with closing(StringIO()) as our_file:\n            t = tqdm(_range(3), file=our_file2, smoothing=None, leave=True,\n                     miniters=1, mininterval=0)\n            cpu_timify(t, timer)\n\n            with tqdm(_range(3), file=our_file, smoothing=None, leave=True,\n                      miniters=1, mininterval=0) as t2:\n                cpu_timify(t2, timer)\n\n                for i in t2:\n                    # Sleep more for first iteration and\n                    # see how quickly rate is updated\n                    if i == 0:\n                        timer.sleep(0.01)\n                    else:\n                        # Need to sleep in all iterations\n                        # to calculate smoothed rate\n                        # (else delta_t is 0!)\n                        timer.sleep(0.001)\n                    t.update()\n            n_old = len(tqdm._instances)\n            t.close()\n            assert len(tqdm._instances) == n_old - 1\n            # Get result for iter-based bar\n            a = progressbar_rate(get_bar(our_file.getvalue(), 3))\n        # Get result for manually updated bar\n        a2 = progressbar_rate(get_bar(our_file2.getvalue(), 3))\n\n    # 2nd case: use max smoothing (= instant rate)\n    with closing(StringIO()) as our_file2:\n        with closing(StringIO()) as our_file:\n            t = tqdm(_range(3), file=our_file2, smoothing=1, leave=True,\n                     miniters=1, mininterval=0)\n            cpu_timify(t, timer)\n\n            with tqdm(_range(3), file=our_file, smoothing=1, leave=True,\n                      miniters=1, mininterval=0) as t2:\n                cpu_timify(t2, timer)\n\n                for i in t2:\n                    if i == 0:\n                        timer.sleep(0.01)\n                    else:\n                        timer.sleep(0.001)\n                    t.update()\n            t.close()\n            # Get result for iter-based bar\n            b = progressbar_rate(get_bar(our_file.getvalue(), 3))\n        # Get result for manually updated bar\n        b2 = progressbar_rate(get_bar(our_file2.getvalue(), 3))\n\n    # 3rd case: use medium smoothing\n    with closing(StringIO()) as our_file2:\n        with closing(StringIO()) as our_file:\n            t = tqdm(_range(3), file=our_file2, smoothing=0.5, leave=True,\n                     miniters=1, mininterval=0)\n            cpu_timify(t, timer)\n\n            t2 = tqdm(_range(3), file=our_file, smoothing=0.5, leave=True,\n                      miniters=1, mininterval=0)\n            cpu_timify(t2, timer)\n\n            for i in t2:\n                if i == 0:\n                    timer.sleep(0.01)\n                else:\n                    timer.sleep(0.001)\n                t.update()\n            t2.close()\n            t.close()\n            # Get result for iter-based bar\n            c = progressbar_rate(get_bar(our_file.getvalue(), 3))\n        # Get result for manually updated bar\n        c2 = progressbar_rate(get_bar(our_file2.getvalue(), 3))\n\n    # Check that medium smoothing's rate is between no and max smoothing rates\n    assert a < c < b\n    assert a2 < c2 < b2",
        "begin_line": 699,
        "end_line": 794,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_deprecated_nested#798",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_deprecated_nested()",
        "snippet": "def test_deprecated_nested():\n    \"\"\" Test nested progress bars \"\"\"\n    if nt_and_no_colorama:\n        raise SkipTest\n    # TODO: test degradation on windows without colorama?\n\n    # Artificially test nested loop printing\n    # Without leave\n    our_file = StringIO()\n    try:\n        tqdm(total=2, file=our_file, nested=True)\n    except DeprecationWarning as e:\n        if str(e) != (\"nested is deprecated and automated.\\nUse position\"\n                      \" instead for manual control\"):\n            raise\n    else:\n        raise DeprecationWarning(\"Should not allow nested kwarg\")",
        "begin_line": 798,
        "end_line": 814,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_bar_format#818",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_bar_format()",
        "snippet": "def test_bar_format():\n    \"\"\" Test custom bar formatting \"\"\"\n    with closing(StringIO()) as our_file:\n        bar_format = r'{l_bar}{bar}|{n_fmt}/{total_fmt}-{n}/{total}{percentage}{rate}{rate_fmt}{elapsed}{remaining}'  # NOQA\n        for i in trange(2, file=our_file, leave=True, bar_format=bar_format):\n            pass\n        out = our_file.getvalue()\n    assert \"\\r  0%|          |0/2-0/20.0None?it/s00:00?\\r\" in out\n\n    # Test unicode string auto conversion\n    with closing(StringIO()) as our_file:\n        bar_format = r'hello world'\n        with tqdm(ascii=False, bar_format=bar_format, file=our_file) as t:\n            assert isinstance(t.bar_format, _unicode)",
        "begin_line": 818,
        "end_line": 831,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_unpause#835",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_unpause()",
        "snippet": "def test_unpause():\n    \"\"\" Test unpause \"\"\"\n    timer = DiscreteTimer()\n    with closing(StringIO()) as our_file:\n        t = trange(10, file=our_file, leave=True, mininterval=0)\n        cpu_timify(t, timer)\n        timer.sleep(0.01)\n        t.update()\n        timer.sleep(0.01)\n        t.update()\n        timer.sleep(0.1)  # longer wait time\n        t.unpause()\n        timer.sleep(0.01)\n        t.update()\n        timer.sleep(0.01)\n        t.update()\n        t.close()\n        r_before = progressbar_rate(get_bar(our_file.getvalue(), 2))\n        r_after = progressbar_rate(get_bar(our_file.getvalue(), 3))\n    assert r_before == r_after",
        "begin_line": 835,
        "end_line": 854,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_position#858",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_position()",
        "snippet": "def test_position():\n    \"\"\" Test positioned progress bars \"\"\"\n    if nt_and_no_colorama:\n        raise SkipTest\n\n    # Artificially test nested loop printing\n    # Without leave\n    our_file = StringIO()\n    t = tqdm(total=2, file=our_file, miniters=1, mininterval=0,\n             maxinterval=0, desc='pos2 bar', leave=False, position=2)\n    t.update()\n    t.close()\n    our_file.seek(0)\n    out = our_file.read()\n    res = [m[0] for m in RE_pos.findall(out)]\n    exres = ['\\n\\n\\rpos2 bar:   0%',\n             '\\x1b[A\\x1b[A\\n\\n\\rpos2 bar:  50%',\n             '\\x1b[A\\x1b[A\\n\\n\\r      ',\n             '\\x1b[A\\x1b[A']\n    if res != exres:\n        raise AssertionError(\"\\nExpected:\\n{0}\\nGot:\\n{1}\\nRaw:\\n{2}\\n\".format(\n            str(exres), str(res), str([out])))\n\n    # Test iteration-based tqdm positioning\n    our_file = StringIO()\n    for i in trange(2, file=our_file, miniters=1, mininterval=0,\n                    maxinterval=0, desc='pos0 bar', position=0):\n        for j in trange(2, file=our_file, miniters=1, mininterval=0,\n                        maxinterval=0, desc='pos1 bar', position=1):\n            for k in trange(2, file=our_file, miniters=1, mininterval=0,\n                            maxinterval=0, desc='pos2 bar', position=2):\n                pass\n    our_file.seek(0)\n    out = our_file.read()\n    res = [m[0] for m in RE_pos.findall(out)]\n    exres = ['\\rpos0 bar:   0%',\n             '\\n\\rpos1 bar:   0%',\n             '\\x1b[A\\n\\n\\rpos2 bar:   0%',\n             '\\x1b[A\\x1b[A\\n\\n\\rpos2 bar:  50%',\n             '\\x1b[A\\x1b[A\\n\\n\\rpos2 bar: 100%',\n             '\\x1b[A\\x1b[A\\n\\n\\x1b[A\\x1b[A\\n\\rpos1 bar:  50%',\n             '\\x1b[A\\n\\n\\rpos2 bar:   0%',\n             '\\x1b[A\\x1b[A\\n\\n\\rpos2 bar:  50%',\n             '\\x1b[A\\x1b[A\\n\\n\\rpos2 bar: 100%',\n             '\\x1b[A\\x1b[A\\n\\n\\x1b[A\\x1b[A\\n\\rpos1 bar: 100%',\n             '\\x1b[A\\n\\x1b[A\\rpos0 bar:  50%',\n             '\\n\\rpos1 bar:   0%',\n             '\\x1b[A\\n\\n\\rpos2 bar:   0%',\n             '\\x1b[A\\x1b[A\\n\\n\\rpos2 bar:  50%',\n             '\\x1b[A\\x1b[A\\n\\n\\rpos2 bar: 100%',\n             '\\x1b[A\\x1b[A\\n\\n\\x1b[A\\x1b[A\\n\\rpos1 bar:  50%',\n             '\\x1b[A\\n\\n\\rpos2 bar:   0%',\n             '\\x1b[A\\x1b[A\\n\\n\\rpos2 bar:  50%',\n             '\\x1b[A\\x1b[A\\n\\n\\rpos2 bar: 100%',\n             '\\x1b[A\\x1b[A\\n\\n\\x1b[A\\x1b[A\\n\\rpos1 bar: 100%',\n             '\\x1b[A\\n\\x1b[A\\rpos0 bar: 100%',\n             '\\n']\n    if res != exres:\n        raise AssertionError(\"\\nExpected:\\n{0}\\nGot:\\n{1}\\nRaw:\\n{2}\\n\".format(\n            str(exres), str(res), str([out])))\n\n    # Test manual tqdm positioning\n    our_file = StringIO()\n    t1 = tqdm(total=2, file=our_file, miniters=1, mininterval=0,\n              maxinterval=0, desc='pos0 bar', position=0)\n    t2 = tqdm(total=2, file=our_file, miniters=1, mininterval=0,\n              maxinterval=0, desc='pos1 bar', position=1)\n    t3 = tqdm(total=2, file=our_file, miniters=1, mininterval=0,\n              maxinterval=0, desc='pos2 bar', position=2)\n    for i in _range(2):\n        t1.update()\n        t3.update()\n        t2.update()\n    our_file.seek(0)\n    out = our_file.read()\n    res = [m[0] for m in RE_pos.findall(out)]\n    exres = ['\\rpos0 bar:   0%',\n             '\\n\\rpos1 bar:   0%',\n             '\\x1b[A\\n\\n\\rpos2 bar:   0%',\n             '\\x1b[A\\x1b[A\\rpos0 bar:  50%',\n             '\\n\\n\\rpos2 bar:  50%',\n             '\\x1b[A\\x1b[A\\n\\rpos1 bar:  50%',\n             '\\x1b[A\\rpos0 bar: 100%',\n             '\\n\\n\\rpos2 bar: 100%',\n             '\\x1b[A\\x1b[A\\n\\rpos1 bar: 100%',\n             '\\x1b[A']\n    if res != exres:\n        raise AssertionError(\"\\nExpected:\\n{0}\\nGot:\\n{1}\\nRaw:\\n{2}\\n\".format(\n            str(exres), str(res), str([out])))\n    t1.close()\n    t2.close()\n    t3.close()\n\n    # Test auto repositionning of bars when a bar is prematurely closed\n    # tqdm._instances.clear()  # reset number of instances\n    with closing(StringIO()) as our_file:\n        t1 = tqdm(total=10, file=our_file, desc='pos0 bar', mininterval=0)\n        t2 = tqdm(total=10, file=our_file, desc='pos1 bar', mininterval=0)\n        t3 = tqdm(total=10, file=our_file, desc='pos2 bar', mininterval=0)\n        res = [m[0] for m in RE_pos.findall(our_file.getvalue())]\n        exres = ['\\rpos0 bar:   0%',\n                 '\\n\\rpos1 bar:   0%',\n                 '\\x1b[A\\n\\n\\rpos2 bar:   0%',\n                 '\\x1b[A\\x1b[A']\n        if res != exres:\n            raise AssertionError(\n                \"\\nExpected:\\n{0}\\nGot:\\n{1}\\n\".format(\n                    str(exres), str(res)))\n\n        t2.close()\n        t4 = tqdm(total=10, file=our_file, desc='pos3 bar', mininterval=0)\n        t1.update(1)\n        t3.update(1)\n        t4.update(1)\n        res = [m[0] for m in RE_pos.findall(our_file.getvalue())]\n        exres = ['\\rpos0 bar:   0%',\n                 '\\n\\rpos1 bar:   0%',\n                 '\\x1b[A\\n\\n\\rpos2 bar:   0%',\n                 '\\x1b[A\\x1b[A\\n\\x1b[A\\n\\n\\rpos3 bar:   0%',\n                 '\\x1b[A\\x1b[A\\rpos0 bar:  10%',\n                 '\\n\\rpos2 bar:  10%',\n                 '\\x1b[A\\n\\n\\rpos3 bar:  10%',\n                 '\\x1b[A\\x1b[A']\n        if res != exres:\n            raise AssertionError(\n                \"\\nExpected:\\n{0}\\nGot:\\n{1}\\n\".format(\n                    str(exres), str(res)))\n        t4.close()\n        t3.close()\n        t1.close()",
        "begin_line": 858,
        "end_line": 987,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_set_description#991",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_set_description()",
        "snippet": "def test_set_description():\n    \"\"\" Test set description \"\"\"\n    with closing(StringIO()) as our_file:\n        with tqdm(desc='Hello', file=our_file) as t:\n            assert t.desc == 'Hello: '\n            t.set_description('World')\n            assert t.desc == 'World: '\n            t.set_description()\n            assert t.desc == ''",
        "begin_line": 991,
        "end_line": 999,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_deprecated_gui#1003",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_deprecated_gui()",
        "snippet": "def test_deprecated_gui():\n    \"\"\" Test internal GUI properties \"\"\"\n    # Check: StatusPrinter iff gui is disabled\n    with closing(StringIO()) as our_file:\n        t = tqdm(total=2, gui=True, file=our_file, miniters=1, mininterval=0)\n        assert not hasattr(t, \"sp\")\n        try:\n            t.update(1)\n        except DeprecationWarning as e:\n            if str(e) != ('Please use tqdm_gui(...) instead of'\n                          ' tqdm(..., gui=True)'):\n                raise\n        else:\n            raise DeprecationWarning('Should not allow manual gui=True without'\n                                     ' overriding __iter__() and update()')\n        finally:\n            t._instances.clear()\n            # t.close()\n            # len(tqdm._instances) += 1  # undo the close() decrement\n\n        t = tqdm(_range(3), gui=True, file=our_file,\n                 miniters=1, mininterval=0)\n        try:\n            for _ in t:\n                pass\n        except DeprecationWarning as e:\n            if str(e) != ('Please use tqdm_gui(...) instead of'\n                          ' tqdm(..., gui=True)'):\n                raise e\n        else:\n            raise DeprecationWarning('Should not allow manual gui=True without'\n                                     ' overriding __iter__() and update()')\n        finally:\n            t._instances.clear()\n            # t.close()\n            # len(tqdm._instances) += 1  # undo the close() decrement\n\n        with tqdm(total=1, gui=False, file=our_file) as t:\n            assert hasattr(t, \"sp\")",
        "begin_line": 1003,
        "end_line": 1041,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_cmp#1045",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_cmp()",
        "snippet": "def test_cmp():\n    \"\"\" Test comparison functions \"\"\"\n    with closing(StringIO()) as our_file:\n        t0 = tqdm(total=10, file=our_file)\n        t1 = tqdm(total=10, file=our_file)\n        t2 = tqdm(total=10, file=our_file)\n\n        assert t0 < t1\n        assert t2 >= t0\n        assert t0 <= t2\n\n        t3 = tqdm(total=10, file=our_file)\n        t4 = tqdm(total=10, file=our_file)\n        t5 = tqdm(total=10, file=our_file)\n        t5.close()\n        t6 = tqdm(total=10, file=our_file)\n\n        assert t3 != t4\n        assert t3 > t2\n        assert t5 == t6\n        t6.close()\n        t4.close()\n        t3.close()\n        t2.close()\n        t1.close()\n        t0.close()",
        "begin_line": 1045,
        "end_line": 1070,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_repr#1074",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_repr()",
        "snippet": "def test_repr():\n    \"\"\" Test representation \"\"\"\n    with closing(StringIO()) as our_file:\n        with tqdm(total=10, ascii=True, file=our_file) as t:\n            assert str(t) == '  0%|          | 0/10 [00:00<?, ?it/s]'",
        "begin_line": 1074,
        "end_line": 1078,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_clear#1082",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_clear()",
        "snippet": "def test_clear():\n    \"\"\" Test clearing bar display \"\"\"\n    with closing(StringIO()) as our_file:\n        t1 = tqdm(total=10, file=our_file, desc='pos0 bar',\n                  bar_format='{l_bar}')\n        t2 = trange(10, file=our_file, desc='pos1 bar',\n                    bar_format='{l_bar}')\n        before = squash_ctrlchars(our_file.getvalue())\n        t2.clear()\n        t1.clear()\n        after = squash_ctrlchars(our_file.getvalue())\n        t1.close()\n        t2.close()\n        assert before == ['pos0 bar:   0%|', 'pos1 bar:   0%|']\n        assert after == ['', '']",
        "begin_line": 1082,
        "end_line": 1096,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_refresh#1100",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_refresh()",
        "snippet": "def test_refresh():\n    \"\"\" Test refresh bar display \"\"\"\n    with closing(StringIO()) as our_file:\n        t1 = tqdm(total=10, file=our_file, desc='pos0 bar',\n                  bar_format='{l_bar}', mininterval=999, miniters=999)\n        t2 = tqdm(total=10, file=our_file, desc='pos1 bar',\n                  bar_format='{l_bar}', mininterval=999, miniters=999)\n        t1.update()\n        t2.update()\n        before = squash_ctrlchars(our_file.getvalue())\n        t1.refresh()\n        t2.refresh()\n        after = squash_ctrlchars(our_file.getvalue())\n        t1.close()\n        t2.close()\n\n        # Check that refreshing indeed forced the display to use realtime state\n        assert before == [u'pos0 bar:   0%|', u'pos1 bar:   0%|']\n        assert after == [u'pos0 bar:  10%|', u'pos1 bar:  10%|']",
        "begin_line": 1100,
        "end_line": 1118,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tqdm.tests.tests_tqdm.test_write#1122",
        "src_path": "tqdm/tests/tests_tqdm.py",
        "class_name": "tqdm.tests.tests_tqdm",
        "signature": "tqdm.tests.tests_tqdm.test_write()",
        "snippet": "def test_write():\n    \"\"\" Test write messages \"\"\"\n    s = \"Hello world\"\n    with closing(StringIO()) as our_file:\n        # Change format to keep only left part w/o bar and it/s rate\n        t1 = tqdm(total=10, file=our_file, desc='pos0 bar',\n                  bar_format='{l_bar}', mininterval=0, miniters=1)\n        t2 = trange(10, file=our_file, desc='pos1 bar', bar_format='{l_bar}',\n                    mininterval=0, miniters=1)\n        t3 = tqdm(total=10, file=our_file, desc='pos2 bar',\n                  bar_format='{l_bar}', mininterval=0, miniters=1)\n        t1.update()\n        t2.update()\n        t3.update()\n        before = our_file.getvalue()\n\n        # Write msg and see if bars are correctly redrawn below the msg\n        t1.write(s, file=our_file)  # call as an instance method\n        tqdm.write(s, file=our_file)  # call as a class method\n        after = our_file.getvalue()\n\n        t1.close()\n        t2.close()\n        t3.close()\n\n        before_squashed = squash_ctrlchars(before)\n        after_squashed = squash_ctrlchars(after)\n\n        assert after_squashed == [s, s] + before_squashed\n\n    # Check that no bar clearing if different file\n    with closing(StringIO()) as our_file_bar:\n        with closing(StringIO()) as our_file_write:\n            t1 = tqdm(total=10, file=our_file_bar, desc='pos0 bar',\n                      bar_format='{l_bar}', mininterval=0, miniters=1)\n\n            t1.update()\n            before_bar = our_file_bar.getvalue()\n\n            tqdm.write(s, file=our_file_write)\n\n            after_bar = our_file_bar.getvalue()\n            t1.close()\n\n            assert before_bar == after_bar\n\n    # Test stdout/stderr anti-mixup strategy\n    # Backup stdout/stderr\n    stde = sys.stderr\n    stdo = sys.stdout\n    # Mock stdout/stderr\n    with closing(StringIO()) as our_stderr:\n        with closing(StringIO()) as our_stdout:\n            sys.stderr = our_stderr\n            sys.stdout = our_stdout\n            t1 = tqdm(total=10, file=sys.stderr, desc='pos0 bar',\n                      bar_format='{l_bar}', mininterval=0, miniters=1)\n\n            t1.update()\n            before_err = sys.stderr.getvalue()\n            before_out = sys.stdout.getvalue()\n\n            tqdm.write(s, file=sys.stdout)\n            after_err = sys.stderr.getvalue()\n            after_out = sys.stdout.getvalue()\n\n            t1.close()\n\n            assert before_err == '\\rpos0 bar:   0%|\\rpos0 bar:  10%|'\n            assert before_out == ''\n            after_err_res = [m[0] for m in RE_pos.findall(after_err)]\n            assert after_err_res == [u'\\rpos0 bar:   0%',\n                                     u'\\rpos0 bar:  10%',\n                                     u'\\r      ',\n                                     u'\\r\\r      ',\n                                     u'\\rpos0 bar:  10%']\n            assert after_out == s+'\\n'\n    # Restore stdout and stderr\n    sys.stderr = stde\n    sys.stdout = stdo",
        "begin_line": 1122,
        "end_line": 1201,
        "comment": "",
        "is_bug": false
    }
]