[
    {
        "name": "tornado.http1connection._QuietException.__init__#37",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection._QuietException",
        "signature": "tornado.http1connection._QuietException.__init__(self)",
        "snippet": "    def __init__(self):\n        pass",
        "begin_line": 37,
        "end_line": 38,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.http1connection._ExceptionLoggingContext.__init__#46",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection._ExceptionLoggingContext",
        "signature": "tornado.http1connection._ExceptionLoggingContext.__init__(self, logger)",
        "snippet": "    def __init__(self, logger):\n        self.logger = logger",
        "begin_line": 46,
        "end_line": 47,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005494505494505495,
            "pseudo_dstar_susp": 0.0006430868167202572,
            "pseudo_tarantula_susp": 0.0005189413596263622,
            "pseudo_op2_susp": 0.0006430868167202572,
            "pseudo_barinel_susp": 0.0005189413596263622
        }
    },
    {
        "name": "tornado.http1connection._ExceptionLoggingContext.__enter__#49",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection._ExceptionLoggingContext",
        "signature": "tornado.http1connection._ExceptionLoggingContext.__enter__(self)",
        "snippet": "    def __enter__(self):\n        pass",
        "begin_line": 49,
        "end_line": 50,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005494505494505495,
            "pseudo_dstar_susp": 0.0006430868167202572,
            "pseudo_tarantula_susp": 0.0005189413596263622,
            "pseudo_op2_susp": 0.0006430868167202572,
            "pseudo_barinel_susp": 0.0005189413596263622
        }
    },
    {
        "name": "tornado.http1connection._ExceptionLoggingContext.__exit__#52",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection._ExceptionLoggingContext",
        "signature": "tornado.http1connection._ExceptionLoggingContext.__exit__(self, typ, value, tb)",
        "snippet": "    def __exit__(self, typ, value, tb):\n        if value is not None:\n            self.logger.error(\"Uncaught exception\", exc_info=(typ, value, tb))\n            raise _QuietException",
        "begin_line": 52,
        "end_line": 55,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005494505494505495,
            "pseudo_dstar_susp": 0.0006430868167202572,
            "pseudo_tarantula_susp": 0.0005189413596263622,
            "pseudo_op2_susp": 0.0006430868167202572,
            "pseudo_barinel_susp": 0.0005189413596263622
        }
    },
    {
        "name": "tornado.http1connection.HTTP1ConnectionParameters.__init__#61",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1ConnectionParameters",
        "signature": "tornado.http1connection.HTTP1ConnectionParameters.__init__(self, no_keep_alive=False, chunk_size=None, max_header_size=None, header_timeout=None, max_body_size=None, body_timeout=None, decompress=False)",
        "snippet": "    def __init__(self, no_keep_alive=False, chunk_size=None,\n                 max_header_size=None, header_timeout=None, max_body_size=None,\n                 body_timeout=None, decompress=False):\n        \"\"\"\n        :arg bool no_keep_alive: If true, always close the connection after\n            one request.\n        :arg int chunk_size: how much data to read into memory at once\n        :arg int max_header_size:  maximum amount of data for HTTP headers\n        :arg float header_timeout: how long to wait for all headers (seconds)\n        :arg int max_body_size: maximum amount of data for body\n        :arg float body_timeout: how long to wait while reading body (seconds)\n        :arg bool decompress: if true, decode incoming\n            ``Content-Encoding: gzip``\n        \"\"\"\n        self.no_keep_alive = no_keep_alive\n        self.chunk_size = chunk_size or 65536\n        self.max_header_size = max_header_size or 65536\n        self.header_timeout = header_timeout\n        self.max_body_size = max_body_size\n        self.body_timeout = body_timeout\n        self.decompress = decompress",
        "begin_line": 61,
        "end_line": 81,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013698630136986301,
            "pseudo_dstar_susp": 0.00141643059490085,
            "pseudo_tarantula_susp": 0.0010427528675703858,
            "pseudo_op2_susp": 0.00141643059490085,
            "pseudo_barinel_susp": 0.0010427528675703858
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.__init__#90",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.__init__(self, stream, is_client, params=None, context=None)",
        "snippet": "    def __init__(self, stream, is_client, params=None, context=None):\n        \"\"\"\n        :arg stream: an `.IOStream`\n        :arg bool is_client: client or server\n        :arg params: a `.HTTP1ConnectionParameters` instance or ``None``\n        :arg context: an opaque application-defined object that can be accessed\n            as ``connection.context``.\n        \"\"\"\n        self.is_client = is_client\n        self.stream = stream\n        if params is None:\n            params = HTTP1ConnectionParameters()\n        self.params = params\n        self.context = context\n        self.no_keep_alive = params.no_keep_alive\n        # The body limits can be altered by the delegate, so save them\n        # here instead of just referencing self.params later.\n        self._max_body_size = (self.params.max_body_size or\n                               self.stream.max_buffer_size)\n        self._body_timeout = self.params.body_timeout\n        # _write_finished is set to True when finish() has been called,\n        # i.e. there will be no more data sent.  Data may still be in the\n        # stream's write buffer.\n        self._write_finished = False\n        # True when we have read the entire incoming body.\n        self._read_finished = False\n        # _finish_future resolves when all data has been written and flushed\n        # to the IOStream.\n        self._finish_future = Future()\n        # If true, the connection should be closed after this request\n        # (after the response has been written in the server side,\n        # and after it has been read in the client)\n        self._disconnect_on_finish = False\n        self._clear_callbacks()\n        # Save the start lines after we read or write them; they\n        # affect later processing (e.g. 304 responses and HEAD methods\n        # have content-length but no bodies)\n        self._request_start_line = None\n        self._response_start_line = None\n        self._request_headers = None\n        # True if we are writing output with chunked encoding.\n        self._chunking_output = None\n        # While reading a body with a content-length, this is the\n        # amount left to read.\n        self._expected_content_remaining = None\n        # A Future for our outgoing writes, returned by IOStream.write.\n        self._pending_write = None",
        "begin_line": 90,
        "end_line": 136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006325110689437065,
            "pseudo_dstar_susp": 0.0006949270326615705,
            "pseudo_tarantula_susp": 0.002857142857142857,
            "pseudo_op2_susp": 0.0006949270326615705,
            "pseudo_barinel_susp": 0.002857142857142857
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.read_response#138",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.read_response(self, delegate)",
        "snippet": "    def read_response(self, delegate):\n        \"\"\"Read a single HTTP response.\n\n        Typical client-mode usage is to write a request using `write_headers`,\n        `write`, and `finish`, and then call ``read_response``.\n\n        :arg delegate: a `.HTTPMessageDelegate`\n\n        Returns a `.Future` that resolves to None after the full response has\n        been read.\n        \"\"\"\n        if self.params.decompress:\n            delegate = _GzipMessageDelegate(delegate, self.params.chunk_size)\n        return self._read_message(delegate)",
        "begin_line": 138,
        "end_line": 151,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005903187721369539,
            "pseudo_dstar_susp": 0.0006949270326615705,
            "pseudo_tarantula_susp": 0.0005488474204171241,
            "pseudo_op2_susp": 0.0006949270326615705,
            "pseudo_barinel_susp": 0.0005488474204171241
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._read_message#154",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._read_message(self, delegate)",
        "snippet": "    def _read_message(self, delegate):\n        need_delegate_close = False\n        try:\n            header_future = self.stream.read_until_regex(\n                b\"\\r?\\n\\r?\\n\",\n                max_bytes=self.params.max_header_size)\n            if self.params.header_timeout is None:\n                header_data = yield header_future\n            else:\n                try:\n                    header_data = yield gen.with_timeout(\n                        self.stream.io_loop.time() + self.params.header_timeout,\n                        header_future,\n                        quiet_exceptions=iostream.StreamClosedError)\n                except gen.TimeoutError:\n                    self.close()\n                    raise gen.Return(False)\n            start_line, headers = self._parse_headers(header_data)\n            if self.is_client:\n                start_line = httputil.parse_response_start_line(start_line)\n                self._response_start_line = start_line\n            else:\n                start_line = httputil.parse_request_start_line(start_line)\n                self._request_start_line = start_line\n                self._request_headers = headers\n\n            self._disconnect_on_finish = not self._can_keep_alive(\n                start_line, headers)\n            need_delegate_close = True\n            with _ExceptionLoggingContext(app_log):\n                header_future = delegate.headers_received(start_line, headers)\n                if header_future is not None:\n                    yield header_future\n            if self.stream is None:\n                # We've been detached.\n                need_delegate_close = False\n                raise gen.Return(False)\n            skip_body = False\n            if self.is_client:\n                if (self._request_start_line is not None and\n                        self._request_start_line.method == 'HEAD'):\n                    skip_body = True\n                code = start_line.code\n                if code == 304:\n                    # 304 responses may include the content-length header\n                    # but do not actually have a body.\n                    # http://tools.ietf.org/html/rfc7230#section-3.3\n                    skip_body = True\n                if code >= 100 and code < 200:\n                    # 1xx responses should never indicate the presence of\n                    # a body.\n                    if ('Content-Length' in headers or\n                            'Transfer-Encoding' in headers):\n                        raise httputil.HTTPInputError(\n                            \"Response code %d cannot have body\" % code)\n                    # TODO: client delegates will get headers_received twice\n                    # in the case of a 100-continue.  Document or change?\n                    yield self._read_message(delegate)\n            else:\n                if (headers.get(\"Expect\") == \"100-continue\" and\n                        not self._write_finished):\n                    self.stream.write(b\"HTTP/1.1 100 (Continue)\\r\\n\\r\\n\")\n            if not skip_body:\n                body_future = self._read_body(\n                    start_line.code if self.is_client else 0, headers, delegate)\n                if body_future is not None:\n                    if self._body_timeout is None:\n                        yield body_future\n                    else:\n                        try:\n                            yield gen.with_timeout(\n                                self.stream.io_loop.time() + self._body_timeout,\n                                body_future,\n                                quiet_exceptions=iostream.StreamClosedError)\n                        except gen.TimeoutError:\n                            gen_log.info(\"Timeout reading body from %s\",\n                                         self.context)\n                            self.stream.close()\n                            raise gen.Return(False)\n            self._read_finished = True\n            if not self._write_finished or self.is_client:\n                need_delegate_close = False\n                with _ExceptionLoggingContext(app_log):\n                    delegate.finish()\n            # If we're waiting for the application to produce an asynchronous\n            # response, and we're not detached, register a close callback\n            # on the stream (we didn't need one while we were reading)\n            if (not self._finish_future.done() and\n                    self.stream is not None and\n                    not self.stream.closed()):\n                self.stream.set_close_callback(self._on_connection_close)\n                yield self._finish_future\n            if self.is_client and self._disconnect_on_finish:\n                self.close()\n            if self.stream is None:\n                raise gen.Return(False)\n        except httputil.HTTPInputError as e:\n            gen_log.info(\"Malformed HTTP message from %s: %s\",\n                         self.context, e)\n            if not self.is_client:\n                yield self.stream.write(b'HTTP/1.1 400 Bad Request\\r\\n\\r\\n')\n            self.close()\n            raise gen.Return(False)\n        finally:\n            if need_delegate_close:\n                with _ExceptionLoggingContext(app_log):\n                    delegate.on_connection_close()\n            header_future = None\n            self._clear_callbacks()\n        raise gen.Return(True)",
        "begin_line": 154,
        "end_line": 263,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0021413276231263384,
            "pseudo_dstar_susp": 0.0007183908045977011,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.0007183908045977011,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._clear_callbacks#265",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._clear_callbacks(self)",
        "snippet": "    def _clear_callbacks(self):\n        \"\"\"Clears the callback attributes.\n\n        This allows the request handler to be garbage collected more\n        quickly in CPython by breaking up reference cycles.\n        \"\"\"\n        self._write_callback = None\n        self._write_future = None\n        self._close_callback = None\n        if self.stream is not None:\n            self.stream.set_close_callback(None)",
        "begin_line": 265,
        "end_line": 275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005903187721369539,
            "pseudo_dstar_susp": 0.0006949270326615705,
            "pseudo_tarantula_susp": 0.0005488474204171241,
            "pseudo_op2_susp": 0.0006949270326615705,
            "pseudo_barinel_susp": 0.0005488474204171241
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.set_close_callback#277",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.set_close_callback(self, callback)",
        "snippet": "    def set_close_callback(self, callback):\n        \"\"\"Sets a callback that will be run when the connection is closed.\n\n        .. deprecated:: 4.0\n            Use `.HTTPMessageDelegate.on_connection_close` instead.\n        \"\"\"\n        self._close_callback = stack_context.wrap(callback)",
        "begin_line": 277,
        "end_line": 283,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005076142131979696,
            "pseudo_dstar_susp": 0.0005461496450027307,
            "pseudo_tarantula_susp": 0.0005243838489774515,
            "pseudo_op2_susp": 0.0005461496450027307,
            "pseudo_barinel_susp": 0.0005243838489774515
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._on_connection_close#285",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._on_connection_close(self)",
        "snippet": "    def _on_connection_close(self):\n        # Note that this callback is only registered on the IOStream\n        # when we have finished reading the request and are waiting for\n        # the application to produce its response.\n        if self._close_callback is not None:\n            callback = self._close_callback\n            self._close_callback = None\n            callback()\n        if not self._finish_future.done():\n            future_set_result_unless_cancelled(self._finish_future, None)\n        self._clear_callbacks()",
        "begin_line": 285,
        "end_line": 295,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.close#297",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.close(self)",
        "snippet": "    def close(self):\n        if self.stream is not None:\n            self.stream.close()\n        self._clear_callbacks()\n        if not self._finish_future.done():\n            future_set_result_unless_cancelled(self._finish_future, None)",
        "begin_line": 297,
        "end_line": 302,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005707762557077625,
            "pseudo_dstar_susp": 0.0006653359946773121,
            "pseudo_tarantula_susp": 0.000572737686139748,
            "pseudo_op2_susp": 0.0006653359946773121,
            "pseudo_barinel_susp": 0.000572737686139748
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.detach#304",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.detach(self)",
        "snippet": "    def detach(self):\n        \"\"\"Take control of the underlying stream.\n\n        Returns the underlying `.IOStream` object and stops all further\n        HTTP processing.  May only be called during\n        `.HTTPMessageDelegate.headers_received`.  Intended for implementing\n        protocols like websockets that tunnel over an HTTP handshake.\n        \"\"\"\n        self._clear_callbacks()\n        stream = self.stream\n        self.stream = None\n        if not self._finish_future.done():\n            future_set_result_unless_cancelled(self._finish_future, None)\n        return stream",
        "begin_line": 304,
        "end_line": 317,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006297229219143577,
            "pseudo_dstar_susp": 0.0004175365344467641,
            "pseudo_tarantula_susp": 0.0024752475247524753,
            "pseudo_op2_susp": 0.0004175365344467641,
            "pseudo_barinel_susp": 0.0024752475247524753
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.set_body_timeout#319",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.set_body_timeout(self, timeout)",
        "snippet": "    def set_body_timeout(self, timeout):\n        \"\"\"Sets the body timeout for a single request.\n\n        Overrides the value from `.HTTP1ConnectionParameters`.\n        \"\"\"\n        self._body_timeout = timeout",
        "begin_line": 319,
        "end_line": 324,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007163323782234957,
            "pseudo_dstar_susp": 0.0004038772213247173,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.0004038772213247173,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.set_max_body_size#326",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.set_max_body_size(self, max_body_size)",
        "snippet": "    def set_max_body_size(self, max_body_size):\n        \"\"\"Sets the body size limit for a single request.\n\n        Overrides the value from `.HTTP1ConnectionParameters`.\n        \"\"\"\n        self._max_body_size = max_body_size",
        "begin_line": 326,
        "end_line": 331,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006211180124223603,
            "pseudo_dstar_susp": 0.00039635354736424893,
            "pseudo_tarantula_susp": 0.0032679738562091504,
            "pseudo_op2_susp": 0.00039635354736424893,
            "pseudo_barinel_susp": 0.0032679738562091504
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.write_headers#333",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.write_headers(self, start_line, headers, chunk=None, callback=None)",
        "snippet": "    def write_headers(self, start_line, headers, chunk=None, callback=None):\n        \"\"\"Implements `.HTTPConnection.write_headers`.\"\"\"\n        lines = []\n        if self.is_client:\n            self._request_start_line = start_line\n            lines.append(utf8('%s %s HTTP/1.1' % (start_line[0], start_line[1])))\n            # Client requests with a non-empty body must have either a\n            # Content-Length or a Transfer-Encoding.\n            self._chunking_output = (\n                start_line.method in ('POST', 'PUT', 'PATCH') and\n                'Content-Length' not in headers and\n                'Transfer-Encoding' not in headers)\n        else:\n            self._response_start_line = start_line\n            lines.append(utf8('HTTP/1.1 %d %s' % (start_line[1], start_line[2])))\n            self._chunking_output = (\n                # TODO: should this use\n                # self._request_start_line.version or\n                # start_line.version?\n                self._request_start_line.version == 'HTTP/1.1' and\n                # 1xx, 204 and 304 responses have no body (not even a zero-length\n                # body), and so should not have either Content-Length or\n                # Transfer-Encoding headers.\n                start_line.code not in (204, 304) and\n                (start_line.code < 100 or start_line.code >= 200) and\n                # No need to chunk the output if a Content-Length is specified.\n                'Content-Length' not in headers and\n                # Applications are discouraged from touching Transfer-Encoding,\n                # but if they do, leave it alone.\n                'Transfer-Encoding' not in headers)\n            # If connection to a 1.1 client will be closed, inform client\n            if (self._request_start_line.version == 'HTTP/1.1' and self._disconnect_on_finish):\n                headers['Connection'] = 'close'\n            # If a 1.0 client asked for keep-alive, add the header.\n            if (self._request_start_line.version == 'HTTP/1.0' and\n                    self._request_headers.get('Connection', '').lower() == 'keep-alive'):\n                headers['Connection'] = 'Keep-Alive'\n        if self._chunking_output:\n            headers['Transfer-Encoding'] = 'chunked'\n        if (not self.is_client and\n            (self._request_start_line.method == 'HEAD' or\n             start_line.code == 304)):\n            self._expected_content_remaining = 0\n        elif 'Content-Length' in headers:\n            self._expected_content_remaining = int(headers['Content-Length'])\n        else:\n            self._expected_content_remaining = None\n        # TODO: headers are supposed to be of type str, but we still have some\n        # cases that let bytes slip through. Remove these native_str calls when those\n        # are fixed.\n        header_lines = (native_str(n) + \": \" + native_str(v) for n, v in headers.get_all())\n        if PY3:\n            lines.extend(l.encode('latin1') for l in header_lines)\n        else:\n            lines.extend(header_lines)\n        for line in lines:\n            if b'\\n' in line:\n                raise ValueError('Newline in header: ' + repr(line))\n        future = None\n        if self.stream.closed():\n            future = self._write_future = Future()\n            future.set_exception(iostream.StreamClosedError())\n            future.exception()\n        else:\n            if callback is not None:\n                self._write_callback = stack_context.wrap(callback)\n            else:\n                future = self._write_future = Future()\n            data = b\"\\r\\n\".join(lines) + b\"\\r\\n\\r\\n\"\n            if chunk:\n                data += self._format_chunk(chunk)\n            self._pending_write = self.stream.write(data)\n            self._pending_write.add_done_callback(self._on_write_complete)\n        return future",
        "begin_line": 333,
        "end_line": 406,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005830903790087463,
            "pseudo_dstar_susp": 0.0007530120481927711,
            "pseudo_tarantula_susp": 0.0017513134851138354,
            "pseudo_op2_susp": 0.0007530120481927711,
            "pseudo_barinel_susp": 0.0017513134851138354
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._format_chunk#408",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._format_chunk(self, chunk)",
        "snippet": "    def _format_chunk(self, chunk):\n        if self._expected_content_remaining is not None:\n            self._expected_content_remaining -= len(chunk)\n            if self._expected_content_remaining < 0:\n                # Close the stream now to stop further framing errors.\n                self.stream.close()\n                raise httputil.HTTPOutputError(\n                    \"Tried to write more data than Content-Length\")\n        if self._chunking_output and chunk:\n            # Don't write out empty chunks because that means END-OF-STREAM\n            # with chunked encoding\n            return utf8(\"%x\" % len(chunk)) + b\"\\r\\n\" + chunk + b\"\\r\\n\"\n        else:\n            return chunk",
        "begin_line": 408,
        "end_line": 421,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005428881650380022,
            "pseudo_dstar_susp": 0.0005824111822947001,
            "pseudo_tarantula_susp": 0.0010857763300760044,
            "pseudo_op2_susp": 0.0005824111822947001,
            "pseudo_barinel_susp": 0.0010857763300760044
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.write#423",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.write(self, chunk, callback=None)",
        "snippet": "    def write(self, chunk, callback=None):\n        \"\"\"Implements `.HTTPConnection.write`.\n\n        For backwards compatibility it is allowed but deprecated to\n        skip `write_headers` and instead call `write()` with a\n        pre-encoded header block.\n        \"\"\"\n        future = None\n        if self.stream.closed():\n            future = self._write_future = Future()\n            self._write_future.set_exception(iostream.StreamClosedError())\n            self._write_future.exception()\n        else:\n            if callback is not None:\n                self._write_callback = stack_context.wrap(callback)\n            else:\n                future = self._write_future = Future()\n            self._pending_write = self.stream.write(self._format_chunk(chunk))\n            self._pending_write.add_done_callback(self._on_write_complete)\n        return future",
        "begin_line": 423,
        "end_line": 442,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005017561465127947,
            "pseudo_dstar_susp": 0.0004697040864255519,
            "pseudo_tarantula_susp": 0.0006027727546714888,
            "pseudo_op2_susp": 0.0004697040864255519,
            "pseudo_barinel_susp": 0.0006027727546714888
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection.finish#444",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection.finish(self)",
        "snippet": "    def finish(self):\n        \"\"\"Implements `.HTTPConnection.finish`.\"\"\"\n        if (self._expected_content_remaining is not None and\n                self._expected_content_remaining != 0 and\n                not self.stream.closed()):\n            self.stream.close()\n            raise httputil.HTTPOutputError(\n                \"Tried to write %d bytes less than Content-Length\" %\n                self._expected_content_remaining)\n        if self._chunking_output:\n            if not self.stream.closed():\n                self._pending_write = self.stream.write(b\"0\\r\\n\\r\\n\")\n                self._pending_write.add_done_callback(self._on_write_complete)\n        self._write_finished = True\n        # If the app finished the request while we're still reading,\n        # divert any remaining data away from the delegate and\n        # close the connection when we're done sending our response.\n        # Closing the connection is the only way to avoid reading the\n        # whole input body.\n        if not self._read_finished:\n            self._disconnect_on_finish = True\n        # No more data is coming, so instruct TCP to send any remaining\n        # data immediately instead of waiting for a full packet or ack.\n        self.stream.set_nodelay(True)\n        if self._pending_write is None:\n            self._finish_request(None)\n        else:\n            future_add_done_callback(self._pending_write, self._finish_request)",
        "begin_line": 444,
        "end_line": 471,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00051440329218107,
            "pseudo_dstar_susp": 0.0005558643690939411,
            "pseudo_tarantula_susp": 0.0009560229445506692,
            "pseudo_op2_susp": 0.0005558643690939411,
            "pseudo_barinel_susp": 0.0009560229445506692
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._on_write_complete#473",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._on_write_complete(self, future)",
        "snippet": "    def _on_write_complete(self, future):\n        exc = future.exception()\n        if exc is not None and not isinstance(exc, iostream.StreamClosedError):\n            future.result()\n        if self._write_callback is not None:\n            callback = self._write_callback\n            self._write_callback = None\n            self.stream.io_loop.add_callback(callback)\n        if self._write_future is not None:\n            future = self._write_future\n            self._write_future = None\n            future_set_result_unless_cancelled(future, None)",
        "begin_line": 473,
        "end_line": 484,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004768717215069146,
            "pseudo_dstar_susp": 0.0005558643690939411,
            "pseudo_tarantula_susp": 0.0006770480704129993,
            "pseudo_op2_susp": 0.0005558643690939411,
            "pseudo_barinel_susp": 0.0006770480704129993
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._can_keep_alive#486",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._can_keep_alive(self, start_line, headers)",
        "snippet": "    def _can_keep_alive(self, start_line, headers):\n        if self.params.no_keep_alive:\n            return False\n        connection_header = headers.get(\"Connection\")\n        if connection_header is not None:\n            connection_header = connection_header.lower()\n        if start_line.version == \"HTTP/1.1\":\n            return connection_header != \"close\"\n        elif (\"Content-Length\" in headers or\n              headers.get(\"Transfer-Encoding\", \"\").lower() == \"chunked\" or\n              getattr(start_line, 'method', None) in (\"HEAD\", \"GET\")):\n            # start_line may be a request or response start line; only\n            # the former has a method attribute.\n            return connection_header == \"keep-alive\"\n        return False",
        "begin_line": 486,
        "end_line": 500,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005530973451327434,
            "pseudo_dstar_susp": 0.0006480881399870382,
            "pseudo_tarantula_susp": 0.0006978367062107466,
            "pseudo_op2_susp": 0.0006480881399870382,
            "pseudo_barinel_susp": 0.0006954102920723226
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._finish_request#502",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._finish_request(self, future)",
        "snippet": "    def _finish_request(self, future):\n        self._clear_callbacks()\n        if not self.is_client and self._disconnect_on_finish:\n            self.close()\n            return\n        # Turn Nagle's algorithm back on, leaving the stream in its\n        # default state for the next request.\n        self.stream.set_nodelay(False)\n        if not self._finish_future.done():\n            future_set_result_unless_cancelled(self._finish_future, None)",
        "begin_line": 502,
        "end_line": 511,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004833252779120348,
            "pseudo_dstar_susp": 0.0005630630630630631,
            "pseudo_tarantula_susp": 0.0004710315591144607,
            "pseudo_op2_susp": 0.0005630630630630631,
            "pseudo_barinel_susp": 0.0004710315591144607
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._parse_headers#513",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._parse_headers(self, data)",
        "snippet": "    def _parse_headers(self, data):\n        # The lstrip removes newlines that some implementations sometimes\n        # insert between messages of a reused connection.  Per RFC 7230,\n        # we SHOULD ignore at least one empty line before the request.\n        # http://tools.ietf.org/html/rfc7230#section-3.5\n        data = native_str(data.decode('latin1')).lstrip(\"\\r\\n\")\n        # RFC 7230 section allows for both CRLF and bare LF.\n        eol = data.find(\"\\n\")\n        start_line = data[:eol].rstrip(\"\\r\")\n        headers = httputil.HTTPHeaders.parse(data[eol:])\n        return start_line, headers",
        "begin_line": 513,
        "end_line": 523,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006071645415907711,
            "pseudo_dstar_susp": 0.0007183908045977011,
            "pseudo_tarantula_susp": 0.0005633802816901409,
            "pseudo_op2_susp": 0.0007183908045977011,
            "pseudo_barinel_susp": 0.0005633802816901409
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._read_body#525",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._read_body(self, code, headers, delegate)",
        "snippet": "    def _read_body(self, code, headers, delegate):\n        if \"Content-Length\" in headers:\n            if \"Transfer-Encoding\" in headers:\n                # Response cannot contain both Content-Length and\n                # Transfer-Encoding headers.\n                # http://tools.ietf.org/html/rfc7230#section-3.3.3\n                raise httputil.HTTPInputError(\n                    \"Response with both Transfer-Encoding and Content-Length\")\n            if \",\" in headers[\"Content-Length\"]:\n                # Proxies sometimes cause Content-Length headers to get\n                # duplicated.  If all the values are identical then we can\n                # use them but if they differ it's an error.\n                pieces = re.split(r',\\s*', headers[\"Content-Length\"])\n                if any(i != pieces[0] for i in pieces):\n                    raise httputil.HTTPInputError(\n                        \"Multiple unequal Content-Lengths: %r\" %\n                        headers[\"Content-Length\"])\n                headers[\"Content-Length\"] = pieces[0]\n\n            try:\n                content_length = int(headers[\"Content-Length\"])\n            except ValueError:\n                # Handles non-integer Content-Length value.\n                raise httputil.HTTPInputError(\n                    \"Only integer Content-Length is allowed: %s\" % headers[\"Content-Length\"])\n\n            if content_length > self._max_body_size:\n                raise httputil.HTTPInputError(\"Content-Length too long\")\n        else:\n            content_length = None\n\n        if code == 204:\n            # This response code is not allowed to have a non-empty body,\n            # and has an implicit length of zero instead of read-until-close.\n            # http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3\n            if (\"Transfer-Encoding\" in headers or\n                    content_length not in (None, 0)):\n                raise httputil.HTTPInputError(\n                    \"Response with code %d should not have body\" % code)\n            content_length = 0\n\n        if content_length is not None:\n            return self._read_fixed_body(content_length, delegate)\n        if headers.get(\"Transfer-Encoding\", \"\").lower() == \"chunked\":\n            return self._read_chunked_body(delegate)\n        if self.is_client:\n            return self._read_body_until_close(delegate)\n        return None",
        "begin_line": 525,
        "end_line": 572,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011668611435239206,
            "pseudo_dstar_susp": 0.0006430868167202572,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.0006430868167202572,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._read_fixed_body#575",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._read_fixed_body(self, content_length, delegate)",
        "snippet": "    def _read_fixed_body(self, content_length, delegate):\n        while content_length > 0:\n            body = yield self.stream.read_bytes(\n                min(self.params.chunk_size, content_length), partial=True)\n            content_length -= len(body)\n            if not self._write_finished or self.is_client:\n                with _ExceptionLoggingContext(app_log):\n                    ret = delegate.data_received(body)\n                    if ret is not None:\n                        yield ret",
        "begin_line": 575,
        "end_line": 584,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003891050583657588,
            "pseudo_dstar_susp": 0.0004073319755600815,
            "pseudo_tarantula_susp": 0.0003878975950349108,
            "pseudo_op2_susp": 0.0004073319755600815,
            "pseudo_barinel_susp": 0.0003878975950349108
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._read_chunked_body#587",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._read_chunked_body(self, delegate)",
        "snippet": "    def _read_chunked_body(self, delegate):\n        # TODO: \"chunk extensions\" http://tools.ietf.org/html/rfc2616#section-3.6.1\n        total_size = 0\n        while True:\n            chunk_len = yield self.stream.read_until(b\"\\r\\n\", max_bytes=64)\n            chunk_len = int(chunk_len.strip(), 16)\n            if chunk_len == 0:\n                crlf = yield self.stream.read_bytes(2)\n                if crlf != b'\\r\\n':\n                    raise httputil.HTTPInputError(\"improperly terminated chunked request\")\n                return\n            total_size += chunk_len\n            if total_size > self._max_body_size:\n                raise httputil.HTTPInputError(\"chunked body too large\")\n            bytes_to_read = chunk_len\n            while bytes_to_read:\n                chunk = yield self.stream.read_bytes(\n                    min(bytes_to_read, self.params.chunk_size), partial=True)\n                bytes_to_read -= len(chunk)\n                if not self._write_finished or self.is_client:\n                    with _ExceptionLoggingContext(app_log):\n                        ret = delegate.data_received(chunk)\n                        if ret is not None:\n                            yield ret\n            # chunk ends with \\r\\n\n            crlf = yield self.stream.read_bytes(2)\n            assert crlf == b\"\\r\\n\"",
        "begin_line": 587,
        "end_line": 613,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008382229673093043,
            "pseudo_dstar_susp": 0.0004210526315789474,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.0004210526315789474,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.http1connection.HTTP1Connection._read_body_until_close#616",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1Connection",
        "signature": "tornado.http1connection.HTTP1Connection._read_body_until_close(self, delegate)",
        "snippet": "    def _read_body_until_close(self, delegate):\n        body = yield self.stream.read_until_close()\n        if not self._write_finished or self.is_client:\n            with _ExceptionLoggingContext(app_log):\n                delegate.data_received(body)",
        "begin_line": 616,
        "end_line": 620,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000859106529209622,
            "pseudo_dstar_susp": 0.0004868549172346641,
            "pseudo_tarantula_susp": 0.0034482758620689655,
            "pseudo_op2_susp": 0.0004868549172346641,
            "pseudo_barinel_susp": 0.0034482758620689655
        }
    },
    {
        "name": "tornado.http1connection._GzipMessageDelegate.__init__#626",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection._GzipMessageDelegate",
        "signature": "tornado.http1connection._GzipMessageDelegate.__init__(self, delegate, chunk_size)",
        "snippet": "    def __init__(self, delegate, chunk_size):\n        self._delegate = delegate\n        self._chunk_size = chunk_size\n        self._decompressor = None",
        "begin_line": 626,
        "end_line": 629,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004666355576294914,
            "pseudo_dstar_susp": 0.0005411255411255411,
            "pseudo_tarantula_susp": 0.00045662100456621003,
            "pseudo_op2_susp": 0.0005411255411255411,
            "pseudo_barinel_susp": 0.00045662100456621003
        }
    },
    {
        "name": "tornado.http1connection._GzipMessageDelegate.headers_received#631",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection._GzipMessageDelegate",
        "signature": "tornado.http1connection._GzipMessageDelegate.headers_received(self, start_line, headers)",
        "snippet": "    def headers_received(self, start_line, headers):\n        if headers.get(\"Content-Encoding\") == \"gzip\":\n            self._decompressor = GzipDecompressor()\n            # Downstream delegates will only see uncompressed data,\n            # so rename the content-encoding header.\n            # (but note that curl_httpclient doesn't do this).\n            headers.add(\"X-Consumed-Content-Encoding\",\n                        headers[\"Content-Encoding\"])\n            del headers[\"Content-Encoding\"]\n        return self._delegate.headers_received(start_line, headers)",
        "begin_line": 631,
        "end_line": 640,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004329004329004329,
            "pseudo_dstar_susp": 0.0004918839153959665,
            "pseudo_tarantula_susp": 0.00042444821731748726,
            "pseudo_op2_susp": 0.0004918839153959665,
            "pseudo_barinel_susp": 0.00042444821731748726
        }
    },
    {
        "name": "tornado.http1connection._GzipMessageDelegate.data_received#643",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection._GzipMessageDelegate",
        "signature": "tornado.http1connection._GzipMessageDelegate.data_received(self, chunk)",
        "snippet": "    def data_received(self, chunk):\n        if self._decompressor:\n            compressed_data = chunk\n            while compressed_data:\n                decompressed = self._decompressor.decompress(\n                    compressed_data, self._chunk_size)\n                if decompressed:\n                    ret = self._delegate.data_received(decompressed)\n                    if ret is not None:\n                        yield ret\n                compressed_data = self._decompressor.unconsumed_tail\n        else:\n            ret = self._delegate.data_received(chunk)\n            if ret is not None:\n                yield ret",
        "begin_line": 643,
        "end_line": 657,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004257130693912303,
            "pseudo_dstar_susp": 0.0004657661853749418,
            "pseudo_tarantula_susp": 0.00042052144659377626,
            "pseudo_op2_susp": 0.0004657661853749418,
            "pseudo_barinel_susp": 0.00042052144659377626
        }
    },
    {
        "name": "tornado.http1connection._GzipMessageDelegate.finish#659",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection._GzipMessageDelegate",
        "signature": "tornado.http1connection._GzipMessageDelegate.finish(self)",
        "snippet": "    def finish(self):\n        if self._decompressor is not None:\n            tail = self._decompressor.flush()\n            if tail:\n                # I believe the tail will always be empty (i.e.\n                # decompress will return all it can).  The purpose\n                # of the flush call is to detect errors such\n                # as truncated input.  But in case it ever returns\n                # anything, treat it as an extra chunk\n                self._delegate.data_received(tail)\n        return self._delegate.finish()",
        "begin_line": 659,
        "end_line": 669,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004185851820845542,
            "pseudo_dstar_susp": 0.0004601932811780948,
            "pseudo_tarantula_susp": 0.00041118421052631577,
            "pseudo_op2_susp": 0.0004601932811780948,
            "pseudo_barinel_susp": 0.00041118421052631577
        }
    },
    {
        "name": "tornado.http1connection._GzipMessageDelegate.on_connection_close#671",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection._GzipMessageDelegate",
        "signature": "tornado.http1connection._GzipMessageDelegate.on_connection_close(self)",
        "snippet": "    def on_connection_close(self):\n        return self._delegate.on_connection_close()",
        "begin_line": 671,
        "end_line": 672,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008176614881439084,
            "pseudo_dstar_susp": 0.00041999160016799666,
            "pseudo_tarantula_susp": 0.005076142131979695,
            "pseudo_op2_susp": 0.00041999160016799666,
            "pseudo_barinel_susp": 0.005076142131979695
        }
    },
    {
        "name": "tornado.http1connection.HTTP1ServerConnection.__init__#677",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1ServerConnection",
        "signature": "tornado.http1connection.HTTP1ServerConnection.__init__(self, stream, params=None, context=None)",
        "snippet": "    def __init__(self, stream, params=None, context=None):\n        \"\"\"\n        :arg stream: an `.IOStream`\n        :arg params: a `.HTTP1ConnectionParameters` or None\n        :arg context: an opaque application-defined object that is accessible\n            as ``connection.context``\n        \"\"\"\n        self.stream = stream\n        if params is None:\n            params = HTTP1ConnectionParameters()\n        self.params = params\n        self.context = context\n        self._serving_future = None",
        "begin_line": 677,
        "end_line": 689,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006071645415907711,
            "pseudo_dstar_susp": 0.0007183908045977011,
            "pseudo_tarantula_susp": 0.0005633802816901409,
            "pseudo_op2_susp": 0.0007183908045977011,
            "pseudo_barinel_susp": 0.0005633802816901409
        }
    },
    {
        "name": "tornado.http1connection.HTTP1ServerConnection.close#692",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1ServerConnection",
        "signature": "tornado.http1connection.HTTP1ServerConnection.close(self)",
        "snippet": "    def close(self):\n        \"\"\"Closes the connection.\n\n        Returns a `.Future` that resolves after the serving loop has exited.\n        \"\"\"\n        self.stream.close()\n        # Block until the serving loop is done, but ignore any exceptions\n        # (start_serving is already responsible for logging them).\n        try:\n            yield self._serving_future\n        except Exception:\n            pass",
        "begin_line": 692,
        "end_line": 703,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015730690577316344,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.http1connection.HTTP1ServerConnection.start_serving#705",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1ServerConnection",
        "signature": "tornado.http1connection.HTTP1ServerConnection.start_serving(self, delegate)",
        "snippet": "    def start_serving(self, delegate):\n        \"\"\"Starts serving requests on this connection.\n\n        :arg delegate: a `.HTTPServerConnectionDelegate`\n        \"\"\"\n        assert isinstance(delegate, httputil.HTTPServerConnectionDelegate)\n        self._serving_future = self._server_request_loop(delegate)\n        # Register the future on the IOLoop so its errors get logged.\n        self.stream.io_loop.add_future(self._serving_future,\n                                       lambda f: f.result())",
        "begin_line": 705,
        "end_line": 714,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006830601092896175,
            "pseudo_dstar_susp": 0.0008733624454148472,
            "pseudo_tarantula_susp": 0.0005724098454493417,
            "pseudo_op2_susp": 0.0008733624454148472,
            "pseudo_barinel_susp": 0.0005724098454493417
        }
    },
    {
        "name": "tornado.http1connection.HTTP1ServerConnection._server_request_loop#717",
        "src_path": "tornado/http1connection.py",
        "class_name": "tornado.http1connection.HTTP1ServerConnection",
        "signature": "tornado.http1connection.HTTP1ServerConnection._server_request_loop(self, delegate)",
        "snippet": "    def _server_request_loop(self, delegate):\n        try:\n            while True:\n                conn = HTTP1Connection(self.stream, False,\n                                       self.params, self.context)\n                request_delegate = delegate.start_request(self, conn)\n                try:\n                    ret = yield conn.read_response(request_delegate)\n                except (iostream.StreamClosedError,\n                        iostream.UnsatisfiableReadError):\n                    return\n                except _QuietException:\n                    # This exception was already logged.\n                    conn.close()\n                    return\n                except Exception:\n                    gen_log.error(\"Uncaught exception\", exc_info=True)\n                    conn.close()\n                    return\n                if not ret:\n                    return\n                yield gen.moment\n        finally:\n            delegate.on_close(self)",
        "begin_line": 717,
        "end_line": 740,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008818342151675485,
            "pseudo_dstar_susp": 0.0007331378299120235,
            "pseudo_tarantula_susp": 0.0030303030303030303,
            "pseudo_op2_susp": 0.0007331378299120235,
            "pseudo_barinel_susp": 0.0030303030303030303
        }
    },
    {
        "name": "tornado.options.OptionParser.__init__#123",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.__init__(self)",
        "snippet": "    def __init__(self):\n        # we have to use self.__dict__ because we override setattr.\n        self.__dict__['_options'] = {}\n        self.__dict__['_parse_callbacks'] = []\n        self.define(\"help\", type=bool, help=\"show this help information\",\n                    callback=self._help_callback)",
        "begin_line": 123,
        "end_line": 128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015730690577316344,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options.OptionParser._normalize_name#130",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser._normalize_name(self, name)",
        "snippet": "    def _normalize_name(self, name):\n        return name.replace('_', '-')",
        "begin_line": 130,
        "end_line": 131,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015730690577316344,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options.OptionParser.__getattr__#133",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        name = self._normalize_name(name)\n        if isinstance(self._options.get(name), _Option):\n            return self._options[name].value()\n        raise AttributeError(\"Unrecognized option %r\" % name)",
        "begin_line": 133,
        "end_line": 137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016880486158001352,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options.OptionParser.__setattr__#139",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.__setattr__(self, name, value)",
        "snippet": "    def __setattr__(self, name, value):\n        name = self._normalize_name(name)\n        if isinstance(self._options.get(name), _Option):\n            return self._options[name].set(value)\n        raise AttributeError(\"Unrecognized option %r\" % name)",
        "begin_line": 139,
        "end_line": 143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001885369532428356,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options.OptionParser.__iter__#145",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.__iter__(self)",
        "snippet": "    def __iter__(self):\n        return (opt.name for opt in self._options.values())",
        "begin_line": 145,
        "end_line": 146,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options.OptionParser.__getitem__#152",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.__getitem__(self, name)",
        "snippet": "    def __getitem__(self, name):\n        return self.__getattr__(name)",
        "begin_line": 152,
        "end_line": 153,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options.OptionParser.__setitem__#155",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.__setitem__(self, name, value)",
        "snippet": "    def __setitem__(self, name, value):\n        return self.__setattr__(name, value)",
        "begin_line": 155,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options.OptionParser.items#158",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.items(self)",
        "snippet": "    def items(self):\n        \"\"\"A sequence of (name, value) pairs.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        return [(opt.name, opt.value()) for name, opt in self._options.items()]",
        "begin_line": 158,
        "end_line": 163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options.OptionParser.groups#165",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.groups(self)",
        "snippet": "    def groups(self):\n        \"\"\"The set of option-groups created by ``define``.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        return set(opt.group_name for opt in self._options.values())",
        "begin_line": 165,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options.OptionParser.group_dict#172",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.group_dict(self, group)",
        "snippet": "    def group_dict(self, group):\n        \"\"\"The names and values of options in a group.\n\n        Useful for copying options into Application settings::\n\n            from tornado.options import define, parse_command_line, options\n\n            define('template_path', group='application')\n            define('static_path', group='application')\n\n            parse_command_line()\n\n            application = Application(\n                handlers, **options.group_dict('application'))\n\n        .. versionadded:: 3.1\n        \"\"\"\n        return dict(\n            (opt.name, opt.value()) for name, opt in self._options.items()\n            if not group or group == opt.group_name)",
        "begin_line": 172,
        "end_line": 191,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options.OptionParser.as_dict#193",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.as_dict(self)",
        "snippet": "    def as_dict(self):\n        \"\"\"The names and values of all options.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        return dict(\n            (opt.name, opt.value()) for name, opt in self._options.items())",
        "begin_line": 193,
        "end_line": 199,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options.OptionParser.define#201",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.define(self, name, default=None, type=None, help=None, metavar=None, multiple=False, group=None, callback=None)",
        "snippet": "    def define(self, name, default=None, type=None, help=None, metavar=None,\n               multiple=False, group=None, callback=None):\n        \"\"\"Defines a new command line option.\n\n        ``type`` can be any of `str`, `int`, `float`, `bool`,\n        `~datetime.datetime`, or `~datetime.timedelta`. If no ``type``\n        is given but a ``default`` is, ``type`` is the type of\n        ``default``. Otherwise, ``type`` defaults to `str`.\n\n        If ``multiple`` is True, the option value is a list of ``type``\n        instead of an instance of ``type``.\n\n        ``help`` and ``metavar`` are used to construct the\n        automatically generated command line help string. The help\n        message is formatted like::\n\n           --name=METAVAR      help string\n\n        ``group`` is used to group the defined options in logical\n        groups. By default, command line options are grouped by the\n        file in which they are defined.\n\n        Command line option names must be unique globally.\n\n        If a ``callback`` is given, it will be run with the new value whenever\n        the option is changed.  This can be used to combine command-line\n        and file-based options::\n\n            define(\"config\", type=str, help=\"path to config file\",\n                   callback=lambda path: parse_config_file(path, final=False))\n\n        With this definition, options in the file specified by ``--config`` will\n        override options set earlier on the command line, but can be overridden\n        by later flags.\n\n        \"\"\"\n        normalized = self._normalize_name(name)\n        if normalized in self._options:\n            raise Error(\"Option %r already defined in %s\" %\n                        (normalized, self._options[normalized].file_name))\n        frame = sys._getframe(0)\n        options_file = frame.f_code.co_filename\n\n        # Can be called directly, or through top level define() fn, in which\n        # case, step up above that frame to look for real caller.\n        if (frame.f_back.f_code.co_filename == options_file and\n                frame.f_back.f_code.co_name == 'define'):\n            frame = frame.f_back\n\n        file_name = frame.f_back.f_code.co_filename\n        if file_name == options_file:\n            file_name = \"\"\n        if type is None:\n            if not multiple and default is not None:\n                type = default.__class__\n            else:\n                type = str\n        if group:\n            group_name = group\n        else:\n            group_name = file_name\n        option = _Option(name, file_name=file_name,\n                         default=default, type=type, help=help,\n                         metavar=metavar, multiple=multiple,\n                         group_name=group_name,\n                         callback=callback)\n        self._options[normalized] = option",
        "begin_line": 201,
        "end_line": 267,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options.OptionParser.parse_command_line#269",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.parse_command_line(self, args=None, final=True)",
        "snippet": "    def parse_command_line(self, args=None, final=True):\n        \"\"\"Parses all options given on the command line (defaults to\n        `sys.argv`).\n\n        Options look like ``--option=value`` and are parsed according\n        to their ``type``. For boolean options, ``--option`` is\n        equivalent to ``--option=true``\n\n        If the option has ``multiple=True``, comma-separated values\n        are accepted. For multi-value integer options, the syntax\n        ``x:y`` is also accepted and equivalent to ``range(x, y)``.\n\n        Note that ``args[0]`` is ignored since it is the program name\n        in `sys.argv`.\n\n        We return a list of all arguments that are not parsed as options.\n\n        If ``final`` is ``False``, parse callbacks will not be run.\n        This is useful for applications that wish to combine configurations\n        from multiple sources.\n\n        \"\"\"\n        if args is None:\n            args = sys.argv\n        remaining = []\n        for i in range(1, len(args)):\n            # All things after the last option are command line arguments\n            if not args[i].startswith(\"-\"):\n                remaining = args[i:]\n                break\n            if args[i] == \"--\":\n                remaining = args[i + 1:]\n                break\n            arg = args[i].lstrip(\"-\")\n            name, equals, value = arg.partition(\"=\")\n            name = self._normalize_name(name)\n            if name not in self._options:\n                self.print_help()\n                raise Error('Unrecognized command line option: %r' % name)\n            option = self._options[name]\n            if not equals:\n                if option.type == bool:\n                    value = \"true\"\n                else:\n                    raise Error('Option %r requires a value' % name)\n            option.parse(value)\n\n        if final:\n            self.run_parse_callbacks()\n\n        return remaining",
        "begin_line": 269,
        "end_line": 319,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options.OptionParser.parse_config_file#321",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.parse_config_file(self, path, final=True)",
        "snippet": "    def parse_config_file(self, path, final=True):\n        \"\"\"Parses and loads the config file at the given path.\n\n        The config file contains Python code that will be executed (so\n        it is **not safe** to use untrusted config files). Anything in\n        the global namespace that matches a defined option will be\n        used to set that option's value.\n\n        Options are not parsed from strings as they would be on the\n        command line; they should be set to the correct type (this\n        means if you have ``datetime`` or ``timedelta`` options you\n        will need to import those modules in the config file.\n\n        Example (using the options defined in the top-level docs of\n        this module)::\n\n            port = 80\n            mysql_host = 'mydb.example.com:3306'\n            memcache_hosts = ['cache1.example.com:11011',\n                              'cache2.example.com:11011']\n\n        If ``final`` is ``False``, parse callbacks will not be run.\n        This is useful for applications that wish to combine configurations\n        from multiple sources.\n\n        .. note::\n\n            `tornado.options` is primarily a command-line library.\n            Config file support is provided for applications that wish\n            to use it, but applications that prefer config files may\n            wish to look at other libraries instead.\n\n        .. versionchanged:: 4.1\n           Config files are now always interpreted as utf-8 instead of\n           the system default encoding.\n\n        .. versionchanged:: 4.4\n           The special variable ``__file__`` is available inside config\n           files, specifying the absolute path to the config file itself.\n\n        \"\"\"\n        config = {'__file__': os.path.abspath(path)}\n        with open(path, 'rb') as f:\n            exec_in(native_str(f.read()), config, config)\n        for name in config:\n            normalized = self._normalize_name(name)\n            if normalized in self._options:\n                self._options[normalized].set(config[name])\n\n        if final:\n            self.run_parse_callbacks()",
        "begin_line": 321,
        "end_line": 371,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options.OptionParser.print_help#373",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.print_help(self, file=None)",
        "snippet": "    def print_help(self, file=None):\n        \"\"\"Prints all the command line options to stderr (or another file).\"\"\"\n        if file is None:\n            file = sys.stderr\n        print(\"Usage: %s [OPTIONS]\" % sys.argv[0], file=file)\n        print(\"\\nOptions:\\n\", file=file)\n        by_group = {}\n        for option in self._options.values():\n            by_group.setdefault(option.group_name, []).append(option)\n\n        for filename, o in sorted(by_group.items()):\n            if filename:\n                print(\"\\n%s options:\\n\" % os.path.normpath(filename), file=file)\n            o.sort(key=lambda option: option.name)\n            for option in o:\n                # Always print names with dashes in a CLI context.\n                prefix = self._normalize_name(option.name)\n                if option.metavar:\n                    prefix += \"=\" + option.metavar\n                description = option.help or \"\"\n                if option.default is not None and option.default != '':\n                    description += \" (default %s)\" % option.default\n                lines = textwrap.wrap(description, 79 - 35)\n                if len(prefix) > 30 or len(lines) == 0:\n                    lines.insert(0, '')\n                print(\"  --%-30s %s\" % (prefix, lines[0]), file=file)\n                for line in lines[1:]:\n                    print(\"%-34s %s\" % (' ', line), file=file)\n        print(file=file)",
        "begin_line": 373,
        "end_line": 401,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options.OptionParser._help_callback#403",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser._help_callback(self, value)",
        "snippet": "    def _help_callback(self, value):\n        if value:\n            self.print_help()\n            sys.exit(0)",
        "begin_line": 403,
        "end_line": 406,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options.OptionParser.add_parse_callback#408",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.add_parse_callback(self, callback)",
        "snippet": "    def add_parse_callback(self, callback):\n        \"\"\"Adds a parse callback, to be invoked when option parsing is done.\"\"\"\n        self._parse_callbacks.append(stack_context.wrap(callback))",
        "begin_line": 408,
        "end_line": 410,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options.OptionParser.run_parse_callbacks#412",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.run_parse_callbacks(self)",
        "snippet": "    def run_parse_callbacks(self):\n        for callback in self._parse_callbacks:\n            callback()",
        "begin_line": 412,
        "end_line": 414,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options.OptionParser.mockable#416",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options.OptionParser",
        "signature": "tornado.options.OptionParser.mockable(self)",
        "snippet": "    def mockable(self):\n        \"\"\"Returns a wrapper around self that is compatible with\n        `mock.patch <unittest.mock.patch>`.\n\n        The `mock.patch <unittest.mock.patch>` function (included in\n        the standard library `unittest.mock` package since Python 3.3,\n        or in the third-party ``mock`` package for older versions of\n        Python) is incompatible with objects like ``options`` that\n        override ``__getattr__`` and ``__setattr__``.  This function\n        returns an object that can be used with `mock.patch.object\n        <unittest.mock.patch.object>` to modify option values::\n\n            with mock.patch.object(options.mockable(), 'name', value):\n                assert options.name == value\n        \"\"\"\n        return _Mockable(self)",
        "begin_line": 416,
        "end_line": 431,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options._Mockable.__init__#446",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Mockable",
        "signature": "tornado.options._Mockable.__init__(self, options)",
        "snippet": "    def __init__(self, options):\n        # Modify __dict__ directly to bypass __setattr__\n        self.__dict__['_options'] = options\n        self.__dict__['_originals'] = {}",
        "begin_line": 446,
        "end_line": 449,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options._Mockable.__getattr__#451",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Mockable",
        "signature": "tornado.options._Mockable.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        return getattr(self._options, name)",
        "begin_line": 451,
        "end_line": 452,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options._Mockable.__setattr__#454",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Mockable",
        "signature": "tornado.options._Mockable.__setattr__(self, name, value)",
        "snippet": "    def __setattr__(self, name, value):\n        assert name not in self._originals, \"don't reuse mockable objects\"\n        self._originals[name] = getattr(self._options, name)\n        setattr(self._options, name, value)",
        "begin_line": 454,
        "end_line": 457,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options._Mockable.__delattr__#459",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Mockable",
        "signature": "tornado.options._Mockable.__delattr__(self, name)",
        "snippet": "    def __delattr__(self, name):\n        setattr(self._options, name, self._originals.pop(name))",
        "begin_line": 459,
        "end_line": 460,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options._Option.__init__#466",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Option",
        "signature": "tornado.options._Option.__init__(self, name, default=None, type=basestring_type, help=None, metavar=None, multiple=False, file_name=None, group_name=None, callback=None)",
        "snippet": "    def __init__(self, name, default=None, type=basestring_type, help=None,\n                 metavar=None, multiple=False, file_name=None, group_name=None,\n                 callback=None):\n        if default is None and multiple:\n            default = []\n        self.name = name\n        self.type = type\n        self.help = help\n        self.metavar = metavar\n        self.multiple = multiple\n        self.file_name = file_name\n        self.group_name = group_name\n        self.callback = callback\n        self.default = default\n        self._value = _Option.UNSET",
        "begin_line": 466,
        "end_line": 480,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options._Option.value#482",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Option",
        "signature": "tornado.options._Option.value(self)",
        "snippet": "    def value(self):\n        return self.default if self._value is _Option.UNSET else self._value",
        "begin_line": 482,
        "end_line": 483,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016622340425531914,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options._Option.parse#485",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Option",
        "signature": "tornado.options._Option.parse(self, value)",
        "snippet": "    def parse(self, value):\n        _parse = {\n            datetime.datetime: self._parse_datetime,\n            datetime.timedelta: self._parse_timedelta,\n            bool: self._parse_bool,\n            basestring_type: self._parse_string,\n        }.get(self.type, self.type)\n        if self.multiple:\n            self._value = []\n            for part in value.split(\",\"):\n                if issubclass(self.type, numbers.Integral):\n                    # allow ranges of the form X:Y (inclusive at both ends)\n                    lo, _, hi = part.partition(\":\")\n                    lo = _parse(lo)\n                    hi = _parse(hi) if hi else lo\n                    self._value.extend(range(lo, hi + 1))\n                else:\n                    self._value.append(_parse(part))\n        else:\n            self._value = _parse(value)\n        if self.callback is not None:\n            self.callback(self._value)\n        return self.value()",
        "begin_line": 485,
        "end_line": 507,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options._Option.set#509",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Option",
        "signature": "tornado.options._Option.set(self, value)",
        "snippet": "    def set(self, value):\n        if self.multiple:\n            if not isinstance(value, list):\n                raise Error(\"Option %r is required to be a list of %s\" %\n                            (self.name, self.type.__name__))\n            for item in value:\n                if item is not None and not isinstance(item, self.type):\n                    raise Error(\"Option %r is required to be a list of %s\" %\n                                (self.name, self.type.__name__))\n        else:\n            if value is not None and not isinstance(value, self.type):\n                raise Error(\"Option %r is required to be a %s (%s given)\" %\n                            (self.name, self.type.__name__, type(value)))\n        self._value = value\n        if self.callback is not None:\n            self.callback(self._value)",
        "begin_line": 509,
        "end_line": 524,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options._Option._parse_datetime#540",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Option",
        "signature": "tornado.options._Option._parse_datetime(self, value)",
        "snippet": "    def _parse_datetime(self, value):\n        for format in self._DATETIME_FORMATS:\n            try:\n                return datetime.datetime.strptime(value, format)\n            except ValueError:\n                pass\n        raise Error('Unrecognized date/time format: %r' % value)",
        "begin_line": 540,
        "end_line": 546,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options._Option._parse_timedelta#565",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Option",
        "signature": "tornado.options._Option._parse_timedelta(self, value)",
        "snippet": "    def _parse_timedelta(self, value):\n        try:\n            sum = datetime.timedelta()\n            start = 0\n            while start < len(value):\n                m = self._TIMEDELTA_PATTERN.match(value, start)\n                if not m:\n                    raise Exception()\n                num = float(m.group(1))\n                units = m.group(2) or 'seconds'\n                units = self._TIMEDELTA_ABBREV_DICT.get(units, units)\n                sum += datetime.timedelta(**{units: num})\n                start = m.end()\n            return sum\n        except Exception:\n            raise",
        "begin_line": 565,
        "end_line": 580,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options._Option._parse_bool#582",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Option",
        "signature": "tornado.options._Option._parse_bool(self, value)",
        "snippet": "    def _parse_bool(self, value):\n        return value.lower() not in (\"false\", \"0\", \"f\")",
        "begin_line": 582,
        "end_line": 583,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.options._Option._parse_string#585",
        "src_path": "tornado/options.py",
        "class_name": "tornado.options._Option",
        "signature": "tornado.options._Option._parse_string(self, value)",
        "snippet": "    def _parse_string(self, value):\n        return _unicode(value)",
        "begin_line": 585,
        "end_line": 586,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.stack_context._State.__init__#82",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context._State",
        "signature": "tornado.stack_context._State.__init__(self)",
        "snippet": "    def __init__(self):\n        self.contexts = (tuple(), None)",
        "begin_line": 82,
        "end_line": 83,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.stack_context.StackContext.__init__#109",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context.StackContext",
        "signature": "tornado.stack_context.StackContext.__init__(self, context_factory)",
        "snippet": "    def __init__(self, context_factory):\n        self.context_factory = context_factory\n        self.contexts = []\n        self.active = True",
        "begin_line": 109,
        "end_line": 112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017295053614666206,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.stack_context.StackContext._deactivate#114",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context.StackContext",
        "signature": "tornado.stack_context.StackContext._deactivate(self)",
        "snippet": "    def _deactivate(self):\n        self.active = False",
        "begin_line": 114,
        "end_line": 115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.stack_context.StackContext.enter#118",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context.StackContext",
        "signature": "tornado.stack_context.StackContext.enter(self)",
        "snippet": "    def enter(self):\n        context = self.context_factory()\n        self.contexts.append(context)\n        context.__enter__()",
        "begin_line": 118,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017295053614666206,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.stack_context.StackContext.exit#123",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context.StackContext",
        "signature": "tornado.stack_context.StackContext.exit(self, type, value, traceback)",
        "snippet": "    def exit(self, type, value, traceback):\n        context = self.contexts.pop()\n        context.__exit__(type, value, traceback)",
        "begin_line": 123,
        "end_line": 125,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017295053614666206,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.stack_context.StackContext.__enter__#130",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context.StackContext",
        "signature": "tornado.stack_context.StackContext.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self.old_contexts = _state.contexts\n        self.new_contexts = (self.old_contexts[0] + (self,), self)\n        _state.contexts = self.new_contexts\n\n        try:\n            self.enter()\n        except:\n            _state.contexts = self.old_contexts\n            raise\n\n        return self._deactivate",
        "begin_line": 130,
        "end_line": 141,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017295053614666206,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.stack_context.StackContext.__exit__#143",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context.StackContext",
        "signature": "tornado.stack_context.StackContext.__exit__(self, type, value, traceback)",
        "snippet": "    def __exit__(self, type, value, traceback):\n        try:\n            self.exit(type, value, traceback)\n        finally:\n            final_contexts = _state.contexts\n            _state.contexts = self.old_contexts\n\n            # Generator coroutines and with-statements with non-local\n            # effects interact badly.  Check here for signs of\n            # the stack getting out of sync.\n            # Note that this check comes after restoring _state.context\n            # so that if it fails things are left in a (relatively)\n            # consistent state.\n            if final_contexts is not self.new_contexts:\n                raise StackContextInconsistentError(\n                    'stack_context inconsistency (may be caused by yield '\n                    'within a \"with StackContext\" block)')\n\n            # Break up a reference to itself to allow for faster GC on CPython.\n            self.new_contexts = None",
        "begin_line": 143,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017295053614666206,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.stack_context.ExceptionStackContext.__init__#178",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context.ExceptionStackContext",
        "signature": "tornado.stack_context.ExceptionStackContext.__init__(self, exception_handler)",
        "snippet": "    def __init__(self, exception_handler):\n        self.exception_handler = exception_handler\n        self.active = True",
        "begin_line": 178,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024154589371980675,
            "pseudo_dstar_susp": 0.008695652173913044,
            "pseudo_tarantula_susp": 0.001402524544179523,
            "pseudo_op2_susp": 0.008695652173913044,
            "pseudo_barinel_susp": 0.001402524544179523
        }
    },
    {
        "name": "tornado.stack_context.ExceptionStackContext._deactivate#182",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context.ExceptionStackContext",
        "signature": "tornado.stack_context.ExceptionStackContext._deactivate(self)",
        "snippet": "    def _deactivate(self):\n        self.active = False",
        "begin_line": 182,
        "end_line": 183,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015422578655151142,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.stack_context.ExceptionStackContext.exit#185",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context.ExceptionStackContext",
        "signature": "tornado.stack_context.ExceptionStackContext.exit(self, type, value, traceback)",
        "snippet": "    def exit(self, type, value, traceback):\n        if type is not None:\n            return self.exception_handler(type, value, traceback)",
        "begin_line": 185,
        "end_line": 187,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.003003003003003003,
            "pseudo_tarantula_susp": 0.0045662100456621,
            "pseudo_op2_susp": 0.003003003003003003,
            "pseudo_barinel_susp": 0.004608294930875576
        }
    },
    {
        "name": "tornado.stack_context.ExceptionStackContext.__enter__#189",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context.ExceptionStackContext",
        "signature": "tornado.stack_context.ExceptionStackContext.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self.old_contexts = _state.contexts\n        self.new_contexts = (self.old_contexts[0], self)\n        _state.contexts = self.new_contexts\n\n        return self._deactivate",
        "begin_line": 189,
        "end_line": 194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024154589371980675,
            "pseudo_dstar_susp": 0.008695652173913044,
            "pseudo_tarantula_susp": 0.001402524544179523,
            "pseudo_op2_susp": 0.008695652173913044,
            "pseudo_barinel_susp": 0.001402524544179523
        }
    },
    {
        "name": "tornado.stack_context.ExceptionStackContext.__exit__#196",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context.ExceptionStackContext",
        "signature": "tornado.stack_context.ExceptionStackContext.__exit__(self, type, value, traceback)",
        "snippet": "    def __exit__(self, type, value, traceback):\n        try:\n            if type is not None:\n                return self.exception_handler(type, value, traceback)\n        finally:\n            final_contexts = _state.contexts\n            _state.contexts = self.old_contexts\n\n            if final_contexts is not self.new_contexts:\n                raise StackContextInconsistentError(\n                    'stack_context inconsistency (may be caused by yield '\n                    'within a \"with StackContext\" block)')\n\n            # Break up a reference to itself to allow for faster GC on CPython.\n            self.new_contexts = None",
        "begin_line": 196,
        "end_line": 210,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024154589371980675,
            "pseudo_dstar_susp": 0.008695652173913044,
            "pseudo_tarantula_susp": 0.001402524544179523,
            "pseudo_op2_susp": 0.008695652173913044,
            "pseudo_barinel_susp": 0.001402524544179523
        }
    },
    {
        "name": "tornado.stack_context.NullContext.__enter__#220",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context.NullContext",
        "signature": "tornado.stack_context.NullContext.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self.old_contexts = _state.contexts\n        _state.contexts = (tuple(), None)",
        "begin_line": 220,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003861003861003861,
            "pseudo_dstar_susp": 0.004545454545454545,
            "pseudo_tarantula_susp": 0.0018975332068311196,
            "pseudo_op2_susp": 0.004545454545454545,
            "pseudo_barinel_susp": 0.0018975332068311196
        }
    },
    {
        "name": "tornado.stack_context.NullContext.__exit__#224",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context.NullContext",
        "signature": "tornado.stack_context.NullContext.__exit__(self, type, value, traceback)",
        "snippet": "    def __exit__(self, type, value, traceback):\n        _state.contexts = self.old_contexts",
        "begin_line": 224,
        "end_line": 225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003861003861003861,
            "pseudo_dstar_susp": 0.004545454545454545,
            "pseudo_tarantula_susp": 0.0018975332068311196,
            "pseudo_op2_susp": 0.004545454545454545,
            "pseudo_barinel_susp": 0.0018975332068311196
        }
    },
    {
        "name": "tornado.stack_context._remove_deactivated#228",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context",
        "signature": "tornado.stack_context._remove_deactivated(contexts)",
        "snippet": "def _remove_deactivated(contexts):\n    \"\"\"Remove deactivated handlers from the chain\"\"\"\n    # Clean ctx handlers\n    stack_contexts = tuple([h for h in contexts[0] if h.active])\n\n    # Find new head\n    head = contexts[1]\n    while head is not None and not head.active:\n        head = head.old_contexts[1]\n\n    # Process chain\n    ctx = head\n    while ctx is not None:\n        parent = ctx.old_contexts[1]\n\n        while parent is not None:\n            if parent.active:\n                break\n            ctx.old_contexts = parent.old_contexts\n            parent = parent.old_contexts[1]\n\n        ctx = parent\n\n    return (stack_contexts, head)",
        "begin_line": 228,
        "end_line": 251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007462686567164179,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.0015625,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.0015625
        }
    },
    {
        "name": "tornado.stack_context.wrap#254",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context",
        "signature": "tornado.stack_context.wrap(fn)",
        "snippet": "def wrap(fn):\n    \"\"\"Returns a callable object that will restore the current `StackContext`\n    when executed.\n\n    Use this whenever saving a callback to be executed later in a\n    different execution context (either in a different thread or\n    asynchronously in the same thread).\n    \"\"\"\n    # Check if function is already wrapped\n    if fn is None or hasattr(fn, '_wrapped'):\n        return fn\n\n    # Capture current stack head\n    # TODO: Any other better way to store contexts and update them in wrapped function?\n    cap_contexts = [_state.contexts]\n\n    if not cap_contexts[0][0] and not cap_contexts[0][1]:\n        # Fast path when there are no active contexts.\n        def null_wrapper(*args, **kwargs):\n            try:\n                current_state = _state.contexts\n                _state.contexts = cap_contexts[0]\n                return fn(*args, **kwargs)\n            finally:\n                _state.contexts = current_state\n        null_wrapper._wrapped = True\n        return null_wrapper\n\n    def wrapped(*args, **kwargs):\n        ret = None\n        try:\n            # Capture old state\n            current_state = _state.contexts\n\n            # Remove deactivated items\n            cap_contexts[0] = contexts = _remove_deactivated(cap_contexts[0])\n\n            # Force new state\n            _state.contexts = contexts\n\n            # Current exception\n            exc = (None, None, None)\n            top = None\n\n            # Apply stack contexts\n            last_ctx = 0\n            stack = contexts[0]\n\n            # Apply state\n            for n in stack:\n                try:\n                    n.enter()\n                    last_ctx += 1\n                except:\n                    # Exception happened. Record exception info and store top-most handler\n                    exc = sys.exc_info()\n                    top = n.old_contexts[1]\n\n            # Execute callback if no exception happened while restoring state\n            if top is None:\n                try:\n                    ret = fn(*args, **kwargs)\n                except:\n                    exc = sys.exc_info()\n                    top = contexts[1]\n\n            # If there was exception, try to handle it by going through the exception chain\n            if top is not None:\n                exc = _handle_exception(top, exc)\n            else:\n                # Otherwise take shorter path and run stack contexts in reverse order\n                while last_ctx > 0:\n                    last_ctx -= 1\n                    c = stack[last_ctx]\n\n                    try:\n                        c.exit(*exc)\n                    except:\n                        exc = sys.exc_info()\n                        top = c.old_contexts[1]\n                        break\n                else:\n                    top = None\n\n                # If if exception happened while unrolling, take longer exception handler path\n                if top is not None:\n                    exc = _handle_exception(top, exc)\n\n            # If exception was not handled, raise it\n            if exc != (None, None, None):\n                raise_exc_info(exc)\n        finally:\n            _state.contexts = current_state\n        return ret\n\n    wrapped._wrapped = True\n    return wrapped",
        "begin_line": 254,
        "end_line": 350,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005952380952380952,
            "pseudo_dstar_susp": 0.07692307692307693,
            "pseudo_tarantula_susp": 0.0024937655860349127,
            "pseudo_op2_susp": 0.07692307692307693,
            "pseudo_barinel_susp": 0.0024937655860349127
        }
    },
    {
        "name": "tornado.stack_context.null_wrapper#272",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context",
        "signature": "tornado.stack_context.null_wrapper(*args, **kwargs)",
        "snippet": "        def null_wrapper(*args, **kwargs):\n            try:\n                current_state = _state.contexts\n                _state.contexts = cap_contexts[0]\n                return fn(*args, **kwargs)\n            finally:\n                _state.contexts = current_state",
        "begin_line": 272,
        "end_line": 278,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010752688172043012,
            "pseudo_dstar_susp": 1.0,
            "pseudo_tarantula_susp": 0.0024154589371980675,
            "pseudo_op2_susp": 1.0,
            "pseudo_barinel_susp": 0.0024154589371980675
        }
    },
    {
        "name": "tornado.stack_context.wrapped#282",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context",
        "signature": "tornado.stack_context.wrapped(*args, **kwargs)",
        "snippet": "    def wrapped(*args, **kwargs):\n        ret = None\n        try:\n            # Capture old state\n            current_state = _state.contexts\n\n            # Remove deactivated items\n            cap_contexts[0] = contexts = _remove_deactivated(cap_contexts[0])\n\n            # Force new state\n            _state.contexts = contexts\n\n            # Current exception\n            exc = (None, None, None)\n            top = None\n\n            # Apply stack contexts\n            last_ctx = 0\n            stack = contexts[0]\n\n            # Apply state\n            for n in stack:\n                try:\n                    n.enter()\n                    last_ctx += 1\n                except:\n                    # Exception happened. Record exception info and store top-most handler\n                    exc = sys.exc_info()\n                    top = n.old_contexts[1]\n\n            # Execute callback if no exception happened while restoring state\n            if top is None:\n                try:\n                    ret = fn(*args, **kwargs)\n                except:\n                    exc = sys.exc_info()\n                    top = contexts[1]\n\n            # If there was exception, try to handle it by going through the exception chain\n            if top is not None:\n                exc = _handle_exception(top, exc)\n            else:\n                # Otherwise take shorter path and run stack contexts in reverse order\n                while last_ctx > 0:\n                    last_ctx -= 1\n                    c = stack[last_ctx]\n\n                    try:\n                        c.exit(*exc)\n                    except:\n                        exc = sys.exc_info()\n                        top = c.old_contexts[1]\n                        break\n                else:\n                    top = None\n\n                # If if exception happened while unrolling, take longer exception handler path\n                if top is not None:\n                    exc = _handle_exception(top, exc)\n\n            # If exception was not handled, raise it\n            if exc != (None, None, None):\n                raise_exc_info(exc)\n        finally:\n            _state.contexts = current_state\n        return ret",
        "begin_line": 282,
        "end_line": 347,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.25,
            "pseudo_tarantula_susp": 0.0045662100456621,
            "pseudo_op2_susp": 0.25,
            "pseudo_barinel_susp": 0.004608294930875576
        }
    },
    {
        "name": "tornado.stack_context._handle_exception#353",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context",
        "signature": "tornado.stack_context._handle_exception(tail, exc)",
        "snippet": "def _handle_exception(tail, exc):\n    while tail is not None:\n        try:\n            if tail.exit(*exc):\n                exc = (None, None, None)\n        except:\n            exc = sys.exc_info()\n\n        tail = tail.old_contexts[1]\n\n    return exc",
        "begin_line": 353,
        "end_line": 363,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.003003003003003003,
            "pseudo_tarantula_susp": 0.0045662100456621,
            "pseudo_op2_susp": 0.003003003003003003,
            "pseudo_barinel_susp": 0.004608294930875576
        }
    },
    {
        "name": "tornado.stack_context.run_with_stack_context#366",
        "src_path": "tornado/stack_context.py",
        "class_name": "tornado.stack_context",
        "signature": "tornado.stack_context.run_with_stack_context(context, func)",
        "snippet": "def run_with_stack_context(context, func):\n    \"\"\"Run a coroutine ``func`` in the given `StackContext`.\n\n    It is not safe to have a ``yield`` statement within a ``with StackContext``\n    block, so it is difficult to use stack context with `.gen.coroutine`.\n    This helper function runs the function in the correct context while\n    keeping the ``yield`` and ``with`` statements syntactically separate.\n\n    Example::\n\n        @gen.coroutine\n        def incorrect():\n            with StackContext(ctx):\n                # ERROR: this will raise StackContextInconsistentError\n                yield other_coroutine()\n\n        @gen.coroutine\n        def correct():\n            yield run_with_stack_context(StackContext(ctx), other_coroutine)\n\n    .. versionadded:: 3.1\n    \"\"\"\n    with context:\n        return func()",
        "begin_line": 366,
        "end_line": 389,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.__init__#168",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.__init__(self, application, request, **kwargs)",
        "snippet": "    def __init__(self, application, request, **kwargs):\n        super(RequestHandler, self).__init__()\n\n        self.application = application\n        self.request = request\n        self._headers_written = False\n        self._finished = False\n        self._auto_finish = True\n        self._transforms = None  # will be set in _execute\n        self._prepared_future = None\n        self._headers = None  # type: httputil.HTTPHeaders\n        self.path_args = None\n        self.path_kwargs = None\n        self.ui = ObjectDict((n, self._ui_method(m)) for n, m in\n                             application.ui_methods.items())\n        # UIModules are available as both `modules` and `_tt_modules` in the\n        # template namespace.  Historically only `modules` was available\n        # but could be clobbered by user additions to the namespace.\n        # The template {% module %} directive looks in `_tt_modules` to avoid\n        # possible conflicts.\n        self.ui[\"_tt_modules\"] = _UIModuleNamespace(self,\n                                                    application.ui_modules)\n        self.ui[\"modules\"] = self.ui[\"_tt_modules\"]\n        self.clear()\n        self.request.connection.set_close_callback(self.on_connection_close)\n        self.initialize(**kwargs)",
        "begin_line": 168,
        "end_line": 193,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000517063081695967,
            "pseudo_dstar_susp": 0.0006693440428380187,
            "pseudo_tarantula_susp": 0.0004351610095735422,
            "pseudo_op2_susp": 0.0006693440428380187,
            "pseudo_barinel_susp": 0.0004351610095735422
        }
    },
    {
        "name": "tornado.web.RequestHandler.initialize#195",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.initialize(self)",
        "snippet": "    def initialize(self):\n        \"\"\"Hook for subclass initialization. Called for each request.\n\n        A dictionary passed as the third argument of a url spec will be\n        supplied as keyword arguments to initialize().\n\n        Example::\n\n            class ProfileHandler(RequestHandler):\n                def initialize(self, database):\n                    self.database = database\n\n                def get(self, username):\n                    ...\n\n            app = Application([\n                (r'/user/(.*)', ProfileHandler, dict(database=database)),\n                ])\n        \"\"\"\n        pass",
        "begin_line": 195,
        "end_line": 214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003968253968253968,
            "pseudo_dstar_susp": 0.00042625745950554135,
            "pseudo_tarantula_susp": 0.00040584415584415587,
            "pseudo_op2_susp": 0.00042625745950554135,
            "pseudo_barinel_susp": 0.00040584415584415587
        }
    },
    {
        "name": "tornado.web.RequestHandler.settings#217",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.settings(self)",
        "snippet": "    def settings(self):\n        \"\"\"An alias for `self.application.settings <Application.settings>`.\"\"\"\n        return self.application.settings",
        "begin_line": 217,
        "end_line": 219,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013473457289140393,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.head#221",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.head(self, *args, **kwargs)",
        "snippet": "    def head(self, *args, **kwargs):\n        raise HTTPError(405)",
        "begin_line": 221,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001885369532428356,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.get#224",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get(self, *args, **kwargs)",
        "snippet": "    def get(self, *args, **kwargs):\n        raise HTTPError(405)",
        "begin_line": 224,
        "end_line": 225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.post#227",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.post(self, *args, **kwargs)",
        "snippet": "    def post(self, *args, **kwargs):\n        raise HTTPError(405)",
        "begin_line": 227,
        "end_line": 228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.delete#230",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.delete(self, *args, **kwargs)",
        "snippet": "    def delete(self, *args, **kwargs):\n        raise HTTPError(405)",
        "begin_line": 230,
        "end_line": 231,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.patch#233",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.patch(self, *args, **kwargs)",
        "snippet": "    def patch(self, *args, **kwargs):\n        raise HTTPError(405)",
        "begin_line": 233,
        "end_line": 234,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.put#236",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.put(self, *args, **kwargs)",
        "snippet": "    def put(self, *args, **kwargs):\n        raise HTTPError(405)",
        "begin_line": 236,
        "end_line": 237,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.options#239",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.options(self, *args, **kwargs)",
        "snippet": "    def options(self, *args, **kwargs):\n        raise HTTPError(405)",
        "begin_line": 239,
        "end_line": 240,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.prepare#242",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.prepare(self)",
        "snippet": "    def prepare(self):\n        \"\"\"Called at the beginning of a request before  `get`/`post`/etc.\n\n        Override this method to perform common initialization regardless\n        of the request method.\n\n        Asynchronous support: Decorate this method with `.gen.coroutine`\n        or use ``async def`` to make it asynchronous (the\n        `asynchronous` decorator cannot be used on `prepare`).\n        If this method returns a `.Future` execution will not proceed\n        until the `.Future` is done.\n\n        .. versionadded:: 3.1\n           Asynchronous support.\n        \"\"\"\n        pass",
        "begin_line": 242,
        "end_line": 257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003952569169960474,
            "pseudo_dstar_susp": 0.000425531914893617,
            "pseudo_tarantula_susp": 0.000392156862745098,
            "pseudo_op2_susp": 0.000425531914893617,
            "pseudo_barinel_susp": 0.000392156862745098
        }
    },
    {
        "name": "tornado.web.RequestHandler.on_finish#259",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.on_finish(self)",
        "snippet": "    def on_finish(self):\n        \"\"\"Called after the end of a request.\n\n        Override this method to perform cleanup, logging, etc.\n        This method is a counterpart to `prepare`.  ``on_finish`` may\n        not produce any output, as it is called after the response\n        has been sent to the client.\n        \"\"\"\n        pass",
        "begin_line": 259,
        "end_line": 267,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004083299305839118,
            "pseudo_dstar_susp": 0.00044943820224719103,
            "pseudo_tarantula_susp": 0.0004020908725371934,
            "pseudo_op2_susp": 0.00044943820224719103,
            "pseudo_barinel_susp": 0.0004020908725371934
        }
    },
    {
        "name": "tornado.web.RequestHandler.on_connection_close#269",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.on_connection_close(self)",
        "snippet": "    def on_connection_close(self):\n        \"\"\"Called in async handlers if the client closed the connection.\n\n        Override this to clean up resources associated with\n        long-lived connections.  Note that this method is called only if\n        the connection was closed during asynchronous processing; if you\n        need to do cleanup after every request override `on_finish`\n        instead.\n\n        Proxies may keep a connection open for a time (perhaps\n        indefinitely) after the client has gone away, so this method\n        may not be called promptly after the end user closes their\n        connection.\n        \"\"\"\n        if _has_stream_request_body(self.__class__):\n            if not self.request.body.done():\n                self.request.body.set_exception(iostream.StreamClosedError())\n                self.request.body.exception()",
        "begin_line": 269,
        "end_line": 286,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008382229673093043,
            "pseudo_dstar_susp": 0.0004789272030651341,
            "pseudo_tarantula_susp": 0.0038461538461538464,
            "pseudo_op2_susp": 0.0004789272030651341,
            "pseudo_barinel_susp": 0.0038461538461538464
        }
    },
    {
        "name": "tornado.web.RequestHandler.clear#288",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.clear(self)",
        "snippet": "    def clear(self):\n        \"\"\"Resets all headers and content for this response.\"\"\"\n        self._headers = httputil.HTTPHeaders({\n            \"Server\": \"TornadoServer/%s\" % tornado.version,\n            \"Content-Type\": \"text/html; charset=UTF-8\",\n            \"Date\": httputil.format_timestamp(time.time()),\n        })\n        self.set_default_headers()\n        self._write_buffer = []\n        self._status_code = 200\n        self._reason = httputil.responses[200]",
        "begin_line": 288,
        "end_line": 298,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00044583147570218456,
            "pseudo_dstar_susp": 0.000514668039114771,
            "pseudo_tarantula_susp": 0.0004351610095735422,
            "pseudo_op2_susp": 0.000514668039114771,
            "pseudo_barinel_susp": 0.0004351610095735422
        }
    },
    {
        "name": "tornado.web.RequestHandler.set_default_headers#300",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.set_default_headers(self)",
        "snippet": "    def set_default_headers(self):\n        \"\"\"Override this to set HTTP headers at the beginning of the request.\n\n        For example, this is the place to set a custom ``Server`` header.\n        Note that setting such headers in the normal flow of request\n        processing may not do what you want, since headers may be reset\n        during error handling.\n        \"\"\"\n        pass",
        "begin_line": 300,
        "end_line": 308,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004506534474988734,
            "pseudo_dstar_susp": 0.0005211047420531526,
            "pseudo_tarantula_susp": 0.00044014084507042255,
            "pseudo_op2_susp": 0.0005211047420531526,
            "pseudo_barinel_susp": 0.00044014084507042255
        }
    },
    {
        "name": "tornado.web.RequestHandler.set_status#310",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.set_status(self, status_code, reason=None)",
        "snippet": "    def set_status(self, status_code, reason=None):\n        \"\"\"Sets the status code for our response.\n\n        :arg int status_code: Response status code.\n        :arg str reason: Human-readable reason phrase describing the status\n            code. If ``None``, it will be filled in from\n            `http.client.responses` or \"Unknown\".\n\n        .. versionchanged:: 5.0\n\n           No longer validates that the response code is in\n           `http.client.responses`.\n        \"\"\"\n        self._status_code = status_code\n        if reason is not None:\n            self._reason = escape.native_str(reason)\n        else:\n            self._reason = httputil.responses.get(status_code, \"Unknown\")",
        "begin_line": 310,
        "end_line": 327,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019275250578257516,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_status#329",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_status(self)",
        "snippet": "    def get_status(self):\n        \"\"\"Returns the status code for our response.\"\"\"\n        return self._status_code",
        "begin_line": 329,
        "end_line": 331,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004083299305839118,
            "pseudo_dstar_susp": 0.00044943820224719103,
            "pseudo_tarantula_susp": 0.0004020908725371934,
            "pseudo_op2_susp": 0.00044943820224719103,
            "pseudo_barinel_susp": 0.0004020908725371934
        }
    },
    {
        "name": "tornado.web.RequestHandler.set_header#333",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.set_header(self, name, value)",
        "snippet": "    def set_header(self, name, value):\n        # type: (str, _HeaderTypes) -> None\n        \"\"\"Sets the given response header name and value.\n\n        If a datetime is given, we automatically format it according to the\n        HTTP specification. If the value is not a string, we convert it to\n        a string. All header values are then encoded as UTF-8.\n        \"\"\"\n        self._headers[name] = self._convert_header_value(value)",
        "begin_line": 333,
        "end_line": 341,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041203131437989287,
            "pseudo_dstar_susp": 0.0004526935264825713,
            "pseudo_tarantula_susp": 0.0004046944556859571,
            "pseudo_op2_susp": 0.0004526935264825713,
            "pseudo_barinel_susp": 0.0004046944556859571
        }
    },
    {
        "name": "tornado.web.RequestHandler.add_header#343",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.add_header(self, name, value)",
        "snippet": "    def add_header(self, name, value):\n        # type: (str, _HeaderTypes) -> None\n        \"\"\"Adds the given response header and value.\n\n        Unlike `set_header`, `add_header` may be called multiple times\n        to return multiple values for the same header.\n        \"\"\"\n        self._headers.add(name, self._convert_header_value(value))",
        "begin_line": 343,
        "end_line": 350,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013749484394335213,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.clear_header#352",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.clear_header(self, name)",
        "snippet": "    def clear_header(self, name):\n        \"\"\"Clears an outgoing header, undoing a previous `set_header` call.\n\n        Note that this method does not apply to multi-valued headers\n        set by `add_header`.\n        \"\"\"\n        if name in self._headers:\n            del self._headers[name]",
        "begin_line": 352,
        "end_line": 359,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013974287311347122,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler._convert_header_value#363",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._convert_header_value(self, value)",
        "snippet": "    def _convert_header_value(self, value):\n        # type: (_HeaderTypes) -> str\n\n        # Convert the input value to a str. This type check is a bit\n        # subtle: The bytes case only executes on python 3, and the\n        # unicode case only executes on python 2, because the other\n        # cases are covered by the first match for str.\n        if isinstance(value, str):\n            retval = value\n        elif isinstance(value, bytes):  # py3\n            # Non-ascii characters in headers are not well supported,\n            # but if you pass bytes, use latin1 so they pass through as-is.\n            retval = value.decode('latin1')\n        elif isinstance(value, unicode_type):  # py2\n            # TODO: This is inconsistent with the use of latin1 above,\n            # but it's been that way for a long time. Should it change?\n            retval = escape.utf8(value)\n        elif isinstance(value, numbers.Integral):\n            # return immediately since we know the converted value will be safe\n            return str(value)\n        elif isinstance(value, datetime.datetime):\n            return httputil.format_timestamp(value)\n        else:\n            raise TypeError(\"Unsupported header value %r\" % value)\n        # If \\n is allowed into the header, it is possible to inject\n        # additional headers or split the request.\n        if RequestHandler._INVALID_HEADER_CHAR_RE.search(retval):\n            raise ValueError(\"Unsafe header value %r\", retval)\n        return retval",
        "begin_line": 363,
        "end_line": 391,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000419639110365086,
            "pseudo_dstar_susp": 0.00046146746654360867,
            "pseudo_tarantula_susp": 0.00041220115416323167,
            "pseudo_op2_susp": 0.00046146746654360867,
            "pseudo_barinel_susp": 0.00041220115416323167
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_argument#395",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_argument(self, name, default=_ARG_DEFAULT, strip=True)",
        "snippet": "    def get_argument(self, name, default=_ARG_DEFAULT, strip=True):\n        \"\"\"Returns the value of the argument with the given name.\n\n        If default is not provided, the argument is considered to be\n        required, and we raise a `MissingArgumentError` if it is missing.\n\n        If the argument appears in the url more than once, we return the\n        last value.\n\n        The returned value is always unicode.\n        \"\"\"\n        return self._get_argument(name, default, self.request.arguments, strip)",
        "begin_line": 395,
        "end_line": 406,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00039872408293460925,
            "pseudo_dstar_susp": 0.00040933278755628325,
            "pseudo_tarantula_susp": 0.0004553734061930783,
            "pseudo_op2_susp": 0.00040933278755628325,
            "pseudo_barinel_susp": 0.0004553734061930783
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_arguments#408",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_arguments(self, name, strip=True)",
        "snippet": "    def get_arguments(self, name, strip=True):\n        \"\"\"Returns a list of the arguments with the given name.\n\n        If the argument is not present, returns an empty list.\n\n        The returned values are always unicode.\n        \"\"\"\n\n        # Make sure `get_arguments` isn't accidentally being called with a\n        # positional argument that's assumed to be a default (like in\n        # `get_argument`.)\n        assert isinstance(strip, bool)\n\n        return self._get_arguments(name, self.request.arguments, strip)",
        "begin_line": 408,
        "end_line": 421,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016474464579901152,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_body_argument#423",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_body_argument(self, name, default=_ARG_DEFAULT, strip=True)",
        "snippet": "    def get_body_argument(self, name, default=_ARG_DEFAULT, strip=True):\n        \"\"\"Returns the value of the argument with the given name\n        from the request body.\n\n        If default is not provided, the argument is considered to be\n        required, and we raise a `MissingArgumentError` if it is missing.\n\n        If the argument appears in the url more than once, we return the\n        last value.\n\n        The returned value is always unicode.\n\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_argument(name, default, self.request.body_arguments,\n                                  strip)",
        "begin_line": 423,
        "end_line": 438,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_body_arguments#440",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_body_arguments(self, name, strip=True)",
        "snippet": "    def get_body_arguments(self, name, strip=True):\n        \"\"\"Returns a list of the body arguments with the given name.\n\n        If the argument is not present, returns an empty list.\n\n        The returned values are always unicode.\n\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_arguments(name, self.request.body_arguments, strip)",
        "begin_line": 440,
        "end_line": 449,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_query_argument#451",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_query_argument(self, name, default=_ARG_DEFAULT, strip=True)",
        "snippet": "    def get_query_argument(self, name, default=_ARG_DEFAULT, strip=True):\n        \"\"\"Returns the value of the argument with the given name\n        from the request query string.\n\n        If default is not provided, the argument is considered to be\n        required, and we raise a `MissingArgumentError` if it is missing.\n\n        If the argument appears in the url more than once, we return the\n        last value.\n\n        The returned value is always unicode.\n\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_argument(name, default,\n                                  self.request.query_arguments, strip)",
        "begin_line": 451,
        "end_line": 466,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_query_arguments#468",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_query_arguments(self, name, strip=True)",
        "snippet": "    def get_query_arguments(self, name, strip=True):\n        \"\"\"Returns a list of the query arguments with the given name.\n\n        If the argument is not present, returns an empty list.\n\n        The returned values are always unicode.\n\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_arguments(name, self.request.query_arguments, strip)",
        "begin_line": 468,
        "end_line": 477,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler._get_argument#479",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._get_argument(self, name, default, source, strip=True)",
        "snippet": "    def _get_argument(self, name, default, source, strip=True):\n        args = self._get_arguments(name, source, strip=strip)\n        if not args:\n            if default is self._ARG_DEFAULT:\n                raise MissingArgumentError(name)\n            return default\n        return args[-1]",
        "begin_line": 479,
        "end_line": 485,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004253509145044662,
            "pseudo_dstar_susp": 0.0004108463434675431,
            "pseudo_tarantula_susp": 0.0005219206680584551,
            "pseudo_op2_susp": 0.0004108463434675431,
            "pseudo_barinel_susp": 0.0005219206680584551
        }
    },
    {
        "name": "tornado.web.RequestHandler._get_arguments#487",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._get_arguments(self, name, source, strip=True)",
        "snippet": "    def _get_arguments(self, name, source, strip=True):\n        values = []\n        for v in source.get(name, []):\n            v = self.decode_argument(v, name=name)\n            if isinstance(v, unicode_type):\n                # Get rid of any weird control chars (unless decoding gave\n                # us bytes, in which case leave it alone)\n                v = RequestHandler._remove_control_chars_regex.sub(\" \", v)\n            if strip:\n                v = v.strip()\n            values.append(v)\n        return values",
        "begin_line": 487,
        "end_line": 498,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00042319085907744394,
            "pseudo_dstar_susp": 0.0004103405826836274,
            "pseudo_tarantula_susp": 0.0004950495049504951,
            "pseudo_op2_susp": 0.0004103405826836274,
            "pseudo_barinel_susp": 0.0004950495049504951
        }
    },
    {
        "name": "tornado.web.RequestHandler.decode_argument#500",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.decode_argument(self, value, name=None)",
        "snippet": "    def decode_argument(self, value, name=None):\n        \"\"\"Decodes an argument from the request.\n\n        The argument has been percent-decoded and is now a byte string.\n        By default, this method decodes the argument as utf-8 and returns\n        a unicode string, but this may be overridden in subclasses.\n\n        This method is used as a filter for both `get_argument()` and for\n        values extracted from the url and passed to `get()`/`post()`/etc.\n\n        The name of the argument is provided if known, but may be None\n        (e.g. for unnamed groups in the url regex).\n        \"\"\"\n        try:\n            return _unicode(value)\n        except UnicodeDecodeError:\n            raise HTTPError(400, \"Invalid unicode in %s: %r\" %\n                            (name or \"url\", value[:40]))",
        "begin_line": 500,
        "end_line": 517,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003924646781789639,
            "pseudo_dstar_susp": 0.0004079967360261118,
            "pseudo_tarantula_susp": 0.00041322314049586776,
            "pseudo_op2_susp": 0.0004079967360261118,
            "pseudo_barinel_susp": 0.00041322314049586776
        }
    },
    {
        "name": "tornado.web.RequestHandler.cookies#520",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.cookies(self)",
        "snippet": "    def cookies(self):\n        \"\"\"An alias for\n        `self.request.cookies <.httputil.HTTPServerRequest.cookies>`.\"\"\"\n        return self.request.cookies",
        "begin_line": 520,
        "end_line": 523,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_cookie#525",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_cookie(self, name, default=None)",
        "snippet": "    def get_cookie(self, name, default=None):\n        \"\"\"Returns the value of the request cookie with the given name.\n\n        If the named cookie is not present, returns ``default``.\n\n        This method only returns cookies that were present in the request.\n        It does not see the outgoing cookies set by `set_cookie` in this\n        handler.\n        \"\"\"\n        if self.request.cookies is not None and name in self.request.cookies:\n            return self.request.cookies[name].value\n        return default",
        "begin_line": 525,
        "end_line": 536,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014727540500736376,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.set_cookie#538",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.set_cookie(self, name, value, domain=None, expires=None, path='/', expires_days=None, **kwargs)",
        "snippet": "    def set_cookie(self, name, value, domain=None, expires=None, path=\"/\",\n                   expires_days=None, **kwargs):\n        \"\"\"Sets an outgoing cookie name/value with the given options.\n\n        Newly-set cookies are not immediately visible via `get_cookie`;\n        they are not present until the next request.\n\n        Additional keyword arguments are set on the cookies.Morsel\n        directly.\n        See https://docs.python.org/3/library/http.cookies.html#http.cookies.Morsel\n        for available attributes.\n        \"\"\"\n        # The cookie library only accepts type str, in both python 2 and 3\n        name = escape.native_str(name)\n        value = escape.native_str(value)\n        if re.search(r\"[\\x00-\\x20]\", name + value):\n            # Don't let us accidentally inject bad stuff\n            raise ValueError(\"Invalid cookie %r: %r\" % (name, value))\n        if not hasattr(self, \"_new_cookie\"):\n            self._new_cookie = Cookie.SimpleCookie()\n        if name in self._new_cookie:\n            del self._new_cookie[name]\n        self._new_cookie[name] = value\n        morsel = self._new_cookie[name]\n        if domain:\n            morsel[\"domain\"] = domain\n        if expires_days is not None and not expires:\n            expires = datetime.datetime.utcnow() + datetime.timedelta(\n                days=expires_days)\n        if expires:\n            morsel[\"expires\"] = httputil.format_timestamp(expires)\n        if path:\n            morsel[\"path\"] = path\n        for k, v in kwargs.items():\n            if k == 'max_age':\n                k = 'max-age'\n\n            # skip falsy values for httponly and secure flags because\n            # SimpleCookie sets them regardless\n            if k in ['httponly', 'secure'] and not v:\n                continue\n\n            morsel[k] = v",
        "begin_line": 538,
        "end_line": 580,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.clear_cookie#582",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.clear_cookie(self, name, path='/', domain=None)",
        "snippet": "    def clear_cookie(self, name, path=\"/\", domain=None):\n        \"\"\"Deletes the cookie with the given name.\n\n        Due to limitations of the cookie protocol, you must pass the same\n        path and domain to clear a cookie as were used when that cookie\n        was set (but there is no way to find out on the server side\n        which values were used for a given cookie).\n\n        Similar to `set_cookie`, the effect of this method will not be\n        seen until the following request.\n        \"\"\"\n        expires = datetime.datetime.utcnow() - datetime.timedelta(days=365)\n        self.set_cookie(name, value=\"\", path=path, expires=expires,\n                        domain=domain)",
        "begin_line": 582,
        "end_line": 595,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001836884643644379,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.clear_all_cookies#597",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.clear_all_cookies(self, path='/', domain=None)",
        "snippet": "    def clear_all_cookies(self, path=\"/\", domain=None):\n        \"\"\"Deletes all the cookies the user sent with this request.\n\n        See `clear_cookie` for more information on the path and domain\n        parameters.\n\n        Similar to `set_cookie`, the effect of this method will not be\n        seen until the following request.\n\n        .. versionchanged:: 3.2\n\n           Added the ``path`` and ``domain`` parameters.\n        \"\"\"\n        for name in self.request.cookies:\n            self.clear_cookie(name, path=path, domain=domain)",
        "begin_line": 597,
        "end_line": 611,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.set_secure_cookie#613",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.set_secure_cookie(self, name, value, expires_days=30, version=None, **kwargs)",
        "snippet": "    def set_secure_cookie(self, name, value, expires_days=30, version=None,\n                          **kwargs):\n        \"\"\"Signs and timestamps a cookie so it cannot be forged.\n\n        You must specify the ``cookie_secret`` setting in your Application\n        to use this method. It should be a long, random sequence of bytes\n        to be used as the HMAC secret for the signature.\n\n        To read a cookie set with this method, use `get_secure_cookie()`.\n\n        Note that the ``expires_days`` parameter sets the lifetime of the\n        cookie in the browser, but is independent of the ``max_age_days``\n        parameter to `get_secure_cookie`.\n\n        Secure cookies may contain arbitrary byte values, not just unicode\n        strings (unlike regular cookies)\n\n        Similar to `set_cookie`, the effect of this method will not be\n        seen until the following request.\n\n        .. versionchanged:: 3.2.1\n\n           Added the ``version`` argument.  Introduced cookie version 2\n           and made it the default.\n        \"\"\"\n        self.set_cookie(name, self.create_signed_value(name, value,\n                                                       version=version),\n                        expires_days=expires_days, **kwargs)",
        "begin_line": 613,
        "end_line": 640,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001885369532428356,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.create_signed_value#642",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.create_signed_value(self, name, value, version=None)",
        "snippet": "    def create_signed_value(self, name, value, version=None):\n        \"\"\"Signs and timestamps a string so it cannot be forged.\n\n        Normally used via set_secure_cookie, but provided as a separate\n        method for non-cookie uses.  To decode a value not stored\n        as a cookie use the optional value argument to get_secure_cookie.\n\n        .. versionchanged:: 3.2.1\n\n           Added the ``version`` argument.  Introduced cookie version 2\n           and made it the default.\n        \"\"\"\n        self.require_setting(\"cookie_secret\", \"secure cookies\")\n        secret = self.application.settings[\"cookie_secret\"]\n        key_version = None\n        if isinstance(secret, dict):\n            if self.application.settings.get(\"key_version\") is None:\n                raise Exception(\"key_version setting must be used for secret_key dicts\")\n            key_version = self.application.settings[\"key_version\"]\n\n        return create_signed_value(secret, name, value, version=version,\n                                   key_version=key_version)",
        "begin_line": 642,
        "end_line": 663,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_secure_cookie#665",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_secure_cookie(self, name, value=None, max_age_days=31, min_version=None)",
        "snippet": "    def get_secure_cookie(self, name, value=None, max_age_days=31,\n                          min_version=None):\n        \"\"\"Returns the given signed cookie if it validates, or None.\n\n        The decoded cookie value is returned as a byte string (unlike\n        `get_cookie`).\n\n        Similar to `get_cookie`, this method only returns cookies that\n        were present in the request. It does not see outgoing cookies set by\n        `set_secure_cookie` in this handler.\n\n        .. versionchanged:: 3.2.1\n\n           Added the ``min_version`` argument.  Introduced cookie version 2;\n           both versions 1 and 2 are accepted by default.\n        \"\"\"\n        self.require_setting(\"cookie_secret\", \"secure cookies\")\n        if value is None:\n            value = self.get_cookie(name)\n        return decode_signed_value(self.application.settings[\"cookie_secret\"],\n                                   name, value, max_age_days=max_age_days,\n                                   min_version=min_version)",
        "begin_line": 665,
        "end_line": 686,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001775568181818182,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.redirect#698",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.redirect(self, url, permanent=False, status=None)",
        "snippet": "    def redirect(self, url, permanent=False, status=None):\n        \"\"\"Sends a redirect to the given (optionally relative) URL.\n\n        If the ``status`` argument is specified, that value is used as the\n        HTTP status code; otherwise either 301 (permanent) or 302\n        (temporary) is chosen based on the ``permanent`` argument.\n        The default is 302 (temporary).\n        \"\"\"\n        if self._headers_written:\n            raise Exception(\"Cannot redirect after headers have been written\")\n        if status is None:\n            status = 301 if permanent else 302\n        else:\n            assert isinstance(status, int) and 300 <= status <= 399\n        self.set_status(status)\n        self.set_header(\"Location\", utf8(url))\n        self.finish()",
        "begin_line": 698,
        "end_line": 714,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.write#716",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.write(self, chunk)",
        "snippet": "    def write(self, chunk):\n        \"\"\"Writes the given chunk to the output buffer.\n\n        To write the output to the network, use the flush() method below.\n\n        If the given chunk is a dictionary, we write it as JSON and set\n        the Content-Type of the response to be ``application/json``.\n        (if you want to send JSON as a different ``Content-Type``, call\n        set_header *after* calling write()).\n\n        Note that lists are not converted to JSON because of a potential\n        cross-site security vulnerability.  All JSON output should be\n        wrapped in a dictionary.  More details at\n        http://haacked.com/archive/2009/06/25/json-hijacking.aspx/ and\n        https://github.com/facebook/tornado/issues/1009\n        \"\"\"\n        if self._finished:\n            raise RuntimeError(\"Cannot write() after finish()\")\n        if not isinstance(chunk, (bytes, unicode_type, dict)):\n            message = \"write() only accepts bytes, unicode, and dict objects\"\n            if isinstance(chunk, list):\n                message += \". Lists not accepted for security reasons; see \" + \\\n                    \"http://www.tornadoweb.org/en/stable/web.html#tornado.web.RequestHandler.write\"\n            raise TypeError(message)\n        if isinstance(chunk, dict):\n            chunk = escape.json_encode(chunk)\n            self.set_header(\"Content-Type\", \"application/json; charset=UTF-8\")\n        chunk = utf8(chunk)\n        self._write_buffer.append(chunk)",
        "begin_line": 716,
        "end_line": 744,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00042211903756859433,
            "pseudo_dstar_susp": 0.0004631773969430292,
            "pseudo_tarantula_susp": 0.00041476565740356696,
            "pseudo_op2_susp": 0.0004631773969430292,
            "pseudo_barinel_susp": 0.00041476565740356696
        }
    },
    {
        "name": "tornado.web.RequestHandler.render#746",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.render(self, template_name, **kwargs)",
        "snippet": "    def render(self, template_name, **kwargs):\n        \"\"\"Renders the template with the given arguments as the response.\"\"\"\n        if self._finished:\n            raise RuntimeError(\"Cannot render() after finish()\")\n        html = self.render_string(template_name, **kwargs)\n\n        # Insert the additional JS and CSS added by the modules on the page\n        js_embed = []\n        js_files = []\n        css_embed = []\n        css_files = []\n        html_heads = []\n        html_bodies = []\n        for module in getattr(self, \"_active_modules\", {}).values():\n            embed_part = module.embedded_javascript()\n            if embed_part:\n                js_embed.append(utf8(embed_part))\n            file_part = module.javascript_files()\n            if file_part:\n                if isinstance(file_part, (unicode_type, bytes)):\n                    js_files.append(file_part)\n                else:\n                    js_files.extend(file_part)\n            embed_part = module.embedded_css()\n            if embed_part:\n                css_embed.append(utf8(embed_part))\n            file_part = module.css_files()\n            if file_part:\n                if isinstance(file_part, (unicode_type, bytes)):\n                    css_files.append(file_part)\n                else:\n                    css_files.extend(file_part)\n            head_part = module.html_head()\n            if head_part:\n                html_heads.append(utf8(head_part))\n            body_part = module.html_body()\n            if body_part:\n                html_bodies.append(utf8(body_part))\n\n        if js_files:\n            # Maintain order of JavaScript files given by modules\n            js = self.render_linked_js(js_files)\n            sloc = html.rindex(b'</body>')\n            html = html[:sloc] + utf8(js) + b'\\n' + html[sloc:]\n        if js_embed:\n            js = self.render_embed_js(js_embed)\n            sloc = html.rindex(b'</body>')\n            html = html[:sloc] + js + b'\\n' + html[sloc:]\n        if css_files:\n            css = self.render_linked_css(css_files)\n            hloc = html.index(b'</head>')\n            html = html[:hloc] + utf8(css) + b'\\n' + html[hloc:]\n        if css_embed:\n            css = self.render_embed_css(css_embed)\n            hloc = html.index(b'</head>')\n            html = html[:hloc] + css + b'\\n' + html[hloc:]\n        if html_heads:\n            hloc = html.index(b'</head>')\n            html = html[:hloc] + b''.join(html_heads) + b'\\n' + html[hloc:]\n        if html_bodies:\n            hloc = html.index(b'</body>')\n            html = html[:hloc] + b''.join(html_bodies) + b'\\n' + html[hloc:]\n        self.finish(html)",
        "begin_line": 746,
        "end_line": 808,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.render_linked_js#810",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.render_linked_js(self, js_files)",
        "snippet": "    def render_linked_js(self, js_files):\n        \"\"\"Default method used to render the final js links for the\n        rendered webpage.\n\n        Override this method in a sub-classed controller to change the output.\n        \"\"\"\n        paths = []\n        unique_paths = set()\n\n        for path in js_files:\n            if not is_absolute(path):\n                path = self.static_url(path)\n            if path not in unique_paths:\n                paths.append(path)\n                unique_paths.add(path)\n\n        return ''.join('<script src=\"' + escape.xhtml_escape(p) +\n                       '\" type=\"text/javascript\"></script>'\n                       for p in paths)",
        "begin_line": 810,
        "end_line": 828,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.render_embed_js#830",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.render_embed_js(self, js_embed)",
        "snippet": "    def render_embed_js(self, js_embed):\n        \"\"\"Default method used to render the final embedded js for the\n        rendered webpage.\n\n        Override this method in a sub-classed controller to change the output.\n        \"\"\"\n        return b'<script type=\"text/javascript\">\\n//<![CDATA[\\n' + \\\n               b'\\n'.join(js_embed) + b'\\n//]]>\\n</script>'",
        "begin_line": 830,
        "end_line": 837,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.render_linked_css#839",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.render_linked_css(self, css_files)",
        "snippet": "    def render_linked_css(self, css_files):\n        \"\"\"Default method used to render the final css links for the\n        rendered webpage.\n\n        Override this method in a sub-classed controller to change the output.\n        \"\"\"\n        paths = []\n        unique_paths = set()\n\n        for path in css_files:\n            if not is_absolute(path):\n                path = self.static_url(path)\n            if path not in unique_paths:\n                paths.append(path)\n                unique_paths.add(path)\n\n        return ''.join('<link href=\"' + escape.xhtml_escape(p) + '\" '\n                       'type=\"text/css\" rel=\"stylesheet\"/>'\n                       for p in paths)",
        "begin_line": 839,
        "end_line": 857,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.render_embed_css#859",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.render_embed_css(self, css_embed)",
        "snippet": "    def render_embed_css(self, css_embed):\n        \"\"\"Default method used to render the final embedded css for the\n        rendered webpage.\n\n        Override this method in a sub-classed controller to change the output.\n        \"\"\"\n        return b'<style type=\"text/css\">\\n' + b'\\n'.join(css_embed) + \\\n               b'\\n</style>'",
        "begin_line": 859,
        "end_line": 866,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.render_string#868",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.render_string(self, template_name, **kwargs)",
        "snippet": "    def render_string(self, template_name, **kwargs):\n        \"\"\"Generate the given template with the given arguments.\n\n        We return the generated byte string (in utf8). To generate and\n        write a template as a response, use render() above.\n        \"\"\"\n        # If no template_path is specified, use the path of the calling file\n        template_path = self.get_template_path()\n        if not template_path:\n            frame = sys._getframe(0)\n            web_file = frame.f_code.co_filename\n            while frame.f_code.co_filename == web_file:\n                frame = frame.f_back\n            template_path = os.path.dirname(frame.f_code.co_filename)\n        with RequestHandler._template_loader_lock:\n            if template_path not in RequestHandler._template_loaders:\n                loader = self.create_template_loader(template_path)\n                RequestHandler._template_loaders[template_path] = loader\n            else:\n                loader = RequestHandler._template_loaders[template_path]\n        t = loader.load(template_name)\n        namespace = self.get_template_namespace()\n        namespace.update(kwargs)\n        return t.generate(**namespace)",
        "begin_line": 868,
        "end_line": 891,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_template_namespace#893",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_template_namespace(self)",
        "snippet": "    def get_template_namespace(self):\n        \"\"\"Returns a dictionary to be used as the default template namespace.\n\n        May be overridden by subclasses to add or modify values.\n\n        The results of this method will be combined with additional\n        defaults in the `tornado.template` module and keyword arguments\n        to `render` or `render_string`.\n        \"\"\"\n        namespace = dict(\n            handler=self,\n            request=self.request,\n            current_user=self.current_user,\n            locale=self.locale,\n            _=self.locale.translate,\n            pgettext=self.locale.pgettext,\n            static_url=self.static_url,\n            xsrf_form_html=self.xsrf_form_html,\n            reverse_url=self.reverse_url\n        )\n        namespace.update(self.ui)\n        return namespace",
        "begin_line": 893,
        "end_line": 914,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017409470752089137,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.create_template_loader#916",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.create_template_loader(self, template_path)",
        "snippet": "    def create_template_loader(self, template_path):\n        \"\"\"Returns a new template loader for the given path.\n\n        May be overridden by subclasses.  By default returns a\n        directory-based loader on the given path, using the\n        ``autoescape`` and ``template_whitespace`` application\n        settings.  If a ``template_loader`` application setting is\n        supplied, uses that instead.\n        \"\"\"\n        settings = self.application.settings\n        if \"template_loader\" in settings:\n            return settings[\"template_loader\"]\n        kwargs = {}\n        if \"autoescape\" in settings:\n            # autoescape=None means \"no escaping\", so we have to be sure\n            # to only pass this kwarg if the user asked for it.\n            kwargs[\"autoescape\"] = settings[\"autoescape\"]\n        if \"template_whitespace\" in settings:\n            kwargs[\"whitespace\"] = settings[\"template_whitespace\"]\n        return template.Loader(template_path, **kwargs)",
        "begin_line": 916,
        "end_line": 935,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016622340425531914,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.flush#937",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.flush(self, include_footers=False, callback=None)",
        "snippet": "    def flush(self, include_footers=False, callback=None):\n        \"\"\"Flushes the current output buffer to the network.\n\n        The ``callback`` argument, if given, can be used for flow control:\n        it will be run when all flushed data has been written to the socket.\n        Note that only one flush callback can be outstanding at a time;\n        if another flush occurs before the previous flush's callback\n        has been run, the previous callback will be discarded.\n\n        .. versionchanged:: 4.0\n           Now returns a `.Future` if no callback is given.\n        \"\"\"\n        chunk = b\"\".join(self._write_buffer)\n        self._write_buffer = []\n        if not self._headers_written:\n            self._headers_written = True\n            for transform in self._transforms:\n                self._status_code, self._headers, chunk = \\\n                    transform.transform_first_chunk(\n                        self._status_code, self._headers,\n                        chunk, include_footers)\n            # Ignore the chunk and only write the headers for HEAD requests\n            if self.request.method == \"HEAD\":\n                chunk = None\n\n            # Finalize the cookie headers (which have been stored in a side\n            # object so an outgoing cookie could be overwritten before it\n            # is sent).\n            if hasattr(self, \"_new_cookie\"):\n                for cookie in self._new_cookie.values():\n                    self.add_header(\"Set-Cookie\", cookie.OutputString(None))\n\n            start_line = httputil.ResponseStartLine('',\n                                                    self._status_code,\n                                                    self._reason)\n            return self.request.connection.write_headers(\n                start_line, self._headers, chunk, callback=callback)\n        else:\n            for transform in self._transforms:\n                chunk = transform.transform_chunk(chunk, include_footers)\n            # Ignore the chunk and only write the headers for HEAD requests\n            if self.request.method != \"HEAD\":\n                return self.request.connection.write(chunk, callback=callback)\n            else:\n                future = Future()\n                future.set_result(None)\n                return future",
        "begin_line": 937,
        "end_line": 983,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004038772213247173,
            "pseudo_dstar_susp": 0.0004440497335701599,
            "pseudo_tarantula_susp": 0.0003977724741447892,
            "pseudo_op2_susp": 0.0004440497335701599,
            "pseudo_barinel_susp": 0.0003977724741447892
        }
    },
    {
        "name": "tornado.web.RequestHandler.finish#985",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.finish(self, chunk=None)",
        "snippet": "    def finish(self, chunk=None):\n        \"\"\"Finishes this response, ending the HTTP request.\"\"\"\n        if self._finished:\n            raise RuntimeError(\"finish() called twice\")\n\n        if chunk is not None:\n            self.write(chunk)\n\n        # Automatically support ETags and add the Content-Length header if\n        # we have not flushed any content yet.\n        if not self._headers_written:\n            if (self._status_code == 200 and\n                self.request.method in (\"GET\", \"HEAD\") and\n                    \"Etag\" not in self._headers):\n                self.set_etag_header()\n                if self.check_etag_header():\n                    self._write_buffer = []\n                    self.set_status(304)\n            if (self._status_code in (204, 304) or\n                    (self._status_code >= 100 and self._status_code < 200)):\n                assert not self._write_buffer, \"Cannot send body with %s\" % self._status_code\n                self._clear_headers_for_304()\n            elif \"Content-Length\" not in self._headers:\n                content_length = sum(len(part) for part in self._write_buffer)\n                self.set_header(\"Content-Length\", content_length)\n\n        if hasattr(self.request, \"connection\"):\n            # Now that the request is finished, clear the callback we\n            # set on the HTTPConnection (which would otherwise prevent the\n            # garbage collection of the RequestHandler when there\n            # are keepalive connections)\n            self.request.connection.set_close_callback(None)\n\n        self.flush(include_footers=True)\n        self.request.finish()\n        self._log()\n        self._finished = True\n        self.on_finish()\n        self._break_cycles()",
        "begin_line": 985,
        "end_line": 1023,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004363001745200698,
            "pseudo_dstar_susp": 0.00055005500550055,
            "pseudo_tarantula_susp": 0.00042176296921130323,
            "pseudo_op2_susp": 0.00055005500550055,
            "pseudo_barinel_susp": 0.00042176296921130323
        }
    },
    {
        "name": "tornado.web.RequestHandler._break_cycles#1025",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._break_cycles(self)",
        "snippet": "    def _break_cycles(self):\n        # Break up a reference cycle between this handler and the\n        # _ui_module closures to allow for faster GC on CPython.\n        self.ui = None",
        "begin_line": 1025,
        "end_line": 1028,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041017227235438887,
            "pseudo_dstar_susp": 0.00045167118337850043,
            "pseudo_tarantula_susp": 0.0004038772213247173,
            "pseudo_op2_susp": 0.00045167118337850043,
            "pseudo_barinel_susp": 0.0004038772213247173
        }
    },
    {
        "name": "tornado.web.RequestHandler.send_error#1030",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.send_error(self, status_code=500, **kwargs)",
        "snippet": "    def send_error(self, status_code=500, **kwargs):\n        \"\"\"Sends the given HTTP error code to the browser.\n\n        If `flush()` has already been called, it is not possible to send\n        an error, so this method will simply terminate the response.\n        If output has been written but not yet flushed, it will be discarded\n        and replaced with the error page.\n\n        Override `write_error()` to customize the error page that is returned.\n        Additional keyword arguments are passed through to `write_error`.\n        \"\"\"\n        if self._headers_written:\n            gen_log.error(\"Cannot send error response after headers written\")\n            if not self._finished:\n                # If we get an error between writing headers and finishing,\n                # we are unlikely to be able to finish due to a\n                # Content-Length mismatch. Try anyway to release the\n                # socket.\n                try:\n                    self.finish()\n                except Exception:\n                    gen_log.error(\"Failed to flush partial response\",\n                                  exc_info=True)\n            return\n        self.clear()\n\n        reason = kwargs.get('reason')\n        if 'exc_info' in kwargs:\n            exception = kwargs['exc_info'][1]\n            if isinstance(exception, HTTPError) and exception.reason:\n                reason = exception.reason\n        self.set_status(status_code, reason=reason)\n        try:\n            self.write_error(status_code, **kwargs)\n        except Exception:\n            app_log.error(\"Uncaught exception in write_error\", exc_info=True)\n        if not self._finished:\n            self.finish()",
        "begin_line": 1030,
        "end_line": 1067,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.write_error#1069",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.write_error(self, status_code, **kwargs)",
        "snippet": "    def write_error(self, status_code, **kwargs):\n        \"\"\"Override to implement custom error pages.\n\n        ``write_error`` may call `write`, `render`, `set_header`, etc\n        to produce output as usual.\n\n        If this error was caused by an uncaught exception (including\n        HTTPError), an ``exc_info`` triple will be available as\n        ``kwargs[\"exc_info\"]``.  Note that this exception may not be\n        the \"current\" exception for purposes of methods like\n        ``sys.exc_info()`` or ``traceback.format_exc``.\n        \"\"\"\n        if self.settings.get(\"serve_traceback\") and \"exc_info\" in kwargs:\n            # in debug mode, try to send a traceback\n            self.set_header('Content-Type', 'text/plain')\n            for line in traceback.format_exception(*kwargs[\"exc_info\"]):\n                self.write(line)\n            self.finish()\n        else:\n            self.finish(\"<html><title>%(code)d: %(message)s</title>\"\n                        \"<body>%(code)d: %(message)s</body></html>\" % {\n                            \"code\": status_code,\n                            \"message\": self._reason,\n                        })",
        "begin_line": 1069,
        "end_line": 1092,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013674278681799536,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.locale#1095",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.locale(self)",
        "snippet": "    def locale(self):\n        \"\"\"The locale for the current session.\n\n        Determined by either `get_user_locale`, which you can override to\n        set the locale based on, e.g., a user preference stored in a\n        database, or `get_browser_locale`, which uses the ``Accept-Language``\n        header.\n\n        .. versionchanged: 4.1\n           Added a property setter.\n        \"\"\"\n        if not hasattr(self, \"_locale\"):\n            self._locale = self.get_user_locale()\n            if not self._locale:\n                self._locale = self.get_browser_locale()\n                assert self._locale\n        return self._locale",
        "begin_line": 1095,
        "end_line": 1111,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016622340425531914,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.locale#1114",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.locale(self, value)",
        "snippet": "    def locale(self, value):\n        self._locale = value",
        "begin_line": 1114,
        "end_line": 1115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_user_locale#1117",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_user_locale(self)",
        "snippet": "    def get_user_locale(self):\n        \"\"\"Override to determine the locale from the authenticated user.\n\n        If None is returned, we fall back to `get_browser_locale()`.\n\n        This method should return a `tornado.locale.Locale` object,\n        most likely obtained via a call like ``tornado.locale.get(\"en\")``\n        \"\"\"\n        return None",
        "begin_line": 1117,
        "end_line": 1125,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016622340425531914,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_browser_locale#1127",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_browser_locale(self, default='en_US')",
        "snippet": "    def get_browser_locale(self, default=\"en_US\"):\n        \"\"\"Determines the user's locale from ``Accept-Language`` header.\n\n        See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4\n        \"\"\"\n        if \"Accept-Language\" in self.request.headers:\n            languages = self.request.headers[\"Accept-Language\"].split(\",\")\n            locales = []\n            for language in languages:\n                parts = language.strip().split(\";\")\n                if len(parts) > 1 and parts[1].startswith(\"q=\"):\n                    try:\n                        score = float(parts[1][2:])\n                    except (ValueError, TypeError):\n                        score = 0.0\n                else:\n                    score = 1.0\n                locales.append((parts[0], score))\n            if locales:\n                locales.sort(key=lambda pair: pair[1], reverse=True)\n                codes = [l[0] for l in locales]\n                return locale.get(*codes)\n        return locale.get(default)",
        "begin_line": 1127,
        "end_line": 1149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016622340425531914,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.current_user#1152",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.current_user(self)",
        "snippet": "    def current_user(self):\n        \"\"\"The authenticated user for this request.\n\n        This is set in one of two ways:\n\n        * A subclass may override `get_current_user()`, which will be called\n          automatically the first time ``self.current_user`` is accessed.\n          `get_current_user()` will only be called once per request,\n          and is cached for future access::\n\n              def get_current_user(self):\n                  user_cookie = self.get_secure_cookie(\"user\")\n                  if user_cookie:\n                      return json.loads(user_cookie)\n                  return None\n\n        * It may be set as a normal variable, typically from an overridden\n          `prepare()`::\n\n              @gen.coroutine\n              def prepare(self):\n                  user_id_cookie = self.get_secure_cookie(\"user_id\")\n                  if user_id_cookie:\n                      self.current_user = yield load_user(user_id_cookie)\n\n        Note that `prepare()` may be a coroutine while `get_current_user()`\n        may not, so the latter form is necessary if loading the user requires\n        asynchronous operations.\n\n        The user object may be any type of the application's choosing.\n        \"\"\"\n        if not hasattr(self, \"_current_user\"):\n            self._current_user = self.get_current_user()\n        return self._current_user",
        "begin_line": 1152,
        "end_line": 1185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013960631020522128,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.current_user#1188",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.current_user(self, value)",
        "snippet": "    def current_user(self, value):\n        self._current_user = value",
        "begin_line": 1188,
        "end_line": 1189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_current_user#1191",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_current_user(self)",
        "snippet": "    def get_current_user(self):\n        \"\"\"Override to determine the current user from, e.g., a cookie.\n\n        This method may not be a coroutine.\n        \"\"\"\n        return None",
        "begin_line": 1191,
        "end_line": 1196,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014072614691809738,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.get_template_path#1206",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.get_template_path(self)",
        "snippet": "    def get_template_path(self):\n        \"\"\"Override to customize template path for each handler.\n\n        By default, we use the ``template_path`` application setting.\n        Return None to load templates relative to the calling file.\n        \"\"\"\n        return self.application.settings.get(\"template_path\")",
        "begin_line": 1206,
        "end_line": 1212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016622340425531914,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.xsrf_token#1215",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.xsrf_token(self)",
        "snippet": "    def xsrf_token(self):\n        \"\"\"The XSRF-prevention token for the current user/session.\n\n        To prevent cross-site request forgery, we set an '_xsrf' cookie\n        and include the same '_xsrf' value as an argument with all POST\n        requests. If the two do not match, we reject the form submission\n        as a potential forgery.\n\n        See http://en.wikipedia.org/wiki/Cross-site_request_forgery\n\n        This property is of type `bytes`, but it contains only ASCII\n        characters. If a character string is required, there is no\n        need to base64-encode it; just decode the byte string as\n        UTF-8.\n\n        .. versionchanged:: 3.2.2\n           The xsrf token will now be have a random mask applied in every\n           request, which makes it safe to include the token in pages\n           that are compressed.  See http://breachattack.com for more\n           information on the issue fixed by this change.  Old (version 1)\n           cookies will be converted to version 2 when this method is called\n           unless the ``xsrf_cookie_version`` `Application` setting is\n           set to 1.\n\n        .. versionchanged:: 4.3\n           The ``xsrf_cookie_kwargs`` `Application` setting may be\n           used to supply additional cookie options (which will be\n           passed directly to `set_cookie`). For example,\n           ``xsrf_cookie_kwargs=dict(httponly=True, secure=True)``\n           will set the ``secure`` and ``httponly`` flags on the\n           ``_xsrf`` cookie.\n        \"\"\"\n        if not hasattr(self, \"_xsrf_token\"):\n            version, token, timestamp = self._get_raw_xsrf_token()\n            output_version = self.settings.get(\"xsrf_cookie_version\", 2)\n            cookie_kwargs = self.settings.get(\"xsrf_cookie_kwargs\", {})\n            if output_version == 1:\n                self._xsrf_token = binascii.b2a_hex(token)\n            elif output_version == 2:\n                mask = os.urandom(4)\n                self._xsrf_token = b\"|\".join([\n                    b\"2\",\n                    binascii.b2a_hex(mask),\n                    binascii.b2a_hex(_websocket_mask(mask, token)),\n                    utf8(str(int(timestamp)))])\n            else:\n                raise ValueError(\"unknown xsrf cookie version %d\",\n                                 output_version)\n            if version is None:\n                expires_days = 30 if self.current_user else None\n                self.set_cookie(\"_xsrf\", self._xsrf_token,\n                                expires_days=expires_days,\n                                **cookie_kwargs)\n        return self._xsrf_token",
        "begin_line": 1215,
        "end_line": 1268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler._get_raw_xsrf_token#1270",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._get_raw_xsrf_token(self)",
        "snippet": "    def _get_raw_xsrf_token(self):\n        \"\"\"Read or generate the xsrf token in its raw form.\n\n        The raw_xsrf_token is a tuple containing:\n\n        * version: the version of the cookie from which this token was read,\n          or None if we generated a new token in this request.\n        * token: the raw token data; random (non-ascii) bytes.\n        * timestamp: the time this token was generated (will not be accurate\n          for version 1 cookies)\n        \"\"\"\n        if not hasattr(self, '_raw_xsrf_token'):\n            cookie = self.get_cookie(\"_xsrf\")\n            if cookie:\n                version, token, timestamp = self._decode_xsrf_token(cookie)\n            else:\n                version, token, timestamp = None, None, None\n            if token is None:\n                version = None\n                token = os.urandom(16)\n                timestamp = time.time()\n            self._raw_xsrf_token = (version, token, timestamp)\n        return self._raw_xsrf_token",
        "begin_line": 1270,
        "end_line": 1292,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015158405335758679,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler._decode_xsrf_token#1294",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._decode_xsrf_token(self, cookie)",
        "snippet": "    def _decode_xsrf_token(self, cookie):\n        \"\"\"Convert a cookie string into a the tuple form returned by\n        _get_raw_xsrf_token.\n        \"\"\"\n\n        try:\n            m = _signed_value_version_re.match(utf8(cookie))\n\n            if m:\n                version = int(m.group(1))\n                if version == 2:\n                    _, mask, masked_token, timestamp = cookie.split(\"|\")\n\n                    mask = binascii.a2b_hex(utf8(mask))\n                    token = _websocket_mask(\n                        mask, binascii.a2b_hex(utf8(masked_token)))\n                    timestamp = int(timestamp)\n                    return version, token, timestamp\n                else:\n                    # Treat unknown versions as not present instead of failing.\n                    raise Exception(\"Unknown xsrf cookie version\")\n            else:\n                version = 1\n                try:\n                    token = binascii.a2b_hex(utf8(cookie))\n                except (binascii.Error, TypeError):\n                    token = utf8(cookie)\n                # We don't have a usable timestamp in older versions.\n                timestamp = int(time.time())\n                return (version, token, timestamp)\n        except Exception:\n            # Catch exceptions and return nothing instead of failing.\n            gen_log.debug(\"Uncaught exception in _decode_xsrf_token\",\n                          exc_info=True)\n            return None, None, None",
        "begin_line": 1294,
        "end_line": 1328,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.check_xsrf_cookie#1330",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.check_xsrf_cookie(self)",
        "snippet": "    def check_xsrf_cookie(self):\n        \"\"\"Verifies that the ``_xsrf`` cookie matches the ``_xsrf`` argument.\n\n        To prevent cross-site request forgery, we set an ``_xsrf``\n        cookie and include the same value as a non-cookie\n        field with all ``POST`` requests. If the two do not match, we\n        reject the form submission as a potential forgery.\n\n        The ``_xsrf`` value may be set as either a form field named ``_xsrf``\n        or in a custom HTTP header named ``X-XSRFToken`` or ``X-CSRFToken``\n        (the latter is accepted for compatibility with Django).\n\n        See http://en.wikipedia.org/wiki/Cross-site_request_forgery\n\n        Prior to release 1.1.1, this check was ignored if the HTTP header\n        ``X-Requested-With: XMLHTTPRequest`` was present.  This exception\n        has been shown to be insecure and has been removed.  For more\n        information please see\n        http://www.djangoproject.com/weblog/2011/feb/08/security/\n        http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails\n\n        .. versionchanged:: 3.2.2\n           Added support for cookie version 2.  Both versions 1 and 2 are\n           supported.\n        \"\"\"\n        token = (self.get_argument(\"_xsrf\", None) or\n                 self.request.headers.get(\"X-Xsrftoken\") or\n                 self.request.headers.get(\"X-Csrftoken\"))\n        if not token:\n            raise HTTPError(403, \"'_xsrf' argument missing from POST\")\n        _, token, _ = self._decode_xsrf_token(token)\n        _, expected_token, _ = self._get_raw_xsrf_token()\n        if not token:\n            raise HTTPError(403, \"'_xsrf' argument has invalid format\")\n        if not _time_independent_equals(utf8(token), utf8(expected_token)):\n            raise HTTPError(403, \"XSRF cookie does not match POST argument\")",
        "begin_line": 1330,
        "end_line": 1365,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.xsrf_form_html#1367",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.xsrf_form_html(self)",
        "snippet": "    def xsrf_form_html(self):\n        \"\"\"An HTML ``<input/>`` element to be included with all POST forms.\n\n        It defines the ``_xsrf`` input value, which we check on all POST\n        requests to prevent cross-site request forgery. If you have set\n        the ``xsrf_cookies`` application setting, you must include this\n        HTML within all of your HTML forms.\n\n        In a template, this method should be called with ``{% module\n        xsrf_form_html() %}``\n\n        See `check_xsrf_cookie()` above for more information.\n        \"\"\"\n        return '<input type=\"hidden\" name=\"_xsrf\" value=\"' + \\\n            escape.xhtml_escape(self.xsrf_token) + '\"/>'",
        "begin_line": 1367,
        "end_line": 1381,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.static_url#1383",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.static_url(self, path, include_host=None, **kwargs)",
        "snippet": "    def static_url(self, path, include_host=None, **kwargs):\n        \"\"\"Returns a static URL for the given relative static file path.\n\n        This method requires you set the ``static_path`` setting in your\n        application (which specifies the root directory of your static\n        files).\n\n        This method returns a versioned url (by default appending\n        ``?v=<signature>``), which allows the static files to be\n        cached indefinitely.  This can be disabled by passing\n        ``include_version=False`` (in the default implementation;\n        other static file implementations are not required to support\n        this, but they may support other options).\n\n        By default this method returns URLs relative to the current\n        host, but if ``include_host`` is true the URL returned will be\n        absolute.  If this handler has an ``include_host`` attribute,\n        that value will be used as the default for all `static_url`\n        calls that do not pass ``include_host`` as a keyword argument.\n\n        \"\"\"\n        self.require_setting(\"static_path\", \"static_url\")\n        get_url = self.settings.get(\"static_handler_class\",\n                                    StaticFileHandler).make_static_url\n\n        if include_host is None:\n            include_host = getattr(self, \"include_host\", False)\n\n        if include_host:\n            base = self.request.protocol + \"://\" + self.request.host\n        else:\n            base = \"\"\n\n        return base + get_url(self.settings, path, **kwargs)",
        "begin_line": 1383,
        "end_line": 1416,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001836884643644379,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.require_setting#1418",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.require_setting(self, name, feature='this feature')",
        "snippet": "    def require_setting(self, name, feature=\"this feature\"):\n        \"\"\"Raises an exception if the given app setting is not defined.\"\"\"\n        if not self.application.settings.get(name):\n            raise Exception(\"You must define the '%s' setting in your \"\n                            \"application to use %s\" % (name, feature))",
        "begin_line": 1418,
        "end_line": 1422,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014803849000740192,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.reverse_url#1424",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.reverse_url(self, name, *args)",
        "snippet": "    def reverse_url(self, name, *args):\n        \"\"\"Alias for `Application.reverse_url`.\"\"\"\n        return self.application.reverse_url(name, *args)",
        "begin_line": 1424,
        "end_line": 1426,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00018018018018018018,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.compute_etag#1428",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.compute_etag(self)",
        "snippet": "    def compute_etag(self):\n        \"\"\"Computes the etag header to be used for this request.\n\n        By default uses a hash of the content written so far.\n\n        May be overridden to provide custom etag implementations,\n        or may return None to disable tornado's default etag support.\n        \"\"\"\n        hasher = hashlib.sha1()\n        for part in self._write_buffer:\n            hasher.update(part)\n        return '\"%s\"' % hasher.hexdigest()",
        "begin_line": 1428,
        "end_line": 1439,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000423728813559322,
            "pseudo_dstar_susp": 0.00043047783039173483,
            "pseudo_tarantula_susp": 0.0004266211604095563,
            "pseudo_op2_susp": 0.00043047783039173483,
            "pseudo_barinel_susp": 0.00042643923240938164
        }
    },
    {
        "name": "tornado.web.RequestHandler.set_etag_header#1441",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.set_etag_header(self)",
        "snippet": "    def set_etag_header(self):\n        \"\"\"Sets the response's Etag header using ``self.compute_etag()``.\n\n        Note: no header will be set if ``compute_etag()`` returns ``None``.\n\n        This method is called automatically when the request is finished.\n        \"\"\"\n        etag = self.compute_etag()\n        if etag is not None:\n            self.set_header(\"Etag\", etag)",
        "begin_line": 1441,
        "end_line": 1450,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003980891719745223,
            "pseudo_dstar_susp": 0.0004269854824935952,
            "pseudo_tarantula_susp": 0.0004127115146512588,
            "pseudo_op2_susp": 0.0004269854824935952,
            "pseudo_barinel_susp": 0.0004127115146512588
        }
    },
    {
        "name": "tornado.web.RequestHandler.check_etag_header#1452",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.check_etag_header(self)",
        "snippet": "    def check_etag_header(self):\n        \"\"\"Checks the ``Etag`` header against requests's ``If-None-Match``.\n\n        Returns ``True`` if the request's Etag matches and a 304 should be\n        returned. For example::\n\n            self.set_etag_header()\n            if self.check_etag_header():\n                self.set_status(304)\n                return\n\n        This method is called automatically when the request is finished,\n        but may be called earlier for applications that override\n        `compute_etag` and want to do an early check for ``If-None-Match``\n        before completing the request.  The ``Etag`` header should be set\n        (perhaps with `set_etag_header`) before calling this method.\n        \"\"\"\n        computed_etag = utf8(self._headers.get(\"Etag\", \"\"))\n        # Find all weak and strong etag values from If-None-Match header\n        # because RFC 7232 allows multiple etag values in a single header.\n        etags = re.findall(\n            br'\\*|(?:W/)?\"[^\"]*\"',\n            utf8(self.request.headers.get(\"If-None-Match\", \"\"))\n        )\n        if not computed_etag or not etags:\n            return False\n\n        match = False\n        if etags[0] == b'*':\n            match = True\n        else:\n            # Use a weak comparison when comparing entity-tags.\n            def val(x):\n                return x[2:] if x.startswith(b'W/') else x\n\n            for etag in etags:\n                if val(etag) == val(computed_etag):\n                    match = True\n                    break\n        return match",
        "begin_line": 1452,
        "end_line": 1491,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004201680672268908,
            "pseudo_dstar_susp": 0.0004299226139294927,
            "pseudo_tarantula_susp": 0.0004224757076468103,
            "pseudo_op2_susp": 0.0004299226139294927,
            "pseudo_barinel_susp": 0.0004224757076468103
        }
    },
    {
        "name": "tornado.web.RequestHandler.val#1484",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.val(x)",
        "snippet": "            def val(x):\n                return x[2:] if x.startswith(b'W/') else x",
        "begin_line": 1484,
        "end_line": 1485,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014847809948032666,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler._stack_context_handle_exception#1493",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._stack_context_handle_exception(self, type, value, traceback)",
        "snippet": "    def _stack_context_handle_exception(self, type, value, traceback):\n        try:\n            # For historical reasons _handle_request_exception only takes\n            # the exception value instead of the full triple,\n            # so re-raise the exception to ensure that it's in\n            # sys.exc_info()\n            raise_exc_info((type, value, traceback))\n        except Exception:\n            self._handle_request_exception(value)\n        return True",
        "begin_line": 1493,
        "end_line": 1502,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler._execute#1505",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._execute(self, transforms, *args, **kwargs)",
        "snippet": "    def _execute(self, transforms, *args, **kwargs):\n        \"\"\"Executes this request with the given output transforms.\"\"\"\n        self._transforms = transforms\n        try:\n            if self.request.method not in self.SUPPORTED_METHODS:\n                raise HTTPError(405)\n            self.path_args = [self.decode_argument(arg) for arg in args]\n            self.path_kwargs = dict((k, self.decode_argument(v, name=k))\n                                    for (k, v) in kwargs.items())\n            # If XSRF cookies are turned on, reject form submissions without\n            # the proper cookie\n            if self.request.method not in (\"GET\", \"HEAD\", \"OPTIONS\") and \\\n                    self.application.settings.get(\"xsrf_cookies\"):\n                self.check_xsrf_cookie()\n\n            result = self.prepare()\n            if result is not None:\n                result = yield result\n            if self._prepared_future is not None:\n                # Tell the Application we've finished with prepare()\n                # and are ready for the body to arrive.\n                future_set_result_unless_cancelled(self._prepared_future, None)\n            if self._finished:\n                return\n\n            if _has_stream_request_body(self.__class__):\n                # In streaming mode request.body is a Future that signals\n                # the body has been completely received.  The Future has no\n                # result; the data has been passed to self.data_received\n                # instead.\n                try:\n                    yield self.request.body\n                except iostream.StreamClosedError:\n                    return\n\n            method = getattr(self, self.request.method.lower())\n            result = method(*self.path_args, **self.path_kwargs)\n            if result is not None:\n                result = yield result\n            if self._auto_finish and not self._finished:\n                self.finish()\n        except Exception as e:\n            try:\n                self._handle_request_exception(e)\n            except Exception:\n                app_log.error(\"Exception in exception handler\", exc_info=True)\n            finally:\n                # Unset result to avoid circular references\n                result = None\n            if (self._prepared_future is not None and\n                    not self._prepared_future.done()):\n                # In case we failed before setting _prepared_future, do it\n                # now (to unblock the HTTP server).  Note that this is not\n                # in a finally block to avoid GC issues prior to Python 3.4.\n                self._prepared_future.set_result(None)",
        "begin_line": 1505,
        "end_line": 1559,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008888888888888889,
            "pseudo_dstar_susp": 0.0006702412868632708,
            "pseudo_tarantula_susp": 0.0058823529411764705,
            "pseudo_op2_susp": 0.0006702412868632708,
            "pseudo_barinel_susp": 0.0058823529411764705
        }
    },
    {
        "name": "tornado.web.RequestHandler._log#1568",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._log(self)",
        "snippet": "    def _log(self):\n        \"\"\"Logs the current request.\n\n        Sort of deprecated since this functionality was moved to the\n        Application, but left in place for the benefit of existing apps\n        that have overridden this method.\n        \"\"\"\n        self.application.log_request(self)",
        "begin_line": 1568,
        "end_line": 1575,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004083299305839118,
            "pseudo_dstar_susp": 0.00044943820224719103,
            "pseudo_tarantula_susp": 0.0004020908725371934,
            "pseudo_op2_susp": 0.00044943820224719103,
            "pseudo_barinel_susp": 0.0004020908725371934
        }
    },
    {
        "name": "tornado.web.RequestHandler._request_summary#1577",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._request_summary(self)",
        "snippet": "    def _request_summary(self):\n        return \"%s %s (%s)\" % (self.request.method, self.request.uri,\n                               self.request.remote_ip)",
        "begin_line": 1577,
        "end_line": 1579,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004038772213247173,
            "pseudo_dstar_susp": 0.0004440497335701599,
            "pseudo_tarantula_susp": 0.0003977724741447892,
            "pseudo_op2_susp": 0.0004440497335701599,
            "pseudo_barinel_susp": 0.0003977724741447892
        }
    },
    {
        "name": "tornado.web.RequestHandler._handle_request_exception#1581",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._handle_request_exception(self, e)",
        "snippet": "    def _handle_request_exception(self, e):\n        if isinstance(e, Finish):\n            # Not an error; just finish the request without logging.\n            if not self._finished:\n                self.finish(*e.args)\n            return\n        try:\n            self.log_exception(*sys.exc_info())\n        except Exception:\n            # An error here should still get a best-effort send_error()\n            # to avoid leaking the connection.\n            app_log.error(\"Error in exception logger\", exc_info=True)\n        if self._finished:\n            # Extra errors after the request has been finished should\n            # be logged, but there is no reason to continue to try and\n            # send a response.\n            return\n        if isinstance(e, HTTPError):\n            self.send_error(e.status_code, exc_info=sys.exc_info())\n        else:\n            self.send_error(500, exc_info=sys.exc_info())",
        "begin_line": 1581,
        "end_line": 1601,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.log_exception#1603",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.log_exception(self, typ, value, tb)",
        "snippet": "    def log_exception(self, typ, value, tb):\n        \"\"\"Override to customize logging of uncaught exceptions.\n\n        By default logs instances of `HTTPError` as warnings without\n        stack traces (on the ``tornado.general`` logger), and all\n        other exceptions as errors with stack traces (on the\n        ``tornado.application`` logger).\n\n        .. versionadded:: 3.1\n        \"\"\"\n        if isinstance(value, HTTPError):\n            if value.log_message:\n                format = \"%d %s: \" + value.log_message\n                args = ([value.status_code, self._request_summary()] +\n                        list(value.args))\n                gen_log.warning(format, *args)\n        else:\n            app_log.error(\"Uncaught exception %s\\n%r\", self._request_summary(),\n                          self.request, exc_info=(typ, value, tb))",
        "begin_line": 1603,
        "end_line": 1621,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016350555918901244,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler._ui_module#1623",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._ui_module(self, name, module)",
        "snippet": "    def _ui_module(self, name, module):\n        def render(*args, **kwargs):\n            if not hasattr(self, \"_active_modules\"):\n                self._active_modules = {}\n            if name not in self._active_modules:\n                self._active_modules[name] = module(self)\n            rendered = self._active_modules[name].render(*args, **kwargs)\n            return rendered\n        return render",
        "begin_line": 1623,
        "end_line": 1631,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017123287671232877,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler.render#1624",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler.render(*args, **kwargs)",
        "snippet": "        def render(*args, **kwargs):\n            if not hasattr(self, \"_active_modules\"):\n                self._active_modules = {}\n            if name not in self._active_modules:\n                self._active_modules[name] = module(self)\n            rendered = self._active_modules[name].render(*args, **kwargs)\n            return rendered",
        "begin_line": 1624,
        "end_line": 1630,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017123287671232877,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler._ui_method#1633",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._ui_method(self, method)",
        "snippet": "    def _ui_method(self, method):\n        return lambda *args, **kwargs: method(self, *args, **kwargs)",
        "begin_line": 1633,
        "end_line": 1634,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RequestHandler._clear_headers_for_304#1636",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RequestHandler",
        "signature": "tornado.web.RequestHandler._clear_headers_for_304(self)",
        "snippet": "    def _clear_headers_for_304(self):\n        # 304 responses should not contain entity headers (defined in\n        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.1)\n        # not explicitly allowed by\n        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5\n        headers = [\"Allow\", \"Content-Encoding\", \"Content-Language\",\n                   \"Content-Length\", \"Content-MD5\", \"Content-Range\",\n                   \"Content-Type\", \"Last-Modified\"]\n        for h in headers:\n            self.clear_header(h)",
        "begin_line": 1636,
        "end_line": 1645,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014005602240896358,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.asynchronous#1648",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.asynchronous(method)",
        "snippet": "def asynchronous(method):\n    \"\"\"Wrap request handler methods with this if they are asynchronous.\n\n    This decorator is for callback-style asynchronous methods; for\n    coroutines, use the ``@gen.coroutine`` decorator without\n    ``@asynchronous``. (It is legal for legacy reasons to use the two\n    decorators together provided ``@asynchronous`` is first, but\n    ``@asynchronous`` will be ignored in this case)\n\n    This decorator should only be applied to the :ref:`HTTP verb\n    methods <verbs>`; its behavior is undefined for any other method.\n    This decorator does not *make* a method asynchronous; it tells\n    the framework that the method *is* asynchronous.  For this decorator\n    to be useful the method must (at least sometimes) do something\n    asynchronous.\n\n    If this decorator is given, the response is not finished when the\n    method returns. It is up to the request handler to call\n    `self.finish() <RequestHandler.finish>` to finish the HTTP\n    request. Without this decorator, the request is automatically\n    finished when the ``get()`` or ``post()`` method returns. Example:\n\n    .. testcode::\n\n       class MyRequestHandler(RequestHandler):\n           @asynchronous\n           def get(self):\n              http = httpclient.AsyncHTTPClient()\n              http.fetch(\"http://friendfeed.com/\", self._on_download)\n\n           def _on_download(self, response):\n              self.write(\"Downloaded!\")\n              self.finish()\n\n    .. testoutput::\n       :hide:\n\n    .. versionchanged:: 3.1\n       The ability to use ``@gen.coroutine`` without ``@asynchronous``.\n\n    .. versionchanged:: 4.3 Returning anything but ``None`` or a\n       yieldable object from a method decorated with ``@asynchronous``\n       is an error. Such return values were previously ignored silently.\n    \"\"\"\n    # Delay the IOLoop import because it's not available on app engine.\n    from tornado.ioloop import IOLoop\n\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        self._auto_finish = False\n        with stack_context.ExceptionStackContext(\n                self._stack_context_handle_exception):\n            result = method(self, *args, **kwargs)\n            if result is not None:\n                result = gen.convert_yielded(result)\n\n                # If @asynchronous is used with @gen.coroutine, (but\n                # not @gen.engine), we can automatically finish the\n                # request when the future resolves.  Additionally,\n                # the Future will swallow any exceptions so we need\n                # to throw them back out to the stack context to finish\n                # the request.\n                def future_complete(f):\n                    f.result()\n                    if not self._finished:\n                        self.finish()\n                IOLoop.current().add_future(result, future_complete)\n                # Once we have done this, hide the Future from our\n                # caller (i.e. RequestHandler._when_complete), which\n                # would otherwise set up its own callback and\n                # exception handler (resulting in exceptions being\n                # logged twice).\n                return None\n            return result\n    return wrapper",
        "begin_line": 1648,
        "end_line": 1722,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00018018018018018018,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.wrapper#1696",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.wrapper(self, *args, **kwargs)",
        "snippet": "    def wrapper(self, *args, **kwargs):\n        self._auto_finish = False\n        with stack_context.ExceptionStackContext(\n                self._stack_context_handle_exception):\n            result = method(self, *args, **kwargs)\n            if result is not None:\n                result = gen.convert_yielded(result)\n\n                # If @asynchronous is used with @gen.coroutine, (but\n                # not @gen.engine), we can automatically finish the\n                # request when the future resolves.  Additionally,\n                # the Future will swallow any exceptions so we need\n                # to throw them back out to the stack context to finish\n                # the request.\n                def future_complete(f):\n                    f.result()\n                    if not self._finished:\n                        self.finish()\n                IOLoop.current().add_future(result, future_complete)\n                # Once we have done this, hide the Future from our\n                # caller (i.e. RequestHandler._when_complete), which\n                # would otherwise set up its own callback and\n                # exception handler (resulting in exceptions being\n                # logged twice).\n                return None\n            return result",
        "begin_line": 1696,
        "end_line": 1721,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.future_complete#1710",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.future_complete(f)",
        "snippet": "                def future_complete(f):\n                    f.result()\n                    if not self._finished:\n                        self.finish()",
        "begin_line": 1710,
        "end_line": 1713,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.stream_request_body#1725",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.stream_request_body(cls)",
        "snippet": "def stream_request_body(cls):\n    \"\"\"Apply to `RequestHandler` subclasses to enable streaming body support.\n\n    This decorator implies the following changes:\n\n    * `.HTTPServerRequest.body` is undefined, and body arguments will not\n      be included in `RequestHandler.get_argument`.\n    * `RequestHandler.prepare` is called when the request headers have been\n      read instead of after the entire body has been read.\n    * The subclass must define a method ``data_received(self, data):``, which\n      will be called zero or more times as data is available.  Note that\n      if the request has an empty body, ``data_received`` may not be called.\n    * ``prepare`` and ``data_received`` may return Futures (such as via\n      ``@gen.coroutine``, in which case the next method will not be called\n      until those futures have completed.\n    * The regular HTTP method (``post``, ``put``, etc) will be called after\n      the entire body has been read.\n\n    See the `file receiver demo <https://github.com/tornadoweb/tornado/tree/master/demos/file_upload/>`_\n    for example usage.\n    \"\"\"  # noqa: E501\n    if not issubclass(cls, RequestHandler):\n        raise TypeError(\"expected subclass of RequestHandler, got %r\", cls)\n    cls._stream_request_body = True\n    return cls",
        "begin_line": 1725,
        "end_line": 1749,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008726003490401396,
            "pseudo_dstar_susp": 0.0005065856129685917,
            "pseudo_tarantula_susp": 0.0035211267605633804,
            "pseudo_op2_susp": 0.0005065856129685917,
            "pseudo_barinel_susp": 0.0035211267605633804
        }
    },
    {
        "name": "tornado.web._has_stream_request_body#1752",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web._has_stream_request_body(cls)",
        "snippet": "def _has_stream_request_body(cls):\n    if not issubclass(cls, RequestHandler):\n        raise TypeError(\"expected subclass of RequestHandler, got %r\", cls)\n    return getattr(cls, '_stream_request_body', False)",
        "begin_line": 1752,
        "end_line": 1755,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005282620179609086,
            "pseudo_dstar_susp": 0.0006161429451632779,
            "pseudo_tarantula_susp": 0.0005025125628140704,
            "pseudo_op2_susp": 0.0006161429451632779,
            "pseudo_barinel_susp": 0.0005025125628140704
        }
    },
    {
        "name": "tornado.web.removeslash#1758",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.removeslash(method)",
        "snippet": "def removeslash(method):\n    \"\"\"Use this decorator to remove trailing slashes from the request path.\n\n    For example, a request to ``/foo/`` would redirect to ``/foo`` with this\n    decorator. Your request handler mapping should use a regular expression\n    like ``r'/foo/*'`` in conjunction with using the decorator.\n    \"\"\"\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        if self.request.path.endswith(\"/\"):\n            if self.request.method in (\"GET\", \"HEAD\"):\n                uri = self.request.path.rstrip(\"/\")\n                if uri:  # don't try to redirect '/' to ''\n                    if self.request.query:\n                        uri += \"?\" + self.request.query\n                    self.redirect(uri, permanent=True)\n                    return\n            else:\n                raise HTTPError(404)\n        return method(self, *args, **kwargs)\n    return wrapper",
        "begin_line": 1758,
        "end_line": 1778,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.wrapper#1766",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.wrapper(self, *args, **kwargs)",
        "snippet": "    def wrapper(self, *args, **kwargs):\n        if self.request.path.endswith(\"/\"):\n            if self.request.method in (\"GET\", \"HEAD\"):\n                uri = self.request.path.rstrip(\"/\")\n                if uri:  # don't try to redirect '/' to ''\n                    if self.request.query:\n                        uri += \"?\" + self.request.query\n                    self.redirect(uri, permanent=True)\n                    return\n            else:\n                raise HTTPError(404)\n        return method(self, *args, **kwargs)",
        "begin_line": 1766,
        "end_line": 1777,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.addslash#1781",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.addslash(method)",
        "snippet": "def addslash(method):\n    \"\"\"Use this decorator to add a missing trailing slash to the request path.\n\n    For example, a request to ``/foo`` would redirect to ``/foo/`` with this\n    decorator. Your request handler mapping should use a regular expression\n    like ``r'/foo/?'`` in conjunction with using the decorator.\n    \"\"\"\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        if not self.request.path.endswith(\"/\"):\n            if self.request.method in (\"GET\", \"HEAD\"):\n                uri = self.request.path + \"/\"\n                if self.request.query:\n                    uri += \"?\" + self.request.query\n                self.redirect(uri, permanent=True)\n                return\n            raise HTTPError(404)\n        return method(self, *args, **kwargs)\n    return wrapper",
        "begin_line": 1781,
        "end_line": 1799,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.wrapper#1789",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.wrapper(self, *args, **kwargs)",
        "snippet": "    def wrapper(self, *args, **kwargs):\n        if not self.request.path.endswith(\"/\"):\n            if self.request.method in (\"GET\", \"HEAD\"):\n                uri = self.request.path + \"/\"\n                if self.request.query:\n                    uri += \"?\" + self.request.query\n                self.redirect(uri, permanent=True)\n                return\n            raise HTTPError(404)\n        return method(self, *args, **kwargs)",
        "begin_line": 1789,
        "end_line": 1798,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web._ApplicationRouter.__init__#1813",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._ApplicationRouter",
        "signature": "tornado.web._ApplicationRouter.__init__(self, application, rules=None)",
        "snippet": "    def __init__(self, application, rules=None):\n        assert isinstance(application, Application)\n        self.application = application\n        super(_ApplicationRouter, self).__init__(rules)",
        "begin_line": 1813,
        "end_line": 1816,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017391304347826088,
            "pseudo_dstar_susp": 0.0017857142857142857,
            "pseudo_tarantula_susp": 0.0012300123001230013,
            "pseudo_op2_susp": 0.0017857142857142857,
            "pseudo_barinel_susp": 0.0012300123001230013
        }
    },
    {
        "name": "tornado.web._ApplicationRouter.process_rule#1818",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._ApplicationRouter",
        "signature": "tornado.web._ApplicationRouter.process_rule(self, rule)",
        "snippet": "    def process_rule(self, rule):\n        rule = super(_ApplicationRouter, self).process_rule(rule)\n\n        if isinstance(rule.target, (list, tuple)):\n            rule.target = _ApplicationRouter(self.application, rule.target)\n\n        return rule",
        "begin_line": 1818,
        "end_line": 1824,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017391304347826088,
            "pseudo_dstar_susp": 0.0017857142857142857,
            "pseudo_tarantula_susp": 0.0012300123001230013,
            "pseudo_op2_susp": 0.0017857142857142857,
            "pseudo_barinel_susp": 0.0012300123001230013
        }
    },
    {
        "name": "tornado.web._ApplicationRouter.get_target_delegate#1826",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._ApplicationRouter",
        "signature": "tornado.web._ApplicationRouter.get_target_delegate(self, target, request, **target_params)",
        "snippet": "    def get_target_delegate(self, target, request, **target_params):\n        if isclass(target) and issubclass(target, RequestHandler):\n            return self.application.get_handler_delegate(request, target, **target_params)\n\n        return super(_ApplicationRouter, self).get_target_delegate(target, request, **target_params)",
        "begin_line": 1826,
        "end_line": 1830,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005393743257820927,
            "pseudo_dstar_susp": 0.0006289308176100629,
            "pseudo_tarantula_susp": 0.0005115089514066496,
            "pseudo_op2_susp": 0.0006289308176100629,
            "pseudo_barinel_susp": 0.0005115089514066496
        }
    },
    {
        "name": "tornado.web.Application.__init__#1916",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application.__init__(self, handlers=None, default_host=None, transforms=None, **settings)",
        "snippet": "    def __init__(self, handlers=None, default_host=None, transforms=None,\n                 **settings):\n        if transforms is None:\n            self.transforms = []\n            if settings.get(\"compress_response\") or settings.get(\"gzip\"):\n                self.transforms.append(GZipContentEncoding)\n        else:\n            self.transforms = transforms\n        self.default_host = default_host\n        self.settings = settings\n        self.ui_modules = {'linkify': _linkify,\n                           'xsrf_form_html': _xsrf_form_html,\n                           'Template': TemplateModule,\n                           }\n        self.ui_methods = {}\n        self._load_ui_modules(settings.get(\"ui_modules\", {}))\n        self._load_ui_methods(settings.get(\"ui_methods\", {}))\n        if self.settings.get(\"static_path\"):\n            path = self.settings[\"static_path\"]\n            handlers = list(handlers or [])\n            static_url_prefix = settings.get(\"static_url_prefix\",\n                                             \"/static/\")\n            static_handler_class = settings.get(\"static_handler_class\",\n                                                StaticFileHandler)\n            static_handler_args = settings.get(\"static_handler_args\", {})\n            static_handler_args['path'] = path\n            for pattern in [re.escape(static_url_prefix) + r\"(.*)\",\n                            r\"/(favicon\\.ico)\", r\"/(robots\\.txt)\"]:\n                handlers.insert(0, (pattern, static_handler_class,\n                                    static_handler_args))\n\n        if self.settings.get('debug'):\n            self.settings.setdefault('autoreload', True)\n            self.settings.setdefault('compiled_template_cache', False)\n            self.settings.setdefault('static_hash_cache', False)\n            self.settings.setdefault('serve_traceback', True)\n\n        self.wildcard_router = _ApplicationRouter(self, handlers)\n        self.default_router = _ApplicationRouter(self, [\n            Rule(AnyMatches(), self.wildcard_router)\n        ])\n\n        # Automatically reload modified modules\n        if self.settings.get('autoreload'):\n            from tornado import autoreload\n            autoreload.start()",
        "begin_line": 1916,
        "end_line": 1961,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017391304347826088,
            "pseudo_dstar_susp": 0.0017857142857142857,
            "pseudo_tarantula_susp": 0.002793296089385475,
            "pseudo_op2_susp": 0.0017857142857142857,
            "pseudo_barinel_susp": 0.002793296089385475
        }
    },
    {
        "name": "tornado.web.Application.listen#1963",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application.listen(self, port, address='', **kwargs)",
        "snippet": "    def listen(self, port, address=\"\", **kwargs):\n        \"\"\"Starts an HTTP server for this application on the given port.\n\n        This is a convenience alias for creating an `.HTTPServer`\n        object and calling its listen method.  Keyword arguments not\n        supported by `HTTPServer.listen <.TCPServer.listen>` are passed to the\n        `.HTTPServer` constructor.  For advanced uses\n        (e.g. multi-process mode), do not use this method; create an\n        `.HTTPServer` and call its\n        `.TCPServer.bind`/`.TCPServer.start` methods directly.\n\n        Note that after calling this method you still need to call\n        ``IOLoop.current().start()`` to start the server.\n\n        Returns the `.HTTPServer` object.\n\n        .. versionchanged:: 4.3\n           Now returns the `.HTTPServer` object.\n        \"\"\"\n        # import is here rather than top level because HTTPServer\n        # is not importable on appengine\n        from tornado.httpserver import HTTPServer\n        server = HTTPServer(self, **kwargs)\n        server.listen(port, address)\n        return server",
        "begin_line": 1963,
        "end_line": 1987,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.Application.add_handlers#1989",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application.add_handlers(self, host_pattern, host_handlers)",
        "snippet": "    def add_handlers(self, host_pattern, host_handlers):\n        \"\"\"Appends the given handlers to our handler list.\n\n        Host patterns are processed sequentially in the order they were\n        added. All matching patterns will be considered.\n        \"\"\"\n        host_matcher = HostMatches(host_pattern)\n        rule = Rule(host_matcher, _ApplicationRouter(self, host_handlers))\n\n        self.default_router.rules.insert(-1, rule)\n\n        if self.default_host is not None:\n            self.wildcard_router.add_rules([(\n                DefaultHostMatches(self, host_matcher.host_pattern),\n                host_handlers\n            )])",
        "begin_line": 1989,
        "end_line": 2004,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.Application._load_ui_methods#2009",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application._load_ui_methods(self, methods)",
        "snippet": "    def _load_ui_methods(self, methods):\n        if isinstance(methods, types.ModuleType):\n            self._load_ui_methods(dict((n, getattr(methods, n))\n                                       for n in dir(methods)))\n        elif isinstance(methods, list):\n            for m in methods:\n                self._load_ui_methods(m)\n        else:\n            for name, fn in methods.items():\n                if not name.startswith(\"_\") and hasattr(fn, \"__call__\") \\\n                        and name[0].lower() == name[0]:\n                    self.ui_methods[name] = fn",
        "begin_line": 2009,
        "end_line": 2020,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017391304347826088,
            "pseudo_dstar_susp": 0.0017857142857142857,
            "pseudo_tarantula_susp": 0.0012300123001230013,
            "pseudo_op2_susp": 0.0017857142857142857,
            "pseudo_barinel_susp": 0.0012300123001230013
        }
    },
    {
        "name": "tornado.web.Application._load_ui_modules#2022",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application._load_ui_modules(self, modules)",
        "snippet": "    def _load_ui_modules(self, modules):\n        if isinstance(modules, types.ModuleType):\n            self._load_ui_modules(dict((n, getattr(modules, n))\n                                       for n in dir(modules)))\n        elif isinstance(modules, list):\n            for m in modules:\n                self._load_ui_modules(m)\n        else:\n            assert isinstance(modules, dict)\n            for name, cls in modules.items():\n                try:\n                    if issubclass(cls, UIModule):\n                        self.ui_modules[name] = cls\n                except TypeError:\n                    pass",
        "begin_line": 2022,
        "end_line": 2036,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017391304347826088,
            "pseudo_dstar_susp": 0.0017857142857142857,
            "pseudo_tarantula_susp": 0.0012300123001230013,
            "pseudo_op2_susp": 0.0017857142857142857,
            "pseudo_barinel_susp": 0.0012300123001230013
        }
    },
    {
        "name": "tornado.web.Application.__call__#2038",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application.__call__(self, request)",
        "snippet": "    def __call__(self, request):\n        # Legacy HTTPServer interface\n        dispatcher = self.find_handler(request)\n        return dispatcher.execute()",
        "begin_line": 2038,
        "end_line": 2041,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013335111348179759,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.Application.find_handler#2043",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application.find_handler(self, request, **kwargs)",
        "snippet": "    def find_handler(self, request, **kwargs):\n        route = self.default_router.find_handler(request)\n        if route is not None:\n            return route\n\n        if self.settings.get('default_handler_class'):\n            return self.get_handler_delegate(\n                request,\n                self.settings['default_handler_class'],\n                self.settings.get('default_handler_args', {}))\n\n        return self.get_handler_delegate(\n            request, ErrorHandler, {'status_code': 404})",
        "begin_line": 2043,
        "end_line": 2055,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005393743257820927,
            "pseudo_dstar_susp": 0.0006289308176100629,
            "pseudo_tarantula_susp": 0.0005115089514066496,
            "pseudo_op2_susp": 0.0006289308176100629,
            "pseudo_barinel_susp": 0.0005115089514066496
        }
    },
    {
        "name": "tornado.web.Application.get_handler_delegate#2057",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application.get_handler_delegate(self, request, target_class, target_kwargs=None, path_args=None, path_kwargs=None)",
        "snippet": "    def get_handler_delegate(self, request, target_class, target_kwargs=None,\n                             path_args=None, path_kwargs=None):\n        \"\"\"Returns `~.httputil.HTTPMessageDelegate` that can serve a request\n        for application and `RequestHandler` subclass.\n\n        :arg httputil.HTTPServerRequest request: current HTTP request.\n        :arg RequestHandler target_class: a `RequestHandler` class.\n        :arg dict target_kwargs: keyword arguments for ``target_class`` constructor.\n        :arg list path_args: positional arguments for ``target_class`` HTTP method that\n            will be executed while handling a request (``get``, ``post`` or any other).\n        :arg dict path_kwargs: keyword arguments for ``target_class`` HTTP method.\n        \"\"\"\n        return _HandlerDelegate(\n            self, request, target_class, target_kwargs, path_args, path_kwargs)",
        "begin_line": 2057,
        "end_line": 2070,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005282620179609086,
            "pseudo_dstar_susp": 0.0006161429451632779,
            "pseudo_tarantula_susp": 0.0005025125628140704,
            "pseudo_op2_susp": 0.0006161429451632779,
            "pseudo_barinel_susp": 0.0005025125628140704
        }
    },
    {
        "name": "tornado.web.Application.reverse_url#2072",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application.reverse_url(self, name, *args)",
        "snippet": "    def reverse_url(self, name, *args):\n        \"\"\"Returns a URL path for handler named ``name``\n\n        The handler must be added to the application as a named `URLSpec`.\n\n        Args will be substituted for capturing groups in the `URLSpec` regex.\n        They will be converted to strings if necessary, encoded as utf8,\n        and url-escaped.\n        \"\"\"\n        reversed_url = self.default_router.reverse_url(name, *args)\n        if reversed_url is not None:\n            return reversed_url\n\n        raise KeyError(\"%s not found in named urls\" % name)",
        "begin_line": 2072,
        "end_line": 2085,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017528483786152498,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.Application.log_request#2087",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.Application",
        "signature": "tornado.web.Application.log_request(self, handler)",
        "snippet": "    def log_request(self, handler):\n        \"\"\"Writes a completed HTTP request to the logs.\n\n        By default writes to the python root logger.  To change\n        this behavior either subclass Application and override this method,\n        or pass a function in the application settings dictionary as\n        ``log_function``.\n        \"\"\"\n        if \"log_function\" in self.settings:\n            self.settings[\"log_function\"](handler)\n            return\n        if handler.get_status() < 400:\n            log_method = access_log.info\n        elif handler.get_status() < 500:\n            log_method = access_log.warning\n        else:\n            log_method = access_log.error\n        request_time = 1000.0 * handler.request.request_time()\n        log_method(\"%d %s %.2fms\", handler.get_status(),\n                   handler._request_summary(), request_time)",
        "begin_line": 2087,
        "end_line": 2106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00042140750105351877,
            "pseudo_dstar_susp": 0.0004623208506703652,
            "pseudo_tarantula_susp": 0.00041407867494824016,
            "pseudo_op2_susp": 0.0004623208506703652,
            "pseudo_barinel_susp": 0.00041407867494824016
        }
    },
    {
        "name": "tornado.web._HandlerDelegate.__init__#2110",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._HandlerDelegate",
        "signature": "tornado.web._HandlerDelegate.__init__(self, application, request, handler_class, handler_kwargs, path_args, path_kwargs)",
        "snippet": "    def __init__(self, application, request, handler_class, handler_kwargs,\n                 path_args, path_kwargs):\n        self.application = application\n        self.connection = request.connection\n        self.request = request\n        self.handler_class = handler_class\n        self.handler_kwargs = handler_kwargs or {}\n        self.path_args = path_args or []\n        self.path_kwargs = path_kwargs or {}\n        self.chunks = []\n        self.stream_request_body = _has_stream_request_body(self.handler_class)",
        "begin_line": 2110,
        "end_line": 2120,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005282620179609086,
            "pseudo_dstar_susp": 0.0006161429451632779,
            "pseudo_tarantula_susp": 0.0005025125628140704,
            "pseudo_op2_susp": 0.0006161429451632779,
            "pseudo_barinel_susp": 0.0005025125628140704
        }
    },
    {
        "name": "tornado.web._HandlerDelegate.headers_received#2122",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._HandlerDelegate",
        "signature": "tornado.web._HandlerDelegate.headers_received(self, start_line, headers)",
        "snippet": "    def headers_received(self, start_line, headers):\n        if self.stream_request_body:\n            self.request.body = Future()\n            return self.execute()",
        "begin_line": 2122,
        "end_line": 2125,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007012622720897616,
            "pseudo_dstar_susp": 0.0006337135614702154,
            "pseudo_tarantula_susp": 0.002857142857142857,
            "pseudo_op2_susp": 0.0006337135614702154,
            "pseudo_barinel_susp": 0.002857142857142857
        }
    },
    {
        "name": "tornado.web._HandlerDelegate.data_received#2127",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._HandlerDelegate",
        "signature": "tornado.web._HandlerDelegate.data_received(self, data)",
        "snippet": "    def data_received(self, data):\n        if self.stream_request_body:\n            return self.handler.data_received(data)\n        else:\n            self.chunks.append(data)",
        "begin_line": 2127,
        "end_line": 2131,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00047058823529411766,
            "pseudo_dstar_susp": 0.00039231071008238524,
            "pseudo_tarantula_susp": 0.0010857763300760044,
            "pseudo_op2_susp": 0.00039231071008238524,
            "pseudo_barinel_susp": 0.0010857763300760044
        }
    },
    {
        "name": "tornado.web._HandlerDelegate.finish#2133",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._HandlerDelegate",
        "signature": "tornado.web._HandlerDelegate.finish(self)",
        "snippet": "    def finish(self):\n        if self.stream_request_body:\n            future_set_result_unless_cancelled(self.request.body, None)\n        else:\n            self.request.body = b''.join(self.chunks)\n            self.request._parse_body()\n            self.execute()",
        "begin_line": 2133,
        "end_line": 2139,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00047058823529411766,
            "pseudo_dstar_susp": 0.00046707146193367583,
            "pseudo_tarantula_susp": 0.0010857763300760044,
            "pseudo_op2_susp": 0.00046707146193367583,
            "pseudo_barinel_susp": 0.0010857763300760044
        }
    },
    {
        "name": "tornado.web._HandlerDelegate.on_connection_close#2141",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._HandlerDelegate",
        "signature": "tornado.web._HandlerDelegate.on_connection_close(self)",
        "snippet": "    def on_connection_close(self):\n        if self.stream_request_body:\n            self.handler.on_connection_close()\n        else:\n            self.chunks = None",
        "begin_line": 2141,
        "end_line": 2145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001218026796589525,
            "pseudo_dstar_susp": 0.0005482456140350877,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.0005482456140350877,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.web._HandlerDelegate.execute#2147",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._HandlerDelegate",
        "signature": "tornado.web._HandlerDelegate.execute(self)",
        "snippet": "    def execute(self):\n        # If template cache is disabled (usually in the debug mode),\n        # re-compile templates and reload static files on every\n        # request so you don't need to restart to see changes\n        if not self.application.settings.get(\"compiled_template_cache\", True):\n            with RequestHandler._template_loader_lock:\n                for loader in RequestHandler._template_loaders.values():\n                    loader.reset()\n        if not self.application.settings.get('static_hash_cache', True):\n            StaticFileHandler.reset()\n\n        self.handler = self.handler_class(self.application, self.request,\n                                          **self.handler_kwargs)\n        transforms = [t(self.request) for t in self.application.transforms]\n\n        if self.stream_request_body:\n            self.handler._prepared_future = Future()\n        # Note that if an exception escapes handler._execute it will be\n        # trapped in the Future it returns (which we are ignoring here,\n        # leaving it to be logged when the Future is GC'd).\n        # However, that shouldn't happen because _execute has a blanket\n        # except handler, and we cannot easily access the IOLoop here to\n        # call add_future (because of the requirement to remain compatible\n        # with WSGI)\n        self.handler._execute(transforms, *self.path_args,\n                              **self.path_kwargs)\n        # If we are streaming the request body, then execute() is finished\n        # when the handler has prepared to receive the body.  If not,\n        # it doesn't matter when execute() finishes (so we return None)\n        return self.handler._prepared_future",
        "begin_line": 2147,
        "end_line": 2176,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007012622720897616,
            "pseudo_dstar_susp": 0.0006693440428380187,
            "pseudo_tarantula_susp": 0.002857142857142857,
            "pseudo_op2_susp": 0.0006693440428380187,
            "pseudo_barinel_susp": 0.002857142857142857
        }
    },
    {
        "name": "tornado.web.HTTPError.__init__#2201",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.HTTPError",
        "signature": "tornado.web.HTTPError.__init__(self, status_code=500, log_message=None, *args, **kwargs)",
        "snippet": "    def __init__(self, status_code=500, log_message=None, *args, **kwargs):\n        self.status_code = status_code\n        self.log_message = log_message\n        self.args = args\n        self.reason = kwargs.get('reason', None)\n        if log_message and not args:\n            self.log_message = log_message.replace('%', '%%')",
        "begin_line": 2201,
        "end_line": 2207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015323322096230462,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.HTTPError.__str__#2209",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.HTTPError",
        "signature": "tornado.web.HTTPError.__str__(self)",
        "snippet": "    def __str__(self):\n        message = \"HTTP %d: %s\" % (\n            self.status_code,\n            self.reason or httputil.responses.get(self.status_code, 'Unknown'))\n        if self.log_message:\n            return message + \" (\" + (self.log_message % self.args) + \")\"\n        else:\n            return message",
        "begin_line": 2209,
        "end_line": 2216,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.MissingArgumentError.__init__#2254",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.MissingArgumentError",
        "signature": "tornado.web.MissingArgumentError.__init__(self, arg_name)",
        "snippet": "    def __init__(self, arg_name):\n        super(MissingArgumentError, self).__init__(\n            400, 'Missing argument %s' % arg_name)\n        self.arg_name = arg_name",
        "begin_line": 2254,
        "end_line": 2257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.ErrorHandler.initialize#2262",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.ErrorHandler",
        "signature": "tornado.web.ErrorHandler.initialize(self, status_code)",
        "snippet": "    def initialize(self, status_code):\n        self.set_status(status_code)",
        "begin_line": 2262,
        "end_line": 2263,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015730690577316344,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.ErrorHandler.prepare#2265",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.ErrorHandler",
        "signature": "tornado.web.ErrorHandler.prepare(self)",
        "snippet": "    def prepare(self):\n        raise HTTPError(self._status_code)",
        "begin_line": 2265,
        "end_line": 2266,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015730690577316344,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.ErrorHandler.check_xsrf_cookie#2268",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.ErrorHandler",
        "signature": "tornado.web.ErrorHandler.check_xsrf_cookie(self)",
        "snippet": "    def check_xsrf_cookie(self):\n        # POSTs to an ErrorHandler don't actually have side effects,\n        # so we don't need to check the xsrf token.  This allows POSTs\n        # to the wrong url to return a 404 instead of 403.\n        pass",
        "begin_line": 2268,
        "end_line": 2272,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RedirectHandler.initialize#2307",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RedirectHandler",
        "signature": "tornado.web.RedirectHandler.initialize(self, url, permanent=True)",
        "snippet": "    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent",
        "begin_line": 2307,
        "end_line": 2309,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00018018018018018018,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.RedirectHandler.get#2311",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.RedirectHandler",
        "signature": "tornado.web.RedirectHandler.get(self, *args)",
        "snippet": "    def get(self, *args):\n        to_url = self._url.format(*args)\n        if self.request.query_arguments:\n            to_url = httputil.url_concat(\n                to_url, list(httputil.qs_to_qsl(self.request.query_arguments)))\n        self.redirect(to_url, permanent=self._permanent)",
        "begin_line": 2311,
        "end_line": 2316,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.initialize#2390",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.initialize(self, path, default_filename=None)",
        "snippet": "    def initialize(self, path, default_filename=None):\n        self.root = path\n        self.default_filename = default_filename",
        "begin_line": 2390,
        "end_line": 2392,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013719303059404582,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.head#2399",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.head(self, path)",
        "snippet": "    def head(self, path):\n        return self.get(path, include_body=False)",
        "begin_line": 2399,
        "end_line": 2400,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013982102908277405,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.get#2403",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.get(self, path, include_body=True)",
        "snippet": "    def get(self, path, include_body=True):\n        # Set up our path instance variables.\n        self.path = self.parse_url_path(path)\n        del path  # make sure we don't refer to path instead of self.path again\n        absolute_path = self.get_absolute_path(self.root, self.path)\n        self.absolute_path = self.validate_absolute_path(\n            self.root, absolute_path)\n        if self.absolute_path is None:\n            return\n\n        self.modified = self.get_modified_time()\n        self.set_headers()\n\n        if self.should_return_304():\n            self.set_status(304)\n            return\n\n        request_range = None\n        range_header = self.request.headers.get(\"Range\")\n        if range_header:\n            # As per RFC 2616 14.16, if an invalid Range header is specified,\n            # the request will be treated as if the header didn't exist.\n            request_range = httputil._parse_request_range(range_header)\n\n        size = self.get_content_size()\n        if request_range:\n            start, end = request_range\n            if (start is not None and start >= size) or end == 0:\n                # As per RFC 2616 14.35.1, a range is not satisfiable only: if\n                # the first requested byte is equal to or greater than the\n                # content, or when a suffix with length 0 is specified\n                self.set_status(416)  # Range Not Satisfiable\n                self.set_header(\"Content-Type\", \"text/plain\")\n                self.set_header(\"Content-Range\", \"bytes */%s\" % (size, ))\n                return\n            if start is not None and start < 0:\n                start += size\n            if end is not None and end > size:\n                # Clients sometimes blindly use a large range to limit their\n                # download size; cap the endpoint at the actual file size.\n                end = size\n            # Note: only return HTTP 206 if less than the entire range has been\n            # requested. Not only is this semantically correct, but Chrome\n            # refuses to play audio if it gets an HTTP 206 in response to\n            # ``Range: bytes=0-``.\n            if size != (end or size) - (start or 0):\n                self.set_status(206)  # Partial Content\n                self.set_header(\"Content-Range\",\n                                httputil._get_content_range(start, end, size))\n        else:\n            start = end = None\n\n        if start is not None and end is not None:\n            content_length = end - start\n        elif end is not None:\n            content_length = end\n        elif start is not None:\n            content_length = size - start\n        else:\n            content_length = size\n        self.set_header(\"Content-Length\", content_length)\n\n        if include_body:\n            content = self.get_content(self.absolute_path, start, end)\n            if isinstance(content, bytes):\n                content = [content]\n            for chunk in content:\n                try:\n                    self.write(chunk)\n                    yield self.flush()\n                except iostream.StreamClosedError:\n                    return\n        else:\n            assert self.request.method == \"HEAD\"",
        "begin_line": 2403,
        "end_line": 2476,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.compute_etag#2478",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.compute_etag(self)",
        "snippet": "    def compute_etag(self):\n        \"\"\"Sets the ``Etag`` header based on static url version.\n\n        This allows efficient ``If-None-Match`` checks against cached\n        versions, and sends the correct ``Etag`` for a partial response\n        (i.e. the same ``Etag`` as the full file).\n\n        .. versionadded:: 3.1\n        \"\"\"\n        version_hash = self._get_cached_version(self.absolute_path)\n        if not version_hash:\n            return None\n        return '\"%s\"' % (version_hash, )",
        "begin_line": 2478,
        "end_line": 2490,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001380452788514633,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.set_headers#2492",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.set_headers(self)",
        "snippet": "    def set_headers(self):\n        \"\"\"Sets the content and caching headers on the response.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        self.set_header(\"Accept-Ranges\", \"bytes\")\n        self.set_etag_header()\n\n        if self.modified is not None:\n            self.set_header(\"Last-Modified\", self.modified)\n\n        content_type = self.get_content_type()\n        if content_type:\n            self.set_header(\"Content-Type\", content_type)\n\n        cache_time = self.get_cache_time(self.path, self.modified,\n                                         content_type)\n        if cache_time > 0:\n            self.set_header(\"Expires\", datetime.datetime.utcnow() +\n                            datetime.timedelta(seconds=cache_time))\n            self.set_header(\"Cache-Control\", \"max-age=\" + str(cache_time))\n\n        self.set_extra_headers(self.path)",
        "begin_line": 2492,
        "end_line": 2514,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001389274798555154,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.should_return_304#2516",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.should_return_304(self)",
        "snippet": "    def should_return_304(self):\n        \"\"\"Returns True if the headers indicate that we should return 304.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        # If client sent If-None-Match, use it, ignore If-Modified-Since\n        if self.request.headers.get('If-None-Match'):\n            return self.check_etag_header()\n\n        # Check the If-Modified-Since, and don't send the result if the\n        # content has not been modified\n        ims_value = self.request.headers.get(\"If-Modified-Since\")\n        if ims_value is not None:\n            date_tuple = email.utils.parsedate(ims_value)\n            if date_tuple is not None:\n                if_since = datetime.datetime(*date_tuple[:6])\n                if if_since >= self.modified:\n                    return True\n\n        return False",
        "begin_line": 2516,
        "end_line": 2535,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.get_absolute_path#2538",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.get_absolute_path(cls, root, path)",
        "snippet": "    def get_absolute_path(cls, root, path):\n        \"\"\"Returns the absolute location of ``path`` relative to ``root``.\n\n        ``root`` is the path configured for this `StaticFileHandler`\n        (in most cases the ``static_path`` `Application` setting).\n\n        This class method may be overridden in subclasses.  By default\n        it returns a filesystem path, but other strings may be used\n        as long as they are unique and understood by the subclass's\n        overridden `get_content`.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        abspath = os.path.abspath(os.path.join(root, path))\n        return abspath",
        "begin_line": 2538,
        "end_line": 2552,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013631406761177754,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.validate_absolute_path#2554",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.validate_absolute_path(self, root, absolute_path)",
        "snippet": "    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n\n        ``root`` is the configured path for the `StaticFileHandler`,\n        and ``path`` is the result of `get_absolute_path`\n\n        This is an instance method called during request processing,\n        so it may raise `HTTPError` or use methods like\n        `RequestHandler.redirect` (return None after redirecting to\n        halt further processing).  This is where 404 errors for missing files\n        are generated.\n\n        This method may modify the path before returning it, but note that\n        any such modifications will not be understood by `make_static_url`.\n\n        In instance methods, this method's result is available as\n        ``self.absolute_path``.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        # os.path.abspath strips a trailing /.\n        # We must add it back to `root` so that we only match files\n        # in a directory named `root` instead of files starting with\n        # that prefix.\n        root = os.path.abspath(root)\n        if not root.endswith(os.path.sep):\n            # abspath always removes a trailing slash, except when\n            # root is '/'. This is an unusual case, but several projects\n            # have independently discovered this technique to disable\n            # Tornado's path validation and (hopefully) do their own,\n            # so we need to support it.\n            root += os.path.sep\n        # The trailing slash also needs to be temporarily added back\n        # the requested path so a request to root/ will match.\n        if not (absolute_path + os.path.sep).startswith(root):\n            raise HTTPError(403, \"%s is not in root static directory\",\n                            self.path)\n        if (os.path.isdir(absolute_path) and\n                self.default_filename is not None):\n            # need to look at the request.path here for when path is empty\n            # but there is some prefix to the path that was already\n            # trimmed by the routing\n            if not self.request.path.endswith(\"/\"):\n                self.redirect(self.request.path + \"/\", permanent=True)\n                return\n            absolute_path = os.path.join(absolute_path, self.default_filename)\n        if not os.path.exists(absolute_path):\n            raise HTTPError(404)\n        if not os.path.isfile(absolute_path):\n            raise HTTPError(403, \"%s is not a file\", self.path)\n        return absolute_path",
        "begin_line": 2554,
        "end_line": 2604,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.get_content#2607",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.get_content(cls, abspath, start=None, end=None)",
        "snippet": "    def get_content(cls, abspath, start=None, end=None):\n        \"\"\"Retrieve the content of the requested resource which is located\n        at the given absolute path.\n\n        This class method may be overridden by subclasses.  Note that its\n        signature is different from other overridable class methods\n        (no ``settings`` argument); this is deliberate to ensure that\n        ``abspath`` is able to stand on its own as a cache key.\n\n        This method should either return a byte string or an iterator\n        of byte strings.  The latter is preferred for large files\n        as it helps reduce memory fragmentation.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        with open(abspath, \"rb\") as file:\n            if start is not None:\n                file.seek(start)\n            if end is not None:\n                remaining = end - (start or 0)\n            else:\n                remaining = None\n            while True:\n                chunk_size = 64 * 1024\n                if remaining is not None and remaining < chunk_size:\n                    chunk_size = remaining\n                chunk = file.read(chunk_size)\n                if chunk:\n                    if remaining is not None:\n                        remaining -= len(chunk)\n                    yield chunk\n                else:\n                    if remaining is not None:\n                        assert remaining == 0\n                    return",
        "begin_line": 2607,
        "end_line": 2641,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001836884643644379,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.get_content_version#2644",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.get_content_version(cls, abspath)",
        "snippet": "    def get_content_version(cls, abspath):\n        \"\"\"Returns a version string for the resource at the given path.\n\n        This class method may be overridden by subclasses.  The\n        default implementation is a hash of the file's contents.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        data = cls.get_content(abspath)\n        hasher = hashlib.md5()\n        if isinstance(data, bytes):\n            hasher.update(data)\n        else:\n            for chunk in data:\n                hasher.update(chunk)\n        return hasher.hexdigest()",
        "begin_line": 2644,
        "end_line": 2659,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler._stat#2661",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler._stat(self)",
        "snippet": "    def _stat(self):\n        if not hasattr(self, '_stat_result'):\n            self._stat_result = os.stat(self.absolute_path)\n        return self._stat_result",
        "begin_line": 2661,
        "end_line": 2664,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001389274798555154,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.get_content_size#2666",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.get_content_size(self)",
        "snippet": "    def get_content_size(self):\n        \"\"\"Retrieve the total size of the resource at the given path.\n\n        This method may be overridden by subclasses.\n\n        .. versionadded:: 3.1\n\n        .. versionchanged:: 4.0\n           This method is now always called, instead of only when\n           partial results are requested.\n        \"\"\"\n        stat_result = self._stat()\n        return stat_result[stat.ST_SIZE]",
        "begin_line": 2666,
        "end_line": 2678,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013948946854512484,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.get_modified_time#2680",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.get_modified_time(self)",
        "snippet": "    def get_modified_time(self):\n        \"\"\"Returns the time that ``self.absolute_path`` was last modified.\n\n        May be overridden in subclasses.  Should return a `~datetime.datetime`\n        object or None.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        stat_result = self._stat()\n        modified = datetime.datetime.utcfromtimestamp(\n            stat_result[stat.ST_MTIME])\n        return modified",
        "begin_line": 2680,
        "end_line": 2691,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001389274798555154,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.get_content_type#2693",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.get_content_type(self)",
        "snippet": "    def get_content_type(self):\n        \"\"\"Returns the ``Content-Type`` header to be used for this request.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        mime_type, encoding = mimetypes.guess_type(self.absolute_path)\n        # per RFC 6713, use the appropriate type for a gzip compressed file\n        if encoding == \"gzip\":\n            return \"application/gzip\"\n        # As of 2015-07-21 there is no bzip2 encoding defined at\n        # http://www.iana.org/assignments/media-types/media-types.xhtml\n        # So for that (and any other encoding), use octet-stream.\n        elif encoding is not None:\n            return \"application/octet-stream\"\n        elif mime_type is not None:\n            return mime_type\n        # if mime_type not detected, use application/octet-stream\n        else:\n            return \"application/octet-stream\"",
        "begin_line": 2693,
        "end_line": 2711,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.set_extra_headers#2713",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.set_extra_headers(self, path)",
        "snippet": "    def set_extra_headers(self, path):\n        \"\"\"For subclass to add extra headers to the response\"\"\"\n        pass",
        "begin_line": 2713,
        "end_line": 2715,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001380452788514633,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.get_cache_time#2717",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.get_cache_time(self, path, modified, mime_type)",
        "snippet": "    def get_cache_time(self, path, modified, mime_type):\n        \"\"\"Override to customize cache control behavior.\n\n        Return a positive number of seconds to make the result\n        cacheable for that amount of time or 0 to mark resource as\n        cacheable for an unspecified amount of time (subject to\n        browser heuristics).\n\n        By default returns cache expiry of 10 years for resources requested\n        with ``v`` argument.\n        \"\"\"\n        return self.CACHE_MAX_AGE if \"v\" in self.request.arguments else 0",
        "begin_line": 2717,
        "end_line": 2728,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001380452788514633,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.make_static_url#2731",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.make_static_url(cls, settings, path, include_version=True)",
        "snippet": "    def make_static_url(cls, settings, path, include_version=True):\n        \"\"\"Constructs a versioned url for the given path.\n\n        This method may be overridden in subclasses (but note that it\n        is a class method rather than an instance method).  Subclasses\n        are only required to implement the signature\n        ``make_static_url(cls, settings, path)``; other keyword\n        arguments may be passed through `~RequestHandler.static_url`\n        but are not standard.\n\n        ``settings`` is the `Application.settings` dictionary.  ``path``\n        is the static path being requested.  The url returned should be\n        relative to the current host.\n\n        ``include_version`` determines whether the generated URL should\n        include the query string containing the version hash of the\n        file corresponding to the given ``path``.\n\n        \"\"\"\n        url = settings.get('static_url_prefix', '/static/') + path\n        if not include_version:\n            return url\n\n        version_hash = cls.get_version(settings, path)\n        if not version_hash:\n            return url\n\n        return '%s?v=%s' % (url, version_hash)",
        "begin_line": 2731,
        "end_line": 2758,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.parse_url_path#2760",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.parse_url_path(self, url_path)",
        "snippet": "    def parse_url_path(self, url_path):\n        \"\"\"Converts a static URL path into a filesystem path.\n\n        ``url_path`` is the path component of the URL with\n        ``static_url_prefix`` removed.  The return value should be\n        filesystem path relative to ``static_path``.\n\n        This is the inverse of `make_static_url`.\n        \"\"\"\n        if os.path.sep != \"/\":\n            url_path = url_path.replace(\"/\", os.path.sep)\n        return url_path",
        "begin_line": 2760,
        "end_line": 2771,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013749484394335213,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler.get_version#2774",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler.get_version(cls, settings, path)",
        "snippet": "    def get_version(cls, settings, path):\n        \"\"\"Generate the version string to be used in static URLs.\n\n        ``settings`` is the `Application.settings` dictionary and ``path``\n        is the relative location of the requested asset on the filesystem.\n        The returned value should be a string, or ``None`` if no version\n        could be determined.\n\n        .. versionchanged:: 3.1\n           This method was previously recommended for subclasses to override;\n           `get_content_version` is now preferred as it allows the base\n           class to handle caching of the result.\n        \"\"\"\n        abs_path = cls.get_absolute_path(settings['static_path'], path)\n        return cls._get_cached_version(abs_path)",
        "begin_line": 2774,
        "end_line": 2788,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001836884643644379,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.StaticFileHandler._get_cached_version#2791",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.StaticFileHandler",
        "signature": "tornado.web.StaticFileHandler._get_cached_version(cls, abs_path)",
        "snippet": "    def _get_cached_version(cls, abs_path):\n        with cls._lock:\n            hashes = cls._static_hashes\n            if abs_path not in hashes:\n                try:\n                    hashes[abs_path] = cls.get_content_version(abs_path)\n                except Exception:\n                    gen_log.error(\"Could not open static file %r\", abs_path)\n                    hashes[abs_path] = None\n            hsh = hashes.get(abs_path)\n            if hsh:\n                return hsh\n        return None",
        "begin_line": 2791,
        "end_line": 2803,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.GZipContentEncoding.__init__#2875",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.GZipContentEncoding",
        "signature": "tornado.web.GZipContentEncoding.__init__(self, request)",
        "snippet": "    def __init__(self, request):\n        self._gzipping = \"gzip\" in request.headers.get(\"Accept-Encoding\", \"\")",
        "begin_line": 2875,
        "end_line": 2876,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013631406761177754,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.GZipContentEncoding._compressible_type#2878",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.GZipContentEncoding",
        "signature": "tornado.web.GZipContentEncoding._compressible_type(self, ctype)",
        "snippet": "    def _compressible_type(self, ctype):\n        return ctype.startswith('text/') or ctype in self.CONTENT_TYPES",
        "begin_line": 2878,
        "end_line": 2879,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013683634373289546,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.GZipContentEncoding.transform_first_chunk#2881",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.GZipContentEncoding",
        "signature": "tornado.web.GZipContentEncoding.transform_first_chunk(self, status_code, headers, chunk, finishing)",
        "snippet": "    def transform_first_chunk(self, status_code, headers, chunk, finishing):\n        # type: (int, httputil.HTTPHeaders, bytes, bool) -> typing.Tuple[int, httputil.HTTPHeaders, bytes] # noqa: E501\n        # TODO: can/should this type be inherited from the superclass?\n        if 'Vary' in headers:\n            headers['Vary'] += ', Accept-Encoding'\n        else:\n            headers['Vary'] = 'Accept-Encoding'\n        if self._gzipping:\n            ctype = _unicode(headers.get(\"Content-Type\", \"\")).split(\";\")[0]\n            self._gzipping = self._compressible_type(ctype) and \\\n                (not finishing or len(chunk) >= self.MIN_LENGTH) and \\\n                (\"Content-Encoding\" not in headers)\n        if self._gzipping:\n            headers[\"Content-Encoding\"] = \"gzip\"\n            self._gzip_value = BytesIO()\n            self._gzip_file = gzip.GzipFile(mode=\"w\", fileobj=self._gzip_value,\n                                            compresslevel=self.GZIP_LEVEL)\n            chunk = self.transform_chunk(chunk, finishing)\n            if \"Content-Length\" in headers:\n                # The original content length is no longer correct.\n                # If this is the last (and only) chunk, we can set the new\n                # content-length; otherwise we remove it and fall back to\n                # chunked encoding.\n                if finishing:\n                    headers[\"Content-Length\"] = str(len(chunk))\n                else:\n                    del headers[\"Content-Length\"]\n        return status_code, headers, chunk",
        "begin_line": 2881,
        "end_line": 2908,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.GZipContentEncoding.transform_chunk#2910",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.GZipContentEncoding",
        "signature": "tornado.web.GZipContentEncoding.transform_chunk(self, chunk, finishing)",
        "snippet": "    def transform_chunk(self, chunk, finishing):\n        if self._gzipping:\n            self._gzip_file.write(chunk)\n            if finishing:\n                self._gzip_file.close()\n            else:\n                self._gzip_file.flush()\n            chunk = self._gzip_value.getvalue()\n            self._gzip_value.truncate(0)\n            self._gzip_value.seek(0)\n        return chunk",
        "begin_line": 2910,
        "end_line": 2920,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017528483786152498,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.authenticated#2923",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.authenticated(method)",
        "snippet": "def authenticated(method):\n    \"\"\"Decorate methods with this to require that the user be logged in.\n\n    If the user is not logged in, they will be redirected to the configured\n    `login url <RequestHandler.get_login_url>`.\n\n    If you configure a login url with a query parameter, Tornado will\n    assume you know what you're doing and use it as-is.  If not, it\n    will add a `next` parameter so the login page knows where to send\n    you once you're logged in.\n    \"\"\"\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        if not self.current_user:\n            if self.request.method in (\"GET\", \"HEAD\"):\n                url = self.get_login_url()\n                if \"?\" not in url:\n                    if urlparse.urlsplit(url).scheme:\n                        # if login url is absolute, make next absolute too\n                        next_url = self.request.full_url()\n                    else:\n                        next_url = self.request.uri\n                    url += \"?\" + urlencode(dict(next=next_url))\n                self.redirect(url)\n                return\n            raise HTTPError(403)\n        return method(self, *args, **kwargs)\n    return wrapper",
        "begin_line": 2923,
        "end_line": 2950,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.wrapper#2935",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.wrapper(self, *args, **kwargs)",
        "snippet": "    def wrapper(self, *args, **kwargs):\n        if not self.current_user:\n            if self.request.method in (\"GET\", \"HEAD\"):\n                url = self.get_login_url()\n                if \"?\" not in url:\n                    if urlparse.urlsplit(url).scheme:\n                        # if login url is absolute, make next absolute too\n                        next_url = self.request.full_url()\n                    else:\n                        next_url = self.request.uri\n                    url += \"?\" + urlencode(dict(next=next_url))\n                self.redirect(url)\n                return\n            raise HTTPError(403)\n        return method(self, *args, **kwargs)",
        "begin_line": 2935,
        "end_line": 2949,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.UIModule.__init__#2962",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.UIModule",
        "signature": "tornado.web.UIModule.__init__(self, handler)",
        "snippet": "    def __init__(self, handler):\n        self.handler = handler\n        self.request = handler.request\n        self.ui = handler.ui\n        self.locale = handler.locale",
        "begin_line": 2962,
        "end_line": 2966,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017123287671232877,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.UIModule.current_user#2969",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.UIModule",
        "signature": "tornado.web.UIModule.current_user(self)",
        "snippet": "    def current_user(self):\n        return self.handler.current_user",
        "begin_line": 2969,
        "end_line": 2970,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.UIModule.embedded_javascript#2976",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.UIModule",
        "signature": "tornado.web.UIModule.embedded_javascript(self)",
        "snippet": "    def embedded_javascript(self):\n        \"\"\"Override to return a JavaScript string\n        to be embedded in the page.\"\"\"\n        return None",
        "begin_line": 2976,
        "end_line": 2979,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.UIModule.javascript_files#2981",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.UIModule",
        "signature": "tornado.web.UIModule.javascript_files(self)",
        "snippet": "    def javascript_files(self):\n        \"\"\"Override to return a list of JavaScript files needed by this module.\n\n        If the return values are relative paths, they will be passed to\n        `RequestHandler.static_url`; otherwise they will be used as-is.\n        \"\"\"\n        return None",
        "begin_line": 2981,
        "end_line": 2987,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.UIModule.embedded_css#2989",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.UIModule",
        "signature": "tornado.web.UIModule.embedded_css(self)",
        "snippet": "    def embedded_css(self):\n        \"\"\"Override to return a CSS string\n        that will be embedded in the page.\"\"\"\n        return None",
        "begin_line": 2989,
        "end_line": 2992,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.UIModule.css_files#2994",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.UIModule",
        "signature": "tornado.web.UIModule.css_files(self)",
        "snippet": "    def css_files(self):\n        \"\"\"Override to returns a list of CSS files required by this module.\n\n        If the return values are relative paths, they will be passed to\n        `RequestHandler.static_url`; otherwise they will be used as-is.\n        \"\"\"\n        return None",
        "begin_line": 2994,
        "end_line": 3000,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.UIModule.html_head#3002",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.UIModule",
        "signature": "tornado.web.UIModule.html_head(self)",
        "snippet": "    def html_head(self):\n        \"\"\"Override to return an HTML string that will be put in the <head/>\n        element.\n        \"\"\"\n        return None",
        "begin_line": 3002,
        "end_line": 3006,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.UIModule.html_body#3008",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.UIModule",
        "signature": "tornado.web.UIModule.html_body(self)",
        "snippet": "    def html_body(self):\n        \"\"\"Override to return an HTML string that will be put at the end of\n        the <body/> element.\n        \"\"\"\n        return None",
        "begin_line": 3008,
        "end_line": 3012,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.UIModule.render_string#3014",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.UIModule",
        "signature": "tornado.web.UIModule.render_string(self, path, **kwargs)",
        "snippet": "    def render_string(self, path, **kwargs):\n        \"\"\"Renders a template and returns it as a string.\"\"\"\n        return self.handler.render_string(path, **kwargs)",
        "begin_line": 3014,
        "end_line": 3016,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web._linkify.render#3020",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._linkify",
        "signature": "tornado.web._linkify.render(self, text, **kwargs)",
        "snippet": "    def render(self, text, **kwargs):\n        return escape.linkify(text, **kwargs)",
        "begin_line": 3020,
        "end_line": 3021,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.TemplateModule.__init__#3044",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule.__init__(self, handler)",
        "snippet": "    def __init__(self, handler):\n        super(TemplateModule, self).__init__(handler)\n        # keep resources in both a list and a dict to preserve order\n        self._resource_list = []\n        self._resource_dict = {}",
        "begin_line": 3044,
        "end_line": 3048,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.TemplateModule.render#3050",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule.render(self, path, **kwargs)",
        "snippet": "    def render(self, path, **kwargs):\n        def set_resources(**kwargs):\n            if path not in self._resource_dict:\n                self._resource_list.append(kwargs)\n                self._resource_dict[path] = kwargs\n            else:\n                if self._resource_dict[path] != kwargs:\n                    raise ValueError(\"set_resources called with different \"\n                                     \"resources for the same template\")\n            return \"\"\n        return self.render_string(path, set_resources=set_resources,\n                                  **kwargs)",
        "begin_line": 3050,
        "end_line": 3061,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.TemplateModule.set_resources#3051",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule.set_resources(**kwargs)",
        "snippet": "        def set_resources(**kwargs):\n            if path not in self._resource_dict:\n                self._resource_list.append(kwargs)\n                self._resource_dict[path] = kwargs\n            else:\n                if self._resource_dict[path] != kwargs:\n                    raise ValueError(\"set_resources called with different \"\n                                     \"resources for the same template\")\n            return \"\"",
        "begin_line": 3051,
        "end_line": 3059,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.TemplateModule._get_resources#3063",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule._get_resources(self, key)",
        "snippet": "    def _get_resources(self, key):\n        return (r[key] for r in self._resource_list if key in r)",
        "begin_line": 3063,
        "end_line": 3064,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.TemplateModule.embedded_javascript#3066",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule.embedded_javascript(self)",
        "snippet": "    def embedded_javascript(self):\n        return \"\\n\".join(self._get_resources(\"embedded_javascript\"))",
        "begin_line": 3066,
        "end_line": 3067,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.TemplateModule.javascript_files#3069",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule.javascript_files(self)",
        "snippet": "    def javascript_files(self):\n        result = []\n        for f in self._get_resources(\"javascript_files\"):\n            if isinstance(f, (unicode_type, bytes)):\n                result.append(f)\n            else:\n                result.extend(f)\n        return result",
        "begin_line": 3069,
        "end_line": 3076,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.TemplateModule.embedded_css#3078",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule.embedded_css(self)",
        "snippet": "    def embedded_css(self):\n        return \"\\n\".join(self._get_resources(\"embedded_css\"))",
        "begin_line": 3078,
        "end_line": 3079,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.TemplateModule.css_files#3081",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule.css_files(self)",
        "snippet": "    def css_files(self):\n        result = []\n        for f in self._get_resources(\"css_files\"):\n            if isinstance(f, (unicode_type, bytes)):\n                result.append(f)\n            else:\n                result.extend(f)\n        return result",
        "begin_line": 3081,
        "end_line": 3088,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.TemplateModule.html_head#3090",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule.html_head(self)",
        "snippet": "    def html_head(self):\n        return \"\".join(self._get_resources(\"html_head\"))",
        "begin_line": 3090,
        "end_line": 3091,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.TemplateModule.html_body#3093",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web.TemplateModule",
        "signature": "tornado.web.TemplateModule.html_body(self)",
        "snippet": "    def html_body(self):\n        return \"\".join(self._get_resources(\"html_body\"))",
        "begin_line": 3093,
        "end_line": 3094,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web._UIModuleNamespace.__init__#3099",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._UIModuleNamespace",
        "signature": "tornado.web._UIModuleNamespace.__init__(self, handler, ui_modules)",
        "snippet": "    def __init__(self, handler, ui_modules):\n        self.handler = handler\n        self.ui_modules = ui_modules",
        "begin_line": 3099,
        "end_line": 3101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00044583147570218456,
            "pseudo_dstar_susp": 0.000514668039114771,
            "pseudo_tarantula_susp": 0.0004351610095735422,
            "pseudo_op2_susp": 0.000514668039114771,
            "pseudo_barinel_susp": 0.0004351610095735422
        }
    },
    {
        "name": "tornado.web._UIModuleNamespace.__getitem__#3103",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._UIModuleNamespace",
        "signature": "tornado.web._UIModuleNamespace.__getitem__(self, key)",
        "snippet": "    def __getitem__(self, key):\n        return self.handler._ui_module(key, self.ui_modules[key])",
        "begin_line": 3103,
        "end_line": 3104,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017123287671232877,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web._UIModuleNamespace.__getattr__#3106",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web._UIModuleNamespace",
        "signature": "tornado.web._UIModuleNamespace.__getattr__(self, key)",
        "snippet": "    def __getattr__(self, key):\n        try:\n            return self[key]\n        except KeyError as e:\n            raise AttributeError(str(e))",
        "begin_line": 3106,
        "end_line": 3110,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017123287671232877,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.create_signed_value#3129",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.create_signed_value(secret, name, value, version=None, clock=None, key_version=None)",
        "snippet": "def create_signed_value(secret, name, value, version=None, clock=None,\n                        key_version=None):\n    if version is None:\n        version = DEFAULT_SIGNED_VALUE_VERSION\n    if clock is None:\n        clock = time.time\n\n    timestamp = utf8(str(int(clock())))\n    value = base64.b64encode(utf8(value))\n    if version == 1:\n        signature = _create_signature_v1(secret, name, value, timestamp)\n        value = b\"|\".join([value, timestamp, signature])\n        return value\n    elif version == 2:\n        # The v2 format consists of a version number and a series of\n        # length-prefixed fields \"%d:%s\", the last of which is a\n        # signature, all separated by pipes.  All numbers are in\n        # decimal format with no leading zeros.  The signature is an\n        # HMAC-SHA256 of the whole string up to that point, including\n        # the final pipe.\n        #\n        # The fields are:\n        # - format version (i.e. 2; no length prefix)\n        # - key version (integer, default is 0)\n        # - timestamp (integer seconds since epoch)\n        # - name (not encoded; assumed to be ~alphanumeric)\n        # - value (base64-encoded)\n        # - signature (hex-encoded; no length prefix)\n        def format_field(s):\n            return utf8(\"%d:\" % len(s)) + utf8(s)\n        to_sign = b\"|\".join([\n            b\"2\",\n            format_field(str(key_version or 0)),\n            format_field(timestamp),\n            format_field(name),\n            format_field(value),\n            b''])\n\n        if isinstance(secret, dict):\n            assert key_version is not None, 'Key version must be set when sign key dict is used'\n            assert version >= 2, 'Version must be at least 2 for key version support'\n            secret = secret[key_version]\n\n        signature = _create_signature_v2(secret, to_sign)\n        return to_sign + signature\n    else:\n        raise ValueError(\"Unsupported version %d\" % version)",
        "begin_line": 3129,
        "end_line": 3175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.format_field#3157",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.format_field(s)",
        "snippet": "        def format_field(s):\n            return utf8(\"%d:\" % len(s)) + utf8(s)",
        "begin_line": 3157,
        "end_line": 3158,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016983695652173913,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web._get_version#3183",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web._get_version(value)",
        "snippet": "def _get_version(value):\n    # Figures out what version value is.  Version 1 did not include an\n    # explicit version field and started with arbitrary base64 data,\n    # which makes this tricky.\n    m = _signed_value_version_re.match(value)\n    if m is None:\n        version = 1\n    else:\n        try:\n            version = int(m.group(1))\n            if version > 999:\n                # Certain payloads from the version-less v1 format may\n                # be parsed as valid integers.  Due to base64 padding\n                # restrictions, this can only happen for numbers whose\n                # length is a multiple of 4, so we can treat all\n                # numbers up to 999 as versions, and for the rest we\n                # fall back to v1 format.\n                version = 1\n        except ValueError:\n            version = 1\n    return version",
        "begin_line": 3183,
        "end_line": 3203,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.decode_signed_value#3206",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.decode_signed_value(secret, name, value, max_age_days=31, clock=None, min_version=None)",
        "snippet": "def decode_signed_value(secret, name, value, max_age_days=31,\n                        clock=None, min_version=None):\n    if clock is None:\n        clock = time.time\n    if min_version is None:\n        min_version = DEFAULT_SIGNED_VALUE_MIN_VERSION\n    if min_version > 2:\n        raise ValueError(\"Unsupported min_version %d\" % min_version)\n    if not value:\n        return None\n\n    value = utf8(value)\n    version = _get_version(value)\n\n    if version < min_version:\n        return None\n    if version == 1:\n        return _decode_signed_value_v1(secret, name, value,\n                                       max_age_days, clock)\n    elif version == 2:\n        return _decode_signed_value_v2(secret, name, value,\n                                       max_age_days, clock)\n    else:\n        return None",
        "begin_line": 3206,
        "end_line": 3229,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web._decode_signed_value_v1#3232",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web._decode_signed_value_v1(secret, name, value, max_age_days, clock)",
        "snippet": "def _decode_signed_value_v1(secret, name, value, max_age_days, clock):\n    parts = utf8(value).split(b\"|\")\n    if len(parts) != 3:\n        return None\n    signature = _create_signature_v1(secret, name, parts[0], parts[1])\n    if not _time_independent_equals(parts[2], signature):\n        gen_log.warning(\"Invalid cookie signature %r\", value)\n        return None\n    timestamp = int(parts[1])\n    if timestamp < clock() - max_age_days * 86400:\n        gen_log.warning(\"Expired cookie %r\", value)\n        return None\n    if timestamp > clock() + 31 * 86400:\n        # _cookie_signature does not hash a delimiter between the\n        # parts of the cookie, so an attacker could transfer trailing\n        # digits from the payload to the timestamp without altering the\n        # signature.  For backwards compatibility, sanity-check timestamp\n        # here instead of modifying _cookie_signature.\n        gen_log.warning(\"Cookie timestamp in future; possible tampering %r\",\n                        value)\n        return None\n    if parts[1].startswith(b\"0\"):\n        gen_log.warning(\"Tampered cookie %r\", value)\n        return None\n    try:\n        return base64.b64decode(parts[0])\n    except Exception:\n        return None",
        "begin_line": 3232,
        "end_line": 3259,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web._decode_fields_v2#3262",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web._decode_fields_v2(value)",
        "snippet": "def _decode_fields_v2(value):\n    def _consume_field(s):\n        length, _, rest = s.partition(b':')\n        n = int(length)\n        field_value = rest[:n]\n        # In python 3, indexing bytes returns small integers; we must\n        # use a slice to get a byte string as in python 2.\n        if rest[n:n + 1] != b'|':\n            raise ValueError(\"malformed v2 signed value field\")\n        rest = rest[n + 1:]\n        return field_value, rest\n\n    rest = value[2:]  # remove version number\n    key_version, rest = _consume_field(rest)\n    timestamp, rest = _consume_field(rest)\n    name_field, rest = _consume_field(rest)\n    value_field, passed_sig = _consume_field(rest)\n    return int(key_version), timestamp, name_field, value_field, passed_sig",
        "begin_line": 3262,
        "end_line": 3279,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001677008217340265,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web._consume_field#3263",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web._consume_field(s)",
        "snippet": "    def _consume_field(s):\n        length, _, rest = s.partition(b':')\n        n = int(length)\n        field_value = rest[:n]\n        # In python 3, indexing bytes returns small integers; we must\n        # use a slice to get a byte string as in python 2.\n        if rest[n:n + 1] != b'|':\n            raise ValueError(\"malformed v2 signed value field\")\n        rest = rest[n + 1:]\n        return field_value, rest",
        "begin_line": 3263,
        "end_line": 3272,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web._decode_signed_value_v2#3282",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web._decode_signed_value_v2(secret, name, value, max_age_days, clock)",
        "snippet": "def _decode_signed_value_v2(secret, name, value, max_age_days, clock):\n    try:\n        key_version, timestamp, name_field, value_field, passed_sig = _decode_fields_v2(value)\n    except ValueError:\n        return None\n    signed_string = value[:-len(passed_sig)]\n\n    if isinstance(secret, dict):\n        try:\n            secret = secret[key_version]\n        except KeyError:\n            return None\n\n    expected_sig = _create_signature_v2(secret, signed_string)\n    if not _time_independent_equals(passed_sig, expected_sig):\n        return None\n    if name_field != utf8(name):\n        return None\n    timestamp = int(timestamp)\n    if timestamp < clock() - max_age_days * 86400:\n        # The signature has expired.\n        return None\n    try:\n        return base64.b64decode(value_field)\n    except Exception:\n        return None",
        "begin_line": 3282,
        "end_line": 3307,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.get_signature_key_version#3310",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.get_signature_key_version(value)",
        "snippet": "def get_signature_key_version(value):\n    value = utf8(value)\n    version = _get_version(value)\n    if version < 2:\n        return None\n    try:\n        key_version, _, _, _, _ = _decode_fields_v2(value)\n    except ValueError:\n        return None\n\n    return key_version",
        "begin_line": 3310,
        "end_line": 3320,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web._create_signature_v1#3323",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web._create_signature_v1(secret, *parts)",
        "snippet": "def _create_signature_v1(secret, *parts):\n    hash = hmac.new(utf8(secret), digestmod=hashlib.sha1)\n    for part in parts:\n        hash.update(utf8(part))\n    return utf8(hash.hexdigest())",
        "begin_line": 3323,
        "end_line": 3327,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web._create_signature_v2#3330",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web._create_signature_v2(secret, s)",
        "snippet": "def _create_signature_v2(secret, s):\n    hash = hmac.new(utf8(secret), digestmod=hashlib.sha256)\n    hash.update(utf8(s))\n    return utf8(hash.hexdigest())",
        "begin_line": 3330,
        "end_line": 3333,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001677008217340265,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.web.is_absolute#3336",
        "src_path": "tornado/web.py",
        "class_name": "tornado.web",
        "signature": "tornado.web.is_absolute(path)",
        "snippet": "def is_absolute(path):\n    return any(path.startswith(x) for x in [\"/\", \"http:\", \"https:\"])",
        "begin_line": 3336,
        "end_line": 3337,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.wsgi.to_wsgi_str#56",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi",
        "signature": "tornado.wsgi.to_wsgi_str(s)",
        "snippet": "    def to_wsgi_str(s):\n        assert isinstance(s, bytes)\n        return s.decode('latin1')",
        "begin_line": 56,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001325556733828208,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.wsgi.from_wsgi_str#60",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi",
        "signature": "tornado.wsgi.from_wsgi_str(s)",
        "snippet": "    def from_wsgi_str(s):\n        assert isinstance(s, str)\n        return s.encode('latin1')",
        "begin_line": 60,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013335111348179759,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.wsgi.WSGIApplication.__call__#80",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi.WSGIApplication",
        "signature": "tornado.wsgi.WSGIApplication.__call__(self, environ, start_response)",
        "snippet": "    def __call__(self, environ, start_response):\n        return WSGIAdapter(self)(environ, start_response)",
        "begin_line": 80,
        "end_line": 81,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013500742540839745,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.wsgi._WSGIConnection.__init__#91",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi._WSGIConnection",
        "signature": "tornado.wsgi._WSGIConnection.__init__(self, method, start_response, context)",
        "snippet": "    def __init__(self, method, start_response, context):\n        self.method = method\n        self.start_response = start_response\n        self.context = context\n        self._write_buffer = []\n        self._finished = False\n        self._expected_content_remaining = None\n        self._error = None",
        "begin_line": 91,
        "end_line": 98,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013335111348179759,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.wsgi._WSGIConnection.set_close_callback#100",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi._WSGIConnection",
        "signature": "tornado.wsgi._WSGIConnection.set_close_callback(self, callback)",
        "snippet": "    def set_close_callback(self, callback):\n        # WSGI has no facility for detecting a closed connection mid-request,\n        # so we can simply ignore the callback.\n        pass",
        "begin_line": 100,
        "end_line": 103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013335111348179759,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.wsgi._WSGIConnection.write_headers#105",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi._WSGIConnection",
        "signature": "tornado.wsgi._WSGIConnection.write_headers(self, start_line, headers, chunk=None, callback=None)",
        "snippet": "    def write_headers(self, start_line, headers, chunk=None, callback=None):\n        if self.method == 'HEAD':\n            self._expected_content_remaining = 0\n        elif 'Content-Length' in headers:\n            self._expected_content_remaining = int(headers['Content-Length'])\n        else:\n            self._expected_content_remaining = None\n        self.start_response(\n            '%s %s' % (start_line.code, start_line.reason),\n            [(native_str(k), native_str(v)) for (k, v) in headers.get_all()])\n        if chunk is not None:\n            self.write(chunk, callback)\n        elif callback is not None:\n            callback()\n        return _dummy_future",
        "begin_line": 105,
        "end_line": 119,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016095284081764043,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.wsgi._WSGIConnection.write#121",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi._WSGIConnection",
        "signature": "tornado.wsgi._WSGIConnection.write(self, chunk, callback=None)",
        "snippet": "    def write(self, chunk, callback=None):\n        if self._expected_content_remaining is not None:\n            self._expected_content_remaining -= len(chunk)\n            if self._expected_content_remaining < 0:\n                self._error = httputil.HTTPOutputError(\n                    \"Tried to write more data than Content-Length\")\n                raise self._error\n        self._write_buffer.append(chunk)\n        if callback is not None:\n            callback()\n        return _dummy_future",
        "begin_line": 121,
        "end_line": 131,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.wsgi._WSGIConnection.finish#133",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi._WSGIConnection",
        "signature": "tornado.wsgi._WSGIConnection.finish(self)",
        "snippet": "    def finish(self):\n        if (self._expected_content_remaining is not None and\n                self._expected_content_remaining != 0):\n            self._error = httputil.HTTPOutputError(\n                \"Tried to write %d bytes less than Content-Length\" %\n                self._expected_content_remaining)\n            raise self._error\n        self._finished = True",
        "begin_line": 133,
        "end_line": 140,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.wsgi._WSGIRequestContext.__init__#144",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi._WSGIRequestContext",
        "signature": "tornado.wsgi._WSGIRequestContext.__init__(self, remote_ip, protocol)",
        "snippet": "    def __init__(self, remote_ip, protocol):\n        self.remote_ip = remote_ip\n        self.protocol = protocol",
        "begin_line": 144,
        "end_line": 146,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013335111348179759,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.wsgi.WSGIAdapter.__init__#184",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi.WSGIAdapter",
        "signature": "tornado.wsgi.WSGIAdapter.__init__(self, application)",
        "snippet": "    def __init__(self, application):\n        if isinstance(application, WSGIApplication):\n            self.application = lambda request: web.Application.__call__(\n                application, request)\n        else:\n            self.application = application",
        "begin_line": 184,
        "end_line": 189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013508037282182898,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.wsgi.WSGIAdapter.__call__#191",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi.WSGIAdapter",
        "signature": "tornado.wsgi.WSGIAdapter.__call__(self, environ, start_response)",
        "snippet": "    def __call__(self, environ, start_response):\n        method = environ[\"REQUEST_METHOD\"]\n        uri = urllib_parse.quote(from_wsgi_str(environ.get(\"SCRIPT_NAME\", \"\")))\n        uri += urllib_parse.quote(from_wsgi_str(environ.get(\"PATH_INFO\", \"\")))\n        if environ.get(\"QUERY_STRING\"):\n            uri += \"?\" + environ[\"QUERY_STRING\"]\n        headers = httputil.HTTPHeaders()\n        if environ.get(\"CONTENT_TYPE\"):\n            headers[\"Content-Type\"] = environ[\"CONTENT_TYPE\"]\n        if environ.get(\"CONTENT_LENGTH\"):\n            headers[\"Content-Length\"] = environ[\"CONTENT_LENGTH\"]\n        for key in environ:\n            if key.startswith(\"HTTP_\"):\n                headers[key[5:].replace(\"_\", \"-\")] = environ[key]\n        if headers.get(\"Content-Length\"):\n            body = environ[\"wsgi.input\"].read(\n                int(headers[\"Content-Length\"]))\n        else:\n            body = b\"\"\n        protocol = environ[\"wsgi.url_scheme\"]\n        remote_ip = environ.get(\"REMOTE_ADDR\", \"\")\n        if environ.get(\"HTTP_HOST\"):\n            host = environ[\"HTTP_HOST\"]\n        else:\n            host = environ[\"SERVER_NAME\"]\n        connection = _WSGIConnection(method, start_response,\n                                     _WSGIRequestContext(remote_ip, protocol))\n        request = httputil.HTTPServerRequest(\n            method, uri, \"HTTP/1.1\", headers=headers, body=body,\n            host=host, connection=connection)\n        request._parse_body()\n        self.application(request)\n        if connection._error:\n            raise connection._error\n        if not connection._finished:\n            raise Exception(\"request did not finish synchronously\")\n        return connection._write_buffer",
        "begin_line": 191,
        "end_line": 227,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.wsgi.WSGIContainer.__init__#264",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi.WSGIContainer",
        "signature": "tornado.wsgi.WSGIContainer.__init__(self, wsgi_application)",
        "snippet": "    def __init__(self, wsgi_application):\n        self.wsgi_application = wsgi_application",
        "begin_line": 264,
        "end_line": 265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013192612137203166,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.wsgi.WSGIContainer.__call__#267",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi.WSGIContainer",
        "signature": "tornado.wsgi.WSGIContainer.__call__(self, request)",
        "snippet": "    def __call__(self, request):\n        data = {}\n        response = []\n\n        def start_response(status, response_headers, exc_info=None):\n            data[\"status\"] = status\n            data[\"headers\"] = response_headers\n            return response.append\n        app_response = self.wsgi_application(\n            WSGIContainer.environ(request), start_response)\n        try:\n            response.extend(app_response)\n            body = b\"\".join(response)\n        finally:\n            if hasattr(app_response, \"close\"):\n                app_response.close()\n        if not data:\n            raise Exception(\"WSGI app did not call start_response\")\n\n        status_code, reason = data[\"status\"].split(' ', 1)\n        status_code = int(status_code)\n        headers = data[\"headers\"]\n        header_set = set(k.lower() for (k, v) in headers)\n        body = escape.utf8(body)\n        if status_code != 304:\n            if \"content-length\" not in header_set:\n                headers.append((\"Content-Length\", str(len(body))))\n            if \"content-type\" not in header_set:\n                headers.append((\"Content-Type\", \"text/html; charset=UTF-8\"))\n        if \"server\" not in header_set:\n            headers.append((\"Server\", \"TornadoServer/%s\" % tornado.version))\n\n        start_line = httputil.ResponseStartLine(\"HTTP/1.1\", status_code, reason)\n        header_obj = httputil.HTTPHeaders()\n        for key, value in headers:\n            header_obj.add(key, value)\n        request.connection.write_headers(start_line, header_obj, chunk=body)\n        request.connection.finish()\n        self._log(status_code, request)",
        "begin_line": 267,
        "end_line": 305,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.wsgi.WSGIContainer.start_response#271",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi.WSGIContainer",
        "signature": "tornado.wsgi.WSGIContainer.start_response(status, response_headers, exc_info=None)",
        "snippet": "        def start_response(status, response_headers, exc_info=None):\n            data[\"status\"] = status\n            data[\"headers\"] = response_headers\n            return response.append",
        "begin_line": 271,
        "end_line": 274,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001325556733828208,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.wsgi.WSGIContainer.environ#308",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi.WSGIContainer",
        "signature": "tornado.wsgi.WSGIContainer.environ(request)",
        "snippet": "    def environ(request):\n        \"\"\"Converts a `tornado.httputil.HTTPServerRequest` to a WSGI environment.\n        \"\"\"\n        hostport = request.host.split(\":\")\n        if len(hostport) == 2:\n            host = hostport[0]\n            port = int(hostport[1])\n        else:\n            host = request.host\n            port = 443 if request.protocol == \"https\" else 80\n        environ = {\n            \"REQUEST_METHOD\": request.method,\n            \"SCRIPT_NAME\": \"\",\n            \"PATH_INFO\": to_wsgi_str(escape.url_unescape(\n                request.path, encoding=None, plus=False)),\n            \"QUERY_STRING\": request.query,\n            \"REMOTE_ADDR\": request.remote_ip,\n            \"SERVER_NAME\": host,\n            \"SERVER_PORT\": str(port),\n            \"SERVER_PROTOCOL\": request.version,\n            \"wsgi.version\": (1, 0),\n            \"wsgi.url_scheme\": request.protocol,\n            \"wsgi.input\": BytesIO(escape.utf8(request.body)),\n            \"wsgi.errors\": sys.stderr,\n            \"wsgi.multithread\": False,\n            \"wsgi.multiprocess\": True,\n            \"wsgi.run_once\": False,\n        }\n        if \"Content-Type\" in request.headers:\n            environ[\"CONTENT_TYPE\"] = request.headers.pop(\"Content-Type\")\n        if \"Content-Length\" in request.headers:\n            environ[\"CONTENT_LENGTH\"] = request.headers.pop(\"Content-Length\")\n        for key, value in request.headers.items():\n            environ[\"HTTP_\" + key.replace(\"-\", \"_\").upper()] = value\n        return environ",
        "begin_line": 308,
        "end_line": 342,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.wsgi.WSGIContainer._log#344",
        "src_path": "tornado/wsgi.py",
        "class_name": "tornado.wsgi.WSGIContainer",
        "signature": "tornado.wsgi.WSGIContainer._log(self, status_code, request)",
        "snippet": "    def _log(self, status_code, request):\n        if status_code < 400:\n            log_method = access_log.info\n        elif status_code < 500:\n            log_method = access_log.warning\n        else:\n            log_method = access_log.error\n        request_time = 1000.0 * request.request_time()\n        summary = request.method + \" \" + request.uri + \" (\" + \\\n            request.remote_ip + \")\"\n        log_method(\"%d %s %.2fms\", status_code, summary, request_time)",
        "begin_line": 344,
        "end_line": 354,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017295053614666206,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.log._safe_unicode#73",
        "src_path": "tornado/log.py",
        "class_name": "tornado.log",
        "signature": "tornado.log._safe_unicode(s)",
        "snippet": "def _safe_unicode(s):\n    try:\n        return _unicode(s)\n    except UnicodeDecodeError:\n        return repr(s)",
        "begin_line": 73,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001775568181818182,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.log.LogFormatter.__init__#114",
        "src_path": "tornado/log.py",
        "class_name": "tornado.log.LogFormatter",
        "signature": "tornado.log.LogFormatter.__init__(self, fmt=DEFAULT_FORMAT, datefmt=DEFAULT_DATE_FORMAT, style='%', color=True, colors=DEFAULT_COLORS)",
        "snippet": "    def __init__(self, fmt=DEFAULT_FORMAT, datefmt=DEFAULT_DATE_FORMAT,\n                 style='%', color=True, colors=DEFAULT_COLORS):\n        r\"\"\"\n        :arg bool color: Enables color support.\n        :arg str fmt: Log message format.\n          It will be applied to the attributes dict of log records. The\n          text between ``%(color)s`` and ``%(end_color)s`` will be colored\n          depending on the level if color support is on.\n        :arg dict colors: color mappings from logging level to terminal color\n          code\n        :arg str datefmt: Datetime format.\n          Used for formatting ``(asctime)`` placeholder in ``prefix_fmt``.\n\n        .. versionchanged:: 3.2\n\n           Added ``fmt`` and ``datefmt`` arguments.\n        \"\"\"\n        logging.Formatter.__init__(self, datefmt=datefmt)\n        self._fmt = fmt\n\n        self._colors = {}\n        if color and _stderr_supports_color():\n            if curses is not None:\n                # The curses module has some str/bytes confusion in\n                # python3.  Until version 3.2.3, most methods return\n                # bytes, but only accept strings.  In addition, we want to\n                # output these strings with the logging module, which\n                # works with unicode strings.  The explicit calls to\n                # unicode() below are harmless in python2 but will do the\n                # right conversion in python 3.\n                fg_color = (curses.tigetstr(\"setaf\") or\n                            curses.tigetstr(\"setf\") or \"\")\n                if (3, 0) < sys.version_info < (3, 2, 3):\n                    fg_color = unicode_type(fg_color, \"ascii\")\n\n                for levelno, code in colors.items():\n                    self._colors[levelno] = unicode_type(curses.tparm(fg_color, code), \"ascii\")\n                self._normal = unicode_type(curses.tigetstr(\"sgr0\"), \"ascii\")\n            else:\n                # If curses is not present (currently we'll only get here for\n                # colorama on windows), assume hard-coded ANSI color codes.\n                for levelno, code in colors.items():\n                    self._colors[levelno] = '\\033[2;3%dm' % code\n                self._normal = '\\033[0m'\n        else:\n            self._normal = ''",
        "begin_line": 114,
        "end_line": 159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001775568181818182,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.log.LogFormatter.format#161",
        "src_path": "tornado/log.py",
        "class_name": "tornado.log.LogFormatter",
        "signature": "tornado.log.LogFormatter.format(self, record)",
        "snippet": "    def format(self, record):\n        try:\n            message = record.getMessage()\n            assert isinstance(message, basestring_type)  # guaranteed by logging\n            # Encoding notes:  The logging module prefers to work with character\n            # strings, but only enforces that log messages are instances of\n            # basestring.  In python 2, non-ascii bytestrings will make\n            # their way through the logging framework until they blow up with\n            # an unhelpful decoding error (with this formatter it happens\n            # when we attach the prefix, but there are other opportunities for\n            # exceptions further along in the framework).\n            #\n            # If a byte string makes it this far, convert it to unicode to\n            # ensure it will make it out to the logs.  Use repr() as a fallback\n            # to ensure that all byte strings can be converted successfully,\n            # but don't do it by default so we don't add extra quotes to ascii\n            # bytestrings.  This is a bit of a hacky place to do this, but\n            # it's worth it since the encoding errors that would otherwise\n            # result are so useless (and tornado is fond of using utf8-encoded\n            # byte strings wherever possible).\n            record.message = _safe_unicode(message)\n        except Exception as e:\n            record.message = \"Bad message (%r): %r\" % (e, record.__dict__)\n\n        record.asctime = self.formatTime(record, self.datefmt)\n\n        if record.levelno in self._colors:\n            record.color = self._colors[record.levelno]\n            record.end_color = self._normal\n        else:\n            record.color = record.end_color = ''\n\n        formatted = self._fmt % record.__dict__\n\n        if record.exc_info:\n            if not record.exc_text:\n                record.exc_text = self.formatException(record.exc_info)\n        if record.exc_text:\n            # exc_text contains multiple lines.  We need to _safe_unicode\n            # each line separately so that non-utf8 bytes don't cause\n            # all the newlines to turn into '\\n'.\n            lines = [formatted.rstrip()]\n            lines.extend(_safe_unicode(ln) for ln in record.exc_text.split('\\n'))\n            formatted = '\\n'.join(lines)\n        return formatted.replace(\"\\n\", \"\\n    \")",
        "begin_line": 161,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.log.enable_pretty_logging#208",
        "src_path": "tornado/log.py",
        "class_name": "tornado.log",
        "signature": "tornado.log.enable_pretty_logging(options=None, logger=None)",
        "snippet": "def enable_pretty_logging(options=None, logger=None):\n    \"\"\"Turns on formatted logging output as configured.\n\n    This is called automatically by `tornado.options.parse_command_line`\n    and `tornado.options.parse_config_file`.\n    \"\"\"\n    if options is None:\n        import tornado.options\n        options = tornado.options.options\n    if options.logging is None or options.logging.lower() == 'none':\n        return\n    if logger is None:\n        logger = logging.getLogger()\n    logger.setLevel(getattr(logging, options.logging.upper()))\n    if options.log_file_prefix:\n        rotate_mode = options.log_rotate_mode\n        if rotate_mode == 'size':\n            channel = logging.handlers.RotatingFileHandler(\n                filename=options.log_file_prefix,\n                maxBytes=options.log_file_max_size,\n                backupCount=options.log_file_num_backups)\n        elif rotate_mode == 'time':\n            channel = logging.handlers.TimedRotatingFileHandler(\n                filename=options.log_file_prefix,\n                when=options.log_rotate_when,\n                interval=options.log_rotate_interval,\n                backupCount=options.log_file_num_backups)\n        else:\n            error_message = 'The value of log_rotate_mode option should be ' +\\\n                            '\"size\" or \"time\", not \"%s\".' % rotate_mode\n            raise ValueError(error_message)\n        channel.setFormatter(LogFormatter(color=False))\n        logger.addHandler(channel)\n\n    if (options.log_to_stderr or\n            (options.log_to_stderr is None and not logger.handlers)):\n        # Set up color if we are in a tty and curses is installed\n        channel = logging.StreamHandler()\n        channel.setFormatter(LogFormatter())\n        logger.addHandler(channel)",
        "begin_line": 208,
        "end_line": 247,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.log.define_logging_options#250",
        "src_path": "tornado/log.py",
        "class_name": "tornado.log",
        "signature": "tornado.log.define_logging_options(options=None)",
        "snippet": "def define_logging_options(options=None):\n    \"\"\"Add logging-related flags to ``options``.\n\n    These options are present automatically on the default options instance;\n    this method is only necessary if you have created your own `.OptionParser`.\n\n    .. versionadded:: 4.2\n        This function existed in prior versions but was broken and undocumented until 4.2.\n    \"\"\"\n    if options is None:\n        # late import to prevent cycle\n        import tornado.options\n        options = tornado.options.options\n    options.define(\"logging\", default=\"info\",\n                   help=(\"Set the Python log level. If 'none', tornado won't touch the \"\n                         \"logging configuration.\"),\n                   metavar=\"debug|info|warning|error|none\")\n    options.define(\"log_to_stderr\", type=bool, default=None,\n                   help=(\"Send log output to stderr (colorized if possible). \"\n                         \"By default use stderr if --log_file_prefix is not set and \"\n                         \"no other logging is configured.\"))\n    options.define(\"log_file_prefix\", type=str, default=None, metavar=\"PATH\",\n                   help=(\"Path prefix for log files. \"\n                         \"Note that if you are running multiple tornado processes, \"\n                         \"log_file_prefix must be different for each of them (e.g. \"\n                         \"include the port number)\"))\n    options.define(\"log_file_max_size\", type=int, default=100 * 1000 * 1000,\n                   help=\"max size of log files before rollover\")\n    options.define(\"log_file_num_backups\", type=int, default=10,\n                   help=\"number of log files to keep\")\n\n    options.define(\"log_rotate_when\", type=str, default='midnight',\n                   help=(\"specify the type of TimedRotatingFileHandler interval \"\n                         \"other options:('S', 'M', 'H', 'D', 'W0'-'W6')\"))\n    options.define(\"log_rotate_interval\", type=int, default=1,\n                   help=\"The interval value of timed rotating\")\n\n    options.define(\"log_rotate_mode\", type=str, default='size',\n                   help=\"The mode of rotating files(time or size)\")\n\n    options.add_parse_callback(lambda: enable_pretty_logging(options))",
        "begin_line": 250,
        "end_line": 290,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.tcpserver.TCPServer.__init__#108",
        "src_path": "tornado/tcpserver.py",
        "class_name": "tornado.tcpserver.TCPServer",
        "signature": "tornado.tcpserver.TCPServer.__init__(self, ssl_options=None, max_buffer_size=None, read_chunk_size=None)",
        "snippet": "    def __init__(self, ssl_options=None, max_buffer_size=None,\n                 read_chunk_size=None):\n        self.ssl_options = ssl_options\n        self._sockets = {}   # fd -> socket object\n        self._handlers = {}  # fd -> remove_handler callable\n        self._pending_sockets = []\n        self._started = False\n        self._stopped = False\n        self.max_buffer_size = max_buffer_size\n        self.read_chunk_size = read_chunk_size\n\n        # Verify the SSL options. Otherwise we don't get errors until clients\n        # connect. This doesn't verify that the keys are legitimate, but\n        # the SSL module doesn't do that until there is a connected socket\n        # which seems like too much work\n        if self.ssl_options is not None and isinstance(self.ssl_options, dict):\n            # Only certfile is required: it can contain both keys\n            if 'certfile' not in self.ssl_options:\n                raise KeyError('missing key \"certfile\" in ssl_options')\n\n            if not os.path.exists(self.ssl_options['certfile']):\n                raise ValueError('certfile \"%s\" does not exist' %\n                                 self.ssl_options['certfile'])\n            if ('keyfile' in self.ssl_options and\n                    not os.path.exists(self.ssl_options['keyfile'])):\n                raise ValueError('keyfile \"%s\" does not exist' %\n                                 self.ssl_options['keyfile'])",
        "begin_line": 108,
        "end_line": 134,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008403361344537815,
            "pseudo_dstar_susp": 0.002061855670103093,
            "pseudo_tarantula_susp": 0.006756756756756757,
            "pseudo_op2_susp": 0.002061855670103093,
            "pseudo_barinel_susp": 0.006756756756756757
        }
    },
    {
        "name": "tornado.tcpserver.TCPServer.listen#136",
        "src_path": "tornado/tcpserver.py",
        "class_name": "tornado.tcpserver.TCPServer",
        "signature": "tornado.tcpserver.TCPServer.listen(self, port, address='')",
        "snippet": "    def listen(self, port, address=\"\"):\n        \"\"\"Starts accepting connections on the given port.\n\n        This method may be called more than once to listen on multiple ports.\n        `listen` takes effect immediately; it is not necessary to call\n        `TCPServer.start` afterwards.  It is, however, necessary to start\n        the `.IOLoop`.\n        \"\"\"\n        sockets = bind_sockets(port, address=address)\n        self.add_sockets(sockets)",
        "begin_line": 136,
        "end_line": 145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.tcpserver.TCPServer.add_sockets#147",
        "src_path": "tornado/tcpserver.py",
        "class_name": "tornado.tcpserver.TCPServer",
        "signature": "tornado.tcpserver.TCPServer.add_sockets(self, sockets)",
        "snippet": "    def add_sockets(self, sockets):\n        \"\"\"Makes this server start accepting connections on the given sockets.\n\n        The ``sockets`` parameter is a list of socket objects such as\n        those returned by `~tornado.netutil.bind_sockets`.\n        `add_sockets` is typically used in combination with that\n        method and `tornado.process.fork_processes` to provide greater\n        control over the initialization of a multi-process server.\n        \"\"\"\n        for sock in sockets:\n            self._sockets[sock.fileno()] = sock\n            self._handlers[sock.fileno()] = add_accept_handler(\n                sock, self._handle_connection)",
        "begin_line": 147,
        "end_line": 159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016233766233766235,
            "pseudo_dstar_susp": 0.00199203187250996,
            "pseudo_tarantula_susp": 0.0010964912280701754,
            "pseudo_op2_susp": 0.00199203187250996,
            "pseudo_barinel_susp": 0.0010964912280701754
        }
    },
    {
        "name": "tornado.tcpserver.TCPServer.add_socket#161",
        "src_path": "tornado/tcpserver.py",
        "class_name": "tornado.tcpserver.TCPServer",
        "signature": "tornado.tcpserver.TCPServer.add_socket(self, socket)",
        "snippet": "    def add_socket(self, socket):\n        \"\"\"Singular version of `add_sockets`.  Takes a single socket object.\"\"\"\n        self.add_sockets([socket])",
        "begin_line": 161,
        "end_line": 163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008726003490401396,
            "pseudo_dstar_susp": 0.0005065856129685917,
            "pseudo_tarantula_susp": 0.0035211267605633804,
            "pseudo_op2_susp": 0.0005065856129685917,
            "pseudo_barinel_susp": 0.0035211267605633804
        }
    },
    {
        "name": "tornado.tcpserver.TCPServer.stop#225",
        "src_path": "tornado/tcpserver.py",
        "class_name": "tornado.tcpserver.TCPServer",
        "signature": "tornado.tcpserver.TCPServer.stop(self)",
        "snippet": "    def stop(self):\n        \"\"\"Stops listening for new connections.\n\n        Requests currently in progress may still continue after the\n        server is stopped.\n        \"\"\"\n        if self._stopped:\n            return\n        self._stopped = True\n        for fd, sock in self._sockets.items():\n            assert sock.fileno() == fd\n            # Unregister socket from IOLoop\n            self._handlers.pop(fd)()\n            sock.close()",
        "begin_line": 225,
        "end_line": 238,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016233766233766235,
            "pseudo_dstar_susp": 0.00199203187250996,
            "pseudo_tarantula_susp": 0.0010964912280701754,
            "pseudo_op2_susp": 0.00199203187250996,
            "pseudo_barinel_susp": 0.0010964912280701754
        }
    },
    {
        "name": "tornado.tcpserver.TCPServer._handle_connection#257",
        "src_path": "tornado/tcpserver.py",
        "class_name": "tornado.tcpserver.TCPServer",
        "signature": "tornado.tcpserver.TCPServer._handle_connection(self, connection, address)",
        "snippet": "    def _handle_connection(self, connection, address):\n        if self.ssl_options is not None:\n            assert ssl, \"Python 2.6+ and OpenSSL required for SSL\"\n            try:\n                connection = ssl_wrap_socket(connection,\n                                             self.ssl_options,\n                                             server_side=True,\n                                             do_handshake_on_connect=False)\n            except ssl.SSLError as err:\n                if err.args[0] == ssl.SSL_ERROR_EOF:\n                    return connection.close()\n                else:\n                    raise\n            except socket.error as err:\n                # If the connection is closed immediately after it is created\n                # (as in a port scan), we can get one of several errors.\n                # wrap_socket makes an internal call to getpeername,\n                # which may return either EINVAL (Mac OS X) or ENOTCONN\n                # (Linux).  If it returns ENOTCONN, this error is\n                # silently swallowed by the ssl module, so we need to\n                # catch another error later on (AttributeError in\n                # SSLIOStream._do_ssl_handshake).\n                # To test this behavior, try nmap with the -sT flag.\n                # https://github.com/tornadoweb/tornado/pull/750\n                if errno_from_exception(err) in (errno.ECONNABORTED, errno.EINVAL):\n                    return connection.close()\n                else:\n                    raise\n        try:\n            if self.ssl_options is not None:\n                stream = SSLIOStream(connection,\n                                     max_buffer_size=self.max_buffer_size,\n                                     read_chunk_size=self.read_chunk_size)\n            else:\n                stream = IOStream(connection,\n                                  max_buffer_size=self.max_buffer_size,\n                                  read_chunk_size=self.read_chunk_size)\n\n            future = self.handle_stream(stream, address)\n            if future is not None:\n                IOLoop.current().add_future(gen.convert_yielded(future),\n                                            lambda f: f.result())\n        except Exception:\n            app_log.error(\"Error in connection callback\", exc_info=True)",
        "begin_line": 257,
        "end_line": 300,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01,
            "pseudo_dstar_susp": 0.0016835016835016834,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.0016835016835016834,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.autoreload.start#112",
        "src_path": "tornado/autoreload.py",
        "class_name": "tornado.autoreload",
        "signature": "tornado.autoreload.start(check_time=500)",
        "snippet": "def start(check_time=500):\n    \"\"\"Begins watching source files for changes.\n\n    .. versionchanged:: 5.0\n       The ``io_loop`` argument (deprecated since version 4.1) has been removed.\n    \"\"\"\n    io_loop = ioloop.IOLoop.current()\n    if io_loop in _io_loops:\n        return\n    _io_loops[io_loop] = True\n    if len(_io_loops) > 1:\n        gen_log.warning(\"tornado.autoreload started more than once in the same process\")\n    modify_times = {}\n    callback = functools.partial(_reload_on_update, modify_times)\n    scheduler = ioloop.PeriodicCallback(callback, check_time)\n    scheduler.start()",
        "begin_line": 112,
        "end_line": 127,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.autoreload.wait#130",
        "src_path": "tornado/autoreload.py",
        "class_name": "tornado.autoreload",
        "signature": "tornado.autoreload.wait()",
        "snippet": "def wait():\n    \"\"\"Wait for a watched file to change, then restart the process.\n\n    Intended to be used at the end of scripts like unit test runners,\n    to run the tests again after any source file changes (but see also\n    the command-line interface in `main`)\n    \"\"\"\n    io_loop = ioloop.IOLoop()\n    io_loop.add_callback(start)\n    io_loop.start()",
        "begin_line": 130,
        "end_line": 139,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.autoreload.watch#142",
        "src_path": "tornado/autoreload.py",
        "class_name": "tornado.autoreload",
        "signature": "tornado.autoreload.watch(filename)",
        "snippet": "def watch(filename):\n    \"\"\"Add a file to the watch list.\n\n    All imported modules are watched by default.\n    \"\"\"\n    _watched_files.add(filename)",
        "begin_line": 142,
        "end_line": 147,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.autoreload.add_reload_hook#150",
        "src_path": "tornado/autoreload.py",
        "class_name": "tornado.autoreload",
        "signature": "tornado.autoreload.add_reload_hook(fn)",
        "snippet": "def add_reload_hook(fn):\n    \"\"\"Add a function to be called before reloading the process.\n\n    Note that for open file and socket handles it is generally\n    preferable to set the ``FD_CLOEXEC`` flag (using `fcntl` or\n    ``tornado.platform.auto.set_close_exec``) instead\n    of using a reload hook to close them.\n    \"\"\"\n    _reload_hooks.append(fn)",
        "begin_line": 150,
        "end_line": 158,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.autoreload._reload_on_update#161",
        "src_path": "tornado/autoreload.py",
        "class_name": "tornado.autoreload",
        "signature": "tornado.autoreload._reload_on_update(modify_times)",
        "snippet": "def _reload_on_update(modify_times):\n    if _reload_attempted:\n        # We already tried to reload and it didn't work, so don't try again.\n        return\n    if process.task_id() is not None:\n        # We're in a child process created by fork_processes.  If child\n        # processes restarted themselves, they'd all restart and then\n        # all call fork_processes again.\n        return\n    for module in list(sys.modules.values()):\n        # Some modules play games with sys.modules (e.g. email/__init__.py\n        # in the standard library), and occasionally this can cause strange\n        # failures in getattr.  Just ignore anything that's not an ordinary\n        # module.\n        if not isinstance(module, types.ModuleType):\n            continue\n        path = getattr(module, \"__file__\", None)\n        if not path:\n            continue\n        if path.endswith(\".pyc\") or path.endswith(\".pyo\"):\n            path = path[:-1]\n        _check_file(modify_times, path)\n    for path in _watched_files:\n        _check_file(modify_times, path)",
        "begin_line": 161,
        "end_line": 184,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.autoreload._check_file#187",
        "src_path": "tornado/autoreload.py",
        "class_name": "tornado.autoreload",
        "signature": "tornado.autoreload._check_file(modify_times, path)",
        "snippet": "def _check_file(modify_times, path):\n    try:\n        modified = os.stat(path).st_mtime\n    except Exception:\n        return\n    if path not in modify_times:\n        modify_times[path] = modified\n        return\n    if modify_times[path] != modified:\n        gen_log.info(\"%s modified; restarting server\", path)\n        _reload()",
        "begin_line": 187,
        "end_line": 197,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.autoreload._reload#200",
        "src_path": "tornado/autoreload.py",
        "class_name": "tornado.autoreload",
        "signature": "tornado.autoreload._reload()",
        "snippet": "def _reload():\n    global _reload_attempted\n    _reload_attempted = True\n    for fn in _reload_hooks:\n        fn()\n    if hasattr(signal, \"setitimer\"):\n        # Clear the alarm signal set by\n        # ioloop.set_blocking_log_threshold so it doesn't fire\n        # after the exec.\n        signal.setitimer(signal.ITIMER_REAL, 0, 0)\n    # sys.path fixes: see comments at top of file.  If __main__.__spec__\n    # exists, we were invoked with -m and the effective path is about to\n    # change on re-exec.  Reconstruct the original command line to\n    # ensure that the new process sees the same path we did.  If\n    # __spec__ is not available (Python < 3.4), check instead if\n    # sys.path[0] is an empty string and add the current directory to\n    # $PYTHONPATH.\n    spec = getattr(sys.modules['__main__'], '__spec__', None)\n    if spec:\n        argv = ['-m', spec.name] + sys.argv[1:]\n    else:\n        argv = sys.argv\n        path_prefix = '.' + os.pathsep\n        if (sys.path[0] == '' and\n                not os.environ.get(\"PYTHONPATH\", \"\").startswith(path_prefix)):\n            os.environ[\"PYTHONPATH\"] = (path_prefix +\n                                        os.environ.get(\"PYTHONPATH\", \"\"))\n    if not _has_execv:\n        subprocess.Popen([sys.executable] + argv)\n        sys.exit(0)\n    else:\n        try:\n            os.execv(sys.executable, [sys.executable] + argv)\n        except OSError:\n            # Mac OS X versions prior to 10.6 do not support execv in\n            # a process that contains multiple threads.  Instead of\n            # re-executing in the current process, start a new one\n            # and cause the current process to exit.  This isn't\n            # ideal since the new process is detached from the parent\n            # terminal and thus cannot easily be killed with ctrl-C,\n            # but it's better than not being able to autoreload at\n            # all.\n            # Unfortunately the errno returned in this case does not\n            # appear to be consistent, so we can't easily check for\n            # this error specifically.\n            os.spawnv(os.P_NOWAIT, sys.executable, [sys.executable] + argv)\n            # At this point the IOLoop has been closed and finally\n            # blocks will experience errors if we allow the stack to\n            # unwind, so just exit uncleanly.\n            os._exit(0)",
        "begin_line": 200,
        "end_line": 249,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.autoreload.main#259",
        "src_path": "tornado/autoreload.py",
        "class_name": "tornado.autoreload",
        "signature": "tornado.autoreload.main()",
        "snippet": "def main():\n    \"\"\"Command-line wrapper to re-run a script whenever its source changes.\n\n    Scripts may be specified by filename or module name::\n\n        python -m tornado.autoreload -m tornado.test.runtests\n        python -m tornado.autoreload tornado/test/runtests.py\n\n    Running a script with this wrapper is similar to calling\n    `tornado.autoreload.wait` at the end of the script, but this wrapper\n    can catch import-time problems like syntax errors that would otherwise\n    prevent the script from reaching its call to `wait`.\n    \"\"\"\n    original_argv = sys.argv\n    sys.argv = sys.argv[:]\n    if len(sys.argv) >= 3 and sys.argv[1] == \"-m\":\n        mode = \"module\"\n        module = sys.argv[2]\n        del sys.argv[1:3]\n    elif len(sys.argv) >= 2:\n        mode = \"script\"\n        script = sys.argv[1]\n        sys.argv = sys.argv[1:]\n    else:\n        print(_USAGE, file=sys.stderr)\n        sys.exit(1)\n\n    try:\n        if mode == \"module\":\n            import runpy\n            runpy.run_module(module, run_name=\"__main__\", alter_sys=True)\n        elif mode == \"script\":\n            with open(script) as f:\n                # Execute the script in our namespace instead of creating\n                # a new one so that something that tries to import __main__\n                # (e.g. the unittest module) will see names defined in the\n                # script instead of just those defined in this module.\n                global __file__\n                __file__ = script\n                # If __package__ is defined, imports may be incorrectly\n                # interpreted as relative to this module.\n                global __package__\n                del __package__\n                exec_in(f.read(), globals(), globals())\n    except SystemExit as e:\n        logging.basicConfig()\n        gen_log.info(\"Script exited with status %s\", e.code)\n    except Exception as e:\n        logging.basicConfig()\n        gen_log.warning(\"Script exited with uncaught exception\", exc_info=True)\n        # If an exception occurred at import time, the file with the error\n        # never made it into sys.modules and so we won't know to watch it.\n        # Just to make sure we've covered everything, walk the stack trace\n        # from the exception and watch every file.\n        for (filename, lineno, name, line) in traceback.extract_tb(sys.exc_info()[2]):\n            watch(filename)\n        if isinstance(e, SyntaxError):\n            # SyntaxErrors are special:  their innermost stack frame is fake\n            # so extract_tb won't see it and we have to get the filename\n            # from the exception object.\n            watch(e.filename)\n    else:\n        logging.basicConfig()\n        gen_log.info(\"Script exited normally\")\n    # restore sys.argv so subsequent executions will include autoreload\n    sys.argv = original_argv\n\n    if mode == 'module':\n        # runpy did a fake import of the module as __main__, but now it's\n        # no longer in sys.modules.  Figure out where it is and watch it.\n        loader = pkgutil.get_loader(module)\n        if loader is not None:\n            watch(loader.get_filename())\n\n    wait()",
        "begin_line": 259,
        "end_line": 333,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.concurrent.is_future#379",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.is_future(x)",
        "snippet": "def is_future(x):\n    return isinstance(x, FUTURES)",
        "begin_line": 379,
        "end_line": 380,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013404825737265416,
            "pseudo_dstar_susp": 0.002183406113537118,
            "pseudo_tarantula_susp": 0.0008019246190858059,
            "pseudo_op2_susp": 0.002183406113537118,
            "pseudo_barinel_susp": 0.0008019246190858059
        }
    },
    {
        "name": "tornado.concurrent.DummyExecutor.submit#384",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent.DummyExecutor",
        "signature": "tornado.concurrent.DummyExecutor.submit(self, fn, *args, **kwargs)",
        "snippet": "    def submit(self, fn, *args, **kwargs):\n        future = Future()\n        try:\n            future_set_result_unless_cancelled(future, fn(*args, **kwargs))\n        except Exception:\n            future_set_exc_info(future, sys.exc_info())\n        return future",
        "begin_line": 384,
        "end_line": 390,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.concurrent.run_on_executor#399",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.run_on_executor(*args, **kwargs)",
        "snippet": "def run_on_executor(*args, **kwargs):\n    \"\"\"Decorator to run a synchronous method asynchronously on an executor.\n\n    The decorated method may be called with a ``callback`` keyword\n    argument and returns a future.\n\n    The executor to be used is determined by the ``executor``\n    attributes of ``self``. To use a different attribute name, pass a\n    keyword argument to the decorator::\n\n        @run_on_executor(executor='_thread_pool')\n        def foo(self):\n            pass\n\n    This decorator should not be confused with the similarly-named\n    `.IOLoop.run_in_executor`. In general, using ``run_in_executor``\n    when *calling* a blocking method is recommended instead of using\n    this decorator when *defining* a method. If compatibility with older\n    versions of Tornado is required, consider defining an executor\n    and using ``executor.submit()`` at the call site.\n\n    .. versionchanged:: 4.2\n       Added keyword arguments to use alternative attributes.\n\n    .. versionchanged:: 5.0\n       Always uses the current IOLoop instead of ``self.io_loop``.\n\n    .. versionchanged:: 5.1\n       Returns a `.Future` compatible with ``await`` instead of a\n       `concurrent.futures.Future`.\n\n    .. deprecated:: 5.1\n\n       The ``callback`` argument is deprecated and will be removed in\n       6.0. The decorator itself is discouraged in new code but will\n       not be removed in 6.0.\n    \"\"\"\n    def run_on_executor_decorator(fn):\n        executor = kwargs.get(\"executor\", \"executor\")\n\n        @functools.wraps(fn)\n        def wrapper(self, *args, **kwargs):\n            callback = kwargs.pop(\"callback\", None)\n            async_future = Future()\n            conc_future = getattr(self, executor).submit(fn, self, *args, **kwargs)\n            chain_future(conc_future, async_future)\n            if callback:\n                warnings.warn(\"callback arguments are deprecated, use the returned Future instead\",\n                              DeprecationWarning)\n                from tornado.ioloop import IOLoop\n                IOLoop.current().add_future(\n                    async_future, lambda future: callback(future.result()))\n            return async_future\n        return wrapper\n    if args and kwargs:\n        raise ValueError(\"cannot combine positional and keyword args\")\n    if len(args) == 1:\n        return run_on_executor_decorator(args[0])\n    elif len(args) != 0:\n        raise ValueError(\"expected 1 argument, got %d\", len(args))\n    return run_on_executor_decorator",
        "begin_line": 399,
        "end_line": 459,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.concurrent.run_on_executor_decorator#436",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.run_on_executor_decorator(fn)",
        "snippet": "    def run_on_executor_decorator(fn):\n        executor = kwargs.get(\"executor\", \"executor\")\n\n        @functools.wraps(fn)\n        def wrapper(self, *args, **kwargs):\n            callback = kwargs.pop(\"callback\", None)\n            async_future = Future()\n            conc_future = getattr(self, executor).submit(fn, self, *args, **kwargs)\n            chain_future(conc_future, async_future)\n            if callback:\n                warnings.warn(\"callback arguments are deprecated, use the returned Future instead\",\n                              DeprecationWarning)\n                from tornado.ioloop import IOLoop\n                IOLoop.current().add_future(\n                    async_future, lambda future: callback(future.result()))\n            return async_future\n        return wrapper",
        "begin_line": 436,
        "end_line": 452,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.concurrent.wrapper#440",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.wrapper(self, *args, **kwargs)",
        "snippet": "        def wrapper(self, *args, **kwargs):\n            callback = kwargs.pop(\"callback\", None)\n            async_future = Future()\n            conc_future = getattr(self, executor).submit(fn, self, *args, **kwargs)\n            chain_future(conc_future, async_future)\n            if callback:\n                warnings.warn(\"callback arguments are deprecated, use the returned Future instead\",\n                              DeprecationWarning)\n                from tornado.ioloop import IOLoop\n                IOLoop.current().add_future(\n                    async_future, lambda future: callback(future.result()))\n            return async_future",
        "begin_line": 440,
        "end_line": 451,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.concurrent.return_future#465",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.return_future(f)",
        "snippet": "def return_future(f):\n    \"\"\"Decorator to make a function that returns via callback return a\n    `Future`.\n\n    This decorator was provided to ease the transition from\n    callback-oriented code to coroutines. It is not recommended for\n    new code.\n\n    The wrapped function should take a ``callback`` keyword argument\n    and invoke it with one argument when it has finished.  To signal failure,\n    the function can simply raise an exception (which will be\n    captured by the `.StackContext` and passed along to the ``Future``).\n\n    From the caller's perspective, the callback argument is optional.\n    If one is given, it will be invoked when the function is complete\n    with ``Future.result()`` as an argument.  If the function fails, the\n    callback will not be run and an exception will be raised into the\n    surrounding `.StackContext`.\n\n    If no callback is given, the caller should use the ``Future`` to\n    wait for the function to complete (perhaps by yielding it in a\n    `.gen.engine` function, or passing it to `.IOLoop.add_future`).\n\n    Usage:\n\n    .. testcode::\n\n        @return_future\n        def future_func(arg1, arg2, callback):\n            # Do stuff (possibly asynchronous)\n            callback(result)\n\n        @gen.engine\n        def caller(callback):\n            yield future_func(arg1, arg2)\n            callback()\n\n    ..\n\n    Note that ``@return_future`` and ``@gen.engine`` can be applied to the\n    same function, provided ``@return_future`` appears first.  However,\n    consider using ``@gen.coroutine`` instead of this combination.\n\n    .. versionchanged:: 5.1\n\n       Now raises a `.DeprecationWarning` if a callback argument is passed to\n       the decorated function and deprecation warnings are enabled.\n\n    .. deprecated:: 5.1\n\n       New code should use coroutines directly instead of wrapping\n       callback-based code with this decorator.\n    \"\"\"\n    replacer = ArgReplacer(f, 'callback')\n\n    @functools.wraps(f)\n    def wrapper(*args, **kwargs):\n        future = Future()\n        callback, args, kwargs = replacer.replace(\n            lambda value=_NO_RESULT: future_set_result_unless_cancelled(future, value),\n            args, kwargs)\n\n        def handle_error(typ, value, tb):\n            future_set_exc_info(future, (typ, value, tb))\n            return True\n        exc_info = None\n        with ExceptionStackContext(handle_error):\n            try:\n                result = f(*args, **kwargs)\n                if result is not None:\n                    raise ReturnValueIgnoredError(\n                        \"@return_future should not be used with functions \"\n                        \"that return values\")\n            except:\n                exc_info = sys.exc_info()\n                raise\n        if exc_info is not None:\n            # If the initial synchronous part of f() raised an exception,\n            # go ahead and raise it to the caller directly without waiting\n            # for them to inspect the Future.\n            future.result()\n\n        # If the caller passed in a callback, schedule it to be called\n        # when the future resolves.  It is important that this happens\n        # just before we return the future, or else we risk confusing\n        # stack contexts with multiple exceptions (one here with the\n        # immediate exception, and again when the future resolves and\n        # the callback triggers its exception by calling future.result()).\n        if callback is not None:\n            warnings.warn(\"callback arguments are deprecated, use the returned Future instead\",\n                          DeprecationWarning)\n\n            def run_callback(future):\n                result = future.result()\n                if result is _NO_RESULT:\n                    callback()\n                else:\n                    callback(future.result())\n            future_add_done_callback(future, wrap(run_callback))\n        return future\n    return wrapper",
        "begin_line": 465,
        "end_line": 565,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.concurrent.wrapper#521",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.wrapper(*args, **kwargs)",
        "snippet": "    def wrapper(*args, **kwargs):\n        future = Future()\n        callback, args, kwargs = replacer.replace(\n            lambda value=_NO_RESULT: future_set_result_unless_cancelled(future, value),\n            args, kwargs)\n\n        def handle_error(typ, value, tb):\n            future_set_exc_info(future, (typ, value, tb))\n            return True\n        exc_info = None\n        with ExceptionStackContext(handle_error):\n            try:\n                result = f(*args, **kwargs)\n                if result is not None:\n                    raise ReturnValueIgnoredError(\n                        \"@return_future should not be used with functions \"\n                        \"that return values\")\n            except:\n                exc_info = sys.exc_info()\n                raise\n        if exc_info is not None:\n            # If the initial synchronous part of f() raised an exception,\n            # go ahead and raise it to the caller directly without waiting\n            # for them to inspect the Future.\n            future.result()\n\n        # If the caller passed in a callback, schedule it to be called\n        # when the future resolves.  It is important that this happens\n        # just before we return the future, or else we risk confusing\n        # stack contexts with multiple exceptions (one here with the\n        # immediate exception, and again when the future resolves and\n        # the callback triggers its exception by calling future.result()).\n        if callback is not None:\n            warnings.warn(\"callback arguments are deprecated, use the returned Future instead\",\n                          DeprecationWarning)\n\n            def run_callback(future):\n                result = future.result()\n                if result is _NO_RESULT:\n                    callback()\n                else:\n                    callback(future.result())\n            future_add_done_callback(future, wrap(run_callback))\n        return future",
        "begin_line": 521,
        "end_line": 564,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.concurrent.handle_error#527",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.handle_error(typ, value, tb)",
        "snippet": "        def handle_error(typ, value, tb):\n            future_set_exc_info(future, (typ, value, tb))\n            return True",
        "begin_line": 527,
        "end_line": 529,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019275250578257516,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.concurrent.run_callback#557",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.run_callback(future)",
        "snippet": "            def run_callback(future):\n                result = future.result()\n                if result is _NO_RESULT:\n                    callback()\n                else:\n                    callback(future.result())",
        "begin_line": 557,
        "end_line": 562,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.concurrent.chain_future#568",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.chain_future(a, b)",
        "snippet": "def chain_future(a, b):\n    \"\"\"Chain two futures together so that when one completes, so does the other.\n\n    The result (success or failure) of ``a`` will be copied to ``b``, unless\n    ``b`` has already been completed or cancelled by the time ``a`` finishes.\n\n    .. versionchanged:: 5.0\n\n       Now accepts both Tornado/asyncio `Future` objects and\n       `concurrent.futures.Future`.\n\n    \"\"\"\n    def copy(future):\n        assert future is a\n        if b.done():\n            return\n        if (hasattr(a, 'exc_info') and\n                a.exc_info() is not None):\n            future_set_exc_info(b, a.exc_info())\n        elif a.exception() is not None:\n            b.set_exception(a.exception())\n        else:\n            b.set_result(a.result())\n    if isinstance(a, Future):\n        future_add_done_callback(a, copy)\n    else:\n        # concurrent.futures.Future\n        from tornado.ioloop import IOLoop\n        IOLoop.current().add_future(a, copy)",
        "begin_line": 568,
        "end_line": 596,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005770340450086555,
            "pseudo_dstar_susp": 0.0006784260515603799,
            "pseudo_tarantula_susp": 0.0005359056806002144,
            "pseudo_op2_susp": 0.0006784260515603799,
            "pseudo_barinel_susp": 0.0005359056806002144
        }
    },
    {
        "name": "tornado.concurrent.copy#580",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.copy(future)",
        "snippet": "    def copy(future):\n        assert future is a\n        if b.done():\n            return\n        if (hasattr(a, 'exc_info') and\n                a.exc_info() is not None):\n            future_set_exc_info(b, a.exc_info())\n        elif a.exception() is not None:\n            b.set_exception(a.exception())\n        else:\n            b.set_result(a.result())",
        "begin_line": 580,
        "end_line": 590,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006738544474393531,
            "pseudo_dstar_susp": 0.0008718395815170009,
            "pseudo_tarantula_susp": 0.0013812154696132596,
            "pseudo_op2_susp": 0.0008718395815170009,
            "pseudo_barinel_susp": 0.0013812154696132596
        }
    },
    {
        "name": "tornado.concurrent.future_set_result_unless_cancelled#599",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.future_set_result_unless_cancelled(future, value)",
        "snippet": "def future_set_result_unless_cancelled(future, value):\n    \"\"\"Set the given ``value`` as the `Future`'s result, if not cancelled.\n\n    Avoids asyncio.InvalidStateError when calling set_result() on\n    a cancelled `asyncio.Future`.\n\n    .. versionadded:: 5.0\n    \"\"\"\n    if not future.cancelled():\n        future.set_result(value)",
        "begin_line": 599,
        "end_line": 608,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011961722488038277,
            "pseudo_dstar_susp": 0.0014858841010401188,
            "pseudo_tarantula_susp": 0.000722543352601156,
            "pseudo_op2_susp": 0.0014858841010401188,
            "pseudo_barinel_susp": 0.000722543352601156
        }
    },
    {
        "name": "tornado.concurrent.future_set_exc_info#611",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.future_set_exc_info(future, exc_info)",
        "snippet": "def future_set_exc_info(future, exc_info):\n    \"\"\"Set the given ``exc_info`` as the `Future`'s exception.\n\n    Understands both `asyncio.Future` and Tornado's extensions to\n    enable better tracebacks on Python 2.\n\n    .. versionadded:: 5.0\n    \"\"\"\n    if hasattr(future, 'set_exc_info'):\n        # Tornado's Future\n        future.set_exc_info(exc_info)\n    else:\n        # asyncio.Future\n        future.set_exception(exc_info[1])",
        "begin_line": 611,
        "end_line": 624,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005714285714285715,
            "pseudo_dstar_susp": 0.000671591672263264,
            "pseudo_tarantula_susp": 0.0005310674455655868,
            "pseudo_op2_susp": 0.000671591672263264,
            "pseudo_barinel_susp": 0.0005310674455655868
        }
    },
    {
        "name": "tornado.concurrent.future_add_done_callback#627",
        "src_path": "tornado/concurrent.py",
        "class_name": "tornado.concurrent",
        "signature": "tornado.concurrent.future_add_done_callback(future, callback)",
        "snippet": "def future_add_done_callback(future, callback):\n    \"\"\"Arrange to call ``callback`` when ``future`` is complete.\n\n    ``callback`` is invoked with one argument, the ``future``.\n\n    If ``future`` is already done, ``callback`` is invoked immediately.\n    This may differ from the behavior of ``Future.add_done_callback``,\n    which makes no such guarantee.\n\n    .. versionadded:: 5.0\n    \"\"\"\n    if future.done():\n        callback(future)\n    else:\n        future.add_done_callback(callback)",
        "begin_line": 627,
        "end_line": 641,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014534883720930232,
            "pseudo_dstar_susp": 0.002136752136752137,
            "pseudo_tarantula_susp": 0.0010121457489878543,
            "pseudo_op2_susp": 0.002136752136752137,
            "pseudo_barinel_susp": 0.0010121457489878543
        }
    },
    {
        "name": "tornado.process._pipe_cloexec#89",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process",
        "signature": "tornado.process._pipe_cloexec()",
        "snippet": "def _pipe_cloexec():\n    r, w = os.pipe()\n    set_close_exec(r)\n    set_close_exec(w)\n    return r, w",
        "begin_line": 89,
        "end_line": 93,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.process.fork_processes#99",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process",
        "signature": "tornado.process.fork_processes(num_processes, max_restarts=100)",
        "snippet": "def fork_processes(num_processes, max_restarts=100):\n    \"\"\"Starts multiple worker processes.\n\n    If ``num_processes`` is None or <= 0, we detect the number of cores\n    available on this machine and fork that number of child\n    processes. If ``num_processes`` is given and > 0, we fork that\n    specific number of sub-processes.\n\n    Since we use processes and not threads, there is no shared memory\n    between any server code.\n\n    Note that multiple processes are not compatible with the autoreload\n    module (or the ``autoreload=True`` option to `tornado.web.Application`\n    which defaults to True when ``debug=True``).\n    When using multiple processes, no IOLoops can be created or\n    referenced until after the call to ``fork_processes``.\n\n    In each child process, ``fork_processes`` returns its *task id*, a\n    number between 0 and ``num_processes``.  Processes that exit\n    abnormally (due to a signal or non-zero exit status) are restarted\n    with the same id (up to ``max_restarts`` times).  In the parent\n    process, ``fork_processes`` returns None if all child processes\n    have exited normally, but will otherwise only exit by throwing an\n    exception.\n    \"\"\"\n    global _task_id\n    assert _task_id is None\n    if num_processes is None or num_processes <= 0:\n        num_processes = cpu_count()\n    gen_log.info(\"Starting %d processes\", num_processes)\n    children = {}\n\n    def start_child(i):\n        pid = os.fork()\n        if pid == 0:\n            # child process\n            _reseed_random()\n            global _task_id\n            _task_id = i\n            return i\n        else:\n            children[pid] = i\n            return None\n\n    for i in range(num_processes):\n        id = start_child(i)\n        if id is not None:\n            return id\n    num_restarts = 0\n    while children:\n        try:\n            pid, status = os.wait()\n        except OSError as e:\n            if errno_from_exception(e) == errno.EINTR:\n                continue\n            raise\n        if pid not in children:\n            continue\n        id = children.pop(pid)\n        if os.WIFSIGNALED(status):\n            gen_log.warning(\"child %d (pid %d) killed by signal %d, restarting\",\n                            id, pid, os.WTERMSIG(status))\n        elif os.WEXITSTATUS(status) != 0:\n            gen_log.warning(\"child %d (pid %d) exited with status %d, restarting\",\n                            id, pid, os.WEXITSTATUS(status))\n        else:\n            gen_log.info(\"child %d (pid %d) exited normally\", id, pid)\n            continue\n        num_restarts += 1\n        if num_restarts > max_restarts:\n            raise RuntimeError(\"Too many child restarts, giving up\")\n        new_id = start_child(id)\n        if new_id is not None:\n            return new_id\n    # All child processes exited cleanly, so exit the master process\n    # instead of just returning to right after the call to\n    # fork_processes (which will probably just start up another IOLoop\n    # unless the caller checks the return value).\n    sys.exit(0)",
        "begin_line": 99,
        "end_line": 177,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.process.start_child#131",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process",
        "signature": "tornado.process.start_child(i)",
        "snippet": "    def start_child(i):\n        pid = os.fork()\n        if pid == 0:\n            # child process\n            _reseed_random()\n            global _task_id\n            _task_id = i\n            return i\n        else:\n            children[pid] = i\n            return None",
        "begin_line": 131,
        "end_line": 141,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.process.task_id#180",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process",
        "signature": "tornado.process.task_id()",
        "snippet": "def task_id():\n    \"\"\"Returns the current task id, if any.\n\n    Returns None if this process was not created by `fork_processes`.\n    \"\"\"\n    global _task_id\n    return _task_id",
        "begin_line": 180,
        "end_line": 186,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.process.Subprocess.__init__#215",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process.Subprocess",
        "signature": "tornado.process.Subprocess.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        self.io_loop = ioloop.IOLoop.current()\n        # All FDs we create should be closed on error; those in to_close\n        # should be closed in the parent process on success.\n        pipe_fds = []\n        to_close = []\n        if kwargs.get('stdin') is Subprocess.STREAM:\n            in_r, in_w = _pipe_cloexec()\n            kwargs['stdin'] = in_r\n            pipe_fds.extend((in_r, in_w))\n            to_close.append(in_r)\n            self.stdin = PipeIOStream(in_w)\n        if kwargs.get('stdout') is Subprocess.STREAM:\n            out_r, out_w = _pipe_cloexec()\n            kwargs['stdout'] = out_w\n            pipe_fds.extend((out_r, out_w))\n            to_close.append(out_w)\n            self.stdout = PipeIOStream(out_r)\n        if kwargs.get('stderr') is Subprocess.STREAM:\n            err_r, err_w = _pipe_cloexec()\n            kwargs['stderr'] = err_w\n            pipe_fds.extend((err_r, err_w))\n            to_close.append(err_w)\n            self.stderr = PipeIOStream(err_r)\n        try:\n            self.proc = subprocess.Popen(*args, **kwargs)\n        except:\n            for fd in pipe_fds:\n                os.close(fd)\n            raise\n        for fd in to_close:\n            os.close(fd)\n        for attr in ['stdin', 'stdout', 'stderr', 'pid']:\n            if not hasattr(self, attr):  # don't clobber streams set above\n                setattr(self, attr, getattr(self.proc, attr))\n        self._exit_callback = None\n        self.returncode = None",
        "begin_line": 215,
        "end_line": 251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.process.Subprocess.set_exit_callback#253",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process.Subprocess",
        "signature": "tornado.process.Subprocess.set_exit_callback(self, callback)",
        "snippet": "    def set_exit_callback(self, callback):\n        \"\"\"Runs ``callback`` when this process exits.\n\n        The callback takes one argument, the return code of the process.\n\n        This method uses a ``SIGCHLD`` handler, which is a global setting\n        and may conflict if you have other libraries trying to handle the\n        same signal.  If you are using more than one ``IOLoop`` it may\n        be necessary to call `Subprocess.initialize` first to designate\n        one ``IOLoop`` to run the signal handlers.\n\n        In many cases a close callback on the stdout or stderr streams\n        can be used as an alternative to an exit callback if the\n        signal handler is causing a problem.\n        \"\"\"\n        self._exit_callback = stack_context.wrap(callback)\n        Subprocess.initialize()\n        Subprocess._waiting[self.pid] = self\n        Subprocess._try_cleanup_process(self.pid)",
        "begin_line": 253,
        "end_line": 271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.process.Subprocess.wait_for_exit#273",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process.Subprocess",
        "signature": "tornado.process.Subprocess.wait_for_exit(self, raise_error=True)",
        "snippet": "    def wait_for_exit(self, raise_error=True):\n        \"\"\"Returns a `.Future` which resolves when the process exits.\n\n        Usage::\n\n            ret = yield proc.wait_for_exit()\n\n        This is a coroutine-friendly alternative to `set_exit_callback`\n        (and a replacement for the blocking `subprocess.Popen.wait`).\n\n        By default, raises `subprocess.CalledProcessError` if the process\n        has a non-zero exit status. Use ``wait_for_exit(raise_error=False)``\n        to suppress this behavior and return the exit status without raising.\n\n        .. versionadded:: 4.2\n        \"\"\"\n        future = Future()\n\n        def callback(ret):\n            if ret != 0 and raise_error:\n                # Unfortunately we don't have the original args any more.\n                future.set_exception(CalledProcessError(ret, None))\n            else:\n                future_set_result_unless_cancelled(future, ret)\n        self.set_exit_callback(callback)\n        return future",
        "begin_line": 273,
        "end_line": 298,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.process.Subprocess.callback#291",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process.Subprocess",
        "signature": "tornado.process.Subprocess.callback(ret)",
        "snippet": "        def callback(ret):\n            if ret != 0 and raise_error:\n                # Unfortunately we don't have the original args any more.\n                future.set_exception(CalledProcessError(ret, None))\n            else:\n                future_set_result_unless_cancelled(future, ret)",
        "begin_line": 291,
        "end_line": 296,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.process.Subprocess.initialize#301",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process.Subprocess",
        "signature": "tornado.process.Subprocess.initialize(cls)",
        "snippet": "    def initialize(cls):\n        \"\"\"Initializes the ``SIGCHLD`` handler.\n\n        The signal handler is run on an `.IOLoop` to avoid locking issues.\n        Note that the `.IOLoop` used for signal handling need not be the\n        same one used by individual Subprocess objects (as long as the\n        ``IOLoops`` are each running in separate threads).\n\n        .. versionchanged:: 5.0\n           The ``io_loop`` argument (deprecated since version 4.1) has been\n           removed.\n        \"\"\"\n        if cls._initialized:\n            return\n        io_loop = ioloop.IOLoop.current()\n        cls._old_sigchld = signal.signal(\n            signal.SIGCHLD,\n            lambda sig, frame: io_loop.add_callback_from_signal(cls._cleanup))\n        cls._initialized = True",
        "begin_line": 301,
        "end_line": 319,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.process.Subprocess.uninitialize#322",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process.Subprocess",
        "signature": "tornado.process.Subprocess.uninitialize(cls)",
        "snippet": "    def uninitialize(cls):\n        \"\"\"Removes the ``SIGCHLD`` handler.\"\"\"\n        if not cls._initialized:\n            return\n        signal.signal(signal.SIGCHLD, cls._old_sigchld)\n        cls._initialized = False",
        "begin_line": 322,
        "end_line": 327,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002197802197802198,
            "pseudo_dstar_susp": 0.006060606060606061,
            "pseudo_tarantula_susp": 0.0013623978201634877,
            "pseudo_op2_susp": 0.006060606060606061,
            "pseudo_barinel_susp": 0.0013623978201634877
        }
    },
    {
        "name": "tornado.process.Subprocess._cleanup#330",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process.Subprocess",
        "signature": "tornado.process.Subprocess._cleanup(cls)",
        "snippet": "    def _cleanup(cls):\n        for pid in list(cls._waiting.keys()):  # make a copy\n            cls._try_cleanup_process(pid)",
        "begin_line": 330,
        "end_line": 332,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.process.Subprocess._try_cleanup_process#335",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process.Subprocess",
        "signature": "tornado.process.Subprocess._try_cleanup_process(cls, pid)",
        "snippet": "    def _try_cleanup_process(cls, pid):\n        try:\n            ret_pid, status = os.waitpid(pid, os.WNOHANG)\n        except OSError as e:\n            if errno_from_exception(e) == errno.ECHILD:\n                return\n        if ret_pid == 0:\n            return\n        assert ret_pid == pid\n        subproc = cls._waiting.pop(pid)\n        subproc.io_loop.add_callback_from_signal(\n            subproc._set_returncode, status)",
        "begin_line": 335,
        "end_line": 346,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.process.Subprocess._set_returncode#348",
        "src_path": "tornado/process.py",
        "class_name": "tornado.process.Subprocess",
        "signature": "tornado.process.Subprocess._set_returncode(self, status)",
        "snippet": "    def _set_returncode(self, status):\n        if os.WIFSIGNALED(status):\n            self.returncode = -os.WTERMSIG(status)\n        else:\n            assert os.WIFEXITED(status)\n            self.returncode = os.WEXITSTATUS(status)\n        # We've taken over wait() duty from the subprocess.Popen\n        # object. If we don't inform it of the process's return code,\n        # it will log a warning at destruction in python 3.6+.\n        self.proc.returncode = self.returncode\n        if self._exit_callback:\n            callback = self._exit_callback\n            self._exit_callback = None\n            callback(self.returncode)",
        "begin_line": 348,
        "end_line": 361,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.current#255",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.current(instance=True)",
        "snippet": "    def current(instance=True):\n        \"\"\"Returns the current thread's `IOLoop`.\n\n        If an `IOLoop` is currently running or has been marked as\n        current by `make_current`, returns that instance.  If there is\n        no current `IOLoop` and ``instance`` is true, creates one.\n\n        .. versionchanged:: 4.1\n           Added ``instance`` argument to control the fallback to\n           `IOLoop.instance()`.\n        .. versionchanged:: 5.0\n           On Python 3, control of the current `IOLoop` is delegated\n           to `asyncio`, with this and other methods as pass-through accessors.\n           The ``instance`` argument now controls whether an `IOLoop`\n           is created automatically when there is none, instead of\n           whether we fall back to `IOLoop.instance()` (which is now\n           an alias for this method). ``instance=False`` is deprecated,\n           since even if we do not create an `IOLoop`, this method\n           may initialize the asyncio loop.\n        \"\"\"\n        if asyncio is None:\n            current = getattr(IOLoop._current, \"instance\", None)\n            if current is None and instance:\n                current = IOLoop()\n                if IOLoop._current.instance is not current:\n                    raise RuntimeError(\"new IOLoop did not become current\")\n        else:\n            try:\n                loop = asyncio.get_event_loop()\n            except (RuntimeError, AssertionError):\n                if not instance:\n                    return None\n                raise\n            try:\n                return IOLoop._ioloop_for_asyncio[loop]\n            except KeyError:\n                if instance:\n                    from tornado.platform.asyncio import AsyncIOMainLoop\n                    current = AsyncIOMainLoop(make_current=True)\n                else:\n                    current = None\n        return current",
        "begin_line": 255,
        "end_line": 296,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005025125628140704,
            "pseudo_dstar_susp": 0.125,
            "pseudo_tarantula_susp": 0.0038461538461538464,
            "pseudo_op2_susp": 0.125,
            "pseudo_barinel_susp": 0.0038461538461538464
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.clear_current#322",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.clear_current()",
        "snippet": "    def clear_current():\n        \"\"\"Clears the `IOLoop` for the current thread.\n\n        Intended primarily for use by test frameworks in between tests.\n\n        .. versionchanged:: 5.0\n           This method also clears the current `asyncio` event loop.\n        \"\"\"\n        old = IOLoop.current(instance=False)\n        if old is not None:\n            old._clear_current_hook()\n        if asyncio is None:\n            IOLoop._current.instance = None",
        "begin_line": 322,
        "end_line": 334,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0026595744680851063,
            "pseudo_dstar_susp": 0.012345679012345678,
            "pseudo_tarantula_susp": 0.0014727540500736377,
            "pseudo_op2_susp": 0.012345679012345678,
            "pseudo_barinel_susp": 0.0014727540500736377
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.configurable_base#344",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.configurable_base(cls)",
        "snippet": "    def configurable_base(cls):\n        return IOLoop",
        "begin_line": 344,
        "end_line": 345,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002849002849002849,
            "pseudo_dstar_susp": 0.01639344262295082,
            "pseudo_tarantula_susp": 0.001524390243902439,
            "pseudo_op2_susp": 0.01639344262295082,
            "pseudo_barinel_susp": 0.001524390243902439
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.configurable_default#348",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.configurable_default(cls)",
        "snippet": "    def configurable_default(cls):\n        if asyncio is not None:\n            from tornado.platform.asyncio import AsyncIOLoop\n            return AsyncIOLoop\n        return PollIOLoop",
        "begin_line": 348,
        "end_line": 352,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.initialize#354",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.initialize(self, make_current=None)",
        "snippet": "    def initialize(self, make_current=None):\n        if make_current is None:\n            if IOLoop.current(instance=False) is None:\n                self.make_current()\n        elif make_current:\n            current = IOLoop.current(instance=False)\n            # AsyncIO loops can already be current by this point.\n            if current is not None and current is not self:\n                raise RuntimeError(\"current IOLoop already exists\")\n            self.make_current()",
        "begin_line": 354,
        "end_line": 363,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028653295128939827,
            "pseudo_dstar_susp": 0.01694915254237288,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.01694915254237288,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.ioloop.IOLoop._setup_logging#479",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop._setup_logging(self)",
        "snippet": "    def _setup_logging(self):\n        \"\"\"The IOLoop catches and logs exceptions, so it's\n        important that log output be visible.  However, python's\n        default behavior for non-root loggers (prior to python\n        3.2) is to print an unhelpful \"no handlers could be\n        found\" message rather than the actual log entry, so we\n        must explicitly configure logging if we've made it this\n        far without anything.\n\n        This method should be called from start() in subclasses.\n        \"\"\"\n        if not any([logging.getLogger().handlers,\n                    logging.getLogger('tornado').handlers,\n                    logging.getLogger('tornado.application').handlers]):\n            logging.basicConfig()",
        "begin_line": 479,
        "end_line": 493,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002617801047120419,
            "pseudo_dstar_susp": 0.007751937984496124,
            "pseudo_tarantula_susp": 0.0016025641025641025,
            "pseudo_op2_susp": 0.007751937984496124,
            "pseudo_barinel_susp": 0.0016025641025641025
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.run_sync#519",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.run_sync(self, func, timeout=None)",
        "snippet": "    def run_sync(self, func, timeout=None):\n        \"\"\"Starts the `IOLoop`, runs the given function, and stops the loop.\n\n        The function must return either a yieldable object or\n        ``None``. If the function returns a yieldable object, the\n        `IOLoop` will run until the yieldable is resolved (and\n        `run_sync()` will return the yieldable's result). If it raises\n        an exception, the `IOLoop` will stop and the exception will be\n        re-raised to the caller.\n\n        The keyword-only argument ``timeout`` may be used to set\n        a maximum duration for the function.  If the timeout expires,\n        a `tornado.util.TimeoutError` is raised.\n\n        This method is useful in conjunction with `tornado.gen.coroutine`\n        to allow asynchronous calls in a ``main()`` function::\n\n            @gen.coroutine\n            def main():\n                # do stuff...\n\n            if __name__ == '__main__':\n                IOLoop.current().run_sync(main)\n\n        .. versionchanged:: 4.3\n           Returning a non-``None``, non-yieldable value is now an error.\n\n        .. versionchanged:: 5.0\n           If a timeout occurs, the ``func`` coroutine will be cancelled.\n        \"\"\"\n        future_cell = [None]\n\n        def run():\n            try:\n                result = func()\n                if result is not None:\n                    from tornado.gen import convert_yielded\n                    result = convert_yielded(result)\n            except Exception:\n                future_cell[0] = Future()\n                future_set_exc_info(future_cell[0], sys.exc_info())\n            else:\n                if is_future(result):\n                    future_cell[0] = result\n                else:\n                    future_cell[0] = Future()\n                    future_cell[0].set_result(result)\n            self.add_future(future_cell[0], lambda future: self.stop())\n        self.add_callback(run)\n        if timeout is not None:\n            def timeout_callback():\n                # If we can cancel the future, do so and wait on it. If not,\n                # Just stop the loop and return with the task still pending.\n                # (If we neither cancel nor wait for the task, a warning\n                # will be logged).\n                if not future_cell[0].cancel():\n                    self.stop()\n            timeout_handle = self.add_timeout(self.time() + timeout, timeout_callback)\n        self.start()\n        if timeout is not None:\n            self.remove_timeout(timeout_handle)\n        if future_cell[0].cancelled() or not future_cell[0].done():\n            raise TimeoutError('Operation timed out after %s seconds' % timeout)\n        return future_cell[0].result()",
        "begin_line": 519,
        "end_line": 582,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015015015015015015,
            "pseudo_dstar_susp": 0.0023094688221709007,
            "pseudo_tarantula_susp": 0.004761904761904762,
            "pseudo_op2_susp": 0.0023094688221709007,
            "pseudo_barinel_susp": 0.004608294930875576
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.run#551",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.run()",
        "snippet": "        def run():\n            try:\n                result = func()\n                if result is not None:\n                    from tornado.gen import convert_yielded\n                    result = convert_yielded(result)\n            except Exception:\n                future_cell[0] = Future()\n                future_set_exc_info(future_cell[0], sys.exc_info())\n            else:\n                if is_future(result):\n                    future_cell[0] = result\n                else:\n                    future_cell[0] = Future()\n                    future_cell[0].set_result(result)\n            self.add_future(future_cell[0], lambda future: self.stop())",
        "begin_line": 551,
        "end_line": 566,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002127659574468085,
            "pseudo_dstar_susp": 0.004166666666666667,
            "pseudo_tarantula_susp": 0.0009505703422053232,
            "pseudo_op2_susp": 0.004166666666666667,
            "pseudo_barinel_susp": 0.0009505703422053232
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.timeout_callback#569",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.timeout_callback()",
        "snippet": "            def timeout_callback():\n                # If we can cancel the future, do so and wait on it. If not,\n                # Just stop the loop and return with the task still pending.\n                # (If we neither cancel nor wait for the task, a warning\n                # will be logged).\n                if not future_cell[0].cancel():\n                    self.stop()",
        "begin_line": 569,
        "end_line": 575,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002028397565922921,
            "pseudo_dstar_susp": 0.002702702702702703,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.002702702702702703,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.time#584",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.time(self)",
        "snippet": "    def time(self):\n        \"\"\"Returns the current time according to the `IOLoop`'s clock.\n\n        The return value is a floating-point number relative to an\n        unspecified time in the past.\n\n        By default, the `IOLoop`'s time function is `time.time`.  However,\n        it may be configured to use e.g. `time.monotonic` instead.\n        Calls to `add_timeout` that pass a number instead of a\n        `datetime.timedelta` should use this function to compute the\n        appropriate time, so they can work no matter what time function\n        is chosen.\n        \"\"\"\n        return time.time()",
        "begin_line": 584,
        "end_line": 597,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00273224043715847,
            "pseudo_dstar_susp": 0.007936507936507936,
            "pseudo_tarantula_susp": 0.0016286644951140066,
            "pseudo_op2_susp": 0.007936507936507936,
            "pseudo_barinel_susp": 0.0016286644951140066
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.add_timeout#599",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.add_timeout(self, deadline, callback, *args, **kwargs)",
        "snippet": "    def add_timeout(self, deadline, callback, *args, **kwargs):\n        \"\"\"Runs the ``callback`` at the time ``deadline`` from the I/O loop.\n\n        Returns an opaque handle that may be passed to\n        `remove_timeout` to cancel.\n\n        ``deadline`` may be a number denoting a time (on the same\n        scale as `IOLoop.time`, normally `time.time`), or a\n        `datetime.timedelta` object for a deadline relative to the\n        current time.  Since Tornado 4.0, `call_later` is a more\n        convenient alternative for the relative case since it does not\n        require a timedelta object.\n\n        Note that it is not safe to call `add_timeout` from other threads.\n        Instead, you must use `add_callback` to transfer control to the\n        `IOLoop`'s thread, and then call `add_timeout` from there.\n\n        Subclasses of IOLoop must implement either `add_timeout` or\n        `call_at`; the default implementations of each will call\n        the other.  `call_at` is usually easier to implement, but\n        subclasses that wish to maintain compatibility with Tornado\n        versions prior to 4.0 must use `add_timeout` instead.\n\n        .. versionchanged:: 4.0\n           Now passes through ``*args`` and ``**kwargs`` to the callback.\n        \"\"\"\n        if isinstance(deadline, numbers.Real):\n            return self.call_at(deadline, callback, *args, **kwargs)\n        elif isinstance(deadline, datetime.timedelta):\n            return self.call_at(self.time() + timedelta_to_seconds(deadline),\n                                callback, *args, **kwargs)\n        else:\n            raise TypeError(\"Unsupported deadline %r\" % deadline)",
        "begin_line": 599,
        "end_line": 631,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0027624309392265192,
            "pseudo_dstar_susp": 0.008130081300813009,
            "pseudo_tarantula_susp": 0.0016366612111292963,
            "pseudo_op2_susp": 0.008130081300813009,
            "pseudo_barinel_susp": 0.0016366612111292963
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.call_later#633",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.call_later(self, delay, callback, *args, **kwargs)",
        "snippet": "    def call_later(self, delay, callback, *args, **kwargs):\n        \"\"\"Runs the ``callback`` after ``delay`` seconds have passed.\n\n        Returns an opaque handle that may be passed to `remove_timeout`\n        to cancel.  Note that unlike the `asyncio` method of the same\n        name, the returned object does not have a ``cancel()`` method.\n\n        See `add_timeout` for comments on thread-safety and subclassing.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        return self.call_at(self.time() + delay, callback, *args, **kwargs)",
        "begin_line": 633,
        "end_line": 644,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014438348252959862,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.spawn_callback#698",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.spawn_callback(self, callback, *args, **kwargs)",
        "snippet": "    def spawn_callback(self, callback, *args, **kwargs):\n        \"\"\"Calls the given callback on the next IOLoop iteration.\n\n        Unlike all other callback-related methods on IOLoop,\n        ``spawn_callback`` does not associate the callback with its caller's\n        ``stack_context``, so it is suitable for fire-and-forget callbacks\n        that should not interfere with the caller.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        with stack_context.NullContext():\n            self.add_callback(callback, *args, **kwargs)",
        "begin_line": 698,
        "end_line": 709,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.add_future#711",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.add_future(self, future, callback)",
        "snippet": "    def add_future(self, future, callback):\n        \"\"\"Schedules a callback on the ``IOLoop`` when the given\n        `.Future` is finished.\n\n        The callback is invoked with one argument, the\n        `.Future`.\n        \"\"\"\n        assert is_future(future)\n        callback = stack_context.wrap(callback)\n        future_add_done_callback(\n            future, lambda future: self.add_callback(callback, future))",
        "begin_line": 711,
        "end_line": 721,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00211864406779661,
            "pseudo_dstar_susp": 0.004132231404958678,
            "pseudo_tarantula_susp": 0.0008340283569641367,
            "pseudo_op2_susp": 0.004132231404958678,
            "pseudo_barinel_susp": 0.0008340283569641367
        }
    },
    {
        "name": "tornado.ioloop.IOLoop._run_callback#754",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop._run_callback(self, callback)",
        "snippet": "    def _run_callback(self, callback):\n        \"\"\"Runs a callback with error handling.\n\n        For use in subclasses.\n        \"\"\"\n        try:\n            ret = callback()\n            if ret is not None:\n                from tornado import gen\n                # Functions that return Futures typically swallow all\n                # exceptions and store them in the Future.  If a Future\n                # makes it out to the IOLoop, ensure its exception (if any)\n                # gets logged too.\n                try:\n                    ret = gen.convert_yielded(ret)\n                except gen.BadYieldError:\n                    # It's not unusual for add_callback to be used with\n                    # methods returning a non-None and non-yieldable\n                    # result, which should just be ignored.\n                    pass\n                else:\n                    self.add_future(ret, self._discard_future_result)\n        except Exception:\n            self.handle_callback_exception(callback)",
        "begin_line": 754,
        "end_line": 777,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001968503937007874,
            "pseudo_dstar_susp": 0.00273224043715847,
            "pseudo_tarantula_susp": 0.0009267840593141798,
            "pseudo_op2_susp": 0.00273224043715847,
            "pseudo_barinel_susp": 0.0009267840593141798
        }
    },
    {
        "name": "tornado.ioloop.IOLoop._discard_future_result#779",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop._discard_future_result(self, future)",
        "snippet": "    def _discard_future_result(self, future):\n        \"\"\"Avoid unhandled-exception warnings from spawned coroutines.\"\"\"\n        future.result()",
        "begin_line": 779,
        "end_line": 781,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.handle_callback_exception#783",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.handle_callback_exception(self, callback)",
        "snippet": "    def handle_callback_exception(self, callback):\n        \"\"\"This method is called whenever a callback run by the `IOLoop`\n        throws an exception.\n\n        By default simply logs the exception as an error.  Subclasses\n        may override this method to customize reporting of exceptions.\n\n        The exception itself is not passed explicitly, but is available\n        in `sys.exc_info`.\n        \"\"\"\n        app_log.error(\"Exception in callback %r\", callback, exc_info=True)",
        "begin_line": 783,
        "end_line": 793,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.split_fd#795",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.split_fd(self, fd)",
        "snippet": "    def split_fd(self, fd):\n        \"\"\"Returns an (fd, obj) pair from an ``fd`` parameter.\n\n        We accept both raw file descriptors and file-like objects as\n        input to `add_handler` and related methods.  When a file-like\n        object is passed, we must retain the object itself so we can\n        close it correctly when the `IOLoop` shuts down, but the\n        poller interfaces favor file descriptors (they will accept\n        file-like objects and call ``fileno()`` for you, but they\n        always return the descriptor itself).\n\n        This method is provided for use by `IOLoop` subclasses and should\n        not generally be used by application code.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        try:\n            return fd.fileno(), fd\n        except AttributeError:\n            return fd, fd",
        "begin_line": 795,
        "end_line": 814,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.045454545454545456,
            "pseudo_dstar_susp": 0.03333333333333333,
            "pseudo_tarantula_susp": 0.005235602094240838,
            "pseudo_op2_susp": 0.03333333333333333,
            "pseudo_barinel_susp": 0.005235602094240838
        }
    },
    {
        "name": "tornado.ioloop.IOLoop.close_fd#816",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.IOLoop",
        "signature": "tornado.ioloop.IOLoop.close_fd(self, fd)",
        "snippet": "    def close_fd(self, fd):\n        \"\"\"Utility method to close an ``fd``.\n\n        If ``fd`` is a file-like object, we close it directly; otherwise\n        we use `os.close`.\n\n        This method is provided for use by `IOLoop` subclasses (in\n        implementations of ``IOLoop.close(all_fds=True)`` and should\n        not generally be used by application code.\n\n        .. versionadded:: 4.0\n        \"\"\"\n        try:\n            try:\n                fd.close()\n            except AttributeError:\n                os.close(fd)\n        except OSError:\n            pass",
        "begin_line": 816,
        "end_line": 834,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.14285714285714285,
            "pseudo_dstar_susp": 0.003105590062111801,
            "pseudo_tarantula_susp": 0.006993006993006993,
            "pseudo_op2_susp": 0.003105590062111801,
            "pseudo_barinel_susp": 0.006993006993006993
        }
    },
    {
        "name": "tornado.ioloop.PeriodicCallback.__init__#1173",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.PeriodicCallback",
        "signature": "tornado.ioloop.PeriodicCallback.__init__(self, callback, callback_time)",
        "snippet": "    def __init__(self, callback, callback_time):\n        self.callback = callback\n        if callback_time <= 0:\n            raise ValueError(\"Periodic callback must have a positive callback_time\")\n        self.callback_time = callback_time\n        self._running = False\n        self._timeout = None",
        "begin_line": 1173,
        "end_line": 1179,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.ioloop.PeriodicCallback.start#1181",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.PeriodicCallback",
        "signature": "tornado.ioloop.PeriodicCallback.start(self)",
        "snippet": "    def start(self):\n        \"\"\"Starts the timer.\"\"\"\n        # Looking up the IOLoop here allows to first instantiate the\n        # PeriodicCallback in another thread, then start it using\n        # IOLoop.add_callback().\n        self.io_loop = IOLoop.current()\n        self._running = True\n        self._next_timeout = self.io_loop.time()\n        self._schedule_next()",
        "begin_line": 1181,
        "end_line": 1189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.ioloop.PeriodicCallback._run#1205",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.PeriodicCallback",
        "signature": "tornado.ioloop.PeriodicCallback._run(self)",
        "snippet": "    def _run(self):\n        if not self._running:\n            return\n        try:\n            return self.callback()\n        except Exception:\n            self.io_loop.handle_callback_exception(self.callback)\n        finally:\n            self._schedule_next()",
        "begin_line": 1205,
        "end_line": 1213,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.ioloop.PeriodicCallback._schedule_next#1215",
        "src_path": "tornado/ioloop.py",
        "class_name": "tornado.ioloop.PeriodicCallback",
        "signature": "tornado.ioloop.PeriodicCallback._schedule_next(self)",
        "snippet": "    def _schedule_next(self):\n        if self._running:\n            current_time = self.io_loop.time()\n\n            if self._next_timeout <= current_time:\n                callback_time_sec = self.callback_time / 1000.0\n                self._next_timeout += (math.floor((current_time - self._next_timeout) /\n                                                  callback_time_sec) + 1) * callback_time_sec\n\n            self._timeout = self.io_loop.add_timeout(self._next_timeout, self._run)",
        "begin_line": 1215,
        "end_line": 1224,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth._auth_future_to_callback#102",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth",
        "signature": "tornado.auth._auth_future_to_callback(callback, future)",
        "snippet": "def _auth_future_to_callback(callback, future):\n    try:\n        result = future.result()\n    except AuthError as e:\n        gen_log.warning(str(e))\n        result = None\n    callback(result)",
        "begin_line": 102,
        "end_line": 108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth._auth_return_future#111",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth",
        "signature": "tornado.auth._auth_return_future(f)",
        "snippet": "def _auth_return_future(f):\n    \"\"\"Similar to tornado.concurrent.return_future, but uses the auth\n    module's legacy callback interface.\n\n    Note that when using this decorator the ``callback`` parameter\n    inside the function will actually be a future.\n\n    .. deprecated:: 5.1\n       Will be removed in 6.0.\n    \"\"\"\n    replacer = ArgReplacer(f, 'callback')\n\n    @functools.wraps(f)\n    def wrapper(*args, **kwargs):\n        future = Future()\n        callback, args, kwargs = replacer.replace(future, args, kwargs)\n        if callback is not None:\n            warnings.warn(\"callback arguments are deprecated, use the returned Future instead\",\n                          DeprecationWarning)\n            future.add_done_callback(\n                functools.partial(_auth_future_to_callback, callback))\n\n        def handle_exception(typ, value, tb):\n            if future.done():\n                return False\n            else:\n                future_set_exc_info(future, (typ, value, tb))\n                return True\n        with ExceptionStackContext(handle_exception):\n            f(*args, **kwargs)\n        return future\n    return wrapper",
        "begin_line": 111,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017295053614666206,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.wrapper#124",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth",
        "signature": "tornado.auth.wrapper(*args, **kwargs)",
        "snippet": "    def wrapper(*args, **kwargs):\n        future = Future()\n        callback, args, kwargs = replacer.replace(future, args, kwargs)\n        if callback is not None:\n            warnings.warn(\"callback arguments are deprecated, use the returned Future instead\",\n                          DeprecationWarning)\n            future.add_done_callback(\n                functools.partial(_auth_future_to_callback, callback))\n\n        def handle_exception(typ, value, tb):\n            if future.done():\n                return False\n            else:\n                future_set_exc_info(future, (typ, value, tb))\n                return True\n        with ExceptionStackContext(handle_exception):\n            f(*args, **kwargs)\n        return future",
        "begin_line": 124,
        "end_line": 141,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.handle_exception#133",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth",
        "signature": "tornado.auth.handle_exception(typ, value, tb)",
        "snippet": "        def handle_exception(typ, value, tb):\n            if future.done():\n                return False\n            else:\n                future_set_exc_info(future, (typ, value, tb))\n                return True",
        "begin_line": 133,
        "end_line": 138,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017295053614666206,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OpenIdMixin.authenticate_redirect#153",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OpenIdMixin",
        "signature": "tornado.auth.OpenIdMixin.authenticate_redirect(self, callback_uri=None, ax_attrs=['name', 'email', 'language', 'username'], callback=None)",
        "snippet": "    def authenticate_redirect(self, callback_uri=None,\n                              ax_attrs=[\"name\", \"email\", \"language\", \"username\"],\n                              callback=None):\n        \"\"\"Redirects to the authentication URL for this service.\n\n        After authentication, the service will redirect back to the given\n        callback URI with additional parameters including ``openid.mode``.\n\n        We request the given attributes for the authenticated user by\n        default (name, email, language, and username). If you don't need\n        all those attributes for your app, you can request fewer with\n        the ax_attrs keyword argument.\n\n        .. versionchanged:: 3.1\n           Returns a `.Future` and takes an optional callback.  These are\n           not strictly necessary as this method is synchronous,\n           but they are supplied for consistency with\n           `OAuthMixin.authorize_redirect`.\n\n        .. deprecated:: 5.1\n\n           The ``callback`` argument and returned awaitable will be removed\n           in Tornado 6.0; this will be an ordinary synchronous function.\n        \"\"\"\n        callback_uri = callback_uri or self.request.uri\n        args = self._openid_args(callback_uri, ax_attrs=ax_attrs)\n        self.redirect(self._OPENID_ENDPOINT + \"?\" + urllib_parse.urlencode(args))\n        callback()",
        "begin_line": 153,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OpenIdMixin.get_authenticated_user#183",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OpenIdMixin",
        "signature": "tornado.auth.OpenIdMixin.get_authenticated_user(self, callback, http_client=None)",
        "snippet": "    def get_authenticated_user(self, callback, http_client=None):\n        \"\"\"Fetches the authenticated user data upon redirect.\n\n        This method should be called by the handler that receives the\n        redirect from the `authenticate_redirect()` method (which is\n        often the same as the one that calls it; in that case you would\n        call `get_authenticated_user` if the ``openid.mode`` parameter\n        is present and `authenticate_redirect` if it is not).\n\n        The result of this method will generally be used to set a cookie.\n\n        .. deprecated:: 5.1\n\n           The ``callback`` argument is deprecated and will be removed in 6.0.\n           Use the returned awaitable object instead.\n        \"\"\"\n        # Verify the OpenID response via direct request to the OP\n        args = dict((k, v[-1]) for k, v in self.request.arguments.items())\n        args[\"openid.mode\"] = u\"check_authentication\"\n        url = self._OPENID_ENDPOINT\n        if http_client is None:\n            http_client = self.get_auth_http_client()\n        http_client.fetch(url, functools.partial(\n            self._on_authentication_verified, callback),\n            method=\"POST\", body=urllib_parse.urlencode(args))",
        "begin_line": 183,
        "end_line": 207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OpenIdMixin._openid_args#209",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OpenIdMixin",
        "signature": "tornado.auth.OpenIdMixin._openid_args(self, callback_uri, ax_attrs=[], oauth_scope=None)",
        "snippet": "    def _openid_args(self, callback_uri, ax_attrs=[], oauth_scope=None):\n        url = urlparse.urljoin(self.request.full_url(), callback_uri)\n        args = {\n            \"openid.ns\": \"http://specs.openid.net/auth/2.0\",\n            \"openid.claimed_id\":\n            \"http://specs.openid.net/auth/2.0/identifier_select\",\n            \"openid.identity\":\n            \"http://specs.openid.net/auth/2.0/identifier_select\",\n            \"openid.return_to\": url,\n            \"openid.realm\": urlparse.urljoin(url, '/'),\n            \"openid.mode\": \"checkid_setup\",\n        }\n        if ax_attrs:\n            args.update({\n                \"openid.ns.ax\": \"http://openid.net/srv/ax/1.0\",\n                \"openid.ax.mode\": \"fetch_request\",\n            })\n            ax_attrs = set(ax_attrs)\n            required = []\n            if \"name\" in ax_attrs:\n                ax_attrs -= set([\"name\", \"firstname\", \"fullname\", \"lastname\"])\n                required += [\"firstname\", \"fullname\", \"lastname\"]\n                args.update({\n                    \"openid.ax.type.firstname\":\n                    \"http://axschema.org/namePerson/first\",\n                    \"openid.ax.type.fullname\":\n                    \"http://axschema.org/namePerson\",\n                    \"openid.ax.type.lastname\":\n                    \"http://axschema.org/namePerson/last\",\n                })\n            known_attrs = {\n                \"email\": \"http://axschema.org/contact/email\",\n                \"language\": \"http://axschema.org/pref/language\",\n                \"username\": \"http://axschema.org/namePerson/friendly\",\n            }\n            for name in ax_attrs:\n                args[\"openid.ax.type.\" + name] = known_attrs[name]\n                required.append(name)\n            args[\"openid.ax.required\"] = \",\".join(required)\n        if oauth_scope:\n            args.update({\n                \"openid.ns.oauth\":\n                \"http://specs.openid.net/extensions/oauth/1.0\",\n                \"openid.oauth.consumer\": self.request.host.split(\":\")[0],\n                \"openid.oauth.scope\": oauth_scope,\n            })\n        return args",
        "begin_line": 209,
        "end_line": 255,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OpenIdMixin._on_authentication_verified#257",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OpenIdMixin",
        "signature": "tornado.auth.OpenIdMixin._on_authentication_verified(self, future, response)",
        "snippet": "    def _on_authentication_verified(self, future, response):\n        if response.error or b\"is_valid:true\" not in response.body:\n            future.set_exception(AuthError(\n                \"Invalid OpenID response: %s\" % (response.error or\n                                                 response.body)))\n            return\n\n        # Make sure we got back at least an email from attribute exchange\n        ax_ns = None\n        for name in self.request.arguments:\n            if name.startswith(\"openid.ns.\") and \\\n                    self.get_argument(name) == u\"http://openid.net/srv/ax/1.0\":\n                ax_ns = name[10:]\n                break\n\n        def get_ax_arg(uri):\n            if not ax_ns:\n                return u\"\"\n            prefix = \"openid.\" + ax_ns + \".type.\"\n            ax_name = None\n            for name in self.request.arguments.keys():\n                if self.get_argument(name) == uri and name.startswith(prefix):\n                    part = name[len(prefix):]\n                    ax_name = \"openid.\" + ax_ns + \".value.\" + part\n                    break\n            if not ax_name:\n                return u\"\"\n            return self.get_argument(ax_name, u\"\")\n\n        email = get_ax_arg(\"http://axschema.org/contact/email\")\n        name = get_ax_arg(\"http://axschema.org/namePerson\")\n        first_name = get_ax_arg(\"http://axschema.org/namePerson/first\")\n        last_name = get_ax_arg(\"http://axschema.org/namePerson/last\")\n        username = get_ax_arg(\"http://axschema.org/namePerson/friendly\")\n        locale = get_ax_arg(\"http://axschema.org/pref/language\").lower()\n        user = dict()\n        name_parts = []\n        if first_name:\n            user[\"first_name\"] = first_name\n            name_parts.append(first_name)\n        if last_name:\n            user[\"last_name\"] = last_name\n            name_parts.append(last_name)\n        if name:\n            user[\"name\"] = name\n        elif name_parts:\n            user[\"name\"] = u\" \".join(name_parts)\n        elif email:\n            user[\"name\"] = email.split(\"@\")[0]\n        if email:\n            user[\"email\"] = email\n        if locale:\n            user[\"locale\"] = locale\n        if username:\n            user[\"username\"] = username\n        claimed_id = self.get_argument(\"openid.claimed_id\", None)\n        if claimed_id:\n            user[\"claimed_id\"] = claimed_id\n        future_set_result_unless_cancelled(future, user)",
        "begin_line": 257,
        "end_line": 315,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OpenIdMixin.get_ax_arg#272",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OpenIdMixin",
        "signature": "tornado.auth.OpenIdMixin.get_ax_arg(uri)",
        "snippet": "        def get_ax_arg(uri):\n            if not ax_ns:\n                return u\"\"\n            prefix = \"openid.\" + ax_ns + \".type.\"\n            ax_name = None\n            for name in self.request.arguments.keys():\n                if self.get_argument(name) == uri and name.startswith(prefix):\n                    part = name[len(prefix):]\n                    ax_name = \"openid.\" + ax_ns + \".value.\" + part\n                    break\n            if not ax_name:\n                return u\"\"\n            return self.get_argument(ax_name, u\"\")",
        "begin_line": 272,
        "end_line": 284,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OAuthMixin.authorize_redirect#343",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuthMixin",
        "signature": "tornado.auth.OAuthMixin.authorize_redirect(self, callback_uri=None, extra_params=None, http_client=None, callback=None)",
        "snippet": "    def authorize_redirect(self, callback_uri=None, extra_params=None,\n                           http_client=None, callback=None):\n        \"\"\"Redirects the user to obtain OAuth authorization for this service.\n\n        The ``callback_uri`` may be omitted if you have previously\n        registered a callback URI with the third-party service. For\n        some services, you must use a previously-registered callback\n        URI and cannot specify a callback via this method.\n\n        This method sets a cookie called ``_oauth_request_token`` which is\n        subsequently used (and cleared) in `get_authenticated_user` for\n        security purposes.\n\n        This method is asynchronous and must be called with ``await``\n        or ``yield`` (This is different from other ``auth*_redirect``\n        methods defined in this module). It calls\n        `.RequestHandler.finish` for you so you should not write any\n        other response after it returns.\n\n        .. versionchanged:: 3.1\n           Now returns a `.Future` and takes an optional callback, for\n           compatibility with `.gen.coroutine`.\n\n        .. deprecated:: 5.1\n\n           The ``callback`` argument is deprecated and will be removed in 6.0.\n           Use the returned awaitable object instead.\n\n        \"\"\"\n        if callback_uri and getattr(self, \"_OAUTH_NO_CALLBACKS\", False):\n            raise Exception(\"This service does not support oauth_callback\")\n        if http_client is None:\n            http_client = self.get_auth_http_client()\n        if getattr(self, \"_OAUTH_VERSION\", \"1.0a\") == \"1.0a\":\n            http_client.fetch(\n                self._oauth_request_token_url(callback_uri=callback_uri,\n                                              extra_params=extra_params),\n                functools.partial(\n                    self._on_request_token,\n                    self._OAUTH_AUTHORIZE_URL,\n                    callback_uri,\n                    callback))\n        else:\n            http_client.fetch(\n                self._oauth_request_token_url(),\n                functools.partial(\n                    self._on_request_token, self._OAUTH_AUTHORIZE_URL,\n                    callback_uri,\n                    callback))",
        "begin_line": 343,
        "end_line": 391,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OAuthMixin.get_authenticated_user#394",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuthMixin",
        "signature": "tornado.auth.OAuthMixin.get_authenticated_user(self, callback, http_client=None)",
        "snippet": "    def get_authenticated_user(self, callback, http_client=None):\n        \"\"\"Gets the OAuth authorized user and access token.\n\n        This method should be called from the handler for your\n        OAuth callback URL to complete the registration process. We run the\n        callback with the authenticated user dictionary.  This dictionary\n        will contain an ``access_key`` which can be used to make authorized\n        requests to this service on behalf of the user.  The dictionary will\n        also contain other fields such as ``name``, depending on the service\n        used.\n\n        .. deprecated:: 5.1\n\n           The ``callback`` argument is deprecated and will be removed in 6.0.\n           Use the returned awaitable object instead.\n        \"\"\"\n        future = callback\n        request_key = escape.utf8(self.get_argument(\"oauth_token\"))\n        oauth_verifier = self.get_argument(\"oauth_verifier\", None)\n        request_cookie = self.get_cookie(\"_oauth_request_token\")\n        if not request_cookie:\n            future.set_exception(AuthError(\n                \"Missing OAuth request token cookie\"))\n            return\n        self.clear_cookie(\"_oauth_request_token\")\n        cookie_key, cookie_secret = [\n            base64.b64decode(escape.utf8(i)) for i in request_cookie.split(\"|\")]\n        if cookie_key != request_key:\n            future.set_exception(AuthError(\n                \"Request token does not match cookie\"))\n            return\n        token = dict(key=cookie_key, secret=cookie_secret)\n        if oauth_verifier:\n            token[\"verifier\"] = oauth_verifier\n        if http_client is None:\n            http_client = self.get_auth_http_client()\n        http_client.fetch(self._oauth_access_token_url(token),\n                          functools.partial(self._on_access_token, callback))",
        "begin_line": 394,
        "end_line": 431,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OAuthMixin._oauth_request_token_url#433",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuthMixin",
        "signature": "tornado.auth.OAuthMixin._oauth_request_token_url(self, callback_uri=None, extra_params=None)",
        "snippet": "    def _oauth_request_token_url(self, callback_uri=None, extra_params=None):\n        consumer_token = self._oauth_consumer_token()\n        url = self._OAUTH_REQUEST_TOKEN_URL\n        args = dict(\n            oauth_consumer_key=escape.to_basestring(consumer_token[\"key\"]),\n            oauth_signature_method=\"HMAC-SHA1\",\n            oauth_timestamp=str(int(time.time())),\n            oauth_nonce=escape.to_basestring(binascii.b2a_hex(uuid.uuid4().bytes)),\n            oauth_version=\"1.0\",\n        )\n        if getattr(self, \"_OAUTH_VERSION\", \"1.0a\") == \"1.0a\":\n            if callback_uri == \"oob\":\n                args[\"oauth_callback\"] = \"oob\"\n            elif callback_uri:\n                args[\"oauth_callback\"] = urlparse.urljoin(\n                    self.request.full_url(), callback_uri)\n            if extra_params:\n                args.update(extra_params)\n            signature = _oauth10a_signature(consumer_token, \"GET\", url, args)\n        else:\n            signature = _oauth_signature(consumer_token, \"GET\", url, args)\n\n        args[\"oauth_signature\"] = signature\n        return url + \"?\" + urllib_parse.urlencode(args)",
        "begin_line": 433,
        "end_line": 456,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OAuthMixin._on_request_token#458",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuthMixin",
        "signature": "tornado.auth.OAuthMixin._on_request_token(self, authorize_url, callback_uri, callback, response)",
        "snippet": "    def _on_request_token(self, authorize_url, callback_uri, callback,\n                          response):\n        if response.error:\n            raise Exception(\"Could not get request token: %s\" % response.error)\n        request_token = _oauth_parse_response(response.body)\n        data = (base64.b64encode(escape.utf8(request_token[\"key\"])) + b\"|\" +\n                base64.b64encode(escape.utf8(request_token[\"secret\"])))\n        self.set_cookie(\"_oauth_request_token\", data)\n        args = dict(oauth_token=request_token[\"key\"])\n        if callback_uri == \"oob\":\n            self.finish(authorize_url + \"?\" + urllib_parse.urlencode(args))\n            callback()\n            return\n        elif callback_uri:\n            args[\"oauth_callback\"] = urlparse.urljoin(\n                self.request.full_url(), callback_uri)\n        self.redirect(authorize_url + \"?\" + urllib_parse.urlencode(args))\n        callback()",
        "begin_line": 458,
        "end_line": 475,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001885369532428356,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OAuthMixin._oauth_access_token_url#477",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuthMixin",
        "signature": "tornado.auth.OAuthMixin._oauth_access_token_url(self, request_token)",
        "snippet": "    def _oauth_access_token_url(self, request_token):\n        consumer_token = self._oauth_consumer_token()\n        url = self._OAUTH_ACCESS_TOKEN_URL\n        args = dict(\n            oauth_consumer_key=escape.to_basestring(consumer_token[\"key\"]),\n            oauth_token=escape.to_basestring(request_token[\"key\"]),\n            oauth_signature_method=\"HMAC-SHA1\",\n            oauth_timestamp=str(int(time.time())),\n            oauth_nonce=escape.to_basestring(binascii.b2a_hex(uuid.uuid4().bytes)),\n            oauth_version=\"1.0\",\n        )\n        if \"verifier\" in request_token:\n            args[\"oauth_verifier\"] = request_token[\"verifier\"]\n\n        if getattr(self, \"_OAUTH_VERSION\", \"1.0a\") == \"1.0a\":\n            signature = _oauth10a_signature(consumer_token, \"GET\", url, args,\n                                            request_token)\n        else:\n            signature = _oauth_signature(consumer_token, \"GET\", url, args,\n                                         request_token)\n\n        args[\"oauth_signature\"] = signature\n        return url + \"?\" + urllib_parse.urlencode(args)",
        "begin_line": 477,
        "end_line": 499,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OAuthMixin._on_access_token#501",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuthMixin",
        "signature": "tornado.auth.OAuthMixin._on_access_token(self, future, response)",
        "snippet": "    def _on_access_token(self, future, response):\n        if response.error:\n            future.set_exception(AuthError(\"Could not fetch access token\"))\n            return\n\n        access_token = _oauth_parse_response(response.body)\n        fut = self._oauth_get_user_future(access_token)\n        fut = gen.convert_yielded(fut)\n        fut.add_done_callback(\n            functools.partial(self._on_oauth_get_user, access_token, future))",
        "begin_line": 501,
        "end_line": 510,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OAuthMixin._oauth_get_user_future#520",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuthMixin",
        "signature": "tornado.auth.OAuthMixin._oauth_get_user_future(self, access_token, callback)",
        "snippet": "    def _oauth_get_user_future(self, access_token, callback):\n        \"\"\"Subclasses must override this to get basic information about the\n        user.\n\n        Should return a `.Future` whose result is a dictionary\n        containing information about the user, which may have been\n        retrieved by using ``access_token`` to make a request to the\n        service.\n\n        The access token will be added to the returned dictionary to make\n        the result of `get_authenticated_user`.\n\n        For backwards compatibility, the callback-based ``_oauth_get_user``\n        method is also supported.\n\n        .. versionchanged:: 5.1\n\n           Subclasses may also define this method with ``async def``.\n\n        .. deprecated:: 5.1\n\n           The ``_oauth_get_user`` fallback is deprecated and support for it\n           will be removed in 6.0.\n        \"\"\"\n        warnings.warn(\"_oauth_get_user is deprecated, override _oauth_get_user_future instead\",\n                      DeprecationWarning)\n        # By default, call the old-style _oauth_get_user, but new code\n        # should override this method instead.\n        self._oauth_get_user(access_token, callback)",
        "begin_line": 520,
        "end_line": 548,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OAuthMixin._on_oauth_get_user#553",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuthMixin",
        "signature": "tornado.auth.OAuthMixin._on_oauth_get_user(self, access_token, future, user_future)",
        "snippet": "    def _on_oauth_get_user(self, access_token, future, user_future):\n        if user_future.exception() is not None:\n            future.set_exception(user_future.exception())\n            return\n        user = user_future.result()\n        if not user:\n            future.set_exception(AuthError(\"Error getting user\"))\n            return\n        user[\"access_token\"] = access_token\n        future_set_result_unless_cancelled(future, user)",
        "begin_line": 553,
        "end_line": 562,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OAuthMixin._oauth_request_parameters#564",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuthMixin",
        "signature": "tornado.auth.OAuthMixin._oauth_request_parameters(self, url, access_token, parameters={}, method='GET')",
        "snippet": "    def _oauth_request_parameters(self, url, access_token, parameters={},\n                                  method=\"GET\"):\n        \"\"\"Returns the OAuth parameters as a dict for the given request.\n\n        parameters should include all POST arguments and query string arguments\n        that will be sent with the request.\n        \"\"\"\n        consumer_token = self._oauth_consumer_token()\n        base_args = dict(\n            oauth_consumer_key=escape.to_basestring(consumer_token[\"key\"]),\n            oauth_token=escape.to_basestring(access_token[\"key\"]),\n            oauth_signature_method=\"HMAC-SHA1\",\n            oauth_timestamp=str(int(time.time())),\n            oauth_nonce=escape.to_basestring(binascii.b2a_hex(uuid.uuid4().bytes)),\n            oauth_version=\"1.0\",\n        )\n        args = {}\n        args.update(base_args)\n        args.update(parameters)\n        if getattr(self, \"_OAUTH_VERSION\", \"1.0a\") == \"1.0a\":\n            signature = _oauth10a_signature(consumer_token, method, url, args,\n                                            access_token)\n        else:\n            signature = _oauth_signature(consumer_token, method, url, args,\n                                         access_token)\n        base_args[\"oauth_signature\"] = escape.to_basestring(signature)\n        return base_args",
        "begin_line": 564,
        "end_line": 590,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OAuthMixin.get_auth_http_client#592",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuthMixin",
        "signature": "tornado.auth.OAuthMixin.get_auth_http_client(self)",
        "snippet": "    def get_auth_http_client(self):\n        \"\"\"Returns the `.AsyncHTTPClient` instance to be used for auth requests.\n\n        May be overridden by subclasses to use an HTTP client other than\n        the default.\n        \"\"\"\n        return httpclient.AsyncHTTPClient()",
        "begin_line": 592,
        "end_line": 598,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OAuth2Mixin.authorize_redirect#613",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuth2Mixin",
        "signature": "tornado.auth.OAuth2Mixin.authorize_redirect(self, redirect_uri=None, client_id=None, client_secret=None, extra_params=None, callback=None, scope=None, response_type='code')",
        "snippet": "    def authorize_redirect(self, redirect_uri=None, client_id=None,\n                           client_secret=None, extra_params=None,\n                           callback=None, scope=None, response_type=\"code\"):\n        \"\"\"Redirects the user to obtain OAuth authorization for this service.\n\n        Some providers require that you register a redirect URL with\n        your application instead of passing one via this method. You\n        should call this method to log the user in, and then call\n        ``get_authenticated_user`` in the handler for your\n        redirect URL to complete the authorization process.\n\n        .. versionchanged:: 3.1\n           Returns a `.Future` and takes an optional callback.  These are\n           not strictly necessary as this method is synchronous,\n           but they are supplied for consistency with\n           `OAuthMixin.authorize_redirect`.\n\n        .. deprecated:: 5.1\n\n           The ``callback`` argument and returned awaitable will be removed\n           in Tornado 6.0; this will be an ordinary synchronous function.\n        \"\"\"\n        args = {\n            \"redirect_uri\": redirect_uri,\n            \"client_id\": client_id,\n            \"response_type\": response_type\n        }\n        if extra_params:\n            args.update(extra_params)\n        if scope:\n            args['scope'] = ' '.join(scope)\n        self.redirect(\n            url_concat(self._OAUTH_AUTHORIZE_URL, args))\n        callback()",
        "begin_line": 613,
        "end_line": 646,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OAuth2Mixin._oauth_request_token_url#648",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuth2Mixin",
        "signature": "tornado.auth.OAuth2Mixin._oauth_request_token_url(self, redirect_uri=None, client_id=None, client_secret=None, code=None, extra_params=None)",
        "snippet": "    def _oauth_request_token_url(self, redirect_uri=None, client_id=None,\n                                 client_secret=None, code=None,\n                                 extra_params=None):\n        url = self._OAUTH_ACCESS_TOKEN_URL\n        args = dict(\n            redirect_uri=redirect_uri,\n            code=code,\n            client_id=client_id,\n            client_secret=client_secret,\n        )\n        if extra_params:\n            args.update(extra_params)\n        return url_concat(url, args)",
        "begin_line": 648,
        "end_line": 660,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OAuth2Mixin.oauth2_request#663",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuth2Mixin",
        "signature": "tornado.auth.OAuth2Mixin.oauth2_request(self, url, callback, access_token=None, post_args=None, **args)",
        "snippet": "    def oauth2_request(self, url, callback, access_token=None,\n                       post_args=None, **args):\n        \"\"\"Fetches the given URL auth an OAuth2 access token.\n\n        If the request is a POST, ``post_args`` should be provided. Query\n        string arguments should be given as keyword arguments.\n\n        Example usage:\n\n        ..testcode::\n\n            class MainHandler(tornado.web.RequestHandler,\n                              tornado.auth.FacebookGraphMixin):\n                @tornado.web.authenticated\n                @tornado.gen.coroutine\n                def get(self):\n                    new_entry = yield self.oauth2_request(\n                        \"https://graph.facebook.com/me/feed\",\n                        post_args={\"message\": \"I am posting from my Tornado application!\"},\n                        access_token=self.current_user[\"access_token\"])\n\n                    if not new_entry:\n                        # Call failed; perhaps missing permission?\n                        yield self.authorize_redirect()\n                        return\n                    self.finish(\"Posted a message!\")\n\n        .. testoutput::\n           :hide:\n\n        .. versionadded:: 4.3\n\n        .. deprecated:: 5.1\n\n           The ``callback`` argument is deprecated and will be removed in 6.0.\n           Use the returned awaitable object instead.\n        \"\"\"\n        all_args = {}\n        if access_token:\n            all_args[\"access_token\"] = access_token\n            all_args.update(args)\n\n        if all_args:\n            url += \"?\" + urllib_parse.urlencode(all_args)\n        callback = functools.partial(self._on_oauth2_request, callback)\n        http = self.get_auth_http_client()\n        if post_args is not None:\n            http.fetch(url, method=\"POST\", body=urllib_parse.urlencode(post_args),\n                       callback=callback)\n        else:\n            http.fetch(url, callback=callback)",
        "begin_line": 663,
        "end_line": 713,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OAuth2Mixin._on_oauth2_request#715",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuth2Mixin",
        "signature": "tornado.auth.OAuth2Mixin._on_oauth2_request(self, future, response)",
        "snippet": "    def _on_oauth2_request(self, future, response):\n        if response.error:\n            future.set_exception(AuthError(\"Error response %s fetching %s\" %\n                                           (response.error, response.request.url)))\n            return\n\n        future_set_result_unless_cancelled(future, escape.json_decode(response.body))",
        "begin_line": 715,
        "end_line": 721,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.OAuth2Mixin.get_auth_http_client#723",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.OAuth2Mixin",
        "signature": "tornado.auth.OAuth2Mixin.get_auth_http_client(self)",
        "snippet": "    def get_auth_http_client(self):\n        \"\"\"Returns the `.AsyncHTTPClient` instance to be used for auth requests.\n\n        May be overridden by subclasses to use an HTTP client other than\n        the default.\n\n        .. versionadded:: 4.3\n        \"\"\"\n        return httpclient.AsyncHTTPClient()",
        "begin_line": 723,
        "end_line": 731,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.TwitterMixin.twitter_request#798",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.TwitterMixin",
        "signature": "tornado.auth.TwitterMixin.twitter_request(self, path, callback=None, access_token=None, post_args=None, **args)",
        "snippet": "    def twitter_request(self, path, callback=None, access_token=None,\n                        post_args=None, **args):\n        \"\"\"Fetches the given API path, e.g., ``statuses/user_timeline/btaylor``\n\n        The path should not include the format or API version number.\n        (we automatically use JSON format and API version 1).\n\n        If the request is a POST, ``post_args`` should be provided. Query\n        string arguments should be given as keyword arguments.\n\n        All the Twitter methods are documented at http://dev.twitter.com/\n\n        Many methods require an OAuth access token which you can\n        obtain through `~OAuthMixin.authorize_redirect` and\n        `~OAuthMixin.get_authenticated_user`. The user returned through that\n        process includes an 'access_token' attribute that can be used\n        to make authenticated requests via this method. Example\n        usage:\n\n        .. testcode::\n\n            class MainHandler(tornado.web.RequestHandler,\n                              tornado.auth.TwitterMixin):\n                @tornado.web.authenticated\n                @tornado.gen.coroutine\n                def get(self):\n                    new_entry = yield self.twitter_request(\n                        \"/statuses/update\",\n                        post_args={\"status\": \"Testing Tornado Web Server\"},\n                        access_token=self.current_user[\"access_token\"])\n                    if not new_entry:\n                        # Call failed; perhaps missing permission?\n                        yield self.authorize_redirect()\n                        return\n                    self.finish(\"Posted a message!\")\n\n        .. testoutput::\n           :hide:\n\n        .. deprecated:: 5.1\n\n           The ``callback`` argument is deprecated and will be removed in 6.0.\n           Use the returned awaitable object instead.\n        \"\"\"\n        if path.startswith('http:') or path.startswith('https:'):\n            # Raw urls are useful for e.g. search which doesn't follow the\n            # usual pattern: http://search.twitter.com/search.json\n            url = path\n        else:\n            url = self._TWITTER_BASE_URL + path + \".json\"\n        # Add the OAuth resource request signature if we have credentials\n        if access_token:\n            all_args = {}\n            all_args.update(args)\n            all_args.update(post_args or {})\n            method = \"POST\" if post_args is not None else \"GET\"\n            oauth = self._oauth_request_parameters(\n                url, access_token, all_args, method=method)\n            args.update(oauth)\n        if args:\n            url += \"?\" + urllib_parse.urlencode(args)\n        http = self.get_auth_http_client()\n        http_callback = functools.partial(self._on_twitter_request, callback)\n        if post_args is not None:\n            http.fetch(url, method=\"POST\", body=urllib_parse.urlencode(post_args),\n                       callback=http_callback)\n        else:\n            http.fetch(url, callback=http_callback)",
        "begin_line": 798,
        "end_line": 865,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.TwitterMixin._on_twitter_request#867",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.TwitterMixin",
        "signature": "tornado.auth.TwitterMixin._on_twitter_request(self, future, response)",
        "snippet": "    def _on_twitter_request(self, future, response):\n        if response.error:\n            future.set_exception(AuthError(\n                \"Error response %s fetching %s\" % (response.error,\n                                                   response.request.url)))\n            return\n        future_set_result_unless_cancelled(future, escape.json_decode(response.body))",
        "begin_line": 867,
        "end_line": 873,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.TwitterMixin._oauth_consumer_token#875",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.TwitterMixin",
        "signature": "tornado.auth.TwitterMixin._oauth_consumer_token(self)",
        "snippet": "    def _oauth_consumer_token(self):\n        self.require_setting(\"twitter_consumer_key\", \"Twitter OAuth\")\n        self.require_setting(\"twitter_consumer_secret\", \"Twitter OAuth\")\n        return dict(\n            key=self.settings[\"twitter_consumer_key\"],\n            secret=self.settings[\"twitter_consumer_secret\"])",
        "begin_line": 875,
        "end_line": 880,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001836884643644379,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.TwitterMixin._oauth_get_user_future#883",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.TwitterMixin",
        "signature": "tornado.auth.TwitterMixin._oauth_get_user_future(self, access_token)",
        "snippet": "    def _oauth_get_user_future(self, access_token):\n        user = yield self.twitter_request(\n            \"/account/verify_credentials\",\n            access_token=access_token)\n        if user:\n            user[\"username\"] = user[\"screen_name\"]\n        raise gen.Return(user)",
        "begin_line": 883,
        "end_line": 889,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.GoogleOAuth2Mixin.get_authenticated_user#917",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.GoogleOAuth2Mixin",
        "signature": "tornado.auth.GoogleOAuth2Mixin.get_authenticated_user(self, redirect_uri, code, callback)",
        "snippet": "    def get_authenticated_user(self, redirect_uri, code, callback):\n        \"\"\"Handles the login for the Google user, returning an access token.\n\n        The result is a dictionary containing an ``access_token`` field\n        ([among others](https://developers.google.com/identity/protocols/OAuth2WebServer#handlingtheresponse)).\n        Unlike other ``get_authenticated_user`` methods in this package,\n        this method does not return any additional information about the user.\n        The returned access token can be used with `OAuth2Mixin.oauth2_request`\n        to request additional information (perhaps from\n        ``https://www.googleapis.com/oauth2/v2/userinfo``)\n\n        Example usage:\n\n        .. testcode::\n\n            class GoogleOAuth2LoginHandler(tornado.web.RequestHandler,\n                                           tornado.auth.GoogleOAuth2Mixin):\n                @tornado.gen.coroutine\n                def get(self):\n                    if self.get_argument('code', False):\n                        access = yield self.get_authenticated_user(\n                            redirect_uri='http://your.site.com/auth/google',\n                            code=self.get_argument('code'))\n                        user = yield self.oauth2_request(\n                            \"https://www.googleapis.com/oauth2/v1/userinfo\",\n                            access_token=access[\"access_token\"])\n                        # Save the user and access token with\n                        # e.g. set_secure_cookie.\n                    else:\n                        yield self.authorize_redirect(\n                            redirect_uri='http://your.site.com/auth/google',\n                            client_id=self.settings['google_oauth']['key'],\n                            scope=['profile', 'email'],\n                            response_type='code',\n                            extra_params={'approval_prompt': 'auto'})\n\n        .. testoutput::\n           :hide:\n\n        .. deprecated:: 5.1\n\n           The ``callback`` argument is deprecated and will be removed in 6.0.\n           Use the returned awaitable object instead.\n        \"\"\"  # noqa: E501\n        http = self.get_auth_http_client()\n        body = urllib_parse.urlencode({\n            \"redirect_uri\": redirect_uri,\n            \"code\": code,\n            \"client_id\": self.settings[self._OAUTH_SETTINGS_KEY]['key'],\n            \"client_secret\": self.settings[self._OAUTH_SETTINGS_KEY]['secret'],\n            \"grant_type\": \"authorization_code\",\n        })\n\n        http.fetch(self._OAUTH_ACCESS_TOKEN_URL,\n                   functools.partial(self._on_access_token, callback),\n                   method=\"POST\",\n                   headers={'Content-Type': 'application/x-www-form-urlencoded'},\n                   body=body)",
        "begin_line": 917,
        "end_line": 974,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.GoogleOAuth2Mixin._on_access_token#976",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.GoogleOAuth2Mixin",
        "signature": "tornado.auth.GoogleOAuth2Mixin._on_access_token(self, future, response)",
        "snippet": "    def _on_access_token(self, future, response):\n        \"\"\"Callback function for the exchange to the access token.\"\"\"\n        if response.error:\n            future.set_exception(AuthError('Google auth error: %s' % str(response)))\n            return\n\n        args = escape.json_decode(response.body)\n        future_set_result_unless_cancelled(future, args)",
        "begin_line": 976,
        "end_line": 983,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.FacebookGraphMixin.get_authenticated_user#994",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.FacebookGraphMixin",
        "signature": "tornado.auth.FacebookGraphMixin.get_authenticated_user(self, redirect_uri, client_id, client_secret, code, callback, extra_fields=None)",
        "snippet": "    def get_authenticated_user(self, redirect_uri, client_id, client_secret,\n                               code, callback, extra_fields=None):\n        \"\"\"Handles the login for the Facebook user, returning a user object.\n\n        Example usage:\n\n        .. testcode::\n\n            class FacebookGraphLoginHandler(tornado.web.RequestHandler,\n                                            tornado.auth.FacebookGraphMixin):\n              @tornado.gen.coroutine\n              def get(self):\n                  if self.get_argument(\"code\", False):\n                      user = yield self.get_authenticated_user(\n                          redirect_uri='/auth/facebookgraph/',\n                          client_id=self.settings[\"facebook_api_key\"],\n                          client_secret=self.settings[\"facebook_secret\"],\n                          code=self.get_argument(\"code\"))\n                      # Save the user with e.g. set_secure_cookie\n                  else:\n                      yield self.authorize_redirect(\n                          redirect_uri='/auth/facebookgraph/',\n                          client_id=self.settings[\"facebook_api_key\"],\n                          extra_params={\"scope\": \"read_stream,offline_access\"})\n\n        .. testoutput::\n           :hide:\n\n        This method returns a dictionary which may contain the following fields:\n\n        * ``access_token``, a string which may be passed to `facebook_request`\n        * ``session_expires``, an integer encoded as a string representing\n          the time until the access token expires in seconds. This field should\n          be used like ``int(user['session_expires'])``; in a future version of\n          Tornado it will change from a string to an integer.\n        * ``id``, ``name``, ``first_name``, ``last_name``, ``locale``, ``picture``,\n          ``link``, plus any fields named in the ``extra_fields`` argument. These\n          fields are copied from the Facebook graph API\n          `user object <https://developers.facebook.com/docs/graph-api/reference/user>`_\n\n        .. versionchanged:: 4.5\n           The ``session_expires`` field was updated to support changes made to the\n           Facebook API in March 2017.\n\n        .. deprecated:: 5.1\n\n           The ``callback`` argument is deprecated and will be removed in 6.0.\n           Use the returned awaitable object instead.\n        \"\"\"\n        http = self.get_auth_http_client()\n        args = {\n            \"redirect_uri\": redirect_uri,\n            \"code\": code,\n            \"client_id\": client_id,\n            \"client_secret\": client_secret,\n        }\n\n        fields = set(['id', 'name', 'first_name', 'last_name',\n                      'locale', 'picture', 'link'])\n        if extra_fields:\n            fields.update(extra_fields)\n\n        http.fetch(self._oauth_request_token_url(**args),\n                   functools.partial(self._on_access_token, redirect_uri, client_id,\n                                     client_secret, callback, fields))",
        "begin_line": 994,
        "end_line": 1058,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.FacebookGraphMixin._on_access_token#1061",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.FacebookGraphMixin",
        "signature": "tornado.auth.FacebookGraphMixin._on_access_token(self, redirect_uri, client_id, client_secret, future, fields, response)",
        "snippet": "    def _on_access_token(self, redirect_uri, client_id, client_secret,\n                         future, fields, response):\n        if response.error:\n            future.set_exception(AuthError('Facebook auth error: %s' % str(response)))\n            return\n\n        args = escape.json_decode(response.body)\n        session = {\n            \"access_token\": args.get(\"access_token\"),\n            \"expires_in\": args.get(\"expires_in\")\n        }\n\n        user = yield self.facebook_request(\n            path=\"/me\",\n            access_token=session[\"access_token\"],\n            appsecret_proof=hmac.new(key=client_secret.encode('utf8'),\n                                     msg=session[\"access_token\"].encode('utf8'),\n                                     digestmod=hashlib.sha256).hexdigest(),\n            fields=\",\".join(fields)\n        )\n\n        if user is None:\n            future_set_result_unless_cancelled(future, None)\n            return\n\n        fieldmap = {}\n        for field in fields:\n            fieldmap[field] = user.get(field)\n\n        # session_expires is converted to str for compatibility with\n        # older versions in which the server used url-encoding and\n        # this code simply returned the string verbatim.\n        # This should change in Tornado 5.0.\n        fieldmap.update({\"access_token\": session[\"access_token\"],\n                         \"session_expires\": str(session.get(\"expires_in\"))})\n        future_set_result_unless_cancelled(future, fieldmap)",
        "begin_line": 1061,
        "end_line": 1096,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth.FacebookGraphMixin.facebook_request#1099",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth.FacebookGraphMixin",
        "signature": "tornado.auth.FacebookGraphMixin.facebook_request(self, path, callback, access_token=None, post_args=None, **args)",
        "snippet": "    def facebook_request(self, path, callback, access_token=None,\n                         post_args=None, **args):\n        \"\"\"Fetches the given relative API path, e.g., \"/btaylor/picture\"\n\n        If the request is a POST, ``post_args`` should be provided. Query\n        string arguments should be given as keyword arguments.\n\n        An introduction to the Facebook Graph API can be found at\n        http://developers.facebook.com/docs/api\n\n        Many methods require an OAuth access token which you can\n        obtain through `~OAuth2Mixin.authorize_redirect` and\n        `get_authenticated_user`. The user returned through that\n        process includes an ``access_token`` attribute that can be\n        used to make authenticated requests via this method.\n\n        Example usage:\n\n        .. testcode::\n\n            class MainHandler(tornado.web.RequestHandler,\n                              tornado.auth.FacebookGraphMixin):\n                @tornado.web.authenticated\n                @tornado.gen.coroutine\n                def get(self):\n                    new_entry = yield self.facebook_request(\n                        \"/me/feed\",\n                        post_args={\"message\": \"I am posting from my Tornado application!\"},\n                        access_token=self.current_user[\"access_token\"])\n\n                    if not new_entry:\n                        # Call failed; perhaps missing permission?\n                        yield self.authorize_redirect()\n                        return\n                    self.finish(\"Posted a message!\")\n\n        .. testoutput::\n           :hide:\n\n        The given path is relative to ``self._FACEBOOK_BASE_URL``,\n        by default \"https://graph.facebook.com\".\n\n        This method is a wrapper around `OAuth2Mixin.oauth2_request`;\n        the only difference is that this method takes a relative path,\n        while ``oauth2_request`` takes a complete url.\n\n        .. versionchanged:: 3.1\n           Added the ability to override ``self._FACEBOOK_BASE_URL``.\n\n        .. deprecated:: 5.1\n\n           The ``callback`` argument is deprecated and will be removed in 6.0.\n           Use the returned awaitable object instead.\n        \"\"\"\n        url = self._FACEBOOK_BASE_URL + path\n        # Thanks to the _auth_return_future decorator, our \"callback\"\n        # argument is a Future, which we cannot pass as a callback to\n        # oauth2_request. Instead, have oauth2_request return a\n        # future and chain them together.\n        oauth_future = self.oauth2_request(url, access_token=access_token,\n                                           post_args=post_args, **args)\n        chain_future(oauth_future, callback)",
        "begin_line": 1099,
        "end_line": 1160,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth._oauth_signature#1163",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth",
        "signature": "tornado.auth._oauth_signature(consumer_token, method, url, parameters={}, token=None)",
        "snippet": "def _oauth_signature(consumer_token, method, url, parameters={}, token=None):\n    \"\"\"Calculates the HMAC-SHA1 OAuth signature for the given request.\n\n    See http://oauth.net/core/1.0/#signing_process\n    \"\"\"\n    parts = urlparse.urlparse(url)\n    scheme, netloc, path = parts[:3]\n    normalized_url = scheme.lower() + \"://\" + netloc.lower() + path\n\n    base_elems = []\n    base_elems.append(method.upper())\n    base_elems.append(normalized_url)\n    base_elems.append(\"&\".join(\"%s=%s\" % (k, _oauth_escape(str(v)))\n                               for k, v in sorted(parameters.items())))\n    base_string = \"&\".join(_oauth_escape(e) for e in base_elems)\n\n    key_elems = [escape.utf8(consumer_token[\"secret\"])]\n    key_elems.append(escape.utf8(token[\"secret\"] if token else \"\"))\n    key = b\"&\".join(key_elems)\n\n    hash = hmac.new(key, escape.utf8(base_string), hashlib.sha1)\n    return binascii.b2a_base64(hash.digest())[:-1]",
        "begin_line": 1163,
        "end_line": 1184,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth._oauth10a_signature#1187",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth",
        "signature": "tornado.auth._oauth10a_signature(consumer_token, method, url, parameters={}, token=None)",
        "snippet": "def _oauth10a_signature(consumer_token, method, url, parameters={}, token=None):\n    \"\"\"Calculates the HMAC-SHA1 OAuth 1.0a signature for the given request.\n\n    See http://oauth.net/core/1.0a/#signing_process\n    \"\"\"\n    parts = urlparse.urlparse(url)\n    scheme, netloc, path = parts[:3]\n    normalized_url = scheme.lower() + \"://\" + netloc.lower() + path\n\n    base_elems = []\n    base_elems.append(method.upper())\n    base_elems.append(normalized_url)\n    base_elems.append(\"&\".join(\"%s=%s\" % (k, _oauth_escape(str(v)))\n                               for k, v in sorted(parameters.items())))\n\n    base_string = \"&\".join(_oauth_escape(e) for e in base_elems)\n    key_elems = [escape.utf8(urllib_parse.quote(consumer_token[\"secret\"], safe='~'))]\n    key_elems.append(escape.utf8(urllib_parse.quote(token[\"secret\"], safe='~') if token else \"\"))\n    key = b\"&\".join(key_elems)\n\n    hash = hmac.new(key, escape.utf8(base_string), hashlib.sha1)\n    return binascii.b2a_base64(hash.digest())[:-1]",
        "begin_line": 1187,
        "end_line": 1208,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017123287671232877,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth._oauth_escape#1211",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth",
        "signature": "tornado.auth._oauth_escape(val)",
        "snippet": "def _oauth_escape(val):\n    if isinstance(val, unicode_type):\n        val = val.encode(\"utf-8\")\n    return urllib_parse.quote(val, safe=\"~\")",
        "begin_line": 1211,
        "end_line": 1214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016474464579901152,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.auth._oauth_parse_response#1217",
        "src_path": "tornado/auth.py",
        "class_name": "tornado.auth",
        "signature": "tornado.auth._oauth_parse_response(body)",
        "snippet": "def _oauth_parse_response(body):\n    # I can't find an officially-defined encoding for oauth responses and\n    # have never seen anyone use non-ascii.  Leave the response in a byte\n    # string for python 2, and use utf8 on python 3.\n    body = escape.native_str(body)\n    p = urlparse.parse_qs(body, keep_blank_values=False)\n    token = dict(key=p[\"oauth_token\"][0], secret=p[\"oauth_token_secret\"][0])\n\n    # Add the extra parameters the Provider included to the token\n    special = (\"oauth_token\", \"oauth_token_secret\")\n    token.update((k, p[k][0]) for k in p if k not in special)\n    return token",
        "begin_line": 1217,
        "end_line": 1228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017295053614666206,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpserver.HTTPServer.__init__#140",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver.HTTPServer",
        "signature": "tornado.httpserver.HTTPServer.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        # Ignore args to __init__; real initialization belongs in\n        # initialize since we're Configurable. (there's something\n        # weird in initialization order between this class,\n        # Configurable, and TCPServer so we can't leave __init__ out\n        # completely)\n        pass",
        "begin_line": 140,
        "end_line": 146,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00141643059490085,
            "pseudo_dstar_susp": 0.0014641288433382138,
            "pseudo_tarantula_susp": 0.0010683760683760685,
            "pseudo_op2_susp": 0.0014641288433382138,
            "pseudo_barinel_susp": 0.0010683760683760685
        }
    },
    {
        "name": "tornado.httpserver.HTTPServer.initialize#148",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver.HTTPServer",
        "signature": "tornado.httpserver.HTTPServer.initialize(self, request_callback, no_keep_alive=False, xheaders=False, ssl_options=None, protocol=None, decompress_request=False, chunk_size=None, max_header_size=None, idle_connection_timeout=None, body_timeout=None, max_body_size=None, max_buffer_size=None, trusted_downstream=None)",
        "snippet": "    def initialize(self, request_callback, no_keep_alive=False,\n                   xheaders=False, ssl_options=None, protocol=None,\n                   decompress_request=False,\n                   chunk_size=None, max_header_size=None,\n                   idle_connection_timeout=None, body_timeout=None,\n                   max_body_size=None, max_buffer_size=None,\n                   trusted_downstream=None):\n        self.request_callback = request_callback\n        self.xheaders = xheaders\n        self.protocol = protocol\n        self.conn_params = HTTP1ConnectionParameters(\n            decompress=decompress_request,\n            chunk_size=chunk_size,\n            max_header_size=max_header_size,\n            header_timeout=idle_connection_timeout or 3600,\n            max_body_size=max_body_size,\n            body_timeout=body_timeout,\n            no_keep_alive=no_keep_alive)\n        TCPServer.__init__(self, ssl_options=ssl_options,\n                           max_buffer_size=max_buffer_size,\n                           read_chunk_size=chunk_size)\n        self._connections = set()\n        self.trusted_downstream = trusted_downstream",
        "begin_line": 148,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00141643059490085,
            "pseudo_dstar_susp": 0.0014641288433382138,
            "pseudo_tarantula_susp": 0.0010683760683760685,
            "pseudo_op2_susp": 0.0014641288433382138,
            "pseudo_barinel_susp": 0.0010683760683760685
        }
    },
    {
        "name": "tornado.httpserver.HTTPServer.configurable_base#173",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver.HTTPServer",
        "signature": "tornado.httpserver.HTTPServer.configurable_base(cls)",
        "snippet": "    def configurable_base(cls):\n        return HTTPServer",
        "begin_line": 173,
        "end_line": 174,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001394700139470014,
            "pseudo_dstar_susp": 0.001440922190201729,
            "pseudo_tarantula_susp": 0.0010559662090813093,
            "pseudo_op2_susp": 0.001440922190201729,
            "pseudo_barinel_susp": 0.0010559662090813093
        }
    },
    {
        "name": "tornado.httpserver.HTTPServer.configurable_default#177",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver.HTTPServer",
        "signature": "tornado.httpserver.HTTPServer.configurable_default(cls)",
        "snippet": "    def configurable_default(cls):\n        return HTTPServer",
        "begin_line": 177,
        "end_line": 178,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpserver.HTTPServer.close_all_connections#181",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver.HTTPServer",
        "signature": "tornado.httpserver.HTTPServer.close_all_connections(self)",
        "snippet": "    def close_all_connections(self):\n        while self._connections:\n            # Peek at an arbitrary element of the set\n            conn = next(iter(self._connections))\n            yield conn.close()",
        "begin_line": 181,
        "end_line": 185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014388489208633094,
            "pseudo_dstar_susp": 0.0014727540500736377,
            "pseudo_tarantula_susp": 0.001072961373390558,
            "pseudo_op2_susp": 0.0014727540500736377,
            "pseudo_barinel_susp": 0.001072961373390558
        }
    },
    {
        "name": "tornado.httpserver.HTTPServer.handle_stream#187",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver.HTTPServer",
        "signature": "tornado.httpserver.HTTPServer.handle_stream(self, stream, address)",
        "snippet": "    def handle_stream(self, stream, address):\n        context = _HTTPRequestContext(stream, address,\n                                      self.protocol,\n                                      self.trusted_downstream)\n        conn = HTTP1ServerConnection(\n            stream, self.conn_params, context)\n        self._connections.add(conn)\n        conn.start_serving(self)",
        "begin_line": 187,
        "end_line": 194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006071645415907711,
            "pseudo_dstar_susp": 0.0007183908045977011,
            "pseudo_tarantula_susp": 0.0005633802816901409,
            "pseudo_op2_susp": 0.0007183908045977011,
            "pseudo_barinel_susp": 0.0005633802816901409
        }
    },
    {
        "name": "tornado.httpserver.HTTPServer.start_request#196",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver.HTTPServer",
        "signature": "tornado.httpserver.HTTPServer.start_request(self, server_conn, request_conn)",
        "snippet": "    def start_request(self, server_conn, request_conn):\n        if isinstance(self.request_callback, httputil.HTTPServerConnectionDelegate):\n            delegate = self.request_callback.start_request(server_conn, request_conn)\n        else:\n            delegate = _CallableAdapter(self.request_callback, request_conn)\n\n        if self.xheaders:\n            delegate = _ProxyAdapter(delegate, request_conn)\n\n        return delegate",
        "begin_line": 196,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006548788474132286,
            "pseudo_dstar_susp": 0.0007336757153338225,
            "pseudo_tarantula_susp": 0.0006131207847946045,
            "pseudo_op2_susp": 0.0007336757153338225,
            "pseudo_barinel_susp": 0.0006131207847946045
        }
    },
    {
        "name": "tornado.httpserver.HTTPServer.on_close#207",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver.HTTPServer",
        "signature": "tornado.httpserver.HTTPServer.on_close(self, server_conn)",
        "snippet": "    def on_close(self, server_conn):\n        self._connections.remove(server_conn)",
        "begin_line": 207,
        "end_line": 208,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006071645415907711,
            "pseudo_dstar_susp": 0.0007183908045977011,
            "pseudo_tarantula_susp": 0.0005633802816901409,
            "pseudo_op2_susp": 0.0007183908045977011,
            "pseudo_barinel_susp": 0.0005633802816901409
        }
    },
    {
        "name": "tornado.httpserver._CallableAdapter.__init__#212",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._CallableAdapter",
        "signature": "tornado.httpserver._CallableAdapter.__init__(self, request_callback, request_conn)",
        "snippet": "    def __init__(self, request_callback, request_conn):\n        self.connection = request_conn\n        self.request_callback = request_callback\n        self.request = None\n        self.delegate = None\n        self._chunks = []",
        "begin_line": 212,
        "end_line": 217,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013206550449022716,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpserver._CallableAdapter.headers_received#219",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._CallableAdapter",
        "signature": "tornado.httpserver._CallableAdapter.headers_received(self, start_line, headers)",
        "snippet": "    def headers_received(self, start_line, headers):\n        self.request = httputil.HTTPServerRequest(\n            connection=self.connection, start_line=start_line,\n            headers=headers)",
        "begin_line": 219,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013206550449022716,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpserver._CallableAdapter.data_received#224",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._CallableAdapter",
        "signature": "tornado.httpserver._CallableAdapter.data_received(self, chunk)",
        "snippet": "    def data_received(self, chunk):\n        self._chunks.append(chunk)",
        "begin_line": 224,
        "end_line": 225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015248551387618176,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpserver._CallableAdapter.finish#227",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._CallableAdapter",
        "signature": "tornado.httpserver._CallableAdapter.finish(self)",
        "snippet": "    def finish(self):\n        self.request.body = b''.join(self._chunks)\n        self.request._parse_body()\n        self.request_callback(self.request)",
        "begin_line": 227,
        "end_line": 230,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013206550449022716,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpserver._HTTPRequestContext.__init__#237",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._HTTPRequestContext",
        "signature": "tornado.httpserver._HTTPRequestContext.__init__(self, stream, address, protocol, trusted_downstream=None)",
        "snippet": "    def __init__(self, stream, address, protocol, trusted_downstream=None):\n        self.address = address\n        # Save the socket's address family now so we know how to\n        # interpret self.address even after the stream is closed\n        # and its socket attribute replaced with None.\n        if stream.socket is not None:\n            self.address_family = stream.socket.family\n        else:\n            self.address_family = None\n        # In HTTPServerRequest we want an IP, not a full socket address.\n        if (self.address_family in (socket.AF_INET, socket.AF_INET6) and\n                address is not None):\n            self.remote_ip = address[0]\n        else:\n            # Unix (or other) socket; fake the remote address.\n            self.remote_ip = '0.0.0.0'\n        if protocol:\n            self.protocol = protocol\n        elif isinstance(stream, iostream.SSLIOStream):\n            self.protocol = \"https\"\n        else:\n            self.protocol = \"http\"\n        self._orig_remote_ip = self.remote_ip\n        self._orig_protocol = self.protocol\n        self.trusted_downstream = set(trusted_downstream or [])",
        "begin_line": 237,
        "end_line": 261,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006430868167202572,
            "pseudo_dstar_susp": 0.0007326007326007326,
            "pseudo_tarantula_susp": 0.0038461538461538464,
            "pseudo_op2_susp": 0.0007326007326007326,
            "pseudo_barinel_susp": 0.0038461538461538464
        }
    },
    {
        "name": "tornado.httpserver._HTTPRequestContext._apply_xheaders#274",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._HTTPRequestContext",
        "signature": "tornado.httpserver._HTTPRequestContext._apply_xheaders(self, headers)",
        "snippet": "    def _apply_xheaders(self, headers):\n        \"\"\"Rewrite the ``remote_ip`` and ``protocol`` fields.\"\"\"\n        # Squid uses X-Forwarded-For, others use X-Real-Ip\n        ip = headers.get(\"X-Forwarded-For\", self.remote_ip)\n        # Skip trusted downstream hosts in X-Forwarded-For list\n        for ip in (cand.strip() for cand in reversed(ip.split(','))):\n            if ip not in self.trusted_downstream:\n                break\n        ip = headers.get(\"X-Real-Ip\", ip)\n        if netutil.is_valid_ip(ip):\n            self.remote_ip = ip\n        # AWS uses X-Forwarded-Proto\n        proto_header = headers.get(\n            \"X-Scheme\", headers.get(\"X-Forwarded-Proto\",\n                                    self.protocol))\n        if proto_header:\n            # use only the last proto entry if there is more than one\n            # TODO: support trusting mutiple layers of proxied protocol\n            proto_header = proto_header.split(',')[-1].strip()\n        if proto_header in (\"http\", \"https\"):\n            self.protocol = proto_header",
        "begin_line": 274,
        "end_line": 294,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpserver._HTTPRequestContext._unapply_xheaders#296",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._HTTPRequestContext",
        "signature": "tornado.httpserver._HTTPRequestContext._unapply_xheaders(self)",
        "snippet": "    def _unapply_xheaders(self):\n        \"\"\"Undo changes from `_apply_xheaders`.\n\n        Xheaders are per-request so they should not leak to the next\n        request on the same connection.\n        \"\"\"\n        self.remote_ip = self._orig_remote_ip\n        self.protocol = self._orig_protocol",
        "begin_line": 296,
        "end_line": 303,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpserver._ProxyAdapter.__init__#307",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._ProxyAdapter",
        "signature": "tornado.httpserver._ProxyAdapter.__init__(self, delegate, request_conn)",
        "snippet": "    def __init__(self, delegate, request_conn):\n        self.connection = request_conn\n        self.delegate = delegate",
        "begin_line": 307,
        "end_line": 309,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpserver._ProxyAdapter.headers_received#311",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._ProxyAdapter",
        "signature": "tornado.httpserver._ProxyAdapter.headers_received(self, start_line, headers)",
        "snippet": "    def headers_received(self, start_line, headers):\n        self.connection.context._apply_xheaders(headers)\n        return self.delegate.headers_received(start_line, headers)",
        "begin_line": 311,
        "end_line": 313,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpserver._ProxyAdapter.finish#318",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._ProxyAdapter",
        "signature": "tornado.httpserver._ProxyAdapter.finish(self)",
        "snippet": "    def finish(self):\n        self.delegate.finish()\n        self._cleanup()",
        "begin_line": 318,
        "end_line": 320,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpserver._ProxyAdapter._cleanup#326",
        "src_path": "tornado/httpserver.py",
        "class_name": "tornado.httpserver._ProxyAdapter",
        "signature": "tornado.httpserver._ProxyAdapter._cleanup(self)",
        "snippet": "    def _cleanup(self):\n        self.connection.context._unapply_xheaders()",
        "begin_line": 326,
        "end_line": 327,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.filter_whitespace#220",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template",
        "signature": "tornado.template.filter_whitespace(mode, text)",
        "snippet": "def filter_whitespace(mode, text):\n    \"\"\"Transform whitespace in ``text`` according to ``mode``.\n\n    Available modes are:\n\n    * ``all``: Return all whitespace unmodified.\n    * ``single``: Collapse consecutive whitespace with a single whitespace\n      character, preserving newlines.\n    * ``oneline``: Collapse all runs of whitespace into a single space\n      character, removing all newlines in the process.\n\n    .. versionadded:: 4.3\n    \"\"\"\n    if mode == 'all':\n        return text\n    elif mode == 'single':\n        text = re.sub(r\"([\\t ]+)\", \" \", text)\n        text = re.sub(r\"(\\s*\\n\\s*)\", \"\\n\", text)\n        return text\n    elif mode == 'oneline':\n        return re.sub(r\"(\\s+)\", \" \", text)\n    else:\n        raise Exception(\"invalid whitespace mode %s\" % mode)",
        "begin_line": 220,
        "end_line": 242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.Template.__init__#254",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Template",
        "signature": "tornado.template.Template.__init__(self, template_string, name='<string>', loader=None, compress_whitespace=_UNSET, autoescape=_UNSET, whitespace=None)",
        "snippet": "    def __init__(self, template_string, name=\"<string>\", loader=None,\n                 compress_whitespace=_UNSET, autoescape=_UNSET,\n                 whitespace=None):\n        \"\"\"Construct a Template.\n\n        :arg str template_string: the contents of the template file.\n        :arg str name: the filename from which the template was loaded\n            (used for error message).\n        :arg tornado.template.BaseLoader loader: the `~tornado.template.BaseLoader` responsible\n            for this template, used to resolve ``{% include %}`` and ``{% extend %}`` directives.\n        :arg bool compress_whitespace: Deprecated since Tornado 4.3.\n            Equivalent to ``whitespace=\"single\"`` if true and\n            ``whitespace=\"all\"`` if false.\n        :arg str autoescape: The name of a function in the template\n            namespace, or ``None`` to disable escaping by default.\n        :arg str whitespace: A string specifying treatment of whitespace;\n            see `filter_whitespace` for options.\n\n        .. versionchanged:: 4.3\n           Added ``whitespace`` parameter; deprecated ``compress_whitespace``.\n        \"\"\"\n        self.name = escape.native_str(name)\n\n        if compress_whitespace is not _UNSET:\n            # Convert deprecated compress_whitespace (bool) to whitespace (str).\n            if whitespace is not None:\n                raise Exception(\"cannot set both whitespace and compress_whitespace\")\n            whitespace = \"single\" if compress_whitespace else \"all\"\n        if whitespace is None:\n            if loader and loader.whitespace:\n                whitespace = loader.whitespace\n            else:\n                # Whitespace defaults by filename.\n                if name.endswith(\".html\") or name.endswith(\".js\"):\n                    whitespace = \"single\"\n                else:\n                    whitespace = \"all\"\n        # Validate the whitespace setting.\n        filter_whitespace(whitespace, '')\n\n        if autoescape is not _UNSET:\n            self.autoescape = autoescape\n        elif loader:\n            self.autoescape = loader.autoescape\n        else:\n            self.autoescape = _DEFAULT_AUTOESCAPE\n\n        self.namespace = loader.namespace if loader else {}\n        reader = _TemplateReader(name, escape.native_str(template_string),\n                                 whitespace)\n        self.file = _File(self, _parse(reader, self))\n        self.code = self._generate_python(loader)\n        self.loader = loader\n        try:\n            # Under python2.5, the fake filename used here must match\n            # the module name used in __name__ below.\n            # The dont_inherit flag prevents template.py's future imports\n            # from being applied to the generated code.\n            self.compiled = compile(\n                escape.to_unicode(self.code),\n                \"%s.generated.py\" % self.name.replace('.', '_'),\n                \"exec\", dont_inherit=True)\n        except Exception:\n            formatted_code = _format_code(self.code).rstrip()\n            app_log.error(\"%s code:\\n%s\", self.name, formatted_code)\n            raise",
        "begin_line": 254,
        "end_line": 319,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.Template.generate#321",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Template",
        "signature": "tornado.template.Template.generate(self, **kwargs)",
        "snippet": "    def generate(self, **kwargs):\n        \"\"\"Generate this template with the given arguments.\"\"\"\n        namespace = {\n            \"escape\": escape.xhtml_escape,\n            \"xhtml_escape\": escape.xhtml_escape,\n            \"url_escape\": escape.url_escape,\n            \"json_encode\": escape.json_encode,\n            \"squeeze\": escape.squeeze,\n            \"linkify\": escape.linkify,\n            \"datetime\": datetime,\n            \"_tt_utf8\": escape.utf8,  # for internal use\n            \"_tt_string_types\": (unicode_type, bytes),\n            # __name__ and __loader__ allow the traceback mechanism to find\n            # the generated source code.\n            \"__name__\": self.name.replace('.', '_'),\n            \"__loader__\": ObjectDict(get_source=lambda name: self.code),\n        }\n        namespace.update(self.namespace)\n        namespace.update(kwargs)\n        exec_in(self.compiled, namespace)\n        execute = namespace[\"_tt_execute\"]\n        # Clear the traceback module's cache of source data now that\n        # we've generated a new template (mainly for this module's\n        # unittests, where different tests reuse the same name).\n        linecache.clearcache()\n        return execute()",
        "begin_line": 321,
        "end_line": 346,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001426330052774212,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.Template._generate_python#348",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Template",
        "signature": "tornado.template.Template._generate_python(self, loader)",
        "snippet": "    def _generate_python(self, loader):\n        buffer = StringIO()\n        try:\n            # named_blocks maps from names to _NamedBlock objects\n            named_blocks = {}\n            ancestors = self._get_ancestors(loader)\n            ancestors.reverse()\n            for ancestor in ancestors:\n                ancestor.find_named_blocks(loader, named_blocks)\n            writer = _CodeWriter(buffer, named_blocks, loader,\n                                 ancestors[0].template)\n            ancestors[0].generate(writer)\n            return buffer.getvalue()\n        finally:\n            buffer.close()",
        "begin_line": 348,
        "end_line": 362,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001426330052774212,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.Template._get_ancestors#364",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Template",
        "signature": "tornado.template.Template._get_ancestors(self, loader)",
        "snippet": "    def _get_ancestors(self, loader):\n        ancestors = [self.file]\n        for chunk in self.file.body.chunks:\n            if isinstance(chunk, _ExtendsBlock):\n                if not loader:\n                    raise ParseError(\"{% extends %} block found, but no \"\n                                     \"template loader\")\n                template = loader.load(chunk.name, self.name)\n                ancestors.extend(template._get_ancestors(loader))\n        return ancestors",
        "begin_line": 364,
        "end_line": 373,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.BaseLoader.__init__#383",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.BaseLoader",
        "signature": "tornado.template.BaseLoader.__init__(self, autoescape=_DEFAULT_AUTOESCAPE, namespace=None, whitespace=None)",
        "snippet": "    def __init__(self, autoescape=_DEFAULT_AUTOESCAPE, namespace=None,\n                 whitespace=None):\n        \"\"\"Construct a template loader.\n\n        :arg str autoescape: The name of a function in the template\n            namespace, such as \"xhtml_escape\", or ``None`` to disable\n            autoescaping by default.\n        :arg dict namespace: A dictionary to be added to the default template\n            namespace, or ``None``.\n        :arg str whitespace: A string specifying default behavior for\n            whitespace in templates; see `filter_whitespace` for options.\n            Default is \"single\" for files ending in \".html\" and \".js\" and\n            \"all\" for other files.\n\n        .. versionchanged:: 4.3\n           Added ``whitespace`` parameter.\n        \"\"\"\n        self.autoescape = autoescape\n        self.namespace = namespace or {}\n        self.whitespace = whitespace\n        self.templates = {}\n        # self.lock protects self.templates.  It's a reentrant lock\n        # because templates may load other templates via `include` or\n        # `extends`.  Note that thanks to the GIL this code would be safe\n        # even without the lock, but could lead to wasted work as multiple\n        # threads tried to compile the same template simultaneously.\n        self.lock = threading.RLock()",
        "begin_line": 383,
        "end_line": 409,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013548299688389108,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.BaseLoader.load#420",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.BaseLoader",
        "signature": "tornado.template.BaseLoader.load(self, name, parent_path=None)",
        "snippet": "    def load(self, name, parent_path=None):\n        \"\"\"Loads a template.\"\"\"\n        name = self.resolve_path(name, parent_path=parent_path)\n        with self.lock:\n            if name not in self.templates:\n                self.templates[name] = self._create_template(name)\n            return self.templates[name]",
        "begin_line": 420,
        "end_line": 426,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014701558365186709,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.Loader.__init__#435",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Loader",
        "signature": "tornado.template.Loader.__init__(self, root_directory, **kwargs)",
        "snippet": "    def __init__(self, root_directory, **kwargs):\n        super(Loader, self).__init__(**kwargs)\n        self.root = os.path.abspath(root_directory)",
        "begin_line": 435,
        "end_line": 437,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.Loader.resolve_path#439",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Loader",
        "signature": "tornado.template.Loader.resolve_path(self, name, parent_path=None)",
        "snippet": "    def resolve_path(self, name, parent_path=None):\n        if parent_path and not parent_path.startswith(\"<\") and \\\n            not parent_path.startswith(\"/\") and \\\n                not name.startswith(\"/\"):\n            current_path = os.path.join(self.root, parent_path)\n            file_dir = os.path.dirname(os.path.abspath(current_path))\n            relative_path = os.path.abspath(os.path.join(file_dir, name))\n            if relative_path.startswith(self.root):\n                name = relative_path[len(self.root) + 1:]\n        return name",
        "begin_line": 439,
        "end_line": 448,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.Loader._create_template#450",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Loader",
        "signature": "tornado.template.Loader._create_template(self, name)",
        "snippet": "    def _create_template(self, name):\n        path = os.path.join(self.root, name)\n        with open(path, \"rb\") as f:\n            template = Template(f.read(), name=name, loader=self)\n            return template",
        "begin_line": 450,
        "end_line": 454,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.DictLoader.__init__#459",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.DictLoader",
        "signature": "tornado.template.DictLoader.__init__(self, dict, **kwargs)",
        "snippet": "    def __init__(self, dict, **kwargs):\n        super(DictLoader, self).__init__(**kwargs)\n        self.dict = dict",
        "begin_line": 459,
        "end_line": 461,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013557483731019523,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.DictLoader.resolve_path#463",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.DictLoader",
        "signature": "tornado.template.DictLoader.resolve_path(self, name, parent_path=None)",
        "snippet": "    def resolve_path(self, name, parent_path=None):\n        if parent_path and not parent_path.startswith(\"<\") and \\\n            not parent_path.startswith(\"/\") and \\\n                not name.startswith(\"/\"):\n            file_dir = posixpath.dirname(parent_path)\n            name = posixpath.normpath(posixpath.join(file_dir, name))\n        return name",
        "begin_line": 463,
        "end_line": 469,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001775568181818182,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.DictLoader._create_template#471",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.DictLoader",
        "signature": "tornado.template.DictLoader._create_template(self, name)",
        "snippet": "    def _create_template(self, name):\n        return Template(self.dict[name], name=name, loader=self)",
        "begin_line": 471,
        "end_line": 472,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014701558365186709,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._Node.each_child#476",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._Node",
        "signature": "tornado.template._Node.each_child(self)",
        "snippet": "    def each_child(self):\n        return ()",
        "begin_line": 476,
        "end_line": 477,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001426330052774212,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._Node.find_named_blocks#482",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._Node",
        "signature": "tornado.template._Node.find_named_blocks(self, loader, named_blocks)",
        "snippet": "    def find_named_blocks(self, loader, named_blocks):\n        for child in self.each_child():\n            child.find_named_blocks(loader, named_blocks)",
        "begin_line": 482,
        "end_line": 484,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001426330052774212,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._File.__init__#488",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._File",
        "signature": "tornado.template._File.__init__(self, template, body)",
        "snippet": "    def __init__(self, template, body):\n        self.template = template\n        self.body = body\n        self.line = 0",
        "begin_line": 488,
        "end_line": 491,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001426330052774212,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._File.generate#493",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._File",
        "signature": "tornado.template._File.generate(self, writer)",
        "snippet": "    def generate(self, writer):\n        writer.write_line(\"def _tt_execute():\", self.line)\n        with writer.indent():\n            writer.write_line(\"_tt_buffer = []\", self.line)\n            writer.write_line(\"_tt_append = _tt_buffer.append\", self.line)\n            self.body.generate(writer)\n            writer.write_line(\"return _tt_utf8('').join(_tt_buffer)\", self.line)",
        "begin_line": 493,
        "end_line": 499,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001426330052774212,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._File.each_child#501",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._File",
        "signature": "tornado.template._File.each_child(self)",
        "snippet": "    def each_child(self):\n        return (self.body,)",
        "begin_line": 501,
        "end_line": 502,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001426330052774212,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._ChunkList.__init__#506",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ChunkList",
        "signature": "tornado.template._ChunkList.__init__(self, chunks)",
        "snippet": "    def __init__(self, chunks):\n        self.chunks = chunks",
        "begin_line": 506,
        "end_line": 507,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014072614691809738,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._ChunkList.generate#509",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ChunkList",
        "signature": "tornado.template._ChunkList.generate(self, writer)",
        "snippet": "    def generate(self, writer):\n        for chunk in self.chunks:\n            chunk.generate(writer)",
        "begin_line": 509,
        "end_line": 511,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001426330052774212,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._ChunkList.each_child#513",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ChunkList",
        "signature": "tornado.template._ChunkList.each_child(self)",
        "snippet": "    def each_child(self):\n        return self.chunks",
        "begin_line": 513,
        "end_line": 514,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001426330052774212,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._NamedBlock.__init__#518",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._NamedBlock",
        "signature": "tornado.template._NamedBlock.__init__(self, name, body, template, line)",
        "snippet": "    def __init__(self, name, body, template, line):\n        self.name = name\n        self.body = body\n        self.template = template\n        self.line = line",
        "begin_line": 518,
        "end_line": 522,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._NamedBlock.each_child#524",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._NamedBlock",
        "signature": "tornado.template._NamedBlock.each_child(self)",
        "snippet": "    def each_child(self):\n        return (self.body,)",
        "begin_line": 524,
        "end_line": 525,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._NamedBlock.generate#527",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._NamedBlock",
        "signature": "tornado.template._NamedBlock.generate(self, writer)",
        "snippet": "    def generate(self, writer):\n        block = writer.named_blocks[self.name]\n        with writer.include(block.template, self.line):\n            block.body.generate(writer)",
        "begin_line": 527,
        "end_line": 530,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._NamedBlock.find_named_blocks#532",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._NamedBlock",
        "signature": "tornado.template._NamedBlock.find_named_blocks(self, loader, named_blocks)",
        "snippet": "    def find_named_blocks(self, loader, named_blocks):\n        named_blocks[self.name] = self\n        _Node.find_named_blocks(self, loader, named_blocks)",
        "begin_line": 532,
        "end_line": 534,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._ExtendsBlock.__init__#538",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ExtendsBlock",
        "signature": "tornado.template._ExtendsBlock.__init__(self, name)",
        "snippet": "    def __init__(self, name):\n        self.name = name",
        "begin_line": 538,
        "end_line": 539,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._IncludeBlock.__init__#543",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._IncludeBlock",
        "signature": "tornado.template._IncludeBlock.__init__(self, name, reader, line)",
        "snippet": "    def __init__(self, name, reader, line):\n        self.name = name\n        self.template_name = reader.name\n        self.line = line",
        "begin_line": 543,
        "end_line": 546,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019275250578257516,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._IncludeBlock.find_named_blocks#548",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._IncludeBlock",
        "signature": "tornado.template._IncludeBlock.find_named_blocks(self, loader, named_blocks)",
        "snippet": "    def find_named_blocks(self, loader, named_blocks):\n        included = loader.load(self.name, self.template_name)\n        included.file.find_named_blocks(loader, named_blocks)",
        "begin_line": 548,
        "end_line": 550,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019275250578257516,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._IncludeBlock.generate#552",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._IncludeBlock",
        "signature": "tornado.template._IncludeBlock.generate(self, writer)",
        "snippet": "    def generate(self, writer):\n        included = writer.loader.load(self.name, self.template_name)\n        with writer.include(included, self.line):\n            included.file.body.generate(writer)",
        "begin_line": 552,
        "end_line": 555,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019275250578257516,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._ApplyBlock.__init__#559",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ApplyBlock",
        "signature": "tornado.template._ApplyBlock.__init__(self, method, line, body=None)",
        "snippet": "    def __init__(self, method, line, body=None):\n        self.method = method\n        self.line = line\n        self.body = body",
        "begin_line": 559,
        "end_line": 562,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._ApplyBlock.each_child#564",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ApplyBlock",
        "signature": "tornado.template._ApplyBlock.each_child(self)",
        "snippet": "    def each_child(self):\n        return (self.body,)",
        "begin_line": 564,
        "end_line": 565,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._ApplyBlock.generate#567",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ApplyBlock",
        "signature": "tornado.template._ApplyBlock.generate(self, writer)",
        "snippet": "    def generate(self, writer):\n        method_name = \"_tt_apply%d\" % writer.apply_counter\n        writer.apply_counter += 1\n        writer.write_line(\"def %s():\" % method_name, self.line)\n        with writer.indent():\n            writer.write_line(\"_tt_buffer = []\", self.line)\n            writer.write_line(\"_tt_append = _tt_buffer.append\", self.line)\n            self.body.generate(writer)\n            writer.write_line(\"return _tt_utf8('').join(_tt_buffer)\", self.line)\n        writer.write_line(\"_tt_append(_tt_utf8(%s(%s())))\" % (\n            self.method, method_name), self.line)",
        "begin_line": 567,
        "end_line": 577,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._ControlBlock.__init__#581",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ControlBlock",
        "signature": "tornado.template._ControlBlock.__init__(self, statement, line, body=None)",
        "snippet": "    def __init__(self, statement, line, body=None):\n        self.statement = statement\n        self.line = line\n        self.body = body",
        "begin_line": 581,
        "end_line": 584,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00018018018018018018,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._ControlBlock.each_child#586",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ControlBlock",
        "signature": "tornado.template._ControlBlock.each_child(self)",
        "snippet": "    def each_child(self):\n        return (self.body,)",
        "begin_line": 586,
        "end_line": 587,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00018018018018018018,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._ControlBlock.generate#589",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._ControlBlock",
        "signature": "tornado.template._ControlBlock.generate(self, writer)",
        "snippet": "    def generate(self, writer):\n        writer.write_line(\"%s:\" % self.statement, self.line)\n        with writer.indent():\n            self.body.generate(writer)\n            # Just in case the body was empty\n            writer.write_line(\"pass\", self.line)",
        "begin_line": 589,
        "end_line": 594,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00018018018018018018,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._IntermediateControlBlock.__init__#598",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._IntermediateControlBlock",
        "signature": "tornado.template._IntermediateControlBlock.__init__(self, statement, line)",
        "snippet": "    def __init__(self, statement, line):\n        self.statement = statement\n        self.line = line",
        "begin_line": 598,
        "end_line": 600,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._IntermediateControlBlock.generate#602",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._IntermediateControlBlock",
        "signature": "tornado.template._IntermediateControlBlock.generate(self, writer)",
        "snippet": "    def generate(self, writer):\n        # In case the previous block was empty\n        writer.write_line(\"pass\", self.line)\n        writer.write_line(\"%s:\" % self.statement, self.line, writer.indent_size() - 1)",
        "begin_line": 602,
        "end_line": 605,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._Statement.__init__#609",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._Statement",
        "signature": "tornado.template._Statement.__init__(self, statement, line)",
        "snippet": "    def __init__(self, statement, line):\n        self.statement = statement\n        self.line = line",
        "begin_line": 609,
        "end_line": 611,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._Statement.generate#613",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._Statement",
        "signature": "tornado.template._Statement.generate(self, writer)",
        "snippet": "    def generate(self, writer):\n        writer.write_line(self.statement, self.line)",
        "begin_line": 613,
        "end_line": 614,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._Expression.__init__#618",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._Expression",
        "signature": "tornado.template._Expression.__init__(self, expression, line, raw=False)",
        "snippet": "    def __init__(self, expression, line, raw=False):\n        self.expression = expression\n        self.line = line\n        self.raw = raw",
        "begin_line": 618,
        "end_line": 621,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014727540500736376,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._Expression.generate#623",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._Expression",
        "signature": "tornado.template._Expression.generate(self, writer)",
        "snippet": "    def generate(self, writer):\n        writer.write_line(\"_tt_tmp = %s\" % self.expression, self.line)\n        writer.write_line(\"if isinstance(_tt_tmp, _tt_string_types):\"\n                          \" _tt_tmp = _tt_utf8(_tt_tmp)\", self.line)\n        writer.write_line(\"else: _tt_tmp = _tt_utf8(str(_tt_tmp))\", self.line)\n        if not self.raw and writer.current_template.autoescape is not None:\n            # In python3 functions like xhtml_escape return unicode,\n            # so we have to convert to utf8 again.\n            writer.write_line(\"_tt_tmp = _tt_utf8(%s(_tt_tmp))\" %\n                              writer.current_template.autoescape, self.line)\n        writer.write_line(\"_tt_append(_tt_tmp)\", self.line)",
        "begin_line": 623,
        "end_line": 633,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015008254539996998,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._Module.__init__#637",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._Module",
        "signature": "tornado.template._Module.__init__(self, expression, line)",
        "snippet": "    def __init__(self, expression, line):\n        super(_Module, self).__init__(\"_tt_modules.\" + expression, line,\n                                      raw=True)",
        "begin_line": 637,
        "end_line": 639,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016983695652173913,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._Text.__init__#643",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._Text",
        "signature": "tornado.template._Text.__init__(self, value, line, whitespace)",
        "snippet": "    def __init__(self, value, line, whitespace):\n        self.value = value\n        self.line = line\n        self.whitespace = whitespace",
        "begin_line": 643,
        "end_line": 646,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014150275930380644,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._Text.generate#648",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._Text",
        "signature": "tornado.template._Text.generate(self, writer)",
        "snippet": "    def generate(self, writer):\n        value = self.value\n\n        # Compress whitespace if requested, with a crude heuristic to avoid\n        # altering preformatted whitespace.\n        if \"<pre>\" not in value:\n            value = filter_whitespace(self.whitespace, value)\n\n        if value:\n            writer.write_line('_tt_append(%r)' % escape.utf8(value), self.line)",
        "begin_line": 648,
        "end_line": 657,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014803849000740192,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.ParseError.__init__#669",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.ParseError",
        "signature": "tornado.template.ParseError.__init__(self, message, filename=None, lineno=0)",
        "snippet": "    def __init__(self, message, filename=None, lineno=0):\n        self.message = message\n        # The names \"filename\" and \"lineno\" are chosen for consistency\n        # with python SyntaxError.\n        self.filename = filename\n        self.lineno = lineno",
        "begin_line": 669,
        "end_line": 674,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.ParseError.__str__#676",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.ParseError",
        "signature": "tornado.template.ParseError.__str__(self)",
        "snippet": "    def __str__(self):\n        return '%s at %s:%d' % (self.message, self.filename, self.lineno)",
        "begin_line": 676,
        "end_line": 677,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._CodeWriter.__init__#681",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._CodeWriter",
        "signature": "tornado.template._CodeWriter.__init__(self, file, named_blocks, loader, current_template)",
        "snippet": "    def __init__(self, file, named_blocks, loader, current_template):\n        self.file = file\n        self.named_blocks = named_blocks\n        self.loader = loader\n        self.current_template = current_template\n        self.apply_counter = 0\n        self.include_stack = []\n        self._indent = 0",
        "begin_line": 681,
        "end_line": 688,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001426330052774212,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._CodeWriter.indent_size#690",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._CodeWriter",
        "signature": "tornado.template._CodeWriter.indent_size(self)",
        "snippet": "    def indent_size(self):\n        return self._indent",
        "begin_line": 690,
        "end_line": 691,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._CodeWriter.indent#693",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._CodeWriter",
        "signature": "tornado.template._CodeWriter.indent(self)",
        "snippet": "    def indent(self):\n        class Indenter(object):\n            def __enter__(_):\n                self._indent += 1\n                return self\n\n            def __exit__(_, *args):\n                assert self._indent > 0\n                self._indent -= 1\n\n        return Indenter()",
        "begin_line": 693,
        "end_line": 703,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001426330052774212,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.Indenter.indent#693",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Indenter",
        "signature": "tornado.template.Indenter.indent(self)",
        "snippet": "    def indent(self):\n        class Indenter(object):\n            def __enter__(_):\n                self._indent += 1\n                return self\n\n            def __exit__(_, *args):\n                assert self._indent > 0\n                self._indent -= 1\n\n        return Indenter()",
        "begin_line": 693,
        "end_line": 703,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013528138528138528,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.Indenter.__enter__#695",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Indenter",
        "signature": "tornado.template.Indenter.__enter__(_)",
        "snippet": "            def __enter__(_):\n                self._indent += 1\n                return self",
        "begin_line": 695,
        "end_line": 697,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001426330052774212,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.Indenter.__exit__#699",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.Indenter",
        "signature": "tornado.template.Indenter.__exit__(_, *args)",
        "snippet": "            def __exit__(_, *args):\n                assert self._indent > 0\n                self._indent -= 1",
        "begin_line": 699,
        "end_line": 701,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001426330052774212,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._CodeWriter.include#705",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._CodeWriter",
        "signature": "tornado.template._CodeWriter.include(self, template, line)",
        "snippet": "    def include(self, template, line):\n        self.include_stack.append((self.current_template, line))\n        self.current_template = template\n\n        class IncludeTemplate(object):\n            def __enter__(_):\n                return self\n\n            def __exit__(_, *args):\n                self.current_template = self.include_stack.pop()[0]\n\n        return IncludeTemplate()",
        "begin_line": 705,
        "end_line": 716,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001775568181818182,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.IncludeTemplate.include#705",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.IncludeTemplate",
        "signature": "tornado.template.IncludeTemplate.include(self, template, line)",
        "snippet": "    def include(self, template, line):\n        self.include_stack.append((self.current_template, line))\n        self.current_template = template\n\n        class IncludeTemplate(object):\n            def __enter__(_):\n                return self\n\n            def __exit__(_, *args):\n                self.current_template = self.include_stack.pop()[0]\n\n        return IncludeTemplate()",
        "begin_line": 705,
        "end_line": 716,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001623640201331385,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.IncludeTemplate.__enter__#710",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.IncludeTemplate",
        "signature": "tornado.template.IncludeTemplate.__enter__(_)",
        "snippet": "            def __enter__(_):\n                return self",
        "begin_line": 710,
        "end_line": 711,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001775568181818182,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template.IncludeTemplate.__exit__#713",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template.IncludeTemplate",
        "signature": "tornado.template.IncludeTemplate.__exit__(_, *args)",
        "snippet": "            def __exit__(_, *args):\n                self.current_template = self.include_stack.pop()[0]",
        "begin_line": 713,
        "end_line": 714,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001775568181818182,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._CodeWriter.write_line#718",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._CodeWriter",
        "signature": "tornado.template._CodeWriter.write_line(self, line, line_number, indent=None)",
        "snippet": "    def write_line(self, line, line_number, indent=None):\n        if indent is None:\n            indent = self._indent\n        line_comment = '  # %s:%d' % (self.current_template.name, line_number)\n        if self.include_stack:\n            ancestors = [\"%s:%d\" % (tmpl.name, lineno)\n                         for (tmpl, lineno) in self.include_stack]\n            line_comment += ' (via %s)' % ', '.join(reversed(ancestors))\n        print(\"    \" * indent + line + line_comment, file=self.file)",
        "begin_line": 718,
        "end_line": 726,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001775568181818182,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._TemplateReader.__init__#730",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._TemplateReader",
        "signature": "tornado.template._TemplateReader.__init__(self, name, text, whitespace)",
        "snippet": "    def __init__(self, name, text, whitespace):\n        self.name = name\n        self.text = text\n        self.whitespace = whitespace\n        self.line = 1\n        self.pos = 0",
        "begin_line": 730,
        "end_line": 735,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014072614691809738,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._TemplateReader.find#737",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._TemplateReader",
        "signature": "tornado.template._TemplateReader.find(self, needle, start=0, end=None)",
        "snippet": "    def find(self, needle, start=0, end=None):\n        assert start >= 0, start\n        pos = self.pos\n        start += pos\n        if end is None:\n            index = self.text.find(needle, start)\n        else:\n            end += pos\n            assert end >= start\n            index = self.text.find(needle, start, end)\n        if index != -1:\n            index -= pos\n        return index",
        "begin_line": 737,
        "end_line": 749,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014382281029771322,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._TemplateReader.consume#751",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._TemplateReader",
        "signature": "tornado.template._TemplateReader.consume(self, count=None)",
        "snippet": "    def consume(self, count=None):\n        if count is None:\n            count = len(self.text) - self.pos\n        newpos = self.pos + count\n        self.line += self.text.count(\"\\n\", self.pos, newpos)\n        s = self.text[self.pos:newpos]\n        self.pos = newpos\n        return s",
        "begin_line": 751,
        "end_line": 758,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001426330052774212,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._TemplateReader.remaining#760",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._TemplateReader",
        "signature": "tornado.template._TemplateReader.remaining(self)",
        "snippet": "    def remaining(self):\n        return len(self.text) - self.pos",
        "begin_line": 760,
        "end_line": 761,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014382281029771322,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._TemplateReader.__getitem__#766",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._TemplateReader",
        "signature": "tornado.template._TemplateReader.__getitem__(self, key)",
        "snippet": "    def __getitem__(self, key):\n        if type(key) is slice:\n            size = len(self)\n            start, stop, step = key.indices(size)\n            if start is None:\n                start = self.pos\n            else:\n                start += self.pos\n            if stop is not None:\n                stop += self.pos\n            return self.text[slice(start, stop, step)]\n        elif key < 0:\n            return self.text[key]\n        else:\n            return self.text[self.pos + key]",
        "begin_line": 766,
        "end_line": 780,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014382281029771322,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._TemplateReader.raise_parse_error#785",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template._TemplateReader",
        "signature": "tornado.template._TemplateReader.raise_parse_error(self, msg)",
        "snippet": "    def raise_parse_error(self, msg):\n        raise ParseError(msg, self.name, self.line)",
        "begin_line": 785,
        "end_line": 786,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.template._parse#795",
        "src_path": "tornado/template.py",
        "class_name": "tornado.template",
        "signature": "tornado.template._parse(reader, template, in_block=None, in_loop=None)",
        "snippet": "def _parse(reader, template, in_block=None, in_loop=None):\n    body = _ChunkList([])\n    while True:\n        # Find next template directive\n        curly = 0\n        while True:\n            curly = reader.find(\"{\", curly)\n            if curly == -1 or curly + 1 == reader.remaining():\n                # EOF\n                if in_block:\n                    reader.raise_parse_error(\n                        \"Missing {%% end %%} block for %s\" % in_block)\n                body.chunks.append(_Text(reader.consume(), reader.line,\n                                         reader.whitespace))\n                return body\n            # If the first curly brace is not the start of a special token,\n            # start searching from the character after it\n            if reader[curly + 1] not in (\"{\", \"%\", \"#\"):\n                curly += 1\n                continue\n            # When there are more than 2 curlies in a row, use the\n            # innermost ones.  This is useful when generating languages\n            # like latex where curlies are also meaningful\n            if (curly + 2 < reader.remaining() and\n                    reader[curly + 1] == '{' and reader[curly + 2] == '{'):\n                curly += 1\n                continue\n            break\n\n        # Append any text before the special token\n        if curly > 0:\n            cons = reader.consume(curly)\n            body.chunks.append(_Text(cons, reader.line,\n                                     reader.whitespace))\n\n        start_brace = reader.consume(2)\n        line = reader.line\n\n        # Template directives may be escaped as \"{{!\" or \"{%!\".\n        # In this case output the braces and consume the \"!\".\n        # This is especially useful in conjunction with jquery templates,\n        # which also use double braces.\n        if reader.remaining() and reader[0] == \"!\":\n            reader.consume(1)\n            body.chunks.append(_Text(start_brace, line,\n                                     reader.whitespace))\n            continue\n\n        # Comment\n        if start_brace == \"{#\":\n            end = reader.find(\"#}\")\n            if end == -1:\n                reader.raise_parse_error(\"Missing end comment #}\")\n            contents = reader.consume(end).strip()\n            reader.consume(2)\n            continue\n\n        # Expression\n        if start_brace == \"{{\":\n            end = reader.find(\"}}\")\n            if end == -1:\n                reader.raise_parse_error(\"Missing end expression }}\")\n            contents = reader.consume(end).strip()\n            reader.consume(2)\n            if not contents:\n                reader.raise_parse_error(\"Empty expression\")\n            body.chunks.append(_Expression(contents, line))\n            continue\n\n        # Block\n        assert start_brace == \"{%\", start_brace\n        end = reader.find(\"%}\")\n        if end == -1:\n            reader.raise_parse_error(\"Missing end block %}\")\n        contents = reader.consume(end).strip()\n        reader.consume(2)\n        if not contents:\n            reader.raise_parse_error(\"Empty block tag ({% %})\")\n\n        operator, space, suffix = contents.partition(\" \")\n        suffix = suffix.strip()\n\n        # Intermediate (\"else\", \"elif\", etc) blocks\n        intermediate_blocks = {\n            \"else\": set([\"if\", \"for\", \"while\", \"try\"]),\n            \"elif\": set([\"if\"]),\n            \"except\": set([\"try\"]),\n            \"finally\": set([\"try\"]),\n        }\n        allowed_parents = intermediate_blocks.get(operator)\n        if allowed_parents is not None:\n            if not in_block:\n                reader.raise_parse_error(\"%s outside %s block\" %\n                                         (operator, allowed_parents))\n            if in_block not in allowed_parents:\n                reader.raise_parse_error(\n                    \"%s block cannot be attached to %s block\" %\n                    (operator, in_block))\n            body.chunks.append(_IntermediateControlBlock(contents, line))\n            continue\n\n        # End tag\n        elif operator == \"end\":\n            if not in_block:\n                reader.raise_parse_error(\"Extra {% end %} block\")\n            return body\n\n        elif operator in (\"extends\", \"include\", \"set\", \"import\", \"from\",\n                          \"comment\", \"autoescape\", \"whitespace\", \"raw\",\n                          \"module\"):\n            if operator == \"comment\":\n                continue\n            if operator == \"extends\":\n                suffix = suffix.strip('\"').strip(\"'\")\n                if not suffix:\n                    reader.raise_parse_error(\"extends missing file path\")\n                block = _ExtendsBlock(suffix)\n            elif operator in (\"import\", \"from\"):\n                if not suffix:\n                    reader.raise_parse_error(\"import missing statement\")\n                block = _Statement(contents, line)\n            elif operator == \"include\":\n                suffix = suffix.strip('\"').strip(\"'\")\n                if not suffix:\n                    reader.raise_parse_error(\"include missing file path\")\n                block = _IncludeBlock(suffix, reader, line)\n            elif operator == \"set\":\n                if not suffix:\n                    reader.raise_parse_error(\"set missing statement\")\n                block = _Statement(suffix, line)\n            elif operator == \"autoescape\":\n                fn = suffix.strip()\n                if fn == \"None\":\n                    fn = None\n                template.autoescape = fn\n                continue\n            elif operator == \"whitespace\":\n                mode = suffix.strip()\n                # Validate the selected mode\n                filter_whitespace(mode, '')\n                reader.whitespace = mode\n                continue\n            elif operator == \"raw\":\n                block = _Expression(suffix, line, raw=True)\n            elif operator == \"module\":\n                block = _Module(suffix, line)\n            body.chunks.append(block)\n            continue\n\n        elif operator in (\"apply\", \"block\", \"try\", \"if\", \"for\", \"while\"):\n            # parse inner body recursively\n            if operator in (\"for\", \"while\"):\n                block_body = _parse(reader, template, operator, operator)\n            elif operator == \"apply\":\n                # apply creates a nested function so syntactically it's not\n                # in the loop.\n                block_body = _parse(reader, template, operator, None)\n            else:\n                block_body = _parse(reader, template, operator, in_loop)\n\n            if operator == \"apply\":\n                if not suffix:\n                    reader.raise_parse_error(\"apply missing method name\")\n                block = _ApplyBlock(suffix, line, block_body)\n            elif operator == \"block\":\n                if not suffix:\n                    reader.raise_parse_error(\"block missing name\")\n                block = _NamedBlock(suffix, block_body, template, line)\n            else:\n                block = _ControlBlock(contents, line, block_body)\n            body.chunks.append(block)\n            continue\n\n        elif operator in (\"break\", \"continue\"):\n            if not in_loop:\n                reader.raise_parse_error(\"%s outside %s block\" %\n                                         (operator, set([\"for\", \"while\"])))\n            body.chunks.append(_Statement(contents, line))\n            continue\n\n        else:\n            reader.raise_parse_error(\"unknown operator: %r\" % operator)",
        "begin_line": 795,
        "end_line": 976,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.testing.bind_unused_port#77",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing",
        "signature": "tornado.testing.bind_unused_port(reuse_port=False)",
        "snippet": "def bind_unused_port(reuse_port=False):\n    \"\"\"Binds a server socket to an available port on localhost.\n\n    Returns a tuple (socket, port).\n\n    .. versionchanged:: 4.4\n       Always binds to ``127.0.0.1`` without resolving the name\n       ``localhost``.\n    \"\"\"\n    sock = netutil.bind_sockets(None, '127.0.0.1', family=socket.AF_INET,\n                                reuse_port=reuse_port)[0]\n    port = sock.getsockname()[1]\n    return sock, port",
        "begin_line": 77,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006756756756756757,
            "pseudo_dstar_susp": 0.0196078431372549,
            "pseudo_tarantula_susp": 0.0026595744680851063,
            "pseudo_op2_susp": 0.0196078431372549,
            "pseudo_barinel_susp": 0.0026595744680851063
        }
    },
    {
        "name": "tornado.testing.get_async_test_timeout#92",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing",
        "signature": "tornado.testing.get_async_test_timeout()",
        "snippet": "def get_async_test_timeout():\n    \"\"\"Get the global timeout setting for async tests.\n\n    Returns a float, the timeout in seconds.\n\n    .. versionadded:: 3.1\n    \"\"\"\n    try:\n        return float(os.environ.get('ASYNC_TEST_TIMEOUT'))\n    except (ValueError, TypeError):\n        return 5",
        "begin_line": 92,
        "end_line": 102,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029411764705882353,
            "pseudo_dstar_susp": 0.0038314176245210726,
            "pseudo_tarantula_susp": 0.0016835016835016834,
            "pseudo_op2_susp": 0.0038314176245210726,
            "pseudo_barinel_susp": 0.0016835016835016834
        }
    },
    {
        "name": "tornado.testing._TestMethodWrapper.__init__#114",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing._TestMethodWrapper",
        "signature": "tornado.testing._TestMethodWrapper.__init__(self, orig_method)",
        "snippet": "    def __init__(self, orig_method):\n        self.orig_method = orig_method",
        "begin_line": 114,
        "end_line": 115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0025188916876574307,
            "pseudo_dstar_susp": 0.01020408163265306,
            "pseudo_tarantula_susp": 0.0014367816091954023,
            "pseudo_op2_susp": 0.01020408163265306,
            "pseudo_barinel_susp": 0.0014367816091954023
        }
    },
    {
        "name": "tornado.testing._TestMethodWrapper.__call__#117",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing._TestMethodWrapper",
        "signature": "tornado.testing._TestMethodWrapper.__call__(self, *args, **kwargs)",
        "snippet": "    def __call__(self, *args, **kwargs):\n        result = self.orig_method(*args, **kwargs)\n        if isinstance(result, GeneratorType) or iscoroutine(result):\n            raise TypeError(\"Generator and coroutine test methods should be\"\n                            \" decorated with tornado.testing.gen_test\")\n        elif result is not None:\n            raise ValueError(\"Return value from test method ignored: %r\" %\n                             result)",
        "begin_line": 117,
        "end_line": 124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002197802197802198,
            "pseudo_dstar_susp": 0.006060606060606061,
            "pseudo_tarantula_susp": 0.0013623978201634877,
            "pseudo_op2_susp": 0.006060606060606061,
            "pseudo_barinel_susp": 0.0013623978201634877
        }
    },
    {
        "name": "tornado.testing._TestMethodWrapper.__getattr__#126",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing._TestMethodWrapper",
        "signature": "tornado.testing._TestMethodWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        \"\"\"Proxy all unknown attributes to the original method.\n\n        This is important for some of the decorators in the `unittest`\n        module, such as `unittest.skipIf`.\n        \"\"\"\n        return getattr(self.orig_method, name)",
        "begin_line": 126,
        "end_line": 132,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0025188916876574307,
            "pseudo_dstar_susp": 0.01020408163265306,
            "pseudo_tarantula_susp": 0.0014367816091954023,
            "pseudo_op2_susp": 0.01020408163265306,
            "pseudo_barinel_susp": 0.0014367816091954023
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase.__init__#196",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase.__init__(self, methodName='runTest')",
        "snippet": "    def __init__(self, methodName='runTest'):\n        super(AsyncTestCase, self).__init__(methodName)\n        self.__stopped = False\n        self.__running = False\n        self.__failure = None\n        self.__stop_args = None\n        self.__timeout = None\n\n        # It's easy to forget the @gen_test decorator, but if you do\n        # the test will silently be ignored because nothing will consume\n        # the generator.  Replace the test method with a wrapper that will\n        # make sure it's not an undecorated generator.\n        setattr(self, methodName, _TestMethodWrapper(getattr(self, methodName)))",
        "begin_line": 196,
        "end_line": 208,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0025188916876574307,
            "pseudo_dstar_susp": 0.01020408163265306,
            "pseudo_tarantula_susp": 0.0014367816091954023,
            "pseudo_op2_susp": 0.01020408163265306,
            "pseudo_barinel_susp": 0.0014367816091954023
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase.setUp#210",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase.setUp(self)",
        "snippet": "    def setUp(self):\n        super(AsyncTestCase, self).setUp()\n        self.io_loop = self.get_new_ioloop()\n        self.io_loop.make_current()",
        "begin_line": 210,
        "end_line": 213,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0025906735751295338,
            "pseudo_dstar_susp": 0.011494252873563218,
            "pseudo_tarantula_susp": 0.00145985401459854,
            "pseudo_op2_susp": 0.011494252873563218,
            "pseudo_barinel_susp": 0.00145985401459854
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase.tearDown#215",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase.tearDown(self)",
        "snippet": "    def tearDown(self):\n        # Clean up Subprocess, so it can be used again with a new ioloop.\n        Subprocess.uninitialize()\n        self.io_loop.clear_current()\n        # Try to clean up any file descriptors left open in the ioloop.\n        # This avoids leaks, especially when tests are run repeatedly\n        # in the same process with autoreload (because curl does not\n        # set FD_CLOEXEC on its file descriptors)\n        self.io_loop.close(all_fds=True)\n        super(AsyncTestCase, self).tearDown()\n        # In case an exception escaped or the StackContext caught an exception\n        # when there wasn't a wait() to re-raise it, do so here.\n        # This is our last chance to raise an exception in a way that the\n        # unittest machinery understands.\n        self.__rethrow()",
        "begin_line": 215,
        "end_line": 229,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002197802197802198,
            "pseudo_dstar_susp": 0.006060606060606061,
            "pseudo_tarantula_susp": 0.0013623978201634877,
            "pseudo_op2_susp": 0.006060606060606061,
            "pseudo_barinel_susp": 0.0013623978201634877
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase.get_new_ioloop#231",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase.get_new_ioloop(self)",
        "snippet": "    def get_new_ioloop(self):\n        \"\"\"Creates a new `.IOLoop` for this test.  May be overridden in\n        subclasses for tests that require a specific `.IOLoop` (usually\n        the singleton `.IOLoop.instance()`).\n        \"\"\"\n        return IOLoop()",
        "begin_line": 231,
        "end_line": 236,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002638522427440633,
            "pseudo_dstar_susp": 0.011904761904761904,
            "pseudo_tarantula_susp": 0.001466275659824047,
            "pseudo_op2_susp": 0.011904761904761904,
            "pseudo_barinel_susp": 0.001466275659824047
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase._handle_exception#238",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase._handle_exception(self, typ, value, tb)",
        "snippet": "    def _handle_exception(self, typ, value, tb):\n        if self.__failure is None:\n            self.__failure = (typ, value, tb)\n        else:\n            app_log.error(\"multiple unhandled exceptions in test\",\n                          exc_info=(typ, value, tb))\n        self.stop()\n        return True",
        "begin_line": 238,
        "end_line": 245,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.08333333333333333,
            "pseudo_dstar_susp": 0.0029154518950437317,
            "pseudo_tarantula_susp": 0.006097560975609756,
            "pseudo_op2_susp": 0.0029154518950437317,
            "pseudo_barinel_susp": 0.006097560975609756
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase.__rethrow#247",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase.__rethrow(self)",
        "snippet": "    def __rethrow(self):\n        if self.__failure is not None:\n            failure = self.__failure\n            self.__failure = None\n            raise_exc_info(failure)",
        "begin_line": 247,
        "end_line": 251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0625,
            "pseudo_dstar_susp": 0.01020408163265306,
            "pseudo_tarantula_susp": 0.005952380952380952,
            "pseudo_op2_susp": 0.01020408163265306,
            "pseudo_barinel_susp": 0.005952380952380952
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase.run#253",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase.run(self, result=None)",
        "snippet": "    def run(self, result=None):\n        with ExceptionStackContext(self._handle_exception):\n            super(AsyncTestCase, self).run(result)\n        # As a last resort, if an exception escaped super.run() and wasn't\n        # re-raised in tearDown, raise it here.  This will cause the\n        # unittest run to fail messily, but that's better than silently\n        # ignoring an error.\n        self.__rethrow()",
        "begin_line": 253,
        "end_line": 260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0025188916876574307,
            "pseudo_dstar_susp": 0.01020408163265306,
            "pseudo_tarantula_susp": 0.0014367816091954023,
            "pseudo_op2_susp": 0.01020408163265306,
            "pseudo_barinel_susp": 0.0014367816091954023
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase.stop#262",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase.stop(self, _arg=None, **kwargs)",
        "snippet": "    def stop(self, _arg=None, **kwargs):\n        \"\"\"Stops the `.IOLoop`, causing one pending (or future) call to `wait()`\n        to return.\n\n        Keyword arguments or a single positional argument passed to `stop()` are\n        saved and will be returned by `wait()`.\n        \"\"\"\n        assert _arg is None or not kwargs\n        self.__stop_args = kwargs or _arg\n        if self.__running:\n            self.io_loop.stop()\n            self.__running = False\n        self.__stopped = True",
        "begin_line": 262,
        "end_line": 274,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003105590062111801,
            "pseudo_dstar_susp": 0.004310344827586207,
            "pseudo_tarantula_susp": 0.001851851851851852,
            "pseudo_op2_susp": 0.004310344827586207,
            "pseudo_barinel_susp": 0.001851851851851852
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase.wait#276",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase.wait(self, condition=None, timeout=None)",
        "snippet": "    def wait(self, condition=None, timeout=None):\n        \"\"\"Runs the `.IOLoop` until stop is called or timeout has passed.\n\n        In the event of a timeout, an exception will be thrown. The\n        default timeout is 5 seconds; it may be overridden with a\n        ``timeout`` keyword argument or globally with the\n        ``ASYNC_TEST_TIMEOUT`` environment variable.\n\n        If ``condition`` is not None, the `.IOLoop` will be restarted\n        after `stop()` until ``condition()`` returns true.\n\n        .. versionchanged:: 3.1\n           Added the ``ASYNC_TEST_TIMEOUT`` environment variable.\n        \"\"\"\n        if timeout is None:\n            timeout = get_async_test_timeout()\n\n        if not self.__stopped:\n            if timeout:\n                def timeout_func():\n                    try:\n                        raise self.failureException(\n                            'Async operation timed out after %s seconds' %\n                            timeout)\n                    except Exception:\n                        self.__failure = sys.exc_info()\n                    self.stop()\n                self.__timeout = self.io_loop.add_timeout(self.io_loop.time() + timeout,\n                                                          timeout_func)\n            while True:\n                self.__running = True\n                self.io_loop.start()\n                if (self.__failure is not None or\n                        condition is None or condition()):\n                    break\n            if self.__timeout is not None:\n                self.io_loop.remove_timeout(self.__timeout)\n                self.__timeout = None\n        assert self.__stopped\n        self.__stopped = False\n        self.__rethrow()\n        result = self.__stop_args\n        self.__stop_args = None\n        return result",
        "begin_line": 276,
        "end_line": 319,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0030303030303030303,
            "pseudo_dstar_susp": 0.0033333333333333335,
            "pseudo_tarantula_susp": 0.00186219739292365,
            "pseudo_op2_susp": 0.0033333333333333335,
            "pseudo_barinel_susp": 0.00186219739292365
        }
    },
    {
        "name": "tornado.testing.AsyncTestCase.timeout_func#295",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncTestCase",
        "signature": "tornado.testing.AsyncTestCase.timeout_func()",
        "snippet": "                def timeout_func():\n                    try:\n                        raise self.failureException(\n                            'Async operation timed out after %s seconds' %\n                            timeout)\n                    except Exception:\n                        self.__failure = sys.exc_info()\n                    self.stop()",
        "begin_line": 295,
        "end_line": 302,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002976190476190476,
            "pseudo_dstar_susp": 0.0032679738562091504,
            "pseudo_tarantula_susp": 0.0018050541516245488,
            "pseudo_op2_susp": 0.0032679738562091504,
            "pseudo_barinel_susp": 0.0018050541516245488
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPTestCase.setUp#354",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPTestCase",
        "signature": "tornado.testing.AsyncHTTPTestCase.setUp(self)",
        "snippet": "    def setUp(self):\n        super(AsyncHTTPTestCase, self).setUp()\n        sock, port = bind_unused_port()\n        self.__port = port\n\n        self.http_client = self.get_http_client()\n        self._app = self.get_app()\n        self.http_server = self.get_http_server()\n        self.http_server.add_sockets([sock])",
        "begin_line": 354,
        "end_line": 362,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001597444089456869,
            "pseudo_dstar_susp": 0.0016666666666666668,
            "pseudo_tarantula_susp": 0.0011560693641618498,
            "pseudo_op2_susp": 0.0016666666666666668,
            "pseudo_barinel_susp": 0.0011560693641618498
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPTestCase.get_http_client#364",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPTestCase",
        "signature": "tornado.testing.AsyncHTTPTestCase.get_http_client(self)",
        "snippet": "    def get_http_client(self):\n        return AsyncHTTPClient()",
        "begin_line": 364,
        "end_line": 365,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041649312786339027,
            "pseudo_dstar_susp": 0.0004576659038901602,
            "pseudo_tarantula_susp": 0.0004091653027823241,
            "pseudo_op2_susp": 0.0004576659038901602,
            "pseudo_barinel_susp": 0.0004091653027823241
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPTestCase.get_http_server#367",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPTestCase",
        "signature": "tornado.testing.AsyncHTTPTestCase.get_http_server(self)",
        "snippet": "    def get_http_server(self):\n        return HTTPServer(self._app, **self.get_httpserver_options())",
        "begin_line": 367,
        "end_line": 368,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001597444089456869,
            "pseudo_dstar_susp": 0.0016666666666666668,
            "pseudo_tarantula_susp": 0.0011560693641618498,
            "pseudo_op2_susp": 0.0016666666666666668,
            "pseudo_barinel_susp": 0.0011560693641618498
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPTestCase.fetch#376",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPTestCase",
        "signature": "tornado.testing.AsyncHTTPTestCase.fetch(self, path, **kwargs)",
        "snippet": "    def fetch(self, path, **kwargs):\n        \"\"\"Convenience method to synchronously fetch a URL.\n\n        The given path will be appended to the local server's host and\n        port.  Any additional kwargs will be passed directly to\n        `.AsyncHTTPClient.fetch` (and so could be used to pass\n        ``method=\"POST\"``, ``body=\"...\"``, etc).\n\n        If the path begins with http:// or https://, it will be treated as a\n        full URL and will be fetched as-is.\n\n        .. versionchanged:: 5.0\n           Added support for absolute URLs.\n        \"\"\"\n        if path.lower().startswith(('http://', 'https://')):\n            self.http_client.fetch(path, self.stop, **kwargs)\n        else:\n            self.http_client.fetch(self.get_url(path), self.stop, **kwargs)\n        return self.wait()",
        "begin_line": 376,
        "end_line": 394,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008695652173913044,
            "pseudo_dstar_susp": 0.000949667616334283,
            "pseudo_tarantula_susp": 0.0007304601899196494,
            "pseudo_op2_susp": 0.000949667616334283,
            "pseudo_barinel_susp": 0.0007304601899196494
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPTestCase.get_httpserver_options#396",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPTestCase",
        "signature": "tornado.testing.AsyncHTTPTestCase.get_httpserver_options(self)",
        "snippet": "    def get_httpserver_options(self):\n        \"\"\"May be overridden by subclasses to return additional\n        keyword arguments for the server.\n        \"\"\"\n        return {}",
        "begin_line": 396,
        "end_line": 400,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004405286343612335,
            "pseudo_dstar_susp": 0.0005076142131979696,
            "pseudo_tarantula_susp": 0.000429553264604811,
            "pseudo_op2_susp": 0.0005076142131979696,
            "pseudo_barinel_susp": 0.000429553264604811
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPTestCase.get_http_port#402",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPTestCase",
        "signature": "tornado.testing.AsyncHTTPTestCase.get_http_port(self)",
        "snippet": "    def get_http_port(self):\n        \"\"\"Returns the port used by the server.\n\n        A new port is chosen for each test.\n        \"\"\"\n        return self.__port",
        "begin_line": 402,
        "end_line": 407,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013123359580052493,
            "pseudo_dstar_susp": 0.001375515818431912,
            "pseudo_tarantula_susp": 0.001075268817204301,
            "pseudo_op2_susp": 0.001375515818431912,
            "pseudo_barinel_susp": 0.001075268817204301
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPTestCase.get_protocol#409",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPTestCase",
        "signature": "tornado.testing.AsyncHTTPTestCase.get_protocol(self)",
        "snippet": "    def get_protocol(self):\n        return 'http'",
        "begin_line": 409,
        "end_line": 410,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004697040864255519,
            "pseudo_dstar_susp": 0.0005449591280653951,
            "pseudo_tarantula_susp": 0.0004610419548178884,
            "pseudo_op2_susp": 0.0005449591280653951,
            "pseudo_barinel_susp": 0.0004610419548178884
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPTestCase.get_url#412",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPTestCase",
        "signature": "tornado.testing.AsyncHTTPTestCase.get_url(self, path)",
        "snippet": "    def get_url(self, path):\n        \"\"\"Returns an absolute url for the given path on the test server.\"\"\"\n        return '%s://127.0.0.1:%s%s' % (self.get_protocol(),\n                                        self.get_http_port(), path)",
        "begin_line": 412,
        "end_line": 415,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001092896174863388,
            "pseudo_dstar_susp": 0.0009652509652509653,
            "pseudo_tarantula_susp": 0.0009970089730807576,
            "pseudo_op2_susp": 0.0009652509652509653,
            "pseudo_barinel_susp": 0.0009970089730807576
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPTestCase.tearDown#417",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPTestCase",
        "signature": "tornado.testing.AsyncHTTPTestCase.tearDown(self)",
        "snippet": "    def tearDown(self):\n        self.http_server.stop()\n        self.io_loop.run_sync(self.http_server.close_all_connections,\n                              timeout=get_async_test_timeout())\n        self.http_client.close()\n        super(AsyncHTTPTestCase, self).tearDown()",
        "begin_line": 417,
        "end_line": 422,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013192612137203166,
            "pseudo_dstar_susp": 0.0014005602240896359,
            "pseudo_tarantula_susp": 0.0010309278350515464,
            "pseudo_op2_susp": 0.0014005602240896359,
            "pseudo_barinel_susp": 0.0010309278350515464
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPSTestCase.get_http_client#430",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPSTestCase",
        "signature": "tornado.testing.AsyncHTTPSTestCase.get_http_client(self)",
        "snippet": "    def get_http_client(self):\n        return AsyncHTTPClient(force_instance=True,\n                               defaults=dict(validate_cert=False))",
        "begin_line": 430,
        "end_line": 432,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008928571428571428,
            "pseudo_dstar_susp": 0.0012578616352201257,
            "pseudo_tarantula_susp": 0.007407407407407408,
            "pseudo_op2_susp": 0.0012578616352201257,
            "pseudo_barinel_susp": 0.007407407407407408
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPSTestCase.get_httpserver_options#434",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPSTestCase",
        "signature": "tornado.testing.AsyncHTTPSTestCase.get_httpserver_options(self)",
        "snippet": "    def get_httpserver_options(self):\n        return dict(ssl_options=self.get_ssl_options())",
        "begin_line": 434,
        "end_line": 435,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008928571428571428,
            "pseudo_dstar_susp": 0.0012578616352201257,
            "pseudo_tarantula_susp": 0.007407407407407408,
            "pseudo_op2_susp": 0.0012578616352201257,
            "pseudo_barinel_susp": 0.007407407407407408
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPSTestCase.get_ssl_options#437",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPSTestCase",
        "signature": "tornado.testing.AsyncHTTPSTestCase.get_ssl_options(self)",
        "snippet": "    def get_ssl_options(self):\n        \"\"\"May be overridden by subclasses to select SSL options.\n\n        By default includes a self-signed testing certificate.\n        \"\"\"\n        # Testing keys were generated with:\n        # openssl req -new -keyout tornado/test/test.key \\\n        #                     -out tornado/test/test.crt -nodes -days 3650 -x509\n        module_dir = os.path.dirname(__file__)\n        return dict(\n            certfile=os.path.join(module_dir, 'test', 'test.crt'),\n            keyfile=os.path.join(module_dir, 'test', 'test.key'))",
        "begin_line": 437,
        "end_line": 448,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008928571428571428,
            "pseudo_dstar_susp": 0.0012578616352201257,
            "pseudo_tarantula_susp": 0.007407407407407408,
            "pseudo_op2_susp": 0.0012578616352201257,
            "pseudo_barinel_susp": 0.007407407407407408
        }
    },
    {
        "name": "tornado.testing.AsyncHTTPSTestCase.get_protocol#450",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.AsyncHTTPSTestCase",
        "signature": "tornado.testing.AsyncHTTPSTestCase.get_protocol(self)",
        "snippet": "    def get_protocol(self):\n        return 'https'",
        "begin_line": 450,
        "end_line": 451,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007575757575757576,
            "pseudo_dstar_susp": 0.0009523809523809524,
            "pseudo_tarantula_susp": 0.008547008547008548,
            "pseudo_op2_susp": 0.0009523809523809524,
            "pseudo_barinel_susp": 0.008547008547008548
        }
    },
    {
        "name": "tornado.testing.gen_test#454",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing",
        "signature": "tornado.testing.gen_test(func=None, timeout=None)",
        "snippet": "def gen_test(func=None, timeout=None):\n    \"\"\"Testing equivalent of ``@gen.coroutine``, to be applied to test methods.\n\n    ``@gen.coroutine`` cannot be used on tests because the `.IOLoop` is not\n    already running.  ``@gen_test`` should be applied to test methods\n    on subclasses of `AsyncTestCase`.\n\n    Example::\n\n        class MyTest(AsyncHTTPTestCase):\n            @gen_test\n            def test_something(self):\n                response = yield self.http_client.fetch(self.get_url('/'))\n\n    By default, ``@gen_test`` times out after 5 seconds. The timeout may be\n    overridden globally with the ``ASYNC_TEST_TIMEOUT`` environment variable,\n    or for each test with the ``timeout`` keyword argument::\n\n        class MyTest(AsyncHTTPTestCase):\n            @gen_test(timeout=10)\n            def test_something_slow(self):\n                response = yield self.http_client.fetch(self.get_url('/'))\n\n    Note that ``@gen_test`` is incompatible with `AsyncTestCase.stop`,\n    `AsyncTestCase.wait`, and `AsyncHTTPTestCase.fetch`. Use ``yield\n    self.http_client.fetch(self.get_url())`` as shown above instead.\n\n    .. versionadded:: 3.1\n       The ``timeout`` argument and ``ASYNC_TEST_TIMEOUT`` environment\n       variable.\n\n    .. versionchanged:: 4.0\n       The wrapper now passes along ``*args, **kwargs`` so it can be used\n       on functions with arguments.\n\n    \"\"\"\n    if timeout is None:\n        timeout = get_async_test_timeout()\n\n    def wrap(f):\n        # Stack up several decorators to allow us to access the generator\n        # object itself.  In the innermost wrapper, we capture the generator\n        # and save it in an attribute of self.  Next, we run the wrapped\n        # function through @gen.coroutine.  Finally, the coroutine is\n        # wrapped again to make it synchronous with run_sync.\n        #\n        # This is a good case study arguing for either some sort of\n        # extensibility in the gen decorators or cancellation support.\n        @functools.wraps(f)\n        def pre_coroutine(self, *args, **kwargs):\n            result = f(self, *args, **kwargs)\n            if isinstance(result, GeneratorType) or iscoroutine(result):\n                self._test_generator = result\n            else:\n                self._test_generator = None\n            return result\n\n        if iscoroutinefunction(f):\n            coro = pre_coroutine\n        else:\n            coro = gen.coroutine(pre_coroutine)\n\n        @functools.wraps(coro)\n        def post_coroutine(self, *args, **kwargs):\n            try:\n                return self.io_loop.run_sync(\n                    functools.partial(coro, self, *args, **kwargs),\n                    timeout=timeout)\n            except TimeoutError as e:\n                # run_sync raises an error with an unhelpful traceback.\n                # If the underlying generator is still running, we can throw the\n                # exception back into it so the stack trace is replaced by the\n                # point where the test is stopped. The only reason the generator\n                # would not be running would be if it were cancelled, which means\n                # a native coroutine, so we can rely on the cr_running attribute.\n                if getattr(self._test_generator, 'cr_running', True):\n                    self._test_generator.throw(e)\n                    # In case the test contains an overly broad except\n                    # clause, we may get back here.\n                # Coroutine was stopped or didn't raise a useful stack trace,\n                # so re-raise the original exception which is better than nothing.\n                raise\n        return post_coroutine\n\n    if func is not None:\n        # Used like:\n        #     @gen_test\n        #     def f(self):\n        #         pass\n        return wrap(func)\n    else:\n        # Used like @gen_test(timeout=10)\n        return wrap",
        "begin_line": 454,
        "end_line": 546,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.testing.wrap#493",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing",
        "signature": "tornado.testing.wrap(f)",
        "snippet": "    def wrap(f):\n        # Stack up several decorators to allow us to access the generator\n        # object itself.  In the innermost wrapper, we capture the generator\n        # and save it in an attribute of self.  Next, we run the wrapped\n        # function through @gen.coroutine.  Finally, the coroutine is\n        # wrapped again to make it synchronous with run_sync.\n        #\n        # This is a good case study arguing for either some sort of\n        # extensibility in the gen decorators or cancellation support.\n        @functools.wraps(f)\n        def pre_coroutine(self, *args, **kwargs):\n            result = f(self, *args, **kwargs)\n            if isinstance(result, GeneratorType) or iscoroutine(result):\n                self._test_generator = result\n            else:\n                self._test_generator = None\n            return result\n\n        if iscoroutinefunction(f):\n            coro = pre_coroutine\n        else:\n            coro = gen.coroutine(pre_coroutine)\n\n        @functools.wraps(coro)\n        def post_coroutine(self, *args, **kwargs):\n            try:\n                return self.io_loop.run_sync(\n                    functools.partial(coro, self, *args, **kwargs),\n                    timeout=timeout)\n            except TimeoutError as e:\n                # run_sync raises an error with an unhelpful traceback.\n                # If the underlying generator is still running, we can throw the\n                # exception back into it so the stack trace is replaced by the\n                # point where the test is stopped. The only reason the generator\n                # would not be running would be if it were cancelled, which means\n                # a native coroutine, so we can rely on the cr_running attribute.\n                if getattr(self._test_generator, 'cr_running', True):\n                    self._test_generator.throw(e)\n                    # In case the test contains an overly broad except\n                    # clause, we may get back here.\n                # Coroutine was stopped or didn't raise a useful stack trace,\n                # so re-raise the original exception which is better than nothing.\n                raise\n        return post_coroutine",
        "begin_line": 493,
        "end_line": 536,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008216926869350862,
            "pseudo_dstar_susp": 0.0007645259938837921,
            "pseudo_tarantula_susp": 0.0008920606601248885,
            "pseudo_op2_susp": 0.0007645259938837921,
            "pseudo_barinel_susp": 0.0008920606601248885
        }
    },
    {
        "name": "tornado.testing.pre_coroutine#503",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing",
        "signature": "tornado.testing.pre_coroutine(self, *args, **kwargs)",
        "snippet": "        def pre_coroutine(self, *args, **kwargs):\n            result = f(self, *args, **kwargs)\n            if isinstance(result, GeneratorType) or iscoroutine(result):\n                self._test_generator = result\n            else:\n                self._test_generator = None\n            return result",
        "begin_line": 503,
        "end_line": 509,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007668711656441718,
            "pseudo_dstar_susp": 0.0007518796992481203,
            "pseudo_tarantula_susp": 0.0007272727272727272,
            "pseudo_op2_susp": 0.0007518796992481203,
            "pseudo_barinel_susp": 0.0007272727272727272
        }
    },
    {
        "name": "tornado.testing.post_coroutine#517",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing",
        "signature": "tornado.testing.post_coroutine(self, *args, **kwargs)",
        "snippet": "        def post_coroutine(self, *args, **kwargs):\n            try:\n                return self.io_loop.run_sync(\n                    functools.partial(coro, self, *args, **kwargs),\n                    timeout=timeout)\n            except TimeoutError as e:\n                # run_sync raises an error with an unhelpful traceback.\n                # If the underlying generator is still running, we can throw the\n                # exception back into it so the stack trace is replaced by the\n                # point where the test is stopped. The only reason the generator\n                # would not be running would be if it were cancelled, which means\n                # a native coroutine, so we can rely on the cr_running attribute.\n                if getattr(self._test_generator, 'cr_running', True):\n                    self._test_generator.throw(e)\n                    # In case the test contains an overly broad except\n                    # clause, we may get back here.\n                # Coroutine was stopped or didn't raise a useful stack trace,\n                # so re-raise the original exception which is better than nothing.\n                raise",
        "begin_line": 517,
        "end_line": 535,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0021691973969631237,
            "pseudo_dstar_susp": 0.0007662835249042146,
            "pseudo_tarantula_susp": 0.005813953488372093,
            "pseudo_op2_susp": 0.0007662835249042146,
            "pseudo_barinel_susp": 0.005813953488372093
        }
    },
    {
        "name": "tornado.testing.ExpectLog.__init__#571",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.ExpectLog",
        "signature": "tornado.testing.ExpectLog.__init__(self, logger, regex, required=True)",
        "snippet": "    def __init__(self, logger, regex, required=True):\n        \"\"\"Constructs an ExpectLog context manager.\n\n        :param logger: Logger object (or name of logger) to watch.  Pass\n            an empty string to watch the root logger.\n        :param regex: Regular expression to match.  Any log entries on\n            the specified logger that match this regex will be suppressed.\n        :param required: If true, an exception will be raised if the end of\n            the ``with`` statement is reached without matching any log entries.\n        \"\"\"\n        if isinstance(logger, basestring_type):\n            logger = logging.getLogger(logger)\n        self.logger = logger\n        self.regex = re.compile(regex)\n        self.required = required\n        self.matched = False\n        self.logged_stack = False",
        "begin_line": 571,
        "end_line": 587,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020833333333333333,
            "pseudo_dstar_susp": 0.0009345794392523365,
            "pseudo_tarantula_susp": 0.0030959752321981426,
            "pseudo_op2_susp": 0.0009345794392523365,
            "pseudo_barinel_susp": 0.0030959752321981426
        }
    },
    {
        "name": "tornado.testing.ExpectLog.filter#589",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.ExpectLog",
        "signature": "tornado.testing.ExpectLog.filter(self, record)",
        "snippet": "    def filter(self, record):\n        if record.exc_info:\n            self.logged_stack = True\n        message = record.getMessage()\n        if self.regex.match(message):\n            self.matched = True\n            return False\n        return True",
        "begin_line": 589,
        "end_line": 596,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014847809948032666,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.testing.ExpectLog.__enter__#598",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.ExpectLog",
        "signature": "tornado.testing.ExpectLog.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self.logger.addFilter(self)\n        return self",
        "begin_line": 598,
        "end_line": 600,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020833333333333333,
            "pseudo_dstar_susp": 0.0009345794392523365,
            "pseudo_tarantula_susp": 0.0030959752321981426,
            "pseudo_op2_susp": 0.0009345794392523365,
            "pseudo_barinel_susp": 0.0030959752321981426
        }
    },
    {
        "name": "tornado.testing.ExpectLog.__exit__#602",
        "src_path": "tornado/testing.py",
        "class_name": "tornado.testing.ExpectLog",
        "signature": "tornado.testing.ExpectLog.__exit__(self, typ, value, tb)",
        "snippet": "    def __exit__(self, typ, value, tb):\n        self.logger.removeFilter(self)\n        if not typ and self.required and not self.matched:\n            raise Exception(\"did not get expected log message\")",
        "begin_line": 602,
        "end_line": 605,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004830917874396135,
            "pseudo_dstar_susp": 0.0009345794392523365,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.0009345794392523365,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.httpclient.HTTPClient.__init__#74",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPClient",
        "signature": "tornado.httpclient.HTTPClient.__init__(self, async_client_class=None, **kwargs)",
        "snippet": "    def __init__(self, async_client_class=None, **kwargs):\n        self._io_loop = IOLoop(make_current=False)\n        if async_client_class is None:\n            async_client_class = AsyncHTTPClient\n        # Create the client while our IOLoop is \"current\", without\n        # clobbering the thread's real current IOLoop (if any).\n        self._async_client = self._io_loop.run_sync(\n            gen.coroutine(lambda: async_client_class(**kwargs)))\n        self._closed = False",
        "begin_line": 74,
        "end_line": 82,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpclient.HTTPClient.__del__#84",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPClient",
        "signature": "tornado.httpclient.HTTPClient.__del__(self)",
        "snippet": "    def __del__(self):\n        self.close()",
        "begin_line": 84,
        "end_line": 85,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpclient.HTTPClient.close#87",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPClient",
        "signature": "tornado.httpclient.HTTPClient.close(self)",
        "snippet": "    def close(self):\n        \"\"\"Closes the HTTPClient, freeing any resources used.\"\"\"\n        if not self._closed:\n            self._async_client.close()\n            self._io_loop.close()\n            self._closed = True",
        "begin_line": 87,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpclient.HTTPClient.fetch#94",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPClient",
        "signature": "tornado.httpclient.HTTPClient.fetch(self, request, **kwargs)",
        "snippet": "    def fetch(self, request, **kwargs):\n        \"\"\"Executes a request, returning an `HTTPResponse`.\n\n        The request may be either a string URL or an `HTTPRequest` object.\n        If it is a string, we construct an `HTTPRequest` using any additional\n        kwargs: ``HTTPRequest(request, **kwargs)``\n\n        If an error occurs during the fetch, we raise an `HTTPError` unless\n        the ``raise_error`` keyword argument is set to False.\n        \"\"\"\n        response = self._io_loop.run_sync(functools.partial(\n            self._async_client.fetch, request, **kwargs))\n        return response",
        "begin_line": 94,
        "end_line": 106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient.configurable_base#148",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient.configurable_base(cls)",
        "snippet": "    def configurable_base(cls):\n        return AsyncHTTPClient",
        "begin_line": 148,
        "end_line": 149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015503875968992248,
            "pseudo_dstar_susp": 0.0016155088852988692,
            "pseudo_tarantula_susp": 0.0011312217194570137,
            "pseudo_op2_susp": 0.0016155088852988692,
            "pseudo_barinel_susp": 0.0011312217194570137
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient.configurable_default#152",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient.configurable_default(cls)",
        "snippet": "    def configurable_default(cls):\n        from tornado.simple_httpclient import SimpleAsyncHTTPClient\n        return SimpleAsyncHTTPClient",
        "begin_line": 152,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient._async_clients#157",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient._async_clients(cls)",
        "snippet": "    def _async_clients(cls):\n        attr_name = '_async_client_dict_' + cls.__name__\n        if not hasattr(cls, attr_name):\n            setattr(cls, attr_name, weakref.WeakKeyDictionary())\n        return getattr(cls, attr_name)",
        "begin_line": 157,
        "end_line": 161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005672149744753262,
            "pseudo_dstar_susp": 0.0006605019815059445,
            "pseudo_tarantula_susp": 0.0005299417064122947,
            "pseudo_op2_susp": 0.0006605019815059445,
            "pseudo_barinel_susp": 0.0005299417064122947
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient.__new__#163",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient.__new__(cls, force_instance=False, **kwargs)",
        "snippet": "    def __new__(cls, force_instance=False, **kwargs):\n        io_loop = IOLoop.current()\n        if force_instance:\n            instance_cache = None\n        else:\n            instance_cache = cls._async_clients()\n        if instance_cache is not None and io_loop in instance_cache:\n            return instance_cache[io_loop]\n        instance = super(AsyncHTTPClient, cls).__new__(cls, **kwargs)\n        # Make sure the instance knows which cache to remove itself from.\n        # It can't simply call _async_clients() because we may be in\n        # __new__(AsyncHTTPClient) but instance.__class__ may be\n        # SimpleAsyncHTTPClient.\n        instance._instance_cache = instance_cache\n        if instance_cache is not None:\n            instance_cache[instance.io_loop] = instance\n        return instance",
        "begin_line": 163,
        "end_line": 179,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003134796238244514,
            "pseudo_dstar_susp": 0.0016155088852988692,
            "pseudo_tarantula_susp": 0.0035587188612099642,
            "pseudo_op2_susp": 0.0016155088852988692,
            "pseudo_barinel_susp": 0.0035587188612099642
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient.initialize#181",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient.initialize(self, defaults=None)",
        "snippet": "    def initialize(self, defaults=None):\n        self.io_loop = IOLoop.current()\n        self.defaults = dict(HTTPRequest._DEFAULTS)\n        if defaults is not None:\n            self.defaults.update(defaults)\n        self._closed = False",
        "begin_line": 181,
        "end_line": 186,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008130081300813009,
            "pseudo_dstar_susp": 0.0016155088852988692,
            "pseudo_tarantula_susp": 0.006578947368421052,
            "pseudo_op2_susp": 0.0016155088852988692,
            "pseudo_barinel_susp": 0.006578947368421052
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient.close#188",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient.close(self)",
        "snippet": "    def close(self):\n        \"\"\"Destroys this HTTP client, freeing any file descriptors used.\n\n        This method is **not needed in normal use** due to the way\n        that `AsyncHTTPClient` objects are transparently reused.\n        ``close()`` is generally only necessary when either the\n        `.IOLoop` is also being closed, or the ``force_instance=True``\n        argument was used when creating the `AsyncHTTPClient`.\n\n        No other methods may be called on the `AsyncHTTPClient` after\n        ``close()``.\n\n        \"\"\"\n        if self._closed:\n            return\n        self._closed = True\n        if self._instance_cache is not None:\n            if self._instance_cache.get(self.io_loop) is not self:\n                raise RuntimeError(\"inconsistent AsyncHTTPClient cache\")\n            del self._instance_cache[self.io_loop]",
        "begin_line": 188,
        "end_line": 207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013020833333333333,
            "pseudo_dstar_susp": 0.0013850415512465374,
            "pseudo_tarantula_susp": 0.0010224948875255625,
            "pseudo_op2_susp": 0.0013850415512465374,
            "pseudo_barinel_susp": 0.0010224948875255625
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient.fetch#209",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient.fetch(self, request, callback=None, raise_error=True, **kwargs)",
        "snippet": "    def fetch(self, request, callback=None, raise_error=True, **kwargs):\n        \"\"\"Executes a request, asynchronously returning an `HTTPResponse`.\n\n        The request may be either a string URL or an `HTTPRequest` object.\n        If it is a string, we construct an `HTTPRequest` using any additional\n        kwargs: ``HTTPRequest(request, **kwargs)``\n\n        This method returns a `.Future` whose result is an\n        `HTTPResponse`. By default, the ``Future`` will raise an\n        `HTTPError` if the request returned a non-200 response code\n        (other errors may also be raised if the server could not be\n        contacted). Instead, if ``raise_error`` is set to False, the\n        response will always be returned regardless of the response\n        code.\n\n        If a ``callback`` is given, it will be invoked with the `HTTPResponse`.\n        In the callback interface, `HTTPError` is not automatically raised.\n        Instead, you must check the response's ``error`` attribute or\n        call its `~HTTPResponse.rethrow` method.\n        \"\"\"\n        if self._closed:\n            raise RuntimeError(\"fetch() called on closed AsyncHTTPClient\")\n        if not isinstance(request, HTTPRequest):\n            request = HTTPRequest(url=request, **kwargs)\n        else:\n            if kwargs:\n                raise ValueError(\"kwargs can't be used if request is an HTTPRequest object\")\n        # We may modify this (to add Host, Accept-Encoding, etc),\n        # so make sure we don't modify the caller's object.  This is also\n        # where normal dicts get converted to HTTPHeaders objects.\n        request.headers = httputil.HTTPHeaders(request.headers)\n        request = _RequestProxy(request, self.defaults)\n        future = Future()\n        if callback is not None:\n            callback = stack_context.wrap(callback)\n\n            def handle_future(future):\n                exc = future.exception()\n                if isinstance(exc, HTTPError) and exc.response is not None:\n                    response = exc.response\n                elif exc is not None:\n                    response = HTTPResponse(\n                        request, 599, error=exc,\n                        request_time=time.time() - request.start_time)\n                else:\n                    response = future.result()\n                self.io_loop.add_callback(callback, response)\n            future.add_done_callback(handle_future)\n\n        def handle_response(response):\n            if raise_error and response.error:\n                future.set_exception(response.error)\n            else:\n                future_set_result_unless_cancelled(future, response)\n        self.fetch_impl(request, handle_response)\n        return future",
        "begin_line": 209,
        "end_line": 264,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001176470588235294,
            "pseudo_dstar_susp": 0.0011337868480725624,
            "pseudo_tarantula_susp": 0.001,
            "pseudo_op2_susp": 0.0011337868480725624,
            "pseudo_barinel_susp": 0.001
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient.handle_future#245",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient.handle_future(future)",
        "snippet": "            def handle_future(future):\n                exc = future.exception()\n                if isinstance(exc, HTTPError) and exc.response is not None:\n                    response = exc.response\n                elif exc is not None:\n                    response = HTTPResponse(\n                        request, 599, error=exc,\n                        request_time=time.time() - request.start_time)\n                else:\n                    response = future.result()\n                self.io_loop.add_callback(callback, response)",
        "begin_line": 245,
        "end_line": 255,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008787346221441124,
            "pseudo_dstar_susp": 0.0013054830287206266,
            "pseudo_tarantula_susp": 0.0017513134851138354,
            "pseudo_op2_susp": 0.0013054830287206266,
            "pseudo_barinel_susp": 0.0017513134851138354
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient.handle_response#258",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient.handle_response(response)",
        "snippet": "        def handle_response(response):\n            if raise_error and response.error:\n                future.set_exception(response.error)\n            else:\n                future_set_result_unless_cancelled(future, response)",
        "begin_line": 258,
        "end_line": 262,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008748906386701663,
            "pseudo_dstar_susp": 0.001303780964797914,
            "pseudo_tarantula_susp": 0.0006779661016949153,
            "pseudo_op2_susp": 0.001303780964797914,
            "pseudo_barinel_susp": 0.0006779661016949153
        }
    },
    {
        "name": "tornado.httpclient.AsyncHTTPClient.configure#270",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.AsyncHTTPClient",
        "signature": "tornado.httpclient.AsyncHTTPClient.configure(cls, impl, **kwargs)",
        "snippet": "    def configure(cls, impl, **kwargs):\n        \"\"\"Configures the `AsyncHTTPClient` subclass to use.\n\n        ``AsyncHTTPClient()`` actually creates an instance of a subclass.\n        This method may be called with either a class object or the\n        fully-qualified name of such a class (or ``None`` to use the default,\n        ``SimpleAsyncHTTPClient``)\n\n        If additional keyword arguments are given, they will be passed\n        to the constructor of each subclass instance created.  The\n        keyword argument ``max_clients`` determines the maximum number\n        of simultaneous `~AsyncHTTPClient.fetch()` operations that can\n        execute in parallel on each `.IOLoop`.  Additional arguments\n        may be supported depending on the implementation class in use.\n\n        Example::\n\n           AsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\")\n        \"\"\"\n        super(AsyncHTTPClient, cls).configure(impl, **kwargs)",
        "begin_line": 270,
        "end_line": 289,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpclient.HTTPRequest.__init__#308",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPRequest",
        "signature": "tornado.httpclient.HTTPRequest.__init__(self, url, method='GET', headers=None, body=None, auth_username=None, auth_password=None, auth_mode=None, connect_timeout=None, request_timeout=None, if_modified_since=None, follow_redirects=None, max_redirects=None, user_agent=None, use_gzip=None, network_interface=None, streaming_callback=None, header_callback=None, prepare_curl_callback=None, proxy_host=None, proxy_port=None, proxy_username=None, proxy_password=None, proxy_auth_mode=None, allow_nonstandard_methods=None, validate_cert=None, ca_certs=None, allow_ipv6=None, client_key=None, client_cert=None, body_producer=None, expect_100_continue=False, decompress_response=None, ssl_options=None)",
        "snippet": "    def __init__(self, url, method=\"GET\", headers=None, body=None,\n                 auth_username=None, auth_password=None, auth_mode=None,\n                 connect_timeout=None, request_timeout=None,\n                 if_modified_since=None, follow_redirects=None,\n                 max_redirects=None, user_agent=None, use_gzip=None,\n                 network_interface=None, streaming_callback=None,\n                 header_callback=None, prepare_curl_callback=None,\n                 proxy_host=None, proxy_port=None, proxy_username=None,\n                 proxy_password=None, proxy_auth_mode=None,\n                 allow_nonstandard_methods=None, validate_cert=None,\n                 ca_certs=None, allow_ipv6=None, client_key=None,\n                 client_cert=None, body_producer=None,\n                 expect_100_continue=False, decompress_response=None,\n                 ssl_options=None):\n        r\"\"\"All parameters except ``url`` are optional.\n\n        :arg str url: URL to fetch\n        :arg str method: HTTP method, e.g. \"GET\" or \"POST\"\n        :arg headers: Additional HTTP headers to pass on the request\n        :type headers: `~tornado.httputil.HTTPHeaders` or `dict`\n        :arg body: HTTP request body as a string (byte or unicode; if unicode\n           the utf-8 encoding will be used)\n        :arg body_producer: Callable used for lazy/asynchronous request bodies.\n           It is called with one argument, a ``write`` function, and should\n           return a `.Future`.  It should call the write function with new\n           data as it becomes available.  The write function returns a\n           `.Future` which can be used for flow control.\n           Only one of ``body`` and ``body_producer`` may\n           be specified.  ``body_producer`` is not supported on\n           ``curl_httpclient``.  When using ``body_producer`` it is recommended\n           to pass a ``Content-Length`` in the headers as otherwise chunked\n           encoding will be used, and many servers do not support chunked\n           encoding on requests.  New in Tornado 4.0\n        :arg str auth_username: Username for HTTP authentication\n        :arg str auth_password: Password for HTTP authentication\n        :arg str auth_mode: Authentication mode; default is \"basic\".\n           Allowed values are implementation-defined; ``curl_httpclient``\n           supports \"basic\" and \"digest\"; ``simple_httpclient`` only supports\n           \"basic\"\n        :arg float connect_timeout: Timeout for initial connection in seconds,\n           default 20 seconds\n        :arg float request_timeout: Timeout for entire request in seconds,\n           default 20 seconds\n        :arg if_modified_since: Timestamp for ``If-Modified-Since`` header\n        :type if_modified_since: `datetime` or `float`\n        :arg bool follow_redirects: Should redirects be followed automatically\n           or return the 3xx response? Default True.\n        :arg int max_redirects: Limit for ``follow_redirects``, default 5.\n        :arg str user_agent: String to send as ``User-Agent`` header\n        :arg bool decompress_response: Request a compressed response from\n           the server and decompress it after downloading.  Default is True.\n           New in Tornado 4.0.\n        :arg bool use_gzip: Deprecated alias for ``decompress_response``\n           since Tornado 4.0.\n        :arg str network_interface: Network interface to use for request.\n           ``curl_httpclient`` only; see note below.\n        :arg collections.abc.Callable streaming_callback: If set, ``streaming_callback`` will\n           be run with each chunk of data as it is received, and\n           ``HTTPResponse.body`` and ``HTTPResponse.buffer`` will be empty in\n           the final response.\n        :arg collections.abc.Callable header_callback: If set, ``header_callback`` will\n           be run with each header line as it is received (including the\n           first line, e.g. ``HTTP/1.0 200 OK\\r\\n``, and a final line\n           containing only ``\\r\\n``.  All lines include the trailing newline\n           characters).  ``HTTPResponse.headers`` will be empty in the final\n           response.  This is most useful in conjunction with\n           ``streaming_callback``, because it's the only way to get access to\n           header data while the request is in progress.\n        :arg collections.abc.Callable prepare_curl_callback: If set, will be called with\n           a ``pycurl.Curl`` object to allow the application to make additional\n           ``setopt`` calls.\n        :arg str proxy_host: HTTP proxy hostname.  To use proxies,\n           ``proxy_host`` and ``proxy_port`` must be set; ``proxy_username``,\n           ``proxy_pass`` and ``proxy_auth_mode`` are optional.  Proxies are\n           currently only supported with ``curl_httpclient``.\n        :arg int proxy_port: HTTP proxy port\n        :arg str proxy_username: HTTP proxy username\n        :arg str proxy_password: HTTP proxy password\n        :arg str proxy_auth_mode: HTTP proxy Authentication mode;\n           default is \"basic\". supports \"basic\" and \"digest\"\n        :arg bool allow_nonstandard_methods: Allow unknown values for ``method``\n           argument? Default is False.\n        :arg bool validate_cert: For HTTPS requests, validate the server's\n           certificate? Default is True.\n        :arg str ca_certs: filename of CA certificates in PEM format,\n           or None to use defaults.  See note below when used with\n           ``curl_httpclient``.\n        :arg str client_key: Filename for client SSL key, if any.  See\n           note below when used with ``curl_httpclient``.\n        :arg str client_cert: Filename for client SSL certificate, if any.\n           See note below when used with ``curl_httpclient``.\n        :arg ssl.SSLContext ssl_options: `ssl.SSLContext` object for use in\n           ``simple_httpclient`` (unsupported by ``curl_httpclient``).\n           Overrides ``validate_cert``, ``ca_certs``, ``client_key``,\n           and ``client_cert``.\n        :arg bool allow_ipv6: Use IPv6 when available?  Default is true.\n        :arg bool expect_100_continue: If true, send the\n           ``Expect: 100-continue`` header and wait for a continue response\n           before sending the request body.  Only supported with\n           simple_httpclient.\n\n        .. note::\n\n            When using ``curl_httpclient`` certain options may be\n            inherited by subsequent fetches because ``pycurl`` does\n            not allow them to be cleanly reset.  This applies to the\n            ``ca_certs``, ``client_key``, ``client_cert``, and\n            ``network_interface`` arguments.  If you use these\n            options, you should pass them on every request (you don't\n            have to always use the same values, but it's not possible\n            to mix requests that specify these options with ones that\n            use the defaults).\n\n        .. versionadded:: 3.1\n           The ``auth_mode`` argument.\n\n        .. versionadded:: 4.0\n           The ``body_producer`` and ``expect_100_continue`` arguments.\n\n        .. versionadded:: 4.2\n           The ``ssl_options`` argument.\n\n        .. versionadded:: 4.5\n           The ``proxy_auth_mode`` argument.\n        \"\"\"\n        # Note that some of these attributes go through property setters\n        # defined below.\n        self.headers = headers\n        if if_modified_since:\n            self.headers[\"If-Modified-Since\"] = httputil.format_timestamp(\n                if_modified_since)\n        self.proxy_host = proxy_host\n        self.proxy_port = proxy_port\n        self.proxy_username = proxy_username\n        self.proxy_password = proxy_password\n        self.proxy_auth_mode = proxy_auth_mode\n        self.url = url\n        self.method = method\n        self.body = body\n        self.body_producer = body_producer\n        self.auth_username = auth_username\n        self.auth_password = auth_password\n        self.auth_mode = auth_mode\n        self.connect_timeout = connect_timeout\n        self.request_timeout = request_timeout\n        self.follow_redirects = follow_redirects\n        self.max_redirects = max_redirects\n        self.user_agent = user_agent\n        if decompress_response is not None:\n            self.decompress_response = decompress_response\n        else:\n            self.decompress_response = use_gzip\n        self.network_interface = network_interface\n        self.streaming_callback = streaming_callback\n        self.header_callback = header_callback\n        self.prepare_curl_callback = prepare_curl_callback\n        self.allow_nonstandard_methods = allow_nonstandard_methods\n        self.validate_cert = validate_cert\n        self.ca_certs = ca_certs\n        self.allow_ipv6 = allow_ipv6\n        self.client_key = client_key\n        self.client_cert = client_cert\n        self.ssl_options = ssl_options\n        self.expect_100_continue = expect_100_continue\n        self.start_time = time.time()",
        "begin_line": 308,
        "end_line": 472,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009115770282588879,
            "pseudo_dstar_susp": 0.0009891196834817012,
            "pseudo_tarantula_susp": 0.0007739938080495357,
            "pseudo_op2_susp": 0.0009891196834817012,
            "pseudo_barinel_susp": 0.0007739938080495357
        }
    },
    {
        "name": "tornado.httpclient.HTTPRequest.headers#475",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPRequest",
        "signature": "tornado.httpclient.HTTPRequest.headers(self)",
        "snippet": "    def headers(self):\n        return self._headers",
        "begin_line": 475,
        "end_line": 476,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009633911368015414,
            "pseudo_dstar_susp": 0.0010309278350515464,
            "pseudo_tarantula_susp": 0.000835421888053467,
            "pseudo_op2_susp": 0.0010309278350515464,
            "pseudo_barinel_susp": 0.000835421888053467
        }
    },
    {
        "name": "tornado.httpclient.HTTPRequest.headers#479",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPRequest",
        "signature": "tornado.httpclient.HTTPRequest.headers(self, value)",
        "snippet": "    def headers(self, value):\n        if value is None:\n            self._headers = httputil.HTTPHeaders()\n        else:\n            self._headers = value",
        "begin_line": 479,
        "end_line": 483,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011001100110011,
            "pseudo_dstar_susp": 0.0010834236186348862,
            "pseudo_tarantula_susp": 0.000949667616334283,
            "pseudo_op2_susp": 0.0010834236186348862,
            "pseudo_barinel_susp": 0.000949667616334283
        }
    },
    {
        "name": "tornado.httpclient.HTTPRequest.body#486",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPRequest",
        "signature": "tornado.httpclient.HTTPRequest.body(self)",
        "snippet": "    def body(self):\n        return self._body",
        "begin_line": 486,
        "end_line": 487,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00045433893684688776,
            "pseudo_dstar_susp": 0.0005254860746190226,
            "pseudo_tarantula_susp": 0.00044444444444444447,
            "pseudo_op2_susp": 0.0005254860746190226,
            "pseudo_barinel_susp": 0.00044444444444444447
        }
    },
    {
        "name": "tornado.httpclient.HTTPRequest.body#490",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPRequest",
        "signature": "tornado.httpclient.HTTPRequest.body(self, value)",
        "snippet": "    def body(self, value):\n        self._body = utf8(value)",
        "begin_line": 490,
        "end_line": 491,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009115770282588879,
            "pseudo_dstar_susp": 0.0009891196834817012,
            "pseudo_tarantula_susp": 0.0007739938080495357,
            "pseudo_op2_susp": 0.0009891196834817012,
            "pseudo_barinel_susp": 0.0007739938080495357
        }
    },
    {
        "name": "tornado.httpclient.HTTPRequest.body_producer#494",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPRequest",
        "signature": "tornado.httpclient.HTTPRequest.body_producer(self)",
        "snippet": "    def body_producer(self):\n        return self._body_producer",
        "begin_line": 494,
        "end_line": 495,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004288164665523156,
            "pseudo_dstar_susp": 0.00048449612403100775,
            "pseudo_tarantula_susp": 0.00041999160016799666,
            "pseudo_op2_susp": 0.00048449612403100775,
            "pseudo_barinel_susp": 0.00041999160016799666
        }
    },
    {
        "name": "tornado.httpclient.HTTPRequest.body_producer#498",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPRequest",
        "signature": "tornado.httpclient.HTTPRequest.body_producer(self, value)",
        "snippet": "    def body_producer(self, value):\n        self._body_producer = stack_context.wrap(value)",
        "begin_line": 498,
        "end_line": 499,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009115770282588879,
            "pseudo_dstar_susp": 0.0009891196834817012,
            "pseudo_tarantula_susp": 0.0007739938080495357,
            "pseudo_op2_susp": 0.0009891196834817012,
            "pseudo_barinel_susp": 0.0007739938080495357
        }
    },
    {
        "name": "tornado.httpclient.HTTPRequest.streaming_callback#502",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPRequest",
        "signature": "tornado.httpclient.HTTPRequest.streaming_callback(self)",
        "snippet": "    def streaming_callback(self):\n        return self._streaming_callback",
        "begin_line": 502,
        "end_line": 503,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041425020712510354,
            "pseudo_dstar_susp": 0.00045495905368516835,
            "pseudo_tarantula_susp": 0.000407000407000407,
            "pseudo_op2_susp": 0.00045495905368516835,
            "pseudo_barinel_susp": 0.000407000407000407
        }
    },
    {
        "name": "tornado.httpclient.HTTPRequest.streaming_callback#506",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPRequest",
        "signature": "tornado.httpclient.HTTPRequest.streaming_callback(self, value)",
        "snippet": "    def streaming_callback(self, value):\n        self._streaming_callback = stack_context.wrap(value)",
        "begin_line": 506,
        "end_line": 507,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009115770282588879,
            "pseudo_dstar_susp": 0.0009891196834817012,
            "pseudo_tarantula_susp": 0.0007739938080495357,
            "pseudo_op2_susp": 0.0009891196834817012,
            "pseudo_barinel_susp": 0.0007739938080495357
        }
    },
    {
        "name": "tornado.httpclient.HTTPRequest.header_callback#510",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPRequest",
        "signature": "tornado.httpclient.HTTPRequest.header_callback(self)",
        "snippet": "    def header_callback(self):\n        return self._header_callback",
        "begin_line": 510,
        "end_line": 511,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000434593654932638,
            "pseudo_dstar_susp": 0.0004940711462450593,
            "pseudo_tarantula_susp": 0.0004266211604095563,
            "pseudo_op2_susp": 0.0004940711462450593,
            "pseudo_barinel_susp": 0.00042643923240938164
        }
    },
    {
        "name": "tornado.httpclient.HTTPRequest.header_callback#514",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPRequest",
        "signature": "tornado.httpclient.HTTPRequest.header_callback(self, value)",
        "snippet": "    def header_callback(self, value):\n        self._header_callback = stack_context.wrap(value)",
        "begin_line": 514,
        "end_line": 515,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009115770282588879,
            "pseudo_dstar_susp": 0.0009891196834817012,
            "pseudo_tarantula_susp": 0.0007739938080495357,
            "pseudo_op2_susp": 0.0009891196834817012,
            "pseudo_barinel_susp": 0.0007739938080495357
        }
    },
    {
        "name": "tornado.httpclient.HTTPRequest.prepare_curl_callback#522",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPRequest",
        "signature": "tornado.httpclient.HTTPRequest.prepare_curl_callback(self, value)",
        "snippet": "    def prepare_curl_callback(self, value):\n        self._prepare_curl_callback = stack_context.wrap(value)",
        "begin_line": 522,
        "end_line": 523,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009115770282588879,
            "pseudo_dstar_susp": 0.0009891196834817012,
            "pseudo_tarantula_susp": 0.0007739938080495357,
            "pseudo_op2_susp": 0.0009891196834817012,
            "pseudo_barinel_susp": 0.0007739938080495357
        }
    },
    {
        "name": "tornado.httpclient.HTTPResponse.__init__#556",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPResponse",
        "signature": "tornado.httpclient.HTTPResponse.__init__(self, request, code, headers=None, buffer=None, effective_url=None, error=None, request_time=None, time_info=None, reason=None)",
        "snippet": "    def __init__(self, request, code, headers=None, buffer=None,\n                 effective_url=None, error=None, request_time=None,\n                 time_info=None, reason=None):\n        if isinstance(request, _RequestProxy):\n            self.request = request.request\n        else:\n            self.request = request\n        self.code = code\n        self.reason = reason or httputil.responses.get(code, \"Unknown\")\n        if headers is not None:\n            self.headers = headers\n        else:\n            self.headers = httputil.HTTPHeaders()\n        self.buffer = buffer\n        self._body = None\n        if effective_url is None:\n            self.effective_url = request.url\n        else:\n            self.effective_url = effective_url\n        if error is None:\n            if self.code < 200 or self.code >= 300:\n                self.error = HTTPError(self.code, message=self.reason,\n                                       response=self)\n            else:\n                self.error = None\n        else:\n            self.error = error\n        self.request_time = request_time\n        self.time_info = time_info or {}",
        "begin_line": 556,
        "end_line": 584,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006734006734006734,
            "pseudo_dstar_susp": 0.0005757052389176742,
            "pseudo_tarantula_susp": 0.0016666666666666668,
            "pseudo_op2_susp": 0.0005757052389176742,
            "pseudo_barinel_susp": 0.0016666666666666668
        }
    },
    {
        "name": "tornado.httpclient.HTTPResponse.body#587",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPResponse",
        "signature": "tornado.httpclient.HTTPResponse.body(self)",
        "snippet": "    def body(self):\n        if self.buffer is None:\n            return None\n        elif self._body is None:\n            self._body = self.buffer.getvalue()\n\n        return self._body",
        "begin_line": 587,
        "end_line": 593,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpclient.HTTPResponse.rethrow#595",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPResponse",
        "signature": "tornado.httpclient.HTTPResponse.rethrow(self)",
        "snippet": "    def rethrow(self):\n        \"\"\"If there was an error on the request, raise an `HTTPError`.\"\"\"\n        if self.error:\n            raise self.error",
        "begin_line": 595,
        "end_line": 598,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpclient.HTTPResponse.__repr__#600",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPResponse",
        "signature": "tornado.httpclient.HTTPResponse.__repr__(self)",
        "snippet": "    def __repr__(self):\n        args = \",\".join(\"%s=%r\" % i for i in sorted(self.__dict__.items()))\n        return \"%s(%s)\" % (self.__class__.__name__, args)",
        "begin_line": 600,
        "end_line": 602,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpclient.HTTPError.__init__#619",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPError",
        "signature": "tornado.httpclient.HTTPError.__init__(self, code, message=None, response=None)",
        "snippet": "    def __init__(self, code, message=None, response=None):\n        self.code = code\n        self.message = message or httputil.responses.get(code, \"Unknown\")\n        self.response = response\n        super(HTTPError, self).__init__(code, message, response)",
        "begin_line": 619,
        "end_line": 623,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005379236148466917,
            "pseudo_dstar_susp": 0.0004987531172069825,
            "pseudo_tarantula_susp": 0.0005959475566150178,
            "pseudo_op2_susp": 0.0004987531172069825,
            "pseudo_barinel_susp": 0.0005959475566150178
        }
    },
    {
        "name": "tornado.httpclient.HTTPError.__str__#625",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient.HTTPError",
        "signature": "tornado.httpclient.HTTPError.__str__(self)",
        "snippet": "    def __str__(self):\n        return \"HTTP %d: %s\" % (self.code, self.message)",
        "begin_line": 625,
        "end_line": 626,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001885369532428356,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httpclient._RequestProxy.__init__#640",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient._RequestProxy",
        "signature": "tornado.httpclient._RequestProxy.__init__(self, request, defaults)",
        "snippet": "    def __init__(self, request, defaults):\n        self.request = request\n        self.defaults = defaults",
        "begin_line": 640,
        "end_line": 642,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009569377990430622,
            "pseudo_dstar_susp": 0.0010256410256410256,
            "pseudo_tarantula_susp": 0.0008285004142502071,
            "pseudo_op2_susp": 0.0010256410256410256,
            "pseudo_barinel_susp": 0.0008285004142502071
        }
    },
    {
        "name": "tornado.httpclient._RequestProxy.__getattr__#644",
        "src_path": "tornado/httpclient.py",
        "class_name": "tornado.httpclient._RequestProxy",
        "signature": "tornado.httpclient._RequestProxy.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        request_attr = getattr(self.request, name)\n        if request_attr is not None:\n            return request_attr\n        elif self.defaults is not None:\n            return self.defaults.get(name, None)\n        else:\n            return None",
        "begin_line": 644,
        "end_line": 651,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009671179883945841,
            "pseudo_dstar_susp": 0.001034126163391934,
            "pseudo_tarantula_susp": 0.0008424599831508003,
            "pseudo_op2_susp": 0.001034126163391934,
            "pseudo_barinel_susp": 0.0008424599831508003
        }
    },
    {
        "name": "tornado.httputil._NormalizedHeaderCache.__missing__#89",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil._NormalizedHeaderCache",
        "signature": "tornado.httputil._NormalizedHeaderCache.__missing__(self, key)",
        "snippet": "    def __missing__(self, key):\n        normalized = \"-\".join([w.capitalize() for w in key.split(\"-\")])\n        self[key] = normalized\n        self.queue.append(key)\n        if len(self.queue) > self.size:\n            # Limit the size of the cache.  LRU would be better, but this\n            # simpler approach should be fine.  In Python 2.7+ we could\n            # use OrderedDict (or in 3.2+, @functools.lru_cache).\n            old_key = self.queue.popleft()\n            del self[old_key]\n        return normalized",
        "begin_line": 89,
        "end_line": 99,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001483459427384661,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.__init__#133",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        self._dict = {}  # type: typing.Dict[str, str]\n        self._as_list = {}  # type: typing.Dict[str, typing.List[str]]\n        self._last_key = None\n        if (len(args) == 1 and len(kwargs) == 0 and\n                isinstance(args[0], HTTPHeaders)):\n            # Copy constructor\n            for k, v in args[0].get_all():\n                self.add(k, v)\n        else:\n            # Dict-style initialization\n            self.update(*args, **kwargs)",
        "begin_line": 133,
        "end_line": 144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012062726176115801,
            "pseudo_dstar_susp": 0.0012987012987012987,
            "pseudo_tarantula_susp": 0.0010131712259371835,
            "pseudo_op2_susp": 0.0012987012987012987,
            "pseudo_barinel_susp": 0.0010131712259371835
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.add#148",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.add(self, name, value)",
        "snippet": "    def add(self, name, value):\n        # type: (str, str) -> None\n        \"\"\"Adds a new value for the given key.\"\"\"\n        norm_name = _normalized_headers[name]\n        self._last_key = norm_name\n        if norm_name in self:\n            self._dict[norm_name] = (native_str(self[norm_name]) + ',' +\n                                     native_str(value))\n            self._as_list[norm_name].append(value)\n        else:\n            self[norm_name] = value",
        "begin_line": 148,
        "end_line": 158,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000543773790103317,
            "pseudo_dstar_susp": 0.0006353240152477764,
            "pseudo_tarantula_susp": 0.0005128205128205128,
            "pseudo_op2_susp": 0.0006353240152477764,
            "pseudo_barinel_susp": 0.0005128205128205128
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.get_list#160",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.get_list(self, name)",
        "snippet": "    def get_list(self, name):\n        \"\"\"Returns all values for the given header as a list.\"\"\"\n        norm_name = _normalized_headers[name]\n        return self._as_list.get(norm_name, [])",
        "begin_line": 160,
        "end_line": 163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014755791648221928,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.get_all#165",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.get_all(self)",
        "snippet": "    def get_all(self):\n        # type: () -> typing.Iterable[typing.Tuple[str, str]]\n        \"\"\"Returns an iterable of all (name, value) pairs.\n\n        If a header has multiple values, multiple pairs will be\n        returned with the same name.\n        \"\"\"\n        for name, values in self._as_list.items():\n            for value in values:\n                yield (name, value)",
        "begin_line": 165,
        "end_line": 174,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008865248226950354,
            "pseudo_dstar_susp": 0.0009624639076034649,
            "pseudo_tarantula_susp": 0.0007209805335255948,
            "pseudo_op2_susp": 0.0009624639076034649,
            "pseudo_barinel_susp": 0.0007209805335255948
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.parse_line#176",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.parse_line(self, line)",
        "snippet": "    def parse_line(self, line):\n        \"\"\"Updates the dictionary with a single header line.\n\n        >>> h = HTTPHeaders()\n        >>> h.parse_line(\"Content-Type: text/html\")\n        >>> h.get('content-type')\n        'text/html'\n        \"\"\"\n        if line[0].isspace():\n            # continuation of a multi-line header\n            if self._last_key is None:\n                raise HTTPInputError(\"first header line cannot start with whitespace\")\n            new_part = ' ' + line.lstrip()\n            self._as_list[self._last_key][-1] += new_part\n            self._dict[self._last_key] += new_part\n        else:\n            try:\n                name, value = line.split(\":\", 1)\n            except ValueError:\n                raise HTTPInputError(\"no colon in header line\")\n            self.add(name, value.strip())",
        "begin_line": 176,
        "end_line": 196,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007163323782234957,
            "pseudo_dstar_susp": 0.0006381620931716656,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.0006381620931716656,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.parse#199",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.parse(cls, headers)",
        "snippet": "    def parse(cls, headers):\n        \"\"\"Returns a dictionary from HTTP header text.\n\n        >>> h = HTTPHeaders.parse(\"Content-Type: text/html\\\\r\\\\nContent-Length: 42\\\\r\\\\n\")\n        >>> sorted(h.items())\n        [('Content-Length', '42'), ('Content-Type', 'text/html')]\n\n        .. versionchanged:: 5.1\n\n           Raises `HTTPInputError` on malformed headers instead of a\n           mix of `KeyError`, and `ValueError`.\n\n        \"\"\"\n        h = cls()\n        for line in _CRLF_RE.split(headers):\n            if line:\n                h.parse_line(line)\n        return h",
        "begin_line": 199,
        "end_line": 216,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005817335660267597,
            "pseudo_dstar_susp": 0.0006844626967830253,
            "pseudo_tarantula_susp": 0.0005399568034557236,
            "pseudo_op2_susp": 0.0006844626967830253,
            "pseudo_barinel_susp": 0.0005399568034557236
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.__setitem__#220",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.__setitem__(self, name, value)",
        "snippet": "    def __setitem__(self, name, value):\n        norm_name = _normalized_headers[name]\n        self._dict[norm_name] = value\n        self._as_list[norm_name] = [value]",
        "begin_line": 220,
        "end_line": 223,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006289308176100629,
            "pseudo_dstar_susp": 0.000757002271006813,
            "pseudo_tarantula_susp": 0.0005787037037037037,
            "pseudo_op2_susp": 0.000757002271006813,
            "pseudo_barinel_susp": 0.0005787037037037037
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.__getitem__#225",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.__getitem__(self, name)",
        "snippet": "    def __getitem__(self, name):\n        # type: (str) -> str\n        return self._dict[_normalized_headers[name]]",
        "begin_line": 225,
        "end_line": 227,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005571030640668524,
            "pseudo_dstar_susp": 0.0006506180871828237,
            "pseudo_tarantula_susp": 0.0005238344683080147,
            "pseudo_op2_susp": 0.0006506180871828237,
            "pseudo_barinel_susp": 0.0005238344683080147
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.__delitem__#229",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.__delitem__(self, name)",
        "snippet": "    def __delitem__(self, name):\n        norm_name = _normalized_headers[name]\n        del self._dict[norm_name]\n        del self._as_list[norm_name]",
        "begin_line": 229,
        "end_line": 232,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001349527665317139,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.__len__#234",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.__len__(self)",
        "snippet": "    def __len__(self):\n        return len(self._dict)",
        "begin_line": 234,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005254860746190226,
            "pseudo_dstar_susp": 0.000612369871402327,
            "pseudo_tarantula_susp": 0.0004992511233150275,
            "pseudo_op2_susp": 0.000612369871402327,
            "pseudo_barinel_susp": 0.0004992511233150275
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.__iter__#237",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.__iter__(self)",
        "snippet": "    def __iter__(self):\n        return iter(self._dict)",
        "begin_line": 237,
        "end_line": 238,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013189132155104195,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.copy#240",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.copy(self)",
        "snippet": "    def copy(self):\n        # defined in dict but not in MutableMapping.\n        return HTTPHeaders(self)",
        "begin_line": 240,
        "end_line": 242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil.HTTPHeaders.__str__#249",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPHeaders",
        "signature": "tornado.httputil.HTTPHeaders.__str__(self)",
        "snippet": "    def __str__(self):\n        lines = []\n        for name, value in self.get_all():\n            lines.append(\"%s: %s\\n\" % (name, value))\n        return \"\".join(lines)",
        "begin_line": 249,
        "end_line": 253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil.HTTPServerRequest.__init__#350",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPServerRequest",
        "signature": "tornado.httputil.HTTPServerRequest.__init__(self, method=None, uri=None, version='HTTP/1.0', headers=None, body=None, host=None, files=None, connection=None, start_line=None, server_connection=None)",
        "snippet": "    def __init__(self, method=None, uri=None, version=\"HTTP/1.0\", headers=None,\n                 body=None, host=None, files=None, connection=None,\n                 start_line=None, server_connection=None):\n        if start_line is not None:\n            method, uri, version = start_line\n        self.method = method\n        self.uri = uri\n        self.version = version\n        self.headers = headers or HTTPHeaders()\n        self.body = body or b\"\"\n\n        # set remote IP and protocol\n        context = getattr(connection, 'context', None)\n        self.remote_ip = getattr(context, 'remote_ip', None)\n        self.protocol = getattr(context, 'protocol', \"http\")\n\n        self.host = host or self.headers.get(\"Host\") or \"127.0.0.1\"\n        self.host_name = split_host_and_port(self.host.lower())[0]\n        self.files = files or {}\n        self.connection = connection\n        self.server_connection = server_connection\n        self._start_time = time.time()\n        self._finish_time = None\n\n        self.path, sep, self.query = uri.partition('?')\n        self.arguments = parse_qs_bytes(self.query, keep_blank_values=True)\n        self.query_arguments = copy.deepcopy(self.arguments)\n        self.body_arguments = {}",
        "begin_line": 350,
        "end_line": 377,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005257623554153522,
            "pseudo_dstar_susp": 0.0006127450980392157,
            "pseudo_tarantula_susp": 0.0004995004995004995,
            "pseudo_op2_susp": 0.0006127450980392157,
            "pseudo_barinel_susp": 0.0004995004995004995
        }
    },
    {
        "name": "tornado.httputil.HTTPServerRequest.cookies#390",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPServerRequest",
        "signature": "tornado.httputil.HTTPServerRequest.cookies(self)",
        "snippet": "    def cookies(self):\n        \"\"\"A dictionary of Cookie.Morsel objects.\"\"\"\n        if not hasattr(self, \"_cookies\"):\n            self._cookies = Cookie.SimpleCookie()\n            if \"Cookie\" in self.headers:\n                try:\n                    parsed = parse_cookie(self.headers[\"Cookie\"])\n                except Exception:\n                    pass\n                else:\n                    for k, v in parsed.items():\n                        try:\n                            self._cookies[k] = v\n                        except Exception:\n                            # SimpleCookie imposes some restrictions on keys;\n                            # parse_cookie does not. Discard any cookies\n                            # with disallowed keys.\n                            pass\n        return self._cookies",
        "begin_line": 390,
        "end_line": 408,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil.HTTPServerRequest.write#410",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPServerRequest",
        "signature": "tornado.httputil.HTTPServerRequest.write(self, chunk, callback=None)",
        "snippet": "    def write(self, chunk, callback=None):\n        \"\"\"Writes the given chunk to the response stream.\n\n        .. deprecated:: 4.0\n           Use ``request.connection`` and the `.HTTPConnection` methods\n           to write the response.\n        \"\"\"\n        assert isinstance(chunk, bytes)\n        assert self.version.startswith(\"HTTP/1.\"), \\\n            \"deprecated interface only supported in HTTP/1.x\"\n        self.connection.write(chunk, callback=callback)",
        "begin_line": 410,
        "end_line": 420,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil.HTTPServerRequest.finish#422",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPServerRequest",
        "signature": "tornado.httputil.HTTPServerRequest.finish(self)",
        "snippet": "    def finish(self):\n        \"\"\"Finishes this HTTP request on the open connection.\n\n        .. deprecated:: 4.0\n           Use ``request.connection`` and the `.HTTPConnection` methods\n           to write the response.\n        \"\"\"\n        self.connection.finish()\n        self._finish_time = time.time()",
        "begin_line": 422,
        "end_line": 430,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004065040650406504,
            "pseudo_dstar_susp": 0.0004472271914132379,
            "pseudo_tarantula_susp": 0.00040032025620496394,
            "pseudo_op2_susp": 0.0004472271914132379,
            "pseudo_barinel_susp": 0.00040032025620496394
        }
    },
    {
        "name": "tornado.httputil.HTTPServerRequest.full_url#432",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPServerRequest",
        "signature": "tornado.httputil.HTTPServerRequest.full_url(self)",
        "snippet": "    def full_url(self):\n        \"\"\"Reconstructs the full URL for this request.\"\"\"\n        return self.protocol + \"://\" + self.host + self.uri",
        "begin_line": 432,
        "end_line": 434,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil.HTTPServerRequest.request_time#436",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPServerRequest",
        "signature": "tornado.httputil.HTTPServerRequest.request_time(self)",
        "snippet": "    def request_time(self):\n        \"\"\"Returns the amount of time it took for this request to execute.\"\"\"\n        if self._finish_time is None:\n            return time.time() - self._start_time\n        else:\n            return self._finish_time - self._start_time",
        "begin_line": 436,
        "end_line": 441,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004083299305839118,
            "pseudo_dstar_susp": 0.00044943820224719103,
            "pseudo_tarantula_susp": 0.0004020908725371934,
            "pseudo_op2_susp": 0.00044943820224719103,
            "pseudo_barinel_susp": 0.0004020908725371934
        }
    },
    {
        "name": "tornado.httputil.HTTPServerRequest._parse_body#468",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPServerRequest",
        "signature": "tornado.httputil.HTTPServerRequest._parse_body(self)",
        "snippet": "    def _parse_body(self):\n        parse_body_arguments(\n            self.headers.get(\"Content-Type\", \"\"), self.body,\n            self.body_arguments, self.files,\n            self.headers)\n\n        for k, v in self.body_arguments.items():\n            self.arguments.setdefault(k, []).extend(v)",
        "begin_line": 468,
        "end_line": 475,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003916960438699569,
            "pseudo_dstar_susp": 0.0004219409282700422,
            "pseudo_tarantula_susp": 0.00038895371450797355,
            "pseudo_op2_susp": 0.0004219409282700422,
            "pseudo_barinel_susp": 0.00038895371450797355
        }
    },
    {
        "name": "tornado.httputil.HTTPServerRequest.__repr__#477",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPServerRequest",
        "signature": "tornado.httputil.HTTPServerRequest.__repr__(self)",
        "snippet": "    def __repr__(self):\n        attrs = (\"protocol\", \"host\", \"method\", \"uri\", \"version\", \"remote_ip\")\n        args = \", \".join([\"%s=%r\" % (n, getattr(self, n)) for n in attrs])\n        return \"%s(%s)\" % (self.__class__.__name__, args)",
        "begin_line": 477,
        "end_line": 480,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001623640201331385,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil.HTTPMessageDelegate.headers_received#531",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil.HTTPMessageDelegate",
        "signature": "tornado.httputil.HTTPMessageDelegate.headers_received(self, start_line, headers)",
        "snippet": "    def headers_received(self, start_line, headers):\n        \"\"\"Called when the HTTP headers have been received and parsed.\n\n        :arg start_line: a `.RequestStartLine` or `.ResponseStartLine`\n            depending on whether this is a client or server message.\n        :arg headers: a `.HTTPHeaders` instance.\n\n        Some `.HTTPConnection` methods can only be called during\n        ``headers_received``.\n\n        May return a `.Future`; if it does the body will not be read\n        until it is done.\n        \"\"\"\n        pass",
        "begin_line": 531,
        "end_line": 544,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil.url_concat#601",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.url_concat(url, args)",
        "snippet": "def url_concat(url, args):\n    \"\"\"Concatenate url and arguments regardless of whether\n    url has existing query parameters.\n\n    ``args`` may be either a dictionary or a list of key-value pairs\n    (the latter allows for multiple values with the same key.\n\n    >>> url_concat(\"http://example.com/foo\", dict(c=\"d\"))\n    'http://example.com/foo?c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", dict(c=\"d\"))\n    'http://example.com/foo?a=b&c=d'\n    >>> url_concat(\"http://example.com/foo?a=b\", [(\"c\", \"d\"), (\"c\", \"d2\")])\n    'http://example.com/foo?a=b&c=d&c=d2'\n    \"\"\"\n    if args is None:\n        return url\n    parsed_url = urlparse(url)\n    if isinstance(args, dict):\n        parsed_query = parse_qsl(parsed_url.query, keep_blank_values=True)\n        parsed_query.extend(args.items())\n    elif isinstance(args, list) or isinstance(args, tuple):\n        parsed_query = parse_qsl(parsed_url.query, keep_blank_values=True)\n        parsed_query.extend(args)\n    else:\n        err = \"'args' parameter should be dict, list or tuple. Not {0}\".format(\n            type(args))\n        raise TypeError(err)\n    final_query = urlencode(parsed_query)\n    url = urlunparse((\n        parsed_url[0],\n        parsed_url[1],\n        parsed_url[2],\n        parsed_url[3],\n        final_query,\n        parsed_url[5]))\n    return url",
        "begin_line": 601,
        "end_line": 636,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil._parse_request_range#652",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil._parse_request_range(range_header)",
        "snippet": "def _parse_request_range(range_header):\n    \"\"\"Parses a Range header.\n\n    Returns either ``None`` or tuple ``(start, end)``.\n    Note that while the HTTP headers use inclusive byte positions,\n    this method returns indexes suitable for use in slices.\n\n    >>> start, end = _parse_request_range(\"bytes=1-2\")\n    >>> start, end\n    (1, 3)\n    >>> [0, 1, 2, 3, 4][start:end]\n    [1, 2]\n    >>> _parse_request_range(\"bytes=6-\")\n    (6, None)\n    >>> _parse_request_range(\"bytes=-6\")\n    (-6, None)\n    >>> _parse_request_range(\"bytes=-0\")\n    (None, 0)\n    >>> _parse_request_range(\"bytes=\")\n    (None, None)\n    >>> _parse_request_range(\"foo=42\")\n    >>> _parse_request_range(\"bytes=1-2,6-10\")\n\n    Note: only supports one range (ex, ``bytes=1-2,6-10`` is not allowed).\n\n    See [0] for the details of the range header.\n\n    [0]: http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges\n    \"\"\"\n    unit, _, value = range_header.partition(\"=\")\n    unit, value = unit.strip(), value.strip()\n    if unit != \"bytes\":\n        return None\n    start_b, _, end_b = value.partition(\"-\")\n    try:\n        start = _int_or_none(start_b)\n        end = _int_or_none(end_b)\n    except ValueError:\n        return None\n    if end is not None:\n        if start is None:\n            if end != 0:\n                start = -end\n                end = None\n        else:\n            end += 1\n    return (start, end)",
        "begin_line": 652,
        "end_line": 698,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil._get_content_range#701",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil._get_content_range(start, end, total)",
        "snippet": "def _get_content_range(start, end, total):\n    \"\"\"Returns a suitable Content-Range header:\n\n    >>> print(_get_content_range(None, 1, 4))\n    bytes 0-0/4\n    >>> print(_get_content_range(1, 3, 4))\n    bytes 1-2/4\n    >>> print(_get_content_range(None, None, 4))\n    bytes 0-3/4\n    \"\"\"\n    start = start or 0\n    end = (end or total) - 1\n    return \"bytes %s-%s/%s\" % (start, end, total)",
        "begin_line": 701,
        "end_line": 713,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017123287671232877,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil._int_or_none#716",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil._int_or_none(val)",
        "snippet": "def _int_or_none(val):\n    val = val.strip()\n    if val == \"\":\n        return None\n    return int(val)",
        "begin_line": 716,
        "end_line": 720,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017123287671232877,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil.parse_body_arguments#723",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.parse_body_arguments(content_type, body, arguments, files, headers=None)",
        "snippet": "def parse_body_arguments(content_type, body, arguments, files, headers=None):\n    \"\"\"Parses a form request body.\n\n    Supports ``application/x-www-form-urlencoded`` and\n    ``multipart/form-data``.  The ``content_type`` parameter should be\n    a string and ``body`` should be a byte string.  The ``arguments``\n    and ``files`` parameters are dictionaries that will be updated\n    with the parsed contents.\n    \"\"\"\n    if headers and 'Content-Encoding' in headers:\n        gen_log.warning(\"Unsupported Content-Encoding: %s\",\n                        headers['Content-Encoding'])\n        return\n    if content_type.startswith(\"application/x-www-form-urlencoded\"):\n        try:\n            uri_arguments = parse_qs_bytes(native_str(body), keep_blank_values=True)\n        except Exception as e:\n            gen_log.warning('Invalid x-www-form-urlencoded body: %s', e)\n            uri_arguments = {}\n        for name, values in uri_arguments.items():\n            if values:\n                arguments.setdefault(name, []).extend(values)\n    elif content_type.startswith(\"multipart/form-data\"):\n        try:\n            fields = content_type.split(\";\")\n            for field in fields:\n                k, sep, v = field.strip().partition(\"=\")\n                if k == \"boundary\" and v:\n                    parse_multipart_form_data(utf8(v), body, arguments, files)\n                    break\n            else:\n                raise ValueError(\"multipart boundary not found\")\n        except Exception as e:\n            gen_log.warning(\"Invalid multipart/form-data: %s\", e)",
        "begin_line": 723,
        "end_line": 756,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003933910306845004,
            "pseudo_dstar_susp": 0.0004233700254022015,
            "pseudo_tarantula_susp": 0.0003901677721420211,
            "pseudo_op2_susp": 0.0004233700254022015,
            "pseudo_barinel_susp": 0.0003901677721420211
        }
    },
    {
        "name": "tornado.httputil.parse_multipart_form_data#759",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.parse_multipart_form_data(boundary, data, arguments, files)",
        "snippet": "def parse_multipart_form_data(boundary, data, arguments, files):\n    \"\"\"Parses a ``multipart/form-data`` body.\n\n    The ``boundary`` and ``data`` parameters are both byte strings.\n    The dictionaries given in the arguments and files parameters\n    will be updated with the contents of the body.\n    \"\"\"\n    # The standard allows for the boundary to be quoted in the header,\n    # although it's rare (it happens at least for google app engine\n    # xmpp).  I think we're also supposed to handle backslash-escapes\n    # here but I'll save that until we see a client that uses them\n    # in the wild.\n    if boundary.startswith(b'\"') and boundary.endswith(b'\"'):\n        boundary = boundary[1:-1]\n    final_boundary_index = data.rfind(b\"--\" + boundary + b\"--\")\n    if final_boundary_index == -1:\n        gen_log.warning(\"Invalid multipart/form-data: no final boundary\")\n        return\n    parts = data[:final_boundary_index].split(b\"--\" + boundary + b\"\\r\\n\")\n    for part in parts:\n        if not part:\n            continue\n        eoh = part.find(b\"\\r\\n\\r\\n\")\n        if eoh == -1:\n            gen_log.warning(\"multipart/form-data missing headers\")\n            continue\n        headers = HTTPHeaders.parse(part[:eoh].decode(\"utf-8\"))\n        disp_header = headers.get(\"Content-Disposition\", \"\")\n        disposition, disp_params = _parse_header(disp_header)\n        if disposition != \"form-data\" or not part.endswith(b\"\\r\\n\"):\n            gen_log.warning(\"Invalid multipart/form-data\")\n            continue\n        value = part[eoh + 4:-2]\n        if not disp_params.get(\"name\"):\n            gen_log.warning(\"multipart/form-data value missing name\")\n            continue\n        name = disp_params[\"name\"]\n        if disp_params.get(\"filename\"):\n            ctype = headers.get(\"Content-Type\", \"application/unknown\")\n            files.setdefault(name, []).append(HTTPFile(  # type: ignore\n                filename=disp_params[\"filename\"], body=value,\n                content_type=ctype))\n        else:\n            arguments.setdefault(name, []).append(value)",
        "begin_line": 759,
        "end_line": 802,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil.format_timestamp#805",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.format_timestamp(ts)",
        "snippet": "def format_timestamp(ts):\n    \"\"\"Formats a timestamp in the format used by HTTP.\n\n    The argument may be a numeric timestamp as returned by `time.time`,\n    a time tuple as returned by `time.gmtime`, or a `datetime.datetime`\n    object.\n\n    >>> format_timestamp(1359312200)\n    'Sun, 27 Jan 2013 18:43:20 GMT'\n    \"\"\"\n    if isinstance(ts, numbers.Real):\n        pass\n    elif isinstance(ts, (tuple, time.struct_time)):\n        ts = calendar.timegm(ts)\n    elif isinstance(ts, datetime.datetime):\n        ts = calendar.timegm(ts.utctimetuple())\n    else:\n        raise TypeError(\"unknown timestamp type: %r\" % ts)\n    return email.utils.formatdate(ts, usegmt=True)",
        "begin_line": 805,
        "end_line": 823,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000441306266548985,
            "pseudo_dstar_susp": 0.000508646998982706,
            "pseudo_tarantula_susp": 0.0004306632213608958,
            "pseudo_op2_susp": 0.000508646998982706,
            "pseudo_barinel_susp": 0.0004306632213608958
        }
    },
    {
        "name": "tornado.httputil.parse_request_start_line#830",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.parse_request_start_line(line)",
        "snippet": "def parse_request_start_line(line):\n    \"\"\"Returns a (method, path, version) tuple for an HTTP 1.x request line.\n\n    The response is a `collections.namedtuple`.\n\n    >>> parse_request_start_line(\"GET /foo HTTP/1.1\")\n    RequestStartLine(method='GET', path='/foo', version='HTTP/1.1')\n    \"\"\"\n    try:\n        method, path, version = line.split(\" \")\n    except ValueError:\n        # https://tools.ietf.org/html/rfc7230#section-3.1.1\n        # invalid request-line SHOULD respond with a 400 (Bad Request)\n        raise HTTPInputError(\"Malformed HTTP request line\")\n    if not re.match(r\"^HTTP/1\\.[0-9]$\", version):\n        raise HTTPInputError(\n            \"Malformed HTTP version in HTTP Request-Line: %r\" % version)\n    return RequestStartLine(method, path, version)",
        "begin_line": 830,
        "end_line": 847,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008841732979664014,
            "pseudo_dstar_susp": 0.0006578947368421052,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.0006578947368421052,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.httputil.parse_response_start_line#854",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.parse_response_start_line(line)",
        "snippet": "def parse_response_start_line(line):\n    \"\"\"Returns a (version, code, reason) tuple for an HTTP 1.x response line.\n\n    The response is a `collections.namedtuple`.\n\n    >>> parse_response_start_line(\"HTTP/1.1 200 OK\")\n    ResponseStartLine(version='HTTP/1.1', code=200, reason='OK')\n    \"\"\"\n    line = native_str(line)\n    match = re.match(\"(HTTP/1.[0-9]) ([0-9]+) ([^\\r]*)\", line)\n    if not match:\n        raise HTTPInputError(\"Error parsing response start line\")\n    return ResponseStartLine(match.group(1), int(match.group(2)),\n                             match.group(3))",
        "begin_line": 854,
        "end_line": 867,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004868549172346641,
            "pseudo_dstar_susp": 0.0005678591709256105,
            "pseudo_tarantula_susp": 0.00047460844803037496,
            "pseudo_op2_susp": 0.0005678591709256105,
            "pseudo_barinel_susp": 0.00047460844803037496
        }
    },
    {
        "name": "tornado.httputil._parseparam#876",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil._parseparam(s)",
        "snippet": "def _parseparam(s):\n    while s[:1] == ';':\n        s = s[1:]\n        end = s.find(';')\n        while end > 0 and (s.count('\"', 0, end) - s.count('\\\\\"', 0, end)) % 2:\n            end = s.find(';', end + 1)\n        if end < 0:\n            end = len(s)\n        f = s[:end]\n        yield f.strip()\n        s = s[end:]",
        "begin_line": 876,
        "end_line": 886,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil._parse_header#889",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil._parse_header(line)",
        "snippet": "def _parse_header(line):\n    \"\"\"Parse a Content-type like header.\n\n    Return the main content-type and a dictionary of options.\n\n    \"\"\"\n    parts = _parseparam(';' + line)\n    key = next(parts)\n    pdict = {}\n    for p in parts:\n        i = p.find('=')\n        if i >= 0:\n            name = p[:i].strip().lower()\n            value = p[i + 1:].strip()\n            if len(value) >= 2 and value[0] == value[-1] == '\"':\n                value = value[1:-1]\n                value = value.replace('\\\\\\\\', '\\\\').replace('\\\\\"', '\"')\n            pdict[name] = value\n        else:\n            pdict[p] = None\n    return key, pdict",
        "begin_line": 889,
        "end_line": 909,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil._encode_header#912",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil._encode_header(key, pdict)",
        "snippet": "def _encode_header(key, pdict):\n    \"\"\"Inverse of _parse_header.\n\n    >>> _encode_header('permessage-deflate',\n    ...     {'client_max_window_bits': 15, 'client_no_context_takeover': None})\n    'permessage-deflate; client_max_window_bits=15; client_no_context_takeover'\n    \"\"\"\n    if not pdict:\n        return key\n    out = [key]\n    # Sort the parameters just to make it easy to test.\n    for k, v in sorted(pdict.items()):\n        if v is None:\n            out.append(k)\n        else:\n            # TODO: quote if necessary.\n            out.append('%s=%s' % (k, v))\n    return '; '.join(out)",
        "begin_line": 912,
        "end_line": 929,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil.split_host_and_port#937",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.split_host_and_port(netloc)",
        "snippet": "def split_host_and_port(netloc):\n    \"\"\"Returns ``(host, port)`` tuple from ``netloc``.\n\n    Returned ``port`` will be ``None`` if not present.\n\n    .. versionadded:: 4.1\n    \"\"\"\n    match = re.match(r'^(.+):(\\d+)$', netloc)\n    if match:\n        host = match.group(1)\n        port = int(match.group(2))\n    else:\n        host = netloc\n        port = None\n    return (host, port)",
        "begin_line": 937,
        "end_line": 951,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011668611435239206,
            "pseudo_dstar_susp": 0.0012376237623762376,
            "pseudo_tarantula_susp": 0.0008920606601248885,
            "pseudo_op2_susp": 0.0012376237623762376,
            "pseudo_barinel_susp": 0.0008920606601248885
        }
    },
    {
        "name": "tornado.httputil.qs_to_qsl#954",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.qs_to_qsl(qs)",
        "snippet": "def qs_to_qsl(qs):\n    \"\"\"Generator converting a result of ``parse_qs`` back to name-value pairs.\n\n    .. versionadded:: 5.0\n    \"\"\"\n    for k, vs in qs.items():\n        for v in vs:\n            yield (k, v)",
        "begin_line": 954,
        "end_line": 961,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil._unquote_cookie#969",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil._unquote_cookie(str)",
        "snippet": "def _unquote_cookie(str):\n    \"\"\"Handle double quotes and escaping in cookie values.\n\n    This method is copied verbatim from the Python 3.5 standard\n    library (http.cookies._unquote) so we don't have to depend on\n    non-public interfaces.\n    \"\"\"\n    # If there aren't any doublequotes,\n    # then there can't be any special characters.  See RFC 2109.\n    if str is None or len(str) < 2:\n        return str\n    if str[0] != '\"' or str[-1] != '\"':\n        return str\n\n    # We have to assume that we must decode this string.\n    # Down to work.\n\n    # Remove the \"s\n    str = str[1:-1]\n\n    # Check for special sequences.  Examples:\n    #    \\012 --> \\n\n    #    \\\"   --> \"\n    #\n    i = 0\n    n = len(str)\n    res = []\n    while 0 <= i < n:\n        o_match = _OctalPatt.search(str, i)\n        q_match = _QuotePatt.search(str, i)\n        if not o_match and not q_match:              # Neither matched\n            res.append(str[i:])\n            break\n        # else:\n        j = k = -1\n        if o_match:\n            j = o_match.start(0)\n        if q_match:\n            k = q_match.start(0)\n        if q_match and (not o_match or k < j):     # QuotePatt matched\n            res.append(str[i:k])\n            res.append(str[k + 1])\n            i = k + 2\n        else:                                      # OctalPatt matched\n            res.append(str[i:j])\n            res.append(chr(int(str[j + 1:j + 4], 8)))\n            i = j + 4\n    return _nulljoin(res)",
        "begin_line": 969,
        "end_line": 1016,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.httputil.parse_cookie#1019",
        "src_path": "tornado/httputil.py",
        "class_name": "tornado.httputil",
        "signature": "tornado.httputil.parse_cookie(cookie)",
        "snippet": "def parse_cookie(cookie):\n    \"\"\"Parse a ``Cookie`` HTTP header into a dict of name/value pairs.\n\n    This function attempts to mimic browser cookie parsing behavior;\n    it specifically does not follow any of the cookie-related RFCs\n    (because browsers don't either).\n\n    The algorithm used is identical to that used by Django version 1.9.10.\n\n    .. versionadded:: 4.4.2\n    \"\"\"\n    cookiedict = {}\n    for chunk in cookie.split(str(';')):\n        if str('=') in chunk:\n            key, val = chunk.split(str('='), 1)\n        else:\n            # Assume an empty name per\n            # https://bugzilla.mozilla.org/show_bug.cgi?id=169091\n            key, val = str(''), chunk\n        key, val = key.strip(), val.strip()\n        if key or val:\n            # unquote using Python's algorithm.\n            cookiedict[key] = _unquote_cookie(val)\n    return cookiedict",
        "begin_line": 1019,
        "end_line": 1042,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen._value_from_stopiteration#171",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen._value_from_stopiteration(e)",
        "snippet": "def _value_from_stopiteration(e):\n    try:\n        # StopIteration has a value attribute beginning in py33.\n        # So does our Return class.\n        return e.value\n    except AttributeError:\n        pass\n    try:\n        # Cython backports coroutine functionality by putting the value in\n        # e.args[0].\n        return e.args[0]\n    except (AttributeError, IndexError):\n        return None",
        "begin_line": 171,
        "end_line": 183,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012239902080783353,
            "pseudo_dstar_susp": 0.0014925373134328358,
            "pseudo_tarantula_susp": 0.0007326007326007326,
            "pseudo_op2_susp": 0.0014925373134328358,
            "pseudo_barinel_susp": 0.0007326007326007326
        }
    },
    {
        "name": "tornado.gen._create_future#186",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen._create_future()",
        "snippet": "def _create_future():\n    future = Future()\n    # Fixup asyncio debug info by removing extraneous stack entries\n    source_traceback = getattr(future, \"_source_traceback\", ())\n    while source_traceback:\n        # Each traceback entry is equivalent to a\n        # (filename, self.lineno, self.name, self.line) tuple\n        filename = source_traceback[-1][0]\n        if filename == __file__:\n            del source_traceback[-1]\n        else:\n            break\n    return future",
        "begin_line": 186,
        "end_line": 198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013297872340425532,
            "pseudo_dstar_susp": 0.0021551724137931034,
            "pseudo_tarantula_susp": 0.0007905138339920949,
            "pseudo_op2_susp": 0.0021551724137931034,
            "pseudo_barinel_susp": 0.0007905138339920949
        }
    },
    {
        "name": "tornado.gen.engine#201",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.engine(func)",
        "snippet": "def engine(func):\n    \"\"\"Callback-oriented decorator for asynchronous generators.\n\n    This is an older interface; for new code that does not need to be\n    compatible with versions of Tornado older than 3.0 the\n    `coroutine` decorator is recommended instead.\n\n    This decorator is similar to `coroutine`, except it does not\n    return a `.Future` and the ``callback`` argument is not treated\n    specially.\n\n    In most cases, functions decorated with `engine` should take\n    a ``callback`` argument and invoke it with their result when\n    they are finished.  One notable exception is the\n    `~tornado.web.RequestHandler` :ref:`HTTP verb methods <verbs>`,\n    which use ``self.finish()`` in place of a callback argument.\n\n    .. deprecated:: 5.1\n\n       This decorator will be removed in 6.0. Use `coroutine` or\n       ``async def`` instead.\n    \"\"\"\n    warnings.warn(\"gen.engine is deprecated, use gen.coroutine or async def instead\",\n                  DeprecationWarning)\n    func = _make_coroutine_wrapper(func, replace_callback=False)\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        future = func(*args, **kwargs)\n\n        def final_callback(future):\n            if future.result() is not None:\n                raise ReturnValueIgnoredError(\n                    \"@gen.engine functions cannot return values: %r\" %\n                    (future.result(),))\n        # The engine interface doesn't give us any way to return\n        # errors but to raise them into the stack context.\n        # Save the stack context here to use when the Future has resolved.\n        future_add_done_callback(future, stack_context.wrap(final_callback))\n    return wrapper",
        "begin_line": 201,
        "end_line": 240,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001456876456876457,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.wrapper#228",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.wrapper(*args, **kwargs)",
        "snippet": "    def wrapper(*args, **kwargs):\n        future = func(*args, **kwargs)\n\n        def final_callback(future):\n            if future.result() is not None:\n                raise ReturnValueIgnoredError(\n                    \"@gen.engine functions cannot return values: %r\" %\n                    (future.result(),))\n        # The engine interface doesn't give us any way to return\n        # errors but to raise them into the stack context.\n        # Save the stack context here to use when the Future has resolved.\n        future_add_done_callback(future, stack_context.wrap(final_callback))",
        "begin_line": 228,
        "end_line": 239,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002053388090349076,
            "pseudo_dstar_susp": 0.0031645569620253164,
            "pseudo_tarantula_susp": 0.001182033096926714,
            "pseudo_op2_susp": 0.0031645569620253164,
            "pseudo_barinel_susp": 0.001182033096926714
        }
    },
    {
        "name": "tornado.gen.final_callback#231",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.final_callback(future)",
        "snippet": "        def final_callback(future):\n            if future.result() is not None:\n                raise ReturnValueIgnoredError(\n                    \"@gen.engine functions cannot return values: %r\" %\n                    (future.result(),))",
        "begin_line": 231,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.coroutine#243",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.coroutine(func)",
        "snippet": "def coroutine(func):\n    \"\"\"Decorator for asynchronous generators.\n\n    Any generator that yields objects from this module must be wrapped\n    in either this decorator or `engine`.\n\n    Coroutines may \"return\" by raising the special exception\n    `Return(value) <Return>`.  In Python 3.3+, it is also possible for\n    the function to simply use the ``return value`` statement (prior to\n    Python 3.3 generators were not allowed to also return values).\n    In all versions of Python a coroutine that simply wishes to exit\n    early may use the ``return`` statement without a value.\n\n    Functions with this decorator return a `.Future`.  Additionally,\n    they may be called with a ``callback`` keyword argument, which\n    will be invoked with the future's result when it resolves.  If the\n    coroutine fails, the callback will not be run and an exception\n    will be raised into the surrounding `.StackContext`.  The\n    ``callback`` argument is not visible inside the decorated\n    function; it is handled by the decorator itself.\n\n    .. warning::\n\n       When exceptions occur inside a coroutine, the exception\n       information will be stored in the `.Future` object. You must\n       examine the result of the `.Future` object, or the exception\n       may go unnoticed by your code. This means yielding the function\n       if called from another coroutine, using something like\n       `.IOLoop.run_sync` for top-level calls, or passing the `.Future`\n       to `.IOLoop.add_future`.\n\n    .. deprecated:: 5.1\n\n       The ``callback`` argument is deprecated and will be removed in 6.0.\n       Use the returned awaitable object instead.\n    \"\"\"\n    return _make_coroutine_wrapper(func, replace_callback=True)",
        "begin_line": 243,
        "end_line": 279,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003894080996884735,
            "pseudo_dstar_susp": 0.00038714672861014324,
            "pseudo_tarantula_susp": 0.0004185851820845542,
            "pseudo_op2_susp": 0.00038714672861014324,
            "pseudo_barinel_susp": 0.0004185851820845542
        }
    },
    {
        "name": "tornado.gen._make_coroutine_wrapper#282",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen._make_coroutine_wrapper(func, replace_callback)",
        "snippet": "def _make_coroutine_wrapper(func, replace_callback):\n    \"\"\"The inner workings of ``@gen.coroutine`` and ``@gen.engine``.\n\n    The two decorators differ in their treatment of the ``callback``\n    argument, so we cannot simply implement ``@engine`` in terms of\n    ``@coroutine``.\n    \"\"\"\n    # On Python 3.5, set the coroutine flag on our generator, to allow it\n    # to be used with 'await'.\n    wrapped = func\n    if hasattr(types, 'coroutine'):\n        func = types.coroutine(func)\n\n    @functools.wraps(wrapped)\n    def wrapper(*args, **kwargs):\n        future = _create_future()\n\n        if replace_callback and 'callback' in kwargs:\n            warnings.warn(\"callback arguments are deprecated, use the returned Future instead\",\n                          DeprecationWarning, stacklevel=2)\n            callback = kwargs.pop('callback')\n            IOLoop.current().add_future(\n                future, lambda future: callback(future.result()))\n\n        try:\n            result = func(*args, **kwargs)\n        except (Return, StopIteration) as e:\n            result = _value_from_stopiteration(e)\n        except Exception:\n            future_set_exc_info(future, sys.exc_info())\n            try:\n                return future\n            finally:\n                # Avoid circular references\n                future = None\n        else:\n            if isinstance(result, GeneratorType):\n                # Inline the first iteration of Runner.run.  This lets us\n                # avoid the cost of creating a Runner when the coroutine\n                # never actually yields, which in turn allows us to\n                # use \"optional\" coroutines in critical path code without\n                # performance penalty for the synchronous case.\n                try:\n                    orig_stack_contexts = stack_context._state.contexts\n                    yielded = next(result)\n                    if stack_context._state.contexts is not orig_stack_contexts:\n                        yielded = _create_future()\n                        yielded.set_exception(\n                            stack_context.StackContextInconsistentError(\n                                'stack_context inconsistency (probably caused '\n                                'by yield within a \"with StackContext\" block)'))\n                except (StopIteration, Return) as e:\n                    future_set_result_unless_cancelled(future, _value_from_stopiteration(e))\n                except Exception:\n                    future_set_exc_info(future, sys.exc_info())\n                else:\n                    # Provide strong references to Runner objects as long\n                    # as their result future objects also have strong\n                    # references (typically from the parent coroutine's\n                    # Runner). This keeps the coroutine's Runner alive.\n                    # We do this by exploiting the public API\n                    # add_done_callback() instead of putting a private\n                    # attribute on the Future.\n                    # (Github issues #1769, #2229).\n                    runner = Runner(result, future, yielded)\n                    future.add_done_callback(lambda _: runner)\n                yielded = None\n                try:\n                    return future\n                finally:\n                    # Subtle memory optimization: if next() raised an exception,\n                    # the future's exc_info contains a traceback which\n                    # includes this stack frame.  This creates a cycle,\n                    # which will be collected at the next full GC but has\n                    # been shown to greatly increase memory usage of\n                    # benchmarks (relative to the refcount-based scheme\n                    # used in the absence of cycles).  We can avoid the\n                    # cycle by clearing the local variable after we return it.\n                    future = None\n        future_set_result_unless_cancelled(future, result)\n        return future\n\n    wrapper.__wrapped__ = wrapped\n    wrapper.__tornado_coroutine__ = True\n    return wrapper",
        "begin_line": 282,
        "end_line": 366,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012787723785166241,
            "pseudo_dstar_susp": 0.002364066193853428,
            "pseudo_tarantula_susp": 0.0007194244604316547,
            "pseudo_op2_susp": 0.002364066193853428,
            "pseudo_barinel_susp": 0.0007194244604316547
        }
    },
    {
        "name": "tornado.gen.wrapper#296",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.wrapper(*args, **kwargs)",
        "snippet": "    def wrapper(*args, **kwargs):\n        future = _create_future()\n\n        if replace_callback and 'callback' in kwargs:\n            warnings.warn(\"callback arguments are deprecated, use the returned Future instead\",\n                          DeprecationWarning, stacklevel=2)\n            callback = kwargs.pop('callback')\n            IOLoop.current().add_future(\n                future, lambda future: callback(future.result()))\n\n        try:\n            result = func(*args, **kwargs)\n        except (Return, StopIteration) as e:\n            result = _value_from_stopiteration(e)\n        except Exception:\n            future_set_exc_info(future, sys.exc_info())\n            try:\n                return future\n            finally:\n                # Avoid circular references\n                future = None\n        else:\n            if isinstance(result, GeneratorType):\n                # Inline the first iteration of Runner.run.  This lets us\n                # avoid the cost of creating a Runner when the coroutine\n                # never actually yields, which in turn allows us to\n                # use \"optional\" coroutines in critical path code without\n                # performance penalty for the synchronous case.\n                try:\n                    orig_stack_contexts = stack_context._state.contexts\n                    yielded = next(result)\n                    if stack_context._state.contexts is not orig_stack_contexts:\n                        yielded = _create_future()\n                        yielded.set_exception(\n                            stack_context.StackContextInconsistentError(\n                                'stack_context inconsistency (probably caused '\n                                'by yield within a \"with StackContext\" block)'))\n                except (StopIteration, Return) as e:\n                    future_set_result_unless_cancelled(future, _value_from_stopiteration(e))\n                except Exception:\n                    future_set_exc_info(future, sys.exc_info())\n                else:\n                    # Provide strong references to Runner objects as long\n                    # as their result future objects also have strong\n                    # references (typically from the parent coroutine's\n                    # Runner). This keeps the coroutine's Runner alive.\n                    # We do this by exploiting the public API\n                    # add_done_callback() instead of putting a private\n                    # attribute on the Future.\n                    # (Github issues #1769, #2229).\n                    runner = Runner(result, future, yielded)\n                    future.add_done_callback(lambda _: runner)\n                yielded = None\n                try:\n                    return future\n                finally:\n                    # Subtle memory optimization: if next() raised an exception,\n                    # the future's exc_info contains a traceback which\n                    # includes this stack frame.  This creates a cycle,\n                    # which will be collected at the next full GC but has\n                    # been shown to greatly increase memory usage of\n                    # benchmarks (relative to the refcount-based scheme\n                    # used in the absence of cycles).  We can avoid the\n                    # cycle by clearing the local variable after we return it.\n                    future = None\n        future_set_result_unless_cancelled(future, result)\n        return future",
        "begin_line": 296,
        "end_line": 362,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002053388090349076,
            "pseudo_dstar_susp": 0.0031645569620253164,
            "pseudo_tarantula_susp": 0.001182033096926714,
            "pseudo_op2_susp": 0.0031645569620253164,
            "pseudo_barinel_susp": 0.001182033096926714
        }
    },
    {
        "name": "tornado.gen.is_coroutine_function#369",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.is_coroutine_function(func)",
        "snippet": "def is_coroutine_function(func):\n    \"\"\"Return whether *func* is a coroutine function, i.e. a function\n    wrapped with `~.gen.coroutine`.\n\n    .. versionadded:: 4.5\n    \"\"\"\n    return getattr(func, '__tornado_coroutine__', False)",
        "begin_line": 369,
        "end_line": 375,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.Return.__init__#398",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Return",
        "signature": "tornado.gen.Return.__init__(self, value=None)",
        "snippet": "    def __init__(self, value=None):\n        super(Return, self).__init__()\n        self.value = value\n        # Cython recognizes subclasses of StopIteration with a .args tuple.\n        self.args = (value,)",
        "begin_line": 398,
        "end_line": 402,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012300123001230013,
            "pseudo_dstar_susp": 0.001314060446780552,
            "pseudo_tarantula_susp": 0.0009532888465204957,
            "pseudo_op2_susp": 0.001314060446780552,
            "pseudo_barinel_susp": 0.0009532888465204957
        }
    },
    {
        "name": "tornado.gen.WaitIterator.__init__#458",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.WaitIterator",
        "signature": "tornado.gen.WaitIterator.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        if args and kwargs:\n            raise ValueError(\n                \"You must provide args or kwargs, not both\")\n\n        if kwargs:\n            self._unfinished = dict((f, k) for (k, f) in kwargs.items())\n            futures = list(kwargs.values())\n        else:\n            self._unfinished = dict((f, i) for (i, f) in enumerate(args))\n            futures = args\n\n        self._finished = collections.deque()\n        self.current_index = self.current_future = None\n        self._running_future = None\n\n        for future in futures:\n            future_add_done_callback(future, self._done_callback)",
        "begin_line": 458,
        "end_line": 475,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.WaitIterator.done#477",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.WaitIterator",
        "signature": "tornado.gen.WaitIterator.done(self)",
        "snippet": "    def done(self):\n        \"\"\"Returns True if this iterator has no more results.\"\"\"\n        if self._finished or self._unfinished:\n            return False\n        # Clear the 'current' values when iteration is done.\n        self.current_index = self.current_future = None\n        return True",
        "begin_line": 477,
        "end_line": 483,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.WaitIterator.next#485",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.WaitIterator",
        "signature": "tornado.gen.WaitIterator.next(self)",
        "snippet": "    def next(self):\n        \"\"\"Returns a `.Future` that will yield the next available result.\n\n        Note that this `.Future` will not be the same object as any of\n        the inputs.\n        \"\"\"\n        self._running_future = Future()\n\n        if self._finished:\n            self._return_result(self._finished.popleft())\n\n        return self._running_future",
        "begin_line": 485,
        "end_line": 496,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.WaitIterator._done_callback#498",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.WaitIterator",
        "signature": "tornado.gen.WaitIterator._done_callback(self, done)",
        "snippet": "    def _done_callback(self, done):\n        if self._running_future and not self._running_future.done():\n            self._return_result(done)\n        else:\n            self._finished.append(done)",
        "begin_line": 498,
        "end_line": 502,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.WaitIterator._return_result#504",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.WaitIterator",
        "signature": "tornado.gen.WaitIterator._return_result(self, done)",
        "snippet": "    def _return_result(self, done):\n        \"\"\"Called set the returned future's state that of the future\n        we yielded, and set the current future for the iterator.\n        \"\"\"\n        chain_future(done, self._running_future)\n\n        self.current_future = done\n        self.current_index = self._unfinished.pop(done)",
        "begin_line": 504,
        "end_line": 511,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.WaitIterator.__aiter__#513",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.WaitIterator",
        "signature": "tornado.gen.WaitIterator.__aiter__(self)",
        "snippet": "    def __aiter__(self):\n        return self",
        "begin_line": 513,
        "end_line": 514,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.WaitIterator.__anext__#516",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.WaitIterator",
        "signature": "tornado.gen.WaitIterator.__anext__(self)",
        "snippet": "    def __anext__(self):\n        if self.done():\n            # Lookup by name to silence pyflakes on older versions.\n            raise getattr(builtins, 'StopAsyncIteration')()\n        return self.next()",
        "begin_line": 516,
        "end_line": 520,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.Callback.__init__#572",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Callback",
        "signature": "tornado.gen.Callback.__init__(self, key)",
        "snippet": "    def __init__(self, key):\n        warnings.warn(\"gen.Callback is deprecated, use Futures instead\",\n                      DeprecationWarning)\n        self.key = key",
        "begin_line": 572,
        "end_line": 575,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015248551387618176,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.Callback.start#577",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Callback",
        "signature": "tornado.gen.Callback.start(self, runner)",
        "snippet": "    def start(self, runner):\n        self.runner = runner\n        runner.register_callback(self.key)",
        "begin_line": 577,
        "end_line": 579,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015248551387618176,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.Callback.is_ready#581",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Callback",
        "signature": "tornado.gen.Callback.is_ready(self)",
        "snippet": "    def is_ready(self):\n        return True",
        "begin_line": 581,
        "end_line": 582,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015248551387618176,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.Callback.get_result#584",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Callback",
        "signature": "tornado.gen.Callback.get_result(self)",
        "snippet": "    def get_result(self):\n        return self.runner.result_callback(self.key)",
        "begin_line": 584,
        "end_line": 585,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015248551387618176,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.Wait.__init__#594",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Wait",
        "signature": "tornado.gen.Wait.__init__(self, key)",
        "snippet": "    def __init__(self, key):\n        warnings.warn(\"gen.Wait is deprecated, use Futures instead\",\n                      DeprecationWarning)\n        self.key = key",
        "begin_line": 594,
        "end_line": 597,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016095284081764043,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.Wait.start#599",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Wait",
        "signature": "tornado.gen.Wait.start(self, runner)",
        "snippet": "    def start(self, runner):\n        self.runner = runner",
        "begin_line": 599,
        "end_line": 600,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016152479405588758,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.Wait.is_ready#602",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Wait",
        "signature": "tornado.gen.Wait.is_ready(self)",
        "snippet": "    def is_ready(self):\n        return self.runner.is_ready(self.key)",
        "begin_line": 602,
        "end_line": 603,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016152479405588758,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.Wait.get_result#605",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Wait",
        "signature": "tornado.gen.Wait.get_result(self)",
        "snippet": "    def get_result(self):\n        return self.runner.pop_result(self.key)",
        "begin_line": 605,
        "end_line": 606,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016474464579901152,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.WaitAll.__init__#620",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.WaitAll",
        "signature": "tornado.gen.WaitAll.__init__(self, keys)",
        "snippet": "    def __init__(self, keys):\n        warnings.warn(\"gen.WaitAll is deprecated, use gen.multi instead\",\n                      DeprecationWarning)\n        self.keys = keys",
        "begin_line": 620,
        "end_line": 623,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.WaitAll.start#625",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.WaitAll",
        "signature": "tornado.gen.WaitAll.start(self, runner)",
        "snippet": "    def start(self, runner):\n        self.runner = runner",
        "begin_line": 625,
        "end_line": 626,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.WaitAll.is_ready#628",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.WaitAll",
        "signature": "tornado.gen.WaitAll.is_ready(self)",
        "snippet": "    def is_ready(self):\n        return all(self.runner.is_ready(key) for key in self.keys)",
        "begin_line": 628,
        "end_line": 629,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.WaitAll.get_result#631",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.WaitAll",
        "signature": "tornado.gen.WaitAll.get_result(self)",
        "snippet": "    def get_result(self):\n        return [self.runner.pop_result(key) for key in self.keys]",
        "begin_line": 631,
        "end_line": 632,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.Task#635",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.Task(func, *args, **kwargs)",
        "snippet": "def Task(func, *args, **kwargs):\n    \"\"\"Adapts a callback-based asynchronous function for use in coroutines.\n\n    Takes a function (and optional additional arguments) and runs it with\n    those arguments plus a ``callback`` keyword argument.  The argument passed\n    to the callback is returned as the result of the yield expression.\n\n    .. versionchanged:: 4.0\n       ``gen.Task`` is now a function that returns a `.Future`, instead of\n       a subclass of `YieldPoint`.  It still behaves the same way when\n       yielded.\n\n    .. deprecated:: 5.1\n       This function is deprecated and will be removed in 6.0.\n    \"\"\"\n    warnings.warn(\"gen.Task is deprecated, use Futures instead\",\n                  DeprecationWarning)\n    future = _create_future()\n\n    def handle_exception(typ, value, tb):\n        if future.done():\n            return False\n        future_set_exc_info(future, (typ, value, tb))\n        return True\n\n    def set_result(result):\n        if future.done():\n            return\n        future_set_result_unless_cancelled(future, result)\n    with stack_context.ExceptionStackContext(handle_exception):\n        func(*args, callback=_argument_adapter(set_result), **kwargs)\n    return future",
        "begin_line": 635,
        "end_line": 666,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015101177891875566,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.handle_exception#654",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.handle_exception(typ, value, tb)",
        "snippet": "    def handle_exception(typ, value, tb):\n        if future.done():\n            return False\n        future_set_exc_info(future, (typ, value, tb))\n        return True",
        "begin_line": 654,
        "end_line": 658,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.set_result#660",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.set_result(result)",
        "snippet": "    def set_result(result):\n        if future.done():\n            return\n        future_set_result_unless_cancelled(future, result)",
        "begin_line": 660,
        "end_line": 663,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016017940092904052,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.YieldFuture.__init__#670",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.YieldFuture",
        "signature": "tornado.gen.YieldFuture.__init__(self, future)",
        "snippet": "    def __init__(self, future):\n        \"\"\"Adapts a `.Future` to the `YieldPoint` interface.\n\n        .. versionchanged:: 5.0\n           The ``io_loop`` argument (deprecated since version 4.1) has been removed.\n\n        .. deprecated:: 5.1\n           This class will be removed in 6.0.\n        \"\"\"\n        warnings.warn(\"YieldFuture is deprecated, use Futures instead\",\n                      DeprecationWarning)\n        self.future = future\n        self.io_loop = IOLoop.current()",
        "begin_line": 670,
        "end_line": 682,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.YieldFuture.start#684",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.YieldFuture",
        "signature": "tornado.gen.YieldFuture.start(self, runner)",
        "snippet": "    def start(self, runner):\n        if not self.future.done():\n            self.runner = runner\n            self.key = object()\n            runner.register_callback(self.key)\n            self.io_loop.add_future(self.future, runner.result_callback(self.key))\n        else:\n            self.runner = None\n            self.result_fn = self.future.result",
        "begin_line": 684,
        "end_line": 692,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.YieldFuture.is_ready#694",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.YieldFuture",
        "signature": "tornado.gen.YieldFuture.is_ready(self)",
        "snippet": "    def is_ready(self):\n        if self.runner is not None:\n            return self.runner.is_ready(self.key)\n        else:\n            return True",
        "begin_line": 694,
        "end_line": 698,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.YieldFuture.get_result#700",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.YieldFuture",
        "signature": "tornado.gen.YieldFuture.get_result(self)",
        "snippet": "    def get_result(self):\n        if self.runner is not None:\n            return self.runner.pop_result(self.key).result()\n        else:\n            return self.result_fn()",
        "begin_line": 700,
        "end_line": 704,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen._contains_yieldpoint#707",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen._contains_yieldpoint(children)",
        "snippet": "def _contains_yieldpoint(children):\n    \"\"\"Returns True if ``children`` contains any YieldPoints.\n\n    ``children`` may be a dict or a list, as used by `MultiYieldPoint`\n    and `multi_future`.\n    \"\"\"\n    if isinstance(children, dict):\n        return any(isinstance(i, YieldPoint) for i in children.values())\n    if isinstance(children, list):\n        return any(isinstance(i, YieldPoint) for i in children)\n    return False",
        "begin_line": 707,
        "end_line": 717,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001272264631043257,
            "pseudo_dstar_susp": 0.001564945226917058,
            "pseudo_tarantula_susp": 0.0007479431563201197,
            "pseudo_op2_susp": 0.001564945226917058,
            "pseudo_barinel_susp": 0.0007479431563201197
        }
    },
    {
        "name": "tornado.gen.multi#720",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.multi(children, quiet_exceptions=())",
        "snippet": "def multi(children, quiet_exceptions=()):\n    \"\"\"Runs multiple asynchronous operations in parallel.\n\n    ``children`` may either be a list or a dict whose values are\n    yieldable objects. ``multi()`` returns a new yieldable\n    object that resolves to a parallel structure containing their\n    results. If ``children`` is a list, the result is a list of\n    results in the same order; if it is a dict, the result is a dict\n    with the same keys.\n\n    That is, ``results = yield multi(list_of_futures)`` is equivalent\n    to::\n\n        results = []\n        for future in list_of_futures:\n            results.append(yield future)\n\n    If any children raise exceptions, ``multi()`` will raise the first\n    one. All others will be logged, unless they are of types\n    contained in the ``quiet_exceptions`` argument.\n\n    If any of the inputs are `YieldPoints <YieldPoint>`, the returned\n    yieldable object is a `YieldPoint`. Otherwise, returns a `.Future`.\n    This means that the result of `multi` can be used in a native\n    coroutine if and only if all of its children can be.\n\n    In a ``yield``-based coroutine, it is not normally necessary to\n    call this function directly, since the coroutine runner will\n    do it automatically when a list or dict is yielded. However,\n    it is necessary in ``await``-based coroutines, or to pass\n    the ``quiet_exceptions`` argument.\n\n    This function is available under the names ``multi()`` and ``Multi()``\n    for historical reasons.\n\n    Cancelling a `.Future` returned by ``multi()`` does not cancel its\n    children. `asyncio.gather` is similar to ``multi()``, but it does\n    cancel its children.\n\n    .. versionchanged:: 4.2\n       If multiple yieldables fail, any exceptions after the first\n       (which is raised) will be logged. Added the ``quiet_exceptions``\n       argument to suppress this logging for selected exception types.\n\n    .. versionchanged:: 4.3\n       Replaced the class ``Multi`` and the function ``multi_future``\n       with a unified function ``multi``. Added support for yieldables\n       other than `YieldPoint` and `.Future`.\n\n    \"\"\"\n    if _contains_yieldpoint(children):\n        return MultiYieldPoint(children, quiet_exceptions=quiet_exceptions)\n    else:\n        return multi_future(children, quiet_exceptions=quiet_exceptions)",
        "begin_line": 720,
        "end_line": 773,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.MultiYieldPoint.__init__#798",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.MultiYieldPoint",
        "signature": "tornado.gen.MultiYieldPoint.__init__(self, children, quiet_exceptions=())",
        "snippet": "    def __init__(self, children, quiet_exceptions=()):\n        warnings.warn(\"MultiYieldPoint is deprecated, use Futures instead\",\n                      DeprecationWarning)\n        self.keys = None\n        if isinstance(children, dict):\n            self.keys = list(children.keys())\n            children = children.values()\n        self.children = []\n        for i in children:\n            if not isinstance(i, YieldPoint):\n                i = convert_yielded(i)\n            if is_future(i):\n                i = YieldFuture(i)\n            self.children.append(i)\n        assert all(isinstance(i, YieldPoint) for i in self.children)\n        self.unfinished_children = set(self.children)\n        self.quiet_exceptions = quiet_exceptions",
        "begin_line": 798,
        "end_line": 814,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.MultiYieldPoint.start#816",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.MultiYieldPoint",
        "signature": "tornado.gen.MultiYieldPoint.start(self, runner)",
        "snippet": "    def start(self, runner):\n        for i in self.children:\n            i.start(runner)",
        "begin_line": 816,
        "end_line": 818,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.MultiYieldPoint.is_ready#820",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.MultiYieldPoint",
        "signature": "tornado.gen.MultiYieldPoint.is_ready(self)",
        "snippet": "    def is_ready(self):\n        finished = list(itertools.takewhile(\n            lambda i: i.is_ready(), self.unfinished_children))\n        self.unfinished_children.difference_update(finished)\n        return not self.unfinished_children",
        "begin_line": 820,
        "end_line": 824,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.MultiYieldPoint.get_result#826",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.MultiYieldPoint",
        "signature": "tornado.gen.MultiYieldPoint.get_result(self)",
        "snippet": "    def get_result(self):\n        result_list = []\n        exc_info = None\n        for f in self.children:\n            try:\n                result_list.append(f.get_result())\n            except Exception as e:\n                if exc_info is None:\n                    exc_info = sys.exc_info()\n                else:\n                    if not isinstance(e, self.quiet_exceptions):\n                        app_log.error(\"Multiple exceptions in yield list\",\n                                      exc_info=True)\n        if exc_info is not None:\n            raise_exc_info(exc_info)\n        if self.keys is not None:\n            return dict(zip(self.keys, result_list))\n        else:\n            return list(result_list)",
        "begin_line": 826,
        "end_line": 844,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.multi_future#847",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.multi_future(children, quiet_exceptions=())",
        "snippet": "def multi_future(children, quiet_exceptions=()):\n    \"\"\"Wait for multiple asynchronous futures in parallel.\n\n    This function is similar to `multi`, but does not support\n    `YieldPoints <YieldPoint>`.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.2\n       If multiple ``Futures`` fail, any exceptions after the first (which is\n       raised) will be logged. Added the ``quiet_exceptions``\n       argument to suppress this logging for selected exception types.\n\n    .. deprecated:: 4.3\n       Use `multi` instead.\n    \"\"\"\n    if isinstance(children, dict):\n        keys = list(children.keys())\n        children = children.values()\n    else:\n        keys = None\n    children = list(map(convert_yielded, children))\n    assert all(is_future(i) or isinstance(i, _NullFuture) for i in children)\n    unfinished_children = set(children)\n\n    future = _create_future()\n    if not children:\n        future_set_result_unless_cancelled(future,\n                                           {} if keys is not None else [])\n\n    def callback(f):\n        unfinished_children.remove(f)\n        if not unfinished_children:\n            result_list = []\n            for f in children:\n                try:\n                    result_list.append(f.result())\n                except Exception as e:\n                    if future.done():\n                        if not isinstance(e, quiet_exceptions):\n                            app_log.error(\"Multiple exceptions in yield list\",\n                                          exc_info=True)\n                    else:\n                        future_set_exc_info(future, sys.exc_info())\n            if not future.done():\n                if keys is not None:\n                    future_set_result_unless_cancelled(future,\n                                                       dict(zip(keys, result_list)))\n                else:\n                    future_set_result_unless_cancelled(future, result_list)\n\n    listening = set()\n    for f in children:\n        if f not in listening:\n            listening.add(f)\n            future_add_done_callback(f, callback)\n    return future",
        "begin_line": 847,
        "end_line": 903,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.callback#877",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.callback(f)",
        "snippet": "    def callback(f):\n        unfinished_children.remove(f)\n        if not unfinished_children:\n            result_list = []\n            for f in children:\n                try:\n                    result_list.append(f.result())\n                except Exception as e:\n                    if future.done():\n                        if not isinstance(e, quiet_exceptions):\n                            app_log.error(\"Multiple exceptions in yield list\",\n                                          exc_info=True)\n                    else:\n                        future_set_exc_info(future, sys.exc_info())\n            if not future.done():\n                if keys is not None:\n                    future_set_result_unless_cancelled(future,\n                                                       dict(zip(keys, result_list)))\n                else:\n                    future_set_result_unless_cancelled(future, result_list)",
        "begin_line": 877,
        "end_line": 896,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.with_timeout#927",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.with_timeout(timeout, future, quiet_exceptions=())",
        "snippet": "def with_timeout(timeout, future, quiet_exceptions=()):\n    \"\"\"Wraps a `.Future` (or other yieldable object) in a timeout.\n\n    Raises `tornado.util.TimeoutError` if the input future does not\n    complete before ``timeout``, which may be specified in any form\n    allowed by `.IOLoop.add_timeout` (i.e. a `datetime.timedelta` or\n    an absolute time relative to `.IOLoop.time`)\n\n    If the wrapped `.Future` fails after it has timed out, the exception\n    will be logged unless it is of a type contained in ``quiet_exceptions``\n    (which may be an exception type or a sequence of types).\n\n    Does not support `YieldPoint` subclasses.\n\n    The wrapped `.Future` is not canceled when the timeout expires,\n    permitting it to be reused. `asyncio.wait_for` is similar to this\n    function but it does cancel the wrapped `.Future` on timeout.\n\n    .. versionadded:: 4.0\n\n    .. versionchanged:: 4.1\n       Added the ``quiet_exceptions`` argument and the logging of unhandled\n       exceptions.\n\n    .. versionchanged:: 4.4\n       Added support for yieldable objects other than `.Future`.\n\n    \"\"\"\n    # TODO: allow YieldPoints in addition to other yieldables?\n    # Tricky to do with stack_context semantics.\n    #\n    # It's tempting to optimize this by cancelling the input future on timeout\n    # instead of creating a new one, but A) we can't know if we are the only\n    # one waiting on the input future, so cancelling it might disrupt other\n    # callers and B) concurrent futures can only be cancelled while they are\n    # in the queue, so cancellation cannot reliably bound our waiting time.\n    future = convert_yielded(future)\n    result = _create_future()\n    chain_future(future, result)\n    io_loop = IOLoop.current()\n\n    def error_callback(future):\n        try:\n            future.result()\n        except Exception as e:\n            if not isinstance(e, quiet_exceptions):\n                app_log.error(\"Exception in Future %r after timeout\",\n                              future, exc_info=True)\n\n    def timeout_callback():\n        if not result.done():\n            result.set_exception(TimeoutError(\"Timeout\"))\n        # In case the wrapped future goes on to fail, log it.\n        future_add_done_callback(future, error_callback)\n    timeout_handle = io_loop.add_timeout(\n        timeout, timeout_callback)\n    if isinstance(future, Future):\n        # We know this future will resolve on the IOLoop, so we don't\n        # need the extra thread-safety of IOLoop.add_future (and we also\n        # don't care about StackContext here.\n        future_add_done_callback(\n            future, lambda future: io_loop.remove_timeout(timeout_handle))\n    else:\n        # concurrent.futures.Futures may resolve on any thread, so we\n        # need to route them back to the IOLoop.\n        io_loop.add_future(\n            future, lambda future: io_loop.remove_timeout(timeout_handle))\n    return result",
        "begin_line": 927,
        "end_line": 994,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006793478260869565,
            "pseudo_dstar_susp": 0.0008726003490401396,
            "pseudo_tarantula_susp": 0.0005408328826392645,
            "pseudo_op2_susp": 0.0008726003490401396,
            "pseudo_barinel_susp": 0.0005408328826392645
        }
    },
    {
        "name": "tornado.gen.error_callback#968",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.error_callback(future)",
        "snippet": "    def error_callback(future):\n        try:\n            future.result()\n        except Exception as e:\n            if not isinstance(e, quiet_exceptions):\n                app_log.error(\"Exception in Future %r after timeout\",\n                              future, exc_info=True)",
        "begin_line": 968,
        "end_line": 974,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006261740763932373,
            "pseudo_dstar_susp": 0.0007434944237918215,
            "pseudo_tarantula_susp": 0.0032679738562091504,
            "pseudo_op2_susp": 0.0007434944237918215,
            "pseudo_barinel_susp": 0.0032679738562091504
        }
    },
    {
        "name": "tornado.gen.timeout_callback#976",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.timeout_callback()",
        "snippet": "    def timeout_callback():\n        if not result.done():\n            result.set_exception(TimeoutError(\"Timeout\"))\n        # In case the wrapped future goes on to fail, log it.\n        future_add_done_callback(future, error_callback)",
        "begin_line": 976,
        "end_line": 980,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000625,
            "pseudo_dstar_susp": 0.000741839762611276,
            "pseudo_tarantula_susp": 0.0013280212483399733,
            "pseudo_op2_susp": 0.000741839762611276,
            "pseudo_barinel_susp": 0.0013280212483399733
        }
    },
    {
        "name": "tornado.gen.sleep#997",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.sleep(duration)",
        "snippet": "def sleep(duration):\n    \"\"\"Return a `.Future` that resolves after the given number of seconds.\n\n    When used with ``yield`` in a coroutine, this is a non-blocking\n    analogue to `time.sleep` (which should not be used in coroutines\n    because it is blocking)::\n\n        yield gen.sleep(0.5)\n\n    Note that calling this function on its own does nothing; you must\n    wait on the `.Future` it returns (usually by yielding it).\n\n    .. versionadded:: 4.1\n    \"\"\"\n    f = _create_future()\n    IOLoop.current().call_later(duration,\n                                lambda: future_set_result_unless_cancelled(f, None))\n    return f",
        "begin_line": 997,
        "end_line": 1014,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014667057788207686,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen._NullFuture.result#1023",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen._NullFuture",
        "signature": "tornado.gen._NullFuture.result(self)",
        "snippet": "    def result(self):\n        return None",
        "begin_line": 1023,
        "end_line": 1024,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004,
            "pseudo_dstar_susp": 0.0004399472063352398,
            "pseudo_tarantula_susp": 0.0003944773175542406,
            "pseudo_op2_susp": 0.0004399472063352398,
            "pseudo_barinel_susp": 0.0003944773175542406
        }
    },
    {
        "name": "tornado.gen._NullFuture.done#1026",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen._NullFuture",
        "signature": "tornado.gen._NullFuture.done(self)",
        "snippet": "    def done(self):\n        return True",
        "begin_line": 1026,
        "end_line": 1027,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004,
            "pseudo_dstar_susp": 0.0004399472063352398,
            "pseudo_tarantula_susp": 0.0003944773175542406,
            "pseudo_op2_susp": 0.0004399472063352398,
            "pseudo_barinel_susp": 0.0003944773175542406
        }
    },
    {
        "name": "tornado.gen.Runner.__init__#1061",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Runner",
        "signature": "tornado.gen.Runner.__init__(self, gen, result_future, first_yielded)",
        "snippet": "    def __init__(self, gen, result_future, first_yielded):\n        self.gen = gen\n        self.result_future = result_future\n        self.future = _null_future\n        self.yield_point = None\n        self.pending_callbacks = None\n        self.results = None\n        self.running = False\n        self.finished = False\n        self.had_exception = False\n        self.io_loop = IOLoop.current()\n        # For efficiency, we do not create a stack context until we\n        # reach a YieldPoint (stack contexts are required for the historical\n        # semantics of YieldPoints, but not for Futures).  When we have\n        # done so, this field will be set and must be called at the end\n        # of the coroutine.\n        self.stack_context_deactivate = None\n        if self.handle_yield(first_yielded):\n            gen = result_future = first_yielded = None\n            self.run()",
        "begin_line": 1061,
        "end_line": 1080,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012515644555694619,
            "pseudo_dstar_susp": 0.0015384615384615385,
            "pseudo_tarantula_susp": 0.0007396449704142012,
            "pseudo_op2_susp": 0.0015384615384615385,
            "pseudo_barinel_susp": 0.0007396449704142012
        }
    },
    {
        "name": "tornado.gen.Runner.register_callback#1082",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Runner",
        "signature": "tornado.gen.Runner.register_callback(self, key)",
        "snippet": "    def register_callback(self, key):\n        \"\"\"Adds ``key`` to the list of callbacks.\"\"\"\n        if self.pending_callbacks is None:\n            # Lazily initialize the old-style YieldPoint data structures.\n            self.pending_callbacks = set()\n            self.results = {}\n        if key in self.pending_callbacks:\n            raise KeyReuseError(\"key %r is already pending\" % (key,))\n        self.pending_callbacks.add(key)",
        "begin_line": 1082,
        "end_line": 1090,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.Runner.is_ready#1092",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Runner",
        "signature": "tornado.gen.Runner.is_ready(self, key)",
        "snippet": "    def is_ready(self, key):\n        \"\"\"Returns true if a result is available for ``key``.\"\"\"\n        if self.pending_callbacks is None or key not in self.pending_callbacks:\n            raise UnknownKeyError(\"key %r is not pending\" % (key,))\n        return key in self.results",
        "begin_line": 1092,
        "end_line": 1096,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.Runner.set_result#1098",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Runner",
        "signature": "tornado.gen.Runner.set_result(self, key, result)",
        "snippet": "    def set_result(self, key, result):\n        \"\"\"Sets the result for ``key`` and attempts to resume the generator.\"\"\"\n        self.results[key] = result\n        if self.yield_point is not None and self.yield_point.is_ready():\n            try:\n                future_set_result_unless_cancelled(self.future,\n                                                   self.yield_point.get_result())\n            except:\n                future_set_exc_info(self.future, sys.exc_info())\n            self.yield_point = None\n            self.run()",
        "begin_line": 1098,
        "end_line": 1108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001775568181818182,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.Runner.pop_result#1110",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Runner",
        "signature": "tornado.gen.Runner.pop_result(self, key)",
        "snippet": "    def pop_result(self, key):\n        \"\"\"Returns the result for ``key`` and unregisters it.\"\"\"\n        self.pending_callbacks.remove(key)\n        return self.results.pop(key)",
        "begin_line": 1110,
        "end_line": 1113,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016350555918901244,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.Runner.run#1115",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Runner",
        "signature": "tornado.gen.Runner.run(self)",
        "snippet": "    def run(self):\n        \"\"\"Starts or resumes the generator, running until it reaches a\n        yield point that is not ready.\n        \"\"\"\n        if self.running or self.finished:\n            return\n        try:\n            self.running = True\n            while True:\n                future = self.future\n                if not future.done():\n                    return\n                self.future = None\n                try:\n                    orig_stack_contexts = stack_context._state.contexts\n                    exc_info = None\n\n                    try:\n                        value = future.result()\n                    except Exception:\n                        self.had_exception = True\n                        exc_info = sys.exc_info()\n                    future = None\n\n                    if exc_info is not None:\n                        try:\n                            yielded = self.gen.throw(*exc_info)\n                        finally:\n                            # Break up a reference to itself\n                            # for faster GC on CPython.\n                            exc_info = None\n                    else:\n                        yielded = self.gen.send(value)\n\n                    if stack_context._state.contexts is not orig_stack_contexts:\n                        self.gen.throw(\n                            stack_context.StackContextInconsistentError(\n                                'stack_context inconsistency (probably caused '\n                                'by yield within a \"with StackContext\" block)'))\n                except (StopIteration, Return) as e:\n                    self.finished = True\n                    self.future = _null_future\n                    if self.pending_callbacks and not self.had_exception:\n                        # If we ran cleanly without waiting on all callbacks\n                        # raise an error (really more of a warning).  If we\n                        # had an exception then some callbacks may have been\n                        # orphaned, so skip the check in that case.\n                        raise LeakedCallbackError(\n                            \"finished without waiting for callbacks %r\" %\n                            self.pending_callbacks)\n                    future_set_result_unless_cancelled(self.result_future,\n                                                       _value_from_stopiteration(e))\n                    self.result_future = None\n                    self._deactivate_stack_context()\n                    return\n                except Exception:\n                    self.finished = True\n                    self.future = _null_future\n                    future_set_exc_info(self.result_future, sys.exc_info())\n                    self.result_future = None\n                    self._deactivate_stack_context()\n                    return\n                if not self.handle_yield(yielded):\n                    return\n                yielded = None\n        finally:\n            self.running = False",
        "begin_line": 1115,
        "end_line": 1181,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012004801920768306,
            "pseudo_dstar_susp": 0.0013698630136986301,
            "pseudo_tarantula_susp": 0.0012755102040816326,
            "pseudo_op2_susp": 0.0013698630136986301,
            "pseudo_barinel_susp": 0.0012755102040816326
        }
    },
    {
        "name": "tornado.gen.Runner.handle_yield#1183",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Runner",
        "signature": "tornado.gen.Runner.handle_yield(self, yielded)",
        "snippet": "    def handle_yield(self, yielded):\n        # Lists containing YieldPoints require stack contexts;\n        # other lists are handled in convert_yielded.\n        if _contains_yieldpoint(yielded):\n            yielded = multi(yielded)\n\n        if isinstance(yielded, YieldPoint):\n            # YieldPoints are too closely coupled to the Runner to go\n            # through the generic convert_yielded mechanism.\n            self.future = Future()\n\n            def start_yield_point():\n                try:\n                    yielded.start(self)\n                    if yielded.is_ready():\n                        future_set_result_unless_cancelled(self.future, yielded.get_result())\n                    else:\n                        self.yield_point = yielded\n                except Exception:\n                    self.future = Future()\n                    future_set_exc_info(self.future, sys.exc_info())\n\n            if self.stack_context_deactivate is None:\n                # Start a stack context if this is the first\n                # YieldPoint we've seen.\n                with stack_context.ExceptionStackContext(\n                        self.handle_exception) as deactivate:\n                    self.stack_context_deactivate = deactivate\n\n                    def cb():\n                        start_yield_point()\n                        self.run()\n                    self.io_loop.add_callback(cb)\n                    return False\n            else:\n                start_yield_point()\n        else:\n            try:\n                self.future = convert_yielded(yielded)\n            except BadYieldError:\n                self.future = Future()\n                future_set_exc_info(self.future, sys.exc_info())\n\n        if self.future is moment:\n            self.io_loop.add_callback(self.run)\n            return False\n        elif not self.future.done():\n            def inner(f):\n                # Break a reference cycle to speed GC.\n                f = None  # noqa\n                self.run()\n            self.io_loop.add_future(\n                self.future, inner)\n            return False\n        return True",
        "begin_line": 1183,
        "end_line": 1237,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012836970474967907,
            "pseudo_dstar_susp": 0.0015698587127158557,
            "pseudo_tarantula_susp": 0.000877963125548727,
            "pseudo_op2_susp": 0.0015698587127158557,
            "pseudo_barinel_susp": 0.000877963125548727
        }
    },
    {
        "name": "tornado.gen.Runner.start_yield_point#1194",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Runner",
        "signature": "tornado.gen.Runner.start_yield_point()",
        "snippet": "            def start_yield_point():\n                try:\n                    yielded.start(self)\n                    if yielded.is_ready():\n                        future_set_result_unless_cancelled(self.future, yielded.get_result())\n                    else:\n                        self.yield_point = yielded\n                except Exception:\n                    self.future = Future()\n                    future_set_exc_info(self.future, sys.exc_info())",
        "begin_line": 1194,
        "end_line": 1203,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.Runner.cb#1212",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Runner",
        "signature": "tornado.gen.Runner.cb()",
        "snippet": "                    def cb():\n                        start_yield_point()\n                        self.run()",
        "begin_line": 1212,
        "end_line": 1214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015158405335758679,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.Runner.inner#1230",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Runner",
        "signature": "tornado.gen.Runner.inner(f)",
        "snippet": "            def inner(f):\n                # Break a reference cycle to speed GC.\n                f = None  # noqa\n                self.run()",
        "begin_line": 1230,
        "end_line": 1233,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020491803278688526,
            "pseudo_dstar_susp": 0.003076923076923077,
            "pseudo_tarantula_susp": 0.0007552870090634441,
            "pseudo_op2_susp": 0.003076923076923077,
            "pseudo_barinel_susp": 0.0007552870090634441
        }
    },
    {
        "name": "tornado.gen.Runner.result_callback#1239",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Runner",
        "signature": "tornado.gen.Runner.result_callback(self, key)",
        "snippet": "    def result_callback(self, key):\n        return stack_context.wrap(_argument_adapter(\n            functools.partial(self.set_result, key)))",
        "begin_line": 1239,
        "end_line": 1241,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015248551387618176,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.Runner.handle_exception#1243",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Runner",
        "signature": "tornado.gen.Runner.handle_exception(self, typ, value, tb)",
        "snippet": "    def handle_exception(self, typ, value, tb):\n        if not self.running and not self.finished:\n            self.future = Future()\n            future_set_exc_info(self.future, (typ, value, tb))\n            self.run()\n            return True\n        else:\n            return False",
        "begin_line": 1243,
        "end_line": 1250,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.Runner._deactivate_stack_context#1252",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen.Runner",
        "signature": "tornado.gen.Runner._deactivate_stack_context(self)",
        "snippet": "    def _deactivate_stack_context(self):\n        if self.stack_context_deactivate is not None:\n            self.stack_context_deactivate()\n            self.stack_context_deactivate = None",
        "begin_line": 1252,
        "end_line": 1255,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009615384615384616,
            "pseudo_dstar_susp": 0.001349527665317139,
            "pseudo_tarantula_susp": 0.0007127583749109052,
            "pseudo_op2_susp": 0.001349527665317139,
            "pseudo_barinel_susp": 0.0007127583749109052
        }
    },
    {
        "name": "tornado.gen._argument_adapter#1261",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen._argument_adapter(callback)",
        "snippet": "def _argument_adapter(callback):\n    \"\"\"Returns a function that when invoked runs ``callback`` with one arg.\n\n    If the function returned by this function is called with exactly\n    one argument, that argument is passed to ``callback``.  Otherwise\n    the args tuple and kwargs dict are wrapped in an `Arguments` object.\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        if kwargs or len(args) > 1:\n            callback(Arguments(args, kwargs))\n        elif args:\n            callback(args[0])\n        else:\n            callback(None)\n    return wrapper",
        "begin_line": 1261,
        "end_line": 1275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014423770373575654,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.gen.wrapper#1268",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.wrapper(*args, **kwargs)",
        "snippet": "    def wrapper(*args, **kwargs):\n        if kwargs or len(args) > 1:\n            callback(Arguments(args, kwargs))\n        elif args:\n            callback(args[0])\n        else:\n            callback(None)",
        "begin_line": 1268,
        "end_line": 1274,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002053388090349076,
            "pseudo_dstar_susp": 0.0031645569620253164,
            "pseudo_tarantula_susp": 0.001182033096926714,
            "pseudo_op2_susp": 0.0031645569620253164,
            "pseudo_barinel_susp": 0.001182033096926714
        }
    },
    {
        "name": "tornado.gen.convert_yielded#1337",
        "src_path": "tornado/gen.py",
        "class_name": "tornado.gen",
        "signature": "tornado.gen.convert_yielded(yielded)",
        "snippet": "def convert_yielded(yielded):\n    \"\"\"Convert a yielded object into a `.Future`.\n\n    The default implementation accepts lists, dictionaries, and Futures.\n\n    If the `~functools.singledispatch` library is available, this function\n    may be extended to support additional types. For example::\n\n        @convert_yielded.register(asyncio.Future)\n        def _(asyncio_future):\n            return tornado.platform.asyncio.to_tornado_future(asyncio_future)\n\n    .. versionadded:: 4.1\n    \"\"\"\n    # Lists and dicts containing YieldPoints were handled earlier.\n    if yielded is None or yielded is moment:\n        return moment\n    elif yielded is _null_future:\n        return _null_future\n    elif isinstance(yielded, (list, dict)):\n        return multi(yielded)\n    elif is_future(yielded):\n        return yielded\n    elif isawaitable(yielded):\n        return _wrap_awaitable(yielded)\n    else:\n        raise BadYieldError(\"yielded unknown object %r\" % (yielded,))",
        "begin_line": 1337,
        "end_line": 1363,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001451378809869376,
            "pseudo_dstar_susp": 0.00228310502283105,
            "pseudo_tarantula_susp": 0.0009233610341643582,
            "pseudo_op2_susp": 0.00228310502283105,
            "pseudo_barinel_susp": 0.0009233610341643582
        }
    },
    {
        "name": "tornado.util.ObjectDict.__getattr__#100",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.ObjectDict",
        "signature": "tornado.util.ObjectDict.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        # type: (str) -> Any\n        try:\n            return self[name]\n        except KeyError:\n            raise AttributeError(name)",
        "begin_line": 100,
        "end_line": 105,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016880486158001352,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.util.GzipDecompressor.__init__#118",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.GzipDecompressor",
        "signature": "tornado.util.GzipDecompressor.__init__(self)",
        "snippet": "    def __init__(self):\n        # Magic parameter makes zlib module understand gzip header\n        # http://stackoverflow.com/questions/1838699/how-can-i-decompress-a-gzip-stream-with-zlib\n        # This works on cpython and pypy, but not jython.\n        self.decompressobj = zlib.decompressobj(16 + zlib.MAX_WBITS)",
        "begin_line": 118,
        "end_line": 122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016017940092904052,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.util.GzipDecompressor.decompress#124",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.GzipDecompressor",
        "signature": "tornado.util.GzipDecompressor.decompress(self, value, max_length=None)",
        "snippet": "    def decompress(self, value, max_length=None):\n        # type: (bytes, Optional[int]) -> bytes\n        \"\"\"Decompress a chunk, returning newly-available data.\n\n        Some data may be buffered for later processing; `flush` must\n        be called when there is no more input data to ensure that\n        all data was processed.\n\n        If ``max_length`` is given, some input data may be left over\n        in ``unconsumed_tail``; you must retrieve this value and pass\n        it back to a future call to `decompress` if it is not empty.\n        \"\"\"\n        return self.decompressobj.decompress(value, max_length)",
        "begin_line": 124,
        "end_line": 136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016017940092904052,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.util.GzipDecompressor.unconsumed_tail#139",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.GzipDecompressor",
        "signature": "tornado.util.GzipDecompressor.unconsumed_tail(self)",
        "snippet": "    def unconsumed_tail(self):\n        # type: () -> bytes\n        \"\"\"Returns the unconsumed portion left over\n        \"\"\"\n        return self.decompressobj.unconsumed_tail",
        "begin_line": 139,
        "end_line": 143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016017940092904052,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.util.GzipDecompressor.flush#145",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.GzipDecompressor",
        "signature": "tornado.util.GzipDecompressor.flush(self)",
        "snippet": "    def flush(self):\n        # type: () -> bytes\n        \"\"\"Return any remaining buffered data not yet returned by decompress.\n\n        Also checks for errors such as truncated input.\n        No other methods may be called on this object after `flush`.\n        \"\"\"\n        return self.decompressobj.flush()",
        "begin_line": 145,
        "end_line": 152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016017940092904052,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.util.import_object#155",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util",
        "signature": "tornado.util.import_object(name)",
        "snippet": "def import_object(name):\n    # type: (_BaseString) -> Any\n    \"\"\"Imports an object by name.\n\n    import_object('x') is equivalent to 'import x'.\n    import_object('x.y.z') is equivalent to 'from x.y import z'.\n\n    >>> import tornado.escape\n    >>> import_object('tornado.escape') is tornado.escape\n    True\n    >>> import_object('tornado.escape.utf8') is tornado.escape.utf8\n    True\n    >>> import_object('tornado') is tornado\n    True\n    >>> import_object('tornado.missing_module')\n    Traceback (most recent call last):\n        ...\n    ImportError: No module named missing_module\n    \"\"\"\n    if not isinstance(name, str):\n        # on python 2 a byte string is required.\n        name = name.encode('utf-8')\n    if name.count('.') == 0:\n        return __import__(name, None, None)\n\n    parts = name.split('.')\n    obj = __import__('.'.join(parts[:-1]), None, None, [parts[-1]], 0)\n    try:\n        return getattr(obj, parts[-1])\n    except AttributeError:\n        raise ImportError(\"No module named %s\" % parts[-1])",
        "begin_line": 155,
        "end_line": 185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001885369532428356,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.util.exec_in#194",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util",
        "signature": "tornado.util.exec_in(code, glob, loc=None)",
        "snippet": "def exec_in(code, glob, loc=None):\n    # type: (Any, Dict[str, Any], Optional[Mapping[str, Any]]) -> Any\n    if isinstance(code, basestring_type):\n        # exec(string) inherits the caller's future imports; compile\n        # the string first to prevent that.\n        code = compile(code, '<string>', 'exec', dont_inherit=True)\n    exec(code, glob, loc)",
        "begin_line": 194,
        "end_line": 200,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.util.errno_from_exception#219",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util",
        "signature": "tornado.util.errno_from_exception(e)",
        "snippet": "def errno_from_exception(e):\n    # type: (BaseException) -> Optional[int]\n    \"\"\"Provides the errno from an Exception object.\n\n    There are cases that the errno attribute was not set so we pull\n    the errno out of the args but if someone instantiates an Exception\n    without any args you will get a tuple error. So this function\n    abstracts all that behavior to give you a safe way to get the\n    errno.\n    \"\"\"\n\n    if hasattr(e, 'errno'):\n        return e.errno  # type: ignore\n    elif e.args:\n        return e.args[0]\n    else:\n        return None",
        "begin_line": 219,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003215434083601286,
            "pseudo_dstar_susp": 0.0035971223021582736,
            "pseudo_tarantula_susp": 0.001949317738791423,
            "pseudo_op2_susp": 0.0035971223021582736,
            "pseudo_barinel_susp": 0.001949317738791423
        }
    },
    {
        "name": "tornado.util._re_unescape_replacement#242",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util",
        "signature": "tornado.util._re_unescape_replacement(match)",
        "snippet": "def _re_unescape_replacement(match):\n    # type: (Match[str]) -> str\n    group = match.group(1)\n    if group[0] in _alphanum:\n        raise ValueError(\"cannot unescape '\\\\\\\\%s'\" % group[0])\n    return group",
        "begin_line": 242,
        "end_line": 247,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.util.re_unescape#253",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util",
        "signature": "tornado.util.re_unescape(s)",
        "snippet": "def re_unescape(s):\n    # type: (str) -> str\n    \"\"\"Unescape a string escaped by `re.escape`.\n\n    May raise ``ValueError`` for regular expressions which could not\n    have been produced by `re.escape` (for example, strings containing\n    ``\\d`` cannot be unescaped).\n\n    .. versionadded:: 4.4\n    \"\"\"\n    return _re_unescape_pattern.sub(_re_unescape_replacement, s)",
        "begin_line": 253,
        "end_line": 263,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018248175182481751,
            "pseudo_dstar_susp": 0.001876172607879925,
            "pseudo_tarantula_susp": 0.0012836970474967907,
            "pseudo_op2_susp": 0.001876172607879925,
            "pseudo_barinel_susp": 0.0012836970474967907
        }
    },
    {
        "name": "tornado.util.Configurable.__new__#295",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.Configurable",
        "signature": "tornado.util.Configurable.__new__(cls, *args, **kwargs)",
        "snippet": "    def __new__(cls, *args, **kwargs):\n        base = cls.configurable_base()\n        init_kwargs = {}\n        if cls is base:\n            impl = cls.configured_class()\n            if base.__impl_kwargs:\n                init_kwargs.update(base.__impl_kwargs)\n        else:\n            impl = cls\n        init_kwargs.update(kwargs)\n        if impl.configurable_base() is not base:\n            # The impl class is itself configurable, so recurse.\n            return impl(*args, **init_kwargs)\n        instance = super(Configurable, cls).__new__(impl)\n        # initialize vs __init__ chosen for compatibility with AsyncHTTPClient\n        # singleton magic.  If we get rid of that we can switch to __init__\n        # here too.\n        instance.initialize(*args, **init_kwargs)\n        return instance",
        "begin_line": 295,
        "end_line": 313,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028089887640449437,
            "pseudo_dstar_susp": 0.015151515151515152,
            "pseudo_tarantula_susp": 0.0028011204481792717,
            "pseudo_op2_susp": 0.015151515151515152,
            "pseudo_barinel_susp": 0.0028011204481792717
        }
    },
    {
        "name": "tornado.util.Configurable.initialize#333",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.Configurable",
        "signature": "tornado.util.Configurable.initialize(self)",
        "snippet": "    def initialize(self):\n        # type: () -> None\n        \"\"\"Initialize a `Configurable` subclass instance.\n\n        Configurable classes should use `initialize` instead of ``__init__``.\n\n        .. versionchanged:: 4.2\n           Now accepts positional arguments in addition to keyword arguments.\n        \"\"\"",
        "begin_line": 333,
        "end_line": 341,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001949317738791423,
            "pseudo_dstar_susp": 0.0020325203252032522,
            "pseudo_tarantula_susp": 0.001288659793814433,
            "pseudo_op2_susp": 0.0020325203252032522,
            "pseudo_barinel_susp": 0.001288659793814433
        }
    },
    {
        "name": "tornado.util.Configurable.configure#344",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.Configurable",
        "signature": "tornado.util.Configurable.configure(cls, impl, **kwargs)",
        "snippet": "    def configure(cls, impl, **kwargs):\n        # type: (Any, **Any) -> None\n        \"\"\"Sets the class to use when the base class is instantiated.\n\n        Keyword arguments will be saved and added to the arguments passed\n        to the constructor.  This can be used to set global defaults for\n        some parameters.\n        \"\"\"\n        base = cls.configurable_base()\n        if isinstance(impl, (str, unicode_type)):\n            impl = import_object(impl)\n        if impl is not None and not issubclass(impl, cls):\n            raise ValueError(\"Invalid subclass of %s\" % cls)\n        base.__impl_class = impl\n        base.__impl_kwargs = kwargs",
        "begin_line": 344,
        "end_line": 358,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.util.Configurable.configured_class#361",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.Configurable",
        "signature": "tornado.util.Configurable.configured_class(cls)",
        "snippet": "    def configured_class(cls):\n        # type: () -> type\n        \"\"\"Returns the currently configured class.\"\"\"\n        base = cls.configurable_base()\n        # Manually mangle the private name to see whether this base\n        # has been configured (and not another base higher in the\n        # hierarchy).\n        if base.__dict__.get('_Configurable__impl_class') is None:\n            base.__impl_class = cls.configurable_default()\n        return base.__impl_class",
        "begin_line": 361,
        "end_line": 370,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0026954177897574125,
            "pseudo_dstar_susp": 0.013157894736842105,
            "pseudo_tarantula_susp": 0.001483679525222552,
            "pseudo_op2_susp": 0.013157894736842105,
            "pseudo_barinel_susp": 0.001483679525222552
        }
    },
    {
        "name": "tornado.util.Configurable._save_configuration#373",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.Configurable",
        "signature": "tornado.util.Configurable._save_configuration(cls)",
        "snippet": "    def _save_configuration(cls):\n        # type: () -> Tuple[type, Dict[str, Any]]\n        base = cls.configurable_base()\n        return (base.__impl_class, base.__impl_kwargs)",
        "begin_line": 373,
        "end_line": 376,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019275250578257516,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.util.Configurable._restore_configuration#379",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.Configurable",
        "signature": "tornado.util.Configurable._restore_configuration(cls, saved)",
        "snippet": "    def _restore_configuration(cls, saved):\n        # type: (Tuple[type, Dict[str, Any]]) -> None\n        base = cls.configurable_base()\n        base.__impl_class = saved[0]\n        base.__impl_kwargs = saved[1]",
        "begin_line": 379,
        "end_line": 383,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019275250578257516,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.util.ArgReplacer.__init__#393",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.ArgReplacer",
        "signature": "tornado.util.ArgReplacer.__init__(self, func, name)",
        "snippet": "    def __init__(self, func, name):\n        # type: (Callable, str) -> None\n        self.name = name\n        try:\n            self.arg_pos = self._getargnames(func).index(name)\n        except ValueError:\n            # Not a positional parameter\n            self.arg_pos = None",
        "begin_line": 393,
        "end_line": 400,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.util.ArgReplacer._getargnames#402",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.ArgReplacer",
        "signature": "tornado.util.ArgReplacer._getargnames(self, func)",
        "snippet": "    def _getargnames(self, func):\n        # type: (Callable) -> List[str]\n        try:\n            return getargspec(func).args\n        except TypeError:\n            if hasattr(func, 'func_code'):\n                # Cython-generated code has all the attributes needed\n                # by inspect.getargspec, but the inspect module only\n                # works with ordinary functions. Inline the portion of\n                # getargspec that we need here. Note that for static\n                # functions the @cython.binding(True) decorator must\n                # be used (for methods it works out of the box).\n                code = func.func_code  # type: ignore\n                return code.co_varnames[:code.co_argcount]\n            raise",
        "begin_line": 402,
        "end_line": 416,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.util.ArgReplacer.get_old_value#418",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.ArgReplacer",
        "signature": "tornado.util.ArgReplacer.get_old_value(self, args, kwargs, default=None)",
        "snippet": "    def get_old_value(self, args, kwargs, default=None):\n        # type: (List[Any], Dict[str, Any], Any) -> Any\n        \"\"\"Returns the old value of the named argument without replacing it.\n\n        Returns ``default`` if the argument is not present.\n        \"\"\"\n        if self.arg_pos is not None and len(args) > self.arg_pos:\n            return args[self.arg_pos]\n        else:\n            return kwargs.get(self.name, default)",
        "begin_line": 418,
        "end_line": 427,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.util.ArgReplacer.replace#429",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util.ArgReplacer",
        "signature": "tornado.util.ArgReplacer.replace(self, new_value, args, kwargs)",
        "snippet": "    def replace(self, new_value, args, kwargs):\n        # type: (Any, List[Any], Dict[str, Any]) -> Tuple[Any, List[Any], Dict[str, Any]]\n        \"\"\"Replace the named argument in ``args, kwargs`` with ``new_value``.\n\n        Returns ``(old_value, args, kwargs)``.  The returned ``args`` and\n        ``kwargs`` objects may not be the same as the input objects, or\n        the input objects may be mutated.\n\n        If the named argument was not found, ``new_value`` will be added\n        to ``kwargs`` and None will be returned as ``old_value``.\n        \"\"\"\n        if self.arg_pos is not None and len(args) > self.arg_pos:\n            # The arg to replace is passed positionally\n            old_value = args[self.arg_pos]\n            args = list(args)  # *args is normally a tuple\n            args[self.arg_pos] = new_value\n        else:\n            # The arg to replace is either omitted or passed by keyword.\n            old_value = kwargs.get(self.name)\n            kwargs[self.name] = new_value\n        return old_value, args, kwargs",
        "begin_line": 429,
        "end_line": 449,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019275250578257516,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.util.timedelta_to_seconds#452",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util",
        "signature": "tornado.util.timedelta_to_seconds(td)",
        "snippet": "def timedelta_to_seconds(td):\n    # type: (datetime.timedelta) -> float\n    \"\"\"Equivalent to td.total_seconds() (introduced in python 2.7).\"\"\"\n    return (td.microseconds + (td.seconds + td.days * 24 * 3600) * 10 ** 6) / float(10 ** 6)",
        "begin_line": 452,
        "end_line": 455,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00044014084507042255,
            "pseudo_dstar_susp": 0.00041186161449752884,
            "pseudo_tarantula_susp": 0.0006706908115358819,
            "pseudo_op2_susp": 0.00041186161449752884,
            "pseudo_barinel_susp": 0.0006706908115358819
        }
    },
    {
        "name": "tornado.util._websocket_mask_python#458",
        "src_path": "tornado/util.py",
        "class_name": "tornado.util",
        "signature": "tornado.util._websocket_mask_python(mask, data)",
        "snippet": "def _websocket_mask_python(mask, data):\n    # type: (bytes, bytes) -> bytes\n    \"\"\"Websocket masking function.\n\n    `mask` is a `bytes` object of length 4; `data` is a `bytes` object of any length.\n    Returns a `bytes` object of the same length as `data` with the mask applied\n    as specified in section 5.3 of RFC 6455.\n\n    This pure-python implementation may be replaced by an optimized version when available.\n    \"\"\"\n    mask_arr = array.array(\"B\", mask)\n    unmasked_arr = array.array(\"B\", data)\n    for i in xrange(len(data)):\n        unmasked_arr[i] = unmasked_arr[i] ^ mask_arr[i % 4]\n    if PY3:\n        # tostring was deprecated in py32.  It hasn't been removed,\n        # but since we turn on deprecation warnings in our tests\n        # we need to use the right one.\n        return unmasked_arr.tobytes()\n    else:\n        return unmasked_arr.tostring()",
        "begin_line": 458,
        "end_line": 478,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013939224979091162,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.simple_httpclient.SimpleAsyncHTTPClient.initialize#47",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.SimpleAsyncHTTPClient",
        "signature": "tornado.simple_httpclient.SimpleAsyncHTTPClient.initialize(self, max_clients=10, hostname_mapping=None, max_buffer_size=104857600, resolver=None, defaults=None, max_header_size=None, max_body_size=None)",
        "snippet": "    def initialize(self, max_clients=10,\n                   hostname_mapping=None, max_buffer_size=104857600,\n                   resolver=None, defaults=None, max_header_size=None,\n                   max_body_size=None):\n        \"\"\"Creates a AsyncHTTPClient.\n\n        Only a single AsyncHTTPClient instance exists per IOLoop\n        in order to provide limitations on the number of pending connections.\n        ``force_instance=True`` may be used to suppress this behavior.\n\n        Note that because of this implicit reuse, unless ``force_instance``\n        is used, only the first call to the constructor actually uses\n        its arguments. It is recommended to use the ``configure`` method\n        instead of the constructor to ensure that arguments take effect.\n\n        ``max_clients`` is the number of concurrent requests that can be\n        in progress; when this limit is reached additional requests will be\n        queued. Note that time spent waiting in this queue still counts\n        against the ``request_timeout``.\n\n        ``hostname_mapping`` is a dictionary mapping hostnames to IP addresses.\n        It can be used to make local DNS changes when modifying system-wide\n        settings like ``/etc/hosts`` is not possible or desirable (e.g. in\n        unittests).\n\n        ``max_buffer_size`` (default 100MB) is the number of bytes\n        that can be read into memory at once. ``max_body_size``\n        (defaults to ``max_buffer_size``) is the largest response body\n        that the client will accept.  Without a\n        ``streaming_callback``, the smaller of these two limits\n        applies; with a ``streaming_callback`` only ``max_body_size``\n        does.\n\n        .. versionchanged:: 4.2\n           Added the ``max_body_size`` argument.\n        \"\"\"\n        super(SimpleAsyncHTTPClient, self).initialize(defaults=defaults)\n        self.max_clients = max_clients\n        self.queue = collections.deque()\n        self.active = {}\n        self.waiting = {}\n        self.max_buffer_size = max_buffer_size\n        self.max_header_size = max_header_size\n        self.max_body_size = max_body_size\n        # TCPClient could create a Resolver for us, but we have to do it\n        # ourselves to support hostname_mapping.\n        if resolver:\n            self.resolver = resolver\n            self.own_resolver = False\n        else:\n            self.resolver = Resolver()\n            self.own_resolver = True\n        if hostname_mapping is not None:\n            self.resolver = OverrideResolver(resolver=self.resolver,\n                                             mapping=hostname_mapping)\n        self.tcp_client = TCPClient(resolver=self.resolver)",
        "begin_line": 47,
        "end_line": 102,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015503875968992248,
            "pseudo_dstar_susp": 0.0016155088852988692,
            "pseudo_tarantula_susp": 0.0011312217194570137,
            "pseudo_op2_susp": 0.0016155088852988692,
            "pseudo_barinel_susp": 0.0011312217194570137
        }
    },
    {
        "name": "tornado.simple_httpclient.SimpleAsyncHTTPClient.close#104",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.SimpleAsyncHTTPClient",
        "signature": "tornado.simple_httpclient.SimpleAsyncHTTPClient.close(self)",
        "snippet": "    def close(self):\n        super(SimpleAsyncHTTPClient, self).close()\n        if self.own_resolver:\n            self.resolver.close()\n        self.tcp_client.close()",
        "begin_line": 104,
        "end_line": 108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013089005235602095,
            "pseudo_dstar_susp": 0.001392757660167131,
            "pseudo_tarantula_susp": 0.001026694045174538,
            "pseudo_op2_susp": 0.001392757660167131,
            "pseudo_barinel_susp": 0.001026694045174538
        }
    },
    {
        "name": "tornado.simple_httpclient.SimpleAsyncHTTPClient.fetch_impl#110",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.SimpleAsyncHTTPClient",
        "signature": "tornado.simple_httpclient.SimpleAsyncHTTPClient.fetch_impl(self, request, callback)",
        "snippet": "    def fetch_impl(self, request, callback):\n        key = object()\n        self.queue.append((key, request, callback))\n        if not len(self.active) < self.max_clients:\n            timeout_handle = self.io_loop.add_timeout(\n                self.io_loop.time() + min(request.connect_timeout,\n                                          request.request_timeout),\n                functools.partial(self._on_timeout, key, \"in request queue\"))\n        else:\n            timeout_handle = None\n        self.waiting[key] = (request, callback, timeout_handle)\n        self._process_queue()\n        if self.queue:\n            gen_log.debug(\"max_clients limit reached, request queued. \"\n                          \"%d active, %d queued requests.\" % (\n                              len(self.active), len(self.queue)))",
        "begin_line": 110,
        "end_line": 125,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011248593925759281,
            "pseudo_dstar_susp": 0.0011074197120708748,
            "pseudo_tarantula_susp": 0.0032679738562091504,
            "pseudo_op2_susp": 0.0011074197120708748,
            "pseudo_barinel_susp": 0.0032679738562091504
        }
    },
    {
        "name": "tornado.simple_httpclient.SimpleAsyncHTTPClient._process_queue#127",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.SimpleAsyncHTTPClient",
        "signature": "tornado.simple_httpclient.SimpleAsyncHTTPClient._process_queue(self)",
        "snippet": "    def _process_queue(self):\n        with stack_context.NullContext():\n            while self.queue and len(self.active) < self.max_clients:\n                key, request, callback = self.queue.popleft()\n                if key not in self.waiting:\n                    continue\n                self._remove_timeout(key)\n                self.active[key] = (request, callback)\n                release_callback = functools.partial(self._release_fetch, key)\n                self._handle_request(request, release_callback, callback)",
        "begin_line": 127,
        "end_line": 136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011248593925759281,
            "pseudo_dstar_susp": 0.0011074197120708748,
            "pseudo_tarantula_susp": 0.0009765625,
            "pseudo_op2_susp": 0.0011074197120708748,
            "pseudo_barinel_susp": 0.0009765625
        }
    },
    {
        "name": "tornado.simple_httpclient.SimpleAsyncHTTPClient._connection_class#138",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.SimpleAsyncHTTPClient",
        "signature": "tornado.simple_httpclient.SimpleAsyncHTTPClient._connection_class(self)",
        "snippet": "    def _connection_class(self):\n        return _HTTPConnection",
        "begin_line": 138,
        "end_line": 139,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011248593925759281,
            "pseudo_dstar_susp": 0.0011074197120708748,
            "pseudo_tarantula_susp": 0.0009765625,
            "pseudo_op2_susp": 0.0011074197120708748,
            "pseudo_barinel_susp": 0.0009765625
        }
    },
    {
        "name": "tornado.simple_httpclient.SimpleAsyncHTTPClient._handle_request#141",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.SimpleAsyncHTTPClient",
        "signature": "tornado.simple_httpclient.SimpleAsyncHTTPClient._handle_request(self, request, release_callback, final_callback)",
        "snippet": "    def _handle_request(self, request, release_callback, final_callback):\n        self._connection_class()(\n            self, request, release_callback,\n            final_callback, self.max_buffer_size, self.tcp_client,\n            self.max_header_size, self.max_body_size)",
        "begin_line": 141,
        "end_line": 145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011248593925759281,
            "pseudo_dstar_susp": 0.0011074197120708748,
            "pseudo_tarantula_susp": 0.0009765625,
            "pseudo_op2_susp": 0.0011074197120708748,
            "pseudo_barinel_susp": 0.0009765625
        }
    },
    {
        "name": "tornado.simple_httpclient.SimpleAsyncHTTPClient._release_fetch#147",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.SimpleAsyncHTTPClient",
        "signature": "tornado.simple_httpclient.SimpleAsyncHTTPClient._release_fetch(self, key)",
        "snippet": "    def _release_fetch(self, key):\n        del self.active[key]\n        self._process_queue()",
        "begin_line": 147,
        "end_line": 149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004965243296921549,
            "pseudo_dstar_susp": 0.000578368999421631,
            "pseudo_tarantula_susp": 0.00048192771084337347,
            "pseudo_op2_susp": 0.000578368999421631,
            "pseudo_barinel_susp": 0.00048192771084337347
        }
    },
    {
        "name": "tornado.simple_httpclient.SimpleAsyncHTTPClient._remove_timeout#151",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.SimpleAsyncHTTPClient",
        "signature": "tornado.simple_httpclient.SimpleAsyncHTTPClient._remove_timeout(self, key)",
        "snippet": "    def _remove_timeout(self, key):\n        if key in self.waiting:\n            request, callback, timeout_handle = self.waiting[key]\n            if timeout_handle is not None:\n                self.io_loop.remove_timeout(timeout_handle)\n            del self.waiting[key]",
        "begin_line": 151,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011248593925759281,
            "pseudo_dstar_susp": 0.0011074197120708748,
            "pseudo_tarantula_susp": 0.0009765625,
            "pseudo_op2_susp": 0.0011074197120708748,
            "pseudo_barinel_susp": 0.0009765625
        }
    },
    {
        "name": "tornado.simple_httpclient.SimpleAsyncHTTPClient._on_timeout#158",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient.SimpleAsyncHTTPClient",
        "signature": "tornado.simple_httpclient.SimpleAsyncHTTPClient._on_timeout(self, key, info=None)",
        "snippet": "    def _on_timeout(self, key, info=None):\n        \"\"\"Timeout callback of request.\n\n        Construct a timeout HTTPResponse when a timeout occurs.\n\n        :arg object key: A simple object to mark the request.\n        :info string key: More detailed timeout information.\n        \"\"\"\n        request, callback, timeout_handle = self.waiting[key]\n        self.queue.remove((key, request, callback))\n\n        error_message = \"Timeout {0}\".format(info) if info else \"Timeout\"\n        timeout_response = HTTPResponse(\n            request, 599, error=HTTPError(599, error_message),\n            request_time=self.io_loop.time() - request.start_time)\n        self.io_loop.add_callback(callback, timeout_response)\n        del self.waiting[key]",
        "begin_line": 158,
        "end_line": 174,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection.__init__#180",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection.__init__(self, client, request, release_callback, final_callback, max_buffer_size, tcp_client, max_header_size, max_body_size)",
        "snippet": "    def __init__(self, client, request, release_callback,\n                 final_callback, max_buffer_size, tcp_client,\n                 max_header_size, max_body_size):\n        self.io_loop = IOLoop.current()\n        self.start_time = self.io_loop.time()\n        self.client = client\n        self.request = request\n        self.release_callback = release_callback\n        self.final_callback = final_callback\n        self.max_buffer_size = max_buffer_size\n        self.tcp_client = tcp_client\n        self.max_header_size = max_header_size\n        self.max_body_size = max_body_size\n        self.code = None\n        self.headers = None\n        self.chunks = []\n        self._decompressor = None\n        # Timeout handle returned by IOLoop.add_timeout\n        self._timeout = None\n        self._sockaddr = None\n        with stack_context.ExceptionStackContext(self._handle_exception):\n            self.parsed = urlparse.urlsplit(_unicode(self.request.url))\n            if self.parsed.scheme not in (\"http\", \"https\"):\n                raise ValueError(\"Unsupported url scheme: %s\" %\n                                 self.request.url)\n            # urlsplit results have hostname and port results, but they\n            # didn't support ipv6 literals until python 2.7.\n            netloc = self.parsed.netloc\n            if \"@\" in netloc:\n                userpass, _, netloc = netloc.rpartition(\"@\")\n            host, port = httputil.split_host_and_port(netloc)\n            if port is None:\n                port = 443 if self.parsed.scheme == \"https\" else 80\n            if re.match(r'^\\[.*\\]$', host):\n                # raw ipv6 addresses in urls are enclosed in brackets\n                host = host[1:-1]\n            self.parsed_hostname = host  # save final host for _on_connect\n\n            if request.allow_ipv6 is False:\n                af = socket.AF_INET\n            else:\n                af = socket.AF_UNSPEC\n\n            ssl_options = self._get_ssl_options(self.parsed.scheme)\n\n            timeout = min(self.request.connect_timeout, self.request.request_timeout)\n            if timeout:\n                self._timeout = self.io_loop.add_timeout(\n                    self.start_time + timeout,\n                    stack_context.wrap(functools.partial(self._on_timeout, \"while connecting\")))\n            fut = self.tcp_client.connect(host, port, af=af,\n                                          ssl_options=ssl_options,\n                                          max_buffer_size=self.max_buffer_size)\n            fut.add_done_callback(stack_context.wrap(self._on_connect))",
        "begin_line": 180,
        "end_line": 233,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010090817356205853,
            "pseudo_dstar_susp": 0.0010822510822510823,
            "pseudo_tarantula_susp": 0.0038461538461538464,
            "pseudo_op2_susp": 0.0010822510822510823,
            "pseudo_barinel_susp": 0.0038461538461538464
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._get_ssl_options#235",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._get_ssl_options(self, scheme)",
        "snippet": "    def _get_ssl_options(self, scheme):\n        if scheme == \"https\":\n            if self.request.ssl_options is not None:\n                return self.request.ssl_options\n            # If we are using the defaults, don't construct a\n            # new SSLContext.\n            if (self.request.validate_cert and\n                    self.request.ca_certs is None and\n                    self.request.client_cert is None and\n                    self.request.client_key is None):\n                return _client_ssl_defaults\n            ssl_ctx = ssl.create_default_context(\n                ssl.Purpose.SERVER_AUTH,\n                cafile=self.request.ca_certs)\n            if not self.request.validate_cert:\n                ssl_ctx.check_hostname = False\n                ssl_ctx.verify_mode = ssl.CERT_NONE\n            if self.request.client_cert is not None:\n                ssl_ctx.load_cert_chain(self.request.client_cert,\n                                        self.request.client_key)\n            if hasattr(ssl, 'OP_NO_COMPRESSION'):\n                # See netutil.ssl_options_to_context\n                ssl_ctx.options |= ssl.OP_NO_COMPRESSION\n            return ssl_ctx\n        return None",
        "begin_line": 235,
        "end_line": 259,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00546448087431694,
            "pseudo_dstar_susp": 0.0010582010582010583,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.0010582010582010583,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._on_timeout#261",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._on_timeout(self, info=None)",
        "snippet": "    def _on_timeout(self, info=None):\n        \"\"\"Timeout callback of _HTTPConnection instance.\n\n        Raise a timeout HTTPError when a timeout occurs.\n\n        :info string key: More detailed timeout information.\n        \"\"\"\n        self._timeout = None\n        error_message = \"Timeout {0}\".format(info) if info else \"Timeout\"\n        if self.final_callback is not None:\n            raise HTTPError(599, error_message)",
        "begin_line": 261,
        "end_line": 271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._remove_timeout#273",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._remove_timeout(self)",
        "snippet": "    def _remove_timeout(self):\n        if self._timeout is not None:\n            self.io_loop.remove_timeout(self._timeout)\n            self._timeout = None",
        "begin_line": 273,
        "end_line": 276,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004854368932038835,
            "pseudo_dstar_susp": 0.0005659309564233164,
            "pseudo_tarantula_susp": 0.0004730368968779565,
            "pseudo_op2_susp": 0.0005659309564233164,
            "pseudo_barinel_susp": 0.0004730368968779565
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._on_connect#278",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._on_connect(self, stream_fut)",
        "snippet": "    def _on_connect(self, stream_fut):\n        stream = stream_fut.result()\n        if self.final_callback is None:\n            # final_callback is cleared if we've hit our timeout.\n            stream.close()\n            return\n        self.stream = stream\n        self.stream.set_close_callback(self.on_connection_close)\n        self._remove_timeout()\n        if self.final_callback is None:\n            return\n        if self.request.request_timeout:\n            self._timeout = self.io_loop.add_timeout(\n                self.start_time + self.request.request_timeout,\n                stack_context.wrap(functools.partial(self._on_timeout, \"during request\")))\n        if (self.request.method not in self._SUPPORTED_METHODS and\n                not self.request.allow_nonstandard_methods):\n            raise KeyError(\"unknown method %s\" % self.request.method)\n        for key in ('network_interface',\n                    'proxy_host', 'proxy_port',\n                    'proxy_username', 'proxy_password',\n                    'proxy_auth_mode'):\n            if getattr(self.request, key, None):\n                raise NotImplementedError('%s not supported' % key)\n        if \"Connection\" not in self.request.headers:\n            self.request.headers[\"Connection\"] = \"close\"\n        if \"Host\" not in self.request.headers:\n            if '@' in self.parsed.netloc:\n                self.request.headers[\"Host\"] = self.parsed.netloc.rpartition('@')[-1]\n            else:\n                self.request.headers[\"Host\"] = self.parsed.netloc\n        username, password = None, None\n        if self.parsed.username is not None:\n            username, password = self.parsed.username, self.parsed.password\n        elif self.request.auth_username is not None:\n            username = self.request.auth_username\n            password = self.request.auth_password or ''\n        if username is not None:\n            if self.request.auth_mode not in (None, \"basic\"):\n                raise ValueError(\"unsupported auth_mode %s\",\n                                 self.request.auth_mode)\n            auth = utf8(username) + b\":\" + utf8(password)\n            self.request.headers[\"Authorization\"] = (b\"Basic \" +\n                                                     base64.b64encode(auth))\n        if self.request.user_agent:\n            self.request.headers[\"User-Agent\"] = self.request.user_agent\n        if not self.request.allow_nonstandard_methods:\n            # Some HTTP methods nearly always have bodies while others\n            # almost never do. Fail in this case unless the user has\n            # opted out of sanity checks with allow_nonstandard_methods.\n            body_expected = self.request.method in (\"POST\", \"PATCH\", \"PUT\")\n            body_present = (self.request.body is not None or\n                            self.request.body_producer is not None)\n            if ((body_expected and not body_present) or\n                    (body_present and not body_expected)):\n                raise ValueError(\n                    'Body must %sbe None for method %s (unless '\n                    'allow_nonstandard_methods is true)' %\n                    ('not ' if body_expected else '', self.request.method))\n        if self.request.expect_100_continue:\n            self.request.headers[\"Expect\"] = \"100-continue\"\n        if self.request.body is not None:\n            # When body_producer is used the caller is responsible for\n            # setting Content-Length (or else chunked encoding will be used).\n            self.request.headers[\"Content-Length\"] = str(len(\n                self.request.body))\n        if (self.request.method == \"POST\" and\n                \"Content-Type\" not in self.request.headers):\n            self.request.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"\n        if self.request.decompress_response:\n            self.request.headers[\"Accept-Encoding\"] = \"gzip\"\n        req_path = ((self.parsed.path or '/') +\n                    (('?' + self.parsed.query) if self.parsed.query else ''))\n        self.connection = self._create_connection(stream)\n        start_line = httputil.RequestStartLine(self.request.method,\n                                               req_path, '')\n        self.connection.write_headers(start_line, self.request.headers)\n        if self.request.expect_100_continue:\n            self._read_response()\n        else:\n            self._write_body(True)",
        "begin_line": 278,
        "end_line": 358,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004854368932038835,
            "pseudo_dstar_susp": 0.0005659309564233164,
            "pseudo_tarantula_susp": 0.0005249343832020997,
            "pseudo_op2_susp": 0.0005659309564233164,
            "pseudo_barinel_susp": 0.0005249343832020997
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._create_connection#360",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._create_connection(self, stream)",
        "snippet": "    def _create_connection(self, stream):\n        stream.set_nodelay(True)\n        connection = HTTP1Connection(\n            stream, True,\n            HTTP1ConnectionParameters(\n                no_keep_alive=True,\n                max_header_size=self.max_header_size,\n                max_body_size=self.max_body_size,\n                decompress=self.request.decompress_response),\n            self._sockaddr)\n        return connection",
        "begin_line": 360,
        "end_line": 370,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00046061722708429296,
            "pseudo_dstar_susp": 0.0005330490405117271,
            "pseudo_tarantula_susp": 0.00045004500450045,
            "pseudo_op2_susp": 0.0005330490405117271,
            "pseudo_barinel_susp": 0.00045004500450045
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._write_body#372",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._write_body(self, start_read)",
        "snippet": "    def _write_body(self, start_read):\n        if self.request.body is not None:\n            self.connection.write(self.request.body)\n        elif self.request.body_producer is not None:\n            fut = self.request.body_producer(self.connection.write)\n            if fut is not None:\n                fut = gen.convert_yielded(fut)\n\n                def on_body_written(fut):\n                    fut.result()\n                    self.connection.finish()\n                    if start_read:\n                        self._read_response()\n                self.io_loop.add_future(fut, on_body_written)\n                return\n        self.connection.finish()\n        if start_read:\n            self._read_response()",
        "begin_line": 372,
        "end_line": 389,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006325110689437065,
            "pseudo_dstar_susp": 0.0005382131324004305,
            "pseudo_tarantula_susp": 0.002857142857142857,
            "pseudo_op2_susp": 0.0005382131324004305,
            "pseudo_barinel_susp": 0.002857142857142857
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection.on_body_written#380",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection.on_body_written(fut)",
        "snippet": "                def on_body_written(fut):\n                    fut.result()\n                    self.connection.finish()\n                    if start_read:\n                        self._read_response()",
        "begin_line": 380,
        "end_line": 384,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007012622720897616,
            "pseudo_dstar_susp": 0.00047596382674916705,
            "pseudo_tarantula_susp": 0.002857142857142857,
            "pseudo_op2_susp": 0.00047596382674916705,
            "pseudo_barinel_susp": 0.002857142857142857
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._read_response#391",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._read_response(self)",
        "snippet": "    def _read_response(self):\n        # Ensure that any exception raised in read_response ends up in our\n        # stack context.\n        self.io_loop.add_future(\n            self.connection.read_response(self),\n            lambda f: f.result())",
        "begin_line": 391,
        "end_line": 396,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005370569280343716,
            "pseudo_dstar_susp": 0.0006706908115358819,
            "pseudo_tarantula_susp": 0.00045004500450045,
            "pseudo_op2_susp": 0.0006706908115358819,
            "pseudo_barinel_susp": 0.00045004500450045
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._release#398",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._release(self)",
        "snippet": "    def _release(self):\n        if self.release_callback is not None:\n            release_callback = self.release_callback\n            self.release_callback = None\n            release_callback()",
        "begin_line": 398,
        "end_line": 402,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004945598417408506,
            "pseudo_dstar_susp": 0.0005757052389176742,
            "pseudo_tarantula_susp": 0.00048007681228996637,
            "pseudo_op2_susp": 0.0005757052389176742,
            "pseudo_barinel_susp": 0.00048007681228996637
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._run_callback#404",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._run_callback(self, response)",
        "snippet": "    def _run_callback(self, response):\n        self._release()\n        if self.final_callback is not None:\n            final_callback = self.final_callback\n            self.final_callback = None\n            self.io_loop.add_callback(final_callback, response)",
        "begin_line": 404,
        "end_line": 409,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004945598417408506,
            "pseudo_dstar_susp": 0.0005757052389176742,
            "pseudo_tarantula_susp": 0.00048007681228996637,
            "pseudo_op2_susp": 0.0005757052389176742,
            "pseudo_barinel_susp": 0.00048007681228996637
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._handle_exception#411",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._handle_exception(self, typ, value, tb)",
        "snippet": "    def _handle_exception(self, typ, value, tb):\n        if self.final_callback:\n            self._remove_timeout()\n            if isinstance(value, StreamClosedError):\n                if value.real_error is None:\n                    value = HTTPError(599, \"Stream closed\")\n                else:\n                    value = value.real_error\n            self._run_callback(HTTPResponse(self.request, 599, error=value,\n                                            request_time=self.io_loop.time() - self.start_time,\n                                            ))\n\n            if hasattr(self, \"stream\"):\n                # TODO: this may cause a StreamClosedError to be raised\n                # by the connection's Future.  Should we cancel the\n                # connection more gracefully?\n                self.stream.close()\n            return True\n        else:\n            # If our callback has already been called, we are probably\n            # catching an exception that is not caused by us but rather\n            # some child of our callback. Rather than drop it on the floor,\n            # pass it along, unless it's just the stream being closed.\n            return isinstance(value, StreamClosedError)",
        "begin_line": 411,
        "end_line": 434,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006765899864682003,
            "pseudo_dstar_susp": 0.000474158368895211,
            "pseudo_tarantula_susp": 0.002976190476190476,
            "pseudo_op2_susp": 0.000474158368895211,
            "pseudo_barinel_susp": 0.002976190476190476
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection.on_connection_close#436",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection.on_connection_close(self)",
        "snippet": "    def on_connection_close(self):\n        if self.final_callback is not None:\n            message = \"Connection closed\"\n            if self.stream.error:\n                raise self.stream.error\n            try:\n                raise HTTPError(599, message)\n            except HTTPError:\n                self._handle_exception(*sys.exc_info())",
        "begin_line": 436,
        "end_line": 444,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008176614881439084,
            "pseudo_dstar_susp": 0.00041999160016799666,
            "pseudo_tarantula_susp": 0.005076142131979695,
            "pseudo_op2_susp": 0.00041999160016799666,
            "pseudo_barinel_susp": 0.005076142131979695
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection.headers_received#446",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection.headers_received(self, first_line, headers)",
        "snippet": "    def headers_received(self, first_line, headers):\n        if self.request.expect_100_continue and first_line.code == 100:\n            self._write_body(False)\n            return\n        self.code = first_line.code\n        self.reason = first_line.reason\n        self.headers = headers\n\n        if self._should_follow_redirect():\n            return\n\n        if self.request.header_callback is not None:\n            # Reassemble the start line.\n            self.request.header_callback('%s %s %s\\r\\n' % first_line)\n            for k, v in self.headers.get_all():\n                self.request.header_callback(\"%s: %s\\r\\n\" % (k, v))\n            self.request.header_callback('\\r\\n')",
        "begin_line": 446,
        "end_line": 462,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000434593654932638,
            "pseudo_dstar_susp": 0.0004940711462450593,
            "pseudo_tarantula_susp": 0.0004266211604095563,
            "pseudo_op2_susp": 0.0004940711462450593,
            "pseudo_barinel_susp": 0.00042643923240938164
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._should_follow_redirect#464",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._should_follow_redirect(self)",
        "snippet": "    def _should_follow_redirect(self):\n        return (self.request.follow_redirects and\n                self.request.max_redirects > 0 and\n                self.code in (301, 302, 303, 307, 308))",
        "begin_line": 464,
        "end_line": 467,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004363001745200698,
            "pseudo_dstar_susp": 0.0004962779156327543,
            "pseudo_tarantula_susp": 0.00043010752688172043,
            "pseudo_op2_susp": 0.0004962779156327543,
            "pseudo_barinel_susp": 0.00043010752688172043
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection.finish#469",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection.finish(self)",
        "snippet": "    def finish(self):\n        data = b''.join(self.chunks)\n        self._remove_timeout()\n        original_request = getattr(self.request, \"original_request\",\n                                   self.request)\n        if self._should_follow_redirect():\n            assert isinstance(self.request, _RequestProxy)\n            new_request = copy.copy(self.request.request)\n            new_request.url = urlparse.urljoin(self.request.url,\n                                               self.headers[\"Location\"])\n            new_request.max_redirects = self.request.max_redirects - 1\n            del new_request.headers[\"Host\"]\n            # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4\n            # Client SHOULD make a GET request after a 303.\n            # According to the spec, 302 should be followed by the same\n            # method as the original request, but in practice browsers\n            # treat 302 the same as 303, and many servers use 302 for\n            # compatibility with pre-HTTP/1.1 user agents which don't\n            # understand the 303 status.\n            if self.code in (302, 303):\n                new_request.method = \"GET\"\n                new_request.body = None\n                for h in [\"Content-Length\", \"Content-Type\",\n                          \"Content-Encoding\", \"Transfer-Encoding\"]:\n                    try:\n                        del self.request.headers[h]\n                    except KeyError:\n                        pass\n            new_request.original_request = original_request\n            final_callback = self.final_callback\n            self.final_callback = None\n            self._release()\n            self.client.fetch(new_request, final_callback)\n            self._on_end_request()\n            return\n        if self.request.streaming_callback:\n            buffer = BytesIO()\n        else:\n            buffer = BytesIO(data)  # TODO: don't require one big string?\n        response = HTTPResponse(original_request,\n                                self.code, reason=getattr(self, 'reason', None),\n                                headers=self.headers,\n                                request_time=self.io_loop.time() - self.start_time,\n                                buffer=buffer,\n                                effective_url=self.request.url)\n        self._run_callback(response)\n        self._on_end_request()",
        "begin_line": 469,
        "end_line": 515,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041893590280687055,
            "pseudo_dstar_susp": 0.00046061722708429296,
            "pseudo_tarantula_susp": 0.00041152263374485596,
            "pseudo_op2_susp": 0.00046061722708429296,
            "pseudo_barinel_susp": 0.00041152263374485596
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection._on_end_request#517",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection._on_end_request(self)",
        "snippet": "    def _on_end_request(self):\n        self.stream.close()",
        "begin_line": 517,
        "end_line": 518,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00041649312786339027,
            "pseudo_dstar_susp": 0.0004576659038901602,
            "pseudo_tarantula_susp": 0.0004091653027823241,
            "pseudo_op2_susp": 0.0004576659038901602,
            "pseudo_barinel_susp": 0.0004091653027823241
        }
    },
    {
        "name": "tornado.simple_httpclient._HTTPConnection.data_received#520",
        "src_path": "tornado/simple_httpclient.py",
        "class_name": "tornado.simple_httpclient._HTTPConnection",
        "signature": "tornado.simple_httpclient._HTTPConnection.data_received(self, chunk)",
        "snippet": "    def data_received(self, chunk):\n        if self._should_follow_redirect():\n            # We're going to follow a redirect so just discard the body.\n            return\n        if self.request.streaming_callback is not None:\n            self.request.streaming_callback(chunk)\n        else:\n            self.chunks.append(chunk)",
        "begin_line": 520,
        "end_line": 527,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00042517006802721087,
            "pseudo_dstar_susp": 0.00046533271288971617,
            "pseudo_tarantula_susp": 0.0004182350480970305,
            "pseudo_op2_susp": 0.00046533271288971617,
            "pseudo_barinel_susp": 0.0004182350480970305
        }
    },
    {
        "name": "tornado.escape.xhtml_escape#50",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.xhtml_escape(value)",
        "snippet": "def xhtml_escape(value):\n    \"\"\"Escapes a string so it is valid within HTML or XML.\n\n    Escapes the characters ``<``, ``>``, ``\"``, ``'``, and ``&``.\n    When used in attribute values the escaped strings must be enclosed\n    in quotes.\n\n    .. versionchanged:: 3.2\n\n       Added the single quote to the list of escaped characters.\n    \"\"\"\n    return _XHTML_ESCAPE_RE.sub(lambda match: _XHTML_ESCAPE_DICT[match.group(0)],\n                                to_basestring(value))",
        "begin_line": 50,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014896469536719798,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.escape.xhtml_unescape#65",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.xhtml_unescape(value)",
        "snippet": "def xhtml_unescape(value):\n    \"\"\"Un-escapes an XML-escaped string.\"\"\"\n    return re.sub(r\"&(#?)(\\w+?);\", _convert_entity, _unicode(value))",
        "begin_line": 65,
        "end_line": 67,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.escape.json_encode#73",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.json_encode(value)",
        "snippet": "def json_encode(value):\n    \"\"\"JSON-encodes the given Python object.\"\"\"\n    # JSON permits but does not require forward slashes to be escaped.\n    # This is useful when json data is emitted in a <script> tag\n    # in HTML, as it prevents </script> tags from prematurely terminating\n    # the javascript.  Some json libraries do this escaping by default,\n    # although python's standard library does not, so we do it here.\n    # http://stackoverflow.com/questions/1580647/json-why-are-forward-slashes-escaped\n    return json.dumps(value).replace(\"</\", \"<\\\\/\")",
        "begin_line": 73,
        "end_line": 81,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013935340022296544,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.escape.json_decode#84",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.json_decode(value)",
        "snippet": "def json_decode(value):\n    \"\"\"Returns Python objects for the given JSON string.\"\"\"\n    return json.loads(to_basestring(value))",
        "begin_line": 84,
        "end_line": 86,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00013939224979091162,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.escape.squeeze#89",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.squeeze(value)",
        "snippet": "def squeeze(value):\n    \"\"\"Replace all sequences of whitespace chars with a single space.\"\"\"\n    return re.sub(r\"[\\x00-\\x20]+\", \" \", value).strip()",
        "begin_line": 89,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.escape.url_escape#94",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.url_escape(value, plus=True)",
        "snippet": "def url_escape(value, plus=True):\n    \"\"\"Returns a URL-encoded version of the given value.\n\n    If ``plus`` is true (the default), spaces will be represented\n    as \"+\" instead of \"%20\".  This is appropriate for query strings\n    but not for the path component of a URL.  Note that this default\n    is the reverse of Python's urllib module.\n\n    .. versionadded:: 3.1\n        The ``plus`` argument\n    \"\"\"\n    quote = urllib_parse.quote_plus if plus else urllib_parse.quote\n    return quote(utf8(value))",
        "begin_line": 94,
        "end_line": 106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017295053614666206,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.escape.url_unescape#138",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.url_unescape(value, encoding='utf-8', plus=True)",
        "snippet": "    def url_unescape(value, encoding='utf-8', plus=True):\n        \"\"\"Decodes the given value from a URL.\n\n        The argument may be either a byte or unicode string.\n\n        If encoding is None, the result will be a byte string.  Otherwise,\n        the result is a unicode string in the specified encoding.\n\n        If ``plus`` is true (the default), plus signs will be interpreted\n        as spaces (literal plus signs must be represented as \"%2B\").  This\n        is appropriate for query strings and form-encoded values but not\n        for the path component of a URL.  Note that this default is the\n        reverse of Python's urllib module.\n\n        .. versionadded:: 3.1\n           The ``plus`` argument\n        \"\"\"\n        if encoding is None:\n            if plus:\n                # unquote_to_bytes doesn't have a _plus variant\n                value = to_basestring(value).replace('+', ' ')\n            return urllib_parse.unquote_to_bytes(value)\n        else:\n            unquote = (urllib_parse.unquote_plus if plus\n                       else urllib_parse.unquote)\n            return unquote(to_basestring(value), encoding=encoding)",
        "begin_line": 138,
        "end_line": 163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.escape.parse_qs_bytes#165",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.parse_qs_bytes(qs, keep_blank_values=False, strict_parsing=False)",
        "snippet": "    def parse_qs_bytes(qs, keep_blank_values=False, strict_parsing=False):\n        \"\"\"Parses a query string like urlparse.parse_qs, but returns the\n        values as byte strings.\n\n        Keys still become type str (interpreted as latin1 in python3!)\n        because it's too painful to keep them as byte strings in\n        python3 and in practice they're nearly always ascii anyway.\n        \"\"\"\n        # This is gross, but python3 doesn't give us another way.\n        # Latin1 is the universal donor of character encodings.\n        result = _parse_qs(qs, keep_blank_values, strict_parsing,\n                           encoding='latin1', errors='strict')\n        encoded = {}\n        for k, v in result.items():\n            encoded[k] = [i.encode('latin1') for i in v]\n        return encoded",
        "begin_line": 165,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005208333333333333,
            "pseudo_dstar_susp": 0.0006067961165048543,
            "pseudo_tarantula_susp": 0.0004950495049504951,
            "pseudo_op2_susp": 0.0006067961165048543,
            "pseudo_barinel_susp": 0.0004950495049504951
        }
    },
    {
        "name": "tornado.escape.utf8#186",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.utf8(value)",
        "snippet": "def utf8(value):\n    # type: (typing.Union[bytes,unicode_type,None])->typing.Union[bytes,None]\n    \"\"\"Converts a string argument to a byte string.\n\n    If the argument is already a byte string or None, it is returned unchanged.\n    Otherwise it must be a unicode string and is encoded as utf8.\n    \"\"\"\n    if isinstance(value, _UTF8_TYPES):\n        return value\n    if not isinstance(value, unicode_type):\n        raise TypeError(\n            \"Expected bytes, unicode, or None; got %r\" % type(value)\n        )\n    return value.encode(\"utf-8\")",
        "begin_line": 186,
        "end_line": 199,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008904719501335708,
            "pseudo_dstar_susp": 0.0011363636363636363,
            "pseudo_tarantula_susp": 0.0007215007215007215,
            "pseudo_op2_susp": 0.0011363636363636363,
            "pseudo_barinel_susp": 0.0007215007215007215
        }
    },
    {
        "name": "tornado.escape.to_unicode#205",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.to_unicode(value)",
        "snippet": "def to_unicode(value):\n    \"\"\"Converts a string argument to a unicode string.\n\n    If the argument is already a unicode string or None, it is returned\n    unchanged.  Otherwise it must be a byte string and is decoded as utf8.\n    \"\"\"\n    if isinstance(value, _TO_UNICODE_TYPES):\n        return value\n    if not isinstance(value, bytes):\n        raise TypeError(\n            \"Expected bytes, unicode, or None; got %r\" % type(value)\n        )\n    return value.decode(\"utf-8\")",
        "begin_line": 205,
        "end_line": 217,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011862396204033216,
            "pseudo_dstar_susp": 0.0012919896640826874,
            "pseudo_tarantula_susp": 0.0007886435331230284,
            "pseudo_op2_susp": 0.0012919896640826874,
            "pseudo_barinel_susp": 0.0007886435331230284
        }
    },
    {
        "name": "tornado.escape.to_basestring#234",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.to_basestring(value)",
        "snippet": "def to_basestring(value):\n    \"\"\"Converts a string argument to a subclass of basestring.\n\n    In python2, byte and unicode strings are mostly interchangeable,\n    so functions that deal with a user-supplied argument in combination\n    with ascii string constants can use either and should return the type\n    the user supplied.  In python3, the two types are not interchangeable,\n    so this method is needed to convert byte strings to unicode.\n    \"\"\"\n    if isinstance(value, _BASESTRING_TYPES):\n        return value\n    if not isinstance(value, bytes):\n        raise TypeError(\n            \"Expected bytes, unicode, or None; got %r\" % type(value)\n        )\n    return value.decode(\"utf-8\")",
        "begin_line": 234,
        "end_line": 249,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001491869312248247,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.escape.recursive_unicode#252",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.recursive_unicode(obj)",
        "snippet": "def recursive_unicode(obj):\n    \"\"\"Walks a simple data structure, converting byte strings to unicode.\n\n    Supports lists, tuples, and dictionaries.\n    \"\"\"\n    if isinstance(obj, dict):\n        return dict((recursive_unicode(k), recursive_unicode(v)) for (k, v) in obj.items())\n    elif isinstance(obj, list):\n        return list(recursive_unicode(i) for i in obj)\n    elif isinstance(obj, tuple):\n        return tuple(recursive_unicode(i) for i in obj)\n    elif isinstance(obj, bytes):\n        return to_unicode(obj)\n    else:\n        return obj",
        "begin_line": 252,
        "end_line": 266,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.escape.linkify#281",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.linkify(text, shorten=False, extra_params='', require_protocol=False, permitted_protocols=['http', 'https'])",
        "snippet": "def linkify(text, shorten=False, extra_params=\"\",\n            require_protocol=False, permitted_protocols=[\"http\", \"https\"]):\n    \"\"\"Converts plain text into HTML with links.\n\n    For example: ``linkify(\"Hello http://tornadoweb.org!\")`` would return\n    ``Hello <a href=\"http://tornadoweb.org\">http://tornadoweb.org</a>!``\n\n    Parameters:\n\n    * ``shorten``: Long urls will be shortened for display.\n\n    * ``extra_params``: Extra text to include in the link tag, or a callable\n      taking the link as an argument and returning the extra text\n      e.g. ``linkify(text, extra_params='rel=\"nofollow\" class=\"external\"')``,\n      or::\n\n          def extra_params_cb(url):\n              if url.startswith(\"http://example.com\"):\n                  return 'class=\"internal\"'\n              else:\n                  return 'class=\"external\" rel=\"nofollow\"'\n          linkify(text, extra_params=extra_params_cb)\n\n    * ``require_protocol``: Only linkify urls which include a protocol. If\n      this is False, urls such as www.facebook.com will also be linkified.\n\n    * ``permitted_protocols``: List (or set) of protocols which should be\n      linkified, e.g. ``linkify(text, permitted_protocols=[\"http\", \"ftp\",\n      \"mailto\"])``. It is very unsafe to include protocols such as\n      ``javascript``.\n    \"\"\"\n    if extra_params and not callable(extra_params):\n        extra_params = \" \" + extra_params.strip()\n\n    def make_link(m):\n        url = m.group(1)\n        proto = m.group(2)\n        if require_protocol and not proto:\n            return url  # not protocol, no linkify\n\n        if proto and proto not in permitted_protocols:\n            return url  # bad protocol, no linkify\n\n        href = m.group(1)\n        if not proto:\n            href = \"http://\" + href   # no proto specified, use http\n\n        if callable(extra_params):\n            params = \" \" + extra_params(href).strip()\n        else:\n            params = extra_params\n\n        # clip long urls. max_len is just an approximation\n        max_len = 30\n        if shorten and len(url) > max_len:\n            before_clip = url\n            if proto:\n                proto_len = len(proto) + 1 + len(m.group(3) or \"\")  # +1 for :\n            else:\n                proto_len = 0\n\n            parts = url[proto_len:].split(\"/\")\n            if len(parts) > 1:\n                # Grab the whole host part plus the first bit of the path\n                # The path is usually not that interesting once shortened\n                # (no more slug, etc), so it really just provides a little\n                # extra indication of shortening.\n                url = url[:proto_len] + parts[0] + \"/\" + \\\n                    parts[1][:8].split('?')[0].split('.')[0]\n\n            if len(url) > max_len * 1.5:  # still too long\n                url = url[:max_len]\n\n            if url != before_clip:\n                amp = url.rfind('&')\n                # avoid splitting html char entities\n                if amp > max_len - 5:\n                    url = url[:amp]\n                url += \"...\"\n\n                if len(url) >= len(before_clip):\n                    url = before_clip\n                else:\n                    # full url is visible on mouse-over (for those who don't\n                    # have a status bar, such as Safari by default)\n                    params += ' title=\"%s\"' % href\n\n        return u'<a href=\"%s\"%s>%s</a>' % (href, params, url)\n\n    # First HTML-escape so that our strings are all safe.\n    # The regex is modified to avoid character entites other than &amp; so\n    # that we won't pick up &quot;, etc.\n    text = _unicode(xhtml_escape(text))\n    return _URL_RE.sub(make_link, text)",
        "begin_line": 281,
        "end_line": 374,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.escape.make_link#315",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape.make_link(m)",
        "snippet": "    def make_link(m):\n        url = m.group(1)\n        proto = m.group(2)\n        if require_protocol and not proto:\n            return url  # not protocol, no linkify\n\n        if proto and proto not in permitted_protocols:\n            return url  # bad protocol, no linkify\n\n        href = m.group(1)\n        if not proto:\n            href = \"http://\" + href   # no proto specified, use http\n\n        if callable(extra_params):\n            params = \" \" + extra_params(href).strip()\n        else:\n            params = extra_params\n\n        # clip long urls. max_len is just an approximation\n        max_len = 30\n        if shorten and len(url) > max_len:\n            before_clip = url\n            if proto:\n                proto_len = len(proto) + 1 + len(m.group(3) or \"\")  # +1 for :\n            else:\n                proto_len = 0\n\n            parts = url[proto_len:].split(\"/\")\n            if len(parts) > 1:\n                # Grab the whole host part plus the first bit of the path\n                # The path is usually not that interesting once shortened\n                # (no more slug, etc), so it really just provides a little\n                # extra indication of shortening.\n                url = url[:proto_len] + parts[0] + \"/\" + \\\n                    parts[1][:8].split('?')[0].split('.')[0]\n\n            if len(url) > max_len * 1.5:  # still too long\n                url = url[:max_len]\n\n            if url != before_clip:\n                amp = url.rfind('&')\n                # avoid splitting html char entities\n                if amp > max_len - 5:\n                    url = url[:amp]\n                url += \"...\"\n\n                if len(url) >= len(before_clip):\n                    url = before_clip\n                else:\n                    # full url is visible on mouse-over (for those who don't\n                    # have a status bar, such as Safari by default)\n                    params += ' title=\"%s\"' % href\n\n        return u'<a href=\"%s\"%s>%s</a>' % (href, params, url)",
        "begin_line": 315,
        "end_line": 368,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.escape._convert_entity#377",
        "src_path": "tornado/escape.py",
        "class_name": "tornado.escape",
        "signature": "tornado.escape._convert_entity(m)",
        "snippet": "def _convert_entity(m):\n    if m.group(1) == \"#\":\n        try:\n            if m.group(2)[:1].lower() == 'x':\n                return unichr(int(m.group(2)[1:], 16))\n            else:\n                return unichr(int(m.group(2)))\n        except ValueError:\n            return \"&#%s;\" % m.group(2)\n    try:\n        return _HTML_UNICODE_MAP[m.group(2)]\n    except KeyError:\n        return \"&%s;\" % m.group(2)",
        "begin_line": 377,
        "end_line": 389,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues._set_timeout#50",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues",
        "signature": "tornado.queues._set_timeout(future, timeout)",
        "snippet": "def _set_timeout(future, timeout):\n    if timeout:\n        def on_timeout():\n            if not future.done():\n                future.set_exception(gen.TimeoutError())\n        io_loop = ioloop.IOLoop.current()\n        timeout_handle = io_loop.add_timeout(timeout, on_timeout)\n        future.add_done_callback(\n            lambda _: io_loop.remove_timeout(timeout_handle))",
        "begin_line": 50,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001836884643644379,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.on_timeout#52",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues",
        "signature": "tornado.queues.on_timeout()",
        "snippet": "        def on_timeout():\n            if not future.done():\n                future.set_exception(gen.TimeoutError())",
        "begin_line": 52,
        "end_line": 54,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues._QueueIterator.__init__#62",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues._QueueIterator",
        "signature": "tornado.queues._QueueIterator.__init__(self, q)",
        "snippet": "    def __init__(self, q):\n        self.q = q",
        "begin_line": 62,
        "end_line": 63,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues._QueueIterator.__anext__#65",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues._QueueIterator",
        "signature": "tornado.queues._QueueIterator.__anext__(self)",
        "snippet": "    def __anext__(self):\n        return self.q.get()",
        "begin_line": 65,
        "end_line": 66,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.Queue.__init__#137",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.__init__(self, maxsize=0)",
        "snippet": "    def __init__(self, maxsize=0):\n        if maxsize is None:\n            raise TypeError(\"maxsize can't be None\")\n\n        if maxsize < 0:\n            raise ValueError(\"maxsize can't be negative\")\n\n        self._maxsize = maxsize\n        self._init()\n        self._getters = collections.deque([])  # Futures.\n        self._putters = collections.deque([])  # Pairs of (item, Future).\n        self._unfinished_tasks = 0\n        self._finished = Event()\n        self._finished.set()",
        "begin_line": 137,
        "end_line": 150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005414185165132648,
            "pseudo_dstar_susp": 0.0004329004329004329,
            "pseudo_tarantula_susp": 0.0006954102920723226,
            "pseudo_op2_susp": 0.0004329004329004329,
            "pseudo_barinel_susp": 0.0006954102920723226
        }
    },
    {
        "name": "tornado.queues.Queue.maxsize#153",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.maxsize(self)",
        "snippet": "    def maxsize(self):\n        \"\"\"Number of items allowed in the queue.\"\"\"\n        return self._maxsize",
        "begin_line": 153,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001491869312248247,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.Queue.qsize#157",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.qsize(self)",
        "snippet": "    def qsize(self):\n        \"\"\"Number of items in the queue.\"\"\"\n        return len(self._queue)",
        "begin_line": 157,
        "end_line": 159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001483459427384661,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.Queue.empty#161",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.empty(self)",
        "snippet": "    def empty(self):\n        return not self._queue",
        "begin_line": 161,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017528483786152498,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.Queue.full#164",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.full(self)",
        "snippet": "    def full(self):\n        if self.maxsize == 0:\n            return False\n        else:\n            return self.qsize() >= self.maxsize",
        "begin_line": 164,
        "end_line": 168,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017409470752089137,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.Queue.put#170",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.put(self, item, timeout=None)",
        "snippet": "    def put(self, item, timeout=None):\n        \"\"\"Put an item into the queue, perhaps waiting until there is room.\n\n        Returns a Future, which raises `tornado.util.TimeoutError` after a\n        timeout.\n\n        ``timeout`` may be a number denoting a time (on the same\n        scale as `tornado.ioloop.IOLoop.time`, normally `time.time`), or a\n        `datetime.timedelta` object for a deadline relative to the\n        current time.\n        \"\"\"\n        future = Future()\n        try:\n            self.put_nowait(item)\n        except QueueFull:\n            self._putters.append((item, future))\n            _set_timeout(future, timeout)\n        else:\n            future.set_result(None)\n        return future",
        "begin_line": 170,
        "end_line": 189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017528483786152498,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.Queue.put_nowait#191",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.put_nowait(self, item)",
        "snippet": "    def put_nowait(self, item):\n        \"\"\"Put an item into the queue without blocking.\n\n        If no free slot is immediately available, raise `QueueFull`.\n        \"\"\"\n        self._consume_expired()\n        if self._getters:\n            assert self.empty(), \"queue non-empty, why are getters waiting?\"\n            getter = self._getters.popleft()\n            self.__put_internal(item)\n            future_set_result_unless_cancelled(getter, self._get())\n        elif self.full():\n            raise QueueFull\n        else:\n            self.__put_internal(item)",
        "begin_line": 191,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001885369532428356,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.Queue.get#207",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.get(self, timeout=None)",
        "snippet": "    def get(self, timeout=None):\n        \"\"\"Remove and return an item from the queue.\n\n        Returns a Future which resolves once an item is available, or raises\n        `tornado.util.TimeoutError` after a timeout.\n\n        ``timeout`` may be a number denoting a time (on the same\n        scale as `tornado.ioloop.IOLoop.time`, normally `time.time`), or a\n        `datetime.timedelta` object for a deadline relative to the\n        current time.\n        \"\"\"\n        future = Future()\n        try:\n            future.set_result(self.get_nowait())\n        except QueueEmpty:\n            self._getters.append(future)\n            _set_timeout(future, timeout)\n        return future",
        "begin_line": 207,
        "end_line": 224,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001836884643644379,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.Queue.get_nowait#226",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.get_nowait(self)",
        "snippet": "    def get_nowait(self):\n        \"\"\"Remove and return an item from the queue without blocking.\n\n        Return an item if one is immediately available, else raise\n        `QueueEmpty`.\n        \"\"\"\n        self._consume_expired()\n        if self._putters:\n            assert self.full(), \"queue not full, why are putters waiting?\"\n            item, putter = self._putters.popleft()\n            self.__put_internal(item)\n            future_set_result_unless_cancelled(putter, None)\n            return self._get()\n        elif self.qsize():\n            return self._get()\n        else:\n            raise QueueEmpty",
        "begin_line": 226,
        "end_line": 242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00018018018018018018,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.Queue.task_done#244",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.task_done(self)",
        "snippet": "    def task_done(self):\n        \"\"\"Indicate that a formerly enqueued task is complete.\n\n        Used by queue consumers. For each `.get` used to fetch a task, a\n        subsequent call to `.task_done` tells the queue that the processing\n        on the task is complete.\n\n        If a `.join` is blocking, it resumes when all items have been\n        processed; that is, when every `.put` is matched by a `.task_done`.\n\n        Raises `ValueError` if called more times than `.put`.\n        \"\"\"\n        if self._unfinished_tasks <= 0:\n            raise ValueError('task_done() called too many times')\n        self._unfinished_tasks -= 1\n        if self._unfinished_tasks == 0:\n            self._finished.set()",
        "begin_line": 244,
        "end_line": 260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.Queue.join#262",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.join(self, timeout=None)",
        "snippet": "    def join(self, timeout=None):\n        \"\"\"Block until all items in the queue are processed.\n\n        Returns a Future, which raises `tornado.util.TimeoutError` after a\n        timeout.\n        \"\"\"\n        return self._finished.wait(timeout)",
        "begin_line": 262,
        "end_line": 268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017409470752089137,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.Queue.__aiter__#270",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.__aiter__(self)",
        "snippet": "    def __aiter__(self):\n        return _QueueIterator(self)",
        "begin_line": 270,
        "end_line": 271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.Queue._init#274",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue._init(self)",
        "snippet": "    def _init(self):\n        self._queue = collections.deque()",
        "begin_line": 274,
        "end_line": 275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005577244841048522,
            "pseudo_dstar_susp": 0.0004347826086956522,
            "pseudo_tarantula_susp": 0.0008920606601248885,
            "pseudo_op2_susp": 0.0004347826086956522,
            "pseudo_barinel_susp": 0.0008920606601248885
        }
    },
    {
        "name": "tornado.queues.Queue._get#277",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue._get(self)",
        "snippet": "    def _get(self):\n        return self._queue.popleft()",
        "begin_line": 277,
        "end_line": 278,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015422578655151142,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.Queue._put#280",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue._put(self, item)",
        "snippet": "    def _put(self, item):\n        self._queue.append(item)",
        "begin_line": 280,
        "end_line": 281,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015158405335758679,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.Queue.__put_internal#284",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.__put_internal(self, item)",
        "snippet": "    def __put_internal(self, item):\n        self._unfinished_tasks += 1\n        self._finished.clear()\n        self._put(item)",
        "begin_line": 284,
        "end_line": 287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014803849000740192,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.Queue._consume_expired#289",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue._consume_expired(self)",
        "snippet": "    def _consume_expired(self):\n        # Remove timed-out waiters.\n        while self._putters and self._putters[0][1].done():\n            self._putters.popleft()\n\n        while self._getters and self._getters[0].done():\n            self._getters.popleft()",
        "begin_line": 289,
        "end_line": 295,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.Queue.__repr__#297",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return '<%s at %s %s>' % (\n            type(self).__name__, hex(id(self)), self._format())",
        "begin_line": 297,
        "end_line": 299,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.Queue.__str__#301",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue.__str__(self)",
        "snippet": "    def __str__(self):\n        return '<%s %s>' % (type(self).__name__, self._format())",
        "begin_line": 301,
        "end_line": 302,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.Queue._format#304",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.Queue",
        "signature": "tornado.queues.Queue._format(self)",
        "snippet": "    def _format(self):\n        result = 'maxsize=%r' % (self.maxsize, )\n        if getattr(self, '_queue', None):\n            result += ' queue=%r' % self._queue\n        if self._getters:\n            result += ' getters[%s]' % len(self._getters)\n        if self._putters:\n            result += ' putters[%s]' % len(self._putters)\n        if self._unfinished_tasks:\n            result += ' tasks=%s' % self._unfinished_tasks\n        return result",
        "begin_line": 304,
        "end_line": 314,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.PriorityQueue._init#341",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.PriorityQueue",
        "signature": "tornado.queues.PriorityQueue._init(self)",
        "snippet": "    def _init(self):\n        self._queue = []",
        "begin_line": 341,
        "end_line": 342,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.PriorityQueue._put#344",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.PriorityQueue",
        "signature": "tornado.queues.PriorityQueue._put(self, item)",
        "snippet": "    def _put(self, item):\n        heapq.heappush(self._queue, item)",
        "begin_line": 344,
        "end_line": 345,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.PriorityQueue._get#347",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.PriorityQueue",
        "signature": "tornado.queues.PriorityQueue._get(self)",
        "snippet": "    def _get(self):\n        return heapq.heappop(self._queue)",
        "begin_line": 347,
        "end_line": 348,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.LifoQueue._init#373",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.LifoQueue",
        "signature": "tornado.queues.LifoQueue._init(self)",
        "snippet": "    def _init(self):\n        self._queue = []",
        "begin_line": 373,
        "end_line": 374,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.LifoQueue._put#376",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.LifoQueue",
        "signature": "tornado.queues.LifoQueue._put(self, item)",
        "snippet": "    def _put(self, item):\n        self._queue.append(item)",
        "begin_line": 376,
        "end_line": 377,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.queues.LifoQueue._get#379",
        "src_path": "tornado/queues.py",
        "class_name": "tornado.queues.LifoQueue",
        "signature": "tornado.queues.LifoQueue._get(self)",
        "snippet": "    def _get(self):\n        return self._queue.pop()",
        "begin_line": 379,
        "end_line": 380,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.iostream.StreamClosedError.__init__#101",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.StreamClosedError",
        "signature": "tornado.iostream.StreamClosedError.__init__(self, real_error=None)",
        "snippet": "    def __init__(self, real_error=None):\n        super(StreamClosedError, self).__init__('Stream is closed')\n        self.real_error = real_error",
        "begin_line": 101,
        "end_line": 103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00048449612403100775,
            "pseudo_dstar_susp": 0.000564652738565782,
            "pseudo_tarantula_susp": 0.00047214353163361664,
            "pseudo_op2_susp": 0.000564652738565782,
            "pseudo_barinel_susp": 0.00047214353163361664
        }
    },
    {
        "name": "tornado.iostream._StreamBuffer.__init__#126",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream._StreamBuffer",
        "signature": "tornado.iostream._StreamBuffer.__init__(self)",
        "snippet": "    def __init__(self):\n        # A sequence of (False, bytearray) and (True, memoryview) objects\n        self._buffers = collections.deque()\n        # Position in the first buffer\n        self._first_pos = 0\n        self._size = 0",
        "begin_line": 126,
        "end_line": 131,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004,
            "pseudo_dstar_susp": 0.0048543689320388345,
            "pseudo_tarantula_susp": 0.002028397565922921,
            "pseudo_op2_susp": 0.0048543689320388345,
            "pseudo_barinel_susp": 0.002028397565922921
        }
    },
    {
        "name": "tornado.iostream._StreamBuffer.__len__#133",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream._StreamBuffer",
        "signature": "tornado.iostream._StreamBuffer.__len__(self)",
        "snippet": "    def __len__(self):\n        return self._size",
        "begin_line": 133,
        "end_line": 134,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00392156862745098,
            "pseudo_dstar_susp": 0.0043859649122807015,
            "pseudo_tarantula_susp": 0.002242152466367713,
            "pseudo_op2_susp": 0.0043859649122807015,
            "pseudo_barinel_susp": 0.002242152466367713
        }
    },
    {
        "name": "tornado.iostream._StreamBuffer.append#140",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream._StreamBuffer",
        "signature": "tornado.iostream._StreamBuffer.append(self, data)",
        "snippet": "    def append(self, data):\n        \"\"\"\n        Append the given piece of data (should be a buffer-compatible object).\n        \"\"\"\n        size = len(data)\n        if size > self._large_buf_threshold:\n            if not isinstance(data, memoryview):\n                data = memoryview(data)\n            self._buffers.append((True, data))\n        elif size > 0:\n            if self._buffers:\n                is_memview, b = self._buffers[-1]\n                new_buf = is_memview or len(b) >= self._large_buf_threshold\n            else:\n                new_buf = True\n            if new_buf:\n                self._buffers.append((False, bytearray(data)))\n            else:\n                b += data\n\n        self._size += size",
        "begin_line": 140,
        "end_line": 160,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008291873963515755,
            "pseudo_dstar_susp": 0.0008904719501335708,
            "pseudo_tarantula_susp": 0.003194888178913738,
            "pseudo_op2_susp": 0.0008904719501335708,
            "pseudo_barinel_susp": 0.003194888178913738
        }
    },
    {
        "name": "tornado.iostream._StreamBuffer.peek#162",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream._StreamBuffer",
        "signature": "tornado.iostream._StreamBuffer.peek(self, size)",
        "snippet": "    def peek(self, size):\n        \"\"\"\n        Get a view over at most ``size`` bytes (possibly fewer) at the\n        current buffer position.\n        \"\"\"\n        assert size > 0\n        try:\n            is_memview, b = self._buffers[0]\n        except IndexError:\n            return memoryview(b'')\n\n        pos = self._first_pos\n        if is_memview:\n            return b[pos:pos + size]\n        else:\n            return memoryview(b)[pos:pos + size]",
        "begin_line": 162,
        "end_line": 177,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008291873963515755,
            "pseudo_dstar_susp": 0.0008620689655172414,
            "pseudo_tarantula_susp": 0.003194888178913738,
            "pseudo_op2_susp": 0.0008620689655172414,
            "pseudo_barinel_susp": 0.003194888178913738
        }
    },
    {
        "name": "tornado.iostream._StreamBuffer.advance#179",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream._StreamBuffer",
        "signature": "tornado.iostream._StreamBuffer.advance(self, size)",
        "snippet": "    def advance(self, size):\n        \"\"\"\n        Advance the current buffer position by ``size`` bytes.\n        \"\"\"\n        assert 0 < size <= self._size\n        self._size -= size\n        pos = self._first_pos\n\n        buffers = self._buffers\n        while buffers and size > 0:\n            is_large, b = buffers[0]\n            b_remain = len(b) - size - pos\n            if b_remain <= 0:\n                buffers.popleft()\n                size -= len(b) - pos\n                pos = 0\n            elif is_large:\n                pos += size\n                size = 0\n            else:\n                # Amortized O(1) shrink for Python 2\n                pos += size\n                if len(b) <= 2 * pos:\n                    del b[:pos]\n                    pos = 0\n                size = 0\n\n        assert size == 0\n        self._first_pos = pos",
        "begin_line": 179,
        "end_line": 207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007485029940119761,
            "pseudo_dstar_susp": 0.0008389261744966443,
            "pseudo_tarantula_susp": 0.0006365372374283895,
            "pseudo_op2_susp": 0.0008389261744966443,
            "pseudo_barinel_susp": 0.0006365372374283895
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.__init__#228",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.__init__(self, max_buffer_size=None, read_chunk_size=None, max_write_buffer_size=None)",
        "snippet": "    def __init__(self, max_buffer_size=None,\n                 read_chunk_size=None, max_write_buffer_size=None):\n        \"\"\"`BaseIOStream` constructor.\n\n        :arg max_buffer_size: Maximum amount of incoming data to buffer;\n            defaults to 100MB.\n        :arg read_chunk_size: Amount of data to read at one time from the\n            underlying transport; defaults to 64KB.\n        :arg max_write_buffer_size: Amount of outgoing data to buffer;\n            defaults to unlimited.\n\n        .. versionchanged:: 4.0\n           Add the ``max_write_buffer_size`` parameter.  Changed default\n           ``read_chunk_size`` to 64KB.\n        .. versionchanged:: 5.0\n           The ``io_loop`` argument (deprecated since version 4.1) has been\n           removed.\n        \"\"\"\n        self.io_loop = ioloop.IOLoop.current()\n        self.max_buffer_size = max_buffer_size or 104857600\n        # A chunk size that is too close to max_buffer_size can cause\n        # spurious failures.\n        self.read_chunk_size = min(read_chunk_size or 65536,\n                                   self.max_buffer_size // 2)\n        self.max_write_buffer_size = max_write_buffer_size\n        self.error = None\n        self._read_buffer = bytearray()\n        self._read_buffer_pos = 0\n        self._read_buffer_size = 0\n        self._user_read_buffer = False\n        self._after_user_read_buffer = None\n        self._write_buffer = _StreamBuffer()\n        self._total_write_index = 0\n        self._total_write_done_index = 0\n        self._read_delimiter = None\n        self._read_regex = None\n        self._read_max_bytes = None\n        self._read_bytes = None\n        self._read_partial = False\n        self._read_until_close = False\n        self._read_callback = None\n        self._read_future = None\n        self._streaming_callback = None\n        self._write_callback = None\n        self._write_futures = collections.deque()\n        self._close_callback = None\n        self._connect_callback = None\n        self._connect_future = None\n        # _ssl_connect_future should be defined in SSLIOStream\n        # but it's here so we can clean it up in maybe_run_close_callback.\n        # TODO: refactor that so subclasses can add additional futures\n        # to be cancelled.\n        self._ssl_connect_future = None\n        self._connecting = False\n        self._state = None\n        self._pending_callbacks = 0\n        self._closed = False",
        "begin_line": 228,
        "end_line": 284,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004464285714285714,
            "pseudo_dstar_susp": 0.0053475935828877,
            "pseudo_tarantula_susp": 0.0021551724137931034,
            "pseudo_op2_susp": 0.0053475935828877,
            "pseudo_barinel_susp": 0.0021551724137931034
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.read_until_regex#330",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.read_until_regex(self, regex, callback=None, max_bytes=None)",
        "snippet": "    def read_until_regex(self, regex, callback=None, max_bytes=None):\n        \"\"\"Asynchronously read until we have matched the given regex.\n\n        The result includes the data that matches the regex and anything\n        that came before it.  If a callback is given, it will be run\n        with the data as an argument; if not, this method returns a\n        `.Future`.\n\n        If ``max_bytes`` is not None, the connection will be closed\n        if more than ``max_bytes`` bytes have been read and the regex is\n        not satisfied.\n\n        .. versionchanged:: 4.0\n            Added the ``max_bytes`` argument.  The ``callback`` argument is\n            now optional and a `.Future` will be returned if it is omitted.\n        \"\"\"\n        future = self._set_read_callback(callback)\n        self._read_regex = re.compile(regex)\n        self._read_max_bytes = max_bytes\n        try:\n            self._try_inline_read()\n        except UnsatisfiableReadError as e:\n            # Handle this the same way as in _handle_events.\n            gen_log.info(\"Unsatisfiable read, closing connection: %s\" % e)\n            self.close(exc_info=e)\n            return future\n        except:\n            if future is not None:\n                # Ensure that the future doesn't log an error because its\n                # failure was never examined.\n                future.add_done_callback(lambda f: f.exception())\n            raise\n        return future",
        "begin_line": 330,
        "end_line": 362,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011668611435239206,
            "pseudo_dstar_susp": 0.0007855459544383347,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.0007855459544383347,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.read_until#364",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.read_until(self, delimiter, callback=None, max_bytes=None)",
        "snippet": "    def read_until(self, delimiter, callback=None, max_bytes=None):\n        \"\"\"Asynchronously read until we have found the given delimiter.\n\n        The result includes all the data read including the delimiter.\n        If a callback is given, it will be run with the data as an argument;\n        if not, this method returns a `.Future`.\n\n        If ``max_bytes`` is not None, the connection will be closed\n        if more than ``max_bytes`` bytes have been read and the delimiter\n        is not found.\n\n        .. versionchanged:: 4.0\n            Added the ``max_bytes`` argument.  The ``callback`` argument is\n            now optional and a `.Future` will be returned if it is omitted.\n        \"\"\"\n        future = self._set_read_callback(callback)\n        self._read_delimiter = delimiter\n        self._read_max_bytes = max_bytes\n        try:\n            self._try_inline_read()\n        except UnsatisfiableReadError as e:\n            # Handle this the same way as in _handle_events.\n            gen_log.info(\"Unsatisfiable read, closing connection: %s\" % e)\n            self.close(exc_info=e)\n            return future\n        except:\n            if future is not None:\n                future.add_done_callback(lambda f: f.exception())\n            raise\n        return future",
        "begin_line": 364,
        "end_line": 393,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011668611435239206,
            "pseudo_dstar_susp": 0.000591715976331361,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.000591715976331361,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.read_bytes#395",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.read_bytes(self, num_bytes, callback=None, streaming_callback=None, partial=False)",
        "snippet": "    def read_bytes(self, num_bytes, callback=None, streaming_callback=None,\n                   partial=False):\n        \"\"\"Asynchronously read a number of bytes.\n\n        If a ``streaming_callback`` is given, it will be called with chunks\n        of data as they become available, and the final result will be empty.\n        Otherwise, the result is all the data that was read.\n        If a callback is given, it will be run with the data as an argument;\n        if not, this method returns a `.Future`.\n\n        If ``partial`` is true, the callback is run as soon as we have\n        any bytes to return (but never more than ``num_bytes``)\n\n        .. versionchanged:: 4.0\n            Added the ``partial`` argument.  The callback argument is now\n            optional and a `.Future` will be returned if it is omitted.\n        \"\"\"\n        future = self._set_read_callback(callback)\n        assert isinstance(num_bytes, numbers.Integral)\n        self._read_bytes = num_bytes\n        self._read_partial = partial\n        self._streaming_callback = stack_context.wrap(streaming_callback)\n        try:\n            self._try_inline_read()\n        except:\n            if future is not None:\n                future.add_done_callback(lambda f: f.exception())\n            raise\n        return future",
        "begin_line": 395,
        "end_line": 423,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003883495145631068,
            "pseudo_dstar_susp": 0.0004065040650406504,
            "pseudo_tarantula_susp": 0.00038714672861014324,
            "pseudo_op2_susp": 0.0004065040650406504,
            "pseudo_barinel_susp": 0.00038714672861014324
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.read_into#425",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.read_into(self, buf, callback=None, partial=False)",
        "snippet": "    def read_into(self, buf, callback=None, partial=False):\n        \"\"\"Asynchronously read a number of bytes.\n\n        ``buf`` must be a writable buffer into which data will be read.\n        If a callback is given, it will be run with the number of read\n        bytes as an argument; if not, this method returns a `.Future`.\n\n        If ``partial`` is true, the callback is run as soon as any bytes\n        have been read.  Otherwise, it is run when the ``buf`` has been\n        entirely filled with read data.\n\n        .. versionadded:: 5.0\n        \"\"\"\n        future = self._set_read_callback(callback)\n\n        # First copy data already in read buffer\n        available_bytes = self._read_buffer_size\n        n = len(buf)\n        if available_bytes >= n:\n            end = self._read_buffer_pos + n\n            buf[:] = memoryview(self._read_buffer)[self._read_buffer_pos:end]\n            del self._read_buffer[:end]\n            self._after_user_read_buffer = self._read_buffer\n        elif available_bytes > 0:\n            buf[:available_bytes] = memoryview(self._read_buffer)[self._read_buffer_pos:]\n\n        # Set up the supplied buffer as our temporary read buffer.\n        # The original (if it had any data remaining) has been\n        # saved for later.\n        self._user_read_buffer = True\n        self._read_buffer = buf\n        self._read_buffer_pos = 0\n        self._read_buffer_size = available_bytes\n        self._read_bytes = n\n        self._read_partial = partial\n\n        try:\n            self._try_inline_read()\n        except:\n            if future is not None:\n                future.add_done_callback(lambda f: f.exception())\n            raise\n        return future",
        "begin_line": 425,
        "end_line": 467,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.read_until_close#469",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.read_until_close(self, callback=None, streaming_callback=None)",
        "snippet": "    def read_until_close(self, callback=None, streaming_callback=None):\n        \"\"\"Asynchronously reads all data from the socket until it is closed.\n\n        If a ``streaming_callback`` is given, it will be called with chunks\n        of data as they become available, and the final result will be empty.\n        Otherwise, the result is all the data that was read.\n        If a callback is given, it will be run with the data as an argument;\n        if not, this method returns a `.Future`.\n\n        Note that if a ``streaming_callback`` is used, data will be\n        read from the socket as quickly as it becomes available; there\n        is no way to apply backpressure or cancel the reads. If flow\n        control or cancellation are desired, use a loop with\n        `read_bytes(partial=True) <.read_bytes>` instead.\n\n        .. versionchanged:: 4.0\n            The callback argument is now optional and a `.Future` will\n            be returned if it is omitted.\n\n        \"\"\"\n        future = self._set_read_callback(callback)\n        self._streaming_callback = stack_context.wrap(streaming_callback)\n        if self.closed():\n            if self._streaming_callback is not None:\n                self._run_read_callback(self._read_buffer_size, True)\n            self._run_read_callback(self._read_buffer_size, False)\n            return future\n        self._read_until_close = True\n        try:\n            self._try_inline_read()\n        except:\n            if future is not None:\n                future.add_done_callback(lambda f: f.exception())\n            raise\n        return future",
        "begin_line": 469,
        "end_line": 503,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008764241893076249,
            "pseudo_dstar_susp": 0.000594883997620464,
            "pseudo_tarantula_susp": 0.004219409282700422,
            "pseudo_op2_susp": 0.000594883997620464,
            "pseudo_barinel_susp": 0.004219409282700422
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.write#505",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.write(self, data, callback=None)",
        "snippet": "    def write(self, data, callback=None):\n        \"\"\"Asynchronously write the given data to this stream.\n\n        If ``callback`` is given, we call it when all of the buffered write\n        data has been successfully written to the stream. If there was\n        previously buffered write data and an old write callback, that\n        callback is simply overwritten with this new callback.\n\n        If no ``callback`` is given, this method returns a `.Future` that\n        resolves (with a result of ``None``) when the write has been\n        completed.\n\n        The ``data`` argument may be of type `bytes` or `memoryview`.\n\n        .. versionchanged:: 4.0\n            Now returns a `.Future` if no callback is given.\n\n        .. versionchanged:: 4.5\n            Added support for `memoryview` arguments.\n        \"\"\"\n        self._check_closed()\n        if data:\n            if (self.max_write_buffer_size is not None and\n                    len(self._write_buffer) + len(data) > self.max_write_buffer_size):\n                raise StreamBufferFullError(\"Reached maximum write buffer size\")\n            self._write_buffer.append(data)\n            self._total_write_index += len(data)\n        if callback is not None:\n            self._write_callback = stack_context.wrap(callback)\n            future = None\n        else:\n            future = Future()\n            future.add_done_callback(lambda f: f.exception())\n            self._write_futures.append((self._total_write_index, future))\n        if not self._connecting:\n            self._handle_write()\n            if self._write_buffer:\n                self._add_io_state(self.io_loop.WRITE)\n            self._maybe_add_error_listener()\n        return future",
        "begin_line": 505,
        "end_line": 544,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008403361344537816,
            "pseudo_dstar_susp": 0.0012804097311139564,
            "pseudo_tarantula_susp": 0.0008920606601248885,
            "pseudo_op2_susp": 0.0012804097311139564,
            "pseudo_barinel_susp": 0.0008920606601248885
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.set_close_callback#546",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.set_close_callback(self, callback)",
        "snippet": "    def set_close_callback(self, callback):\n        \"\"\"Call the given callback when the stream is closed.\n\n        This is not necessary for applications that use the `.Future`\n        interface; all outstanding ``Futures`` will resolve with a\n        `StreamClosedError` when the stream is closed.\n        \"\"\"\n        self._close_callback = stack_context.wrap(callback)\n        self._maybe_add_error_listener()",
        "begin_line": 546,
        "end_line": 554,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007911392405063291,
            "pseudo_dstar_susp": 0.0008673026886383347,
            "pseudo_tarantula_susp": 0.0006743088334457181,
            "pseudo_op2_susp": 0.0008673026886383347,
            "pseudo_barinel_susp": 0.0006743088334457181
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.close#556",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.close(self, exc_info=False)",
        "snippet": "    def close(self, exc_info=False):\n        \"\"\"Close this stream.\n\n        If ``exc_info`` is true, set the ``error`` attribute to the current\n        exception from `sys.exc_info` (or if ``exc_info`` is a tuple,\n        use that instead of `sys.exc_info`).\n        \"\"\"\n        if not self.closed():\n            if exc_info:\n                if isinstance(exc_info, tuple):\n                    self.error = exc_info[1]\n                elif isinstance(exc_info, BaseException):\n                    self.error = exc_info\n                else:\n                    exc_info = sys.exc_info()\n                    if any(exc_info):\n                        self.error = exc_info[1]\n            if self._read_until_close:\n                if (self._streaming_callback is not None and\n                        self._read_buffer_size):\n                    self._run_read_callback(self._read_buffer_size, True)\n                self._read_until_close = False\n                self._run_read_callback(self._read_buffer_size, False)\n            if self._state is not None:\n                self.io_loop.remove_handler(self.fileno())\n                self._state = None\n            self.close_fd()\n            self._closed = True\n        self._maybe_run_close_callback()",
        "begin_line": 556,
        "end_line": 584,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002036659877800407,
            "pseudo_dstar_susp": 0.0009182736455463728,
            "pseudo_tarantula_susp": 0.004901960784313725,
            "pseudo_op2_susp": 0.0009182736455463728,
            "pseudo_barinel_susp": 0.004901960784313725
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._maybe_run_close_callback#586",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._maybe_run_close_callback(self)",
        "snippet": "    def _maybe_run_close_callback(self):\n        # If there are pending callbacks, don't run the close callback\n        # until they're done (see _maybe_add_error_handler)\n        if self.closed() and self._pending_callbacks == 0:\n            futures = []\n            if self._read_future is not None:\n                futures.append(self._read_future)\n                self._read_future = None\n            futures += [future for _, future in self._write_futures]\n            self._write_futures.clear()\n            if self._connect_future is not None:\n                futures.append(self._connect_future)\n                self._connect_future = None\n            if self._ssl_connect_future is not None:\n                futures.append(self._ssl_connect_future)\n                self._ssl_connect_future = None\n            for future in futures:\n                future.set_exception(StreamClosedError(real_error=self.error))\n                future.exception()\n            if self._close_callback is not None:\n                cb = self._close_callback\n                self._close_callback = None\n                self._run_callback(cb)\n            # Delete any unfinished callbacks to break up reference cycles.\n            self._read_callback = self._write_callback = None\n            # Clear the buffers so they can be cleared immediately even\n            # if the IOStream object is kept alive by a reference cycle.\n            # TODO: Clear the read buffer too; it currently breaks some tests.\n            self._write_buffer = None",
        "begin_line": 586,
        "end_line": 614,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008658008658008658,
            "pseudo_dstar_susp": 0.0013175230566534915,
            "pseudo_tarantula_susp": 0.0024752475247524753,
            "pseudo_op2_susp": 0.0013175230566534915,
            "pseudo_barinel_susp": 0.0024752475247524753
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.reading#616",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.reading(self)",
        "snippet": "    def reading(self):\n        \"\"\"Returns true if we are currently reading from the stream.\"\"\"\n        return self._read_callback is not None or self._read_future is not None",
        "begin_line": 616,
        "end_line": 618,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015060240963855422,
            "pseudo_dstar_susp": 0.0019646365422396855,
            "pseudo_tarantula_susp": 0.001037344398340249,
            "pseudo_op2_susp": 0.0019646365422396855,
            "pseudo_barinel_susp": 0.001037344398340249
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.writing#620",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.writing(self)",
        "snippet": "    def writing(self):\n        \"\"\"Returns true if we are currently writing to the stream.\"\"\"\n        return bool(self._write_buffer)",
        "begin_line": 620,
        "end_line": 622,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0036363636363636364,
            "pseudo_dstar_susp": 0.00398406374501992,
            "pseudo_tarantula_susp": 0.002,
            "pseudo_op2_susp": 0.00398406374501992,
            "pseudo_barinel_susp": 0.002
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.closed#624",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.closed(self)",
        "snippet": "    def closed(self):\n        \"\"\"Returns true if the stream has been closed.\"\"\"\n        return self._closed",
        "begin_line": 624,
        "end_line": 626,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003952569169960474,
            "pseudo_dstar_susp": 0.004629629629629629,
            "pseudo_tarantula_susp": 0.00196078431372549,
            "pseudo_op2_susp": 0.004629629629629629,
            "pseudo_barinel_susp": 0.00196078431372549
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._handle_events#643",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._handle_events(self, fd, events)",
        "snippet": "    def _handle_events(self, fd, events):\n        if self.closed():\n            gen_log.warning(\"Got events for closed stream %s\", fd)\n            return\n        try:\n            if self._connecting:\n                # Most IOLoops will report a write failed connect\n                # with the WRITE event, but SelectIOLoop reports a\n                # READ as well so we must check for connecting before\n                # either.\n                self._handle_connect()\n            if self.closed():\n                return\n            if events & self.io_loop.READ:\n                self._handle_read()\n            if self.closed():\n                return\n            if events & self.io_loop.WRITE:\n                self._handle_write()\n            if self.closed():\n                return\n            if events & self.io_loop.ERROR:\n                self.error = self.get_fd_error()\n                # We may have queued up a user callback in _handle_read or\n                # _handle_write, so don't close the IOStream until those\n                # callbacks have had a chance to run.\n                self.io_loop.add_callback(self.close)\n                return\n            state = self.io_loop.ERROR\n            if self.reading():\n                state |= self.io_loop.READ\n            if self.writing():\n                state |= self.io_loop.WRITE\n            if state == self.io_loop.ERROR and self._read_buffer_size == 0:\n                # If the connection is idle, listen for reads too so\n                # we can tell if the connection is closed.  If there is\n                # data in the read buffer we won't run the close callback\n                # yet anyway, so we don't need to listen in this case.\n                state |= self.io_loop.READ\n            if state != self._state:\n                assert self._state is not None, \\\n                    \"shouldn't happen: _handle_events without self._state\"\n                self._state = state\n                self.io_loop.update_handler(self.fileno(), self._state)\n        except UnsatisfiableReadError as e:\n            gen_log.info(\"Unsatisfiable read, closing connection: %s\" % e)\n            self.close(exc_info=e)\n        except Exception as e:\n            gen_log.error(\"Uncaught exception, closing connection.\",\n                          exc_info=True)\n            self.close(exc_info=e)\n            raise",
        "begin_line": 643,
        "end_line": 694,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010869565217391304,
            "pseudo_dstar_susp": 0.004219409282700422,
            "pseudo_tarantula_susp": 0.006329113924050633,
            "pseudo_op2_susp": 0.004219409282700422,
            "pseudo_barinel_susp": 0.006329113924050633
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._run_callback#696",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._run_callback(self, callback, *args)",
        "snippet": "    def _run_callback(self, callback, *args):\n        def wrapper():\n            self._pending_callbacks -= 1\n            try:\n                return callback(*args)\n            except Exception as e:\n                app_log.error(\"Uncaught exception, closing connection.\",\n                              exc_info=True)\n                # Close the socket on an uncaught exception from a user callback\n                # (It would eventually get closed when the socket object is\n                # gc'd, but we don't want to rely on gc happening before we\n                # run out of file descriptors)\n                self.close(exc_info=e)\n                # Re-raise the exception so that IOLoop.handle_callback_exception\n                # can see it and log the error\n                raise\n            finally:\n                self._maybe_add_error_listener()\n        # We schedule callbacks to be run on the next IOLoop iteration\n        # rather than running them directly for several reasons:\n        # * Prevents unbounded stack growth when a callback calls an\n        #   IOLoop operation that immediately runs another callback\n        # * Provides a predictable execution context for e.g.\n        #   non-reentrant mutexes\n        # * Ensures that the try/except in wrapper() is run outside\n        #   of the application's StackContexts\n        with stack_context.NullContext():\n            # stack_context was already captured in callback, we don't need to\n            # capture it again for IOStream's wrapper.  This is especially\n            # important if the callback was pre-wrapped before entry to\n            # IOStream (as in HTTPConnection._header_callback), as we could\n            # capture and leak the wrong context here.\n            self._pending_callbacks += 1\n            self.io_loop.add_callback(wrapper)",
        "begin_line": 696,
        "end_line": 729,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005555555555555556,
            "pseudo_dstar_susp": 0.002857142857142857,
            "pseudo_tarantula_susp": 0.0033444816053511705,
            "pseudo_op2_susp": 0.002857142857142857,
            "pseudo_barinel_susp": 0.0033444816053511705
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream.wrapper#697",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream.wrapper()",
        "snippet": "        def wrapper():\n            self._pending_callbacks -= 1\n            try:\n                return callback(*args)\n            except Exception as e:\n                app_log.error(\"Uncaught exception, closing connection.\",\n                              exc_info=True)\n                # Close the socket on an uncaught exception from a user callback\n                # (It would eventually get closed when the socket object is\n                # gc'd, but we don't want to rely on gc happening before we\n                # run out of file descriptors)\n                self.close(exc_info=e)\n                # Re-raise the exception so that IOLoop.handle_callback_exception\n                # can see it and log the error\n                raise\n            finally:\n                self._maybe_add_error_listener()",
        "begin_line": 697,
        "end_line": 713,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005434782608695652,
            "pseudo_dstar_susp": 0.003067484662576687,
            "pseudo_tarantula_susp": 0.0031645569620253164,
            "pseudo_op2_susp": 0.003067484662576687,
            "pseudo_barinel_susp": 0.0031645569620253164
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._read_to_buffer_loop#731",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._read_to_buffer_loop(self)",
        "snippet": "    def _read_to_buffer_loop(self):\n        # This method is called from _handle_read and _try_inline_read.\n        try:\n            if self._read_bytes is not None:\n                target_bytes = self._read_bytes\n            elif self._read_max_bytes is not None:\n                target_bytes = self._read_max_bytes\n            elif self.reading():\n                # For read_until without max_bytes, or\n                # read_until_close, read as much as we can before\n                # scanning for the delimiter.\n                target_bytes = None\n            else:\n                target_bytes = 0\n            next_find_pos = 0\n            # Pretend to have a pending callback so that an EOF in\n            # _read_to_buffer doesn't trigger an immediate close\n            # callback.  At the end of this method we'll either\n            # establish a real pending callback via\n            # _read_from_buffer or run the close callback.\n            #\n            # We need two try statements here so that\n            # pending_callbacks is decremented before the `except`\n            # clause below (which calls `close` and does need to\n            # trigger the callback)\n            self._pending_callbacks += 1\n            while not self.closed():\n                # Read from the socket until we get EWOULDBLOCK or equivalent.\n                # SSL sockets do some internal buffering, and if the data is\n                # sitting in the SSL object's buffer select() and friends\n                # can't see it; the only way to find out if it's there is to\n                # try to read it.\n                if self._read_to_buffer() == 0:\n                    break\n\n                self._run_streaming_callback()\n\n                # If we've read all the bytes we can use, break out of\n                # this loop.  We can't just call read_from_buffer here\n                # because of subtle interactions with the\n                # pending_callback and error_listener mechanisms.\n                #\n                # If we've reached target_bytes, we know we're done.\n                if (target_bytes is not None and\n                        self._read_buffer_size >= target_bytes):\n                    break\n\n                # Otherwise, we need to call the more expensive find_read_pos.\n                # It's inefficient to do this on every read, so instead\n                # do it on the first read and whenever the read buffer\n                # size has doubled.\n                if self._read_buffer_size >= next_find_pos:\n                    pos = self._find_read_pos()\n                    if pos is not None:\n                        return pos\n                    next_find_pos = self._read_buffer_size * 2\n            return self._find_read_pos()\n        finally:\n            self._pending_callbacks -= 1",
        "begin_line": 731,
        "end_line": 789,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000877963125548727,
            "pseudo_dstar_susp": 0.0008635578583765112,
            "pseudo_tarantula_susp": 0.0029940119760479044,
            "pseudo_op2_susp": 0.0008635578583765112,
            "pseudo_barinel_susp": 0.0029940119760479044
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._handle_read#791",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._handle_read(self)",
        "snippet": "    def _handle_read(self):\n        try:\n            pos = self._read_to_buffer_loop()\n        except UnsatisfiableReadError:\n            raise\n        except Exception as e:\n            gen_log.warning(\"error on read: %s\" % e)\n            self.close(exc_info=e)\n            return\n        if pos is not None:\n            self._read_from_buffer(pos)\n            return\n        else:\n            self._maybe_run_close_callback()",
        "begin_line": 791,
        "end_line": 804,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001183431952662722,
            "pseudo_dstar_susp": 0.0007968127490039841,
            "pseudo_tarantula_susp": 0.006329113924050633,
            "pseudo_op2_susp": 0.0007968127490039841,
            "pseudo_barinel_susp": 0.006329113924050633
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._set_read_callback#806",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._set_read_callback(self, callback)",
        "snippet": "    def _set_read_callback(self, callback):\n        assert self._read_callback is None, \"Already reading\"\n        assert self._read_future is None, \"Already reading\"\n        if callback is not None:\n            self._read_callback = stack_context.wrap(callback)\n        else:\n            self._read_future = Future()\n        return self._read_future",
        "begin_line": 806,
        "end_line": 813,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008271298593879239,
            "pseudo_dstar_susp": 0.0008090614886731392,
            "pseudo_tarantula_susp": 0.0013513513513513514,
            "pseudo_op2_susp": 0.0008090614886731392,
            "pseudo_barinel_susp": 0.0013513513513513514
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._run_read_callback#815",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._run_read_callback(self, size, streaming)",
        "snippet": "    def _run_read_callback(self, size, streaming):\n        if self._user_read_buffer:\n            self._read_buffer = self._after_user_read_buffer or bytearray()\n            self._after_user_read_buffer = None\n            self._read_buffer_pos = 0\n            self._read_buffer_size = len(self._read_buffer)\n            self._user_read_buffer = False\n            result = size\n        else:\n            result = self._consume(size)\n        if streaming:\n            callback = self._streaming_callback\n        else:\n            callback = self._read_callback\n            self._read_callback = self._streaming_callback = None\n            if self._read_future is not None:\n                assert callback is None\n                future = self._read_future\n                self._read_future = None\n\n                future.set_result(result)\n        if callback is not None:\n            assert (self._read_future is None) or streaming\n            self._run_callback(callback, result)\n        else:\n            # If we scheduled a callback, we will add the error listener\n            # afterwards.  If we didn't, we have to do it now.\n            self._maybe_add_error_listener()",
        "begin_line": 815,
        "end_line": 842,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006557377049180328,
            "pseudo_dstar_susp": 0.0007722007722007722,
            "pseudo_tarantula_susp": 0.0006863417982155113,
            "pseudo_op2_susp": 0.0007722007722007722,
            "pseudo_barinel_susp": 0.0006863417982155113
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._try_inline_read#844",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._try_inline_read(self)",
        "snippet": "    def _try_inline_read(self):\n        \"\"\"Attempt to complete the current read operation from buffered data.\n\n        If the read can be completed without blocking, schedules the\n        read callback on the next IOLoop iteration; otherwise starts\n        listening for reads on the socket.\n        \"\"\"\n        # See if we've already got the data from a previous read\n        self._run_streaming_callback()\n        pos = self._find_read_pos()\n        if pos is not None:\n            self._read_from_buffer(pos)\n            return\n        self._check_closed()\n        try:\n            pos = self._read_to_buffer_loop()\n        except Exception:\n            # If there was an in _read_to_buffer, we called close() already,\n            # but couldn't run the close callback because of _pending_callbacks.\n            # Before we escape from this function, run the close callback if\n            # applicable.\n            self._maybe_run_close_callback()\n            raise\n        if pos is not None:\n            self._read_from_buffer(pos)\n            return\n        # We couldn't satisfy the read inline, so either close the stream\n        # or listen for new data.\n        if self.closed():\n            self._maybe_run_close_callback()\n        else:\n            self._add_io_state(ioloop.IOLoop.READ)",
        "begin_line": 844,
        "end_line": 875,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00202020202020202,
            "pseudo_dstar_susp": 0.0008230452674897119,
            "pseudo_tarantula_susp": 0.0064516129032258064,
            "pseudo_op2_susp": 0.0008230452674897119,
            "pseudo_barinel_susp": 0.0064516129032258064
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._read_to_buffer#877",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._read_to_buffer(self)",
        "snippet": "    def _read_to_buffer(self):\n        \"\"\"Reads from the socket and appends the result to the read buffer.\n\n        Returns the number of bytes read.  Returns 0 if there is nothing\n        to read (i.e. the read returns EWOULDBLOCK or equivalent).  On\n        error closes the socket and raises an exception.\n        \"\"\"\n        try:\n            while True:\n                try:\n                    if self._user_read_buffer:\n                        buf = memoryview(self._read_buffer)[self._read_buffer_size:]\n                    else:\n                        buf = bytearray(self.read_chunk_size)\n                    bytes_read = self.read_from_fd(buf)\n                except (socket.error, IOError, OSError) as e:\n                    if errno_from_exception(e) == errno.EINTR:\n                        continue\n                    # ssl.SSLError is a subclass of socket.error\n                    if self._is_connreset(e):\n                        # Treat ECONNRESET as a connection close rather than\n                        # an error to minimize log spam  (the exception will\n                        # be available on self.error for apps that care).\n                        self.close(exc_info=e)\n                        return\n                    self.close(exc_info=e)\n                    raise\n                break\n            if bytes_read is None:\n                return 0\n            elif bytes_read == 0:\n                self.close()\n                return 0\n            if not self._user_read_buffer:\n                self._read_buffer += memoryview(buf)[:bytes_read]\n            self._read_buffer_size += bytes_read\n        finally:\n            # Break the reference to buf so we don't waste a chunk's worth of\n            # memory in case an exception hangs on to our stack frame.\n            buf = None\n        if self._read_buffer_size > self.max_buffer_size:\n            gen_log.error(\"Reached maximum read buffer size\")\n            self.close()\n            raise StreamBufferFullError(\"Reached maximum read buffer size\")\n        return bytes_read",
        "begin_line": 877,
        "end_line": 921,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00076103500761035,
            "pseudo_dstar_susp": 0.0008547008547008547,
            "pseudo_tarantula_susp": 0.0006854009595613434,
            "pseudo_op2_susp": 0.0008547008547008547,
            "pseudo_barinel_susp": 0.0006854009595613434
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._run_streaming_callback#923",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._run_streaming_callback(self)",
        "snippet": "    def _run_streaming_callback(self):\n        if self._streaming_callback is not None and self._read_buffer_size:\n            bytes_to_consume = self._read_buffer_size\n            if self._read_bytes is not None:\n                bytes_to_consume = min(self._read_bytes, bytes_to_consume)\n                self._read_bytes -= bytes_to_consume\n            self._run_read_callback(bytes_to_consume, True)",
        "begin_line": 923,
        "end_line": 929,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000725689404934688,
            "pseudo_dstar_susp": 0.0008136696501220504,
            "pseudo_tarantula_susp": 0.0006218905472636816,
            "pseudo_op2_susp": 0.0008136696501220504,
            "pseudo_barinel_susp": 0.0006218905472636816
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._read_from_buffer#931",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._read_from_buffer(self, pos)",
        "snippet": "    def _read_from_buffer(self, pos):\n        \"\"\"Attempts to complete the currently-pending read from the buffer.\n\n        The argument is either a position in the read buffer or None,\n        as returned by _find_read_pos.\n        \"\"\"\n        self._read_bytes = self._read_delimiter = self._read_regex = None\n        self._read_partial = False\n        self._run_read_callback(pos, False)",
        "begin_line": 931,
        "end_line": 939,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006613756613756613,
            "pseudo_dstar_susp": 0.00078003120124805,
            "pseudo_tarantula_susp": 0.0005938242280285036,
            "pseudo_op2_susp": 0.00078003120124805,
            "pseudo_barinel_susp": 0.0005938242280285036
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._find_read_pos#941",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._find_read_pos(self)",
        "snippet": "    def _find_read_pos(self):\n        \"\"\"Attempts to find a position in the read buffer that satisfies\n        the currently-pending read.\n\n        Returns a position in the buffer if the current read can be satisfied,\n        or None if it cannot.\n        \"\"\"\n        if (self._read_bytes is not None and\n            (self._read_buffer_size >= self._read_bytes or\n             (self._read_partial and self._read_buffer_size > 0))):\n            num_bytes = min(self._read_bytes, self._read_buffer_size)\n            return num_bytes\n        elif self._read_delimiter is not None:\n            # Multi-byte delimiters (e.g. '\\r\\n') may straddle two\n            # chunks in the read buffer, so we can't easily find them\n            # without collapsing the buffer.  However, since protocols\n            # using delimited reads (as opposed to reads of a known\n            # length) tend to be \"line\" oriented, the delimiter is likely\n            # to be in the first few chunks.  Merge the buffer gradually\n            # since large merges are relatively expensive and get undone in\n            # _consume().\n            if self._read_buffer:\n                loc = self._read_buffer.find(self._read_delimiter,\n                                             self._read_buffer_pos)\n                if loc != -1:\n                    loc -= self._read_buffer_pos\n                    delimiter_len = len(self._read_delimiter)\n                    self._check_max_bytes(self._read_delimiter,\n                                          loc + delimiter_len)\n                    return loc + delimiter_len\n                self._check_max_bytes(self._read_delimiter,\n                                      self._read_buffer_size)\n        elif self._read_regex is not None:\n            if self._read_buffer:\n                m = self._read_regex.search(self._read_buffer,\n                                            self._read_buffer_pos)\n                if m is not None:\n                    loc = m.end() - self._read_buffer_pos\n                    self._check_max_bytes(self._read_regex, loc)\n                    return loc\n                self._check_max_bytes(self._read_regex, self._read_buffer_size)\n        return None",
        "begin_line": 941,
        "end_line": 982,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008264462809917355,
            "pseudo_dstar_susp": 0.0008230452674897119,
            "pseudo_tarantula_susp": 0.0033783783783783786,
            "pseudo_op2_susp": 0.0008230452674897119,
            "pseudo_barinel_susp": 0.0033783783783783786
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._check_max_bytes#984",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._check_max_bytes(self, delimiter, size)",
        "snippet": "    def _check_max_bytes(self, delimiter, size):\n        if (self._read_max_bytes is not None and\n                size > self._read_max_bytes):\n            raise UnsatisfiableReadError(\n                \"delimiter %r not found within %d bytes\" % (\n                    delimiter, self._read_max_bytes))",
        "begin_line": 984,
        "end_line": 989,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0021598272138228943,
            "pseudo_dstar_susp": 0.0008658008658008658,
            "pseudo_tarantula_susp": 0.006756756756756757,
            "pseudo_op2_susp": 0.0008658008658008658,
            "pseudo_barinel_susp": 0.006756756756756757
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._handle_write#991",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._handle_write(self)",
        "snippet": "    def _handle_write(self):\n        while True:\n            size = len(self._write_buffer)\n            if not size:\n                break\n            assert size > 0\n            try:\n                if _WINDOWS:\n                    # On windows, socket.send blows up if given a\n                    # write buffer that's too large, instead of just\n                    # returning the number of bytes it was able to\n                    # process.  Therefore we must not call socket.send\n                    # with more than 128KB at a time.\n                    size = 128 * 1024\n\n                num_bytes = self.write_to_fd(self._write_buffer.peek(size))\n                if num_bytes == 0:\n                    break\n                self._write_buffer.advance(num_bytes)\n                self._total_write_done_index += num_bytes\n            except (socket.error, IOError, OSError) as e:\n                if e.args[0] in _ERRNO_WOULDBLOCK:\n                    break\n                else:\n                    if not self._is_connreset(e):\n                        # Broken pipe errors are usually caused by connection\n                        # reset, and its better to not log EPIPE errors to\n                        # minimize log spam\n                        gen_log.warning(\"Write error on %s: %s\",\n                                        self.fileno(), e)\n                    self.close(exc_info=e)\n                    return\n\n        while self._write_futures:\n            index, future = self._write_futures[0]\n            if index > self._total_write_done_index:\n                break\n            self._write_futures.popleft()\n            future.set_result(None)\n\n        if not len(self._write_buffer):\n            if self._write_callback:\n                callback = self._write_callback\n                self._write_callback = None\n                self._run_callback(callback)",
        "begin_line": 991,
        "end_line": 1035,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001984126984126984,
            "pseudo_dstar_susp": 0.0021141649048625794,
            "pseudo_tarantula_susp": 0.0011061946902654867,
            "pseudo_op2_susp": 0.0021141649048625794,
            "pseudo_barinel_susp": 0.0011061946902654867
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._consume#1037",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._consume(self, loc)",
        "snippet": "    def _consume(self, loc):\n        # Consume loc bytes from the read buffer and return them\n        if loc == 0:\n            return b\"\"\n        assert loc <= self._read_buffer_size\n        # Slice the bytearray buffer into bytes, without intermediate copying\n        b = (memoryview(self._read_buffer)\n             [self._read_buffer_pos:self._read_buffer_pos + loc]\n             ).tobytes()\n        self._read_buffer_pos += loc\n        self._read_buffer_size -= loc\n        # Amortized O(1) shrink\n        # (this heuristic is implemented natively in Python 3.4+\n        #  but is replicated here for Python 2)\n        if self._read_buffer_pos > self._read_buffer_size:\n            del self._read_buffer[:self._read_buffer_pos]\n            self._read_buffer_pos = 0\n        return b",
        "begin_line": 1037,
        "end_line": 1054,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006993006993006993,
            "pseudo_dstar_susp": 0.0007757951900698216,
            "pseudo_tarantula_susp": 0.001639344262295082,
            "pseudo_op2_susp": 0.0007757951900698216,
            "pseudo_barinel_susp": 0.001639344262295082
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._check_closed#1056",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._check_closed(self)",
        "snippet": "    def _check_closed(self):\n        if self.closed():\n            raise StreamClosedError(real_error=self.error)",
        "begin_line": 1056,
        "end_line": 1058,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00078064012490242,
            "pseudo_dstar_susp": 0.000877963125548727,
            "pseudo_tarantula_susp": 0.0006527415143603133,
            "pseudo_op2_susp": 0.000877963125548727,
            "pseudo_barinel_susp": 0.0006527415143603133
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._maybe_add_error_listener#1060",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._maybe_add_error_listener(self)",
        "snippet": "    def _maybe_add_error_listener(self):\n        # This method is part of an optimization: to detect a connection that\n        # is closed when we're not actively reading or writing, we must listen\n        # for read events.  However, it is inefficient to do this when the\n        # connection is first established because we are going to read or write\n        # immediately anyway.  Instead, we insert checks at various times to\n        # see if the connection is idle and add the read listener then.\n        if self._pending_callbacks != 0:\n            return\n        if self._state is None or self._state == ioloop.IOLoop.ERROR:\n            if self.closed():\n                self._maybe_run_close_callback()\n            elif (self._read_buffer_size == 0 and\n                  self._close_callback is not None):\n                self._add_io_state(ioloop.IOLoop.READ)",
        "begin_line": 1060,
        "end_line": 1074,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008665511265164644,
            "pseudo_dstar_susp": 0.000942507068803016,
            "pseudo_tarantula_susp": 0.0027548209366391185,
            "pseudo_op2_susp": 0.000942507068803016,
            "pseudo_barinel_susp": 0.0027548209366391185
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._add_io_state#1076",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._add_io_state(self, state)",
        "snippet": "    def _add_io_state(self, state):\n        \"\"\"Adds `state` (IOLoop.{READ,WRITE} flags) to our event handler.\n\n        Implementation notes: Reads and writes have a fast path and a\n        slow path.  The fast path reads synchronously from socket\n        buffers, while the slow path uses `_add_io_state` to schedule\n        an IOLoop callback.  Note that in both cases, the callback is\n        run asynchronously with `_run_callback`.\n\n        To detect closed connections, we must have called\n        `_add_io_state` at some point, but we want to delay this as\n        much as possible so we don't have to set an `IOLoop.ERROR`\n        listener that will be overwritten by the next slow-path\n        operation.  As long as there are callbacks scheduled for\n        fast-path ops, those callbacks may do more reads.\n        If a sequence of fast-path ops do not end in a slow-path op,\n        (e.g. for an @asynchronous long-poll request), we must add\n        the error handler.  This is done in `_run_callback` and `write`\n        (since the write callback is optional so we can have a\n        fast-path write with no `_run_callback`)\n        \"\"\"\n        if self.closed():\n            # connection has been closed, so there can be no future events\n            return\n        if self._state is None:\n            self._state = ioloop.IOLoop.ERROR | state\n            with stack_context.NullContext():\n                self.io_loop.add_handler(\n                    self.fileno(), self._handle_events, self._state)\n        elif not self._state & state:\n            self._state = self._state | state\n            self.io_loop.update_handler(self.fileno(), self._state)",
        "begin_line": 1076,
        "end_line": 1107,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004081632653061225,
            "pseudo_dstar_susp": 0.0047169811320754715,
            "pseudo_tarantula_susp": 0.002325581395348837,
            "pseudo_op2_susp": 0.0047169811320754715,
            "pseudo_barinel_susp": 0.002325581395348837
        }
    },
    {
        "name": "tornado.iostream.BaseIOStream._is_connreset#1109",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.BaseIOStream",
        "signature": "tornado.iostream.BaseIOStream._is_connreset(self, exc)",
        "snippet": "    def _is_connreset(self, exc):\n        \"\"\"Return true if exc is ECONNRESET or equivalent.\n\n        May be overridden in subclasses.\n        \"\"\"\n        return (isinstance(exc, (socket.error, IOError)) and\n                errno_from_exception(exc) in _ERRNO_CONNRESET)",
        "begin_line": 1109,
        "end_line": 1115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.iostream.IOStream.__init__#1166",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream.__init__(self, socket, *args, **kwargs)",
        "snippet": "    def __init__(self, socket, *args, **kwargs):\n        self.socket = socket\n        self.socket.setblocking(False)\n        super(IOStream, self).__init__(*args, **kwargs)",
        "begin_line": 1166,
        "end_line": 1169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0037313432835820895,
            "pseudo_dstar_susp": 0.004098360655737705,
            "pseudo_tarantula_susp": 0.0020491803278688526,
            "pseudo_op2_susp": 0.004098360655737705,
            "pseudo_barinel_susp": 0.0020491803278688526
        }
    },
    {
        "name": "tornado.iostream.IOStream.fileno#1171",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream.fileno(self)",
        "snippet": "    def fileno(self):\n        return self.socket",
        "begin_line": 1171,
        "end_line": 1172,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003246753246753247,
            "pseudo_dstar_susp": 0.0036363636363636364,
            "pseudo_tarantula_susp": 0.001968503937007874,
            "pseudo_op2_susp": 0.0036363636363636364,
            "pseudo_barinel_susp": 0.001968503937007874
        }
    },
    {
        "name": "tornado.iostream.IOStream.close_fd#1174",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream.close_fd(self)",
        "snippet": "    def close_fd(self):\n        self.socket.close()\n        self.socket = None",
        "begin_line": 1174,
        "end_line": 1176,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006920415224913495,
            "pseudo_dstar_susp": 0.0007993605115907274,
            "pseudo_tarantula_susp": 0.0006097560975609756,
            "pseudo_op2_susp": 0.0007993605115907274,
            "pseudo_barinel_susp": 0.0006097560975609756
        }
    },
    {
        "name": "tornado.iostream.IOStream.read_from_fd#1183",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream.read_from_fd(self, buf)",
        "snippet": "    def read_from_fd(self, buf):\n        try:\n            return self.socket.recv_into(buf)\n        except socket.error as e:\n            if e.args[0] in _ERRNO_WOULDBLOCK:\n                return None\n            else:\n                raise\n        finally:\n            buf = None",
        "begin_line": 1183,
        "end_line": 1192,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006858710562414266,
            "pseudo_dstar_susp": 0.0007911392405063291,
            "pseudo_tarantula_susp": 0.0005998800239952009,
            "pseudo_op2_susp": 0.0007911392405063291,
            "pseudo_barinel_susp": 0.0005998800239952009
        }
    },
    {
        "name": "tornado.iostream.IOStream.write_to_fd#1194",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream.write_to_fd(self, data)",
        "snippet": "    def write_to_fd(self, data):\n        try:\n            return self.socket.send(data)\n        finally:\n            # Avoid keeping to data, which can be a memoryview.\n            # See https://github.com/tornadoweb/tornado/pull/2008\n            del data",
        "begin_line": 1194,
        "end_line": 1200,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000687757909215956,
            "pseudo_dstar_susp": 0.0007936507936507937,
            "pseudo_tarantula_susp": 0.0006013229104028864,
            "pseudo_op2_susp": 0.0007936507936507937,
            "pseudo_barinel_susp": 0.0006013229104028864
        }
    },
    {
        "name": "tornado.iostream.IOStream.connect#1202",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream.connect(self, address, callback=None, server_hostname=None)",
        "snippet": "    def connect(self, address, callback=None, server_hostname=None):\n        \"\"\"Connects the socket to a remote address without blocking.\n\n        May only be called if the socket passed to the constructor was\n        not previously connected.  The address parameter is in the\n        same format as for `socket.connect <socket.socket.connect>` for\n        the type of socket passed to the IOStream constructor,\n        e.g. an ``(ip, port)`` tuple.  Hostnames are accepted here,\n        but will be resolved synchronously and block the IOLoop.\n        If you have a hostname instead of an IP address, the `.TCPClient`\n        class is recommended instead of calling this method directly.\n        `.TCPClient` will do asynchronous DNS resolution and handle\n        both IPv4 and IPv6.\n\n        If ``callback`` is specified, it will be called with no\n        arguments when the connection is completed; if not this method\n        returns a `.Future` (whose result after a successful\n        connection will be the stream itself).\n\n        In SSL mode, the ``server_hostname`` parameter will be used\n        for certificate validation (unless disabled in the\n        ``ssl_options``) and SNI (if supported; requires Python\n        2.7.9+).\n\n        Note that it is safe to call `IOStream.write\n        <BaseIOStream.write>` while the connection is pending, in\n        which case the data will be written as soon as the connection\n        is ready.  Calling `IOStream` read methods before the socket is\n        connected works on some platforms but is non-portable.\n\n        .. versionchanged:: 4.0\n            If no callback is given, returns a `.Future`.\n\n        .. versionchanged:: 4.2\n           SSL certificates are validated by default; pass\n           ``ssl_options=dict(cert_reqs=ssl.CERT_NONE)`` or a\n           suitably-configured `ssl.SSLContext` to the\n           `SSLIOStream` constructor to disable.\n        \"\"\"\n        self._connecting = True\n        if callback is not None:\n            self._connect_callback = stack_context.wrap(callback)\n            future = None\n        else:\n            future = self._connect_future = Future()\n        try:\n            self.socket.connect(address)\n        except socket.error as e:\n            # In non-blocking mode we expect connect() to raise an\n            # exception with EINPROGRESS or EWOULDBLOCK.\n            #\n            # On freebsd, other errors such as ECONNREFUSED may be\n            # returned immediately when attempting to connect to\n            # localhost, so handle them the same way as an error\n            # reported later in _handle_connect.\n            if (errno_from_exception(e) not in _ERRNO_INPROGRESS and\n                    errno_from_exception(e) not in _ERRNO_WOULDBLOCK):\n                if future is None:\n                    gen_log.warning(\"Connect error on fd %s: %s\",\n                                    self.socket.fileno(), e)\n                self.close(exc_info=e)\n                return future\n        self._add_io_state(self.io_loop.WRITE)\n        return future",
        "begin_line": 1202,
        "end_line": 1265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008264462809917356,
            "pseudo_dstar_susp": 0.0037593984962406013,
            "pseudo_tarantula_susp": 0.0041841004184100415,
            "pseudo_op2_susp": 0.0037593984962406013,
            "pseudo_barinel_susp": 0.0041841004184100415
        }
    },
    {
        "name": "tornado.iostream.IOStream.start_tls#1267",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream.start_tls(self, server_side, ssl_options=None, server_hostname=None)",
        "snippet": "    def start_tls(self, server_side, ssl_options=None, server_hostname=None):\n        \"\"\"Convert this `IOStream` to an `SSLIOStream`.\n\n        This enables protocols that begin in clear-text mode and\n        switch to SSL after some initial negotiation (such as the\n        ``STARTTLS`` extension to SMTP and IMAP).\n\n        This method cannot be used if there are outstanding reads\n        or writes on the stream, or if there is any data in the\n        IOStream's buffer (data in the operating system's socket\n        buffer is allowed).  This means it must generally be used\n        immediately after reading or writing the last clear-text\n        data.  It can also be used immediately after connecting,\n        before any reads or writes.\n\n        The ``ssl_options`` argument may be either an `ssl.SSLContext`\n        object or a dictionary of keyword arguments for the\n        `ssl.wrap_socket` function.  The ``server_hostname`` argument\n        will be used for certificate validation unless disabled\n        in the ``ssl_options``.\n\n        This method returns a `.Future` whose result is the new\n        `SSLIOStream`.  After this method has been called,\n        any other operation on the original stream is undefined.\n\n        If a close callback is defined on this stream, it will be\n        transferred to the new stream.\n\n        .. versionadded:: 4.0\n\n        .. versionchanged:: 4.2\n           SSL certificates are validated by default; pass\n           ``ssl_options=dict(cert_reqs=ssl.CERT_NONE)`` or a\n           suitably-configured `ssl.SSLContext` to disable.\n        \"\"\"\n        if (self._read_callback or self._read_future or\n                self._write_callback or self._write_futures or\n                self._connect_callback or self._connect_future or\n                self._pending_callbacks or self._closed or\n                self._read_buffer or self._write_buffer):\n            raise ValueError(\"IOStream is not idle; cannot convert to SSL\")\n        if ssl_options is None:\n            if server_side:\n                ssl_options = _server_ssl_defaults\n            else:\n                ssl_options = _client_ssl_defaults\n\n        socket = self.socket\n        self.io_loop.remove_handler(socket)\n        self.socket = None\n        socket = ssl_wrap_socket(socket, ssl_options,\n                                 server_hostname=server_hostname,\n                                 server_side=server_side,\n                                 do_handshake_on_connect=False)\n        orig_close_callback = self._close_callback\n        self._close_callback = None\n\n        future = Future()\n        ssl_stream = SSLIOStream(socket, ssl_options=ssl_options)\n        # Wrap the original close callback so we can fail our Future as well.\n        # If we had an \"unwrap\" counterpart to this method we would need\n        # to restore the original callback after our Future resolves\n        # so that repeated wrap/unwrap calls don't build up layers.\n\n        def close_callback():\n            if not future.done():\n                # Note that unlike most Futures returned by IOStream,\n                # this one passes the underlying error through directly\n                # instead of wrapping everything in a StreamClosedError\n                # with a real_error attribute. This is because once the\n                # connection is established it's more helpful to raise\n                # the SSLError directly than to hide it behind a\n                # StreamClosedError (and the client is expecting SSL\n                # issues rather than network issues since this method is\n                # named start_tls).\n                future.set_exception(ssl_stream.error or StreamClosedError())\n            if orig_close_callback is not None:\n                orig_close_callback()\n        ssl_stream.set_close_callback(close_callback)\n        ssl_stream._ssl_connect_callback = lambda: future.set_result(ssl_stream)\n        ssl_stream.max_buffer_size = self.max_buffer_size\n        ssl_stream.read_chunk_size = self.read_chunk_size\n        return future",
        "begin_line": 1267,
        "end_line": 1349,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008517887563884157,
            "pseudo_dstar_susp": 0.00043706293706293706,
            "pseudo_tarantula_susp": 0.005555555555555556,
            "pseudo_op2_susp": 0.00043706293706293706,
            "pseudo_barinel_susp": 0.005555555555555556
        }
    },
    {
        "name": "tornado.iostream.IOStream.close_callback#1331",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream.close_callback()",
        "snippet": "        def close_callback():\n            if not future.done():\n                # Note that unlike most Futures returned by IOStream,\n                # this one passes the underlying error through directly\n                # instead of wrapping everything in a StreamClosedError\n                # with a real_error attribute. This is because once the\n                # connection is established it's more helpful to raise\n                # the SSLError directly than to hide it behind a\n                # StreamClosedError (and the client is expecting SSL\n                # issues rather than network issues since this method is\n                # named start_tls).\n                future.set_exception(ssl_stream.error or StreamClosedError())\n            if orig_close_callback is not None:\n                orig_close_callback()",
        "begin_line": 1331,
        "end_line": 1344,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006430868167202572,
            "pseudo_dstar_susp": 0.00039984006397441024,
            "pseudo_tarantula_susp": 0.0038461538461538464,
            "pseudo_op2_susp": 0.00039984006397441024,
            "pseudo_barinel_susp": 0.0038461538461538464
        }
    },
    {
        "name": "tornado.iostream.IOStream._handle_connect#1351",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream._handle_connect(self)",
        "snippet": "    def _handle_connect(self):\n        err = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n        if err != 0:\n            self.error = socket.error(err, os.strerror(err))\n            # IOLoop implementations may vary: some of them return\n            # an error state before the socket becomes writable, so\n            # in that case a connection failure would be handled by the\n            # error path in _handle_events instead of here.\n            if self._connect_future is None:\n                gen_log.warning(\"Connect error on fd %s: %s\",\n                                self.socket.fileno(), errno.errorcode[err])\n            self.close()\n            return\n        if self._connect_callback is not None:\n            callback = self._connect_callback\n            self._connect_callback = None\n            self._run_callback(callback)\n        if self._connect_future is not None:\n            future = self._connect_future\n            self._connect_future = None\n            future.set_result(self)\n        self._connecting = False",
        "begin_line": 1351,
        "end_line": 1372,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009433962264150943,
            "pseudo_dstar_susp": 0.0037593984962406013,
            "pseudo_tarantula_susp": 0.0043859649122807015,
            "pseudo_op2_susp": 0.0037593984962406013,
            "pseudo_barinel_susp": 0.0043859649122807015
        }
    },
    {
        "name": "tornado.iostream.IOStream.set_nodelay#1374",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.IOStream",
        "signature": "tornado.iostream.IOStream.set_nodelay(self, value)",
        "snippet": "    def set_nodelay(self, value):\n        if (self.socket is not None and\n                self.socket.family in (socket.AF_INET, socket.AF_INET6)):\n            try:\n                self.socket.setsockopt(socket.IPPROTO_TCP,\n                                       socket.TCP_NODELAY, 1 if value else 0)\n            except socket.error as e:\n                # Sometimes setsockopt will fail if the socket is closed\n                # at the wrong time.  This can happen with HTTPServer\n                # resetting the value to false between requests.\n                if e.errno != errno.EINVAL and not self._is_connreset(e):\n                    raise",
        "begin_line": 1374,
        "end_line": 1385,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00048146364949446316,
            "pseudo_dstar_susp": 0.0005621135469364812,
            "pseudo_tarantula_susp": 0.00047036688617121356,
            "pseudo_op2_susp": 0.0005621135469364812,
            "pseudo_barinel_susp": 0.00047036688617121356
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream.__init__#1399",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        \"\"\"The ``ssl_options`` keyword argument may either be an\n        `ssl.SSLContext` object or a dictionary of keywords arguments\n        for `ssl.wrap_socket`\n        \"\"\"\n        self._ssl_options = kwargs.pop('ssl_options', _client_ssl_defaults)\n        super(SSLIOStream, self).__init__(*args, **kwargs)\n        self._ssl_accepting = True\n        self._handshake_reading = False\n        self._handshake_writing = False\n        self._ssl_connect_callback = None\n        self._server_hostname = None\n\n        # If the socket is already connected, attempt to start the handshake.\n        try:\n            self.socket.getpeername()\n        except socket.error:\n            pass\n        else:\n            # Indirectly start the handshake, which will run on the next\n            # IOLoop iteration and then the real IO state will be set in\n            # _handle_events.\n            self._add_io_state(self.io_loop.WRITE)",
        "begin_line": 1399,
        "end_line": 1421,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02564102564102564,
            "pseudo_dstar_susp": 0.0025974025974025974,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.0025974025974025974,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream.reading#1423",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream.reading(self)",
        "snippet": "    def reading(self):\n        return self._handshake_reading or super(SSLIOStream, self).reading()",
        "begin_line": 1423,
        "end_line": 1424,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02564102564102564,
            "pseudo_dstar_susp": 0.0025974025974025974,
            "pseudo_tarantula_susp": 0.009900990099009901,
            "pseudo_op2_susp": 0.0025974025974025974,
            "pseudo_barinel_susp": 0.009900990099009901
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream.writing#1426",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream.writing(self)",
        "snippet": "    def writing(self):\n        return self._handshake_writing or super(SSLIOStream, self).writing()",
        "begin_line": 1426,
        "end_line": 1427,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02564102564102564,
            "pseudo_dstar_susp": 0.0025974025974025974,
            "pseudo_tarantula_susp": 0.009900990099009901,
            "pseudo_op2_susp": 0.0025974025974025974,
            "pseudo_barinel_susp": 0.009900990099009901
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream._do_ssl_handshake#1429",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream._do_ssl_handshake(self)",
        "snippet": "    def _do_ssl_handshake(self):\n        # Based on code from test_ssl.py in the python stdlib\n        try:\n            self._handshake_reading = False\n            self._handshake_writing = False\n            self.socket.do_handshake()\n        except ssl.SSLError as err:\n            if err.args[0] == ssl.SSL_ERROR_WANT_READ:\n                self._handshake_reading = True\n                return\n            elif err.args[0] == ssl.SSL_ERROR_WANT_WRITE:\n                self._handshake_writing = True\n                return\n            elif err.args[0] in (ssl.SSL_ERROR_EOF,\n                                 ssl.SSL_ERROR_ZERO_RETURN):\n                return self.close(exc_info=err)\n            elif err.args[0] == ssl.SSL_ERROR_SSL:\n                try:\n                    peer = self.socket.getpeername()\n                except Exception:\n                    peer = '(not connected)'\n                gen_log.warning(\"SSL Error on %s %s: %s\",\n                                self.socket.fileno(), peer, err)\n                return self.close(exc_info=err)\n            raise\n        except socket.error as err:\n            # Some port scans (e.g. nmap in -sT mode) have been known\n            # to cause do_handshake to raise EBADF and ENOTCONN, so make\n            # those errors quiet as well.\n            # https://groups.google.com/forum/?fromgroups#!topic/python-tornado/ApucKJat1_0\n            if (self._is_connreset(err) or\n                    err.args[0] in (errno.EBADF, errno.ENOTCONN)):\n                return self.close(exc_info=err)\n            raise\n        except AttributeError as err:\n            # On Linux, if the connection was reset before the call to\n            # wrap_socket, do_handshake will fail with an\n            # AttributeError.\n            return self.close(exc_info=err)\n        else:\n            self._ssl_accepting = False\n            if not self._verify_cert(self.socket.getpeercert()):\n                self.close()\n                return\n            self._run_ssl_connect_callback()",
        "begin_line": 1429,
        "end_line": 1473,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02564102564102564,
            "pseudo_dstar_susp": 0.0025974025974025974,
            "pseudo_tarantula_susp": 0.009900990099009901,
            "pseudo_op2_susp": 0.0025974025974025974,
            "pseudo_barinel_susp": 0.009900990099009901
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream._handle_write#1518",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream._handle_write(self)",
        "snippet": "    def _handle_write(self):\n        if self._ssl_accepting:\n            self._do_ssl_handshake()\n            return\n        super(SSLIOStream, self)._handle_write()",
        "begin_line": 1518,
        "end_line": 1522,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02564102564102564,
            "pseudo_dstar_susp": 0.0025974025974025974,
            "pseudo_tarantula_susp": 0.009900990099009901,
            "pseudo_op2_susp": 0.0025974025974025974,
            "pseudo_barinel_susp": 0.009900990099009901
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream.connect#1524",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream.connect(self, address, callback=None, server_hostname=None)",
        "snippet": "    def connect(self, address, callback=None, server_hostname=None):\n        self._server_hostname = server_hostname\n        # Pass a dummy callback to super.connect(), which is slightly\n        # more efficient than letting it return a Future we ignore.\n        super(SSLIOStream, self).connect(address, callback=lambda: None)\n        return self.wait_for_handshake(callback)",
        "begin_line": 1524,
        "end_line": 1529,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.041666666666666664,
            "pseudo_dstar_susp": 0.0027624309392265192,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.0027624309392265192,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream._handle_connect#1531",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream._handle_connect(self)",
        "snippet": "    def _handle_connect(self):\n        # Call the superclass method to check for errors.\n        super(SSLIOStream, self)._handle_connect()\n        if self.closed():\n            return\n        # When the connection is complete, wrap the socket for SSL\n        # traffic.  Note that we do this by overriding _handle_connect\n        # instead of by passing a callback to super().connect because\n        # user callbacks are enqueued asynchronously on the IOLoop,\n        # but since _handle_events calls _handle_connect immediately\n        # followed by _handle_write we need this to be synchronous.\n        #\n        # The IOLoop will get confused if we swap out self.socket while the\n        # fd is registered, so remove it now and re-register after\n        # wrap_socket().\n        self.io_loop.remove_handler(self.socket)\n        old_state = self._state\n        self._state = None\n        self.socket = ssl_wrap_socket(self.socket, self._ssl_options,\n                                      server_hostname=self._server_hostname,\n                                      do_handshake_on_connect=False)\n        self._add_io_state(old_state)",
        "begin_line": 1531,
        "end_line": 1552,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.015384615384615385,
            "pseudo_dstar_susp": 0.0024271844660194173,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.0024271844660194173,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.iostream.SSLIOStream.wait_for_handshake#1554",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.SSLIOStream",
        "signature": "tornado.iostream.SSLIOStream.wait_for_handshake(self, callback=None)",
        "snippet": "    def wait_for_handshake(self, callback=None):\n        \"\"\"Wait for the initial SSL handshake to complete.\n\n        If a ``callback`` is given, it will be called with no\n        arguments once the handshake is complete; otherwise this\n        method returns a `.Future` which will resolve to the\n        stream itself after the handshake is complete.\n\n        Once the handshake is complete, information such as\n        the peer's certificate and NPN/ALPN selections may be\n        accessed on ``self.socket``.\n\n        This method is intended for use on server-side streams\n        or after using `IOStream.start_tls`; it should not be used\n        with `IOStream.connect` (which already waits for the\n        handshake to complete). It may only be called once per stream.\n\n        .. versionadded:: 4.2\n        \"\"\"\n        if (self._ssl_connect_callback is not None or\n                self._ssl_connect_future is not None):\n            raise RuntimeError(\"Already waiting\")\n        if callback is not None:\n            self._ssl_connect_callback = stack_context.wrap(callback)\n            future = None\n        else:\n            future = self._ssl_connect_future = Future()\n        if not self._ssl_accepting:\n            self._run_ssl_connect_callback()\n        return future",
        "begin_line": 1554,
        "end_line": 1583,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.015384615384615385,
            "pseudo_dstar_susp": 0.0024271844660194173,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.0024271844660194173,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.iostream.PipeIOStream.__init__#1641",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.PipeIOStream",
        "signature": "tornado.iostream.PipeIOStream.__init__(self, fd, *args, **kwargs)",
        "snippet": "    def __init__(self, fd, *args, **kwargs):\n        self.fd = fd\n        self._fio = io.FileIO(self.fd, \"r+\")\n        _set_nonblocking(fd)\n        super(PipeIOStream, self).__init__(*args, **kwargs)",
        "begin_line": 1641,
        "end_line": 1645,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007757951900698216,
            "pseudo_dstar_susp": 0.0005012531328320802,
            "pseudo_tarantula_susp": 0.0023923444976076554,
            "pseudo_op2_susp": 0.0005012531328320802,
            "pseudo_barinel_susp": 0.0023923444976076554
        }
    },
    {
        "name": "tornado.iostream.PipeIOStream.fileno#1647",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.PipeIOStream",
        "signature": "tornado.iostream.PipeIOStream.fileno(self)",
        "snippet": "    def fileno(self):\n        return self.fd",
        "begin_line": 1647,
        "end_line": 1648,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008216926869350862,
            "pseudo_dstar_susp": 0.0005045408678102926,
            "pseudo_tarantula_susp": 0.0029411764705882353,
            "pseudo_op2_susp": 0.0005045408678102926,
            "pseudo_barinel_susp": 0.0029411764705882353
        }
    },
    {
        "name": "tornado.iostream.PipeIOStream.close_fd#1650",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.PipeIOStream",
        "signature": "tornado.iostream.PipeIOStream.close_fd(self)",
        "snippet": "    def close_fd(self):\n        self._fio.close()",
        "begin_line": 1650,
        "end_line": 1651,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0007757951900698216,
            "pseudo_dstar_susp": 0.0005012531328320802,
            "pseudo_tarantula_susp": 0.0023923444976076554,
            "pseudo_op2_susp": 0.0005012531328320802,
            "pseudo_barinel_susp": 0.0023923444976076554
        }
    },
    {
        "name": "tornado.iostream.PipeIOStream.write_to_fd#1653",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.PipeIOStream",
        "signature": "tornado.iostream.PipeIOStream.write_to_fd(self, data)",
        "snippet": "    def write_to_fd(self, data):\n        try:\n            return os.write(self.fd, data)\n        finally:\n            # Avoid keeping to data, which can be a memoryview.\n            # See https://github.com/tornadoweb/tornado/pull/2008\n            del data",
        "begin_line": 1653,
        "end_line": 1659,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008130081300813008,
            "pseudo_dstar_susp": 0.0005037783375314861,
            "pseudo_tarantula_susp": 0.002777777777777778,
            "pseudo_op2_susp": 0.0005037783375314861,
            "pseudo_barinel_susp": 0.002777777777777778
        }
    },
    {
        "name": "tornado.iostream.PipeIOStream.read_from_fd#1661",
        "src_path": "tornado/iostream.py",
        "class_name": "tornado.iostream.PipeIOStream",
        "signature": "tornado.iostream.PipeIOStream.read_from_fd(self, buf)",
        "snippet": "    def read_from_fd(self, buf):\n        try:\n            return self._fio.readinto(buf)\n        except (IOError, OSError) as e:\n            if errno_from_exception(e) == errno.EBADF:\n                # If the writing half of a pipe is closed, select will\n                # report it as readable but reads will fail with EBADF.\n                self.close(exc_info=e)\n                return None\n            else:\n                raise\n        finally:\n            buf = None",
        "begin_line": 1661,
        "end_line": 1673,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0008090614886731392,
            "pseudo_dstar_susp": 0.0005027652086475615,
            "pseudo_tarantula_susp": 0.0024390243902439024,
            "pseudo_op2_susp": 0.0005027652086475615,
            "pseudo_barinel_susp": 0.0024390243902439024
        }
    },
    {
        "name": "tornado.routing.Router.start_request#211",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.Router",
        "signature": "tornado.routing.Router.start_request(self, server_conn, request_conn)",
        "snippet": "    def start_request(self, server_conn, request_conn):\n        return _RoutingDelegate(self, server_conn, request_conn)",
        "begin_line": 211,
        "end_line": 212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006635700066357001,
            "pseudo_dstar_susp": 0.0007358351729212656,
            "pseudo_tarantula_susp": 0.0006153846153846154,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0006153846153846154
        }
    },
    {
        "name": "tornado.routing._RoutingDelegate.__init__#232",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing._RoutingDelegate",
        "signature": "tornado.routing._RoutingDelegate.__init__(self, router, server_conn, request_conn)",
        "snippet": "    def __init__(self, router, server_conn, request_conn):\n        self.server_conn = server_conn\n        self.request_conn = request_conn\n        self.delegate = None\n        self.router = router  # type: Router",
        "begin_line": 232,
        "end_line": 236,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006635700066357001,
            "pseudo_dstar_susp": 0.0007358351729212656,
            "pseudo_tarantula_susp": 0.0006153846153846154,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0006153846153846154
        }
    },
    {
        "name": "tornado.routing._RoutingDelegate.headers_received#238",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing._RoutingDelegate",
        "signature": "tornado.routing._RoutingDelegate.headers_received(self, start_line, headers)",
        "snippet": "    def headers_received(self, start_line, headers):\n        request = httputil.HTTPServerRequest(\n            connection=self.request_conn,\n            server_connection=self.server_conn,\n            start_line=start_line, headers=headers)\n\n        self.delegate = self.router.find_handler(request)\n        if self.delegate is None:\n            app_log.debug(\"Delegate for %s %s request not found\",\n                          start_line.method, start_line.path)\n            self.delegate = _DefaultMessageDelegate(self.request_conn)\n\n        return self.delegate.headers_received(start_line, headers)",
        "begin_line": 238,
        "end_line": 250,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005630630630630631,
            "pseudo_dstar_susp": 0.0006317119393556538,
            "pseudo_tarantula_susp": 0.000591715976331361,
            "pseudo_op2_susp": 0.0006317119393556538,
            "pseudo_barinel_susp": 0.000591715976331361
        }
    },
    {
        "name": "tornado.routing._RoutingDelegate.data_received#252",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing._RoutingDelegate",
        "signature": "tornado.routing._RoutingDelegate.data_received(self, chunk)",
        "snippet": "    def data_received(self, chunk):\n        return self.delegate.data_received(chunk)",
        "begin_line": 252,
        "end_line": 253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0003957261574990107,
            "pseudo_dstar_susp": 0.00038880248833592535,
            "pseudo_tarantula_susp": 0.0005154639175257732,
            "pseudo_op2_susp": 0.00038880248833592535,
            "pseudo_barinel_susp": 0.0005154639175257732
        }
    },
    {
        "name": "tornado.routing._RoutingDelegate.finish#255",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing._RoutingDelegate",
        "signature": "tornado.routing._RoutingDelegate.finish(self)",
        "snippet": "    def finish(self):\n        self.delegate.finish()",
        "begin_line": 255,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004278990158322636,
            "pseudo_dstar_susp": 0.0004666355576294914,
            "pseudo_tarantula_susp": 0.0004284490145672665,
            "pseudo_op2_susp": 0.0004666355576294914,
            "pseudo_barinel_susp": 0.0004284490145672665
        }
    },
    {
        "name": "tornado.routing._RoutingDelegate.on_connection_close#258",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing._RoutingDelegate",
        "signature": "tornado.routing._RoutingDelegate.on_connection_close(self)",
        "snippet": "    def on_connection_close(self):\n        self.delegate.on_connection_close()",
        "begin_line": 258,
        "end_line": 259,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001218026796589525,
            "pseudo_dstar_susp": 0.0005482456140350877,
            "pseudo_tarantula_susp": 0.004761904761904762,
            "pseudo_op2_susp": 0.0005482456140350877,
            "pseudo_barinel_susp": 0.004608294930875576
        }
    },
    {
        "name": "tornado.routing._DefaultMessageDelegate.__init__#263",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing._DefaultMessageDelegate",
        "signature": "tornado.routing._DefaultMessageDelegate.__init__(self, connection)",
        "snippet": "    def __init__(self, connection):\n        self.connection = connection",
        "begin_line": 263,
        "end_line": 264,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.routing._DefaultMessageDelegate.finish#266",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing._DefaultMessageDelegate",
        "signature": "tornado.routing._DefaultMessageDelegate.finish(self)",
        "snippet": "    def finish(self):\n        self.connection.write_headers(\n            httputil.ResponseStartLine(\"HTTP/1.1\", 404, \"Not Found\"), httputil.HTTPHeaders())\n        self.connection.finish()",
        "begin_line": 266,
        "end_line": 269,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.routing.RuleRouter.__init__#275",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.RuleRouter",
        "signature": "tornado.routing.RuleRouter.__init__(self, rules=None)",
        "snippet": "    def __init__(self, rules=None):\n        \"\"\"Constructs a router from an ordered list of rules::\n\n            RuleRouter([\n                Rule(PathMatches(\"/handler\"), Target),\n                # ... more rules\n            ])\n\n        You can also omit explicit `Rule` constructor and use tuples of arguments::\n\n            RuleRouter([\n                (PathMatches(\"/handler\"), Target),\n            ])\n\n        `PathMatches` is a default matcher, so the example above can be simplified::\n\n            RuleRouter([\n                (\"/handler\", Target),\n            ])\n\n        In the examples above, ``Target`` can be a nested `Router` instance, an instance of\n        `~.httputil.HTTPServerConnectionDelegate` or an old-style callable,\n        accepting a request argument.\n\n        :arg rules: a list of `Rule` instances or tuples of `Rule`\n            constructor arguments.\n        \"\"\"\n        self.rules = []  # type: typing.List[Rule]\n        if rules:\n            self.add_rules(rules)",
        "begin_line": 275,
        "end_line": 304,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017391304347826088,
            "pseudo_dstar_susp": 0.0017857142857142857,
            "pseudo_tarantula_susp": 0.0012300123001230013,
            "pseudo_op2_susp": 0.0017857142857142857,
            "pseudo_barinel_susp": 0.0012300123001230013
        }
    },
    {
        "name": "tornado.routing.RuleRouter.add_rules#306",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.RuleRouter",
        "signature": "tornado.routing.RuleRouter.add_rules(self, rules)",
        "snippet": "    def add_rules(self, rules):\n        \"\"\"Appends new rules to the router.\n\n        :arg rules: a list of Rule instances (or tuples of arguments, which are\n            passed to Rule constructor).\n        \"\"\"\n        for rule in rules:\n            if isinstance(rule, (tuple, list)):\n                assert len(rule) in (2, 3, 4)\n                if isinstance(rule[0], basestring_type):\n                    rule = Rule(PathMatches(rule[0]), *rule[1:])\n                else:\n                    rule = Rule(*rule)\n\n            self.rules.append(self.process_rule(rule))",
        "begin_line": 306,
        "end_line": 320,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017391304347826088,
            "pseudo_dstar_susp": 0.0017857142857142857,
            "pseudo_tarantula_susp": 0.0012300123001230013,
            "pseudo_op2_susp": 0.0017857142857142857,
            "pseudo_barinel_susp": 0.0012300123001230013
        }
    },
    {
        "name": "tornado.routing.RuleRouter.process_rule#322",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.RuleRouter",
        "signature": "tornado.routing.RuleRouter.process_rule(self, rule)",
        "snippet": "    def process_rule(self, rule):\n        \"\"\"Override this method for additional preprocessing of each rule.\n\n        :arg Rule rule: a rule to be processed.\n        :returns: the same or modified Rule instance.\n        \"\"\"\n        return rule",
        "begin_line": 322,
        "end_line": 328,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017391304347826088,
            "pseudo_dstar_susp": 0.0017857142857142857,
            "pseudo_tarantula_susp": 0.0012300123001230013,
            "pseudo_op2_susp": 0.0017857142857142857,
            "pseudo_barinel_susp": 0.0012300123001230013
        }
    },
    {
        "name": "tornado.routing.RuleRouter.find_handler#330",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.RuleRouter",
        "signature": "tornado.routing.RuleRouter.find_handler(self, request, **kwargs)",
        "snippet": "    def find_handler(self, request, **kwargs):\n        for rule in self.rules:\n            target_params = rule.matcher.match(request)\n            if target_params is not None:\n                if rule.target_kwargs:\n                    target_params['target_kwargs'] = rule.target_kwargs\n\n                delegate = self.get_target_delegate(\n                    rule.target, request, **target_params)\n\n                if delegate is not None:\n                    return delegate\n\n        return None",
        "begin_line": 330,
        "end_line": 343,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005393743257820927,
            "pseudo_dstar_susp": 0.0006289308176100629,
            "pseudo_tarantula_susp": 0.0005115089514066496,
            "pseudo_op2_susp": 0.0006289308176100629,
            "pseudo_barinel_susp": 0.0005115089514066496
        }
    },
    {
        "name": "tornado.routing.RuleRouter.get_target_delegate#345",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.RuleRouter",
        "signature": "tornado.routing.RuleRouter.get_target_delegate(self, target, request, **target_params)",
        "snippet": "    def get_target_delegate(self, target, request, **target_params):\n        \"\"\"Returns an instance of `~.httputil.HTTPMessageDelegate` for a\n        Rule's target. This method is called by `~.find_handler` and can be\n        extended to provide additional target types.\n\n        :arg target: a Rule's target.\n        :arg httputil.HTTPServerRequest request: current request.\n        :arg target_params: additional parameters that can be useful\n            for `~.httputil.HTTPMessageDelegate` creation.\n        \"\"\"\n        if isinstance(target, Router):\n            return target.find_handler(request, **target_params)\n\n        elif isinstance(target, httputil.HTTPServerConnectionDelegate):\n            return target.start_request(request.server_connection, request.connection)\n\n        elif callable(target):\n            return _CallableAdapter(\n                partial(target, **target_params), request.connection\n            )\n\n        return None",
        "begin_line": 345,
        "end_line": 366,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005341880341880342,
            "pseudo_dstar_susp": 0.0006242197253433209,
            "pseudo_tarantula_susp": 0.0005078720162519045,
            "pseudo_op2_susp": 0.0006242197253433209,
            "pseudo_barinel_susp": 0.0005078720162519045
        }
    },
    {
        "name": "tornado.routing.ReversibleRuleRouter.__init__#377",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.ReversibleRuleRouter",
        "signature": "tornado.routing.ReversibleRuleRouter.__init__(self, rules=None)",
        "snippet": "    def __init__(self, rules=None):\n        self.named_rules = {}  # type: typing.Dict[str]\n        super(ReversibleRuleRouter, self).__init__(rules)",
        "begin_line": 377,
        "end_line": 379,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017391304347826088,
            "pseudo_dstar_susp": 0.0017857142857142857,
            "pseudo_tarantula_susp": 0.0012300123001230013,
            "pseudo_op2_susp": 0.0017857142857142857,
            "pseudo_barinel_susp": 0.0012300123001230013
        }
    },
    {
        "name": "tornado.routing.ReversibleRuleRouter.process_rule#381",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.ReversibleRuleRouter",
        "signature": "tornado.routing.ReversibleRuleRouter.process_rule(self, rule)",
        "snippet": "    def process_rule(self, rule):\n        rule = super(ReversibleRuleRouter, self).process_rule(rule)\n\n        if rule.name:\n            if rule.name in self.named_rules:\n                app_log.warning(\n                    \"Multiple handlers named %s; replacing previous value\",\n                    rule.name)\n            self.named_rules[rule.name] = rule\n\n        return rule",
        "begin_line": 381,
        "end_line": 391,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017391304347826088,
            "pseudo_dstar_susp": 0.0017857142857142857,
            "pseudo_tarantula_susp": 0.001869158878504673,
            "pseudo_op2_susp": 0.0017857142857142857,
            "pseudo_barinel_susp": 0.001869158878504673
        }
    },
    {
        "name": "tornado.routing.ReversibleRuleRouter.reverse_url#393",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.ReversibleRuleRouter",
        "signature": "tornado.routing.ReversibleRuleRouter.reverse_url(self, name, *args)",
        "snippet": "    def reverse_url(self, name, *args):\n        if name in self.named_rules:\n            return self.named_rules[name].matcher.reverse(*args)\n\n        for rule in self.rules:\n            if isinstance(rule.target, ReversibleRouter):\n                reversed_url = rule.target.reverse_url(name, *args)\n                if reversed_url is not None:\n                    return reversed_url\n\n        return None",
        "begin_line": 393,
        "end_line": 403,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.routing.Rule.__init__#409",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.Rule",
        "signature": "tornado.routing.Rule.__init__(self, matcher, target, target_kwargs=None, name=None)",
        "snippet": "    def __init__(self, matcher, target, target_kwargs=None, name=None):\n        \"\"\"Constructs a Rule instance.\n\n        :arg Matcher matcher: a `Matcher` instance used for determining\n            whether the rule should be considered a match for a specific\n            request.\n        :arg target: a Rule's target (typically a ``RequestHandler`` or\n            `~.httputil.HTTPServerConnectionDelegate` subclass or even a nested `Router`,\n            depending on routing implementation).\n        :arg dict target_kwargs: a dict of parameters that can be useful\n            at the moment of target instantiation (for example, ``status_code``\n            for a ``RequestHandler`` subclass). They end up in\n            ``target_params['target_kwargs']`` of `RuleRouter.get_target_delegate`\n            method.\n        :arg str name: the name of the rule that can be used to find it\n            in `ReversibleRouter.reverse_url` implementation.\n        \"\"\"\n        if isinstance(target, str):\n            # import the Module and instantiate the class\n            # Must be a fully qualified name (module.ClassName)\n            target = import_object(target)\n\n        self.matcher = matcher  # type: Matcher\n        self.target = target\n        self.target_kwargs = target_kwargs if target_kwargs else {}\n        self.name = name",
        "begin_line": 409,
        "end_line": 434,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016556291390728477,
            "pseudo_dstar_susp": 0.001697792869269949,
            "pseudo_tarantula_susp": 0.0011876484560570072,
            "pseudo_op2_susp": 0.001697792869269949,
            "pseudo_barinel_susp": 0.0011876484560570072
        }
    },
    {
        "name": "tornado.routing.Rule.reverse#436",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.Rule",
        "signature": "tornado.routing.Rule.reverse(self, *args)",
        "snippet": "    def reverse(self, *args):\n        return self.matcher.reverse(*args)",
        "begin_line": 436,
        "end_line": 437,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.routing.AnyMatches.match#468",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.AnyMatches",
        "signature": "tornado.routing.AnyMatches.match(self, request)",
        "snippet": "    def match(self, request):\n        return {}",
        "begin_line": 468,
        "end_line": 469,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005341880341880342,
            "pseudo_dstar_susp": 0.0006242197253433209,
            "pseudo_tarantula_susp": 0.0005078720162519045,
            "pseudo_op2_susp": 0.0006242197253433209,
            "pseudo_barinel_susp": 0.0005078720162519045
        }
    },
    {
        "name": "tornado.routing.HostMatches.__init__#475",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.HostMatches",
        "signature": "tornado.routing.HostMatches.__init__(self, host_pattern)",
        "snippet": "    def __init__(self, host_pattern):\n        if isinstance(host_pattern, basestring_type):\n            if not host_pattern.endswith(\"$\"):\n                host_pattern += \"$\"\n            self.host_pattern = re.compile(host_pattern)\n        else:\n            self.host_pattern = host_pattern",
        "begin_line": 475,
        "end_line": 481,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019275250578257516,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.routing.HostMatches.match#483",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.HostMatches",
        "signature": "tornado.routing.HostMatches.match(self, request)",
        "snippet": "    def match(self, request):\n        if self.host_pattern.match(request.host_name):\n            return {}\n\n        return None",
        "begin_line": 483,
        "end_line": 487,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.routing.DefaultHostMatches.__init__#495",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.DefaultHostMatches",
        "signature": "tornado.routing.DefaultHostMatches.__init__(self, application, host_pattern)",
        "snippet": "    def __init__(self, application, host_pattern):\n        self.application = application\n        self.host_pattern = host_pattern",
        "begin_line": 495,
        "end_line": 497,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.routing.DefaultHostMatches.match#499",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.DefaultHostMatches",
        "signature": "tornado.routing.DefaultHostMatches.match(self, request)",
        "snippet": "    def match(self, request):\n        # Look for default host if not behind load balancer (for debugging)\n        if \"X-Real-Ip\" not in request.headers:\n            if self.host_pattern.match(self.application.default_host):\n                return {}\n        return None",
        "begin_line": 499,
        "end_line": 504,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.routing.PathMatches.__init__#510",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.PathMatches",
        "signature": "tornado.routing.PathMatches.__init__(self, path_pattern)",
        "snippet": "    def __init__(self, path_pattern):\n        if isinstance(path_pattern, basestring_type):\n            if not path_pattern.endswith('$'):\n                path_pattern += '$'\n            self.regex = re.compile(path_pattern)\n        else:\n            self.regex = path_pattern\n\n        assert len(self.regex.groupindex) in (0, self.regex.groups), \\\n            (\"groups in url regexes must either be all named or all \"\n             \"positional: %r\" % self.regex.pattern)\n\n        self._path, self._group_count = self._find_groups()",
        "begin_line": 510,
        "end_line": 522,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001893939393939394,
            "pseudo_dstar_susp": 0.001949317738791423,
            "pseudo_tarantula_susp": 0.0013245033112582781,
            "pseudo_op2_susp": 0.001949317738791423,
            "pseudo_barinel_susp": 0.0013245033112582781
        }
    },
    {
        "name": "tornado.routing.PathMatches.match#524",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.PathMatches",
        "signature": "tornado.routing.PathMatches.match(self, request)",
        "snippet": "    def match(self, request):\n        match = self.regex.match(request.path)\n        if match is None:\n            return None\n        if not self.regex.groups:\n            return {}\n\n        path_args, path_kwargs = [], {}\n\n        # Pass matched groups to the handler.  Since\n        # match.groups() includes both named and\n        # unnamed groups, we want to use either groups\n        # or groupdict but not both.\n        if self.regex.groupindex:\n            path_kwargs = dict(\n                (str(k), _unquote_or_none(v))\n                for (k, v) in match.groupdict().items())\n        else:\n            path_args = [_unquote_or_none(s) for s in match.groups()]\n\n        return dict(path_args=path_args, path_kwargs=path_kwargs)",
        "begin_line": 524,
        "end_line": 544,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005580357142857143,
            "pseudo_dstar_susp": 0.0006297229219143577,
            "pseudo_tarantula_susp": 0.0005763688760806917,
            "pseudo_op2_susp": 0.0006297229219143577,
            "pseudo_barinel_susp": 0.0005763688760806917
        }
    },
    {
        "name": "tornado.routing.PathMatches.reverse#546",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.PathMatches",
        "signature": "tornado.routing.PathMatches.reverse(self, *args)",
        "snippet": "    def reverse(self, *args):\n        if self._path is None:\n            raise ValueError(\"Cannot reverse url regex \" + self.regex.pattern)\n        assert len(args) == self._group_count, \"required number of arguments \" \\\n                                               \"not found\"\n        if not len(args):\n            return self._path\n        converted_args = []\n        for a in args:\n            if not isinstance(a, (unicode_type, bytes)):\n                a = str(a)\n            converted_args.append(url_escape(utf8(a), plus=False))\n        return self._path % tuple(converted_args)",
        "begin_line": 546,
        "end_line": 558,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.routing.PathMatches._find_groups#560",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.PathMatches",
        "signature": "tornado.routing.PathMatches._find_groups(self)",
        "snippet": "    def _find_groups(self):\n        \"\"\"Returns a tuple (reverse string, group count) for a url.\n\n        For example: Given the url pattern /([0-9]{4})/([a-z-]+)/, this method\n        would return ('/%s/%s/', 2).\n        \"\"\"\n        pattern = self.regex.pattern\n        if pattern.startswith('^'):\n            pattern = pattern[1:]\n        if pattern.endswith('$'):\n            pattern = pattern[:-1]\n\n        if self.regex.groups != pattern.count('('):\n            # The pattern is too complicated for our simplistic matching,\n            # so we can't support reversing it.\n            return None, None\n\n        pieces = []\n        for fragment in pattern.split('('):\n            if ')' in fragment:\n                paren_loc = fragment.index(')')\n                if paren_loc >= 0:\n                    pieces.append('%s' + fragment[paren_loc + 1:])\n            else:\n                try:\n                    unescaped_fragment = re_unescape(fragment)\n                except ValueError:\n                    # If we can't unescape part of it, we can't\n                    # reverse this url.\n                    return (None, None)\n                pieces.append(unescaped_fragment)\n\n        return ''.join(pieces), self.regex.groups",
        "begin_line": 560,
        "end_line": 592,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001890359168241966,
            "pseudo_dstar_susp": 0.0019455252918287938,
            "pseudo_tarantula_susp": 0.0013227513227513227,
            "pseudo_op2_susp": 0.0019455252918287938,
            "pseudo_barinel_susp": 0.0013227513227513227
        }
    },
    {
        "name": "tornado.routing.URLSpec.__init__#602",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing.URLSpec",
        "signature": "tornado.routing.URLSpec.__init__(self, pattern, handler, kwargs=None, name=None)",
        "snippet": "    def __init__(self, pattern, handler, kwargs=None, name=None):\n        \"\"\"Parameters:\n\n        * ``pattern``: Regular expression to be matched. Any capturing\n          groups in the regex will be passed in to the handler's\n          get/post/etc methods as arguments (by keyword if named, by\n          position if unnamed. Named and unnamed capturing groups\n          may not be mixed in the same rule).\n\n        * ``handler``: `~.web.RequestHandler` subclass to be invoked.\n\n        * ``kwargs`` (optional): A dictionary of additional arguments\n          to be passed to the handler's constructor.\n\n        * ``name`` (optional): A name for this handler.  Used by\n          `~.web.Application.reverse_url`.\n\n        \"\"\"\n        super(URLSpec, self).__init__(PathMatches(pattern), handler, kwargs, name)\n\n        self.regex = self.matcher.regex\n        self.handler_class = self.target\n        self.kwargs = kwargs",
        "begin_line": 602,
        "end_line": 624,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011904761904761906,
            "pseudo_dstar_susp": 0.0008968609865470852,
            "pseudo_tarantula_susp": 0.0017035775127768314,
            "pseudo_op2_susp": 0.0008968609865470852,
            "pseudo_barinel_susp": 0.0017035775127768314
        }
    },
    {
        "name": "tornado.routing._unquote_or_none#632",
        "src_path": "tornado/routing.py",
        "class_name": "tornado.routing",
        "signature": "tornado.routing._unquote_or_none(s)",
        "snippet": "def _unquote_or_none(s):\n    \"\"\"None-safe wrapper around url_unescape to handle unmatched optional\n    groups correctly.\n\n    Note that args are passed as bytes so the handler can decide what\n    encoding to use.\n    \"\"\"\n    if s is None:\n        return s\n    return url_unescape(s, encoding=None, plus=False)",
        "begin_line": 632,
        "end_line": 641,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.netutil.bind_sockets#80",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil",
        "signature": "tornado.netutil.bind_sockets(port, address=None, family=socket.AF_UNSPEC, backlog=_DEFAULT_BACKLOG, flags=None, reuse_port=False)",
        "snippet": "def bind_sockets(port, address=None, family=socket.AF_UNSPEC,\n                 backlog=_DEFAULT_BACKLOG, flags=None, reuse_port=False):\n    \"\"\"Creates listening sockets bound to the given port and address.\n\n    Returns a list of socket objects (multiple sockets are returned if\n    the given address maps to multiple IP addresses, which is most common\n    for mixed IPv4 and IPv6 use).\n\n    Address may be either an IP address or hostname.  If it's a hostname,\n    the server will listen on all IP addresses associated with the\n    name.  Address may be an empty string or None to listen on all\n    available interfaces.  Family may be set to either `socket.AF_INET`\n    or `socket.AF_INET6` to restrict to IPv4 or IPv6 addresses, otherwise\n    both will be used if available.\n\n    The ``backlog`` argument has the same meaning as for\n    `socket.listen() <socket.socket.listen>`.\n\n    ``flags`` is a bitmask of AI_* flags to `~socket.getaddrinfo`, like\n    ``socket.AI_PASSIVE | socket.AI_NUMERICHOST``.\n\n    ``reuse_port`` option sets ``SO_REUSEPORT`` option for every socket\n    in the list. If your platform doesn't support this option ValueError will\n    be raised.\n    \"\"\"\n    if reuse_port and not hasattr(socket, \"SO_REUSEPORT\"):\n        raise ValueError(\"the platform doesn't support SO_REUSEPORT\")\n\n    sockets = []\n    if address == \"\":\n        address = None\n    if not socket.has_ipv6 and family == socket.AF_UNSPEC:\n        # Python can be compiled with --disable-ipv6, which causes\n        # operations on AF_INET6 sockets to fail, but does not\n        # automatically exclude those results from getaddrinfo\n        # results.\n        # http://bugs.python.org/issue16208\n        family = socket.AF_INET\n    if flags is None:\n        flags = socket.AI_PASSIVE\n    bound_port = None\n    for res in set(socket.getaddrinfo(address, port, family, socket.SOCK_STREAM,\n                                      0, flags)):\n        af, socktype, proto, canonname, sockaddr = res\n        if (sys.platform == 'darwin' and address == 'localhost' and\n                af == socket.AF_INET6 and sockaddr[3] != 0):\n            # Mac OS X includes a link-local address fe80::1%lo0 in the\n            # getaddrinfo results for 'localhost'.  However, the firewall\n            # doesn't understand that this is a local address and will\n            # prompt for access (often repeatedly, due to an apparent\n            # bug in its ability to remember granting access to an\n            # application). Skip these addresses.\n            continue\n        try:\n            sock = socket.socket(af, socktype, proto)\n        except socket.error as e:\n            if errno_from_exception(e) == errno.EAFNOSUPPORT:\n                continue\n            raise\n        set_close_exec(sock.fileno())\n        if os.name != 'nt':\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        if reuse_port:\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n        if af == socket.AF_INET6:\n            # On linux, ipv6 sockets accept ipv4 too by default,\n            # but this makes it impossible to bind to both\n            # 0.0.0.0 in ipv4 and :: in ipv6.  On other systems,\n            # separate sockets *must* be used to listen for both ipv4\n            # and ipv6.  For consistency, always disable ipv4 on our\n            # ipv6 sockets and use a separate ipv4 socket when needed.\n            #\n            # Python 2.x on windows doesn't have IPPROTO_IPV6.\n            if hasattr(socket, \"IPPROTO_IPV6\"):\n                sock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 1)\n\n        # automatic port allocation with port=None\n        # should bind on the same port on IPv4 and IPv6\n        host, requested_port = sockaddr[:2]\n        if requested_port == 0 and bound_port is not None:\n            sockaddr = tuple([host, bound_port] + list(sockaddr[2:]))\n\n        sock.setblocking(0)\n        sock.bind(sockaddr)\n        bound_port = sock.getsockname()[1]\n        sock.listen(backlog)\n        sockets.append(sock)\n    return sockets",
        "begin_line": 80,
        "end_line": 167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007142857142857143,
            "pseudo_dstar_susp": 0.047619047619047616,
            "pseudo_tarantula_susp": 0.0038461538461538464,
            "pseudo_op2_susp": 0.047619047619047616,
            "pseudo_barinel_susp": 0.0038461538461538464
        }
    },
    {
        "name": "tornado.netutil.bind_unix_socket#171",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil",
        "signature": "tornado.netutil.bind_unix_socket(file, mode=384, backlog=_DEFAULT_BACKLOG)",
        "snippet": "    def bind_unix_socket(file, mode=0o600, backlog=_DEFAULT_BACKLOG):\n        \"\"\"Creates a listening unix socket.\n\n        If a socket with the given name already exists, it will be deleted.\n        If any other file with that name exists, an exception will be\n        raised.\n\n        Returns a socket object (not a list of socket objects like\n        `bind_sockets`)\n        \"\"\"\n        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n        set_close_exec(sock.fileno())\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.setblocking(0)\n        try:\n            st = os.stat(file)\n        except OSError as err:\n            if errno_from_exception(err) != errno.ENOENT:\n                raise\n        else:\n            if stat.S_ISSOCK(st.st_mode):\n                os.remove(file)\n            else:\n                raise ValueError(\"File %s exists and is not a socket\", file)\n        sock.bind(file)\n        os.chmod(file, mode)\n        sock.listen(backlog)\n        return sock",
        "begin_line": 171,
        "end_line": 198,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0006430868167202572,
            "pseudo_dstar_susp": 0.00039984006397441024,
            "pseudo_tarantula_susp": 0.0038461538461538464,
            "pseudo_op2_susp": 0.00039984006397441024,
            "pseudo_barinel_susp": 0.0038461538461538464
        }
    },
    {
        "name": "tornado.netutil.add_accept_handler#201",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil",
        "signature": "tornado.netutil.add_accept_handler(sock, callback)",
        "snippet": "def add_accept_handler(sock, callback):\n    \"\"\"Adds an `.IOLoop` event handler to accept new connections on ``sock``.\n\n    When a connection is accepted, ``callback(connection, address)`` will\n    be run (``connection`` is a socket object, and ``address`` is the\n    address of the other end of the connection).  Note that this signature\n    is different from the ``callback(fd, events)`` signature used for\n    `.IOLoop` handlers.\n\n    A callable is returned which, when called, will remove the `.IOLoop`\n    event handler and stop processing further incoming connections.\n\n    .. versionchanged:: 5.0\n       The ``io_loop`` argument (deprecated since version 4.1) has been removed.\n\n    .. versionchanged:: 5.0\n       A callable is returned (``None`` was returned before).\n    \"\"\"\n    io_loop = IOLoop.current()\n    removed = [False]\n\n    def accept_handler(fd, events):\n        # More connections may come in while we're handling callbacks;\n        # to prevent starvation of other tasks we must limit the number\n        # of connections we accept at a time.  Ideally we would accept\n        # up to the number of connections that were waiting when we\n        # entered this method, but this information is not available\n        # (and rearranging this method to call accept() as many times\n        # as possible before running any callbacks would have adverse\n        # effects on load balancing in multiprocess configurations).\n        # Instead, we use the (default) listen backlog as a rough\n        # heuristic for the number of connections we can reasonably\n        # accept at once.\n        for i in xrange(_DEFAULT_BACKLOG):\n            if removed[0]:\n                # The socket was probably closed\n                return\n            try:\n                connection, address = sock.accept()\n            except socket.error as e:\n                # _ERRNO_WOULDBLOCK indicate we have accepted every\n                # connection that is available.\n                if errno_from_exception(e) in _ERRNO_WOULDBLOCK:\n                    return\n                # ECONNABORTED indicates that there was a connection\n                # but it was closed while still in the accept queue.\n                # (observed on FreeBSD).\n                if errno_from_exception(e) == errno.ECONNABORTED:\n                    continue\n                raise\n            set_close_exec(connection.fileno())\n            callback(connection, address)\n\n    def remove_handler():\n        io_loop.remove_handler(sock)\n        removed[0] = True\n\n    io_loop.add_handler(sock, accept_handler, IOLoop.READ)\n    return remove_handler",
        "begin_line": 201,
        "end_line": 259,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005681818181818182,
            "pseudo_dstar_susp": 0.017857142857142856,
            "pseudo_tarantula_susp": 0.002512562814070352,
            "pseudo_op2_susp": 0.017857142857142856,
            "pseudo_barinel_susp": 0.002512562814070352
        }
    },
    {
        "name": "tornado.netutil.accept_handler#222",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil",
        "signature": "tornado.netutil.accept_handler(fd, events)",
        "snippet": "    def accept_handler(fd, events):\n        # More connections may come in while we're handling callbacks;\n        # to prevent starvation of other tasks we must limit the number\n        # of connections we accept at a time.  Ideally we would accept\n        # up to the number of connections that were waiting when we\n        # entered this method, but this information is not available\n        # (and rearranging this method to call accept() as many times\n        # as possible before running any callbacks would have adverse\n        # effects on load balancing in multiprocess configurations).\n        # Instead, we use the (default) listen backlog as a rough\n        # heuristic for the number of connections we can reasonably\n        # accept at once.\n        for i in xrange(_DEFAULT_BACKLOG):\n            if removed[0]:\n                # The socket was probably closed\n                return\n            try:\n                connection, address = sock.accept()\n            except socket.error as e:\n                # _ERRNO_WOULDBLOCK indicate we have accepted every\n                # connection that is available.\n                if errno_from_exception(e) in _ERRNO_WOULDBLOCK:\n                    return\n                # ECONNABORTED indicates that there was a connection\n                # but it was closed while still in the accept queue.\n                # (observed on FreeBSD).\n                if errno_from_exception(e) == errno.ECONNABORTED:\n                    continue\n                raise\n            set_close_exec(connection.fileno())\n            callback(connection, address)",
        "begin_line": 222,
        "end_line": 252,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010638297872340425,
            "pseudo_dstar_susp": 0.5,
            "pseudo_tarantula_susp": 0.002421307506053269,
            "pseudo_op2_susp": 0.5,
            "pseudo_barinel_susp": 0.002421307506053269
        }
    },
    {
        "name": "tornado.netutil.remove_handler#254",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil",
        "signature": "tornado.netutil.remove_handler()",
        "snippet": "    def remove_handler():\n        io_loop.remove_handler(sock)\n        removed[0] = True",
        "begin_line": 254,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005780346820809248,
            "pseudo_dstar_susp": 0.2,
            "pseudo_tarantula_susp": 0.0016750418760469012,
            "pseudo_op2_susp": 0.2,
            "pseudo_barinel_susp": 0.0016750418760469012
        }
    },
    {
        "name": "tornado.netutil.is_valid_ip#262",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil",
        "signature": "tornado.netutil.is_valid_ip(ip)",
        "snippet": "def is_valid_ip(ip):\n    \"\"\"Returns true if the given string is a well-formed IP address.\n\n    Supports IPv4 and IPv6.\n    \"\"\"\n    if not ip or '\\x00' in ip:\n        # getaddrinfo resolves empty strings to localhost, and truncates\n        # on zero bytes.\n        return False\n    try:\n        res = socket.getaddrinfo(ip, 0, socket.AF_UNSPEC,\n                                 socket.SOCK_STREAM,\n                                 0, socket.AI_NUMERICHOST)\n        return bool(res)\n    except socket.gaierror as e:\n        if e.args[0] == socket.EAI_NONAME:\n            return False\n        raise\n    return True",
        "begin_line": 262,
        "end_line": 280,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.netutil.Resolver.configurable_base#307",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.Resolver",
        "signature": "tornado.netutil.Resolver.configurable_base(cls)",
        "snippet": "    def configurable_base(cls):\n        return Resolver",
        "begin_line": 307,
        "end_line": 308,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019011406844106464,
            "pseudo_dstar_susp": 0.00202020202020202,
            "pseudo_tarantula_susp": 0.0011806375442739079,
            "pseudo_op2_susp": 0.00202020202020202,
            "pseudo_barinel_susp": 0.0011806375442739079
        }
    },
    {
        "name": "tornado.netutil.Resolver.configurable_default#311",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.Resolver",
        "signature": "tornado.netutil.Resolver.configurable_default(cls)",
        "snippet": "    def configurable_default(cls):\n        return DefaultExecutorResolver",
        "begin_line": 311,
        "end_line": 312,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.netutil.Resolver.close#338",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.Resolver",
        "signature": "tornado.netutil.Resolver.close(self)",
        "snippet": "    def close(self):\n        \"\"\"Closes the `Resolver`, freeing any resources used.\n\n        .. versionadded:: 3.1\n\n        \"\"\"\n        pass",
        "begin_line": 338,
        "end_line": 344,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014970059880239522,
            "pseudo_dstar_susp": 0.0015105740181268882,
            "pseudo_tarantula_susp": 0.001081081081081081,
            "pseudo_op2_susp": 0.0015105740181268882,
            "pseudo_barinel_susp": 0.001081081081081081
        }
    },
    {
        "name": "tornado.netutil._resolve_addr#347",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil",
        "signature": "tornado.netutil._resolve_addr(host, port, family=socket.AF_UNSPEC)",
        "snippet": "def _resolve_addr(host, port, family=socket.AF_UNSPEC):\n    # On Solaris, getaddrinfo fails if the given port is not found\n    # in /etc/services and no socket type is given, so we must pass\n    # one here.  The socket type used here doesn't seem to actually\n    # matter (we discard the one we get back in the results),\n    # so the addresses we return should still be usable with SOCK_DGRAM.\n    addrinfo = socket.getaddrinfo(host, port, family, socket.SOCK_STREAM)\n    results = []\n    for family, socktype, proto, canonname, address in addrinfo:\n        results.append((family, address))\n    return results",
        "begin_line": 347,
        "end_line": 357,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010638297872340426,
            "pseudo_dstar_susp": 0.0011933174224343676,
            "pseudo_tarantula_susp": 0.0008756567425569177,
            "pseudo_op2_susp": 0.0011933174224343676,
            "pseudo_barinel_susp": 0.0008756567425569177
        }
    },
    {
        "name": "tornado.netutil.DefaultExecutorResolver.resolve#366",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.DefaultExecutorResolver",
        "signature": "tornado.netutil.DefaultExecutorResolver.resolve(self, host, port, family=socket.AF_UNSPEC)",
        "snippet": "    def resolve(self, host, port, family=socket.AF_UNSPEC):\n        result = yield IOLoop.current().run_in_executor(\n            None, _resolve_addr, host, port, family)\n        raise gen.Return(result)",
        "begin_line": 366,
        "end_line": 369,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010845986984815619,
            "pseudo_dstar_susp": 0.0012165450121654502,
            "pseudo_tarantula_susp": 0.0009149130832570906,
            "pseudo_op2_susp": 0.0012165450121654502,
            "pseudo_barinel_susp": 0.0009149130832570906
        }
    },
    {
        "name": "tornado.netutil.ExecutorResolver.initialize#389",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.ExecutorResolver",
        "signature": "tornado.netutil.ExecutorResolver.initialize(self, executor=None, close_executor=True)",
        "snippet": "    def initialize(self, executor=None, close_executor=True):\n        self.io_loop = IOLoop.current()\n        if executor is not None:\n            self.executor = executor\n            self.close_executor = close_executor\n        else:\n            self.executor = dummy_executor\n            self.close_executor = False",
        "begin_line": 389,
        "end_line": 396,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.netutil.ExecutorResolver.close#398",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.ExecutorResolver",
        "signature": "tornado.netutil.ExecutorResolver.close(self)",
        "snippet": "    def close(self):\n        if self.close_executor:\n            self.executor.shutdown()\n        self.executor = None",
        "begin_line": 398,
        "end_line": 401,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.netutil.ExecutorResolver.resolve#404",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.ExecutorResolver",
        "signature": "tornado.netutil.ExecutorResolver.resolve(self, host, port, family=socket.AF_UNSPEC)",
        "snippet": "    def resolve(self, host, port, family=socket.AF_UNSPEC):\n        return _resolve_addr(host, port, family)",
        "begin_line": 404,
        "end_line": 405,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001775568181818182,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.netutil.BlockingResolver.initialize#418",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.BlockingResolver",
        "signature": "tornado.netutil.BlockingResolver.initialize(self)",
        "snippet": "    def initialize(self):\n        super(BlockingResolver, self).initialize()",
        "begin_line": 418,
        "end_line": 419,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001836884643644379,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.netutil.ThreadedResolver.initialize#445",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.ThreadedResolver",
        "signature": "tornado.netutil.ThreadedResolver.initialize(self, num_threads=10)",
        "snippet": "    def initialize(self, num_threads=10):\n        threadpool = ThreadedResolver._create_threadpool(num_threads)\n        super(ThreadedResolver, self).initialize(\n            executor=threadpool, close_executor=False)",
        "begin_line": 445,
        "end_line": 448,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.netutil.ThreadedResolver._create_threadpool#451",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.ThreadedResolver",
        "signature": "tornado.netutil.ThreadedResolver._create_threadpool(cls, num_threads)",
        "snippet": "    def _create_threadpool(cls, num_threads):\n        pid = os.getpid()\n        if cls._threadpool_pid != pid:\n            # Threads cannot survive after a fork, so if our pid isn't what it\n            # was when we created the pool then delete it.\n            cls._threadpool = None\n        if cls._threadpool is None:\n            from concurrent.futures import ThreadPoolExecutor\n            cls._threadpool = ThreadPoolExecutor(num_threads)\n            cls._threadpool_pid = pid\n        return cls._threadpool",
        "begin_line": 451,
        "end_line": 461,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.netutil.OverrideResolver.initialize#486",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.OverrideResolver",
        "signature": "tornado.netutil.OverrideResolver.initialize(self, resolver, mapping)",
        "snippet": "    def initialize(self, resolver, mapping):\n        self.resolver = resolver\n        self.mapping = mapping",
        "begin_line": 486,
        "end_line": 488,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.netutil.OverrideResolver.close#490",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.OverrideResolver",
        "signature": "tornado.netutil.OverrideResolver.close(self)",
        "snippet": "    def close(self):\n        self.resolver.close()",
        "begin_line": 490,
        "end_line": 491,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.netutil.OverrideResolver.resolve#493",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil.OverrideResolver",
        "signature": "tornado.netutil.OverrideResolver.resolve(self, host, port, family=socket.AF_UNSPEC, *args, **kwargs)",
        "snippet": "    def resolve(self, host, port, family=socket.AF_UNSPEC, *args, **kwargs):\n        if (host, port, family) in self.mapping:\n            host, port = self.mapping[(host, port, family)]\n        elif (host, port) in self.mapping:\n            host, port = self.mapping[(host, port)]\n        elif host in self.mapping:\n            host = self.mapping[host]\n        return self.resolver.resolve(host, port, family, *args, **kwargs)",
        "begin_line": 493,
        "end_line": 500,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.netutil.ssl_options_to_context#510",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil",
        "signature": "tornado.netutil.ssl_options_to_context(ssl_options)",
        "snippet": "def ssl_options_to_context(ssl_options):\n    \"\"\"Try to convert an ``ssl_options`` dictionary to an\n    `~ssl.SSLContext` object.\n\n    The ``ssl_options`` dictionary contains keywords to be passed to\n    `ssl.wrap_socket`.  In Python 2.7.9+, `ssl.SSLContext` objects can\n    be used instead.  This function converts the dict form to its\n    `~ssl.SSLContext` equivalent, and may be used when a component which\n    accepts both forms needs to upgrade to the `~ssl.SSLContext` version\n    to use features like SNI or NPN.\n    \"\"\"\n    if isinstance(ssl_options, ssl.SSLContext):\n        return ssl_options\n    assert isinstance(ssl_options, dict)\n    assert all(k in _SSL_CONTEXT_KEYWORDS for k in ssl_options), ssl_options\n    # Can't use create_default_context since this interface doesn't\n    # tell us client vs server.\n    context = ssl.SSLContext(\n        ssl_options.get('ssl_version', ssl.PROTOCOL_SSLv23))\n    if 'certfile' in ssl_options:\n        context.load_cert_chain(ssl_options['certfile'], ssl_options.get('keyfile', None))\n    if 'cert_reqs' in ssl_options:\n        context.verify_mode = ssl_options['cert_reqs']\n    if 'ca_certs' in ssl_options:\n        context.load_verify_locations(ssl_options['ca_certs'])\n    if 'ciphers' in ssl_options:\n        context.set_ciphers(ssl_options['ciphers'])\n    if hasattr(ssl, 'OP_NO_COMPRESSION'):\n        # Disable TLS compression to avoid CRIME and related attacks.\n        # This constant depends on openssl version 1.0.\n        # TODO: Do we need to do this ourselves or can we trust\n        # the defaults?\n        context.options |= ssl.OP_NO_COMPRESSION\n    return context",
        "begin_line": 510,
        "end_line": 543,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 1.0,
            "pseudo_dstar_susp": 0.08333333333333333,
            "pseudo_tarantula_susp": 0.024390243902439025,
            "pseudo_op2_susp": 0.08333333333333333,
            "pseudo_barinel_susp": 0.024390243902439025
        }
    },
    {
        "name": "tornado.netutil.ssl_wrap_socket#546",
        "src_path": "tornado/netutil.py",
        "class_name": "tornado.netutil",
        "signature": "tornado.netutil.ssl_wrap_socket(socket, ssl_options, server_hostname=None, **kwargs)",
        "snippet": "def ssl_wrap_socket(socket, ssl_options, server_hostname=None, **kwargs):\n    \"\"\"Returns an ``ssl.SSLSocket`` wrapping the given socket.\n\n    ``ssl_options`` may be either an `ssl.SSLContext` object or a\n    dictionary (as accepted by `ssl_options_to_context`).  Additional\n    keyword arguments are passed to ``wrap_socket`` (either the\n    `~ssl.SSLContext` method or the `ssl` module function as\n    appropriate).\n    \"\"\"\n    context = ssl_options_to_context(ssl_options)\n    if ssl.HAS_SNI:\n        # In python 3.4, wrap_socket only accepts the server_hostname\n        # argument if HAS_SNI is true.\n        # TODO: add a unittest (python added server-side SNI support in 3.4)\n        # In the meantime it can be manually tested with\n        # python3 -m tornado.httpclient https://sni.velox.ch\n        return context.wrap_socket(socket, server_hostname=server_hostname,\n                                   **kwargs)\n    else:\n        return context.wrap_socket(socket, **kwargs)",
        "begin_line": 546,
        "end_line": 565,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.25,
            "pseudo_dstar_susp": 0.003134796238244514,
            "pseudo_tarantula_susp": 0.011764705882352941,
            "pseudo_op2_susp": 0.003134796238244514,
            "pseudo_barinel_susp": 0.011764705882352941
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.__init__#140",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.__init__(self, application, request, **kwargs)",
        "snippet": "    def __init__(self, application, request, **kwargs):\n        super(WebSocketHandler, self).__init__(application, request, **kwargs)\n        self.ws_connection = None\n        self.close_code = None\n        self.close_reason = None\n        self.stream = None\n        self._on_close_called = False",
        "begin_line": 140,
        "end_line": 146,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015008254539996998,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.get#149",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.get(self, *args, **kwargs)",
        "snippet": "    def get(self, *args, **kwargs):\n        self.open_args = args\n        self.open_kwargs = kwargs\n\n        # Upgrade header should be present and should be equal to WebSocket\n        if self.request.headers.get(\"Upgrade\", \"\").lower() != 'websocket':\n            self.set_status(400)\n            log_msg = \"Can \\\"Upgrade\\\" only to \\\"WebSocket\\\".\"\n            self.finish(log_msg)\n            gen_log.debug(log_msg)\n            return\n\n        # Connection header should be upgrade.\n        # Some proxy servers/load balancers\n        # might mess with it.\n        headers = self.request.headers\n        connection = map(lambda s: s.strip().lower(),\n                         headers.get(\"Connection\", \"\").split(\",\"))\n        if 'upgrade' not in connection:\n            self.set_status(400)\n            log_msg = \"\\\"Connection\\\" must be \\\"Upgrade\\\".\"\n            self.finish(log_msg)\n            gen_log.debug(log_msg)\n            return\n\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n\n        # If there was an origin header, check to make sure it matches\n        # according to check_origin. When the origin is None, we assume it\n        # did not come from a browser and that it can be passed on.\n        if origin is not None and not self.check_origin(origin):\n            self.set_status(403)\n            log_msg = \"Cross origin websockets not allowed\"\n            self.finish(log_msg)\n            gen_log.debug(log_msg)\n            return\n\n        self.ws_connection = self.get_websocket_protocol()\n        if self.ws_connection:\n            self.ws_connection.accept_connection()\n        else:\n            self.set_status(426, \"Upgrade Required\")\n            self.set_header(\"Sec-WebSocket-Version\", \"7, 8, 13\")\n            self.finish()",
        "begin_line": 149,
        "end_line": 199,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.ping_interval#204",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.ping_interval(self)",
        "snippet": "    def ping_interval(self):\n        \"\"\"The interval for websocket keep-alive pings.\n\n        Set websocket_ping_interval = 0 to disable pings.\n        \"\"\"\n        return self.settings.get('websocket_ping_interval', None)",
        "begin_line": 204,
        "end_line": 209,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015730690577316344,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.ping_timeout#212",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.ping_timeout(self)",
        "snippet": "    def ping_timeout(self):\n        \"\"\"If no ping is received in this many seconds,\n        close the websocket connection (VPNs, etc. can fail to cleanly close ws connections).\n        Default is max of 3 pings or 30 seconds.\n        \"\"\"\n        return self.settings.get('websocket_ping_timeout', None)",
        "begin_line": 212,
        "end_line": 217,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.max_message_size#220",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.max_message_size(self)",
        "snippet": "    def max_message_size(self):\n        \"\"\"Maximum allowed message size.\n\n        If the remote peer sends a message larger than this, the connection\n        will be closed.\n\n        Default is 10MiB.\n        \"\"\"\n        return self.settings.get('websocket_max_message_size', None)",
        "begin_line": 220,
        "end_line": 228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016017940092904052,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.write_message#230",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.write_message(self, message, binary=False)",
        "snippet": "    def write_message(self, message, binary=False):\n        \"\"\"Sends the given message to the client of this Web Socket.\n\n        The message may be either a string or a dict (which will be\n        encoded as json).  If the ``binary`` argument is false, the\n        message will be sent as utf8; in binary mode any byte string\n        is allowed.\n\n        If the connection is already closed, raises `WebSocketClosedError`.\n        Returns a `.Future` which can be used for flow control.\n\n        .. versionchanged:: 3.2\n           `WebSocketClosedError` was added (previously a closed connection\n           would raise an `AttributeError`)\n\n        .. versionchanged:: 4.3\n           Returns a `.Future` which can be used for flow control.\n\n        .. versionchanged:: 5.0\n           Consistently raises `WebSocketClosedError`. Previously could\n           sometimes raise `.StreamClosedError`.\n        \"\"\"\n        if self.ws_connection is None:\n            raise WebSocketClosedError()\n        if isinstance(message, dict):\n            message = tornado.escape.json_encode(message)\n        return self.ws_connection.write_message(message, binary=binary)",
        "begin_line": 230,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016350555918901244,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.open#295",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.open(self, *args, **kwargs)",
        "snippet": "    def open(self, *args, **kwargs):\n        \"\"\"Invoked when a new WebSocket is opened.\n\n        The arguments to `open` are extracted from the `tornado.web.URLSpec`\n        regular expression, just like the arguments to\n        `tornado.web.RequestHandler.get`.\n        \"\"\"\n        pass",
        "begin_line": 295,
        "end_line": 302,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001623640201331385,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.close#357",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.close(self, code=None, reason=None)",
        "snippet": "    def close(self, code=None, reason=None):\n        \"\"\"Closes this Web Socket.\n\n        Once the close handshake is successful the socket will be closed.\n\n        ``code`` may be a numeric status code, taken from the values\n        defined in `RFC 6455 section 7.4.1\n        <https://tools.ietf.org/html/rfc6455#section-7.4.1>`_.\n        ``reason`` may be a textual message about why the connection is\n        closing.  These values are made available to the client, but are\n        not otherwise interpreted by the websocket protocol.\n\n        .. versionchanged:: 4.0\n\n           Added the ``code`` and ``reason`` arguments.\n        \"\"\"\n        if self.ws_connection:\n            self.ws_connection.close(code, reason)\n            self.ws_connection = None",
        "begin_line": 357,
        "end_line": 375,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.check_origin#377",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.check_origin(self, origin)",
        "snippet": "    def check_origin(self, origin):\n        \"\"\"Override to enable support for allowing alternate origins.\n\n        The ``origin`` argument is the value of the ``Origin`` HTTP\n        header, the url responsible for initiating this request.  This\n        method is not called for clients that do not send this header;\n        such requests are always allowed (because all browsers that\n        implement WebSockets support this header, and non-browser\n        clients do not have the same cross-site security concerns).\n\n        Should return True to accept the request or False to reject it.\n        By default, rejects all requests with an origin on a host other\n        than this one.\n\n        This is a security protection against cross site scripting attacks on\n        browsers, since WebSockets are allowed to bypass the usual same-origin\n        policies and don't use CORS headers.\n\n        .. warning::\n\n           This is an important security measure; don't disable it\n           without understanding the security implications. In\n           particular, if your authentication is cookie-based, you\n           must either restrict the origins allowed by\n           ``check_origin()`` or implement your own XSRF-like\n           protection for websocket connections. See `these\n           <https://www.christian-schneider.net/CrossSiteWebSocketHijacking.html>`_\n           `articles\n           <https://devcenter.heroku.com/articles/websocket-security>`_\n           for more.\n\n        To accept all cross-origin traffic (which was the default prior to\n        Tornado 4.0), simply override this method to always return true::\n\n            def check_origin(self, origin):\n                return True\n\n        To allow connections from any subdomain of your site, you might\n        do something like::\n\n            def check_origin(self, origin):\n                parsed_origin = urllib.parse.urlparse(origin)\n                return parsed_origin.netloc.endswith(\".mydomain.com\")\n\n        .. versionadded:: 4.0\n\n        \"\"\"\n        parsed_origin = urlparse(origin)\n        origin = parsed_origin.netloc\n        origin = origin.lower()\n\n        host = self.request.headers.get(\"Host\")\n\n        # Check to see that origin matches host directly, including ports\n        return origin == host",
        "begin_line": 377,
        "end_line": 431,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.on_connection_close#449",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.on_connection_close(self)",
        "snippet": "    def on_connection_close(self):\n        if self.ws_connection:\n            self.ws_connection.on_connection_close()\n            self.ws_connection = None\n        if not self._on_close_called:\n            self._on_close_called = True\n            self.on_close()\n            self._break_cycles()",
        "begin_line": 449,
        "end_line": 456,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016622340425531914,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler._break_cycles#458",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler._break_cycles(self)",
        "snippet": "    def _break_cycles(self):\n        # WebSocketHandlers call finish() early, but we don't want to\n        # break up reference cycles (which makes it impossible to call\n        # self.render_string) until after we've really closed the\n        # connection (if it was established in the first place,\n        # indicated by status code 101).\n        if self.get_status() != 101 or self._on_close_called:\n            super(WebSocketHandler, self)._break_cycles()",
        "begin_line": 458,
        "end_line": 465,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015422578655151142,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler.get_websocket_protocol#477",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler.get_websocket_protocol(self)",
        "snippet": "    def get_websocket_protocol(self):\n        websocket_version = self.request.headers.get(\"Sec-WebSocket-Version\")\n        if websocket_version in (\"7\", \"8\", \"13\"):\n            return WebSocketProtocol13(\n                self, compression_options=self.get_compression_options())",
        "begin_line": 477,
        "end_line": 481,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015422578655151142,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketHandler._attach_stream#483",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketHandler",
        "signature": "tornado.websocket.WebSocketHandler._attach_stream(self)",
        "snippet": "    def _attach_stream(self):\n        self.stream = self.request.connection.detach()\n        self.stream.set_close_callback(self.on_connection_close)\n        # disable non-WS methods\n        for method in [\"write\", \"redirect\", \"set_header\", \"set_cookie\",\n                       \"set_status\", \"flush\", \"finish\"]:\n            setattr(self, method, _raise_not_supported_for_websockets)",
        "begin_line": 483,
        "end_line": 489,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015730690577316344,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket._raise_not_supported_for_websockets#492",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket",
        "signature": "tornado.websocket._raise_not_supported_for_websockets(*args, **kwargs)",
        "snippet": "def _raise_not_supported_for_websockets(*args, **kwargs):\n    raise RuntimeError(\"Method not supported for Web Sockets\")",
        "begin_line": 492,
        "end_line": 493,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol.__init__#499",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol",
        "signature": "tornado.websocket.WebSocketProtocol.__init__(self, handler)",
        "snippet": "    def __init__(self, handler):\n        self.handler = handler\n        self.request = handler.request\n        self.stream = handler.stream\n        self.client_terminated = False\n        self.server_terminated = False",
        "begin_line": 499,
        "end_line": 504,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015422578655151142,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol._run_callback#506",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol",
        "signature": "tornado.websocket.WebSocketProtocol._run_callback(self, callback, *args, **kwargs)",
        "snippet": "    def _run_callback(self, callback, *args, **kwargs):\n        \"\"\"Runs the given callback with exception handling.\n\n        If the callback is a coroutine, returns its Future. On error, aborts the\n        websocket connection and returns None.\n        \"\"\"\n        try:\n            result = callback(*args, **kwargs)\n        except Exception:\n            app_log.error(\"Uncaught exception in %s\",\n                          getattr(self.request, 'path', None), exc_info=True)\n            self._abort()\n        else:\n            if result is not None:\n                result = gen.convert_yielded(result)\n                self.stream.io_loop.add_future(result, lambda f: f.result())\n            return result",
        "begin_line": 506,
        "end_line": 522,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol.on_connection_close#524",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol",
        "signature": "tornado.websocket.WebSocketProtocol.on_connection_close(self)",
        "snippet": "    def on_connection_close(self):\n        self._abort()",
        "begin_line": 524,
        "end_line": 525,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016622340425531914,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol._abort#527",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol",
        "signature": "tornado.websocket.WebSocketProtocol._abort(self)",
        "snippet": "    def _abort(self):\n        \"\"\"Instantly aborts the WebSocket connection by closing the socket\"\"\"\n        self.client_terminated = True\n        self.server_terminated = True\n        self.stream.close()  # forcibly tear down the connection\n        self.close()  # let the subclass cleanup",
        "begin_line": 527,
        "end_line": 532,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016622340425531914,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket._PerMessageDeflateCompressor.__init__#536",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket._PerMessageDeflateCompressor",
        "signature": "tornado.websocket._PerMessageDeflateCompressor.__init__(self, persistent, max_wbits, compression_options=None)",
        "snippet": "    def __init__(self, persistent, max_wbits, compression_options=None):\n        if max_wbits is None:\n            max_wbits = zlib.MAX_WBITS\n        # There is no symbolic constant for the minimum wbits value.\n        if not (8 <= max_wbits <= zlib.MAX_WBITS):\n            raise ValueError(\"Invalid max_wbits value %r; allowed range 8-%d\",\n                             max_wbits, zlib.MAX_WBITS)\n        self._max_wbits = max_wbits\n\n        if compression_options is None or 'compression_level' not in compression_options:\n            self._compression_level = tornado.web.GZipContentEncoding.GZIP_LEVEL\n        else:\n            self._compression_level = compression_options['compression_level']\n\n        if compression_options is None or 'mem_level' not in compression_options:\n            self._mem_level = 8\n        else:\n            self._mem_level = compression_options['mem_level']\n\n        if persistent:\n            self._compressor = self._create_compressor()\n        else:\n            self._compressor = None",
        "begin_line": 536,
        "end_line": 558,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket._PerMessageDeflateCompressor._create_compressor#560",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket._PerMessageDeflateCompressor",
        "signature": "tornado.websocket._PerMessageDeflateCompressor._create_compressor(self)",
        "snippet": "    def _create_compressor(self):\n        return zlib.compressobj(self._compression_level,\n                                zlib.DEFLATED, -self._max_wbits, self._mem_level)",
        "begin_line": 560,
        "end_line": 562,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket._PerMessageDeflateCompressor.compress#564",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket._PerMessageDeflateCompressor",
        "signature": "tornado.websocket._PerMessageDeflateCompressor.compress(self, data)",
        "snippet": "    def compress(self, data):\n        compressor = self._compressor or self._create_compressor()\n        data = (compressor.compress(data) +\n                compressor.flush(zlib.Z_SYNC_FLUSH))\n        assert data.endswith(b'\\x00\\x00\\xff\\xff')\n        return data[:-4]",
        "begin_line": 564,
        "end_line": 569,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket._PerMessageDeflateDecompressor.__init__#573",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket._PerMessageDeflateDecompressor",
        "signature": "tornado.websocket._PerMessageDeflateDecompressor.__init__(self, persistent, max_wbits, compression_options=None)",
        "snippet": "    def __init__(self, persistent, max_wbits, compression_options=None):\n        if max_wbits is None:\n            max_wbits = zlib.MAX_WBITS\n        if not (8 <= max_wbits <= zlib.MAX_WBITS):\n            raise ValueError(\"Invalid max_wbits value %r; allowed range 8-%d\",\n                             max_wbits, zlib.MAX_WBITS)\n        self._max_wbits = max_wbits\n        if persistent:\n            self._decompressor = self._create_decompressor()\n        else:\n            self._decompressor = None",
        "begin_line": 573,
        "end_line": 583,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket._PerMessageDeflateDecompressor._create_decompressor#585",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket._PerMessageDeflateDecompressor",
        "signature": "tornado.websocket._PerMessageDeflateDecompressor._create_decompressor(self)",
        "snippet": "    def _create_decompressor(self):\n        return zlib.decompressobj(-self._max_wbits)",
        "begin_line": 585,
        "end_line": 586,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket._PerMessageDeflateDecompressor.decompress#588",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket._PerMessageDeflateDecompressor",
        "signature": "tornado.websocket._PerMessageDeflateDecompressor.decompress(self, data)",
        "snippet": "    def decompress(self, data):\n        decompressor = self._decompressor or self._create_decompressor()\n        return decompressor.decompress(data + b'\\x00\\x00\\xff\\xff')",
        "begin_line": 588,
        "end_line": 590,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.__init__#607",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.__init__(self, handler, mask_outgoing=False, compression_options=None)",
        "snippet": "    def __init__(self, handler, mask_outgoing=False,\n                 compression_options=None):\n        WebSocketProtocol.__init__(self, handler)\n        self.mask_outgoing = mask_outgoing\n        self._final_frame = False\n        self._frame_opcode = None\n        self._masked_frame = None\n        self._frame_mask = None\n        self._frame_length = None\n        self._fragmented_message_buffer = None\n        self._fragmented_message_opcode = None\n        self._waiting = None\n        self._compression_options = compression_options\n        self._decompressor = None\n        self._compressor = None\n        self._frame_compressed = None\n        # The total uncompressed size of all messages received or sent.\n        # Unicode messages are encoded to utf8.\n        # Only for testing; subject to change.\n        self._message_bytes_in = 0\n        self._message_bytes_out = 0\n        # The total size of all packets received or sent.  Includes\n        # the effect of compression, frame overhead, and control frames.\n        self._wire_bytes_in = 0\n        self._wire_bytes_out = 0\n        self.ping_callback = None\n        self.last_ping = 0\n        self.last_pong = 0",
        "begin_line": 607,
        "end_line": 634,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015422578655151142,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.accept_connection#636",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.accept_connection(self)",
        "snippet": "    def accept_connection(self):\n        try:\n            self._handle_websocket_headers()\n        except ValueError:\n            self.handler.set_status(400)\n            log_msg = \"Missing/Invalid WebSocket headers\"\n            self.handler.finish(log_msg)\n            gen_log.debug(log_msg)\n            return\n\n        try:\n            self._accept_connection()\n        except ValueError:\n            gen_log.debug(\"Malformed WebSocket request received\",\n                          exc_info=True)\n            self._abort()\n            return",
        "begin_line": 636,
        "end_line": 652,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._handle_websocket_headers#654",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._handle_websocket_headers(self)",
        "snippet": "    def _handle_websocket_headers(self):\n        \"\"\"Verifies all invariant- and required headers\n\n        If a header is missing or have an incorrect value ValueError will be\n        raised\n        \"\"\"\n        fields = (\"Host\", \"Sec-Websocket-Key\", \"Sec-Websocket-Version\")\n        if not all(map(lambda f: self.request.headers.get(f), fields)):\n            raise ValueError(\"Missing/Invalid WebSocket headers\")",
        "begin_line": 654,
        "end_line": 662,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.compute_accept_value#665",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.compute_accept_value(key)",
        "snippet": "    def compute_accept_value(key):\n        \"\"\"Computes the value for the Sec-WebSocket-Accept header,\n        given the value for Sec-WebSocket-Key.\n        \"\"\"\n        sha1 = hashlib.sha1()\n        sha1.update(utf8(key))\n        sha1.update(b\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\")  # Magic value\n        return native_str(base64.b64encode(sha1.digest()))",
        "begin_line": 665,
        "end_line": 672,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015730690577316344,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._challenge_response#674",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._challenge_response(self)",
        "snippet": "    def _challenge_response(self):\n        return WebSocketProtocol13.compute_accept_value(\n            self.request.headers.get(\"Sec-Websocket-Key\"))",
        "begin_line": 674,
        "end_line": 676,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015730690577316344,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._accept_connection#678",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._accept_connection(self)",
        "snippet": "    def _accept_connection(self):\n        subprotocols = [s.strip() for s in self.request.headers.get_list(\"Sec-WebSocket-Protocol\")]\n        if subprotocols:\n            selected = self.handler.select_subprotocol(subprotocols)\n            if selected:\n                assert selected in subprotocols\n                self.handler.set_header(\"Sec-WebSocket-Protocol\", selected)\n\n        extensions = self._parse_extensions_header(self.request.headers)\n        for ext in extensions:\n            if (ext[0] == 'permessage-deflate' and\n                    self._compression_options is not None):\n                # TODO: negotiate parameters if compression_options\n                # specifies limits.\n                self._create_compressors('server', ext[1], self._compression_options)\n                if ('client_max_window_bits' in ext[1] and\n                        ext[1]['client_max_window_bits'] is None):\n                    # Don't echo an offered client_max_window_bits\n                    # parameter with no value.\n                    del ext[1]['client_max_window_bits']\n                self.handler.set_header(\"Sec-WebSocket-Extensions\",\n                                        httputil._encode_header(\n                                            'permessage-deflate', ext[1]))\n                break\n\n        self.handler.clear_header(\"Content-Type\")\n        self.handler.set_status(101)\n        self.handler.set_header(\"Upgrade\", \"websocket\")\n        self.handler.set_header(\"Connection\", \"Upgrade\")\n        self.handler.set_header(\"Sec-WebSocket-Accept\", self._challenge_response())\n        self.handler.finish()\n\n        self.handler._attach_stream()\n        self.stream = self.handler.stream\n\n        self.start_pinging()\n        self._run_callback(self.handler.open, *self.handler.open_args,\n                           **self.handler.open_kwargs)\n        self._receive_frame()",
        "begin_line": 678,
        "end_line": 716,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._parse_extensions_header#718",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._parse_extensions_header(self, headers)",
        "snippet": "    def _parse_extensions_header(self, headers):\n        extensions = headers.get(\"Sec-WebSocket-Extensions\", '')\n        if extensions:\n            return [httputil._parse_header(e.strip())\n                    for e in extensions.split(',')]\n        return []",
        "begin_line": 718,
        "end_line": 723,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._process_server_headers#725",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._process_server_headers(self, key, headers)",
        "snippet": "    def _process_server_headers(self, key, headers):\n        \"\"\"Process the headers sent by the server to this client connection.\n\n        'key' is the websocket handshake challenge/response key.\n        \"\"\"\n        assert headers['Upgrade'].lower() == 'websocket'\n        assert headers['Connection'].lower() == 'upgrade'\n        accept = self.compute_accept_value(key)\n        assert headers['Sec-Websocket-Accept'] == accept\n\n        extensions = self._parse_extensions_header(headers)\n        for ext in extensions:\n            if (ext[0] == 'permessage-deflate' and\n                    self._compression_options is not None):\n                self._create_compressors('client', ext[1])\n            else:\n                raise ValueError(\"unsupported extension %r\", ext)",
        "begin_line": 725,
        "end_line": 741,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._get_compressor_options#743",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._get_compressor_options(self, side, agreed_parameters, compression_options=None)",
        "snippet": "    def _get_compressor_options(self, side, agreed_parameters, compression_options=None):\n        \"\"\"Converts a websocket agreed_parameters set to keyword arguments\n        for our compressor objects.\n        \"\"\"\n        options = dict(\n            persistent=(side + '_no_context_takeover') not in agreed_parameters)\n        wbits_header = agreed_parameters.get(side + '_max_window_bits', None)\n        if wbits_header is None:\n            options['max_wbits'] = zlib.MAX_WBITS\n        else:\n            options['max_wbits'] = int(wbits_header)\n        options['compression_options'] = compression_options\n        return options",
        "begin_line": 743,
        "end_line": 755,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._create_compressors#757",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._create_compressors(self, side, agreed_parameters, compression_options=None)",
        "snippet": "    def _create_compressors(self, side, agreed_parameters, compression_options=None):\n        # TODO: handle invalid parameters gracefully\n        allowed_keys = set(['server_no_context_takeover',\n                            'client_no_context_takeover',\n                            'server_max_window_bits',\n                            'client_max_window_bits'])\n        for key in agreed_parameters:\n            if key not in allowed_keys:\n                raise ValueError(\"unsupported compression parameter %r\" % key)\n        other_side = 'client' if (side == 'server') else 'server'\n        self._compressor = _PerMessageDeflateCompressor(\n            **self._get_compressor_options(side, agreed_parameters, compression_options))\n        self._decompressor = _PerMessageDeflateDecompressor(\n            **self._get_compressor_options(other_side, agreed_parameters, compression_options))",
        "begin_line": 757,
        "end_line": 770,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._write_frame#772",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._write_frame(self, fin, opcode, data, flags=0)",
        "snippet": "    def _write_frame(self, fin, opcode, data, flags=0):\n        data_len = len(data)\n        if opcode & 0x8:\n            # All control frames MUST have a payload length of 125\n            # bytes or less and MUST NOT be fragmented.\n            if not fin:\n                raise ValueError(\"control frames may not be fragmented\")\n            if data_len > 125:\n                raise ValueError(\"control frame payloads may not exceed 125 bytes\")\n        if fin:\n            finbit = self.FIN\n        else:\n            finbit = 0\n        frame = struct.pack(\"B\", finbit | opcode | flags)\n        if self.mask_outgoing:\n            mask_bit = 0x80\n        else:\n            mask_bit = 0\n        if data_len < 126:\n            frame += struct.pack(\"B\", data_len | mask_bit)\n        elif data_len <= 0xFFFF:\n            frame += struct.pack(\"!BH\", 126 | mask_bit, data_len)\n        else:\n            frame += struct.pack(\"!BQ\", 127 | mask_bit, data_len)\n        if self.mask_outgoing:\n            mask = os.urandom(4)\n            data = mask + _websocket_mask(mask, data)\n        frame += data\n        self._wire_bytes_out += len(frame)\n        return self.stream.write(frame)",
        "begin_line": 772,
        "end_line": 801,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.write_message#803",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.write_message(self, message, binary=False)",
        "snippet": "    def write_message(self, message, binary=False):\n        \"\"\"Sends the given message to the client of this Web Socket.\"\"\"\n        if binary:\n            opcode = 0x2\n        else:\n            opcode = 0x1\n        message = tornado.escape.utf8(message)\n        assert isinstance(message, bytes)\n        self._message_bytes_out += len(message)\n        flags = 0\n        if self._compressor:\n            message = self._compressor.compress(message)\n            flags |= self.RSV1\n        # For historical reasons, write methods in Tornado operate in a semi-synchronous\n        # mode in which awaiting the Future they return is optional (But errors can\n        # still be raised). This requires us to go through an awkward dance here\n        # to transform the errors that may be returned while presenting the same\n        # semi-synchronous interface.\n        try:\n            fut = self._write_frame(True, opcode, message, flags=flags)\n        except StreamClosedError:\n            raise WebSocketClosedError()\n\n        @gen.coroutine\n        def wrapper():\n            try:\n                yield fut\n            except StreamClosedError:\n                raise WebSocketClosedError()\n        return wrapper()",
        "begin_line": 803,
        "end_line": 832,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.wrapper#827",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.wrapper()",
        "snippet": "        def wrapper():\n            try:\n                yield fut\n            except StreamClosedError:\n                raise WebSocketClosedError()",
        "begin_line": 827,
        "end_line": 831,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001623640201331385,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.write_ping#834",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.write_ping(self, data)",
        "snippet": "    def write_ping(self, data):\n        \"\"\"Send ping frame.\"\"\"\n        assert isinstance(data, bytes)\n        self._write_frame(True, 0x9, data)",
        "begin_line": 834,
        "end_line": 837,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00023272050267628578,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._receive_frame#839",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._receive_frame(self)",
        "snippet": "    def _receive_frame(self):\n        try:\n            self.stream.read_bytes(2, self._on_frame_start)\n        except StreamClosedError:\n            self._abort()",
        "begin_line": 839,
        "end_line": 843,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015730690577316344,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._on_frame_start#845",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._on_frame_start(self, data)",
        "snippet": "    def _on_frame_start(self, data):\n        self._wire_bytes_in += len(data)\n        header, payloadlen = struct.unpack(\"BB\", data)\n        self._final_frame = header & self.FIN\n        reserved_bits = header & self.RSV_MASK\n        self._frame_opcode = header & self.OPCODE_MASK\n        self._frame_opcode_is_control = self._frame_opcode & 0x8\n        if self._decompressor is not None and self._frame_opcode != 0:\n            self._frame_compressed = bool(reserved_bits & self.RSV1)\n            reserved_bits &= ~self.RSV1\n        if reserved_bits:\n            # client is using as-yet-undefined extensions; abort\n            self._abort()\n            return\n        self._masked_frame = bool(payloadlen & 0x80)\n        payloadlen = payloadlen & 0x7f\n        if self._frame_opcode_is_control and payloadlen >= 126:\n            # control frames must have payload < 126\n            self._abort()\n            return\n        try:\n            if payloadlen < 126:\n                self._frame_length = payloadlen\n                if self._masked_frame:\n                    self.stream.read_bytes(4, self._on_masking_key)\n                else:\n                    self._read_frame_data(False)\n            elif payloadlen == 126:\n                self.stream.read_bytes(2, self._on_frame_length_16)\n            elif payloadlen == 127:\n                self.stream.read_bytes(8, self._on_frame_length_64)\n        except StreamClosedError:\n            self._abort()",
        "begin_line": 845,
        "end_line": 877,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._read_frame_data#879",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._read_frame_data(self, masked)",
        "snippet": "    def _read_frame_data(self, masked):\n        new_len = self._frame_length\n        if self._fragmented_message_buffer is not None:\n            new_len += len(self._fragmented_message_buffer)\n        if new_len > (self.handler.max_message_size or 10 * 1024 * 1024):\n            self.close(1009, \"message too big\")\n            return\n        self.stream.read_bytes(\n            self._frame_length,\n            self._on_masked_frame_data if masked else self._on_frame_data)",
        "begin_line": 879,
        "end_line": 888,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._on_frame_length_16#890",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._on_frame_length_16(self, data)",
        "snippet": "    def _on_frame_length_16(self, data):\n        self._wire_bytes_in += len(data)\n        self._frame_length = struct.unpack(\"!H\", data)[0]\n        try:\n            if self._masked_frame:\n                self.stream.read_bytes(4, self._on_masking_key)\n            else:\n                self._read_frame_data(False)\n        except StreamClosedError:\n            self._abort()",
        "begin_line": 890,
        "end_line": 899,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._on_masking_key#912",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._on_masking_key(self, data)",
        "snippet": "    def _on_masking_key(self, data):\n        self._wire_bytes_in += len(data)\n        self._frame_mask = data\n        try:\n            self._read_frame_data(True)\n        except StreamClosedError:\n            self._abort()",
        "begin_line": 912,
        "end_line": 918,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016017940092904052,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._on_masked_frame_data#920",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._on_masked_frame_data(self, data)",
        "snippet": "    def _on_masked_frame_data(self, data):\n        # Don't touch _wire_bytes_in; we'll do it in _on_frame_data.\n        self._on_frame_data(_websocket_mask(self._frame_mask, data))",
        "begin_line": 920,
        "end_line": 922,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016017940092904052,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._on_frame_data#924",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._on_frame_data(self, data)",
        "snippet": "    def _on_frame_data(self, data):\n        handled_future = None\n\n        self._wire_bytes_in += len(data)\n        if self._frame_opcode_is_control:\n            # control frames may be interleaved with a series of fragmented\n            # data frames, so control frames must not interact with\n            # self._fragmented_*\n            if not self._final_frame:\n                # control frames must not be fragmented\n                self._abort()\n                return\n            opcode = self._frame_opcode\n        elif self._frame_opcode == 0:  # continuation frame\n            if self._fragmented_message_buffer is None:\n                # nothing to continue\n                self._abort()\n                return\n            self._fragmented_message_buffer += data\n            if self._final_frame:\n                opcode = self._fragmented_message_opcode\n                data = self._fragmented_message_buffer\n                self._fragmented_message_buffer = None\n        else:  # start of new data message\n            if self._fragmented_message_buffer is not None:\n                # can't start new message until the old one is finished\n                self._abort()\n                return\n            if self._final_frame:\n                opcode = self._frame_opcode\n            else:\n                self._fragmented_message_opcode = self._frame_opcode\n                self._fragmented_message_buffer = data\n\n        if self._final_frame:\n            handled_future = self._handle_message(opcode, data)\n\n        if not self.client_terminated:\n            if handled_future:\n                # on_message is a coroutine, process more frames once it's done.\n                handled_future.add_done_callback(\n                    lambda future: self._receive_frame())\n            else:\n                self._receive_frame()",
        "begin_line": 924,
        "end_line": 967,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00017295053614666206,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13._handle_message#969",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13._handle_message(self, opcode, data)",
        "snippet": "    def _handle_message(self, opcode, data):\n        \"\"\"Execute on_message, returning its Future if it is a coroutine.\"\"\"\n        if self.client_terminated:\n            return\n\n        if self._frame_compressed:\n            data = self._decompressor.decompress(data)\n\n        if opcode == 0x1:\n            # UTF-8 data\n            self._message_bytes_in += len(data)\n            try:\n                decoded = data.decode(\"utf-8\")\n            except UnicodeDecodeError:\n                self._abort()\n                return\n            return self._run_callback(self.handler.on_message, decoded)\n        elif opcode == 0x2:\n            # Binary data\n            self._message_bytes_in += len(data)\n            return self._run_callback(self.handler.on_message, data)\n        elif opcode == 0x8:\n            # Close\n            self.client_terminated = True\n            if len(data) >= 2:\n                self.handler.close_code = struct.unpack('>H', data[:2])[0]\n            if len(data) > 2:\n                self.handler.close_reason = to_unicode(data[2:])\n            # Echo the received close code, if any (RFC 6455 section 5.5.1).\n            self.close(self.handler.close_code)\n        elif opcode == 0x9:\n            # Ping\n            try:\n                self._write_frame(True, 0xA, data)\n            except StreamClosedError:\n                self._abort()\n            self._run_callback(self.handler.on_ping, data)\n        elif opcode == 0xA:\n            # Pong\n            self.last_pong = IOLoop.current().time()\n            return self._run_callback(self.handler.on_pong, data)\n        else:\n            self._abort()",
        "begin_line": 969,
        "end_line": 1011,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.close#1013",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.close(self, code=None, reason=None)",
        "snippet": "    def close(self, code=None, reason=None):\n        \"\"\"Closes the WebSocket connection.\"\"\"\n        if not self.server_terminated:\n            if not self.stream.closed():\n                if code is None and reason is not None:\n                    code = 1000  # \"normal closure\" status code\n                if code is None:\n                    close_data = b''\n                else:\n                    close_data = struct.pack('>H', code)\n                if reason is not None:\n                    close_data += utf8(reason)\n                try:\n                    self._write_frame(True, 0x8, close_data)\n                except StreamClosedError:\n                    self._abort()\n            self.server_terminated = True\n        if self.client_terminated:\n            if self._waiting is not None:\n                self.stream.io_loop.remove_timeout(self._waiting)\n                self._waiting = None\n            self.stream.close()\n        elif self._waiting is None:\n            # Give the client a few seconds to complete a clean shutdown,\n            # otherwise just close the connection.\n            self._waiting = self.stream.io_loop.add_timeout(\n                self.stream.io_loop.time() + 5, self._abort)",
        "begin_line": 1013,
        "end_line": 1039,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.ping_interval#1042",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.ping_interval(self)",
        "snippet": "    def ping_interval(self):\n        interval = self.handler.ping_interval\n        if interval is not None:\n            return interval\n        return 0",
        "begin_line": 1042,
        "end_line": 1046,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.ping_timeout#1049",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.ping_timeout(self)",
        "snippet": "    def ping_timeout(self):\n        timeout = self.handler.ping_timeout\n        if timeout is not None:\n            return timeout\n        return max(3 * self.ping_interval, 30)",
        "begin_line": 1049,
        "end_line": 1053,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.start_pinging#1055",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.start_pinging(self)",
        "snippet": "    def start_pinging(self):\n        \"\"\"Start sending periodic pings to keep the connection alive\"\"\"\n        if self.ping_interval > 0:\n            self.last_ping = self.last_pong = IOLoop.current().time()\n            self.ping_callback = PeriodicCallback(\n                self.periodic_ping, self.ping_interval * 1000)\n            self.ping_callback.start()",
        "begin_line": 1055,
        "end_line": 1061,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketProtocol13.periodic_ping#1063",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketProtocol13",
        "signature": "tornado.websocket.WebSocketProtocol13.periodic_ping(self)",
        "snippet": "    def periodic_ping(self):\n        \"\"\"Send a ping to keep the websocket alive\n\n        Called periodically if the websocket_ping_interval is set and non-zero.\n        \"\"\"\n        if self.stream.closed() and self.ping_callback is not None:\n            self.ping_callback.stop()\n            return\n\n        # Check for timeout on pong. Make sure that we really have\n        # sent a recent ping in case the machine with both server and\n        # client has been suspended since the last ping.\n        now = IOLoop.current().time()\n        since_last_pong = now - self.last_pong\n        since_last_ping = now - self.last_ping\n        if (since_last_ping < 2 * self.ping_interval and\n                since_last_pong > self.ping_timeout):\n            self.close()\n            return\n\n        self.write_ping(b'')\n        self.last_ping = now",
        "begin_line": 1063,
        "end_line": 1084,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.__init__#1093",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.__init__(self, request, on_message_callback=None, compression_options=None, ping_interval=None, ping_timeout=None, max_message_size=None)",
        "snippet": "    def __init__(self, request, on_message_callback=None,\n                 compression_options=None, ping_interval=None, ping_timeout=None,\n                 max_message_size=None):\n        self.compression_options = compression_options\n        self.connect_future = Future()\n        self.protocol = None\n        self.read_future = None\n        self.read_queue = collections.deque()\n        self.key = base64.b64encode(os.urandom(16))\n        self._on_message_callback = on_message_callback\n        self.close_code = self.close_reason = None\n        self.ping_interval = ping_interval\n        self.ping_timeout = ping_timeout\n        self.max_message_size = max_message_size\n\n        scheme, sep, rest = request.url.partition(':')\n        scheme = {'ws': 'http', 'wss': 'https'}[scheme]\n        request.url = scheme + sep + rest\n        request.headers.update({\n            'Upgrade': 'websocket',\n            'Connection': 'Upgrade',\n            'Sec-WebSocket-Key': self.key,\n            'Sec-WebSocket-Version': '13',\n        })\n        if self.compression_options is not None:\n            # Always offer to let the server set our max_wbits (and even though\n            # we don't offer it, we will accept a client_no_context_takeover\n            # from the server).\n            # TODO: set server parameters for deflate extension\n            # if requested in self.compression_options.\n            request.headers['Sec-WebSocket-Extensions'] = (\n                'permessage-deflate; client_max_window_bits')\n\n        self.tcp_client = TCPClient()\n        super(WebSocketClientConnection, self).__init__(\n            None, request, lambda: None, self._on_http_response,\n            104857600, self.tcp_client, 65536, 104857600)",
        "begin_line": 1093,
        "end_line": 1129,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.close#1131",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.close(self, code=None, reason=None)",
        "snippet": "    def close(self, code=None, reason=None):\n        \"\"\"Closes the websocket connection.\n\n        ``code`` and ``reason`` are documented under\n        `WebSocketHandler.close`.\n\n        .. versionadded:: 3.2\n\n        .. versionchanged:: 4.0\n\n           Added the ``code`` and ``reason`` arguments.\n        \"\"\"\n        if self.protocol is not None:\n            self.protocol.close(code, reason)\n            self.protocol = None",
        "begin_line": 1131,
        "end_line": 1145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001677008217340265,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.on_connection_close#1147",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.on_connection_close(self)",
        "snippet": "    def on_connection_close(self):\n        if not self.connect_future.done():\n            self.connect_future.set_exception(StreamClosedError())\n        self.on_message(None)\n        self.tcp_client.close()\n        super(WebSocketClientConnection, self).on_connection_close()",
        "begin_line": 1147,
        "end_line": 1152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001623640201331385,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection._on_http_response#1154",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection._on_http_response(self, response)",
        "snippet": "    def _on_http_response(self, response):\n        if not self.connect_future.done():\n            if response.error:\n                self.connect_future.set_exception(response.error)\n            else:\n                self.connect_future.set_exception(WebSocketError(\n                    \"Non-websocket response\"))",
        "begin_line": 1154,
        "end_line": 1160,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.headers_received#1162",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.headers_received(self, start_line, headers)",
        "snippet": "    def headers_received(self, start_line, headers):\n        if start_line.code != 101:\n            return super(WebSocketClientConnection, self).headers_received(\n                start_line, headers)\n\n        self.headers = headers\n        self.protocol = self.get_websocket_protocol()\n        self.protocol._process_server_headers(self.key, self.headers)\n        self.protocol.start_pinging()\n        self.protocol._receive_frame()\n\n        if self._timeout is not None:\n            self.io_loop.remove_timeout(self._timeout)\n            self._timeout = None\n\n        self.stream = self.connection.detach()\n        self.stream.set_close_callback(self.on_connection_close)\n        # Once we've taken over the connection, clear the final callback\n        # we set on the http request.  This deactivates the error handling\n        # in simple_httpclient that would otherwise interfere with our\n        # ability to see exceptions.\n        self.final_callback = None\n\n        future_set_result_unless_cancelled(self.connect_future, self)",
        "begin_line": 1162,
        "end_line": 1185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.write_message#1187",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.write_message(self, message, binary=False)",
        "snippet": "    def write_message(self, message, binary=False):\n        \"\"\"Sends a message to the WebSocket server.\n\n        If the stream is closed, raises `WebSocketClosedError`.\n        Returns a `.Future` which can be used for flow control.\n\n        .. versionchanged:: 5.0\n           Exception raised on a closed stream changed from `.StreamClosedError`\n           to `WebSocketClosedError`.\n        \"\"\"\n        return self.protocol.write_message(message, binary=binary)",
        "begin_line": 1187,
        "end_line": 1197,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001677008217340265,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.read_message#1199",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.read_message(self, callback=None)",
        "snippet": "    def read_message(self, callback=None):\n        \"\"\"Reads a message from the WebSocket server.\n\n        If on_message_callback was specified at WebSocket\n        initialization, this function will never return messages\n\n        Returns a future whose result is the message, or None\n        if the connection is closed.  If a callback argument\n        is given it will be called with the future when it is\n        ready.\n        \"\"\"\n        assert self.read_future is None\n        future = Future()\n        if self.read_queue:\n            future_set_result_unless_cancelled(future, self.read_queue.popleft())\n        else:\n            self.read_future = future\n        if callback is not None:\n            self.io_loop.add_future(future, callback)\n        return future",
        "begin_line": 1199,
        "end_line": 1218,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.on_message#1220",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.on_message(self, message)",
        "snippet": "    def on_message(self, message):\n        if self._on_message_callback:\n            self._on_message_callback(message)\n        elif self.read_future is not None:\n            future_set_result_unless_cancelled(self.read_future, message)\n            self.read_future = None\n        else:\n            self.read_queue.append(message)",
        "begin_line": 1220,
        "end_line": 1227,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016622340425531914,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.ping#1229",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.ping(self, data=b'')",
        "snippet": "    def ping(self, data=b''):\n        \"\"\"Send ping frame to the remote end.\n\n        The data argument allows a small amount of data (up to 125\n        bytes) to be sent as a part of the ping message. Note that not\n        all websocket implementations expose this data to\n        applications.\n\n        Consider using the ``ping_interval`` argument to\n        `websocket_connect` instead of sending pings manually.\n\n        .. versionadded:: 5.1\n\n        \"\"\"\n        data = utf8(data)\n        if self.protocol is None:\n            raise WebSocketClosedError()\n        self.protocol.write_ping(data)",
        "begin_line": 1229,
        "end_line": 1246,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.on_pong#1248",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.on_pong(self, data)",
        "snippet": "    def on_pong(self, data):\n        pass",
        "begin_line": 1248,
        "end_line": 1249,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.on_ping#1251",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.on_ping(self, data)",
        "snippet": "    def on_ping(self, data):\n        pass",
        "begin_line": 1251,
        "end_line": 1252,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.WebSocketClientConnection.get_websocket_protocol#1254",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket.WebSocketClientConnection",
        "signature": "tornado.websocket.WebSocketClientConnection.get_websocket_protocol(self)",
        "snippet": "    def get_websocket_protocol(self):\n        return WebSocketProtocol13(self, mask_outgoing=True,\n                                   compression_options=self.compression_options)",
        "begin_line": 1254,
        "end_line": 1256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015730690577316344,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.websocket.websocket_connect#1259",
        "src_path": "tornado/websocket.py",
        "class_name": "tornado.websocket",
        "signature": "tornado.websocket.websocket_connect(url, callback=None, connect_timeout=None, on_message_callback=None, compression_options=None, ping_interval=None, ping_timeout=None, max_message_size=None)",
        "snippet": "def websocket_connect(url, callback=None, connect_timeout=None,\n                      on_message_callback=None, compression_options=None,\n                      ping_interval=None, ping_timeout=None,\n                      max_message_size=None):\n    \"\"\"Client-side websocket support.\n\n    Takes a url and returns a Future whose result is a\n    `WebSocketClientConnection`.\n\n    ``compression_options`` is interpreted in the same way as the\n    return value of `.WebSocketHandler.get_compression_options`.\n\n    The connection supports two styles of operation. In the coroutine\n    style, the application typically calls\n    `~.WebSocketClientConnection.read_message` in a loop::\n\n        conn = yield websocket_connect(url)\n        while True:\n            msg = yield conn.read_message()\n            if msg is None: break\n            # Do something with msg\n\n    In the callback style, pass an ``on_message_callback`` to\n    ``websocket_connect``. In both styles, a message of ``None``\n    indicates that the connection has been closed.\n\n    .. versionchanged:: 3.2\n       Also accepts ``HTTPRequest`` objects in place of urls.\n\n    .. versionchanged:: 4.1\n       Added ``compression_options`` and ``on_message_callback``.\n\n    .. versionchanged:: 4.5\n       Added the ``ping_interval``, ``ping_timeout``, and ``max_message_size``\n       arguments, which have the same meaning as in `WebSocketHandler`.\n\n    .. versionchanged:: 5.0\n       The ``io_loop`` argument (deprecated since version 4.1) has been removed.\n    \"\"\"\n    if isinstance(url, httpclient.HTTPRequest):\n        assert connect_timeout is None\n        request = url\n        # Copy and convert the headers dict/object (see comments in\n        # AsyncHTTPClient.fetch)\n        request.headers = httputil.HTTPHeaders(request.headers)\n    else:\n        request = httpclient.HTTPRequest(url, connect_timeout=connect_timeout)\n    request = httpclient._RequestProxy(\n        request, httpclient.HTTPRequest._DEFAULTS)\n    conn = WebSocketClientConnection(request,\n                                     on_message_callback=on_message_callback,\n                                     compression_options=compression_options,\n                                     ping_interval=ping_interval,\n                                     ping_timeout=ping_timeout,\n                                     max_message_size=max_message_size)\n    if callback is not None:\n        IOLoop.current().add_future(conn.connect_future, callback)\n    return conn.connect_future",
        "begin_line": 1259,
        "end_line": 1316,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks._TimeoutGarbageCollector.__init__#35",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks._TimeoutGarbageCollector",
        "signature": "tornado.locks._TimeoutGarbageCollector.__init__(self)",
        "snippet": "    def __init__(self):\n        self._waiters = collections.deque()  # Futures.\n        self._timeouts = 0",
        "begin_line": 35,
        "end_line": 37,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014874312063067083,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks._TimeoutGarbageCollector._garbage_collect#39",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks._TimeoutGarbageCollector",
        "signature": "tornado.locks._TimeoutGarbageCollector._garbage_collect(self)",
        "snippet": "    def _garbage_collect(self):\n        # Occasionally clear timed-out waiters.\n        self._timeouts += 1\n        if self._timeouts > 100:\n            self._timeouts = 0\n            self._waiters = collections.deque(\n                w for w in self._waiters if not w.done())",
        "begin_line": 39,
        "end_line": 45,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Condition.__init__#111",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Condition",
        "signature": "tornado.locks.Condition.__init__(self)",
        "snippet": "    def __init__(self):\n        super(Condition, self).__init__()\n        self.io_loop = ioloop.IOLoop.current()",
        "begin_line": 111,
        "end_line": 113,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001775568181818182,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Condition.__repr__#115",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Condition",
        "signature": "tornado.locks.Condition.__repr__(self)",
        "snippet": "    def __repr__(self):\n        result = '<%s' % (self.__class__.__name__, )\n        if self._waiters:\n            result += ' waiters[%s]' % len(self._waiters)\n        return result + '>'",
        "begin_line": 115,
        "end_line": 119,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Condition.wait#121",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Condition",
        "signature": "tornado.locks.Condition.wait(self, timeout=None)",
        "snippet": "    def wait(self, timeout=None):\n        \"\"\"Wait for `.notify`.\n\n        Returns a `.Future` that resolves ``True`` if the condition is notified,\n        or ``False`` after a timeout.\n        \"\"\"\n        waiter = Future()\n        self._waiters.append(waiter)\n        if timeout:\n            def on_timeout():\n                if not waiter.done():\n                    future_set_result_unless_cancelled(waiter, False)\n                self._garbage_collect()\n            io_loop = ioloop.IOLoop.current()\n            timeout_handle = io_loop.add_timeout(timeout, on_timeout)\n            waiter.add_done_callback(\n                lambda _: io_loop.remove_timeout(timeout_handle))\n        return waiter",
        "begin_line": 121,
        "end_line": 138,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Condition.on_timeout#130",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Condition",
        "signature": "tornado.locks.Condition.on_timeout()",
        "snippet": "            def on_timeout():\n                if not waiter.done():\n                    future_set_result_unless_cancelled(waiter, False)\n                self._garbage_collect()",
        "begin_line": 130,
        "end_line": 133,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Condition.notify#140",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Condition",
        "signature": "tornado.locks.Condition.notify(self, n=1)",
        "snippet": "    def notify(self, n=1):\n        \"\"\"Wake ``n`` waiters.\"\"\"\n        waiters = []  # Waiters we plan to run right now.\n        while n and self._waiters:\n            waiter = self._waiters.popleft()\n            if not waiter.done():  # Might have timed out.\n                n -= 1\n                waiters.append(waiter)\n\n        for waiter in waiters:\n            future_set_result_unless_cancelled(waiter, True)",
        "begin_line": 140,
        "end_line": 150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001836884643644379,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Condition.notify_all#152",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Condition",
        "signature": "tornado.locks.Condition.notify_all(self)",
        "snippet": "    def notify_all(self):\n        \"\"\"Wake all waiters.\"\"\"\n        self.notify(len(self._waiters))",
        "begin_line": 152,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Event.__init__#199",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Event",
        "signature": "tornado.locks.Event.__init__(self)",
        "snippet": "    def __init__(self):\n        self._value = False\n        self._waiters = set()",
        "begin_line": 199,
        "end_line": 201,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005128205128205128,
            "pseudo_dstar_susp": 0.00043122035360068997,
            "pseudo_tarantula_susp": 0.0006825938566552901,
            "pseudo_op2_susp": 0.00043122035360068997,
            "pseudo_barinel_susp": 0.0006825938566552901
        }
    },
    {
        "name": "tornado.locks.Event.__repr__#203",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Event",
        "signature": "tornado.locks.Event.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return '<%s %s>' % (\n            self.__class__.__name__, 'set' if self.is_set() else 'clear')",
        "begin_line": 203,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Event.is_set#207",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Event",
        "signature": "tornado.locks.Event.is_set(self)",
        "snippet": "    def is_set(self):\n        \"\"\"Return ``True`` if the internal flag is true.\"\"\"\n        return self._value",
        "begin_line": 207,
        "end_line": 209,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Event.set#211",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Event",
        "signature": "tornado.locks.Event.set(self)",
        "snippet": "    def set(self):\n        \"\"\"Set the internal flag to ``True``. All waiters are awakened.\n\n        Calling `.wait` once the flag is set will not block.\n        \"\"\"\n        if not self._value:\n            self._value = True\n\n            for fut in self._waiters:\n                if not fut.done():\n                    fut.set_result(None)",
        "begin_line": 211,
        "end_line": 221,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005128205128205128,
            "pseudo_dstar_susp": 0.00043122035360068997,
            "pseudo_tarantula_susp": 0.0006825938566552901,
            "pseudo_op2_susp": 0.00043122035360068997,
            "pseudo_barinel_susp": 0.0006825938566552901
        }
    },
    {
        "name": "tornado.locks.Event.clear#223",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Event",
        "signature": "tornado.locks.Event.clear(self)",
        "snippet": "    def clear(self):\n        \"\"\"Reset the internal flag to ``False``.\n\n        Calls to `.wait` will block until `.set` is called.\n        \"\"\"\n        self._value = False",
        "begin_line": 223,
        "end_line": 228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00014755791648221928,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Event.wait#230",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Event",
        "signature": "tornado.locks.Event.wait(self, timeout=None)",
        "snippet": "    def wait(self, timeout=None):\n        \"\"\"Block until the internal flag is true.\n\n        Returns a Future, which raises `tornado.util.TimeoutError` after a\n        timeout.\n        \"\"\"\n        fut = Future()\n        if self._value:\n            fut.set_result(None)\n            return fut\n        self._waiters.add(fut)\n        fut.add_done_callback(lambda fut: self._waiters.remove(fut))\n        if timeout is None:\n            return fut\n        else:\n            timeout_fut = gen.with_timeout(timeout, fut, quiet_exceptions=(CancelledError,))\n            # This is a slightly clumsy workaround for the fact that\n            # gen.with_timeout doesn't cancel its futures. Cancelling\n            # fut will remove it from the waiters list.\n            timeout_fut.add_done_callback(lambda tf: fut.cancel() if not fut.done() else None)\n            return timeout_fut",
        "begin_line": 230,
        "end_line": 250,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks._ReleasingContextManager.__init__#261",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks._ReleasingContextManager",
        "signature": "tornado.locks._ReleasingContextManager.__init__(self, obj)",
        "snippet": "    def __init__(self, obj):\n        self._obj = obj",
        "begin_line": 261,
        "end_line": 262,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001677008217340265,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks._ReleasingContextManager.__enter__#264",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks._ReleasingContextManager",
        "signature": "tornado.locks._ReleasingContextManager.__enter__(self)",
        "snippet": "    def __enter__(self):\n        pass",
        "begin_line": 264,
        "end_line": 265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks._ReleasingContextManager.__exit__#267",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks._ReleasingContextManager",
        "signature": "tornado.locks._ReleasingContextManager.__exit__(self, exc_type, exc_val, exc_tb)",
        "snippet": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        self._obj.release()",
        "begin_line": 267,
        "end_line": 268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Semaphore.__init__#368",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Semaphore",
        "signature": "tornado.locks.Semaphore.__init__(self, value=1)",
        "snippet": "    def __init__(self, value=1):\n        super(Semaphore, self).__init__()\n        if value < 0:\n            raise ValueError('semaphore initial value must be >= 0')\n\n        self._value = value",
        "begin_line": 368,
        "end_line": 373,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Semaphore.__repr__#375",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Semaphore",
        "signature": "tornado.locks.Semaphore.__repr__(self)",
        "snippet": "    def __repr__(self):\n        res = super(Semaphore, self).__repr__()\n        extra = 'locked' if self._value == 0 else 'unlocked,value:{0}'.format(\n            self._value)\n        if self._waiters:\n            extra = '{0},waiters:{1}'.format(extra, len(self._waiters))\n        return '<{0} [{1}]>'.format(res[1:-1], extra)",
        "begin_line": 375,
        "end_line": 381,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Semaphore.release#383",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Semaphore",
        "signature": "tornado.locks.Semaphore.release(self)",
        "snippet": "    def release(self):\n        \"\"\"Increment the counter and wake one waiter.\"\"\"\n        self._value += 1\n        while self._waiters:\n            waiter = self._waiters.popleft()\n            if not waiter.done():\n                self._value -= 1\n\n                # If the waiter is a coroutine paused at\n                #\n                #     with (yield semaphore.acquire()):\n                #\n                # then the context manager's __exit__ calls release() at the end\n                # of the \"with\" block.\n                waiter.set_result(_ReleasingContextManager(self))\n                break",
        "begin_line": 383,
        "end_line": 398,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001885369532428356,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Semaphore.acquire#400",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Semaphore",
        "signature": "tornado.locks.Semaphore.acquire(self, timeout=None)",
        "snippet": "    def acquire(self, timeout=None):\n        \"\"\"Decrement the counter. Returns a Future.\n\n        Block if the counter is zero and wait for a `.release`. The Future\n        raises `.TimeoutError` after the deadline.\n        \"\"\"\n        waiter = Future()\n        if self._value > 0:\n            self._value -= 1\n            waiter.set_result(_ReleasingContextManager(self))\n        else:\n            self._waiters.append(waiter)\n            if timeout:\n                def on_timeout():\n                    if not waiter.done():\n                        waiter.set_exception(gen.TimeoutError())\n                    self._garbage_collect()\n                io_loop = ioloop.IOLoop.current()\n                timeout_handle = io_loop.add_timeout(timeout, on_timeout)\n                waiter.add_done_callback(\n                    lambda _: io_loop.remove_timeout(timeout_handle))\n        return waiter",
        "begin_line": 400,
        "end_line": 421,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00020479213598197828,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Semaphore.on_timeout#413",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Semaphore",
        "signature": "tornado.locks.Semaphore.on_timeout()",
        "snippet": "                def on_timeout():\n                    if not waiter.done():\n                        waiter.set_exception(gen.TimeoutError())\n                    self._garbage_collect()",
        "begin_line": 413,
        "end_line": 416,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Semaphore.__enter__#423",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Semaphore",
        "signature": "tornado.locks.Semaphore.__enter__(self)",
        "snippet": "    def __enter__(self):\n        raise RuntimeError(\n            \"Use Semaphore like 'with (yield semaphore.acquire())', not like\"\n            \" 'with semaphore'\")",
        "begin_line": 423,
        "end_line": 426,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Semaphore.__aenter__#431",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Semaphore",
        "signature": "tornado.locks.Semaphore.__aenter__(self)",
        "snippet": "    def __aenter__(self):\n        yield self.acquire()",
        "begin_line": 431,
        "end_line": 432,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Semaphore.__aexit__#435",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Semaphore",
        "signature": "tornado.locks.Semaphore.__aexit__(self, typ, value, tb)",
        "snippet": "    def __aexit__(self, typ, value, tb):\n        self.release()",
        "begin_line": 435,
        "end_line": 436,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.BoundedSemaphore.__init__#447",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.BoundedSemaphore",
        "signature": "tornado.locks.BoundedSemaphore.__init__(self, value=1)",
        "snippet": "    def __init__(self, value=1):\n        super(BoundedSemaphore, self).__init__(value=value)\n        self._initial_value = value",
        "begin_line": 447,
        "end_line": 449,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001836884643644379,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.BoundedSemaphore.release#451",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.BoundedSemaphore",
        "signature": "tornado.locks.BoundedSemaphore.release(self)",
        "snippet": "    def release(self):\n        \"\"\"Increment the counter and wake one waiter.\"\"\"\n        if self._value >= self._initial_value:\n            raise ValueError(\"Semaphore released too many times\")\n        super(BoundedSemaphore, self).release()",
        "begin_line": 451,
        "end_line": 455,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Lock.__init__#496",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Lock",
        "signature": "tornado.locks.Lock.__init__(self)",
        "snippet": "    def __init__(self):\n        self._block = BoundedSemaphore(value=1)",
        "begin_line": 496,
        "end_line": 497,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0001885369532428356,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Lock.__repr__#499",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Lock",
        "signature": "tornado.locks.Lock.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return \"<%s _block=%s>\" % (\n            self.__class__.__name__,\n            self._block)",
        "begin_line": 499,
        "end_line": 502,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002630194634402946,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Lock.acquire#504",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Lock",
        "signature": "tornado.locks.Lock.acquire(self, timeout=None)",
        "snippet": "    def acquire(self, timeout=None):\n        \"\"\"Attempt to lock. Returns a Future.\n\n        Returns a Future, which raises `tornado.util.TimeoutError` after a\n        timeout.\n        \"\"\"\n        return self._block.acquire(timeout)",
        "begin_line": 504,
        "end_line": 510,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00019782393669634025,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Lock.release#512",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Lock",
        "signature": "tornado.locks.Lock.release(self)",
        "snippet": "    def release(self):\n        \"\"\"Unlock.\n\n        The first coroutine in line waiting for `acquire` gets the lock.\n\n        If not locked, raise a `RuntimeError`.\n        \"\"\"\n        try:\n            self._block.release()\n        except ValueError:\n            raise RuntimeError('release unlocked lock')",
        "begin_line": 512,
        "end_line": 522,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Lock.__enter__#524",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Lock",
        "signature": "tornado.locks.Lock.__enter__(self)",
        "snippet": "    def __enter__(self):\n        raise RuntimeError(\n            \"Use Lock like 'with (yield lock)', not like 'with lock'\")",
        "begin_line": 524,
        "end_line": 526,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Lock.__aenter__#531",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Lock",
        "signature": "tornado.locks.Lock.__aenter__(self)",
        "snippet": "    def __aenter__(self):\n        yield self.acquire()",
        "begin_line": 531,
        "end_line": 532,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locks.Lock.__aexit__#535",
        "src_path": "tornado/locks.py",
        "class_name": "tornado.locks.Lock",
        "signature": "tornado.locks.Lock.__aexit__(self, typ, value, tb)",
        "snippet": "    def __aexit__(self, typ, value, tb):\n        self.release()",
        "begin_line": 535,
        "end_line": 536,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locale.get#65",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale",
        "signature": "tornado.locale.get(*locale_codes)",
        "snippet": "def get(*locale_codes):\n    \"\"\"Returns the closest match for the given locale codes.\n\n    We iterate over all given locale codes in order. If we have a tight\n    or a loose match for the code (e.g., \"en\" for \"en_US\"), we return\n    the locale. Otherwise we move to the next code in the list.\n\n    By default we return ``en_US`` if no translations are found for any of\n    the specified locales. You can change the default locale with\n    `set_default_locale()`.\n    \"\"\"\n    return Locale.get_closest(*locale_codes)",
        "begin_line": 65,
        "end_line": 76,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015248551387618176,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locale.load_translations#93",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale",
        "signature": "tornado.locale.load_translations(directory, encoding=None)",
        "snippet": "def load_translations(directory, encoding=None):\n    \"\"\"Loads translations from CSV files in a directory.\n\n    Translations are strings with optional Python-style named placeholders\n    (e.g., ``My name is %(name)s``) and their associated translations.\n\n    The directory should have translation files of the form ``LOCALE.csv``,\n    e.g. ``es_GT.csv``. The CSV files should have two or three columns: string,\n    translation, and an optional plural indicator. Plural indicators should\n    be one of \"plural\" or \"singular\". A given string can have both singular\n    and plural forms. For example ``%(name)s liked this`` may have a\n    different verb conjugation depending on whether %(name)s is one\n    name or a list of names. There should be two rows in the CSV file for\n    that string, one with plural indicator \"singular\", and one \"plural\".\n    For strings with no verbs that would change on translation, simply\n    use \"unknown\" or the empty string (or don't include the column at all).\n\n    The file is read using the `csv` module in the default \"excel\" dialect.\n    In this format there should not be spaces after the commas.\n\n    If no ``encoding`` parameter is given, the encoding will be\n    detected automatically (among UTF-8 and UTF-16) if the file\n    contains a byte-order marker (BOM), defaulting to UTF-8 if no BOM\n    is present.\n\n    Example translation ``es_LA.csv``::\n\n        \"I love you\",\"Te amo\"\n        \"%(name)s liked this\",\"A %(name)s les gust\u00f3 esto\",\"plural\"\n        \"%(name)s liked this\",\"A %(name)s le gust\u00f3 esto\",\"singular\"\n\n    .. versionchanged:: 4.3\n       Added ``encoding`` parameter. Added support for BOM-based encoding\n       detection, UTF-16, and UTF-8-with-BOM.\n    \"\"\"\n    global _translations\n    global _supported_locales\n    _translations = {}\n    for path in os.listdir(directory):\n        if not path.endswith(\".csv\"):\n            continue\n        locale, extension = path.split(\".\")\n        if not re.match(\"[a-z]+(_[A-Z]+)?$\", locale):\n            gen_log.error(\"Unrecognized locale %r (path: %s)\", locale,\n                          os.path.join(directory, path))\n            continue\n        full_path = os.path.join(directory, path)\n        if encoding is None:\n            # Try to autodetect encoding based on the BOM.\n            with open(full_path, 'rb') as f:\n                data = f.read(len(codecs.BOM_UTF16_LE))\n            if data in (codecs.BOM_UTF16_LE, codecs.BOM_UTF16_BE):\n                encoding = 'utf-16'\n            else:\n                # utf-8-sig is \"utf-8 with optional BOM\". It's discouraged\n                # in most cases but is common with CSV files because Excel\n                # cannot read utf-8 files without a BOM.\n                encoding = 'utf-8-sig'\n        if PY3:\n            # python 3: csv.reader requires a file open in text mode.\n            # Force utf8 to avoid dependence on $LANG environment variable.\n            f = open(full_path, \"r\", encoding=encoding)\n        else:\n            # python 2: csv can only handle byte strings (in ascii-compatible\n            # encodings), which we decode below. Transcode everything into\n            # utf8 before passing it to csv.reader.\n            f = BytesIO()\n            with codecs.open(full_path, \"r\", encoding=encoding) as infile:\n                f.write(escape.utf8(infile.read()))\n            f.seek(0)\n        _translations[locale] = {}\n        for i, row in enumerate(csv.reader(f)):\n            if not row or len(row) < 2:\n                continue\n            row = [escape.to_unicode(c).strip() for c in row]\n            english, translation = row[:2]\n            if len(row) > 2:\n                plural = row[2] or \"unknown\"\n            else:\n                plural = \"unknown\"\n            if plural not in (\"plural\", \"singular\", \"unknown\"):\n                gen_log.error(\"Unrecognized plural indicator %r in %s line %d\",\n                              plural, path, i + 1)\n                continue\n            _translations[locale].setdefault(plural, {})[english] = translation\n        f.close()\n    _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])\n    gen_log.debug(\"Supported locales: %s\", sorted(_supported_locales))",
        "begin_line": 93,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locale.load_gettext_translations#183",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale",
        "signature": "tornado.locale.load_gettext_translations(directory, domain)",
        "snippet": "def load_gettext_translations(directory, domain):\n    \"\"\"Loads translations from `gettext`'s locale tree\n\n    Locale tree is similar to system's ``/usr/share/locale``, like::\n\n        {directory}/{lang}/LC_MESSAGES/{domain}.mo\n\n    Three steps are required to have your app translated:\n\n    1. Generate POT translation file::\n\n        xgettext --language=Python --keyword=_:1,2 -d mydomain file1.py file2.html etc\n\n    2. Merge against existing POT file::\n\n        msgmerge old.po mydomain.po > new.po\n\n    3. Compile::\n\n        msgfmt mydomain.po -o {directory}/pt_BR/LC_MESSAGES/mydomain.mo\n    \"\"\"\n    import gettext\n    global _translations\n    global _supported_locales\n    global _use_gettext\n    _translations = {}\n    for lang in os.listdir(directory):\n        if lang.startswith('.'):\n            continue  # skip .svn, etc\n        if os.path.isfile(os.path.join(directory, lang)):\n            continue\n        try:\n            os.stat(os.path.join(directory, lang, \"LC_MESSAGES\", domain + \".mo\"))\n            _translations[lang] = gettext.translation(domain, directory,\n                                                      languages=[lang])\n        except Exception as e:\n            gen_log.error(\"Cannot load translation for '%s': %s\", lang, str(e))\n            continue\n    _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])\n    _use_gettext = True\n    gen_log.debug(\"Supported locales: %s\", sorted(_supported_locales))",
        "begin_line": 183,
        "end_line": 223,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locale.Locale.get_closest#238",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.Locale",
        "signature": "tornado.locale.Locale.get_closest(cls, *locale_codes)",
        "snippet": "    def get_closest(cls, *locale_codes):\n        \"\"\"Returns the closest match for the given locale code.\"\"\"\n        for code in locale_codes:\n            if not code:\n                continue\n            code = code.replace(\"-\", \"_\")\n            parts = code.split(\"_\")\n            if len(parts) > 2:\n                continue\n            elif len(parts) == 2:\n                code = parts[0].lower() + \"_\" + parts[1].upper()\n            if code in _supported_locales:\n                return cls.get(code)\n            if parts[0].lower() in _supported_locales:\n                return cls.get(parts[0].lower())\n        return cls.get(_default_locale)",
        "begin_line": 238,
        "end_line": 253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00015248551387618176,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locale.Locale.get#256",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.Locale",
        "signature": "tornado.locale.Locale.get(cls, code)",
        "snippet": "    def get(cls, code):\n        \"\"\"Returns the Locale for the given locale code.\n\n        If it is not supported, we raise an exception.\n        \"\"\"\n        if not hasattr(cls, \"_cache\"):\n            cls._cache = {}\n        if code not in cls._cache:\n            assert code in _supported_locales\n            translations = _translations.get(code, None)\n            if translations is None:\n                locale = CSVLocale(code, {})\n            elif _use_gettext:\n                locale = GettextLocale(code, translations)\n            else:\n                locale = CSVLocale(code, translations)\n            cls._cache[code] = locale\n        return cls._cache[code]",
        "begin_line": 256,
        "end_line": 273,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locale.Locale.__init__#275",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.Locale",
        "signature": "tornado.locale.Locale.__init__(self, code, translations)",
        "snippet": "    def __init__(self, code, translations):\n        self.code = code\n        self.name = LOCALE_NAMES.get(code, {}).get(\"name\", u\"Unknown\")\n        self.rtl = False\n        for prefix in [\"fa\", \"ar\", \"he\"]:\n            if self.code.startswith(prefix):\n                self.rtl = True\n                break\n        self.translations = translations\n\n        # Initialize strings for date formatting\n        _ = self.translate\n        self._months = [\n            _(\"January\"), _(\"February\"), _(\"March\"), _(\"April\"),\n            _(\"May\"), _(\"June\"), _(\"July\"), _(\"August\"),\n            _(\"September\"), _(\"October\"), _(\"November\"), _(\"December\")]\n        self._weekdays = [\n            _(\"Monday\"), _(\"Tuesday\"), _(\"Wednesday\"), _(\"Thursday\"),\n            _(\"Friday\"), _(\"Saturday\"), _(\"Sunday\")]",
        "begin_line": 275,
        "end_line": 293,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locale.Locale.format_date#308",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.Locale",
        "signature": "tornado.locale.Locale.format_date(self, date, gmt_offset=0, relative=True, shorter=False, full_format=False)",
        "snippet": "    def format_date(self, date, gmt_offset=0, relative=True, shorter=False,\n                    full_format=False):\n        \"\"\"Formats the given date (which should be GMT).\n\n        By default, we return a relative time (e.g., \"2 minutes ago\"). You\n        can return an absolute date string with ``relative=False``.\n\n        You can force a full format date (\"July 10, 1980\") with\n        ``full_format=True``.\n\n        This method is primarily intended for dates in the past.\n        For dates in the future, we fall back to full format.\n        \"\"\"\n        if isinstance(date, numbers.Real):\n            date = datetime.datetime.utcfromtimestamp(date)\n        now = datetime.datetime.utcnow()\n        if date > now:\n            if relative and (date - now).seconds < 60:\n                # Due to click skew, things are some things slightly\n                # in the future. Round timestamps in the immediate\n                # future down to now in relative mode.\n                date = now\n            else:\n                # Otherwise, future dates always use the full format.\n                full_format = True\n        local_date = date - datetime.timedelta(minutes=gmt_offset)\n        local_now = now - datetime.timedelta(minutes=gmt_offset)\n        local_yesterday = local_now - datetime.timedelta(hours=24)\n        difference = now - date\n        seconds = difference.seconds\n        days = difference.days\n\n        _ = self.translate\n        format = None\n        if not full_format:\n            if relative and days == 0:\n                if seconds < 50:\n                    return _(\"1 second ago\", \"%(seconds)d seconds ago\",\n                             seconds) % {\"seconds\": seconds}\n\n                if seconds < 50 * 60:\n                    minutes = round(seconds / 60.0)\n                    return _(\"1 minute ago\", \"%(minutes)d minutes ago\",\n                             minutes) % {\"minutes\": minutes}\n\n                hours = round(seconds / (60.0 * 60))\n                return _(\"1 hour ago\", \"%(hours)d hours ago\",\n                         hours) % {\"hours\": hours}\n\n            if days == 0:\n                format = _(\"%(time)s\")\n            elif days == 1 and local_date.day == local_yesterday.day and \\\n                    relative:\n                format = _(\"yesterday\") if shorter else \\\n                    _(\"yesterday at %(time)s\")\n            elif days < 5:\n                format = _(\"%(weekday)s\") if shorter else \\\n                    _(\"%(weekday)s at %(time)s\")\n            elif days < 334:  # 11mo, since confusing for same month last year\n                format = _(\"%(month_name)s %(day)s\") if shorter else \\\n                    _(\"%(month_name)s %(day)s at %(time)s\")\n\n        if format is None:\n            format = _(\"%(month_name)s %(day)s, %(year)s\") if shorter else \\\n                _(\"%(month_name)s %(day)s, %(year)s at %(time)s\")\n\n        tfhour_clock = self.code not in (\"en\", \"en_US\", \"zh_CN\")\n        if tfhour_clock:\n            str_time = \"%d:%02d\" % (local_date.hour, local_date.minute)\n        elif self.code == \"zh_CN\":\n            str_time = \"%s%d:%02d\" % (\n                (u'\\u4e0a\\u5348', u'\\u4e0b\\u5348')[local_date.hour >= 12],\n                local_date.hour % 12 or 12, local_date.minute)\n        else:\n            str_time = \"%d:%02d %s\" % (\n                local_date.hour % 12 or 12, local_date.minute,\n                (\"am\", \"pm\")[local_date.hour >= 12])\n\n        return format % {\n            \"month_name\": self._months[local_date.month - 1],\n            \"weekday\": self._weekdays[local_date.weekday()],\n            \"day\": str(local_date.day),\n            \"year\": str(local_date.year),\n            \"time\": str_time\n        }",
        "begin_line": 308,
        "end_line": 392,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locale.Locale.format_day#394",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.Locale",
        "signature": "tornado.locale.Locale.format_day(self, date, gmt_offset=0, dow=True)",
        "snippet": "    def format_day(self, date, gmt_offset=0, dow=True):\n        \"\"\"Formats the given date as a day of week.\n\n        Example: \"Monday, January 22\". You can remove the day of week with\n        ``dow=False``.\n        \"\"\"\n        local_date = date - datetime.timedelta(minutes=gmt_offset)\n        _ = self.translate\n        if dow:\n            return _(\"%(weekday)s, %(month_name)s %(day)s\") % {\n                \"month_name\": self._months[local_date.month - 1],\n                \"weekday\": self._weekdays[local_date.weekday()],\n                \"day\": str(local_date.day),\n            }\n        else:\n            return _(\"%(month_name)s %(day)s\") % {\n                \"month_name\": self._months[local_date.month - 1],\n                \"day\": str(local_date.day),\n            }",
        "begin_line": 394,
        "end_line": 412,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locale.Locale.list#414",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.Locale",
        "signature": "tornado.locale.Locale.list(self, parts)",
        "snippet": "    def list(self, parts):\n        \"\"\"Returns a comma-separated list for the given list of parts.\n\n        The format is, e.g., \"A, B and C\", \"A and B\" or just \"A\" for lists\n        of size 1.\n        \"\"\"\n        _ = self.translate\n        if len(parts) == 0:\n            return \"\"\n        if len(parts) == 1:\n            return parts[0]\n        comma = u' \\u0648 ' if self.code.startswith(\"fa\") else u\", \"\n        return _(\"%(commas)s and %(last)s\") % {\n            \"commas\": comma.join(parts[:-1]),\n            \"last\": parts[len(parts) - 1],\n        }",
        "begin_line": 414,
        "end_line": 429,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locale.Locale.friendly_number#431",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.Locale",
        "signature": "tornado.locale.Locale.friendly_number(self, value)",
        "snippet": "    def friendly_number(self, value):\n        \"\"\"Returns a comma-separated number for the given integer.\"\"\"\n        if self.code not in (\"en\", \"en_US\"):\n            return str(value)\n        value = str(value)\n        parts = []\n        while value:\n            parts.append(value[-3:])\n            value = value[:-3]\n        return \",\".join(reversed(parts))",
        "begin_line": 431,
        "end_line": 440,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locale.CSVLocale.translate#445",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.CSVLocale",
        "signature": "tornado.locale.CSVLocale.translate(self, message, plural_message=None, count=None)",
        "snippet": "    def translate(self, message, plural_message=None, count=None):\n        if plural_message is not None:\n            assert count is not None\n            if count != 1:\n                message = plural_message\n                message_dict = self.translations.get(\"plural\", {})\n            else:\n                message_dict = self.translations.get(\"singular\", {})\n        else:\n            message_dict = self.translations.get(\"unknown\", {})\n        return message_dict.get(message, message)",
        "begin_line": 445,
        "end_line": 455,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locale.GettextLocale.__init__#465",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.GettextLocale",
        "signature": "tornado.locale.GettextLocale.__init__(self, code, translations)",
        "snippet": "    def __init__(self, code, translations):\n        try:\n            # python 2\n            self.ngettext = translations.ungettext\n            self.gettext = translations.ugettext\n        except AttributeError:\n            # python 3\n            self.ngettext = translations.ngettext\n            self.gettext = translations.gettext\n        # self.gettext must exist before __init__ is called, since it\n        # calls into self.translate\n        super(GettextLocale, self).__init__(code, translations)",
        "begin_line": 465,
        "end_line": 476,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locale.GettextLocale.translate#478",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.GettextLocale",
        "signature": "tornado.locale.GettextLocale.translate(self, message, plural_message=None, count=None)",
        "snippet": "    def translate(self, message, plural_message=None, count=None):\n        if plural_message is not None:\n            assert count is not None\n            return self.ngettext(message, plural_message, count)\n        else:\n            return self.gettext(message)",
        "begin_line": 478,
        "end_line": 483,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.locale.GettextLocale.pgettext#485",
        "src_path": "tornado/locale.py",
        "class_name": "tornado.locale.GettextLocale",
        "signature": "tornado.locale.GettextLocale.pgettext(self, context, message, plural_message=None, count=None)",
        "snippet": "    def pgettext(self, context, message, plural_message=None, count=None):\n        \"\"\"Allows to set context for translation, accepts plural forms.\n\n        Usage example::\n\n            pgettext(\"law\", \"right\")\n            pgettext(\"good\", \"right\")\n\n        Plural message example::\n\n            pgettext(\"organization\", \"club\", \"clubs\", len(clubs))\n            pgettext(\"stick\", \"club\", \"clubs\", len(clubs))\n\n        To generate POT file with context, add following options to step 1\n        of `load_gettext_translations` sequence::\n\n            xgettext [basic options] --keyword=pgettext:1c,2 --keyword=pgettext:1c,2,3\n\n        .. versionadded:: 4.2\n        \"\"\"\n        if plural_message is not None:\n            assert count is not None\n            msgs_with_ctxt = (\"%s%s%s\" % (context, CONTEXT_SEPARATOR, message),\n                              \"%s%s%s\" % (context, CONTEXT_SEPARATOR, plural_message),\n                              count)\n            result = self.ngettext(*msgs_with_ctxt)\n            if CONTEXT_SEPARATOR in result:\n                # Translation not found\n                result = self.ngettext(message, plural_message, count)\n            return result\n        else:\n            msg_with_ctxt = \"%s%s%s\" % (context, CONTEXT_SEPARATOR, message)\n            result = self.gettext(msg_with_ctxt)\n            if CONTEXT_SEPARATOR in result:\n                # Translation not found\n                result = message\n            return result",
        "begin_line": 485,
        "end_line": 521,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00032562683165092806,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.tcpclient._Connector.__init__#54",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.__init__(self, addrinfo, connect)",
        "snippet": "    def __init__(self, addrinfo, connect):\n        self.io_loop = IOLoop.current()\n        self.connect = connect\n\n        self.future = Future()\n        self.timeout = None\n        self.connect_timeout = None\n        self.last_error = None\n        self.remaining = len(addrinfo)\n        self.primary_addrs, self.secondary_addrs = self.split(addrinfo)\n        self.streams = set()",
        "begin_line": 54,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010309278350515464,
            "pseudo_dstar_susp": 0.0011641443538998836,
            "pseudo_tarantula_susp": 0.0008123476848090983,
            "pseudo_op2_susp": 0.0011641443538998836,
            "pseudo_barinel_susp": 0.0008123476848090983
        }
    },
    {
        "name": "tornado.tcpclient._Connector.split#67",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.split(addrinfo)",
        "snippet": "    def split(addrinfo):\n        \"\"\"Partition the ``addrinfo`` list by address family.\n\n        Returns two lists.  The first list contains the first entry from\n        ``addrinfo`` and all others with the same family, and the\n        second list contains all other addresses (normally one list will\n        be AF_INET and the other AF_INET6, although non-standard resolvers\n        may return additional families).\n        \"\"\"\n        primary = []\n        secondary = []\n        primary_af = addrinfo[0][0]\n        for af, addr in addrinfo:\n            if af == primary_af:\n                primary.append((af, addr))\n            else:\n                secondary.append((af, addr))\n        return primary, secondary",
        "begin_line": 67,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010141987829614604,
            "pseudo_dstar_susp": 0.001142857142857143,
            "pseudo_tarantula_susp": 0.0007968127490039841,
            "pseudo_op2_susp": 0.001142857142857143,
            "pseudo_barinel_susp": 0.0007968127490039841
        }
    },
    {
        "name": "tornado.tcpclient._Connector.start#86",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.start(self, timeout=_INITIAL_CONNECT_TIMEOUT, connect_timeout=None)",
        "snippet": "    def start(self, timeout=_INITIAL_CONNECT_TIMEOUT, connect_timeout=None):\n        self.try_connect(iter(self.primary_addrs))\n        self.set_timeout(timeout)\n        if connect_timeout is not None:\n            self.set_connect_timeout(connect_timeout)\n        return self.future",
        "begin_line": 86,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010427528675703858,
            "pseudo_dstar_susp": 0.0011750881316098707,
            "pseudo_tarantula_susp": 0.0008230452674897119,
            "pseudo_op2_susp": 0.0011750881316098707,
            "pseudo_barinel_susp": 0.0008230452674897119
        }
    },
    {
        "name": "tornado.tcpclient._Connector.try_connect#93",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.try_connect(self, addrs)",
        "snippet": "    def try_connect(self, addrs):\n        try:\n            af, addr = next(addrs)\n        except StopIteration:\n            # We've reached the end of our queue, but the other queue\n            # might still be working.  Send a final error on the future\n            # only when both queues are finished.\n            if self.remaining == 0 and not self.future.done():\n                self.future.set_exception(self.last_error or\n                                          IOError(\"connection failed\"))\n            return\n        stream, future = self.connect(af, addr)\n        self.streams.add(stream)\n        future_add_done_callback(\n            future, functools.partial(self.on_connect_done, addrs, af, addr))",
        "begin_line": 93,
        "end_line": 107,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010427528675703858,
            "pseudo_dstar_susp": 0.0011750881316098707,
            "pseudo_tarantula_susp": 0.001349527665317139,
            "pseudo_op2_susp": 0.0011750881316098707,
            "pseudo_barinel_susp": 0.001349527665317139
        }
    },
    {
        "name": "tornado.tcpclient._Connector.on_connect_done#109",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.on_connect_done(self, addrs, af, addr, future)",
        "snippet": "    def on_connect_done(self, addrs, af, addr, future):\n        self.remaining -= 1\n        try:\n            stream = future.result()\n        except Exception as e:\n            if self.future.done():\n                return\n            # Error: try again (but remember what happened so we have an\n            # error to raise in the end)\n            self.last_error = e\n            self.try_connect(addrs)\n            if self.timeout is not None:\n                # If the first attempt failed, don't wait for the\n                # timeout to try an address from the secondary queue.\n                self.io_loop.remove_timeout(self.timeout)\n                self.on_timeout()\n            return\n        self.clear_timeouts()\n        if self.future.done():\n            # This is a late arrival; just drop it.\n            stream.close()\n        else:\n            self.streams.discard(stream)\n            self.future.set_result((af, addr, stream))\n            self.close_streams()",
        "begin_line": 109,
        "end_line": 133,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010582010582010583,
            "pseudo_dstar_susp": 0.0011862396204033216,
            "pseudo_tarantula_susp": 0.0010857763300760044,
            "pseudo_op2_susp": 0.0011862396204033216,
            "pseudo_barinel_susp": 0.0010857763300760044
        }
    },
    {
        "name": "tornado.tcpclient._Connector.set_timeout#135",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.set_timeout(self, timeout)",
        "snippet": "    def set_timeout(self, timeout):\n        self.timeout = self.io_loop.add_timeout(self.io_loop.time() + timeout,\n                                                self.on_timeout)",
        "begin_line": 135,
        "end_line": 137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010427528675703858,
            "pseudo_dstar_susp": 0.0011750881316098707,
            "pseudo_tarantula_susp": 0.0008230452674897119,
            "pseudo_op2_susp": 0.0011750881316098707,
            "pseudo_barinel_susp": 0.0008230452674897119
        }
    },
    {
        "name": "tornado.tcpclient._Connector.on_timeout#139",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.on_timeout(self)",
        "snippet": "    def on_timeout(self):\n        self.timeout = None\n        if not self.future.done():\n            self.try_connect(iter(self.secondary_addrs))",
        "begin_line": 139,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0004302925989672978,
            "pseudo_dstar_susp": 0.00038955979742890534,
            "pseudo_tarantula_susp": 0.0006825938566552901,
            "pseudo_op2_susp": 0.00038955979742890534,
            "pseudo_barinel_susp": 0.0006825938566552901
        }
    },
    {
        "name": "tornado.tcpclient._Connector.set_connect_timeout#148",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.set_connect_timeout(self, connect_timeout)",
        "snippet": "    def set_connect_timeout(self, connect_timeout):\n        self.connect_timeout = self.io_loop.add_timeout(\n            connect_timeout, self.on_connect_timeout)",
        "begin_line": 148,
        "end_line": 150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.00016983695652173913,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.tcpclient._Connector.on_connect_timeout#152",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.on_connect_timeout(self)",
        "snippet": "    def on_connect_timeout(self):\n        if not self.future.done():\n            self.future.set_exception(TimeoutError())\n        self.close_streams()",
        "begin_line": 152,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00019603999215840032,
            "pseudo_dstar_susp": 0.00019603999215840032,
            "pseudo_tarantula_susp": 0.00019603999215840032,
            "pseudo_op2_susp": 0.0002143163309044149,
            "pseudo_barinel_susp": 0.00019603999215840032
        }
    },
    {
        "name": "tornado.tcpclient._Connector.clear_timeouts#157",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.clear_timeouts(self)",
        "snippet": "    def clear_timeouts(self):\n        if self.timeout is not None:\n            self.io_loop.remove_timeout(self.timeout)\n        if self.connect_timeout is not None:\n            self.io_loop.remove_timeout(self.connect_timeout)",
        "begin_line": 157,
        "end_line": 161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.000968054211035818,
            "pseudo_dstar_susp": 0.0010351966873706005,
            "pseudo_tarantula_susp": 0.0008431703204047217,
            "pseudo_op2_susp": 0.0010351966873706005,
            "pseudo_barinel_susp": 0.0008431703204047217
        }
    },
    {
        "name": "tornado.tcpclient._Connector.close_streams#163",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient._Connector",
        "signature": "tornado.tcpclient._Connector.close_streams(self)",
        "snippet": "    def close_streams(self):\n        for stream in self.streams:\n            stream.close()",
        "begin_line": 163,
        "end_line": 165,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0009328358208955224,
            "pseudo_dstar_susp": 0.0010141987829614604,
            "pseudo_tarantula_susp": 0.0007930214115781126,
            "pseudo_op2_susp": 0.0010141987829614604,
            "pseudo_barinel_susp": 0.0007930214115781126
        }
    },
    {
        "name": "tornado.tcpclient.TCPClient.__init__#174",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient.TCPClient",
        "signature": "tornado.tcpclient.TCPClient.__init__(self, resolver=None)",
        "snippet": "    def __init__(self, resolver=None):\n        if resolver is not None:\n            self.resolver = resolver\n            self._own_resolver = False\n        else:\n            self.resolver = Resolver()\n            self._own_resolver = True",
        "begin_line": 174,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001949317738791423,
            "pseudo_dstar_susp": 0.0020325203252032522,
            "pseudo_tarantula_susp": 0.001288659793814433,
            "pseudo_op2_susp": 0.0020325203252032522,
            "pseudo_barinel_susp": 0.001288659793814433
        }
    },
    {
        "name": "tornado.tcpclient.TCPClient.close#182",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient.TCPClient",
        "signature": "tornado.tcpclient.TCPClient.close(self)",
        "snippet": "    def close(self):\n        if self._own_resolver:\n            self.resolver.close()",
        "begin_line": 182,
        "end_line": 184,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0014925373134328358,
            "pseudo_dstar_susp": 0.0015060240963855422,
            "pseudo_tarantula_susp": 0.0010787486515641855,
            "pseudo_op2_susp": 0.0015060240963855422,
            "pseudo_barinel_susp": 0.0010787486515641855
        }
    },
    {
        "name": "tornado.tcpclient.TCPClient.connect#187",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient.TCPClient",
        "signature": "tornado.tcpclient.TCPClient.connect(self, host, port, af=socket.AF_UNSPEC, ssl_options=None, max_buffer_size=None, source_ip=None, source_port=None, timeout=None)",
        "snippet": "    def connect(self, host, port, af=socket.AF_UNSPEC, ssl_options=None,\n                max_buffer_size=None, source_ip=None, source_port=None,\n                timeout=None):\n        \"\"\"Connect to the given host and port.\n\n        Asynchronously returns an `.IOStream` (or `.SSLIOStream` if\n        ``ssl_options`` is not None).\n\n        Using the ``source_ip`` kwarg, one can specify the source\n        IP address to use when establishing the connection.\n        In case the user needs to resolve and\n        use a specific interface, it has to be handled outside\n        of Tornado as this depends very much on the platform.\n\n        Raises `TimeoutError` if the input future does not complete before\n        ``timeout``, which may be specified in any form allowed by\n        `.IOLoop.add_timeout` (i.e. a `datetime.timedelta` or an absolute time\n        relative to `.IOLoop.time`)\n\n        Similarly, when the user requires a certain source port, it can\n        be specified using the ``source_port`` arg.\n\n        .. versionchanged:: 4.5\n           Added the ``source_ip`` and ``source_port`` arguments.\n\n        .. versionchanged:: 5.0\n           Added the ``timeout`` argument.\n        \"\"\"\n        if timeout is not None:\n            if isinstance(timeout, numbers.Real):\n                timeout = IOLoop.current().time() + timeout\n            elif isinstance(timeout, datetime.timedelta):\n                timeout = IOLoop.current().time() + timedelta_to_seconds(timeout)\n            else:\n                raise TypeError(\"Unsupported timeout %r\" % timeout)\n        if timeout is not None:\n            addrinfo = yield gen.with_timeout(\n                timeout, self.resolver.resolve(host, port, af))\n        else:\n            addrinfo = yield self.resolver.resolve(host, port, af)\n        connector = _Connector(\n            addrinfo,\n            functools.partial(self._create_stream, max_buffer_size,\n                              source_ip=source_ip, source_port=source_port)\n        )\n        af, addr, stream = yield connector.start(connect_timeout=timeout)\n        # TODO: For better performance we could cache the (af, addr)\n        # information here and re-use it on subsequent connections to\n        # the same host. (http://tools.ietf.org/html/rfc6555#section-4.2)\n        if ssl_options is not None:\n            if timeout is not None:\n                stream = yield gen.with_timeout(timeout, stream.start_tls(\n                    False, ssl_options=ssl_options, server_hostname=host))\n            else:\n                stream = yield stream.start_tls(False, ssl_options=ssl_options,\n                                                server_hostname=host)\n        raise gen.Return(stream)",
        "begin_line": 187,
        "end_line": 243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010845986984815619,
            "pseudo_dstar_susp": 0.0012165450121654502,
            "pseudo_tarantula_susp": 0.0009149130832570906,
            "pseudo_op2_susp": 0.0012165450121654502,
            "pseudo_barinel_susp": 0.0009149130832570906
        }
    },
    {
        "name": "tornado.tcpclient.TCPClient._create_stream#245",
        "src_path": "tornado/tcpclient.py",
        "class_name": "tornado.tcpclient.TCPClient",
        "signature": "tornado.tcpclient.TCPClient._create_stream(self, max_buffer_size, af, addr, source_ip=None, source_port=None)",
        "snippet": "    def _create_stream(self, max_buffer_size, af, addr, source_ip=None,\n                       source_port=None):\n        # Always connect in plaintext; we'll convert to ssl if necessary\n        # after one connection has completed.\n        source_port_bind = source_port if isinstance(source_port, int) else 0\n        source_ip_bind = source_ip\n        if source_port_bind and not source_ip:\n            # User required a specific port, but did not specify\n            # a certain source IP, will bind to the default loopback.\n            source_ip_bind = '::1' if af == socket.AF_INET6 else '127.0.0.1'\n            # Trying to use the same address family as the requested af socket:\n            # - 127.0.0.1 for IPv4\n            # - ::1 for IPv6\n        socket_obj = socket.socket(af)\n        set_close_exec(socket_obj.fileno())\n        if source_port_bind or source_ip_bind:\n            # If the user requires binding also to a specific IP/port.\n            try:\n                socket_obj.bind((source_ip_bind, source_port_bind))\n            except socket.error:\n                socket_obj.close()\n                # Fail loudly if unable to use the IP/port.\n                raise\n        try:\n            stream = IOStream(socket_obj,\n                              max_buffer_size=max_buffer_size)\n        except socket.error as e:\n            fu = Future()\n            fu.set_exception(e)\n            return fu\n        else:\n            return stream, stream.connect(addr)",
        "begin_line": 245,
        "end_line": 276,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0010976948408342481,
            "pseudo_dstar_susp": 0.0012285012285012285,
            "pseudo_tarantula_susp": 0.0009216589861751152,
            "pseudo_op2_susp": 0.0012285012285012285,
            "pseudo_barinel_susp": 0.0009216589861751152
        }
    }
]