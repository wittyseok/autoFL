[
    {
        "name": "tests.conftest.backup_dir#17",
        "src_path": "tests/conftest.py",
        "class_name": "tests.conftest",
        "signature": "tests.conftest.backup_dir(original_dir, backup_dir)",
        "snippet": "def backup_dir(original_dir, backup_dir):\n    \"\"\"Generate backup directory based on original directory.\"\"\"\n    # If the default original_dir is pre-existing, move it to a temp location\n    if not os.path.isdir(original_dir):\n        return False\n\n    # Remove existing backups before backing up. If they exist, they're stale.\n    if os.path.isdir(backup_dir):\n        utils.rmtree(backup_dir)\n\n    shutil.copytree(original_dir, backup_dir)\n    return True",
        "begin_line": 17,
        "end_line": 28,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.conftest.restore_backup_dir#31",
        "src_path": "tests/conftest.py",
        "class_name": "tests.conftest",
        "signature": "tests.conftest.restore_backup_dir(original_dir, backup_dir, original_dir_found)",
        "snippet": "def restore_backup_dir(original_dir, backup_dir, original_dir_found):\n    \"\"\"Restore default contents.\"\"\"\n    # Carefully delete the created original_dir only in certain\n    # conditions.\n    original_dir_is_dir = os.path.isdir(original_dir)\n    if original_dir_found:\n        # Delete the created original_dir as long as a backup\n        # exists\n        if original_dir_is_dir and os.path.isdir(backup_dir):\n            utils.rmtree(original_dir)\n    else:\n        # Delete the created original_dir.\n        # There's no backup because it never existed\n        if original_dir_is_dir:\n            utils.rmtree(original_dir)\n\n    # Restore the user's default original_dir contents\n    if os.path.isdir(backup_dir):\n        shutil.copytree(backup_dir, original_dir)\n    if os.path.isdir(original_dir):\n        utils.rmtree(backup_dir)",
        "begin_line": 31,
        "end_line": 51,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.conftest.clean_system#55",
        "src_path": "tests/conftest.py",
        "class_name": "tests.conftest",
        "signature": "tests.conftest.clean_system(request)",
        "snippet": "def clean_system(request):\n    \"\"\"Fixture. Simulates a clean system with no configured or cloned cookiecutters.\n\n    It runs code which can be regarded as setup code as known from a unittest\n    TestCase. Additionally it defines a local function referring to values\n    which have been stored to local variables in the setup such as the location\n    of the cookiecutters on disk. This function is registered as a teardown\n    hook with `request.addfinalizer` at the very end of the fixture. Pytest\n    runs the named hook as soon as the fixture is out of scope, when the test\n    finished to put it another way.\n\n    During setup:\n\n    * Back up the `~/.cookiecutterrc` config file to `~/.cookiecutterrc.backup`\n    * Back up the `~/.cookiecutters/` dir to `~/.cookiecutters.backup/`\n    * Back up the `~/.cookiecutter_replay/` dir to\n      `~/.cookiecutter_replay.backup/`\n    * Starts off a test case with no pre-existing `~/.cookiecutterrc` or\n      `~/.cookiecutters/` or `~/.cookiecutter_replay/`\n\n    During teardown:\n\n    * Delete `~/.cookiecutters/` only if a backup is present at\n      `~/.cookiecutters.backup/`\n    * Delete `~/.cookiecutter_replay/` only if a backup is present at\n      `~/.cookiecutter_replay.backup/`\n    * Restore the `~/.cookiecutterrc` config file from\n      `~/.cookiecutterrc.backup`\n    * Restore the `~/.cookiecutters/` dir from `~/.cookiecutters.backup/`\n    * Restore the `~/.cookiecutter_replay/` dir from\n      `~/.cookiecutter_replay.backup/`\n\n    \"\"\"\n    # If ~/.cookiecutterrc is pre-existing, move it to a temp location\n    user_config_path = os.path.expanduser('~/.cookiecutterrc')\n    user_config_path_backup = os.path.expanduser('~/.cookiecutterrc.backup')\n    if os.path.exists(user_config_path):\n        user_config_found = True\n        shutil.copy(user_config_path, user_config_path_backup)\n        os.remove(user_config_path)\n    else:\n        user_config_found = False\n\n    # If the default cookiecutters_dir is pre-existing, move it to a\n    # temp location\n    cookiecutters_dir = os.path.expanduser('~/.cookiecutters')\n    cookiecutters_dir_backup = os.path.expanduser('~/.cookiecutters.backup')\n    cookiecutters_dir_found = backup_dir(cookiecutters_dir, cookiecutters_dir_backup)\n\n    # If the default cookiecutter_replay_dir is pre-existing, move it to a\n    # temp location\n    cookiecutter_replay_dir = os.path.expanduser('~/.cookiecutter_replay')\n    cookiecutter_replay_dir_backup = os.path.expanduser('~/.cookiecutter_replay.backup')\n    cookiecutter_replay_dir_found = backup_dir(\n        cookiecutter_replay_dir, cookiecutter_replay_dir_backup\n    )\n\n    def restore_backup():\n        # If it existed, restore ~/.cookiecutterrc\n        # We never write to ~/.cookiecutterrc, so this logic is simpler.\n        if user_config_found and os.path.exists(user_config_path_backup):\n            shutil.copy(user_config_path_backup, user_config_path)\n            os.remove(user_config_path_backup)\n\n        # Carefully delete the created ~/.cookiecutters dir only in certain\n        # conditions.\n        restore_backup_dir(\n            cookiecutters_dir, cookiecutters_dir_backup, cookiecutters_dir_found\n        )\n\n        # Carefully delete the created ~/.cookiecutter_replay dir only in\n        # certain conditions.\n        restore_backup_dir(\n            cookiecutter_replay_dir,\n            cookiecutter_replay_dir_backup,\n            cookiecutter_replay_dir_found,\n        )\n\n    request.addfinalizer(restore_backup)",
        "begin_line": 55,
        "end_line": 133,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.conftest.restore_backup#112",
        "src_path": "tests/conftest.py",
        "class_name": "tests.conftest",
        "signature": "tests.conftest.restore_backup()",
        "snippet": "    def restore_backup():\n        # If it existed, restore ~/.cookiecutterrc\n        # We never write to ~/.cookiecutterrc, so this logic is simpler.\n        if user_config_found and os.path.exists(user_config_path_backup):\n            shutil.copy(user_config_path_backup, user_config_path)\n            os.remove(user_config_path_backup)\n\n        # Carefully delete the created ~/.cookiecutters dir only in certain\n        # conditions.\n        restore_backup_dir(\n            cookiecutters_dir, cookiecutters_dir_backup, cookiecutters_dir_found\n        )\n\n        # Carefully delete the created ~/.cookiecutter_replay dir only in\n        # certain conditions.\n        restore_backup_dir(\n            cookiecutter_replay_dir,\n            cookiecutter_replay_dir_backup,\n            cookiecutter_replay_dir_found,\n        )",
        "begin_line": 112,
        "end_line": 131,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.conftest.disable_poyo_logging#181",
        "src_path": "tests/conftest.py",
        "class_name": "tests.conftest",
        "signature": "tests.conftest.disable_poyo_logging()",
        "snippet": "def disable_poyo_logging():\n    \"\"\"Fixture that disables poyo logging.\"\"\"\n    logging.getLogger('poyo').setLevel(logging.WARNING)",
        "begin_line": 181,
        "end_line": 183,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test-extensions.hello_extension.hello_extension.HelloExtension.__init__#11",
        "src_path": "tests/test-extensions/hello_extension/hello_extension.py",
        "class_name": "tests.test-extensions.hello_extension.hello_extension.HelloExtension",
        "signature": "tests.test-extensions.hello_extension.hello_extension.HelloExtension.__init__(self, environment)",
        "snippet": "    def __init__(self, environment):\n        \"\"\"Hello Extension Constructor.\"\"\"\n        super(HelloExtension, self).__init__(environment)",
        "begin_line": 11,
        "end_line": 13,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test-extensions.hello_extension.hello_extension.HelloExtension._hello#15",
        "src_path": "tests/test-extensions/hello_extension/hello_extension.py",
        "class_name": "tests.test-extensions.hello_extension.hello_extension.HelloExtension",
        "signature": "tests.test-extensions.hello_extension.hello_extension.HelloExtension._hello(self, name)",
        "snippet": "    def _hello(self, name):\n        \"\"\"Do actual tag replace when invoked by parser.\"\"\"\n        return 'Hello {name}!'.format(name=name)",
        "begin_line": 15,
        "end_line": 17,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test-extensions.hello_extension.hello_extension.HelloExtension.parse#19",
        "src_path": "tests/test-extensions/hello_extension/hello_extension.py",
        "class_name": "tests.test-extensions.hello_extension.hello_extension.HelloExtension",
        "signature": "tests.test-extensions.hello_extension.hello_extension.HelloExtension.parse(self, parser)",
        "snippet": "    def parse(self, parser):\n        \"\"\"Work when something match `tags` variable.\"\"\"\n        lineno = next(parser.stream).lineno\n        node = parser.parse_expression()\n        call_method = self.call_method('_hello', [node], lineno=lineno)\n        return nodes.Output([call_method], lineno=lineno)",
        "begin_line": 19,
        "end_line": 24,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.make_test_repo#12",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks",
        "signature": "tests.test_hooks.make_test_repo(name, multiple_hooks=False)",
        "snippet": "def make_test_repo(name, multiple_hooks=False):\n    \"\"\"Create test repository for test setup methods.\"\"\"\n    hook_dir = os.path.join(name, 'hooks')\n    template = os.path.join(name, 'input{{hooks}}')\n    os.mkdir(name)\n    os.mkdir(hook_dir)\n    os.mkdir(template)\n\n    with open(os.path.join(template, 'README.rst'), 'w') as f:\n        f.write(\"foo\\n===\\n\\nbar\\n\")\n\n    with open(os.path.join(hook_dir, 'pre_gen_project.py'), 'w') as f:\n        f.write(\"#!/usr/bin/env python\\n\")\n        f.write(\"# -*- coding: utf-8 -*-\\n\")\n        f.write(\"from __future__ import print_function\\n\")\n        f.write(\"\\n\")\n        f.write(\"print('pre generation hook')\\n\")\n        f.write(\"f = open('python_pre.txt', 'w')\\n\")\n        f.write(\"f.close()\\n\")\n\n    if sys.platform.startswith('win'):\n        post = 'post_gen_project.bat'\n        with open(os.path.join(hook_dir, post), 'w') as f:\n            f.write(\"@echo off\\n\")\n            f.write(\"\\n\")\n            f.write(\"echo post generation hook\\n\")\n            f.write(\"echo. >shell_post.txt\\n\")\n    else:\n        post = 'post_gen_project.sh'\n        filename = os.path.join(hook_dir, post)\n        with open(filename, 'w') as f:\n            f.write(\"#!/bin/bash\\n\")\n            f.write(\"\\n\")\n            f.write(\"echo 'post generation hook';\\n\")\n            f.write(\"touch 'shell_post.txt'\\n\")\n        # Set the execute bit\n        os.chmod(filename, os.stat(filename).st_mode | stat.S_IXUSR)\n\n    # Adding an additional pre script\n    if multiple_hooks:\n        if sys.platform.startswith('win'):\n            pre = 'pre_gen_project.bat'\n            with open(os.path.join(hook_dir, pre), 'w') as f:\n                f.write(\"@echo off\\n\")\n                f.write(\"\\n\")\n                f.write(\"echo post generation hook\\n\")\n                f.write(\"echo. >shell_pre.txt\\n\")\n        else:\n            pre = 'pre_gen_project.sh'\n            filename = os.path.join(hook_dir, pre)\n            with open(filename, 'w') as f:\n                f.write(\"#!/bin/bash\\n\")\n                f.write(\"\\n\")\n                f.write(\"echo 'post generation hook';\\n\")\n                f.write(\"touch 'shell_pre.txt'\\n\")\n            # Set the execute bit\n            os.chmod(filename, os.stat(filename).st_mode | stat.S_IXUSR)\n\n    return post",
        "begin_line": 12,
        "end_line": 70,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestFindHooks.setup_method#78",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestFindHooks",
        "signature": "tests.test_hooks.TestFindHooks.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n        \"\"\"Find hooks related tests setup fixture.\"\"\"\n        self.post_hook = make_test_repo(self.repo_path)",
        "begin_line": 78,
        "end_line": 80,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestFindHooks.teardown_method#82",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestFindHooks",
        "signature": "tests.test_hooks.TestFindHooks.teardown_method(self, method)",
        "snippet": "    def teardown_method(self, method):\n        \"\"\"Find hooks related tests teardown fixture.\"\"\"\n        utils.rmtree(self.repo_path)",
        "begin_line": 82,
        "end_line": 84,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestFindHooks.test_find_hook#86",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestFindHooks",
        "signature": "tests.test_hooks.TestFindHooks.test_find_hook(self)",
        "snippet": "    def test_find_hook(self):\n        \"\"\"Finds the specified hook.\"\"\"\n        with utils.work_in(self.repo_path):\n            expected_pre = os.path.abspath('hooks/pre_gen_project.py')\n            actual_hook_path = hooks.find_hook('pre_gen_project')\n            assert expected_pre == actual_hook_path[0]\n\n            expected_post = os.path.abspath('hooks/{}'.format(self.post_hook))\n            actual_hook_path = hooks.find_hook('post_gen_project')\n            assert expected_post == actual_hook_path[0]",
        "begin_line": 86,
        "end_line": 95,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestFindHooks.test_no_hooks#97",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestFindHooks",
        "signature": "tests.test_hooks.TestFindHooks.test_no_hooks(self)",
        "snippet": "    def test_no_hooks(self):\n        \"\"\"`find_hooks` should return None if the hook could not be found.\"\"\"\n        with utils.work_in('tests/fake-repo'):\n            assert None is hooks.find_hook('pre_gen_project')",
        "begin_line": 97,
        "end_line": 100,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestFindHooks.test_unknown_hooks_dir#102",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestFindHooks",
        "signature": "tests.test_hooks.TestFindHooks.test_unknown_hooks_dir(self)",
        "snippet": "    def test_unknown_hooks_dir(self):\n        \"\"\"`find_hooks` should return None if hook directory not found.\"\"\"\n        with utils.work_in(self.repo_path):\n            assert hooks.find_hook('pre_gen_project', hooks_dir='hooks_dir') is None",
        "begin_line": 102,
        "end_line": 105,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestFindHooks.test_hook_not_found#107",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestFindHooks",
        "signature": "tests.test_hooks.TestFindHooks.test_hook_not_found(self)",
        "snippet": "    def test_hook_not_found(self):\n        \"\"\"`find_hooks` should return None if the hook could not be found.\"\"\"\n        with utils.work_in(self.repo_path):\n            assert hooks.find_hook('unknown_hook') is None",
        "begin_line": 107,
        "end_line": 110,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestExternalHooks.setup_method#119",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestExternalHooks",
        "signature": "tests.test_hooks.TestExternalHooks.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n        \"\"\"External hooks related tests setup fixture.\"\"\"\n        self.post_hook = make_test_repo(self.repo_path, multiple_hooks=True)",
        "begin_line": 119,
        "end_line": 121,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestExternalHooks.teardown_method#123",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestExternalHooks",
        "signature": "tests.test_hooks.TestExternalHooks.teardown_method(self, method)",
        "snippet": "    def teardown_method(self, method):\n        \"\"\"External hooks related tests teardown fixture.\"\"\"\n        utils.rmtree(self.repo_path)\n\n        if os.path.exists('python_pre.txt'):\n            os.remove('python_pre.txt')\n        if os.path.exists('shell_post.txt'):\n            os.remove('shell_post.txt')\n        if os.path.exists('shell_pre.txt'):\n            os.remove('shell_pre.txt')\n        if os.path.exists('tests/shell_post.txt'):\n            os.remove('tests/shell_post.txt')\n        if os.path.exists('tests/test-hooks/input{{hooks}}/python_pre.txt'):\n            os.remove('tests/test-hooks/input{{hooks}}/python_pre.txt')\n        if os.path.exists('tests/test-hooks/input{{hooks}}/shell_post.txt'):\n            os.remove('tests/test-hooks/input{{hooks}}/shell_post.txt')\n        if os.path.exists('tests/context_post.txt'):\n            os.remove('tests/context_post.txt')",
        "begin_line": 123,
        "end_line": 140,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestExternalHooks.test_run_script#142",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestExternalHooks",
        "signature": "tests.test_hooks.TestExternalHooks.test_run_script(self)",
        "snippet": "    def test_run_script(self):\n        \"\"\"Execute a hook script, independently of project generation.\"\"\"\n        hooks.run_script(os.path.join(self.hooks_path, self.post_hook))\n        assert os.path.isfile('shell_post.txt')",
        "begin_line": 142,
        "end_line": 145,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestExternalHooks.test_run_script_cwd#147",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestExternalHooks",
        "signature": "tests.test_hooks.TestExternalHooks.test_run_script_cwd(self)",
        "snippet": "    def test_run_script_cwd(self):\n        \"\"\"Change directory before running hook.\"\"\"\n        hooks.run_script(os.path.join(self.hooks_path, self.post_hook), 'tests')\n        assert os.path.isfile('tests/shell_post.txt')\n        assert 'tests' not in os.getcwd()",
        "begin_line": 147,
        "end_line": 151,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestExternalHooks.test_run_script_with_context#153",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestExternalHooks",
        "signature": "tests.test_hooks.TestExternalHooks.test_run_script_with_context(self)",
        "snippet": "    def test_run_script_with_context(self):\n        \"\"\"Execute a hook script, passing a context.\"\"\"\n        hook_path = os.path.join(self.hooks_path, 'post_gen_project.sh')\n\n        if sys.platform.startswith('win'):\n            post = 'post_gen_project.bat'\n            with open(os.path.join(self.hooks_path, post), 'w') as f:\n                f.write(\"@echo off\\n\")\n                f.write(\"\\n\")\n                f.write(\"echo post generation hook\\n\")\n                f.write(\"echo. >{{cookiecutter.file}}\\n\")\n        else:\n            with open(hook_path, 'w') as fh:\n                fh.write(\"#!/bin/bash\\n\")\n                fh.write(\"\\n\")\n                fh.write(\"echo 'post generation hook';\\n\")\n                fh.write(\"touch 'shell_post.txt'\\n\")\n                fh.write(\"touch '{{cookiecutter.file}}'\\n\")\n                os.chmod(hook_path, os.stat(hook_path).st_mode | stat.S_IXUSR)\n\n        hooks.run_script_with_context(\n            os.path.join(self.hooks_path, self.post_hook),\n            'tests',\n            {'cookiecutter': {'file': 'context_post.txt'}},\n        )\n        assert os.path.isfile('tests/context_post.txt')\n        assert 'tests' not in os.getcwd()",
        "begin_line": 153,
        "end_line": 179,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestExternalHooks.test_run_hook#181",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestExternalHooks",
        "signature": "tests.test_hooks.TestExternalHooks.test_run_hook(self)",
        "snippet": "    def test_run_hook(self):\n        \"\"\"Execute hook from specified template in specified output \\\n        directory.\"\"\"\n        tests_dir = os.path.join(self.repo_path, 'input{{hooks}}')\n        with utils.work_in(self.repo_path):\n            hooks.run_hook('pre_gen_project', tests_dir, {})\n            assert os.path.isfile(os.path.join(tests_dir, 'python_pre.txt'))\n            assert os.path.isfile(os.path.join(tests_dir, 'shell_pre.txt'))\n\n            hooks.run_hook('post_gen_project', tests_dir, {})\n            assert os.path.isfile(os.path.join(tests_dir, 'shell_post.txt'))",
        "begin_line": 181,
        "end_line": 191,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestExternalHooks.test_run_failing_hook#193",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestExternalHooks",
        "signature": "tests.test_hooks.TestExternalHooks.test_run_failing_hook(self)",
        "snippet": "    def test_run_failing_hook(self):\n        \"\"\"Test correct exception raise if hook exit code is not zero.\"\"\"\n        hook_path = os.path.join(self.hooks_path, 'pre_gen_project.py')\n        tests_dir = os.path.join(self.repo_path, 'input{{hooks}}')\n\n        with open(hook_path, 'w') as f:\n            f.write(\"#!/usr/bin/env python\\n\")\n            f.write(\"import sys; sys.exit(1)\\n\")\n\n        with utils.work_in(self.repo_path):\n            with pytest.raises(exceptions.FailedHookException) as excinfo:\n                hooks.run_hook('pre_gen_project', tests_dir, {})\n            assert 'Hook script failed' in str(excinfo.value)",
        "begin_line": 193,
        "end_line": 205,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.dir_with_hooks#209",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks",
        "signature": "tests.test_hooks.dir_with_hooks(tmpdir)",
        "snippet": "def dir_with_hooks(tmpdir):\n    \"\"\"Yield a directory that contains hook backup files.\"\"\"\n    hooks_dir = tmpdir.mkdir('hooks')\n\n    pre_hook_content = textwrap.dedent(\n        \"\"\"\n        #!/usr/bin/env python\n        # -*- coding: utf-8 -*-\n        print('pre_gen_project.py~')\n        \"\"\"\n    )\n    pre_gen_hook_file = hooks_dir / 'pre_gen_project.py~'\n    pre_gen_hook_file.write_text(pre_hook_content, encoding='utf8')\n\n    post_hook_content = textwrap.dedent(\n        \"\"\"\n        #!/usr/bin/env python\n        # -*- coding: utf-8 -*-\n        print('post_gen_project.py~')\n        \"\"\"\n    )\n\n    post_gen_hook_file = hooks_dir / 'post_gen_project.py~'\n    post_gen_hook_file.write_text(post_hook_content, encoding='utf8')\n\n    # Make sure to yield the parent directory as `find_hooks()`\n    # looks into `hooks/` in the current working directory\n    yield str(tmpdir)\n\n    pre_gen_hook_file.remove()\n    post_gen_hook_file.remove()",
        "begin_line": 209,
        "end_line": 239,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.test_ignore_hook_backup_files#242",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks",
        "signature": "tests.test_hooks.test_ignore_hook_backup_files(monkeypatch, dir_with_hooks)",
        "snippet": "def test_ignore_hook_backup_files(monkeypatch, dir_with_hooks):\n    \"\"\"Test `find_hook` correctly use `valid_hook` verification function.\"\"\"\n    # Change the current working directory that contains `hooks/`\n    monkeypatch.chdir(dir_with_hooks)\n    assert hooks.find_hook('pre_gen_project') is None\n    assert hooks.find_hook('post_gen_project') is None",
        "begin_line": 242,
        "end_line": 247,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.replay.conftest.context#6",
        "src_path": "tests/replay/conftest.py",
        "class_name": "tests.replay.conftest",
        "signature": "tests.replay.conftest.context()",
        "snippet": "def context():\n    \"\"\"Fixture to return a valid context as known from a cookiecutter.json.\"\"\"\n    return {\n        'cookiecutter': {\n            'email': 'raphael@hackebrot.de',\n            'full_name': 'Raphael Pierzina',\n            'github_username': 'hackebrot',\n            'version': '0.1.0',\n        }\n    }",
        "begin_line": 6,
        "end_line": 15,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.replay.conftest.replay_test_dir#19",
        "src_path": "tests/replay/conftest.py",
        "class_name": "tests.replay.conftest",
        "signature": "tests.replay.conftest.replay_test_dir()",
        "snippet": "def replay_test_dir():\n    \"\"\"Fixture to test directory.\"\"\"\n    return 'tests/test-replay/'",
        "begin_line": 19,
        "end_line": 21,
        "comment": "",
        "is_bug": false
    }
]