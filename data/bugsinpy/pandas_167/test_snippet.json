[
    {
        "name": "pandas.tests.indexes.conftest.indices#28",
        "src_path": "pandas/tests/indexes/conftest.py",
        "class_name": "pandas.tests.indexes.conftest",
        "signature": "pandas.tests.indexes.conftest.indices(request)",
        "snippet": "def indices(request):\n    return request.param",
        "begin_line": 28,
        "end_line": 29,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.conftest.one#33",
        "src_path": "pandas/tests/indexes/conftest.py",
        "class_name": "pandas.tests.indexes.conftest",
        "signature": "pandas.tests.indexes.conftest.one(request)",
        "snippet": "def one(request):\n    # zero-dim integer array behaves like an integer\n    return request.param",
        "begin_line": 33,
        "end_line": 35,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_dti_slicing#24",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_dti_slicing(self)",
        "snippet": "    def test_dti_slicing(self):\n        dti = date_range(start=\"1/1/2005\", end=\"12/1/2005\", freq=\"M\")\n        dti2 = dti[[1, 3, 5]]\n\n        v1 = dti2[0]\n        v2 = dti2[1]\n        v3 = dti2[2]\n\n        assert v1 == Timestamp(\"2/28/2005\")\n        assert v2 == Timestamp(\"4/30/2005\")\n        assert v3 == Timestamp(\"6/30/2005\")\n\n        # don't carry freq through irregular slicing\n        assert dti2.freq is None",
        "begin_line": 24,
        "end_line": 37,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_slice_keeps_name#39",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_slice_keeps_name(self)",
        "snippet": "    def test_slice_keeps_name(self):\n        # GH4226\n        st = pd.Timestamp(\"2013-07-01 00:00:00\", tz=\"America/Los_Angeles\")\n        et = pd.Timestamp(\"2013-07-02 00:00:00\", tz=\"America/Los_Angeles\")\n        dr = pd.date_range(st, et, freq=\"H\", name=\"timebucket\")\n        assert dr[1:].name == dr.name",
        "begin_line": 39,
        "end_line": 44,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_slice_with_negative_step#46",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_slice_with_negative_step(self)",
        "snippet": "    def test_slice_with_negative_step(self):\n        ts = Series(np.arange(20), date_range(\"2014-01-01\", periods=20, freq=\"MS\"))\n        SLC = pd.IndexSlice\n\n        def assert_slices_equivalent(l_slc, i_slc):\n            tm.assert_series_equal(ts[l_slc], ts.iloc[i_slc])\n            tm.assert_series_equal(ts.loc[l_slc], ts.iloc[i_slc])\n            tm.assert_series_equal(ts.loc[l_slc], ts.iloc[i_slc])\n\n        assert_slices_equivalent(SLC[Timestamp(\"2014-10-01\") :: -1], SLC[9::-1])\n        assert_slices_equivalent(SLC[\"2014-10-01\"::-1], SLC[9::-1])\n\n        assert_slices_equivalent(SLC[: Timestamp(\"2014-10-01\") : -1], SLC[:8:-1])\n        assert_slices_equivalent(SLC[:\"2014-10-01\":-1], SLC[:8:-1])\n\n        assert_slices_equivalent(SLC[\"2015-02-01\":\"2014-10-01\":-1], SLC[13:8:-1])\n        assert_slices_equivalent(\n            SLC[Timestamp(\"2015-02-01\") : Timestamp(\"2014-10-01\") : -1], SLC[13:8:-1]\n        )\n        assert_slices_equivalent(\n            SLC[\"2015-02-01\" : Timestamp(\"2014-10-01\") : -1], SLC[13:8:-1]\n        )\n        assert_slices_equivalent(\n            SLC[Timestamp(\"2015-02-01\") : \"2014-10-01\" : -1], SLC[13:8:-1]\n        )\n\n        assert_slices_equivalent(SLC[\"2014-10-01\":\"2015-02-01\":-1], SLC[:0])",
        "begin_line": 46,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.assert_slices_equivalent#50",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.assert_slices_equivalent(l_slc, i_slc)",
        "snippet": "        def assert_slices_equivalent(l_slc, i_slc):\n            tm.assert_series_equal(ts[l_slc], ts.iloc[i_slc])\n            tm.assert_series_equal(ts.loc[l_slc], ts.iloc[i_slc])\n            tm.assert_series_equal(ts.loc[l_slc], ts.iloc[i_slc])",
        "begin_line": 50,
        "end_line": 53,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_slice_with_zero_step_raises#74",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_slice_with_zero_step_raises(self)",
        "snippet": "    def test_slice_with_zero_step_raises(self):\n        ts = Series(np.arange(20), date_range(\"2014-01-01\", periods=20, freq=\"MS\"))\n        with pytest.raises(ValueError, match=\"slice step cannot be zero\"):\n            ts[::0]\n        with pytest.raises(ValueError, match=\"slice step cannot be zero\"):\n            ts.loc[::0]\n        with pytest.raises(ValueError, match=\"slice step cannot be zero\"):\n            ts.loc[::0]",
        "begin_line": 74,
        "end_line": 81,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_slice_bounds_empty#83",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_slice_bounds_empty(self)",
        "snippet": "    def test_slice_bounds_empty(self):\n        # GH#14354\n        empty_idx = date_range(freq=\"1H\", periods=0, end=\"2015\")\n\n        right = empty_idx._maybe_cast_slice_bound(\"2015-01-02\", \"right\", \"loc\")\n        exp = Timestamp(\"2015-01-02 23:59:59.999999999\")\n        assert right == exp\n\n        left = empty_idx._maybe_cast_slice_bound(\"2015-01-02\", \"left\", \"loc\")\n        exp = Timestamp(\"2015-01-02 00:00:00\")\n        assert left == exp",
        "begin_line": 83,
        "end_line": 93,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_slice_duplicate_monotonic#95",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_slice_duplicate_monotonic(self)",
        "snippet": "    def test_slice_duplicate_monotonic(self):\n        # https://github.com/pandas-dev/pandas/issues/16515\n        idx = pd.DatetimeIndex([\"2017\", \"2017\"])\n        result = idx._maybe_cast_slice_bound(\"2017-01-01\", \"left\", \"loc\")\n        expected = Timestamp(\"2017-01-01\")\n        assert result == expected",
        "begin_line": 95,
        "end_line": 100,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_monotone_DTI_indexing_bug#102",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_monotone_DTI_indexing_bug(self)",
        "snippet": "    def test_monotone_DTI_indexing_bug(self):\n        # GH 19362\n        # Testing accessing the first element in a monotonic descending\n        # partial string indexing.\n\n        df = pd.DataFrame(list(range(5)))\n        date_list = [\n            \"2018-01-02\",\n            \"2017-02-10\",\n            \"2016-03-10\",\n            \"2015-03-15\",\n            \"2014-03-16\",\n        ]\n        date_index = pd.to_datetime(date_list)\n        df[\"date\"] = date_index\n        expected = pd.DataFrame({0: list(range(5)), \"date\": date_index})\n        tm.assert_frame_equal(df, expected)\n\n        df = pd.DataFrame(\n            {\"A\": [1, 2, 3]}, index=pd.date_range(\"20170101\", periods=3)[::-1]\n        )\n        expected = pd.DataFrame({\"A\": 1}, index=pd.date_range(\"20170103\", periods=1))\n        tm.assert_frame_equal(df.loc[\"2017-01-03\"], expected)",
        "begin_line": 102,
        "end_line": 124,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_slice_year#126",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_slice_year(self)",
        "snippet": "    def test_slice_year(self):\n        dti = date_range(freq=\"B\", start=datetime(2005, 1, 1), periods=500)\n\n        s = Series(np.arange(len(dti)), index=dti)\n        result = s[\"2005\"]\n        expected = s[s.index.year == 2005]\n        tm.assert_series_equal(result, expected)\n\n        df = DataFrame(np.random.rand(len(dti), 5), index=dti)\n        result = df.loc[\"2005\"]\n        expected = df[df.index.year == 2005]\n        tm.assert_frame_equal(result, expected)\n\n        rng = date_range(\"1/1/2000\", \"1/1/2010\")\n\n        result = rng.get_loc(\"2009\")\n        expected = slice(3288, 3653)\n        assert result == expected",
        "begin_line": 126,
        "end_line": 143,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_slice_quarter#145",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_slice_quarter(self)",
        "snippet": "    def test_slice_quarter(self):\n        dti = date_range(freq=\"D\", start=datetime(2000, 6, 1), periods=500)\n\n        s = Series(np.arange(len(dti)), index=dti)\n        assert len(s[\"2001Q1\"]) == 90\n\n        df = DataFrame(np.random.rand(len(dti), 5), index=dti)\n        assert len(df.loc[\"1Q01\"]) == 90",
        "begin_line": 145,
        "end_line": 152,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_slice_month#154",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_slice_month(self)",
        "snippet": "    def test_slice_month(self):\n        dti = date_range(freq=\"D\", start=datetime(2005, 1, 1), periods=500)\n        s = Series(np.arange(len(dti)), index=dti)\n        assert len(s[\"2005-11\"]) == 30\n\n        df = DataFrame(np.random.rand(len(dti), 5), index=dti)\n        assert len(df.loc[\"2005-11\"]) == 30\n\n        tm.assert_series_equal(s[\"2005-11\"], s[\"11-2005\"])",
        "begin_line": 154,
        "end_line": 162,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_partial_slice#164",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_partial_slice(self)",
        "snippet": "    def test_partial_slice(self):\n        rng = date_range(freq=\"D\", start=datetime(2005, 1, 1), periods=500)\n        s = Series(np.arange(len(rng)), index=rng)\n\n        result = s[\"2005-05\":\"2006-02\"]\n        expected = s[\"20050501\":\"20060228\"]\n        tm.assert_series_equal(result, expected)\n\n        result = s[\"2005-05\":]\n        expected = s[\"20050501\":]\n        tm.assert_series_equal(result, expected)\n\n        result = s[:\"2006-02\"]\n        expected = s[:\"20060228\"]\n        tm.assert_series_equal(result, expected)\n\n        result = s[\"2005-1-1\"]\n        assert result == s.iloc[0]\n\n        with pytest.raises(KeyError, match=r\"^'2004-12-31'$\"):\n            s[\"2004-12-31\"]",
        "begin_line": 164,
        "end_line": 184,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_partial_slice_daily#186",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_partial_slice_daily(self)",
        "snippet": "    def test_partial_slice_daily(self):\n        rng = date_range(freq=\"H\", start=datetime(2005, 1, 31), periods=500)\n        s = Series(np.arange(len(rng)), index=rng)\n\n        result = s[\"2005-1-31\"]\n        tm.assert_series_equal(result, s.iloc[:24])\n\n        with pytest.raises(KeyError, match=r\"^'2004-12-31 00'$\"):\n            s[\"2004-12-31 00\"]",
        "begin_line": 186,
        "end_line": 194,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_partial_slice_hourly#196",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_partial_slice_hourly(self)",
        "snippet": "    def test_partial_slice_hourly(self):\n        rng = date_range(freq=\"T\", start=datetime(2005, 1, 1, 20, 0, 0), periods=500)\n        s = Series(np.arange(len(rng)), index=rng)\n\n        result = s[\"2005-1-1\"]\n        tm.assert_series_equal(result, s.iloc[: 60 * 4])\n\n        result = s[\"2005-1-1 20\"]\n        tm.assert_series_equal(result, s.iloc[:60])\n\n        assert s[\"2005-1-1 20:00\"] == s.iloc[0]\n        with pytest.raises(KeyError, match=r\"^'2004-12-31 00:15'$\"):\n            s[\"2004-12-31 00:15\"]",
        "begin_line": 196,
        "end_line": 208,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_partial_slice_minutely#210",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_partial_slice_minutely(self)",
        "snippet": "    def test_partial_slice_minutely(self):\n        rng = date_range(freq=\"S\", start=datetime(2005, 1, 1, 23, 59, 0), periods=500)\n        s = Series(np.arange(len(rng)), index=rng)\n\n        result = s[\"2005-1-1 23:59\"]\n        tm.assert_series_equal(result, s.iloc[:60])\n\n        result = s[\"2005-1-1\"]\n        tm.assert_series_equal(result, s.iloc[:60])\n\n        assert s[Timestamp(\"2005-1-1 23:59:00\")] == s.iloc[0]\n        with pytest.raises(KeyError, match=r\"^'2004-12-31 00:00:00'$\"):\n            s[\"2004-12-31 00:00:00\"]",
        "begin_line": 210,
        "end_line": 222,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_partial_slice_second_precision#224",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_partial_slice_second_precision(self)",
        "snippet": "    def test_partial_slice_second_precision(self):\n        rng = date_range(\n            start=datetime(2005, 1, 1, 0, 0, 59, microsecond=999990),\n            periods=20,\n            freq=\"US\",\n        )\n        s = Series(np.arange(20), rng)\n\n        tm.assert_series_equal(s[\"2005-1-1 00:00\"], s.iloc[:10])\n        tm.assert_series_equal(s[\"2005-1-1 00:00:59\"], s.iloc[:10])\n\n        tm.assert_series_equal(s[\"2005-1-1 00:01\"], s.iloc[10:])\n        tm.assert_series_equal(s[\"2005-1-1 00:01:00\"], s.iloc[10:])\n\n        assert s[Timestamp(\"2005-1-1 00:00:59.999990\")] == s.iloc[0]\n        with pytest.raises(KeyError, match=\"2005-1-1 00:00:00\"):\n            s[\"2005-1-1 00:00:00\"]",
        "begin_line": 224,
        "end_line": 240,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_partial_slicing_dataframe#242",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_partial_slicing_dataframe(self)",
        "snippet": "    def test_partial_slicing_dataframe(self):\n        # GH14856\n        # Test various combinations of string slicing resolution vs.\n        # index resolution\n        # - If string resolution is less precise than index resolution,\n        # string is considered a slice\n        # - If string resolution is equal to or more precise than index\n        # resolution, string is considered an exact match\n        formats = [\n            \"%Y\",\n            \"%Y-%m\",\n            \"%Y-%m-%d\",\n            \"%Y-%m-%d %H\",\n            \"%Y-%m-%d %H:%M\",\n            \"%Y-%m-%d %H:%M:%S\",\n        ]\n        resolutions = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\"]\n        for rnum, resolution in enumerate(resolutions[2:], 2):\n            # we check only 'day', 'hour', 'minute' and 'second'\n            unit = Timedelta(\"1 \" + resolution)\n            middate = datetime(2012, 1, 1, 0, 0, 0)\n            index = DatetimeIndex([middate - unit, middate, middate + unit])\n            values = [1, 2, 3]\n            df = DataFrame({\"a\": values}, index, dtype=np.int64)\n            assert df.index.resolution == resolution\n\n            # Timestamp with the same resolution as index\n            # Should be exact match for Series (return scalar)\n            # and raise KeyError for Frame\n            for timestamp, expected in zip(index, values):\n                ts_string = timestamp.strftime(formats[rnum])\n                # make ts_string as precise as index\n                result = df[\"a\"][ts_string]\n                assert isinstance(result, np.int64)\n                assert result == expected\n                msg = r\"^'{}'$\".format(ts_string)\n                with pytest.raises(KeyError, match=msg):\n                    df[ts_string]\n\n            # Timestamp with resolution less precise than index\n            for fmt in formats[:rnum]:\n                for element, theslice in [[0, slice(None, 1)], [1, slice(1, None)]]:\n                    ts_string = index[element].strftime(fmt)\n\n                    # Series should return slice\n                    result = df[\"a\"][ts_string]\n                    expected = df[\"a\"][theslice]\n                    tm.assert_series_equal(result, expected)\n\n                    # Frame should return slice as well\n                    result = df[ts_string]\n                    expected = df[theslice]\n                    tm.assert_frame_equal(result, expected)\n\n            # Timestamp with resolution more precise than index\n            # Compatible with existing key\n            # Should return scalar for Series\n            # and raise KeyError for Frame\n            for fmt in formats[rnum + 1 :]:\n                ts_string = index[1].strftime(fmt)\n                result = df[\"a\"][ts_string]\n                assert isinstance(result, np.int64)\n                assert result == 2\n                msg = r\"^'{}'$\".format(ts_string)\n                with pytest.raises(KeyError, match=msg):\n                    df[ts_string]\n\n            # Not compatible with existing key\n            # Should raise KeyError\n            for fmt, res in list(zip(formats, resolutions))[rnum + 1 :]:\n                ts = index[1] + Timedelta(\"1 \" + res)\n                ts_string = ts.strftime(fmt)\n                msg = r\"^'{}'$\".format(ts_string)\n                with pytest.raises(KeyError, match=msg):\n                    df[\"a\"][ts_string]\n                with pytest.raises(KeyError, match=msg):\n                    df[ts_string]",
        "begin_line": 242,
        "end_line": 318,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_partial_slicing_with_multiindex#320",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_partial_slicing_with_multiindex(self)",
        "snippet": "    def test_partial_slicing_with_multiindex(self):\n\n        # GH 4758\n        # partial string indexing with a multi-index buggy\n        df = DataFrame(\n            {\n                \"ACCOUNT\": [\"ACCT1\", \"ACCT1\", \"ACCT1\", \"ACCT2\"],\n                \"TICKER\": [\"ABC\", \"MNP\", \"XYZ\", \"XYZ\"],\n                \"val\": [1, 2, 3, 4],\n            },\n            index=date_range(\"2013-06-19 09:30:00\", periods=4, freq=\"5T\"),\n        )\n        df_multi = df.set_index([\"ACCOUNT\", \"TICKER\"], append=True)\n\n        expected = DataFrame(\n            [[1]], index=Index([\"ABC\"], name=\"TICKER\"), columns=[\"val\"]\n        )\n        result = df_multi.loc[(\"2013-06-19 09:30:00\", \"ACCT1\")]\n        tm.assert_frame_equal(result, expected)\n\n        expected = df_multi.loc[\n            (pd.Timestamp(\"2013-06-19 09:30:00\", tz=None), \"ACCT1\", \"ABC\")\n        ]\n        result = df_multi.loc[(\"2013-06-19 09:30:00\", \"ACCT1\", \"ABC\")]\n        tm.assert_series_equal(result, expected)\n\n        # this is an IndexingError as we don't do partial string selection on\n        # multi-levels.\n        msg = \"Too many indexers\"\n        with pytest.raises(IndexingError, match=msg):\n            df_multi.loc[(\"2013-06-19\", \"ACCT1\", \"ABC\")]\n\n        # GH 4294\n        # partial slice on a series mi\n        s = pd.DataFrame(\n            np.random.rand(1000, 1000), index=pd.date_range(\"2000-1-1\", periods=1000)\n        ).stack()\n\n        s2 = s[:-1].copy()\n        expected = s2[\"2000-1-4\"]\n        result = s2[pd.Timestamp(\"2000-1-4\")]\n        tm.assert_series_equal(result, expected)\n\n        result = s[pd.Timestamp(\"2000-1-4\")]\n        expected = s[\"2000-1-4\"]\n        tm.assert_series_equal(result, expected)\n\n        df2 = pd.DataFrame(s)\n        expected = df2.xs(\"2000-1-4\")\n        result = df2.loc[pd.Timestamp(\"2000-1-4\")]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 320,
        "end_line": 370,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_partial_slice_doesnt_require_monotonicity#372",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_partial_slice_doesnt_require_monotonicity(self)",
        "snippet": "    def test_partial_slice_doesnt_require_monotonicity(self):\n        # For historical reasons.\n        s = pd.Series(np.arange(10), pd.date_range(\"2014-01-01\", periods=10))\n\n        nonmonotonic = s[[3, 5, 4]]\n        expected = nonmonotonic.iloc[:0]\n        timestamp = pd.Timestamp(\"2014-01-10\")\n\n        tm.assert_series_equal(nonmonotonic[\"2014-01-10\":], expected)\n        with pytest.raises(KeyError, match=r\"Timestamp\\('2014-01-10 00:00:00'\\)\"):\n            nonmonotonic[timestamp:]\n\n        tm.assert_series_equal(nonmonotonic.loc[\"2014-01-10\":], expected)\n        with pytest.raises(KeyError, match=r\"Timestamp\\('2014-01-10 00:00:00'\\)\"):\n            nonmonotonic.loc[timestamp:]",
        "begin_line": 372,
        "end_line": 386,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_loc_datetime_length_one#388",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_loc_datetime_length_one(self)",
        "snippet": "    def test_loc_datetime_length_one(self):\n        # GH16071\n        df = pd.DataFrame(\n            columns=[\"1\"],\n            index=pd.date_range(\"2016-10-01T00:00:00\", \"2016-10-01T23:59:59\"),\n        )\n        result = df.loc[datetime(2016, 10, 1) :]\n        tm.assert_frame_equal(result, df)\n\n        result = df.loc[\"2016-10-01T00:00:00\":]\n        tm.assert_frame_equal(result, df)",
        "begin_line": 388,
        "end_line": 398,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_selection_by_datetimelike#417",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_selection_by_datetimelike(self, datetimelike, op, expected)",
        "snippet": "    def test_selection_by_datetimelike(self, datetimelike, op, expected):\n        # GH issue #17965, test for ability to compare datetime64[ns] columns\n        # to datetimelike\n        df = DataFrame(\n            {\n                \"A\": [\n                    pd.Timestamp(\"20120101\"),\n                    pd.Timestamp(\"20130101\"),\n                    np.nan,\n                    pd.Timestamp(\"20130103\"),\n                ]\n            }\n        )\n        result = op(df.A, datetimelike)\n        expected = Series(expected, name=\"A\")\n        tm.assert_series_equal(result, expected)",
        "begin_line": 417,
        "end_line": 432,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_getitem_with_datestring_with_UTC_offset#450",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_getitem_with_datestring_with_UTC_offset(self, start, end)",
        "snippet": "    def test_getitem_with_datestring_with_UTC_offset(self, start, end):\n        # GH 24076\n        idx = pd.date_range(\n            start=\"2018-12-02 14:50:00-07:00\",\n            end=\"2018-12-02 14:50:00-07:00\",\n            freq=\"1min\",\n        )\n        df = pd.DataFrame(1, index=idx, columns=[\"A\"])\n        result = df[start:end]\n        expected = df.iloc[0:3, :]\n        tm.assert_frame_equal(result, expected)\n\n        # GH 16785\n        start = str(start)\n        end = str(end)\n        with pytest.raises(ValueError, match=\"Both dates must\"):\n            df[start : end[:-4] + \"1:00\"]\n\n        with pytest.raises(ValueError, match=\"The index must be timezone\"):\n            df = df.tz_localize(None)\n            df[start:end]",
        "begin_line": 450,
        "end_line": 470,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_slice_reduce_to_series#472",
        "src_path": "pandas/tests/indexes/datetimes/test_partial_slicing.py",
        "class_name": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing",
        "signature": "pandas.tests.indexes.datetimes.test_partial_slicing.TestSlicing.test_slice_reduce_to_series(self)",
        "snippet": "    def test_slice_reduce_to_series(self):\n        # GH 27516\n        df = pd.DataFrame(\n            {\"A\": range(24)}, index=pd.date_range(\"2000\", periods=24, freq=\"M\")\n        )\n        expected = pd.Series(\n            range(12), index=pd.date_range(\"2000\", periods=12, freq=\"M\"), name=\"A\"\n        )\n        result = df.loc[\"2000\", \"A\"]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 472,
        "end_line": 481,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.setup_indices#34",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.setup_indices(self)",
        "snippet": "    def setup_indices(self):\n        for name, idx in self.indices.items():\n            setattr(self, name, idx)",
        "begin_line": 34,
        "end_line": 36,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_pickle_compat_construction#38",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_pickle_compat_construction(self)",
        "snippet": "    def test_pickle_compat_construction(self):\n        # need an object to create with\n        msg = (\n            r\"Index\\(\\.\\.\\.\\) must be called with a collection of some\"\n            r\" kind, None was passed|\"\n            r\"__new__\\(\\) missing 1 required positional argument: 'data'|\"\n            r\"__new__\\(\\) takes at least 2 arguments \\(1 given\\)\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            self._holder()",
        "begin_line": 38,
        "end_line": 47,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_series#49",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_series(self)",
        "snippet": "    def test_to_series(self):\n        # assert that we are creating a copy of the index\n\n        idx = self.create_index()\n        s = idx.to_series()\n        assert s.values is not idx.values\n        assert s.index is not idx\n        assert s.name == idx.name",
        "begin_line": 49,
        "end_line": 56,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_series_with_arguments#58",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_series_with_arguments(self)",
        "snippet": "    def test_to_series_with_arguments(self):\n        # GH18699\n\n        # index kwarg\n        idx = self.create_index()\n        s = idx.to_series(index=idx)\n\n        assert s.values is not idx.values\n        assert s.index is idx\n        assert s.name == idx.name\n\n        # name kwarg\n        idx = self.create_index()\n        s = idx.to_series(name=\"__test\")\n\n        assert s.values is not idx.values\n        assert s.index is not idx\n        assert s.name != idx.name",
        "begin_line": 58,
        "end_line": 75,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_frame#78",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_frame(self, name)",
        "snippet": "    def test_to_frame(self, name):\n        # see GH-15230, GH-22580\n        idx = self.create_index()\n\n        if name:\n            idx_name = name\n        else:\n            idx_name = idx.name or 0\n\n        df = idx.to_frame(name=idx_name)\n\n        assert df.index is idx\n        assert len(df.columns) == 1\n        assert df.columns[0] == idx_name\n        assert df[idx_name].values is not idx.values\n\n        df = idx.to_frame(index=False, name=idx_name)\n        assert df.index is not idx",
        "begin_line": 78,
        "end_line": 95,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_frame_datetime_tz#97",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_frame_datetime_tz(self)",
        "snippet": "    def test_to_frame_datetime_tz(self):\n        # GH 25809\n        idx = pd.date_range(start=\"2019-01-01\", end=\"2019-01-30\", freq=\"D\")\n        idx = idx.tz_localize(\"UTC\")\n        result = idx.to_frame()\n        expected = pd.DataFrame(idx, index=idx)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 97,
        "end_line": 103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_shift#105",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_shift(self)",
        "snippet": "    def test_shift(self):\n\n        # GH8083 test the base class for shift\n        idx = self.create_index()\n        msg = \"Not supported for type {}\".format(type(idx).__name__)\n        with pytest.raises(NotImplementedError, match=msg):\n            idx.shift(1)\n        with pytest.raises(NotImplementedError, match=msg):\n            idx.shift(1, 2)",
        "begin_line": 105,
        "end_line": 113,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_create_index_existing_name#115",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_create_index_existing_name(self)",
        "snippet": "    def test_create_index_existing_name(self):\n\n        # GH11193, when an existing index is passed, and a new name is not\n        # specified, the new index should inherit the previous object name\n        expected = self.create_index()\n        if not isinstance(expected, MultiIndex):\n            expected.name = \"foo\"\n            result = pd.Index(expected)\n            tm.assert_index_equal(result, expected)\n\n            result = pd.Index(expected, name=\"bar\")\n            expected.name = \"bar\"\n            tm.assert_index_equal(result, expected)\n        else:\n            expected.names = [\"foo\", \"bar\"]\n            result = pd.Index(expected)\n            tm.assert_index_equal(\n                result,\n                Index(\n                    Index(\n                        [\n                            (\"foo\", \"one\"),\n                            (\"foo\", \"two\"),\n                            (\"bar\", \"one\"),\n                            (\"baz\", \"two\"),\n                            (\"qux\", \"one\"),\n                            (\"qux\", \"two\"),\n                        ],\n                        dtype=\"object\",\n                    ),\n                    names=[\"foo\", \"bar\"],\n                ),\n            )\n\n            result = pd.Index(expected, names=[\"A\", \"B\"])\n            tm.assert_index_equal(\n                result,\n                Index(\n                    Index(\n                        [\n                            (\"foo\", \"one\"),\n                            (\"foo\", \"two\"),\n                            (\"bar\", \"one\"),\n                            (\"baz\", \"two\"),\n                            (\"qux\", \"one\"),\n                            (\"qux\", \"two\"),\n                        ],\n                        dtype=\"object\",\n                    ),\n                    names=[\"A\", \"B\"],\n                ),\n            )",
        "begin_line": 115,
        "end_line": 166,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numeric_compat#168",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numeric_compat(self)",
        "snippet": "    def test_numeric_compat(self):\n\n        idx = self.create_index()\n        with pytest.raises(TypeError, match=\"cannot perform __mul__\"):\n            idx * 1\n        with pytest.raises(TypeError, match=\"cannot perform __rmul__\"):\n            1 * idx\n\n        div_err = \"cannot perform __truediv__\"\n        with pytest.raises(TypeError, match=div_err):\n            idx / 1\n\n        div_err = div_err.replace(\" __\", \" __r\")\n        with pytest.raises(TypeError, match=div_err):\n            1 / idx\n        with pytest.raises(TypeError, match=\"cannot perform __floordiv__\"):\n            idx // 1\n        with pytest.raises(TypeError, match=\"cannot perform __rfloordiv__\"):\n            1 // idx",
        "begin_line": 168,
        "end_line": 186,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_logical_compat#188",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_logical_compat(self)",
        "snippet": "    def test_logical_compat(self):\n        idx = self.create_index()\n        with pytest.raises(TypeError, match=\"cannot perform all\"):\n            idx.all()\n        with pytest.raises(TypeError, match=\"cannot perform any\"):\n            idx.any()",
        "begin_line": 188,
        "end_line": 193,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_boolean_context_compat#195",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_boolean_context_compat(self)",
        "snippet": "    def test_boolean_context_compat(self):\n\n        # boolean context compat\n        idx = self.create_index()\n\n        with pytest.raises(ValueError, match=\"The truth value of a\"):\n            if idx:\n                pass",
        "begin_line": 195,
        "end_line": 202,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_reindex_base#204",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_reindex_base(self)",
        "snippet": "    def test_reindex_base(self):\n        idx = self.create_index()\n        expected = np.arange(idx.size, dtype=np.intp)\n\n        actual = idx.get_indexer(idx)\n        tm.assert_numpy_array_equal(expected, actual)\n\n        with pytest.raises(ValueError, match=\"Invalid fill method\"):\n            idx.get_indexer(idx, method=\"invalid\")",
        "begin_line": 204,
        "end_line": 212,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_get_indexer_consistency#214",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_get_indexer_consistency(self)",
        "snippet": "    def test_get_indexer_consistency(self):\n        # See GH 16819\n        for name, index in self.indices.items():\n            if isinstance(index, IntervalIndex):\n                continue\n\n            if index.is_unique or isinstance(index, CategoricalIndex):\n                indexer = index.get_indexer(index[0:2])\n                assert isinstance(indexer, np.ndarray)\n                assert indexer.dtype == np.intp\n            else:\n                e = \"Reindexing only valid with uniquely valued Index objects\"\n                with pytest.raises(InvalidIndexError, match=e):\n                    index.get_indexer(index[0:2])\n\n            indexer, _ = index.get_indexer_non_unique(index[0:2])\n            assert isinstance(indexer, np.ndarray)\n            assert indexer.dtype == np.intp",
        "begin_line": 214,
        "end_line": 231,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_ndarray_compat_properties#233",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_ndarray_compat_properties(self)",
        "snippet": "    def test_ndarray_compat_properties(self):\n        idx = self.create_index()\n        assert idx.T.equals(idx)\n        assert idx.transpose().equals(idx)\n\n        values = idx.values\n        for prop in self._compat_props:\n            assert getattr(idx, prop) == getattr(values, prop)\n\n        # test for validity\n        idx.nbytes\n        idx.values.nbytes",
        "begin_line": 233,
        "end_line": 244,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repr_roundtrip#246",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repr_roundtrip(self)",
        "snippet": "    def test_repr_roundtrip(self):\n\n        idx = self.create_index()\n        tm.assert_index_equal(eval(repr(idx)), idx)",
        "begin_line": 246,
        "end_line": 249,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_str#251",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_str(self)",
        "snippet": "    def test_str(self):\n\n        # test the string repr\n        idx = self.create_index()\n        idx.name = \"foo\"\n        assert \"'foo'\" in str(idx)\n        assert idx.__class__.__name__ in str(idx)",
        "begin_line": 251,
        "end_line": 257,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repr_max_seq_item_setting#259",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repr_max_seq_item_setting(self)",
        "snippet": "    def test_repr_max_seq_item_setting(self):\n        # GH10182\n        idx = self.create_index()\n        idx = idx.repeat(50)\n        with pd.option_context(\"display.max_seq_items\", None):\n            repr(idx)\n            assert \"...\" not in str(idx)",
        "begin_line": 259,
        "end_line": 265,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_copy_name#267",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_copy_name(self)",
        "snippet": "    def test_copy_name(self):\n        # gh-12309: Check that the \"name\" argument\n        # passed at initialization is honored.\n\n        for name, index in self.indices.items():\n            if isinstance(index, MultiIndex):\n                continue\n\n            first = index.__class__(index, copy=True, name=\"mario\")\n            second = first.__class__(first, copy=False)\n\n            # Even though \"copy=False\", we want a new object.\n            assert first is not second\n\n            # Not using tm.assert_index_equal() since names differ.\n            assert index.equals(first)\n\n            assert first.name == \"mario\"\n            assert second.name == \"mario\"\n\n            s1 = Series(2, index=first)\n            s2 = Series(3, index=second[:-1])\n\n            if not isinstance(index, CategoricalIndex):\n                # See gh-13365\n                s3 = s1 * s2\n                assert s3.index.name == \"mario\"",
        "begin_line": 267,
        "end_line": 293,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_ensure_copied_data#295",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_ensure_copied_data(self)",
        "snippet": "    def test_ensure_copied_data(self):\n        # Check the \"copy\" argument of each Index.__new__ is honoured\n        # GH12309\n        for name, index in self.indices.items():\n            init_kwargs = {}\n            if isinstance(index, PeriodIndex):\n                # Needs \"freq\" specification:\n                init_kwargs[\"freq\"] = index.freq\n            elif isinstance(index, (RangeIndex, MultiIndex, CategoricalIndex)):\n                # RangeIndex cannot be initialized from data\n                # MultiIndex and CategoricalIndex are tested separately\n                continue\n\n            index_type = index.__class__\n            result = index_type(index.values, copy=True, **init_kwargs)\n            tm.assert_index_equal(index, result)\n            tm.assert_numpy_array_equal(\n                index._ndarray_values, result._ndarray_values, check_same=\"copy\"\n            )\n\n            if isinstance(index, PeriodIndex):\n                # .values an object array of Period, thus copied\n                result = index_type(ordinal=index.asi8, copy=False, **init_kwargs)\n                tm.assert_numpy_array_equal(\n                    index._ndarray_values, result._ndarray_values, check_same=\"same\"\n                )\n            elif isinstance(index, IntervalIndex):\n                # checked in test_interval.py\n                pass\n            else:\n                result = index_type(index.values, copy=False, **init_kwargs)\n                tm.assert_numpy_array_equal(\n                    index.values, result.values, check_same=\"same\"\n                )\n                tm.assert_numpy_array_equal(\n                    index._ndarray_values, result._ndarray_values, check_same=\"same\"\n                )",
        "begin_line": 295,
        "end_line": 331,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_memory_usage#333",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_memory_usage(self)",
        "snippet": "    def test_memory_usage(self):\n        for name, index in self.indices.items():\n            result = index.memory_usage()\n            if len(index):\n                index.get_loc(index[0])\n                result2 = index.memory_usage()\n                result3 = index.memory_usage(deep=True)\n\n                # RangeIndex, IntervalIndex\n                # don't have engines\n                if not isinstance(index, (RangeIndex, IntervalIndex)):\n                    assert result2 > result\n\n                if index.inferred_type == \"object\":\n                    assert result3 > result2\n\n            else:\n\n                # we report 0 for no-length\n                assert result == 0",
        "begin_line": 333,
        "end_line": 352,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_argsort#354",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_argsort(self)",
        "snippet": "    def test_argsort(self):\n        for k, ind in self.indices.items():\n\n            # separately tested\n            if k in [\"catIndex\"]:\n                continue\n\n            result = ind.argsort()\n            expected = np.array(ind).argsort()\n            tm.assert_numpy_array_equal(result, expected, check_dtype=False)",
        "begin_line": 354,
        "end_line": 363,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numpy_argsort#365",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numpy_argsort(self)",
        "snippet": "    def test_numpy_argsort(self):\n        for k, ind in self.indices.items():\n            result = np.argsort(ind)\n            expected = ind.argsort()\n            tm.assert_numpy_array_equal(result, expected)\n\n            # these are the only two types that perform\n            # pandas compatibility input validation - the\n            # rest already perform separate (or no) such\n            # validation via their 'values' attribute as\n            # defined in pandas.core.indexes/base.py - they\n            # cannot be changed at the moment due to\n            # backwards compatibility concerns\n            if isinstance(type(ind), (CategoricalIndex, RangeIndex)):\n                msg = \"the 'axis' parameter is not supported\"\n                with pytest.raises(ValueError, match=msg):\n                    np.argsort(ind, axis=1)\n\n                msg = \"the 'kind' parameter is not supported\"\n                with pytest.raises(ValueError, match=msg):\n                    np.argsort(ind, kind=\"mergesort\")\n\n                msg = \"the 'order' parameter is not supported\"\n                with pytest.raises(ValueError, match=msg):\n                    np.argsort(ind, order=(\"a\", \"b\"))",
        "begin_line": 365,
        "end_line": 389,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_take#391",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_take(self)",
        "snippet": "    def test_take(self):\n        indexer = [4, 3, 0, 2]\n        for k, ind in self.indices.items():\n\n            # separate\n            if k in [\"boolIndex\", \"tuples\", \"empty\"]:\n                continue\n\n            result = ind.take(indexer)\n            expected = ind[indexer]\n            assert result.equals(expected)\n\n            if not isinstance(ind, (DatetimeIndex, PeriodIndex, TimedeltaIndex)):\n                # GH 10791\n                with pytest.raises(AttributeError):\n                    ind.freq",
        "begin_line": 391,
        "end_line": 406,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_take_invalid_kwargs#408",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_take_invalid_kwargs(self)",
        "snippet": "    def test_take_invalid_kwargs(self):\n        idx = self.create_index()\n        indices = [1, 2]\n\n        msg = r\"take\\(\\) got an unexpected keyword argument 'foo'\"\n        with pytest.raises(TypeError, match=msg):\n            idx.take(indices, foo=2)\n\n        msg = \"the 'out' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            idx.take(indices, out=indices)\n\n        msg = \"the 'mode' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            idx.take(indices, mode=\"clip\")",
        "begin_line": 408,
        "end_line": 422,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repeat#424",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repeat(self)",
        "snippet": "    def test_repeat(self):\n        rep = 2\n        i = self.create_index()\n        expected = pd.Index(i.values.repeat(rep), name=i.name)\n        tm.assert_index_equal(i.repeat(rep), expected)\n\n        i = self.create_index()\n        rep = np.arange(len(i))\n        expected = pd.Index(i.values.repeat(rep), name=i.name)\n        tm.assert_index_equal(i.repeat(rep), expected)",
        "begin_line": 424,
        "end_line": 433,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numpy_repeat#435",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numpy_repeat(self)",
        "snippet": "    def test_numpy_repeat(self):\n        rep = 2\n        i = self.create_index()\n        expected = i.repeat(rep)\n        tm.assert_index_equal(np.repeat(i, rep), expected)\n\n        msg = \"the 'axis' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            np.repeat(i, rep, axis=0)",
        "begin_line": 435,
        "end_line": 443,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_where#446",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_where(self, klass)",
        "snippet": "    def test_where(self, klass):\n        i = self.create_index()\n\n        cond = [True] * len(i)\n        result = i.where(klass(cond))\n        expected = i\n        tm.assert_index_equal(result, expected)\n\n        cond = [False] + [True] * len(i[1:])\n        expected = pd.Index([i._na_value] + i[1:].tolist(), dtype=i.dtype)\n        result = i.where(klass(cond))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 446,
        "end_line": 457,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_set_ops_error_cases#463",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_set_ops_error_cases(self, case, method)",
        "snippet": "    def test_set_ops_error_cases(self, case, method):\n        for name, idx in self.indices.items():\n            # non-iterable input\n\n            msg = \"Input must be Index or array-like\"\n            with pytest.raises(TypeError, match=msg):\n                getattr(idx, method)(case)",
        "begin_line": 463,
        "end_line": 469,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_intersection_base#471",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_intersection_base(self)",
        "snippet": "    def test_intersection_base(self):\n        for name, idx in self.indices.items():\n            first = idx[:5]\n            second = idx[:3]\n            intersect = first.intersection(second)\n\n            if isinstance(idx, CategoricalIndex):\n                pass\n            else:\n                assert tm.equalContents(intersect, second)\n\n            # GH 10149\n            cases = [klass(second.values) for klass in [np.array, Series, list]]\n            for case in cases:\n                if isinstance(idx, CategoricalIndex):\n                    pass\n                else:\n                    result = first.intersection(case)\n                    assert tm.equalContents(result, second)\n\n            if isinstance(idx, MultiIndex):\n                msg = \"other must be a MultiIndex or a list of tuples\"\n                with pytest.raises(TypeError, match=msg):\n                    first.intersection([1, 2, 3])",
        "begin_line": 471,
        "end_line": 494,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_union_base#496",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_union_base(self)",
        "snippet": "    def test_union_base(self):\n        for name, idx in self.indices.items():\n            first = idx[3:]\n            second = idx[:5]\n            everything = idx\n            union = first.union(second)\n            assert tm.equalContents(union, everything)\n\n            # GH 10149\n            cases = [klass(second.values) for klass in [np.array, Series, list]]\n            for case in cases:\n                if isinstance(idx, CategoricalIndex):\n                    pass\n                else:\n                    result = first.union(case)\n                    assert tm.equalContents(result, everything)\n\n            if isinstance(idx, MultiIndex):\n                msg = \"other must be a MultiIndex or a list of tuples\"\n                with pytest.raises(TypeError, match=msg):\n                    first.union([1, 2, 3])",
        "begin_line": 496,
        "end_line": 516,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_difference_base#519",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_difference_base(self, sort)",
        "snippet": "    def test_difference_base(self, sort):\n        for name, idx in self.indices.items():\n            first = idx[2:]\n            second = idx[:4]\n            answer = idx[4:]\n            result = first.difference(second, sort)\n\n            if isinstance(idx, CategoricalIndex):\n                pass\n            else:\n                assert tm.equalContents(result, answer)\n\n            # GH 10149\n            cases = [klass(second.values) for klass in [np.array, Series, list]]\n            for case in cases:\n                if isinstance(idx, CategoricalIndex):\n                    pass\n                elif isinstance(idx, (DatetimeIndex, TimedeltaIndex)):\n                    assert result.__class__ == answer.__class__\n                    tm.assert_numpy_array_equal(\n                        result.sort_values().asi8, answer.sort_values().asi8\n                    )\n                else:\n                    result = first.difference(case, sort)\n                    assert tm.equalContents(result, answer)\n\n            if isinstance(idx, MultiIndex):\n                msg = \"other must be a MultiIndex or a list of tuples\"\n                with pytest.raises(TypeError, match=msg):\n                    first.difference([1, 2, 3], sort)",
        "begin_line": 519,
        "end_line": 548,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_symmetric_difference#550",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_symmetric_difference(self)",
        "snippet": "    def test_symmetric_difference(self):\n        for name, idx in self.indices.items():\n            first = idx[1:]\n            second = idx[:-1]\n            if isinstance(idx, CategoricalIndex):\n                pass\n            else:\n                answer = idx[[0, -1]]\n                result = first.symmetric_difference(second)\n                assert tm.equalContents(result, answer)\n\n            # GH 10149\n            cases = [klass(second.values) for klass in [np.array, Series, list]]\n            for case in cases:\n                if isinstance(idx, CategoricalIndex):\n                    pass\n                else:\n                    result = first.symmetric_difference(case)\n                    assert tm.equalContents(result, answer)\n\n            if isinstance(idx, MultiIndex):\n                msg = \"other must be a MultiIndex or a list of tuples\"\n                with pytest.raises(TypeError, match=msg):\n                    first.symmetric_difference([1, 2, 3])",
        "begin_line": 550,
        "end_line": 573,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_insert_base#575",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_insert_base(self)",
        "snippet": "    def test_insert_base(self):\n\n        for name, idx in self.indices.items():\n            result = idx[1:4]\n\n            if not len(idx):\n                continue\n\n            # test 0th element\n            assert idx[0:4].equals(result.insert(0, idx[0]))",
        "begin_line": 575,
        "end_line": 584,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_delete_base#586",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_delete_base(self)",
        "snippet": "    def test_delete_base(self):\n\n        for name, idx in self.indices.items():\n\n            if not len(idx):\n                continue\n\n            if isinstance(idx, RangeIndex):\n                # tested in class\n                continue\n\n            expected = idx[1:]\n            result = idx.delete(0)\n            assert result.equals(expected)\n            assert result.name == expected.name\n\n            expected = idx[:-1]\n            result = idx.delete(-1)\n            assert result.equals(expected)\n            assert result.name == expected.name\n\n            with pytest.raises((IndexError, ValueError)):\n                # either depending on numpy version\n                idx.delete(len(idx))",
        "begin_line": 586,
        "end_line": 609,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_equals#611",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_equals(self)",
        "snippet": "    def test_equals(self):\n\n        for name, idx in self.indices.items():\n            assert idx.equals(idx)\n            assert idx.equals(idx.copy())\n            assert idx.equals(idx.astype(object))\n\n            assert not idx.equals(list(idx))\n            assert not idx.equals(np.array(idx))\n\n            # Cannot pass in non-int64 dtype to RangeIndex\n            if not isinstance(idx, RangeIndex):\n                same_values = Index(idx, dtype=object)\n                assert idx.equals(same_values)\n                assert same_values.equals(idx)\n\n            if idx.nlevels == 1:\n                # do not test MultiIndex\n                assert not idx.equals(pd.Series(idx))",
        "begin_line": 611,
        "end_line": 629,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_equals_op#631",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_equals_op(self)",
        "snippet": "    def test_equals_op(self):\n        # GH9947, GH10637\n        index_a = self.create_index()\n        if isinstance(index_a, PeriodIndex):\n            pytest.skip(\"Skip check for PeriodIndex\")\n\n        n = len(index_a)\n        index_b = index_a[0:-1]\n        index_c = index_a[0:-1].append(index_a[-2:-1])\n        index_d = index_a[0:1]\n\n        msg = \"Lengths must match|could not be broadcast\"\n        with pytest.raises(ValueError, match=msg):\n            index_a == index_b\n        expected1 = np.array([True] * n)\n        expected2 = np.array([True] * (n - 1) + [False])\n        tm.assert_numpy_array_equal(index_a == index_a, expected1)\n        tm.assert_numpy_array_equal(index_a == index_c, expected2)\n\n        # test comparisons with numpy arrays\n        array_a = np.array(index_a)\n        array_b = np.array(index_a[0:-1])\n        array_c = np.array(index_a[0:-1].append(index_a[-2:-1]))\n        array_d = np.array(index_a[0:1])\n        with pytest.raises(ValueError, match=msg):\n            index_a == array_b\n        tm.assert_numpy_array_equal(index_a == array_a, expected1)\n        tm.assert_numpy_array_equal(index_a == array_c, expected2)\n\n        # test comparisons with Series\n        series_a = Series(array_a)\n        series_b = Series(array_b)\n        series_c = Series(array_c)\n        series_d = Series(array_d)\n        with pytest.raises(ValueError, match=msg):\n            index_a == series_b\n\n        tm.assert_numpy_array_equal(index_a == series_a, expected1)\n        tm.assert_numpy_array_equal(index_a == series_c, expected2)\n\n        # cases where length is 1 for one of them\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == index_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == series_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == array_d\n        msg = \"Can only compare identically-labeled Series objects\"\n        with pytest.raises(ValueError, match=msg):\n            series_a == series_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            series_a == array_d\n\n        # comparing with a scalar should broadcast; note that we are excluding\n        # MultiIndex because in this case each item in the index is a tuple of\n        # length 2, and therefore is considered an array of length 2 in the\n        # comparison instead of a scalar\n        if not isinstance(index_a, MultiIndex):\n            expected3 = np.array([False] * (len(index_a) - 2) + [True, False])\n            # assuming the 2nd to last item is unique in the data\n            item = index_a[-2]\n            tm.assert_numpy_array_equal(index_a == item, expected3)\n            tm.assert_series_equal(series_a == item, Series(expected3))",
        "begin_line": 631,
        "end_line": 693,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_hasnans_isnans#695",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_hasnans_isnans(self)",
        "snippet": "    def test_hasnans_isnans(self):\n        # GH 11343, added tests for hasnans / isnans\n\n        for name, index in self.indices.items():\n            if isinstance(index, MultiIndex):\n                pass\n            else:\n                idx = index.copy()\n\n                # cases in indices doesn't include NaN\n                expected = np.array([False] * len(idx), dtype=bool)\n                tm.assert_numpy_array_equal(idx._isnan, expected)\n                assert idx.hasnans is False\n\n                idx = index.copy()\n                values = np.asarray(idx.values)\n\n                if len(index) == 0:\n                    continue\n                elif isinstance(index, DatetimeIndexOpsMixin):\n                    values[1] = iNaT\n                elif isinstance(index, (Int64Index, UInt64Index)):\n                    continue\n                else:\n                    values[1] = np.nan\n\n                if isinstance(index, PeriodIndex):\n                    idx = index.__class__(values, freq=index.freq)\n                else:\n                    idx = index.__class__(values)\n\n                expected = np.array([False] * len(idx), dtype=bool)\n                expected[1] = True\n                tm.assert_numpy_array_equal(idx._isnan, expected)\n                assert idx.hasnans is True",
        "begin_line": 695,
        "end_line": 729,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_fillna#731",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_fillna(self)",
        "snippet": "    def test_fillna(self):\n        # GH 11343\n        for name, index in self.indices.items():\n            if len(index) == 0:\n                pass\n            elif isinstance(index, MultiIndex):\n                idx = index.copy()\n                msg = \"isna is not defined for MultiIndex\"\n                with pytest.raises(NotImplementedError, match=msg):\n                    idx.fillna(idx[0])\n            else:\n                idx = index.copy()\n                result = idx.fillna(idx[0])\n                tm.assert_index_equal(result, idx)\n                assert result is not idx\n\n                msg = \"'value' must be a scalar, passed: \"\n                with pytest.raises(TypeError, match=msg):\n                    idx.fillna([idx[0]])\n\n                idx = index.copy()\n                values = np.asarray(idx.values)\n\n                if isinstance(index, DatetimeIndexOpsMixin):\n                    values[1] = iNaT\n                elif isinstance(index, (Int64Index, UInt64Index)):\n                    continue\n                else:\n                    values[1] = np.nan\n\n                if isinstance(index, PeriodIndex):\n                    idx = index.__class__(values, freq=index.freq)\n                else:\n                    idx = index.__class__(values)\n\n                expected = np.array([False] * len(idx), dtype=bool)\n                expected[1] = True\n                tm.assert_numpy_array_equal(idx._isnan, expected)\n                assert idx.hasnans is True",
        "begin_line": 731,
        "end_line": 769,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_nulls#771",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_nulls(self)",
        "snippet": "    def test_nulls(self):\n        # this is really a smoke test for the methods\n        # as these are adequately tested for function elsewhere\n\n        for name, index in self.indices.items():\n            if len(index) == 0:\n                tm.assert_numpy_array_equal(index.isna(), np.array([], dtype=bool))\n            elif isinstance(index, MultiIndex):\n                idx = index.copy()\n                msg = \"isna is not defined for MultiIndex\"\n                with pytest.raises(NotImplementedError, match=msg):\n                    idx.isna()\n            else:\n\n                if not index.hasnans:\n                    tm.assert_numpy_array_equal(\n                        index.isna(), np.zeros(len(index), dtype=bool)\n                    )\n                    tm.assert_numpy_array_equal(\n                        index.notna(), np.ones(len(index), dtype=bool)\n                    )\n                else:\n                    result = isna(index)\n                    tm.assert_numpy_array_equal(index.isna(), result)\n                    tm.assert_numpy_array_equal(index.notna(), ~result)",
        "begin_line": 771,
        "end_line": 795,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_empty#797",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_empty(self)",
        "snippet": "    def test_empty(self):\n        # GH 15270\n        index = self.create_index()\n        assert not index.empty\n        assert index[:0].empty",
        "begin_line": 797,
        "end_line": 801,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_join_self_unique#803",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_join_self_unique(self, join_type)",
        "snippet": "    def test_join_self_unique(self, join_type):\n        index = self.create_index()\n        if index.is_unique:\n            joined = index.join(index, how=join_type)\n            assert (index == joined).all()",
        "begin_line": 803,
        "end_line": 807,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_map#809",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_map(self)",
        "snippet": "    def test_map(self):\n        # callable\n        index = self.create_index()\n\n        # we don't infer UInt64\n        if isinstance(index, pd.UInt64Index):\n            expected = index.astype(\"int64\")\n        else:\n            expected = index\n\n        result = index.map(lambda x: x)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 809,
        "end_line": 820,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_map_dictlike#829",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_map_dictlike(self, mapper)",
        "snippet": "    def test_map_dictlike(self, mapper):\n\n        index = self.create_index()\n        if isinstance(index, (pd.CategoricalIndex, pd.IntervalIndex)):\n            pytest.skip(\"skipping tests for {}\".format(type(index)))\n\n        identity = mapper(index.values, index)\n\n        # we don't infer to UInt64 for a dict\n        if isinstance(index, pd.UInt64Index) and isinstance(identity, dict):\n            expected = index.astype(\"int64\")\n        else:\n            expected = index\n\n        result = index.map(identity)\n        tm.assert_index_equal(result, expected)\n\n        # empty mappable\n        expected = pd.Index([np.nan] * len(index))\n        result = index.map(mapper(expected, index))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 829,
        "end_line": 849,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_putmask_with_wrong_mask#851",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_putmask_with_wrong_mask(self)",
        "snippet": "    def test_putmask_with_wrong_mask(self):\n        # GH18368\n        index = self.create_index()\n\n        with pytest.raises(ValueError):\n            index.putmask(np.ones(len(index) + 1, np.bool), 1)\n\n        with pytest.raises(ValueError):\n            index.putmask(np.ones(len(index) - 1, np.bool), 1)\n\n        with pytest.raises(ValueError):\n            index.putmask(\"foo\", 1)",
        "begin_line": 851,
        "end_line": 862,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_astype_category#867",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_astype_category(self, copy, name, ordered)",
        "snippet": "    def test_astype_category(self, copy, name, ordered):\n        # GH 18630\n        index = self.create_index()\n        if name:\n            index = index.rename(name)\n\n        # standard categories\n        dtype = CategoricalDtype(ordered=ordered)\n        result = index.astype(dtype, copy=copy)\n        expected = CategoricalIndex(index.values, name=name, ordered=ordered)\n        tm.assert_index_equal(result, expected)\n\n        # non-standard categories\n        dtype = CategoricalDtype(index.unique().tolist()[:-1], ordered)\n        result = index.astype(dtype, copy=copy)\n        expected = CategoricalIndex(index.values, name=name, dtype=dtype)\n        tm.assert_index_equal(result, expected)\n\n        if ordered is False:\n            # dtype='category' defaults to ordered=False, so only test once\n            result = index.astype(\"category\", copy=copy)\n            expected = CategoricalIndex(index.values, name=name)\n            tm.assert_index_equal(result, expected)",
        "begin_line": 867,
        "end_line": 889,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_is_unique#891",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_is_unique(self)",
        "snippet": "    def test_is_unique(self):\n        # initialize a unique index\n        index = self.create_index().drop_duplicates()\n        assert index.is_unique is True\n\n        # empty index should be unique\n        index_empty = index[:0]\n        assert index_empty.is_unique is True\n\n        # test basic dupes\n        index_dup = index.insert(0, index[0])\n        assert index_dup.is_unique is False\n\n        # single NA should be unique\n        index_na = index.insert(0, np.nan)\n        assert index_na.is_unique is True\n\n        # multiple NA should not be unique\n        index_na_dup = index_na.insert(0, np.nan)\n        assert index_na_dup.is_unique is False",
        "begin_line": 891,
        "end_line": 910,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.idx#9",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.idx()",
        "snippet": "def idx():\n    # a MultiIndex used to test the general functionality of the\n    # general functionality of this object\n    major_axis = Index([\"foo\", \"bar\", \"baz\", \"qux\"])\n    minor_axis = Index([\"one\", \"two\"])\n\n    major_codes = np.array([0, 0, 1, 2, 3, 3])\n    minor_codes = np.array([0, 1, 0, 1, 0, 1])\n    index_names = [\"first\", \"second\"]\n    mi = MultiIndex(\n        levels=[major_axis, minor_axis],\n        codes=[major_codes, minor_codes],\n        names=index_names,\n        verify_integrity=False,\n    )\n    return mi",
        "begin_line": 9,
        "end_line": 24,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.idx_dup#28",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.idx_dup()",
        "snippet": "def idx_dup():\n    # compare tests/indexes/multi/conftest.py\n    major_axis = Index([\"foo\", \"bar\", \"baz\", \"qux\"])\n    minor_axis = Index([\"one\", \"two\"])\n\n    major_codes = np.array([0, 0, 1, 0, 1, 1])\n    minor_codes = np.array([0, 1, 0, 1, 0, 1])\n    index_names = [\"first\", \"second\"]\n    mi = MultiIndex(\n        levels=[major_axis, minor_axis],\n        codes=[major_codes, minor_codes],\n        names=index_names,\n        verify_integrity=False,\n    )\n    return mi",
        "begin_line": 28,
        "end_line": 42,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.index_names#46",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.index_names()",
        "snippet": "def index_names():\n    # names that match those in the idx fixture for testing equality of\n    # names assigned to the idx\n    return [\"first\", \"second\"]",
        "begin_line": 46,
        "end_line": 49,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.holder#53",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.holder()",
        "snippet": "def holder():\n    # the MultiIndex constructor used to base compatibility with pickle\n    return MultiIndex",
        "begin_line": 53,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.compat_props#59",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.compat_props()",
        "snippet": "def compat_props():\n    # a MultiIndex must have these properties associated with it\n    return [\"shape\", \"ndim\", \"size\"]",
        "begin_line": 59,
        "end_line": 61,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.narrow_multi_index#65",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.narrow_multi_index()",
        "snippet": "def narrow_multi_index():\n    \"\"\"\n    Return a MultiIndex that is narrower than the display (<80 characters).\n    \"\"\"\n    n = 1000\n    ci = pd.CategoricalIndex(list(\"a\" * n) + ([\"abc\"] * n))\n    dti = pd.date_range(\"2000-01-01\", freq=\"s\", periods=n * 2)\n    return pd.MultiIndex.from_arrays([ci, ci.codes + 9, dti], names=[\"a\", \"b\", \"dti\"])",
        "begin_line": 65,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.wide_multi_index#76",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.wide_multi_index()",
        "snippet": "def wide_multi_index():\n    \"\"\"\n    Return a MultiIndex that is wider than the display (>80 characters).\n    \"\"\"\n    n = 1000\n    ci = pd.CategoricalIndex(list(\"a\" * n) + ([\"abc\"] * n))\n    dti = pd.date_range(\"2000-01-01\", freq=\"s\", periods=n * 2)\n    levels = [ci, ci.codes + 9, dti, dti, dti]\n    names = [\"a\", \"b\", \"dti_1\", \"dti_2\", \"dti_3\"]\n    return pd.MultiIndex.from_arrays(levels, names=names)",
        "begin_line": 76,
        "end_line": 85,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_argmax_axis_invalid#12",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_argmax_axis_invalid(self)",
        "snippet": "    def test_argmax_axis_invalid(self):\n        # GH#23081\n        rng = self.create_index()\n        with pytest.raises(ValueError):\n            rng.argmax(axis=1)\n        with pytest.raises(ValueError):\n            rng.argmin(axis=2)\n        with pytest.raises(ValueError):\n            rng.min(axis=-2)\n        with pytest.raises(ValueError):\n            rng.max(axis=-3)",
        "begin_line": 12,
        "end_line": 22,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_can_hold_identifiers#24",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_can_hold_identifiers(self)",
        "snippet": "    def test_can_hold_identifiers(self):\n        idx = self.create_index()\n        key = idx[0]\n        assert idx._can_hold_identifiers_and_holds_name(key) is False",
        "begin_line": 24,
        "end_line": 27,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_shift_identity#29",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_shift_identity(self)",
        "snippet": "    def test_shift_identity(self):\n\n        idx = self.create_index()\n        tm.assert_index_equal(idx, idx.shift(0))",
        "begin_line": 29,
        "end_line": 32,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_str#34",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_str(self)",
        "snippet": "    def test_str(self):\n\n        # test the string repr\n        idx = self.create_index()\n        idx.name = \"foo\"\n        assert not \"length={}\".format(len(idx)) in str(idx)\n        assert \"'foo'\" in str(idx)\n        assert idx.__class__.__name__ in str(idx)\n\n        if hasattr(idx, \"tz\"):\n            if idx.tz is not None:\n                assert idx.tz in str(idx)\n        if hasattr(idx, \"freq\"):\n            assert \"freq='{idx.freqstr}'\".format(idx=idx) in str(idx)",
        "begin_line": 34,
        "end_line": 47,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_view#49",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_view(self)",
        "snippet": "    def test_view(self):\n        i = self.create_index()\n\n        i_view = i.view(\"i8\")\n        result = self._holder(i)\n        tm.assert_index_equal(result, i)\n\n        i_view = i.view(self._holder)\n        result = self._holder(i)\n        tm.assert_index_equal(result, i_view)",
        "begin_line": 49,
        "end_line": 58,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_callable#60",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_callable(self)",
        "snippet": "    def test_map_callable(self):\n        expected = self.index + self.index.freq\n        result = self.index.map(lambda x: x + x.freq)\n        tm.assert_index_equal(result, expected)\n\n        # map to NaT\n        result = self.index.map(lambda x: pd.NaT if x == self.index[0] else x)\n        expected = pd.Index([pd.NaT] + self.index[1:].tolist())\n        tm.assert_index_equal(result, expected)",
        "begin_line": 60,
        "end_line": 68,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_dictlike#77",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_dictlike(self, mapper)",
        "snippet": "    def test_map_dictlike(self, mapper):\n        expected = self.index + self.index.freq\n\n        # don't compare the freqs\n        if isinstance(expected, pd.DatetimeIndex):\n            expected.freq = None\n\n        result = self.index.map(mapper(expected, self.index))\n        tm.assert_index_equal(result, expected)\n\n        expected = pd.Index([pd.NaT] + self.index[1:].tolist())\n        result = self.index.map(mapper(expected, self.index))\n        tm.assert_index_equal(result, expected)\n\n        # empty map; these map to np.nan because we cannot know\n        # to re-infer things\n        expected = pd.Index([np.nan] * len(self.index))\n        result = self.index.map(mapper([], []))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 77,
        "end_line": 95,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_asobject_deprecated#97",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_asobject_deprecated(self)",
        "snippet": "    def test_asobject_deprecated(self):\n        # GH18572\n        d = self.create_index()\n        with tm.assert_produces_warning(FutureWarning):\n            i = d.asobject\n        assert isinstance(i, pd.Index)",
        "begin_line": 97,
        "end_line": 102,
        "comment": "",
        "is_bug": false
    }
]