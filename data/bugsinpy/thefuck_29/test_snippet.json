[
    {
        "name": "tests.test_types.test_rules_names_list#5",
        "src_path": "tests/test_types.py",
        "class_name": "tests.test_types",
        "signature": "tests.test_types.test_rules_names_list()",
        "snippet": "def test_rules_names_list():\n    assert RulesNamesList(['bash', 'lisp']) == ['bash', 'lisp']\n    assert RulesNamesList(['bash', 'lisp']) == RulesNamesList(['bash', 'lisp'])\n    assert Rule('lisp') in RulesNamesList(['lisp'])\n    assert Rule('bash') not in RulesNamesList(['lisp'])",
        "begin_line": 5,
        "end_line": 9,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_types.test_update_settings#12",
        "src_path": "tests/test_types.py",
        "class_name": "tests.test_types",
        "signature": "tests.test_types.test_update_settings()",
        "snippet": "def test_update_settings():\n    settings = Settings({'key': 'val'})\n    new_settings = settings.update(key='new-val', unset='unset-value')\n    assert new_settings.key == 'val'\n    assert new_settings.unset == 'unset-value'\n    assert settings.key == 'val'",
        "begin_line": 12,
        "end_line": 17,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_utils.test_wrap_settings#14",
        "src_path": "tests/test_utils.py",
        "class_name": "tests.test_utils",
        "signature": "tests.test_utils.test_wrap_settings(override, old, new)",
        "snippet": "def test_wrap_settings(override, old, new):\n    fn = lambda _, settings: settings\n    assert wrap_settings(override)(fn)(None, Settings(old)) == new",
        "begin_line": 14,
        "end_line": 16,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_utils.test_sudo_support#27",
        "src_path": "tests/test_utils.py",
        "class_name": "tests.test_utils",
        "signature": "tests.test_utils.test_sudo_support(return_value, command, called, result)",
        "snippet": "def test_sudo_support(return_value, command, called, result):\n    fn = Mock(return_value=return_value, __name__='')\n    assert sudo_support(fn)(Command(command), None) == result\n    fn.assert_called_once_with(Command(called), None)",
        "begin_line": 27,
        "end_line": 30,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_utils.test_git_support#36",
        "src_path": "tests/test_utils.py",
        "class_name": "tests.test_utils",
        "signature": "tests.test_utils.test_git_support(called, command, stderr)",
        "snippet": "def test_git_support(called, command, stderr):\n    @git_support\n    def fn(command, settings): return command.script\n    assert fn(Command(script=called, stderr=stderr), None) == command",
        "begin_line": 36,
        "end_line": 39,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_utils.fn#38",
        "src_path": "tests/test_utils.py",
        "class_name": "tests.test_utils",
        "signature": "tests.test_utils.fn(command, settings)",
        "snippet": "    def fn(command, settings): return command.script",
        "begin_line": 38,
        "end_line": 38,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_utils.test_git_support_match#50",
        "src_path": "tests/test_utils.py",
        "class_name": "tests.test_utils",
        "signature": "tests.test_utils.test_git_support_match(command, is_git)",
        "snippet": "def test_git_support_match(command, is_git):\n    @git_support\n    def fn(command, settings): return True\n    assert fn(Command(script=command), None) == is_git",
        "begin_line": 50,
        "end_line": 53,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_utils.fn#52",
        "src_path": "tests/test_utils.py",
        "class_name": "tests.test_utils",
        "signature": "tests.test_utils.fn(command, settings)",
        "snippet": "    def fn(command, settings): return True",
        "begin_line": 52,
        "end_line": 52,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_utils.test_memoize#56",
        "src_path": "tests/test_utils.py",
        "class_name": "tests.test_utils",
        "signature": "tests.test_utils.test_memoize()",
        "snippet": "def test_memoize():\n    fn = Mock(__name__='fn')\n    memoized = memoize(fn)\n    memoized()\n    memoized()\n    fn.assert_called_once_with()",
        "begin_line": 56,
        "end_line": 61,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_utils.test_no_memoize#65",
        "src_path": "tests/test_utils.py",
        "class_name": "tests.test_utils",
        "signature": "tests.test_utils.test_no_memoize()",
        "snippet": "def test_no_memoize():\n    fn = Mock(__name__='fn')\n    memoized = memoize(fn)\n    memoized()\n    memoized()\n    assert fn.call_count == 2",
        "begin_line": 65,
        "end_line": 70,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_utils.TestGetClosest.test_when_can_match#75",
        "src_path": "tests/test_utils.py",
        "class_name": "tests.test_utils.TestGetClosest",
        "signature": "tests.test_utils.TestGetClosest.test_when_can_match(self)",
        "snippet": "    def test_when_can_match(self):\n        assert 'branch' == get_closest('brnch', ['branch', 'status'])",
        "begin_line": 75,
        "end_line": 76,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_utils.TestGetClosest.test_when_cant_match#78",
        "src_path": "tests/test_utils.py",
        "class_name": "tests.test_utils.TestGetClosest",
        "signature": "tests.test_utils.TestGetClosest.test_when_cant_match(self)",
        "snippet": "    def test_when_cant_match(self):\n        assert 'status' == get_closest('st', ['status', 'reset'])",
        "begin_line": 78,
        "end_line": 79,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_utils.TestGetClosest.test_without_fallback#81",
        "src_path": "tests/test_utils.py",
        "class_name": "tests.test_utils.TestGetClosest",
        "signature": "tests.test_utils.TestGetClosest.test_without_fallback(self)",
        "snippet": "    def test_without_fallback(self):\n        assert get_closest('st', ['status', 'reset'],\n                           fallback_to_first=False) is None",
        "begin_line": 81,
        "end_line": 83,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_utils.get_aliases#87",
        "src_path": "tests/test_utils.py",
        "class_name": "tests.test_utils",
        "signature": "tests.test_utils.get_aliases(mocker)",
        "snippet": "def get_aliases(mocker):\n    mocker.patch('thefuck.shells.get_aliases',\n                 return_value=['vim', 'apt-get', 'fsck', 'fuck'])",
        "begin_line": 87,
        "end_line": 89,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_utils.test_get_all_callables#93",
        "src_path": "tests/test_utils.py",
        "class_name": "tests.test_utils",
        "signature": "tests.test_utils.test_get_all_callables()",
        "snippet": "def test_get_all_callables():\n    all_callables = get_all_executables()\n    assert 'vim' in all_callables\n    assert 'fsck' in all_callables\n    assert 'fuck' not in all_callables",
        "begin_line": 93,
        "end_line": 97,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_utils.test_replace_argument#103",
        "src_path": "tests/test_utils.py",
        "class_name": "tests.test_utils",
        "signature": "tests.test_utils.test_replace_argument(args, result)",
        "snippet": "def test_replace_argument(args, result):\n    assert replace_argument(*args) == result",
        "begin_line": 103,
        "end_line": 104,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_utils.test_get_all_matched_commands#132",
        "src_path": "tests/test_utils.py",
        "class_name": "tests.test_utils",
        "signature": "tests.test_utils.test_get_all_matched_commands(stderr, result)",
        "snippet": "def test_get_all_matched_commands(stderr, result):\n    assert list(get_all_matched_commands(stderr)) == result",
        "begin_line": 132,
        "end_line": 133,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.conftest.no_memoize#5",
        "src_path": "tests/conftest.py",
        "class_name": "tests.conftest",
        "signature": "tests.conftest.no_memoize(monkeypatch)",
        "snippet": "def no_memoize(monkeypatch):\n    monkeypatch.setattr('thefuck.utils.memoize.disabled', True)",
        "begin_line": 5,
        "end_line": 6,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.rules.conftest.generic_shell#5",
        "src_path": "tests/rules/conftest.py",
        "class_name": "tests.rules.conftest",
        "signature": "tests.rules.conftest.generic_shell(monkeypatch)",
        "snippet": "def generic_shell(monkeypatch):\n    monkeypatch.setattr('thefuck.shells.and_', lambda *x: ' && '.join(x))",
        "begin_line": 5,
        "end_line": 6,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.utils.Command#5",
        "src_path": "tests/utils.py",
        "class_name": "tests.utils",
        "signature": "tests.utils.Command(script='', stdout='', stderr='')",
        "snippet": "def Command(script='', stdout='', stderr=''):\n    return types.Command(script, stdout, stderr)",
        "begin_line": 5,
        "end_line": 6,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.utils.Rule#9",
        "src_path": "tests/utils.py",
        "class_name": "tests.utils",
        "signature": "tests.utils.Rule(name='', match=lambda *_: True, get_new_command=lambda *_: '', enabled_by_default=True, side_effect=None, priority=DEFAULT_PRIORITY, requires_output=True)",
        "snippet": "def Rule(name='', match=lambda *_: True,\n         get_new_command=lambda *_: '',\n         enabled_by_default=True,\n         side_effect=None,\n         priority=DEFAULT_PRIORITY,\n         requires_output=True):\n    return types.Rule(name, match, get_new_command,\n                      enabled_by_default, side_effect,\n                      priority, requires_output)",
        "begin_line": 9,
        "end_line": 17,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.utils.CorrectedCommand#20",
        "src_path": "tests/utils.py",
        "class_name": "tests.utils",
        "signature": "tests.utils.CorrectedCommand(script='', side_effect=None, priority=DEFAULT_PRIORITY)",
        "snippet": "def CorrectedCommand(script='', side_effect=None, priority=DEFAULT_PRIORITY):\n    return types.CorrectedCommand(script, side_effect, priority)",
        "begin_line": 20,
        "end_line": 21,
        "comment": "",
        "is_bug": false
    }
]