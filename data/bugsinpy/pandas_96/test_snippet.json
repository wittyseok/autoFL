[
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestTimestampEquivDateRange.test_date_range_timestamp_equiv#37",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestTimestampEquivDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestTimestampEquivDateRange.test_date_range_timestamp_equiv(self)",
        "snippet": "    def test_date_range_timestamp_equiv(self):\n        rng = date_range(\"20090415\", \"20090519\", tz=\"US/Eastern\")\n        stamp = rng[0]\n\n        ts = Timestamp(\"20090415\", tz=\"US/Eastern\", freq=\"D\")\n        assert ts == stamp",
        "begin_line": 37,
        "end_line": 42,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestTimestampEquivDateRange.test_date_range_timestamp_equiv_dateutil#44",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestTimestampEquivDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestTimestampEquivDateRange.test_date_range_timestamp_equiv_dateutil(self)",
        "snippet": "    def test_date_range_timestamp_equiv_dateutil(self):\n        rng = date_range(\"20090415\", \"20090519\", tz=\"dateutil/US/Eastern\")\n        stamp = rng[0]\n\n        ts = Timestamp(\"20090415\", tz=\"dateutil/US/Eastern\", freq=\"D\")\n        assert ts == stamp",
        "begin_line": 44,
        "end_line": 49,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestTimestampEquivDateRange.test_date_range_timestamp_equiv_explicit_pytz#51",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestTimestampEquivDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestTimestampEquivDateRange.test_date_range_timestamp_equiv_explicit_pytz(self)",
        "snippet": "    def test_date_range_timestamp_equiv_explicit_pytz(self):\n        rng = date_range(\"20090415\", \"20090519\", tz=pytz.timezone(\"US/Eastern\"))\n        stamp = rng[0]\n\n        ts = Timestamp(\"20090415\", tz=pytz.timezone(\"US/Eastern\"), freq=\"D\")\n        assert ts == stamp",
        "begin_line": 51,
        "end_line": 56,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestTimestampEquivDateRange.test_date_range_timestamp_equiv_explicit_dateutil#59",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestTimestampEquivDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestTimestampEquivDateRange.test_date_range_timestamp_equiv_explicit_dateutil(self)",
        "snippet": "    def test_date_range_timestamp_equiv_explicit_dateutil(self):\n        from pandas._libs.tslibs.timezones import dateutil_gettz as gettz\n\n        rng = date_range(\"20090415\", \"20090519\", tz=gettz(\"US/Eastern\"))\n        stamp = rng[0]\n\n        ts = Timestamp(\"20090415\", tz=gettz(\"US/Eastern\"), freq=\"D\")\n        assert ts == stamp",
        "begin_line": 59,
        "end_line": 66,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestTimestampEquivDateRange.test_date_range_timestamp_equiv_from_datetime_instance#68",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestTimestampEquivDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestTimestampEquivDateRange.test_date_range_timestamp_equiv_from_datetime_instance(self)",
        "snippet": "    def test_date_range_timestamp_equiv_from_datetime_instance(self):\n        datetime_instance = datetime(2014, 3, 4)\n        # build a timestamp with a frequency, since then it supports\n        # addition/subtraction of integers\n        timestamp_instance = date_range(datetime_instance, periods=1, freq=\"D\")[0]\n\n        ts = Timestamp(datetime_instance, freq=\"D\")\n        assert ts == timestamp_instance",
        "begin_line": 68,
        "end_line": 75,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestTimestampEquivDateRange.test_date_range_timestamp_equiv_preserve_frequency#77",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestTimestampEquivDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestTimestampEquivDateRange.test_date_range_timestamp_equiv_preserve_frequency(self)",
        "snippet": "    def test_date_range_timestamp_equiv_preserve_frequency(self):\n        timestamp_instance = date_range(\"2014-03-05\", periods=1, freq=\"D\")[0]\n        ts = Timestamp(\"2014-03-05\", freq=\"D\")\n\n        assert timestamp_instance == ts",
        "begin_line": 77,
        "end_line": 81,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_nat#85",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_nat(self)",
        "snippet": "    def test_date_range_nat(self):\n        # GH#11587\n        msg = \"Neither `start` nor `end` can be NaT\"\n        with pytest.raises(ValueError, match=msg):\n            date_range(start=\"2016-01-01\", end=pd.NaT, freq=\"D\")\n        with pytest.raises(ValueError, match=msg):\n            date_range(start=pd.NaT, end=\"2016-01-01\", freq=\"D\")",
        "begin_line": 85,
        "end_line": 91,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_multiplication_overflow#93",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_multiplication_overflow(self)",
        "snippet": "    def test_date_range_multiplication_overflow(self):\n        # GH#24255\n        # check that overflows in calculating `addend = periods * stride`\n        #  are caught\n        with tm.assert_produces_warning(None):\n            # we should _not_ be seeing a overflow RuntimeWarning\n            dti = date_range(start=\"1677-09-22\", periods=213503, freq=\"D\")\n\n        assert dti[0] == Timestamp(\"1677-09-22\")\n        assert len(dti) == 213503\n\n        msg = \"Cannot generate range with\"\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            date_range(\"1969-05-04\", periods=200000000, freq=\"30000D\")",
        "begin_line": 93,
        "end_line": 106,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_unsigned_overflow_handling#108",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_unsigned_overflow_handling(self)",
        "snippet": "    def test_date_range_unsigned_overflow_handling(self):\n        # GH#24255\n        # case where `addend = periods * stride` overflows int64 bounds\n        #  but not uint64 bounds\n        dti = date_range(start=\"1677-09-22\", end=\"2262-04-11\", freq=\"D\")\n\n        dti2 = date_range(start=dti[0], periods=len(dti), freq=\"D\")\n        assert dti2.equals(dti)\n\n        dti3 = date_range(end=dti[-1], periods=len(dti), freq=\"D\")\n        assert dti3.equals(dti)",
        "begin_line": 108,
        "end_line": 118,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_int64_overflow_non_recoverable#120",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_int64_overflow_non_recoverable(self)",
        "snippet": "    def test_date_range_int64_overflow_non_recoverable(self):\n        # GH#24255\n        # case with start later than 1970-01-01, overflow int64 but not uint64\n        msg = \"Cannot generate range with\"\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            date_range(start=\"1970-02-01\", periods=106752 * 24, freq=\"H\")\n\n        # case with end before 1970-01-01, overflow int64 but not uint64\n        with pytest.raises(OutOfBoundsDatetime, match=msg):\n            date_range(end=\"1969-11-14\", periods=106752 * 24, freq=\"H\")",
        "begin_line": 120,
        "end_line": 129,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_int64_overflow_stride_endpoint_different_signs#131",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_int64_overflow_stride_endpoint_different_signs(self)",
        "snippet": "    def test_date_range_int64_overflow_stride_endpoint_different_signs(self):\n        # cases where stride * periods overflow int64 and stride/endpoint\n        #  have different signs\n        start = Timestamp(\"2262-02-23\")\n        end = Timestamp(\"1969-11-14\")\n\n        expected = date_range(start=start, end=end, freq=\"-1H\")\n        assert expected[0] == start\n        assert expected[-1] == end\n\n        dti = date_range(end=end, periods=len(expected), freq=\"-1H\")\n        tm.assert_index_equal(dti, expected)\n\n        start2 = Timestamp(\"1970-02-01\")\n        end2 = Timestamp(\"1677-10-22\")\n\n        expected2 = date_range(start=start2, end=end2, freq=\"-1H\")\n        assert expected2[0] == start2\n        assert expected2[-1] == end2\n\n        dti2 = date_range(start=start2, periods=len(expected2), freq=\"-1H\")\n        tm.assert_index_equal(dti2, expected2)",
        "begin_line": 131,
        "end_line": 152,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_out_of_bounds#154",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_out_of_bounds(self)",
        "snippet": "    def test_date_range_out_of_bounds(self):\n        # GH#14187\n        with pytest.raises(OutOfBoundsDatetime):\n            date_range(\"2016-01-01\", periods=100000, freq=\"D\")\n        with pytest.raises(OutOfBoundsDatetime):\n            date_range(end=\"1763-10-12\", periods=100000, freq=\"D\")",
        "begin_line": 154,
        "end_line": 159,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_gen_error#161",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_gen_error(self)",
        "snippet": "    def test_date_range_gen_error(self):\n        rng = date_range(\"1/1/2000 00:00\", \"1/1/2000 00:18\", freq=\"5min\")\n        assert len(rng) == 4",
        "begin_line": 161,
        "end_line": 163,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_begin_year_alias#166",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_begin_year_alias(self, freq)",
        "snippet": "    def test_begin_year_alias(self, freq):\n        # see gh-9313\n        rng = date_range(\"1/1/2013\", \"7/1/2017\", freq=freq)\n        exp = pd.DatetimeIndex(\n            [\"2013-01-01\", \"2014-01-01\", \"2015-01-01\", \"2016-01-01\", \"2017-01-01\"],\n            freq=freq,\n        )\n        tm.assert_index_equal(rng, exp)",
        "begin_line": 166,
        "end_line": 173,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_end_year_alias#176",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_end_year_alias(self, freq)",
        "snippet": "    def test_end_year_alias(self, freq):\n        # see gh-9313\n        rng = date_range(\"1/1/2013\", \"7/1/2017\", freq=freq)\n        exp = pd.DatetimeIndex(\n            [\"2013-12-31\", \"2014-12-31\", \"2015-12-31\", \"2016-12-31\"], freq=freq\n        )\n        tm.assert_index_equal(rng, exp)",
        "begin_line": 176,
        "end_line": 182,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_business_end_year_alias#185",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_business_end_year_alias(self, freq)",
        "snippet": "    def test_business_end_year_alias(self, freq):\n        # see gh-9313\n        rng = date_range(\"1/1/2013\", \"7/1/2017\", freq=freq)\n        exp = pd.DatetimeIndex(\n            [\"2013-12-31\", \"2014-12-31\", \"2015-12-31\", \"2016-12-30\"], freq=freq\n        )\n        tm.assert_index_equal(rng, exp)",
        "begin_line": 185,
        "end_line": 191,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_negative_freq#193",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_negative_freq(self)",
        "snippet": "    def test_date_range_negative_freq(self):\n        # GH 11018\n        rng = date_range(\"2011-12-31\", freq=\"-2A\", periods=3)\n        exp = pd.DatetimeIndex([\"2011-12-31\", \"2009-12-31\", \"2007-12-31\"], freq=\"-2A\")\n        tm.assert_index_equal(rng, exp)\n        assert rng.freq == \"-2A\"\n\n        rng = date_range(\"2011-01-31\", freq=\"-2M\", periods=3)\n        exp = pd.DatetimeIndex([\"2011-01-31\", \"2010-11-30\", \"2010-09-30\"], freq=\"-2M\")\n        tm.assert_index_equal(rng, exp)\n        assert rng.freq == \"-2M\"",
        "begin_line": 193,
        "end_line": 203,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_bms_bug#205",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_bms_bug(self)",
        "snippet": "    def test_date_range_bms_bug(self):\n        # #1645\n        rng = date_range(\"1/1/2000\", periods=10, freq=\"BMS\")\n\n        ex_first = Timestamp(\"2000-01-03\")\n        assert rng[0] == ex_first",
        "begin_line": 205,
        "end_line": 210,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_normalize#212",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_normalize(self)",
        "snippet": "    def test_date_range_normalize(self):\n        snap = datetime.today()\n        n = 50\n\n        rng = date_range(snap, periods=n, normalize=False, freq=\"2D\")\n\n        offset = timedelta(2)\n        values = DatetimeIndex([snap + i * offset for i in range(n)])\n\n        tm.assert_index_equal(rng, values)\n\n        rng = date_range(\"1/1/2000 08:15\", periods=n, normalize=False, freq=\"B\")\n        the_time = time(8, 15)\n        for val in rng:\n            assert val.time() == the_time",
        "begin_line": 212,
        "end_line": 226,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_fy5252#228",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_fy5252(self)",
        "snippet": "    def test_date_range_fy5252(self):\n        dr = date_range(\n            start=\"2013-01-01\",\n            periods=2,\n            freq=offsets.FY5253(startingMonth=1, weekday=3, variation=\"nearest\"),\n        )\n        assert dr[0] == Timestamp(\"2013-01-31\")\n        assert dr[1] == Timestamp(\"2014-01-30\")",
        "begin_line": 228,
        "end_line": 235,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_ambiguous_arguments#237",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_ambiguous_arguments(self)",
        "snippet": "    def test_date_range_ambiguous_arguments(self):\n        # #2538\n        start = datetime(2011, 1, 1, 5, 3, 40)\n        end = datetime(2011, 1, 1, 8, 9, 40)\n\n        msg = (\n            \"Of the four parameters: start, end, periods, and \"\n            \"freq, exactly three must be specified\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            date_range(start, end, periods=10, freq=\"s\")",
        "begin_line": 237,
        "end_line": 247,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_convenience_periods#249",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_convenience_periods(self)",
        "snippet": "    def test_date_range_convenience_periods(self):\n        # GH 20808\n        result = date_range(\"2018-04-24\", \"2018-04-27\", periods=3)\n        expected = DatetimeIndex(\n            [\"2018-04-24 00:00:00\", \"2018-04-25 12:00:00\", \"2018-04-27 00:00:00\"],\n            freq=None,\n        )\n\n        tm.assert_index_equal(result, expected)\n\n        # Test if spacing remains linear if tz changes to dst in range\n        result = date_range(\n            \"2018-04-01 01:00:00\",\n            \"2018-04-01 04:00:00\",\n            tz=\"Australia/Sydney\",\n            periods=3,\n        )\n        expected = DatetimeIndex(\n            [\n                Timestamp(\"2018-04-01 01:00:00+1100\", tz=\"Australia/Sydney\"),\n                Timestamp(\"2018-04-01 02:00:00+1000\", tz=\"Australia/Sydney\"),\n                Timestamp(\"2018-04-01 04:00:00+1000\", tz=\"Australia/Sydney\"),\n            ]\n        )\n        tm.assert_index_equal(result, expected)",
        "begin_line": 249,
        "end_line": 273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_linspacing_tz#293",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_linspacing_tz(self, start, end, result_tz)",
        "snippet": "    def test_date_range_linspacing_tz(self, start, end, result_tz):\n        # GH 20983\n        result = date_range(start, end, periods=3, tz=result_tz)\n        expected = date_range(\"20180101\", periods=3, freq=\"D\", tz=\"US/Eastern\")\n        tm.assert_index_equal(result, expected)",
        "begin_line": 293,
        "end_line": 297,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_businesshour#299",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_date_range_businesshour(self)",
        "snippet": "    def test_date_range_businesshour(self):\n        idx = DatetimeIndex(\n            [\n                \"2014-07-04 09:00\",\n                \"2014-07-04 10:00\",\n                \"2014-07-04 11:00\",\n                \"2014-07-04 12:00\",\n                \"2014-07-04 13:00\",\n                \"2014-07-04 14:00\",\n                \"2014-07-04 15:00\",\n                \"2014-07-04 16:00\",\n            ],\n            freq=\"BH\",\n        )\n        rng = date_range(\"2014-07-04 09:00\", \"2014-07-04 16:00\", freq=\"BH\")\n        tm.assert_index_equal(idx, rng)\n\n        idx = DatetimeIndex([\"2014-07-04 16:00\", \"2014-07-07 09:00\"], freq=\"BH\")\n        rng = date_range(\"2014-07-04 16:00\", \"2014-07-07 09:00\", freq=\"BH\")\n        tm.assert_index_equal(idx, rng)\n\n        idx = DatetimeIndex(\n            [\n                \"2014-07-04 09:00\",\n                \"2014-07-04 10:00\",\n                \"2014-07-04 11:00\",\n                \"2014-07-04 12:00\",\n                \"2014-07-04 13:00\",\n                \"2014-07-04 14:00\",\n                \"2014-07-04 15:00\",\n                \"2014-07-04 16:00\",\n                \"2014-07-07 09:00\",\n                \"2014-07-07 10:00\",\n                \"2014-07-07 11:00\",\n                \"2014-07-07 12:00\",\n                \"2014-07-07 13:00\",\n                \"2014-07-07 14:00\",\n                \"2014-07-07 15:00\",\n                \"2014-07-07 16:00\",\n                \"2014-07-08 09:00\",\n                \"2014-07-08 10:00\",\n                \"2014-07-08 11:00\",\n                \"2014-07-08 12:00\",\n                \"2014-07-08 13:00\",\n                \"2014-07-08 14:00\",\n                \"2014-07-08 15:00\",\n                \"2014-07-08 16:00\",\n            ],\n            freq=\"BH\",\n        )\n        rng = date_range(\"2014-07-04 09:00\", \"2014-07-08 16:00\", freq=\"BH\")\n        tm.assert_index_equal(idx, rng)",
        "begin_line": 299,
        "end_line": 350,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_range_misspecified#352",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_range_misspecified(self)",
        "snippet": "    def test_range_misspecified(self):\n        # GH #1095\n        msg = (\n            \"Of the four parameters: start, end, periods, and \"\n            \"freq, exactly three must be specified\"\n        )\n\n        with pytest.raises(ValueError, match=msg):\n            date_range(start=\"1/1/2000\")\n\n        with pytest.raises(ValueError, match=msg):\n            date_range(end=\"1/1/2000\")\n\n        with pytest.raises(ValueError, match=msg):\n            date_range(periods=10)\n\n        with pytest.raises(ValueError, match=msg):\n            date_range(start=\"1/1/2000\", freq=\"H\")\n\n        with pytest.raises(ValueError, match=msg):\n            date_range(end=\"1/1/2000\", freq=\"H\")\n\n        with pytest.raises(ValueError, match=msg):\n            date_range(periods=10, freq=\"H\")\n\n        with pytest.raises(ValueError, match=msg):\n            date_range()",
        "begin_line": 352,
        "end_line": 378,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_compat_replace#380",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_compat_replace(self)",
        "snippet": "    def test_compat_replace(self):\n        # https://github.com/statsmodels/statsmodels/issues/3349\n        # replace should take ints/longs for compat\n        result = date_range(\n            Timestamp(\"1960-04-01 00:00:00\", freq=\"QS-JAN\"), periods=76, freq=\"QS-JAN\"\n        )\n        assert len(result) == 76",
        "begin_line": 380,
        "end_line": 386,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_catch_infinite_loop#388",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_catch_infinite_loop(self)",
        "snippet": "    def test_catch_infinite_loop(self):\n        offset = offsets.DateOffset(minute=5)\n        # blow up, don't loop forever\n        msg = \"Offset <DateOffset: minute=5> did not increment date\"\n        with pytest.raises(ValueError, match=msg):\n            date_range(datetime(2011, 11, 11), datetime(2011, 11, 12), freq=offset)",
        "begin_line": 388,
        "end_line": 393,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_wom_len#396",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_wom_len(self, periods)",
        "snippet": "    def test_wom_len(self, periods):\n        # https://github.com/pandas-dev/pandas/issues/20517\n        res = date_range(start=\"20110101\", periods=periods, freq=\"WOM-1MON\")\n        assert len(res) == periods",
        "begin_line": 396,
        "end_line": 399,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_construct_over_dst#401",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_construct_over_dst(self)",
        "snippet": "    def test_construct_over_dst(self):\n        # GH 20854\n        pre_dst = Timestamp(\"2010-11-07 01:00:00\").tz_localize(\n            \"US/Pacific\", ambiguous=True\n        )\n        pst_dst = Timestamp(\"2010-11-07 01:00:00\").tz_localize(\n            \"US/Pacific\", ambiguous=False\n        )\n        expect_data = [\n            Timestamp(\"2010-11-07 00:00:00\", tz=\"US/Pacific\"),\n            pre_dst,\n            pst_dst,\n        ]\n        expected = DatetimeIndex(expect_data)\n        result = date_range(start=\"2010-11-7\", periods=3, freq=\"H\", tz=\"US/Pacific\")\n        tm.assert_index_equal(result, expected)",
        "begin_line": 401,
        "end_line": 416,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_construct_with_different_start_end_string_format#418",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_construct_with_different_start_end_string_format(self)",
        "snippet": "    def test_construct_with_different_start_end_string_format(self):\n        # GH 12064\n        result = date_range(\n            \"2013-01-01 00:00:00+09:00\", \"2013/01/01 02:00:00+09:00\", freq=\"H\"\n        )\n        expected = DatetimeIndex(\n            [\n                Timestamp(\"2013-01-01 00:00:00+09:00\"),\n                Timestamp(\"2013-01-01 01:00:00+09:00\"),\n                Timestamp(\"2013-01-01 02:00:00+09:00\"),\n            ]\n        )\n        tm.assert_index_equal(result, expected)",
        "begin_line": 418,
        "end_line": 430,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_error_with_zero_monthends#432",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_error_with_zero_monthends(self)",
        "snippet": "    def test_error_with_zero_monthends(self):\n        msg = r\"Offset <0 \\* MonthEnds> did not increment date\"\n        with pytest.raises(ValueError, match=msg):\n            date_range(\"1/1/2000\", \"1/1/2001\", freq=MonthEnd(0))",
        "begin_line": 432,
        "end_line": 435,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_range_bug#437",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_range_bug(self)",
        "snippet": "    def test_range_bug(self):\n        # GH #770\n        offset = DateOffset(months=3)\n        result = date_range(\"2011-1-1\", \"2012-1-31\", freq=offset)\n\n        start = datetime(2011, 1, 1)\n        expected = DatetimeIndex([start + i * offset for i in range(5)])\n        tm.assert_index_equal(result, expected)",
        "begin_line": 437,
        "end_line": 444,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_range_tz_pytz#446",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_range_tz_pytz(self)",
        "snippet": "    def test_range_tz_pytz(self):\n        # see gh-2906\n        tz = timezone(\"US/Eastern\")\n        start = tz.localize(datetime(2011, 1, 1))\n        end = tz.localize(datetime(2011, 1, 3))\n\n        dr = date_range(start=start, periods=3)\n        assert dr.tz.zone == tz.zone\n        assert dr[0] == start\n        assert dr[2] == end\n\n        dr = date_range(end=end, periods=3)\n        assert dr.tz.zone == tz.zone\n        assert dr[0] == start\n        assert dr[2] == end\n\n        dr = date_range(start=start, end=end)\n        assert dr.tz.zone == tz.zone\n        assert dr[0] == start\n        assert dr[2] == end",
        "begin_line": 446,
        "end_line": 465,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_range_tz_dst_straddle_pytz#480",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_range_tz_dst_straddle_pytz(self, start, end)",
        "snippet": "    def test_range_tz_dst_straddle_pytz(self, start, end):\n        dr = date_range(start, end, freq=\"D\")\n        assert dr[0] == start\n        assert dr[-1] == end\n        assert np.all(dr.hour == 0)\n\n        dr = date_range(start, end, freq=\"D\", tz=\"US/Eastern\")\n        assert dr[0] == start\n        assert dr[-1] == end\n        assert np.all(dr.hour == 0)\n\n        dr = date_range(\n            start.replace(tzinfo=None),\n            end.replace(tzinfo=None),\n            freq=\"D\",\n            tz=\"US/Eastern\",\n        )\n        assert dr[0] == start\n        assert dr[-1] == end\n        assert np.all(dr.hour == 0)",
        "begin_line": 480,
        "end_line": 499,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_range_tz_dateutil#501",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_range_tz_dateutil(self)",
        "snippet": "    def test_range_tz_dateutil(self):\n        # see gh-2906\n\n        # Use maybe_get_tz to fix filename in tz under dateutil.\n        from pandas._libs.tslibs.timezones import maybe_get_tz\n\n        tz = lambda x: maybe_get_tz(\"dateutil/\" + x)\n\n        start = datetime(2011, 1, 1, tzinfo=tz(\"US/Eastern\"))\n        end = datetime(2011, 1, 3, tzinfo=tz(\"US/Eastern\"))\n\n        dr = date_range(start=start, periods=3)\n        assert dr.tz == tz(\"US/Eastern\")\n        assert dr[0] == start\n        assert dr[2] == end\n\n        dr = date_range(end=end, periods=3)\n        assert dr.tz == tz(\"US/Eastern\")\n        assert dr[0] == start\n        assert dr[2] == end\n\n        dr = date_range(start=start, end=end)\n        assert dr.tz == tz(\"US/Eastern\")\n        assert dr[0] == start\n        assert dr[2] == end",
        "begin_line": 501,
        "end_line": 525,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_range_closed#528",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_range_closed(self, freq)",
        "snippet": "    def test_range_closed(self, freq):\n        begin = datetime(2011, 1, 1)\n        end = datetime(2014, 1, 1)\n\n        closed = date_range(begin, end, closed=None, freq=freq)\n        left = date_range(begin, end, closed=\"left\", freq=freq)\n        right = date_range(begin, end, closed=\"right\", freq=freq)\n        expected_left = left\n        expected_right = right\n\n        if end == closed[-1]:\n            expected_left = closed[:-1]\n        if begin == closed[0]:\n            expected_right = closed[1:]\n\n        tm.assert_index_equal(expected_left, left)\n        tm.assert_index_equal(expected_right, right)",
        "begin_line": 528,
        "end_line": 544,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_range_closed_with_tz_aware_start_end#546",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_range_closed_with_tz_aware_start_end(self)",
        "snippet": "    def test_range_closed_with_tz_aware_start_end(self):\n        # GH12409, GH12684\n        begin = Timestamp(\"2011/1/1\", tz=\"US/Eastern\")\n        end = Timestamp(\"2014/1/1\", tz=\"US/Eastern\")\n\n        for freq in [\"1D\", \"3D\", \"2M\", \"7W\", \"3H\", \"A\"]:\n            closed = date_range(begin, end, closed=None, freq=freq)\n            left = date_range(begin, end, closed=\"left\", freq=freq)\n            right = date_range(begin, end, closed=\"right\", freq=freq)\n            expected_left = left\n            expected_right = right\n\n            if end == closed[-1]:\n                expected_left = closed[:-1]\n            if begin == closed[0]:\n                expected_right = closed[1:]\n\n            tm.assert_index_equal(expected_left, left)\n            tm.assert_index_equal(expected_right, right)\n\n        begin = Timestamp(\"2011/1/1\")\n        end = Timestamp(\"2014/1/1\")\n        begintz = Timestamp(\"2011/1/1\", tz=\"US/Eastern\")\n        endtz = Timestamp(\"2014/1/1\", tz=\"US/Eastern\")\n\n        for freq in [\"1D\", \"3D\", \"2M\", \"7W\", \"3H\", \"A\"]:\n            closed = date_range(begin, end, closed=None, freq=freq, tz=\"US/Eastern\")\n            left = date_range(begin, end, closed=\"left\", freq=freq, tz=\"US/Eastern\")\n            right = date_range(begin, end, closed=\"right\", freq=freq, tz=\"US/Eastern\")\n            expected_left = left\n            expected_right = right\n\n            if endtz == closed[-1]:\n                expected_left = closed[:-1]\n            if begintz == closed[0]:\n                expected_right = closed[1:]\n\n            tm.assert_index_equal(expected_left, left)\n            tm.assert_index_equal(expected_right, right)",
        "begin_line": 546,
        "end_line": 584,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_range_closed_boundary#587",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_range_closed_boundary(self, closed)",
        "snippet": "    def test_range_closed_boundary(self, closed):\n        # GH#11804\n        right_boundary = date_range(\n            \"2015-09-12\", \"2015-12-01\", freq=\"QS-MAR\", closed=closed\n        )\n        left_boundary = date_range(\n            \"2015-09-01\", \"2015-09-12\", freq=\"QS-MAR\", closed=closed\n        )\n        both_boundary = date_range(\n            \"2015-09-01\", \"2015-12-01\", freq=\"QS-MAR\", closed=closed\n        )\n        expected_right = expected_left = expected_both = both_boundary\n\n        if closed == \"right\":\n            expected_left = both_boundary[1:]\n        if closed == \"left\":\n            expected_right = both_boundary[:-1]\n        if closed is None:\n            expected_right = both_boundary[1:]\n            expected_left = both_boundary[:-1]\n\n        tm.assert_index_equal(right_boundary, expected_right)\n        tm.assert_index_equal(left_boundary, expected_left)\n        tm.assert_index_equal(both_boundary, expected_both)",
        "begin_line": 587,
        "end_line": 610,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_years_only#612",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_years_only(self)",
        "snippet": "    def test_years_only(self):\n        # GH 6961\n        dr = date_range(\"2014\", \"2015\", freq=\"M\")\n        assert dr[0] == datetime(2014, 1, 31)\n        assert dr[-1] == datetime(2014, 12, 31)",
        "begin_line": 612,
        "end_line": 616,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_freq_divides_end_in_nanos#618",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_freq_divides_end_in_nanos(self)",
        "snippet": "    def test_freq_divides_end_in_nanos(self):\n        # GH 10885\n        result_1 = date_range(\"2005-01-12 10:00\", \"2005-01-12 16:00\", freq=\"345min\")\n        result_2 = date_range(\"2005-01-13 10:00\", \"2005-01-13 16:00\", freq=\"345min\")\n        expected_1 = DatetimeIndex(\n            [\"2005-01-12 10:00:00\", \"2005-01-12 15:45:00\"],\n            dtype=\"datetime64[ns]\",\n            freq=\"345T\",\n            tz=None,\n        )\n        expected_2 = DatetimeIndex(\n            [\"2005-01-13 10:00:00\", \"2005-01-13 15:45:00\"],\n            dtype=\"datetime64[ns]\",\n            freq=\"345T\",\n            tz=None,\n        )\n        tm.assert_index_equal(result_1, expected_1)\n        tm.assert_index_equal(result_2, expected_2)",
        "begin_line": 618,
        "end_line": 635,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_cached_range_bug#637",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_cached_range_bug(self)",
        "snippet": "    def test_cached_range_bug(self):\n        rng = date_range(\"2010-09-01 05:00:00\", periods=50, freq=DateOffset(hours=6))\n        assert len(rng) == 50\n        assert rng[0] == datetime(2010, 9, 1, 5)",
        "begin_line": 637,
        "end_line": 640,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_timezone_comparaison_bug#642",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_timezone_comparaison_bug(self)",
        "snippet": "    def test_timezone_comparaison_bug(self):\n        # smoke test\n        start = Timestamp(\"20130220 10:00\", tz=\"US/Eastern\")\n        result = date_range(start, periods=2, tz=\"US/Eastern\")\n        assert len(result) == 2",
        "begin_line": 642,
        "end_line": 646,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_timezone_comparaison_assert#648",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_timezone_comparaison_assert(self)",
        "snippet": "    def test_timezone_comparaison_assert(self):\n        start = Timestamp(\"20130220 10:00\", tz=\"US/Eastern\")\n        msg = \"Inferred time zone not equal to passed time zone\"\n        with pytest.raises(AssertionError, match=msg):\n            date_range(start, periods=2, tz=\"Europe/Berlin\")",
        "begin_line": 648,
        "end_line": 652,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_negative_non_tick_frequency_descending_dates#654",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestDateRanges.test_negative_non_tick_frequency_descending_dates(self, tz_aware_fixture)",
        "snippet": "    def test_negative_non_tick_frequency_descending_dates(self, tz_aware_fixture):\n        # GH 23270\n        tz = tz_aware_fixture\n        result = pd.date_range(start=\"2011-06-01\", end=\"2011-01-01\", freq=\"-1MS\", tz=tz)\n        expected = pd.date_range(\n            end=\"2011-06-01\", start=\"2011-01-01\", freq=\"1MS\", tz=tz\n        )[::-1]\n        tm.assert_index_equal(result, expected)",
        "begin_line": 654,
        "end_line": 661,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration.test_generate#665",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration.test_generate(self)",
        "snippet": "    def test_generate(self):\n        rng1 = list(generate_range(START, END, offset=BDay()))\n        rng2 = list(generate_range(START, END, offset=\"B\"))\n        assert rng1 == rng2",
        "begin_line": 665,
        "end_line": 668,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration.test_generate_cday#670",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration.test_generate_cday(self)",
        "snippet": "    def test_generate_cday(self):\n        rng1 = list(generate_range(START, END, offset=CDay()))\n        rng2 = list(generate_range(START, END, offset=\"C\"))\n        assert rng1 == rng2",
        "begin_line": 670,
        "end_line": 673,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration.test_1#675",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration.test_1(self)",
        "snippet": "    def test_1(self):\n        rng = list(generate_range(start=datetime(2009, 3, 25), periods=2))\n        expected = [datetime(2009, 3, 25), datetime(2009, 3, 26)]\n        assert rng == expected",
        "begin_line": 675,
        "end_line": 678,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration.test_2#680",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration.test_2(self)",
        "snippet": "    def test_2(self):\n        rng = list(generate_range(start=datetime(2008, 1, 1), end=datetime(2008, 1, 3)))\n        expected = [datetime(2008, 1, 1), datetime(2008, 1, 2), datetime(2008, 1, 3)]\n        assert rng == expected",
        "begin_line": 680,
        "end_line": 683,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration.test_3#685",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration.test_3(self)",
        "snippet": "    def test_3(self):\n        rng = list(generate_range(start=datetime(2008, 1, 5), end=datetime(2008, 1, 6)))\n        expected = []\n        assert rng == expected",
        "begin_line": 685,
        "end_line": 688,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration.test_precision_finer_than_offset#690",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration.test_precision_finer_than_offset(self)",
        "snippet": "    def test_precision_finer_than_offset(self):\n        # GH#9907\n        result1 = pd.date_range(\n            start=\"2015-04-15 00:00:03\", end=\"2016-04-22 00:00:00\", freq=\"Q\"\n        )\n        result2 = pd.date_range(\n            start=\"2015-04-15 00:00:03\", end=\"2015-06-22 00:00:04\", freq=\"W\"\n        )\n        expected1_list = [\n            \"2015-06-30 00:00:03\",\n            \"2015-09-30 00:00:03\",\n            \"2015-12-31 00:00:03\",\n            \"2016-03-31 00:00:03\",\n        ]\n        expected2_list = [\n            \"2015-04-19 00:00:03\",\n            \"2015-04-26 00:00:03\",\n            \"2015-05-03 00:00:03\",\n            \"2015-05-10 00:00:03\",\n            \"2015-05-17 00:00:03\",\n            \"2015-05-24 00:00:03\",\n            \"2015-05-31 00:00:03\",\n            \"2015-06-07 00:00:03\",\n            \"2015-06-14 00:00:03\",\n            \"2015-06-21 00:00:03\",\n        ]\n        expected1 = DatetimeIndex(\n            expected1_list, dtype=\"datetime64[ns]\", freq=\"Q-DEC\", tz=None\n        )\n        expected2 = DatetimeIndex(\n            expected2_list, dtype=\"datetime64[ns]\", freq=\"W-SUN\", tz=None\n        )\n        tm.assert_index_equal(result1, expected1)\n        tm.assert_index_equal(result2, expected2)",
        "begin_line": 690,
        "end_line": 723,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration.test_mismatching_tz_raises_err#737",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestGenRangeGeneration.test_mismatching_tz_raises_err(self, start, end)",
        "snippet": "    def test_mismatching_tz_raises_err(self, start, end):\n        # issue 18488\n        with pytest.raises(TypeError):\n            pd.date_range(start, end)\n        with pytest.raises(TypeError):\n            pd.date_range(start, end, freq=BDay())",
        "begin_line": 737,
        "end_line": 742,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange.test_constructor#746",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange.test_constructor(self)",
        "snippet": "    def test_constructor(self):\n        bdate_range(START, END, freq=BDay())\n        bdate_range(START, periods=20, freq=BDay())\n        bdate_range(end=START, periods=20, freq=BDay())\n\n        msg = \"periods must be a number, got B\"\n        with pytest.raises(TypeError, match=msg):\n            date_range(\"2011-1-1\", \"2012-1-1\", \"B\")\n\n        with pytest.raises(TypeError, match=msg):\n            bdate_range(\"2011-1-1\", \"2012-1-1\", \"B\")\n\n        msg = \"freq must be specified for bdate_range; use date_range instead\"\n        with pytest.raises(TypeError, match=msg):\n            bdate_range(START, END, periods=10, freq=None)",
        "begin_line": 746,
        "end_line": 760,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange.test_naive_aware_conflicts#762",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange.test_naive_aware_conflicts(self)",
        "snippet": "    def test_naive_aware_conflicts(self):\n        naive = bdate_range(START, END, freq=BDay(), tz=None)\n        aware = bdate_range(START, END, freq=BDay(), tz=\"Asia/Hong_Kong\")\n\n        msg = \"tz-naive.*tz-aware\"\n        with pytest.raises(TypeError, match=msg):\n            naive.join(aware)\n\n        with pytest.raises(TypeError, match=msg):\n            aware.join(naive)",
        "begin_line": 762,
        "end_line": 771,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange.test_misc#773",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange.test_misc(self)",
        "snippet": "    def test_misc(self):\n        end = datetime(2009, 5, 13)\n        dr = bdate_range(end=end, periods=20)\n        firstDate = end - 19 * BDay()\n\n        assert len(dr) == 20\n        assert dr[0] == firstDate\n        assert dr[-1] == end",
        "begin_line": 773,
        "end_line": 780,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange.test_date_parse_failure#782",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange.test_date_parse_failure(self)",
        "snippet": "    def test_date_parse_failure(self):\n        badly_formed_date = \"2007/100/1\"\n\n        with pytest.raises(ValueError):\n            Timestamp(badly_formed_date)\n\n        with pytest.raises(ValueError):\n            bdate_range(start=badly_formed_date, periods=10)\n\n        with pytest.raises(ValueError):\n            bdate_range(end=badly_formed_date, periods=10)\n\n        with pytest.raises(ValueError):\n            bdate_range(badly_formed_date, badly_formed_date)",
        "begin_line": 782,
        "end_line": 795,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange.test_daterange_bug_456#797",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange.test_daterange_bug_456(self)",
        "snippet": "    def test_daterange_bug_456(self):\n        # GH #456\n        rng1 = bdate_range(\"12/5/2011\", \"12/5/2011\")\n        rng2 = bdate_range(\"12/2/2011\", \"12/5/2011\")\n        rng2._data.freq = BDay()  # TODO: shouldn't this already be set?\n\n        result = rng1.union(rng2)\n        assert isinstance(result, DatetimeIndex)",
        "begin_line": 797,
        "end_line": 804,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange.test_bdays_and_open_boundaries#807",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange.test_bdays_and_open_boundaries(self, closed)",
        "snippet": "    def test_bdays_and_open_boundaries(self, closed):\n        # GH 6673\n        start = \"2018-07-21\"  # Saturday\n        end = \"2018-07-29\"  # Sunday\n        result = pd.date_range(start, end, freq=\"B\", closed=closed)\n\n        bday_start = \"2018-07-23\"  # Monday\n        bday_end = \"2018-07-27\"  # Friday\n        expected = pd.date_range(bday_start, bday_end, freq=\"D\")\n        tm.assert_index_equal(result, expected)",
        "begin_line": 807,
        "end_line": 816,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange.test_bday_near_overflow#818",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange.test_bday_near_overflow(self)",
        "snippet": "    def test_bday_near_overflow(self):\n        # GH#24252 avoid doing unnecessary addition that _would_ overflow\n        start = pd.Timestamp.max.floor(\"D\").to_pydatetime()\n        rng = pd.date_range(start, end=None, periods=1, freq=\"B\")\n        expected = pd.DatetimeIndex([start], freq=\"B\")\n        tm.assert_index_equal(rng, expected)",
        "begin_line": 818,
        "end_line": 823,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange.test_bday_overflow_error#825",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestBusinessDateRange.test_bday_overflow_error(self)",
        "snippet": "    def test_bday_overflow_error(self):\n        # GH#24252 check that we get OutOfBoundsDatetime and not OverflowError\n        start = pd.Timestamp.max.floor(\"D\").to_pydatetime()\n        with pytest.raises(OutOfBoundsDatetime):\n            pd.date_range(start, periods=2, freq=\"B\")",
        "begin_line": 825,
        "end_line": 829,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange.test_constructor#833",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange.test_constructor(self)",
        "snippet": "    def test_constructor(self):\n        bdate_range(START, END, freq=CDay())\n        bdate_range(START, periods=20, freq=CDay())\n        bdate_range(end=START, periods=20, freq=CDay())\n\n        msg = \"periods must be a number, got C\"\n        with pytest.raises(TypeError, match=msg):\n            date_range(\"2011-1-1\", \"2012-1-1\", \"C\")\n\n        with pytest.raises(TypeError, match=msg):\n            bdate_range(\"2011-1-1\", \"2012-1-1\", \"C\")",
        "begin_line": 833,
        "end_line": 843,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange.test_misc#845",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange.test_misc(self)",
        "snippet": "    def test_misc(self):\n        end = datetime(2009, 5, 13)\n        dr = bdate_range(end=end, periods=20, freq=\"C\")\n        firstDate = end - 19 * CDay()\n\n        assert len(dr) == 20\n        assert dr[0] == firstDate\n        assert dr[-1] == end",
        "begin_line": 845,
        "end_line": 852,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange.test_daterange_bug_456#854",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange.test_daterange_bug_456(self)",
        "snippet": "    def test_daterange_bug_456(self):\n        # GH #456\n        rng1 = bdate_range(\"12/5/2011\", \"12/5/2011\", freq=\"C\")\n        rng2 = bdate_range(\"12/2/2011\", \"12/5/2011\", freq=\"C\")\n        rng2._data.freq = CDay()  # TODO: shouldn't this already be set?\n\n        result = rng1.union(rng2)\n        assert isinstance(result, DatetimeIndex)",
        "begin_line": 854,
        "end_line": 861,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange.test_cdaterange#863",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange.test_cdaterange(self)",
        "snippet": "    def test_cdaterange(self):\n        result = bdate_range(\"2013-05-01\", periods=3, freq=\"C\")\n        expected = DatetimeIndex([\"2013-05-01\", \"2013-05-02\", \"2013-05-03\"])\n        tm.assert_index_equal(result, expected)",
        "begin_line": 863,
        "end_line": 866,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange.test_cdaterange_weekmask#868",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange.test_cdaterange_weekmask(self)",
        "snippet": "    def test_cdaterange_weekmask(self):\n        result = bdate_range(\n            \"2013-05-01\", periods=3, freq=\"C\", weekmask=\"Sun Mon Tue Wed Thu\"\n        )\n        expected = DatetimeIndex([\"2013-05-01\", \"2013-05-02\", \"2013-05-05\"])\n        tm.assert_index_equal(result, expected)\n\n        # raise with non-custom freq\n        msg = (\n            \"a custom frequency string is required when holidays or \"\n            \"weekmask are passed, got frequency B\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            bdate_range(\"2013-05-01\", periods=3, weekmask=\"Sun Mon Tue Wed Thu\")",
        "begin_line": 868,
        "end_line": 881,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange.test_cdaterange_holidays#883",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange.test_cdaterange_holidays(self)",
        "snippet": "    def test_cdaterange_holidays(self):\n        result = bdate_range(\"2013-05-01\", periods=3, freq=\"C\", holidays=[\"2013-05-01\"])\n        expected = DatetimeIndex([\"2013-05-02\", \"2013-05-03\", \"2013-05-06\"])\n        tm.assert_index_equal(result, expected)\n\n        # raise with non-custom freq\n        msg = (\n            \"a custom frequency string is required when holidays or \"\n            \"weekmask are passed, got frequency B\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            bdate_range(\"2013-05-01\", periods=3, holidays=[\"2013-05-01\"])",
        "begin_line": 883,
        "end_line": 894,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange.test_cdaterange_weekmask_and_holidays#896",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange.test_cdaterange_weekmask_and_holidays(self)",
        "snippet": "    def test_cdaterange_weekmask_and_holidays(self):\n        result = bdate_range(\n            \"2013-05-01\",\n            periods=3,\n            freq=\"C\",\n            weekmask=\"Sun Mon Tue Wed Thu\",\n            holidays=[\"2013-05-01\"],\n        )\n        expected = DatetimeIndex([\"2013-05-02\", \"2013-05-05\", \"2013-05-06\"])\n        tm.assert_index_equal(result, expected)\n\n        # raise with non-custom freq\n        msg = (\n            \"a custom frequency string is required when holidays or \"\n            \"weekmask are passed, got frequency B\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            bdate_range(\n                \"2013-05-01\",\n                periods=3,\n                weekmask=\"Sun Mon Tue Wed Thu\",\n                holidays=[\"2013-05-01\"],\n            )",
        "begin_line": 896,
        "end_line": 918,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange.test_all_custom_freq#923",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange.test_all_custom_freq(self, freq)",
        "snippet": "    def test_all_custom_freq(self, freq):\n        # should not raise\n        bdate_range(\n            START, END, freq=freq, weekmask=\"Mon Wed Fri\", holidays=[\"2009-03-14\"]\n        )\n\n        bad_freq = freq + \"FOO\"\n        msg = \"invalid custom frequency string: {freq}\"\n        with pytest.raises(ValueError, match=msg.format(freq=bad_freq)):\n            bdate_range(START, END, freq=bad_freq)",
        "begin_line": 923,
        "end_line": 932,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange.test_range_with_millisecond_resolution#942",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.TestCustomDateRange.test_range_with_millisecond_resolution(self, start_end)",
        "snippet": "    def test_range_with_millisecond_resolution(self, start_end):\n        # https://github.com/pandas-dev/pandas/issues/24110\n        start, end = start_end\n        result = pd.date_range(start=start, end=end, periods=2, closed=\"left\")\n        expected = DatetimeIndex([start])\n        tm.assert_index_equal(result, expected)",
        "begin_line": 942,
        "end_line": 947,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_date_range.test_date_range_with_custom_holidays#950",
        "src_path": "pandas/tests/indexes/datetimes/test_date_range.py",
        "class_name": "pandas.tests.indexes.datetimes.test_date_range",
        "signature": "pandas.tests.indexes.datetimes.test_date_range.test_date_range_with_custom_holidays()",
        "snippet": "def test_date_range_with_custom_holidays():\n    # GH 30593\n    freq = pd.offsets.CustomBusinessHour(start=\"15:00\", holidays=[\"2020-11-26\"])\n    result = pd.date_range(start=\"2020-11-25 15:00\", periods=4, freq=freq)\n    expected = pd.DatetimeIndex(\n        [\n            \"2020-11-25 15:00:00\",\n            \"2020-11-25 16:00:00\",\n            \"2020-11-27 15:00:00\",\n            \"2020-11-27 16:00:00\",\n        ],\n        freq=freq,\n    )\n    tm.assert_index_equal(result, expected)",
        "begin_line": 950,
        "end_line": 963,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.conftest.indices#28",
        "src_path": "pandas/tests/indexes/conftest.py",
        "class_name": "pandas.tests.indexes.conftest",
        "signature": "pandas.tests.indexes.conftest.indices(request)",
        "snippet": "def indices(request):\n    # copy to avoid mutation, e.g. setting .name\n    return indices_dict[request.param].copy()",
        "begin_line": 28,
        "end_line": 30,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_pickle_compat_construction#37",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_pickle_compat_construction(self)",
        "snippet": "    def test_pickle_compat_construction(self):\n        # need an object to create with\n        msg = (\n            r\"Index\\(\\.\\.\\.\\) must be called with a collection of some\"\n            r\" kind, None was passed|\"\n            r\"__new__\\(\\) missing 1 required positional argument: 'data'|\"\n            r\"__new__\\(\\) takes at least 2 arguments \\(1 given\\)\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            self._holder()",
        "begin_line": 37,
        "end_line": 46,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_series#48",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_series(self)",
        "snippet": "    def test_to_series(self):\n        # assert that we are creating a copy of the index\n\n        idx = self.create_index()\n        s = idx.to_series()\n        assert s.values is not idx.values\n        assert s.index is not idx\n        assert s.name == idx.name",
        "begin_line": 48,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_series_with_arguments#57",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_series_with_arguments(self)",
        "snippet": "    def test_to_series_with_arguments(self):\n        # GH18699\n\n        # index kwarg\n        idx = self.create_index()\n        s = idx.to_series(index=idx)\n\n        assert s.values is not idx.values\n        assert s.index is idx\n        assert s.name == idx.name\n\n        # name kwarg\n        idx = self.create_index()\n        s = idx.to_series(name=\"__test\")\n\n        assert s.values is not idx.values\n        assert s.index is not idx\n        assert s.name != idx.name",
        "begin_line": 57,
        "end_line": 74,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_frame#77",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_frame(self, name)",
        "snippet": "    def test_to_frame(self, name):\n        # see GH-15230, GH-22580\n        idx = self.create_index()\n\n        if name:\n            idx_name = name\n        else:\n            idx_name = idx.name or 0\n\n        df = idx.to_frame(name=idx_name)\n\n        assert df.index is idx\n        assert len(df.columns) == 1\n        assert df.columns[0] == idx_name\n        assert df[idx_name].values is not idx.values\n\n        df = idx.to_frame(index=False, name=idx_name)\n        assert df.index is not idx",
        "begin_line": 77,
        "end_line": 94,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_shift#96",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_shift(self)",
        "snippet": "    def test_shift(self):\n\n        # GH8083 test the base class for shift\n        idx = self.create_index()\n        msg = \"Not supported for type {}\".format(type(idx).__name__)\n        with pytest.raises(NotImplementedError, match=msg):\n            idx.shift(1)\n        with pytest.raises(NotImplementedError, match=msg):\n            idx.shift(1, 2)",
        "begin_line": 96,
        "end_line": 104,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_constructor_name_unhashable#106",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_constructor_name_unhashable(self)",
        "snippet": "    def test_constructor_name_unhashable(self):\n        # GH#29069 check that name is hashable\n        # See also same-named test in tests.series.test_constructors\n        idx = self.create_index()\n        with pytest.raises(TypeError, match=\"Index.name must be a hashable type\"):\n            type(idx)(idx, name=[])",
        "begin_line": 106,
        "end_line": 111,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_create_index_existing_name#113",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_create_index_existing_name(self)",
        "snippet": "    def test_create_index_existing_name(self):\n\n        # GH11193, when an existing index is passed, and a new name is not\n        # specified, the new index should inherit the previous object name\n        expected = self.create_index()\n        if not isinstance(expected, MultiIndex):\n            expected.name = \"foo\"\n            result = pd.Index(expected)\n            tm.assert_index_equal(result, expected)\n\n            result = pd.Index(expected, name=\"bar\")\n            expected.name = \"bar\"\n            tm.assert_index_equal(result, expected)\n        else:\n            expected.names = [\"foo\", \"bar\"]\n            result = pd.Index(expected)\n            tm.assert_index_equal(\n                result,\n                Index(\n                    Index(\n                        [\n                            (\"foo\", \"one\"),\n                            (\"foo\", \"two\"),\n                            (\"bar\", \"one\"),\n                            (\"baz\", \"two\"),\n                            (\"qux\", \"one\"),\n                            (\"qux\", \"two\"),\n                        ],\n                        dtype=\"object\",\n                    ),\n                    names=[\"foo\", \"bar\"],\n                ),\n            )\n\n            result = pd.Index(expected, names=[\"A\", \"B\"])\n            tm.assert_index_equal(\n                result,\n                Index(\n                    Index(\n                        [\n                            (\"foo\", \"one\"),\n                            (\"foo\", \"two\"),\n                            (\"bar\", \"one\"),\n                            (\"baz\", \"two\"),\n                            (\"qux\", \"one\"),\n                            (\"qux\", \"two\"),\n                        ],\n                        dtype=\"object\",\n                    ),\n                    names=[\"A\", \"B\"],\n                ),\n            )",
        "begin_line": 113,
        "end_line": 164,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numeric_compat#166",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numeric_compat(self)",
        "snippet": "    def test_numeric_compat(self):\n\n        idx = self.create_index()\n        with pytest.raises(TypeError, match=\"cannot perform __mul__\"):\n            idx * 1\n        with pytest.raises(TypeError, match=\"cannot perform __rmul__\"):\n            1 * idx\n\n        div_err = \"cannot perform __truediv__\"\n        with pytest.raises(TypeError, match=div_err):\n            idx / 1\n\n        div_err = div_err.replace(\" __\", \" __r\")\n        with pytest.raises(TypeError, match=div_err):\n            1 / idx\n        with pytest.raises(TypeError, match=\"cannot perform __floordiv__\"):\n            idx // 1\n        with pytest.raises(TypeError, match=\"cannot perform __rfloordiv__\"):\n            1 // idx",
        "begin_line": 166,
        "end_line": 184,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_logical_compat#186",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_logical_compat(self)",
        "snippet": "    def test_logical_compat(self):\n        idx = self.create_index()\n        with pytest.raises(TypeError, match=\"cannot perform all\"):\n            idx.all()\n        with pytest.raises(TypeError, match=\"cannot perform any\"):\n            idx.any()",
        "begin_line": 186,
        "end_line": 191,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_boolean_context_compat#193",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_boolean_context_compat(self)",
        "snippet": "    def test_boolean_context_compat(self):\n\n        # boolean context compat\n        idx = self.create_index()\n\n        with pytest.raises(ValueError, match=\"The truth value of a\"):\n            if idx:\n                pass",
        "begin_line": 193,
        "end_line": 200,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_reindex_base#202",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_reindex_base(self)",
        "snippet": "    def test_reindex_base(self):\n        idx = self.create_index()\n        expected = np.arange(idx.size, dtype=np.intp)\n\n        actual = idx.get_indexer(idx)\n        tm.assert_numpy_array_equal(expected, actual)\n\n        with pytest.raises(ValueError, match=\"Invalid fill method\"):\n            idx.get_indexer(idx, method=\"invalid\")",
        "begin_line": 202,
        "end_line": 210,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_get_indexer_consistency#212",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_get_indexer_consistency(self, indices)",
        "snippet": "    def test_get_indexer_consistency(self, indices):\n        # See GH 16819\n        if isinstance(indices, IntervalIndex):\n            return\n\n        if indices.is_unique or isinstance(indices, CategoricalIndex):\n            indexer = indices.get_indexer(indices[0:2])\n            assert isinstance(indexer, np.ndarray)\n            assert indexer.dtype == np.intp\n        else:\n            e = \"Reindexing only valid with uniquely valued Index objects\"\n            with pytest.raises(InvalidIndexError, match=e):\n                indices.get_indexer(indices[0:2])\n\n        indexer, _ = indices.get_indexer_non_unique(indices[0:2])\n        assert isinstance(indexer, np.ndarray)\n        assert indexer.dtype == np.intp",
        "begin_line": 212,
        "end_line": 228,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_ndarray_compat_properties#230",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_ndarray_compat_properties(self)",
        "snippet": "    def test_ndarray_compat_properties(self):\n        idx = self.create_index()\n        assert idx.T.equals(idx)\n        assert idx.transpose().equals(idx)\n\n        values = idx.values\n        for prop in self._compat_props:\n            assert getattr(idx, prop) == getattr(values, prop)\n\n        # test for validity\n        idx.nbytes\n        idx.values.nbytes",
        "begin_line": 230,
        "end_line": 241,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repr_roundtrip#243",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repr_roundtrip(self)",
        "snippet": "    def test_repr_roundtrip(self):\n\n        idx = self.create_index()\n        tm.assert_index_equal(eval(repr(idx)), idx)",
        "begin_line": 243,
        "end_line": 246,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_str#248",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_str(self)",
        "snippet": "    def test_str(self):\n\n        # test the string repr\n        idx = self.create_index()\n        idx.name = \"foo\"\n        assert \"'foo'\" in str(idx)\n        assert type(idx).__name__ in str(idx)",
        "begin_line": 248,
        "end_line": 254,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repr_max_seq_item_setting#256",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repr_max_seq_item_setting(self)",
        "snippet": "    def test_repr_max_seq_item_setting(self):\n        # GH10182\n        idx = self.create_index()\n        idx = idx.repeat(50)\n        with pd.option_context(\"display.max_seq_items\", None):\n            repr(idx)\n            assert \"...\" not in str(idx)",
        "begin_line": 256,
        "end_line": 262,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_copy_name#264",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_copy_name(self, indices)",
        "snippet": "    def test_copy_name(self, indices):\n        # gh-12309: Check that the \"name\" argument\n        # passed at initialization is honored.\n        if isinstance(indices, MultiIndex):\n            return\n\n        first = type(indices)(indices, copy=True, name=\"mario\")\n        second = type(first)(first, copy=False)\n\n        # Even though \"copy=False\", we want a new object.\n        assert first is not second\n\n        # Not using tm.assert_index_equal() since names differ.\n        assert indices.equals(first)\n\n        assert first.name == \"mario\"\n        assert second.name == \"mario\"\n\n        s1 = Series(2, index=first)\n        s2 = Series(3, index=second[:-1])\n\n        if not isinstance(indices, CategoricalIndex):\n            # See gh-13365\n            s3 = s1 * s2\n            assert s3.index.name == \"mario\"",
        "begin_line": 264,
        "end_line": 288,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_ensure_copied_data#290",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_ensure_copied_data(self, indices)",
        "snippet": "    def test_ensure_copied_data(self, indices):\n        # Check the \"copy\" argument of each Index.__new__ is honoured\n        # GH12309\n        init_kwargs = {}\n        if isinstance(indices, PeriodIndex):\n            # Needs \"freq\" specification:\n            init_kwargs[\"freq\"] = indices.freq\n        elif isinstance(indices, (RangeIndex, MultiIndex, CategoricalIndex)):\n            # RangeIndex cannot be initialized from data\n            # MultiIndex and CategoricalIndex are tested separately\n            return\n\n        index_type = type(indices)\n        result = index_type(indices.values, copy=True, **init_kwargs)\n        tm.assert_index_equal(indices, result)\n        tm.assert_numpy_array_equal(\n            indices._ndarray_values, result._ndarray_values, check_same=\"copy\"\n        )\n\n        if isinstance(indices, PeriodIndex):\n            # .values an object array of Period, thus copied\n            result = index_type(ordinal=indices.asi8, copy=False, **init_kwargs)\n            tm.assert_numpy_array_equal(\n                indices._ndarray_values, result._ndarray_values, check_same=\"same\"\n            )\n        elif isinstance(indices, IntervalIndex):\n            # checked in test_interval.py\n            pass\n        else:\n            result = index_type(indices.values, copy=False, **init_kwargs)\n            tm.assert_numpy_array_equal(\n                indices.values, result.values, check_same=\"same\"\n            )\n            tm.assert_numpy_array_equal(\n                indices._ndarray_values, result._ndarray_values, check_same=\"same\"\n            )",
        "begin_line": 290,
        "end_line": 325,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_memory_usage#327",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_memory_usage(self, indices)",
        "snippet": "    def test_memory_usage(self, indices):\n        indices._engine.clear_mapping()\n        result = indices.memory_usage()\n        if indices.empty:\n            # we report 0 for no-length\n            assert result == 0\n            return\n\n        # non-zero length\n        indices.get_loc(indices[0])\n        result2 = indices.memory_usage()\n        result3 = indices.memory_usage(deep=True)\n\n        # RangeIndex, IntervalIndex\n        # don't have engines\n        if not isinstance(indices, (RangeIndex, IntervalIndex)):\n            assert result2 > result\n\n        if indices.inferred_type == \"object\":\n            assert result3 > result2",
        "begin_line": 327,
        "end_line": 346,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_argsort#348",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_argsort(self, request, indices)",
        "snippet": "    def test_argsort(self, request, indices):\n        # separately tested\n        if isinstance(indices, CategoricalIndex):\n            return\n\n        result = indices.argsort()\n        expected = np.array(indices).argsort()\n        tm.assert_numpy_array_equal(result, expected, check_dtype=False)",
        "begin_line": 348,
        "end_line": 355,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numpy_argsort#357",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numpy_argsort(self, indices)",
        "snippet": "    def test_numpy_argsort(self, indices):\n        result = np.argsort(indices)\n        expected = indices.argsort()\n        tm.assert_numpy_array_equal(result, expected)\n\n        # these are the only two types that perform\n        # pandas compatibility input validation - the\n        # rest already perform separate (or no) such\n        # validation via their 'values' attribute as\n        # defined in pandas.core.indexes/base.py - they\n        # cannot be changed at the moment due to\n        # backwards compatibility concerns\n        if isinstance(type(indices), (CategoricalIndex, RangeIndex)):\n            msg = \"the 'axis' parameter is not supported\"\n            with pytest.raises(ValueError, match=msg):\n                np.argsort(indices, axis=1)\n\n            msg = \"the 'kind' parameter is not supported\"\n            with pytest.raises(ValueError, match=msg):\n                np.argsort(indices, kind=\"mergesort\")\n\n            msg = \"the 'order' parameter is not supported\"\n            with pytest.raises(ValueError, match=msg):\n                np.argsort(indices, order=(\"a\", \"b\"))",
        "begin_line": 357,
        "end_line": 380,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_take#382",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_take(self, indices)",
        "snippet": "    def test_take(self, indices):\n        indexer = [4, 3, 0, 2]\n        if len(indices) < 5:\n            # not enough elements; ignore\n            return\n\n        result = indices.take(indexer)\n        expected = indices[indexer]\n        assert result.equals(expected)\n\n        if not isinstance(indices, (DatetimeIndex, PeriodIndex, TimedeltaIndex)):\n            # GH 10791\n            with pytest.raises(AttributeError):\n                indices.freq",
        "begin_line": 382,
        "end_line": 395,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_take_invalid_kwargs#397",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_take_invalid_kwargs(self)",
        "snippet": "    def test_take_invalid_kwargs(self):\n        idx = self.create_index()\n        indices = [1, 2]\n\n        msg = r\"take\\(\\) got an unexpected keyword argument 'foo'\"\n        with pytest.raises(TypeError, match=msg):\n            idx.take(indices, foo=2)\n\n        msg = \"the 'out' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            idx.take(indices, out=indices)\n\n        msg = \"the 'mode' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            idx.take(indices, mode=\"clip\")",
        "begin_line": 397,
        "end_line": 411,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repeat#413",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repeat(self)",
        "snippet": "    def test_repeat(self):\n        rep = 2\n        i = self.create_index()\n        expected = pd.Index(i.values.repeat(rep), name=i.name)\n        tm.assert_index_equal(i.repeat(rep), expected)\n\n        i = self.create_index()\n        rep = np.arange(len(i))\n        expected = pd.Index(i.values.repeat(rep), name=i.name)\n        tm.assert_index_equal(i.repeat(rep), expected)",
        "begin_line": 413,
        "end_line": 422,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numpy_repeat#424",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numpy_repeat(self)",
        "snippet": "    def test_numpy_repeat(self):\n        rep = 2\n        i = self.create_index()\n        expected = i.repeat(rep)\n        tm.assert_index_equal(np.repeat(i, rep), expected)\n\n        msg = \"the 'axis' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            np.repeat(i, rep, axis=0)",
        "begin_line": 424,
        "end_line": 432,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_where#435",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_where(self, klass)",
        "snippet": "    def test_where(self, klass):\n        i = self.create_index()\n\n        cond = [True] * len(i)\n        result = i.where(klass(cond))\n        expected = i\n        tm.assert_index_equal(result, expected)\n\n        cond = [False] + [True] * len(i[1:])\n        expected = pd.Index([i._na_value] + i[1:].tolist(), dtype=i.dtype)\n        result = i.where(klass(cond))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 435,
        "end_line": 446,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_set_ops_error_cases#452",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_set_ops_error_cases(self, case, method, indices)",
        "snippet": "    def test_set_ops_error_cases(self, case, method, indices):\n        # non-iterable input\n        msg = \"Input must be Index or array-like\"\n        with pytest.raises(TypeError, match=msg):\n            getattr(indices, method)(case)",
        "begin_line": 452,
        "end_line": 456,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_intersection_base#458",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_intersection_base(self, indices)",
        "snippet": "    def test_intersection_base(self, indices):\n        if isinstance(indices, CategoricalIndex):\n            return\n\n        first = indices[:5]\n        second = indices[:3]\n        intersect = first.intersection(second)\n        assert tm.equalContents(intersect, second)\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            result = first.intersection(case)\n            assert tm.equalContents(result, second)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.intersection([1, 2, 3])",
        "begin_line": 458,
        "end_line": 476,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_union_base#478",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_union_base(self, indices)",
        "snippet": "    def test_union_base(self, indices):\n        first = indices[3:]\n        second = indices[:5]\n        everything = indices\n        union = first.union(second)\n        assert tm.equalContents(union, everything)\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            if not isinstance(indices, CategoricalIndex):\n                result = first.union(case)\n                assert tm.equalContents(result, everything)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.union([1, 2, 3])",
        "begin_line": 478,
        "end_line": 495,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_difference_base#498",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_difference_base(self, sort, indices)",
        "snippet": "    def test_difference_base(self, sort, indices):\n        if isinstance(indices, CategoricalIndex):\n            return\n\n        first = indices[2:]\n        second = indices[:4]\n        answer = indices[4:]\n        result = first.difference(second, sort)\n        assert tm.equalContents(result, answer)\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            if isinstance(indices, (DatetimeIndex, TimedeltaIndex)):\n                assert type(result) == type(answer)\n                tm.assert_numpy_array_equal(\n                    result.sort_values().asi8, answer.sort_values().asi8\n                )\n            else:\n                result = first.difference(case, sort)\n                assert tm.equalContents(result, answer)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.difference([1, 2, 3], sort)",
        "begin_line": 498,
        "end_line": 523,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_symmetric_difference#525",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_symmetric_difference(self, indices)",
        "snippet": "    def test_symmetric_difference(self, indices):\n        if isinstance(indices, CategoricalIndex):\n            return\n\n        first = indices[1:]\n        second = indices[:-1]\n        answer = indices[[0, -1]]\n        result = first.symmetric_difference(second)\n        assert tm.equalContents(result, answer)\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            result = first.symmetric_difference(case)\n            assert tm.equalContents(result, answer)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.symmetric_difference([1, 2, 3])",
        "begin_line": 525,
        "end_line": 544,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_insert_base#546",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_insert_base(self, indices)",
        "snippet": "    def test_insert_base(self, indices):\n        result = indices[1:4]\n\n        if not len(indices):\n            return\n\n        # test 0th element\n        assert indices[0:4].equals(result.insert(0, indices[0]))",
        "begin_line": 546,
        "end_line": 553,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_delete_base#555",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_delete_base(self, indices)",
        "snippet": "    def test_delete_base(self, indices):\n        if not len(indices):\n            return\n\n        if isinstance(indices, RangeIndex):\n            # tested in class\n            return\n\n        expected = indices[1:]\n        result = indices.delete(0)\n        assert result.equals(expected)\n        assert result.name == expected.name\n\n        expected = indices[:-1]\n        result = indices.delete(-1)\n        assert result.equals(expected)\n        assert result.name == expected.name\n\n        with pytest.raises((IndexError, ValueError)):\n            # either depending on numpy version\n            indices.delete(len(indices))",
        "begin_line": 555,
        "end_line": 575,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_equals#577",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_equals(self, indices)",
        "snippet": "    def test_equals(self, indices):\n        if isinstance(indices, IntervalIndex):\n            # IntervalIndex tested separately\n            return\n\n        assert indices.equals(indices)\n        assert indices.equals(indices.copy())\n        assert indices.equals(indices.astype(object))\n\n        assert not indices.equals(list(indices))\n        assert not indices.equals(np.array(indices))\n\n        # Cannot pass in non-int64 dtype to RangeIndex\n        if not isinstance(indices, RangeIndex):\n            same_values = Index(indices, dtype=object)\n            assert indices.equals(same_values)\n            assert same_values.equals(indices)\n\n        if indices.nlevels == 1:\n            # do not test MultiIndex\n            assert not indices.equals(Series(indices))",
        "begin_line": 577,
        "end_line": 597,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_equals_op#599",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_equals_op(self)",
        "snippet": "    def test_equals_op(self):\n        # GH9947, GH10637\n        index_a = self.create_index()\n        if isinstance(index_a, PeriodIndex):\n            pytest.skip(\"Skip check for PeriodIndex\")\n\n        n = len(index_a)\n        index_b = index_a[0:-1]\n        index_c = index_a[0:-1].append(index_a[-2:-1])\n        index_d = index_a[0:1]\n\n        msg = \"Lengths must match|could not be broadcast\"\n        with pytest.raises(ValueError, match=msg):\n            index_a == index_b\n        expected1 = np.array([True] * n)\n        expected2 = np.array([True] * (n - 1) + [False])\n        tm.assert_numpy_array_equal(index_a == index_a, expected1)\n        tm.assert_numpy_array_equal(index_a == index_c, expected2)\n\n        # test comparisons with numpy arrays\n        array_a = np.array(index_a)\n        array_b = np.array(index_a[0:-1])\n        array_c = np.array(index_a[0:-1].append(index_a[-2:-1]))\n        array_d = np.array(index_a[0:1])\n        with pytest.raises(ValueError, match=msg):\n            index_a == array_b\n        tm.assert_numpy_array_equal(index_a == array_a, expected1)\n        tm.assert_numpy_array_equal(index_a == array_c, expected2)\n\n        # test comparisons with Series\n        series_a = Series(array_a)\n        series_b = Series(array_b)\n        series_c = Series(array_c)\n        series_d = Series(array_d)\n        with pytest.raises(ValueError, match=msg):\n            index_a == series_b\n\n        tm.assert_numpy_array_equal(index_a == series_a, expected1)\n        tm.assert_numpy_array_equal(index_a == series_c, expected2)\n\n        # cases where length is 1 for one of them\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == index_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == series_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == array_d\n        msg = \"Can only compare identically-labeled Series objects\"\n        with pytest.raises(ValueError, match=msg):\n            series_a == series_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            series_a == array_d\n\n        # comparing with a scalar should broadcast; note that we are excluding\n        # MultiIndex because in this case each item in the index is a tuple of\n        # length 2, and therefore is considered an array of length 2 in the\n        # comparison instead of a scalar\n        if not isinstance(index_a, MultiIndex):\n            expected3 = np.array([False] * (len(index_a) - 2) + [True, False])\n            # assuming the 2nd to last item is unique in the data\n            item = index_a[-2]\n            tm.assert_numpy_array_equal(index_a == item, expected3)\n            tm.assert_series_equal(series_a == item, Series(expected3))",
        "begin_line": 599,
        "end_line": 661,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_hasnans_isnans#663",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_hasnans_isnans(self, indices)",
        "snippet": "    def test_hasnans_isnans(self, indices):\n        # GH 11343, added tests for hasnans / isnans\n        if isinstance(indices, MultiIndex):\n            return\n\n        # cases in indices doesn't include NaN\n        idx = indices.copy(deep=True)\n        expected = np.array([False] * len(idx), dtype=bool)\n        tm.assert_numpy_array_equal(idx._isnan, expected)\n        assert idx.hasnans is False\n\n        idx = indices.copy(deep=True)\n        values = np.asarray(idx.values)\n\n        if len(indices) == 0:\n            return\n        elif isinstance(indices, DatetimeIndexOpsMixin):\n            values[1] = iNaT\n        elif isinstance(indices, (Int64Index, UInt64Index)):\n            return\n        else:\n            values[1] = np.nan\n\n        if isinstance(indices, PeriodIndex):\n            idx = type(indices)(values, freq=indices.freq)\n        else:\n            idx = type(indices)(values)\n\n            expected = np.array([False] * len(idx), dtype=bool)\n            expected[1] = True\n            tm.assert_numpy_array_equal(idx._isnan, expected)\n            assert idx.hasnans is True",
        "begin_line": 663,
        "end_line": 694,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_fillna#696",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_fillna(self, indices)",
        "snippet": "    def test_fillna(self, indices):\n        # GH 11343\n        if len(indices) == 0:\n            pass\n        elif isinstance(indices, MultiIndex):\n            idx = indices.copy(deep=True)\n            msg = \"isna is not defined for MultiIndex\"\n            with pytest.raises(NotImplementedError, match=msg):\n                idx.fillna(idx[0])\n        else:\n            idx = indices.copy(deep=True)\n            result = idx.fillna(idx[0])\n            tm.assert_index_equal(result, idx)\n            assert result is not idx\n\n            msg = \"'value' must be a scalar, passed: \"\n            with pytest.raises(TypeError, match=msg):\n                idx.fillna([idx[0]])\n\n            idx = indices.copy(deep=True)\n            values = np.asarray(idx.values)\n\n            if isinstance(indices, DatetimeIndexOpsMixin):\n                values[1] = iNaT\n            elif isinstance(indices, (Int64Index, UInt64Index)):\n                return\n            else:\n                values[1] = np.nan\n\n            if isinstance(indices, PeriodIndex):\n                idx = type(indices)(values, freq=indices.freq)\n            else:\n                idx = type(indices)(values)\n\n            expected = np.array([False] * len(idx), dtype=bool)\n            expected[1] = True\n            tm.assert_numpy_array_equal(idx._isnan, expected)\n            assert idx.hasnans is True",
        "begin_line": 696,
        "end_line": 733,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_nulls#735",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_nulls(self, indices)",
        "snippet": "    def test_nulls(self, indices):\n        # this is really a smoke test for the methods\n        # as these are adequately tested for function elsewhere\n        if len(indices) == 0:\n            tm.assert_numpy_array_equal(indices.isna(), np.array([], dtype=bool))\n        elif isinstance(indices, MultiIndex):\n            idx = indices.copy()\n            msg = \"isna is not defined for MultiIndex\"\n            with pytest.raises(NotImplementedError, match=msg):\n                idx.isna()\n        elif not indices.hasnans:\n            tm.assert_numpy_array_equal(\n                indices.isna(), np.zeros(len(indices), dtype=bool)\n            )\n            tm.assert_numpy_array_equal(\n                indices.notna(), np.ones(len(indices), dtype=bool)\n            )\n        else:\n            result = isna(indices)\n            tm.assert_numpy_array_equal(indices.isna(), result)\n            tm.assert_numpy_array_equal(indices.notna(), ~result)",
        "begin_line": 735,
        "end_line": 755,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_empty#757",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_empty(self)",
        "snippet": "    def test_empty(self):\n        # GH 15270\n        index = self.create_index()\n        assert not index.empty\n        assert index[:0].empty",
        "begin_line": 757,
        "end_line": 761,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_join_self_unique#763",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_join_self_unique(self, join_type)",
        "snippet": "    def test_join_self_unique(self, join_type):\n        index = self.create_index()\n        if index.is_unique:\n            joined = index.join(index, how=join_type)\n            assert (index == joined).all()",
        "begin_line": 763,
        "end_line": 767,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_map#769",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_map(self)",
        "snippet": "    def test_map(self):\n        # callable\n        index = self.create_index()\n\n        # we don't infer UInt64\n        if isinstance(index, pd.UInt64Index):\n            expected = index.astype(\"int64\")\n        else:\n            expected = index\n\n        result = index.map(lambda x: x)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 769,
        "end_line": 780,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_map_dictlike#789",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_map_dictlike(self, mapper)",
        "snippet": "    def test_map_dictlike(self, mapper):\n\n        index = self.create_index()\n        if isinstance(index, (pd.CategoricalIndex, pd.IntervalIndex)):\n            pytest.skip(\"skipping tests for {}\".format(type(index)))\n\n        identity = mapper(index.values, index)\n\n        # we don't infer to UInt64 for a dict\n        if isinstance(index, pd.UInt64Index) and isinstance(identity, dict):\n            expected = index.astype(\"int64\")\n        else:\n            expected = index\n\n        result = index.map(identity)\n        tm.assert_index_equal(result, expected)\n\n        # empty mappable\n        expected = pd.Index([np.nan] * len(index))\n        result = index.map(mapper(expected, index))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 789,
        "end_line": 809,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_putmask_with_wrong_mask#811",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_putmask_with_wrong_mask(self)",
        "snippet": "    def test_putmask_with_wrong_mask(self):\n        # GH18368\n        index = self.create_index()\n\n        with pytest.raises(ValueError):\n            index.putmask(np.ones(len(index) + 1, np.bool), 1)\n\n        with pytest.raises(ValueError):\n            index.putmask(np.ones(len(index) - 1, np.bool), 1)\n\n        with pytest.raises(ValueError):\n            index.putmask(\"foo\", 1)",
        "begin_line": 811,
        "end_line": 822,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_astype_category#827",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_astype_category(self, copy, name, ordered)",
        "snippet": "    def test_astype_category(self, copy, name, ordered):\n        # GH 18630\n        index = self.create_index()\n        if name:\n            index = index.rename(name)\n\n        # standard categories\n        dtype = CategoricalDtype(ordered=ordered)\n        result = index.astype(dtype, copy=copy)\n        expected = CategoricalIndex(index.values, name=name, ordered=ordered)\n        tm.assert_index_equal(result, expected)\n\n        # non-standard categories\n        dtype = CategoricalDtype(index.unique().tolist()[:-1], ordered)\n        result = index.astype(dtype, copy=copy)\n        expected = CategoricalIndex(index.values, name=name, dtype=dtype)\n        tm.assert_index_equal(result, expected)\n\n        if ordered is False:\n            # dtype='category' defaults to ordered=False, so only test once\n            result = index.astype(\"category\", copy=copy)\n            expected = CategoricalIndex(index.values, name=name)\n            tm.assert_index_equal(result, expected)",
        "begin_line": 827,
        "end_line": 849,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_is_unique#851",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_is_unique(self)",
        "snippet": "    def test_is_unique(self):\n        # initialize a unique index\n        index = self.create_index().drop_duplicates()\n        assert index.is_unique is True\n\n        # empty index should be unique\n        index_empty = index[:0]\n        assert index_empty.is_unique is True\n\n        # test basic dupes\n        index_dup = index.insert(0, index[0])\n        assert index_dup.is_unique is False\n\n        # single NA should be unique\n        index_na = index.insert(0, np.nan)\n        assert index_na.is_unique is True\n\n        # multiple NA should not be unique\n        index_na_dup = index_na.insert(0, np.nan)\n        assert index_na_dup.is_unique is False",
        "begin_line": 851,
        "end_line": 870,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_engine_reference_cycle#872",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_engine_reference_cycle(self)",
        "snippet": "    def test_engine_reference_cycle(self):\n        # GH27585\n        index = self.create_index()\n        nrefs_pre = len(gc.get_referrers(index))\n        index._engine\n        assert len(gc.get_referrers(index)) == nrefs_pre",
        "begin_line": 872,
        "end_line": 877,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.idx#9",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.idx()",
        "snippet": "def idx():\n    # a MultiIndex used to test the general functionality of the\n    # general functionality of this object\n    major_axis = Index([\"foo\", \"bar\", \"baz\", \"qux\"])\n    minor_axis = Index([\"one\", \"two\"])\n\n    major_codes = np.array([0, 0, 1, 2, 3, 3])\n    minor_codes = np.array([0, 1, 0, 1, 0, 1])\n    index_names = [\"first\", \"second\"]\n    mi = MultiIndex(\n        levels=[major_axis, minor_axis],\n        codes=[major_codes, minor_codes],\n        names=index_names,\n        verify_integrity=False,\n    )\n    return mi",
        "begin_line": 9,
        "end_line": 24,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.idx_dup#28",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.idx_dup()",
        "snippet": "def idx_dup():\n    # compare tests/indexes/multi/conftest.py\n    major_axis = Index([\"foo\", \"bar\", \"baz\", \"qux\"])\n    minor_axis = Index([\"one\", \"two\"])\n\n    major_codes = np.array([0, 0, 1, 0, 1, 1])\n    minor_codes = np.array([0, 1, 0, 1, 0, 1])\n    index_names = [\"first\", \"second\"]\n    mi = MultiIndex(\n        levels=[major_axis, minor_axis],\n        codes=[major_codes, minor_codes],\n        names=index_names,\n        verify_integrity=False,\n    )\n    return mi",
        "begin_line": 28,
        "end_line": 42,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.index_names#46",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.index_names()",
        "snippet": "def index_names():\n    # names that match those in the idx fixture for testing equality of\n    # names assigned to the idx\n    return [\"first\", \"second\"]",
        "begin_line": 46,
        "end_line": 49,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.holder#53",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.holder()",
        "snippet": "def holder():\n    # the MultiIndex constructor used to base compatibility with pickle\n    return MultiIndex",
        "begin_line": 53,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.compat_props#59",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.compat_props()",
        "snippet": "def compat_props():\n    # a MultiIndex must have these properties associated with it\n    return [\"shape\", \"ndim\", \"size\"]",
        "begin_line": 59,
        "end_line": 61,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.narrow_multi_index#65",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.narrow_multi_index()",
        "snippet": "def narrow_multi_index():\n    \"\"\"\n    Return a MultiIndex that is narrower than the display (<80 characters).\n    \"\"\"\n    n = 1000\n    ci = pd.CategoricalIndex(list(\"a\" * n) + ([\"abc\"] * n))\n    dti = pd.date_range(\"2000-01-01\", freq=\"s\", periods=n * 2)\n    return pd.MultiIndex.from_arrays([ci, ci.codes + 9, dti], names=[\"a\", \"b\", \"dti\"])",
        "begin_line": 65,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.wide_multi_index#76",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.wide_multi_index()",
        "snippet": "def wide_multi_index():\n    \"\"\"\n    Return a MultiIndex that is wider than the display (>80 characters).\n    \"\"\"\n    n = 1000\n    ci = pd.CategoricalIndex(list(\"a\" * n) + ([\"abc\"] * n))\n    dti = pd.date_range(\"2000-01-01\", freq=\"s\", periods=n * 2)\n    levels = [ci, ci.codes + 9, dti, dti, dti]\n    names = [\"a\", \"b\", \"dti_1\", \"dti_2\", \"dti_3\"]\n    return pd.MultiIndex.from_arrays(levels, names=names)",
        "begin_line": 76,
        "end_line": 85,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_argmax_axis_invalid#12",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_argmax_axis_invalid(self)",
        "snippet": "    def test_argmax_axis_invalid(self):\n        # GH#23081\n        rng = self.create_index()\n        with pytest.raises(ValueError):\n            rng.argmax(axis=1)\n        with pytest.raises(ValueError):\n            rng.argmin(axis=2)\n        with pytest.raises(ValueError):\n            rng.min(axis=-2)\n        with pytest.raises(ValueError):\n            rng.max(axis=-3)",
        "begin_line": 12,
        "end_line": 22,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_can_hold_identifiers#24",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_can_hold_identifiers(self)",
        "snippet": "    def test_can_hold_identifiers(self):\n        idx = self.create_index()\n        key = idx[0]\n        assert idx._can_hold_identifiers_and_holds_name(key) is False",
        "begin_line": 24,
        "end_line": 27,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_shift_identity#29",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_shift_identity(self)",
        "snippet": "    def test_shift_identity(self):\n\n        idx = self.create_index()\n        tm.assert_index_equal(idx, idx.shift(0))",
        "begin_line": 29,
        "end_line": 32,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_str#34",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_str(self)",
        "snippet": "    def test_str(self):\n\n        # test the string repr\n        idx = self.create_index()\n        idx.name = \"foo\"\n        assert not \"length={}\".format(len(idx)) in str(idx)\n        assert \"'foo'\" in str(idx)\n        assert type(idx).__name__ in str(idx)\n\n        if hasattr(idx, \"tz\"):\n            if idx.tz is not None:\n                assert idx.tz in str(idx)\n        if hasattr(idx, \"freq\"):\n            assert \"freq='{idx.freqstr}'\".format(idx=idx) in str(idx)",
        "begin_line": 34,
        "end_line": 47,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_view#49",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_view(self)",
        "snippet": "    def test_view(self):\n        i = self.create_index()\n\n        i_view = i.view(\"i8\")\n        result = self._holder(i)\n        tm.assert_index_equal(result, i)\n\n        i_view = i.view(self._holder)\n        result = self._holder(i)\n        tm.assert_index_equal(result, i_view)",
        "begin_line": 49,
        "end_line": 58,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_callable#60",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_callable(self)",
        "snippet": "    def test_map_callable(self):\n        index = self.create_index()\n        expected = index + index.freq\n        result = index.map(lambda x: x + x.freq)\n        tm.assert_index_equal(result, expected)\n\n        # map to NaT\n        result = index.map(lambda x: pd.NaT if x == index[0] else x)\n        expected = pd.Index([pd.NaT] + index[1:].tolist())\n        tm.assert_index_equal(result, expected)",
        "begin_line": 60,
        "end_line": 69,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_dictlike#78",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_dictlike(self, mapper)",
        "snippet": "    def test_map_dictlike(self, mapper):\n        index = self.create_index()\n        expected = index + index.freq\n\n        # don't compare the freqs\n        if isinstance(expected, pd.DatetimeIndex):\n            expected._data.freq = None\n\n        result = index.map(mapper(expected, index))\n        tm.assert_index_equal(result, expected)\n\n        expected = pd.Index([pd.NaT] + index[1:].tolist())\n        result = index.map(mapper(expected, index))\n        tm.assert_index_equal(result, expected)\n\n        # empty map; these map to np.nan because we cannot know\n        # to re-infer things\n        expected = pd.Index([np.nan] * len(index))\n        result = index.map(mapper([], []))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 78,
        "end_line": 97,
        "comment": "",
        "is_bug": false
    }
]