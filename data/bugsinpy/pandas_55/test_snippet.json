[
    {
        "name": "pandas.tests.indexing.multiindex.conftest.multiindex_dataframe_random_data#9",
        "src_path": "pandas/tests/indexing/multiindex/conftest.py",
        "class_name": "pandas.tests.indexing.multiindex.conftest",
        "signature": "pandas.tests.indexing.multiindex.conftest.multiindex_dataframe_random_data()",
        "snippet": "def multiindex_dataframe_random_data():\n    \"\"\"DataFrame with 2 level MultiIndex with random data\"\"\"\n    index = MultiIndex(\n        levels=[[\"foo\", \"bar\", \"baz\", \"qux\"], [\"one\", \"two\", \"three\"]],\n        codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],\n        names=[\"first\", \"second\"],\n    )\n    return DataFrame(\n        np.random.randn(10, 3), index=index, columns=Index([\"A\", \"B\", \"C\"], name=\"exp\")\n    )",
        "begin_line": 9,
        "end_line": 18,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.conftest.multiindex_year_month_day_dataframe_random_data#22",
        "src_path": "pandas/tests/indexing/multiindex/conftest.py",
        "class_name": "pandas.tests.indexing.multiindex.conftest",
        "signature": "pandas.tests.indexing.multiindex.conftest.multiindex_year_month_day_dataframe_random_data()",
        "snippet": "def multiindex_year_month_day_dataframe_random_data():\n    \"\"\"\n    DataFrame with 3 level MultiIndex (year, month, day) covering\n    first 100 business days from 2000-01-01 with random data\n    \"\"\"\n    tdf = tm.makeTimeDataFrame(100)\n    ymd = tdf.groupby([lambda x: x.year, lambda x: x.month, lambda x: x.day]).sum()\n    # use Int64Index, to make sure things work\n    ymd.index.set_levels([lev.astype(\"i8\") for lev in ymd.index.levels], inplace=True)\n    ymd.index.set_names([\"year\", \"month\", \"day\"], inplace=True)\n    return ymd",
        "begin_line": 22,
        "end_line": 32,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc.test_iloc_getitem_int#18",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc.test_iloc_getitem_int(self)",
        "snippet": "    def test_iloc_getitem_int(self):\n        # integer\n        self.check_result(\n            \"iloc\",\n            2,\n            typs=[\"labels\", \"mixed\", \"ts\", \"floats\", \"empty\"],\n            fails=IndexError,\n        )",
        "begin_line": 18,
        "end_line": 25,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc.test_iloc_getitem_neg_int#27",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc.test_iloc_getitem_neg_int(self)",
        "snippet": "    def test_iloc_getitem_neg_int(self):\n        # neg integer\n        self.check_result(\n            \"iloc\",\n            -1,\n            typs=[\"labels\", \"mixed\", \"ts\", \"floats\", \"empty\"],\n            fails=IndexError,\n        )",
        "begin_line": 27,
        "end_line": 34,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc.test_iloc_getitem_list_int#36",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc.test_iloc_getitem_list_int(self)",
        "snippet": "    def test_iloc_getitem_list_int(self):\n        self.check_result(\n            \"iloc\",\n            [0, 1, 2],\n            typs=[\"labels\", \"mixed\", \"ts\", \"floats\", \"empty\"],\n            fails=IndexError,\n        )",
        "begin_line": 36,
        "end_line": 42,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_is_scalar_access#51",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_is_scalar_access(self)",
        "snippet": "    def test_is_scalar_access(self):\n        # GH#32085 index with duplicates doesnt matter for _is_scalar_access\n        index = pd.Index([1, 2, 1])\n        ser = pd.Series(range(3), index=index)\n\n        assert ser.iloc._is_scalar_access((1,))\n\n        df = ser.to_frame()\n        assert df.iloc._is_scalar_access((1, 0,))",
        "begin_line": 51,
        "end_line": 59,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_exceeds_bounds#61",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_exceeds_bounds(self)",
        "snippet": "    def test_iloc_exceeds_bounds(self):\n\n        # GH6296\n        # iloc should allow indexers that exceed the bounds\n        df = DataFrame(np.random.random_sample((20, 5)), columns=list(\"ABCDE\"))\n\n        # lists of positions should raise IndexError!\n        msg = \"positional indexers are out-of-bounds\"\n        with pytest.raises(IndexError, match=msg):\n            df.iloc[:, [0, 1, 2, 3, 4, 5]]\n        with pytest.raises(IndexError, match=msg):\n            df.iloc[[1, 30]]\n        with pytest.raises(IndexError, match=msg):\n            df.iloc[[1, -30]]\n        with pytest.raises(IndexError, match=msg):\n            df.iloc[[100]]\n\n        s = df[\"A\"]\n        with pytest.raises(IndexError, match=msg):\n            s.iloc[[100]]\n        with pytest.raises(IndexError, match=msg):\n            s.iloc[[-100]]\n\n        # still raise on a single indexer\n        msg = \"single positional indexer is out-of-bounds\"\n        with pytest.raises(IndexError, match=msg):\n            df.iloc[30]\n        with pytest.raises(IndexError, match=msg):\n            df.iloc[-30]\n\n        # GH10779\n        # single positive/negative indexer exceeding Series bounds should raise\n        # an IndexError\n        with pytest.raises(IndexError, match=msg):\n            s.iloc[30]\n        with pytest.raises(IndexError, match=msg):\n            s.iloc[-30]\n\n        # slices are ok\n        result = df.iloc[:, 4:10]  # 0 < start < len < stop\n        expected = df.iloc[:, 4:]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[:, -4:-10]  # stop < 0 < start < len\n        expected = df.iloc[:, :0]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[:, 10:4:-1]  # 0 < stop < len < start (down)\n        expected = df.iloc[:, :4:-1]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[:, 4:-10:-1]  # stop < 0 < start < len (down)\n        expected = df.iloc[:, 4::-1]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[:, -10:4]  # start < 0 < stop < len\n        expected = df.iloc[:, :4]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[:, 10:4]  # 0 < stop < len < start\n        expected = df.iloc[:, :0]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[:, -10:-11:-1]  # stop < start < 0 < len (down)\n        expected = df.iloc[:, :0]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[:, 10:11]  # 0 < len < start < stop\n        expected = df.iloc[:, :0]\n        tm.assert_frame_equal(result, expected)\n\n        # slice bounds exceeding is ok\n        result = s.iloc[18:30]\n        expected = s.iloc[18:]\n        tm.assert_series_equal(result, expected)\n\n        result = s.iloc[30:]\n        expected = s.iloc[:0]\n        tm.assert_series_equal(result, expected)\n\n        result = s.iloc[30::-1]\n        expected = s.iloc[::-1]\n        tm.assert_series_equal(result, expected)\n\n        # doc example\n        def check(result, expected):\n            str(result)\n            result.dtypes\n            tm.assert_frame_equal(result, expected)\n\n        dfl = DataFrame(np.random.randn(5, 2), columns=list(\"AB\"))\n        check(dfl.iloc[:, 2:3], DataFrame(index=dfl.index))\n        check(dfl.iloc[:, 1:3], dfl.iloc[:, [1]])\n        check(dfl.iloc[4:6], dfl.iloc[[4]])\n\n        msg = \"positional indexers are out-of-bounds\"\n        with pytest.raises(IndexError, match=msg):\n            dfl.iloc[[4, 5, 6]]\n        msg = \"single positional indexer is out-of-bounds\"\n        with pytest.raises(IndexError, match=msg):\n            dfl.iloc[:, 4]",
        "begin_line": 61,
        "end_line": 161,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.check#146",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.check(result, expected)",
        "snippet": "        def check(result, expected):\n            str(result)\n            result.dtypes\n            tm.assert_frame_equal(result, expected)",
        "begin_line": 146,
        "end_line": 149,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_non_integer_raises#172",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_non_integer_raises(self, index, columns, index_vals, column_vals)",
        "snippet": "    def test_iloc_non_integer_raises(self, index, columns, index_vals, column_vals):\n        # GH 25753\n        df = DataFrame(\n            np.random.randn(len(index), len(columns)), index=index, columns=columns\n        )\n        msg = \".iloc requires numeric indexers, got\"\n        with pytest.raises(IndexError, match=msg):\n            df.iloc[index_vals, column_vals]",
        "begin_line": 172,
        "end_line": 179,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_invalid_scalar#182",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_invalid_scalar(self, dims)",
        "snippet": "    def test_iloc_getitem_invalid_scalar(self, dims):\n        # GH 21982\n\n        if dims == 1:\n            s = Series(np.arange(10))\n        else:\n            s = DataFrame(np.arange(100).reshape(10, 10))\n\n        with pytest.raises(TypeError, match=\"Cannot index by location index\"):\n            s.iloc[\"a\"]",
        "begin_line": 182,
        "end_line": 191,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_array_not_mutating_negative_indices#193",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_array_not_mutating_negative_indices(self)",
        "snippet": "    def test_iloc_array_not_mutating_negative_indices(self):\n\n        # GH 21867\n        array_with_neg_numbers = np.array([1, 2, -1])\n        array_copy = array_with_neg_numbers.copy()\n        df = pd.DataFrame(\n            {\"A\": [100, 101, 102], \"B\": [103, 104, 105], \"C\": [106, 107, 108]},\n            index=[1, 2, 3],\n        )\n        df.iloc[array_with_neg_numbers]\n        tm.assert_numpy_array_equal(array_with_neg_numbers, array_copy)\n        df.iloc[:, array_with_neg_numbers]\n        tm.assert_numpy_array_equal(array_with_neg_numbers, array_copy)",
        "begin_line": 193,
        "end_line": 205,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_neg_int_can_reach_first_index#207",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_neg_int_can_reach_first_index(self)",
        "snippet": "    def test_iloc_getitem_neg_int_can_reach_first_index(self):\n        # GH10547 and GH10779\n        # negative integers should be able to reach index 0\n        df = DataFrame({\"A\": [2, 3, 5], \"B\": [7, 11, 13]})\n        s = df[\"A\"]\n\n        expected = df.iloc[0]\n        result = df.iloc[-3]\n        tm.assert_series_equal(result, expected)\n\n        expected = df.iloc[[0]]\n        result = df.iloc[[-3]]\n        tm.assert_frame_equal(result, expected)\n\n        expected = s.iloc[0]\n        result = s.iloc[-3]\n        assert result == expected\n\n        expected = s.iloc[[0]]\n        result = s.iloc[[-3]]\n        tm.assert_series_equal(result, expected)\n\n        # check the length 1 Series case highlighted in GH10547\n        expected = Series([\"a\"], index=[\"A\"])\n        result = expected.iloc[[-1]]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 207,
        "end_line": 232,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_dups#234",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_dups(self)",
        "snippet": "    def test_iloc_getitem_dups(self):\n        # GH 6766\n        df1 = DataFrame([{\"A\": None, \"B\": 1}, {\"A\": 2, \"B\": 2}])\n        df2 = DataFrame([{\"A\": 3, \"B\": 3}, {\"A\": 4, \"B\": 4}])\n        df = concat([df1, df2], axis=1)\n\n        # cross-sectional indexing\n        result = df.iloc[0, 0]\n        assert isna(result)\n\n        result = df.iloc[0, :]\n        expected = Series([np.nan, 1, 3, 3], index=[\"A\", \"B\", \"A\", \"B\"], name=0)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 234,
        "end_line": 246,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_array#248",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_array(self)",
        "snippet": "    def test_iloc_getitem_array(self):\n        # TODO: test something here?\n        pass",
        "begin_line": 248,
        "end_line": 250,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_bool#252",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_bool(self)",
        "snippet": "    def test_iloc_getitem_bool(self):\n        # TODO: test something here?\n        pass",
        "begin_line": 252,
        "end_line": 254,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_bool_diff_len#257",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_bool_diff_len(self, index)",
        "snippet": "    def test_iloc_getitem_bool_diff_len(self, index):\n        # GH26658\n        s = Series([1, 2, 3])\n        msg = f\"Boolean index has wrong length: {len(index)} instead of {len(s)}\"\n        with pytest.raises(IndexError, match=msg):\n            _ = s.iloc[index]",
        "begin_line": 257,
        "end_line": 262,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_slice#264",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_slice(self)",
        "snippet": "    def test_iloc_getitem_slice(self):\n        # TODO: test something here?\n        pass",
        "begin_line": 264,
        "end_line": 266,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_slice_dups#268",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_slice_dups(self)",
        "snippet": "    def test_iloc_getitem_slice_dups(self):\n\n        df1 = DataFrame(np.random.randn(10, 4), columns=[\"A\", \"A\", \"B\", \"B\"])\n        df2 = DataFrame(\n            np.random.randint(0, 10, size=20).reshape(10, 2), columns=[\"A\", \"C\"]\n        )\n\n        # axis=1\n        df = concat([df1, df2], axis=1)\n        tm.assert_frame_equal(df.iloc[:, :4], df1)\n        tm.assert_frame_equal(df.iloc[:, 4:], df2)\n\n        df = concat([df2, df1], axis=1)\n        tm.assert_frame_equal(df.iloc[:, :2], df2)\n        tm.assert_frame_equal(df.iloc[:, 2:], df1)\n\n        exp = concat([df2, df1.iloc[:, [0]]], axis=1)\n        tm.assert_frame_equal(df.iloc[:, 0:3], exp)\n\n        # axis=0\n        df = concat([df, df], axis=0)\n        tm.assert_frame_equal(df.iloc[0:10, :2], df2)\n        tm.assert_frame_equal(df.iloc[0:10, 2:], df1)\n        tm.assert_frame_equal(df.iloc[10:, :2], df2)\n        tm.assert_frame_equal(df.iloc[10:, 2:], df1)",
        "begin_line": 268,
        "end_line": 292,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem#294",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem(self)",
        "snippet": "    def test_iloc_setitem(self):\n        df = DataFrame(\n            np.random.randn(4, 4), index=np.arange(0, 8, 2), columns=np.arange(0, 12, 3)\n        )\n\n        df.iloc[1, 1] = 1\n        result = df.iloc[1, 1]\n        assert result == 1\n\n        df.iloc[:, 2:3] = 0\n        expected = df.iloc[:, 2:3]\n        result = df.iloc[:, 2:3]\n        tm.assert_frame_equal(result, expected)\n\n        # GH5771\n        s = Series(0, index=[4, 5, 6])\n        s.iloc[1:2] += 1\n        expected = Series([0, 1, 0], index=[4, 5, 6])\n        tm.assert_series_equal(s, expected)",
        "begin_line": 294,
        "end_line": 312,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_list#314",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_list(self)",
        "snippet": "    def test_iloc_setitem_list(self):\n\n        # setitem with an iloc list\n        df = DataFrame(\n            np.arange(9).reshape((3, 3)), index=[\"A\", \"B\", \"C\"], columns=[\"A\", \"B\", \"C\"]\n        )\n        df.iloc[[0, 1], [1, 2]]\n        df.iloc[[0, 1], [1, 2]] += 100\n\n        expected = DataFrame(\n            np.array([0, 101, 102, 3, 104, 105, 6, 7, 8]).reshape((3, 3)),\n            index=[\"A\", \"B\", \"C\"],\n            columns=[\"A\", \"B\", \"C\"],\n        )\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 314,
        "end_line": 328,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_pandas_object#330",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_pandas_object(self)",
        "snippet": "    def test_iloc_setitem_pandas_object(self):\n        # GH 17193\n        s_orig = Series([0, 1, 2, 3])\n        expected = Series([0, -1, -2, 3])\n\n        s = s_orig.copy()\n        s.iloc[Series([1, 2])] = [-1, -2]\n        tm.assert_series_equal(s, expected)\n\n        s = s_orig.copy()\n        s.iloc[pd.Index([1, 2])] = [-1, -2]\n        tm.assert_series_equal(s, expected)",
        "begin_line": 330,
        "end_line": 341,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_dups#343",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_dups(self)",
        "snippet": "    def test_iloc_setitem_dups(self):\n\n        # GH 6766\n        # iloc with a mask aligning from another iloc\n        df1 = DataFrame([{\"A\": None, \"B\": 1}, {\"A\": 2, \"B\": 2}])\n        df2 = DataFrame([{\"A\": 3, \"B\": 3}, {\"A\": 4, \"B\": 4}])\n        df = concat([df1, df2], axis=1)\n\n        expected = df.fillna(3)\n        expected[\"A\"] = expected[\"A\"].astype(\"float64\")\n        inds = np.isnan(df.iloc[:, 0])\n        mask = inds[inds].index\n        df.iloc[mask, 0] = df.iloc[mask, 2]\n        tm.assert_frame_equal(df, expected)\n\n        # del a dup column across blocks\n        expected = DataFrame({0: [1, 2], 1: [3, 4]})\n        expected.columns = [\"B\", \"B\"]\n        del df[\"A\"]\n        tm.assert_frame_equal(df, expected)\n\n        # assign back to self\n        df.iloc[[0, 1], [0, 1]] = df.iloc[[0, 1], [0, 1]]\n        tm.assert_frame_equal(df, expected)\n\n        # reversed x 2\n        df.iloc[[1, 0], [0, 1]] = df.iloc[[1, 0], [0, 1]].reset_index(drop=True)\n        df.iloc[[1, 0], [0, 1]] = df.iloc[[1, 0], [0, 1]].reset_index(drop=True)\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 343,
        "end_line": 371,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_frame#375",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_frame(self)",
        "snippet": "    def test_iloc_getitem_frame(self):\n        df = DataFrame(\n            np.random.randn(10, 4), index=range(0, 20, 2), columns=range(0, 8, 2)\n        )\n\n        result = df.iloc[2]\n        exp = df.loc[4]\n        tm.assert_series_equal(result, exp)\n\n        result = df.iloc[2, 2]\n        exp = df.loc[4, 4]\n        assert result == exp\n\n        # slice\n        result = df.iloc[4:8]\n        expected = df.loc[8:14]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[:, 2:3]\n        expected = df.loc[:, 4:5]\n        tm.assert_frame_equal(result, expected)\n\n        # list of integers\n        result = df.iloc[[0, 1, 3]]\n        expected = df.loc[[0, 2, 6]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[[0, 1, 3], [0, 1]]\n        expected = df.loc[[0, 2, 6], [0, 2]]\n        tm.assert_frame_equal(result, expected)\n\n        # neg indices\n        result = df.iloc[[-1, 1, 3], [-1, 1]]\n        expected = df.loc[[18, 2, 6], [6, 2]]\n        tm.assert_frame_equal(result, expected)\n\n        # dups indices\n        result = df.iloc[[-1, -1, 1, 3], [-1, 1]]\n        expected = df.loc[[18, 18, 2, 6], [6, 2]]\n        tm.assert_frame_equal(result, expected)\n\n        # with index-like\n        s = Series(index=range(1, 5), dtype=object)\n        result = df.iloc[s.index]\n        expected = df.loc[[2, 4, 6, 8]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 375,
        "end_line": 420,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_labelled_frame#422",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_labelled_frame(self)",
        "snippet": "    def test_iloc_getitem_labelled_frame(self):\n        # try with labelled frame\n        df = DataFrame(\n            np.random.randn(10, 4), index=list(\"abcdefghij\"), columns=list(\"ABCD\")\n        )\n\n        result = df.iloc[1, 1]\n        exp = df.loc[\"b\", \"B\"]\n        assert result == exp\n\n        result = df.iloc[:, 2:3]\n        expected = df.loc[:, [\"C\"]]\n        tm.assert_frame_equal(result, expected)\n\n        # negative indexing\n        result = df.iloc[-1, -1]\n        exp = df.loc[\"j\", \"D\"]\n        assert result == exp\n\n        # out-of-bounds exception\n        msg = \"single positional indexer is out-of-bounds\"\n        with pytest.raises(IndexError, match=msg):\n            df.iloc[10, 5]\n\n        # trying to use a label\n        msg = (\n            r\"Location based indexing can only have \\[integer, integer \"\n            r\"slice \\(START point is INCLUDED, END point is EXCLUDED\\), \"\n            r\"listlike of integers, boolean array\\] types\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            df.iloc[\"j\", \"D\"]",
        "begin_line": 422,
        "end_line": 453,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_doc_issue#455",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_getitem_doc_issue(self)",
        "snippet": "    def test_iloc_getitem_doc_issue(self):\n\n        # multi axis slicing issue with single block\n        # surfaced in GH 6059\n\n        arr = np.random.randn(6, 4)\n        index = date_range(\"20130101\", periods=6)\n        columns = list(\"ABCD\")\n        df = DataFrame(arr, index=index, columns=columns)\n\n        # defines ref_locs\n        df.describe()\n\n        result = df.iloc[3:5, 0:2]\n        str(result)\n        result.dtypes\n\n        expected = DataFrame(arr[3:5, 0:2], index=index[3:5], columns=columns[0:2])\n        tm.assert_frame_equal(result, expected)\n\n        # for dups\n        df.columns = list(\"aaaa\")\n        result = df.iloc[3:5, 0:2]\n        str(result)\n        result.dtypes\n\n        expected = DataFrame(arr[3:5, 0:2], index=index[3:5], columns=list(\"aa\"))\n        tm.assert_frame_equal(result, expected)\n\n        # related\n        arr = np.random.randn(6, 4)\n        index = list(range(0, 12, 2))\n        columns = list(range(0, 8, 2))\n        df = DataFrame(arr, index=index, columns=columns)\n\n        df._data.blocks[0].mgr_locs\n        result = df.iloc[1:5, 2:4]\n        str(result)\n        result.dtypes\n        expected = DataFrame(arr[1:5, 2:4], index=index[1:5], columns=columns[2:4])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 455,
        "end_line": 495,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_series#497",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_series(self)",
        "snippet": "    def test_iloc_setitem_series(self):\n        df = DataFrame(\n            np.random.randn(10, 4), index=list(\"abcdefghij\"), columns=list(\"ABCD\")\n        )\n\n        df.iloc[1, 1] = 1\n        result = df.iloc[1, 1]\n        assert result == 1\n\n        df.iloc[:, 2:3] = 0\n        expected = df.iloc[:, 2:3]\n        result = df.iloc[:, 2:3]\n        tm.assert_frame_equal(result, expected)\n\n        s = Series(np.random.randn(10), index=range(0, 20, 2))\n\n        s.iloc[1] = 1\n        result = s.iloc[1]\n        assert result == 1\n\n        s.iloc[:4] = 0\n        expected = s.iloc[:4]\n        result = s.iloc[:4]\n        tm.assert_series_equal(result, expected)\n\n        s = Series([-1] * 6)\n        s.iloc[0::2] = [0, 2, 4]\n        s.iloc[1::2] = [1, 3, 5]\n        result = s\n        expected = Series([0, 1, 2, 3, 4, 5])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 497,
        "end_line": 527,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_list_of_lists#529",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_list_of_lists(self)",
        "snippet": "    def test_iloc_setitem_list_of_lists(self):\n\n        # GH 7551\n        # list-of-list is set incorrectly in mixed vs. single dtyped frames\n        df = DataFrame(\n            dict(A=np.arange(5, dtype=\"int64\"), B=np.arange(5, 10, dtype=\"int64\"))\n        )\n        df.iloc[2:4] = [[10, 11], [12, 13]]\n        expected = DataFrame(dict(A=[0, 1, 10, 12, 4], B=[5, 6, 11, 13, 9]))\n        tm.assert_frame_equal(df, expected)\n\n        df = DataFrame(dict(A=list(\"abcde\"), B=np.arange(5, 10, dtype=\"int64\")))\n        df.iloc[2:4] = [[\"x\", 11], [\"y\", 13]]\n        expected = DataFrame(dict(A=[\"a\", \"b\", \"x\", \"y\", \"e\"], B=[5, 6, 11, 13, 9]))\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 529,
        "end_line": 543,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_with_scalar_index#547",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_setitem_with_scalar_index(self, indexer, value)",
        "snippet": "    def test_iloc_setitem_with_scalar_index(self, indexer, value):\n        # GH #19474\n        # assigning like \"df.iloc[0, [0]] = ['Z']\" should be evaluated\n        # elementwisely, not using \"setter('A', ['Z'])\".\n\n        df = pd.DataFrame([[1, 2], [3, 4]], columns=[\"A\", \"B\"])\n        df.iloc[0, indexer] = value\n        result = df.iloc[0, 0]\n\n        assert is_scalar(result) and result == \"Z\"",
        "begin_line": 547,
        "end_line": 556,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_mask#558",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_mask(self)",
        "snippet": "    def test_iloc_mask(self):\n\n        # GH 3631, iloc with a mask (of a series) should raise\n        df = DataFrame(list(range(5)), index=list(\"ABCDE\"), columns=[\"a\"])\n        mask = df.a % 2 == 0\n        msg = \"iLocation based boolean indexing cannot use an indexable as a mask\"\n        with pytest.raises(ValueError, match=msg):\n            df.iloc[mask]\n        mask.index = range(len(mask))\n        msg = \"iLocation based boolean indexing on an integer type is not available\"\n        with pytest.raises(NotImplementedError, match=msg):\n            df.iloc[mask]\n\n        # ndarray ok\n        result = df.iloc[np.array([True] * len(mask), dtype=bool)]\n        tm.assert_frame_equal(result, df)\n\n        # the possibilities\n        locs = np.arange(4)\n        nums = 2 ** locs\n        reps = [bin(num) for num in nums]\n        df = DataFrame({\"locs\": locs, \"nums\": nums}, reps)\n\n        expected = {\n            (None, \"\"): \"0b1100\",\n            (None, \".loc\"): \"0b1100\",\n            (None, \".iloc\"): \"0b1100\",\n            (\"index\", \"\"): \"0b11\",\n            (\"index\", \".loc\"): \"0b11\",\n            (\"index\", \".iloc\"): (\n                \"iLocation based boolean indexing cannot use an indexable as a mask\"\n            ),\n            (\"locs\", \"\"): \"Unalignable boolean Series provided as indexer \"\n            \"(index of the boolean Series and of the indexed \"\n            \"object do not match).\",\n            (\"locs\", \".loc\"): \"Unalignable boolean Series provided as indexer \"\n            \"(index of the boolean Series and of the \"\n            \"indexed object do not match).\",\n            (\"locs\", \".iloc\"): (\n                \"iLocation based boolean indexing on an \"\n                \"integer type is not available\"\n            ),\n        }\n\n        # UserWarnings from reindex of a boolean mask\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", UserWarning)\n            result = dict()\n            for idx in [None, \"index\", \"locs\"]:\n                mask = (df.nums > 2).values\n                if idx:\n                    mask = Series(mask, list(reversed(getattr(df, idx))))\n                for method in [\"\", \".loc\", \".iloc\"]:\n                    try:\n                        if method:\n                            accessor = getattr(df, method[1:])\n                        else:\n                            accessor = df\n                        ans = str(bin(accessor[mask][\"nums\"].sum()))\n                    except (ValueError, IndexingError, NotImplementedError) as e:\n                        ans = str(e)\n\n                    key = tuple([idx, method])\n                    r = expected.get(key)\n                    if r != ans:\n                        raise AssertionError(\n                            f\"[{key}] does not match [{ans}], received [{r}]\"\n                        )",
        "begin_line": 558,
        "end_line": 625,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_non_unique_indexing#627",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_non_unique_indexing(self)",
        "snippet": "    def test_iloc_non_unique_indexing(self):\n\n        # GH 4017, non-unique indexing (on the axis)\n        df = DataFrame({\"A\": [0.1] * 3000, \"B\": [1] * 3000})\n        idx = np.arange(30) * 99\n        expected = df.iloc[idx]\n\n        df3 = concat([df, 2 * df, 3 * df])\n        result = df3.iloc[idx]\n\n        tm.assert_frame_equal(result, expected)\n\n        df2 = DataFrame({\"A\": [0.1] * 1000, \"B\": [1] * 1000})\n        df2 = concat([df2, 2 * df2, 3 * df2])\n\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            df2.loc[idx]",
        "begin_line": 627,
        "end_line": 643,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_empty_list_indexer_is_ok#645",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_iloc_empty_list_indexer_is_ok(self)",
        "snippet": "    def test_iloc_empty_list_indexer_is_ok(self):\n\n        df = tm.makeCustomDataframe(5, 2)\n        # vertical empty\n        tm.assert_frame_equal(\n            df.iloc[:, []],\n            df.iloc[:, :0],\n            check_index_type=True,\n            check_column_type=True,\n        )\n        # horizontal empty\n        tm.assert_frame_equal(\n            df.iloc[[], :],\n            df.iloc[:0, :],\n            check_index_type=True,\n            check_column_type=True,\n        )\n        # horizontal empty\n        tm.assert_frame_equal(\n            df.iloc[[]], df.iloc[:0, :], check_index_type=True, check_column_type=True\n        )",
        "begin_line": 645,
        "end_line": 665,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_identity_slice_returns_new_object#667",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_identity_slice_returns_new_object(self)",
        "snippet": "    def test_identity_slice_returns_new_object(self):\n        # GH13873\n        original_df = DataFrame({\"a\": [1, 2, 3]})\n        sliced_df = original_df.iloc[:]\n        assert sliced_df is not original_df\n\n        # should be a shallow copy\n        original_df[\"a\"] = [4, 4, 4]\n        assert (sliced_df[\"a\"] == 4).all()\n\n        original_series = Series([1, 2, 3, 4, 5, 6])\n        sliced_series = original_series.iloc[:]\n        assert sliced_series is not original_series\n\n        # should also be a shallow copy\n        original_series[:3] = [7, 8, 9]\n        assert all(sliced_series[:3] == [7, 8, 9])",
        "begin_line": 667,
        "end_line": 683,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_indexing_zerodim_np_array#685",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_indexing_zerodim_np_array(self)",
        "snippet": "    def test_indexing_zerodim_np_array(self):\n        # GH24919\n        df = DataFrame([[1, 2], [3, 4]])\n        result = df.iloc[np.array(0)]\n        s = pd.Series([1, 2], name=0)\n        tm.assert_series_equal(result, s)",
        "begin_line": 685,
        "end_line": 690,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_iloc.TestiLoc2.test_series_indexing_zerodim_np_array#692",
        "src_path": "pandas/tests/indexing/test_iloc.py",
        "class_name": "pandas.tests.indexing.test_iloc.TestiLoc2",
        "signature": "pandas.tests.indexing.test_iloc.TestiLoc2.test_series_indexing_zerodim_np_array(self)",
        "snippet": "    def test_series_indexing_zerodim_np_array(self):\n        # GH24919\n        s = Series([1, 2])\n        result = s.iloc[np.array(0)]\n        assert result == 1",
        "begin_line": 692,
        "end_line": 696,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common._mklbl#10",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common",
        "signature": "pandas.tests.indexing.common._mklbl(prefix, n)",
        "snippet": "def _mklbl(prefix, n):\n    return [f\"{prefix}{i}\" for i in range(n)]",
        "begin_line": 10,
        "end_line": 11,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common._axify#14",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common",
        "signature": "pandas.tests.indexing.common._axify(obj, key, axis)",
        "snippet": "def _axify(obj, key, axis):\n    # create a tuple accessor\n    axes = [slice(None)] * obj.ndim\n    axes[axis] = key\n    return tuple(axes)",
        "begin_line": 14,
        "end_line": 18,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.setup_method#37",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n\n        self.series_ints = Series(np.random.rand(4), index=np.arange(0, 8, 2))\n        self.frame_ints = DataFrame(\n            np.random.randn(4, 4), index=np.arange(0, 8, 2), columns=np.arange(0, 12, 3)\n        )\n\n        self.series_uints = Series(\n            np.random.rand(4), index=UInt64Index(np.arange(0, 8, 2))\n        )\n        self.frame_uints = DataFrame(\n            np.random.randn(4, 4),\n            index=UInt64Index(range(0, 8, 2)),\n            columns=UInt64Index(range(0, 12, 3)),\n        )\n\n        self.series_floats = Series(\n            np.random.rand(4), index=Float64Index(range(0, 8, 2))\n        )\n        self.frame_floats = DataFrame(\n            np.random.randn(4, 4),\n            index=Float64Index(range(0, 8, 2)),\n            columns=Float64Index(range(0, 12, 3)),\n        )\n\n        m_idces = [\n            MultiIndex.from_product([[1, 2], [3, 4]]),\n            MultiIndex.from_product([[5, 6], [7, 8]]),\n            MultiIndex.from_product([[9, 10], [11, 12]]),\n        ]\n\n        self.series_multi = Series(np.random.rand(4), index=m_idces[0])\n        self.frame_multi = DataFrame(\n            np.random.randn(4, 4), index=m_idces[0], columns=m_idces[1]\n        )\n\n        self.series_labels = Series(np.random.randn(4), index=list(\"abcd\"))\n        self.frame_labels = DataFrame(\n            np.random.randn(4, 4), index=list(\"abcd\"), columns=list(\"ABCD\")\n        )\n\n        self.series_mixed = Series(np.random.randn(4), index=[2, 4, \"null\", 8])\n        self.frame_mixed = DataFrame(np.random.randn(4, 4), index=[2, 4, \"null\", 8])\n\n        self.series_ts = Series(\n            np.random.randn(4), index=date_range(\"20130101\", periods=4)\n        )\n        self.frame_ts = DataFrame(\n            np.random.randn(4, 4), index=date_range(\"20130101\", periods=4)\n        )\n\n        dates_rev = date_range(\"20130101\", periods=4).sort_values(ascending=False)\n        self.series_ts_rev = Series(np.random.randn(4), index=dates_rev)\n        self.frame_ts_rev = DataFrame(np.random.randn(4, 4), index=dates_rev)\n\n        self.frame_empty = DataFrame()\n        self.series_empty = Series(dtype=object)\n\n        # form agglomerates\n        for kind in self._kinds:\n            d = dict()\n            for typ in self._typs:\n                d[typ] = getattr(self, f\"{kind}_{typ}\")\n\n            setattr(self, kind, d)",
        "begin_line": 37,
        "end_line": 101,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.generate_indices#103",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.generate_indices(self, f, values=False)",
        "snippet": "    def generate_indices(self, f, values=False):\n        \"\"\"\n        generate the indices\n        if values is True , use the axis values\n        is False, use the range\n        \"\"\"\n        axes = f.axes\n        if values:\n            axes = (list(range(len(ax))) for ax in axes)\n\n        return itertools.product(*axes)",
        "begin_line": 103,
        "end_line": 113,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.get_value#115",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.get_value(self, name, f, i, values=False)",
        "snippet": "    def get_value(self, name, f, i, values=False):\n        \"\"\" return the value for the location i \"\"\"\n        # check against values\n        if values:\n            return f.values[i]\n\n        elif name == \"iat\":\n            return f.iloc[i]\n        else:\n            assert name == \"at\"\n            return f.loc[i]",
        "begin_line": 115,
        "end_line": 125,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.check_values#127",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.check_values(self, f, func, values=False)",
        "snippet": "    def check_values(self, f, func, values=False):\n\n        if f is None:\n            return\n        axes = f.axes\n        indicies = itertools.product(*axes)\n\n        for i in indicies:\n            result = getattr(f, func)[i]\n\n            # check against values\n            if values:\n                expected = f.values[i]\n            else:\n                expected = f\n                for a in reversed(i):\n                    expected = expected.__getitem__(a)\n\n            tm.assert_almost_equal(result, expected)",
        "begin_line": 127,
        "end_line": 145,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.check_result#147",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.check_result(self, method, key, typs=None, axes=None, fails=None)",
        "snippet": "    def check_result(\n        self, method, key, typs=None, axes=None, fails=None,\n    ):\n        def _eq(axis, obj, key):\n            \"\"\" compare equal for these 2 keys \"\"\"\n            axified = _axify(obj, key, axis)\n            try:\n                getattr(obj, method).__getitem__(axified)\n\n            except (IndexError, TypeError, KeyError) as detail:\n\n                # if we are in fails, the ok, otherwise raise it\n                if fails is not None:\n                    if isinstance(detail, fails):\n                        return\n                raise\n\n        if typs is None:\n            typs = self._typs\n\n        if axes is None:\n            axes = [0, 1]\n        else:\n            assert axes in [0, 1]\n            axes = [axes]\n\n        # check\n        for kind in self._kinds:\n\n            d = getattr(self, kind)\n            for ax in axes:\n                for typ in typs:\n                    assert typ in self._typs\n\n                    obj = d[typ]\n                    if ax < obj.ndim:\n                        _eq(axis=ax, obj=obj, key=key)",
        "begin_line": 147,
        "end_line": 183,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base._eq#150",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base._eq(axis, obj, key)",
        "snippet": "        def _eq(axis, obj, key):\n            \"\"\" compare equal for these 2 keys \"\"\"\n            axified = _axify(obj, key, axis)\n            try:\n                getattr(obj, method).__getitem__(axified)\n\n            except (IndexError, TypeError, KeyError) as detail:\n\n                # if we are in fails, the ok, otherwise raise it\n                if fails is not None:\n                    if isinstance(detail, fails):\n                        return\n                raise",
        "begin_line": 150,
        "end_line": 162,
        "comment": "",
        "is_bug": false
    }
]