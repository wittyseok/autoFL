[
    {
        "name": "test.helpers.with_config.__init__#90",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.with_config",
        "signature": "test.helpers.with_config.__init__(self, config, replace_sections=False)",
        "snippet": "    def __init__(self, config, replace_sections=False):\n        self.config = config\n        self.replace_sections = replace_sections",
        "begin_line": 90,
        "end_line": 92,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.with_config._make_dict#94",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.with_config",
        "signature": "test.helpers.with_config._make_dict(self, old_dict)",
        "snippet": "    def _make_dict(self, old_dict):\n        if self.replace_sections:\n            old_dict.update(self.config)\n            return old_dict\n\n        def get_section(sec):\n            old_sec = old_dict.get(sec, {})\n            new_sec = self.config.get(sec, {})\n            old_sec.update(new_sec)\n            return old_sec\n\n        all_sections = itertools.chain(old_dict.keys(), self.config.keys())\n        return {sec: get_section(sec) for sec in all_sections}",
        "begin_line": 94,
        "end_line": 106,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.with_config.get_section#99",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.with_config",
        "signature": "test.helpers.with_config.get_section(sec)",
        "snippet": "        def get_section(sec):\n            old_sec = old_dict.get(sec, {})\n            new_sec = self.config.get(sec, {})\n            old_sec.update(new_sec)\n            return old_sec",
        "begin_line": 99,
        "end_line": 103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.with_config.__call__#108",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.with_config",
        "signature": "test.helpers.with_config.__call__(self, fun)",
        "snippet": "    def __call__(self, fun):\n        @functools.wraps(fun)\n        def wrapper(*args, **kwargs):\n            import luigi.configuration\n            orig_conf = luigi.configuration.LuigiConfigParser.instance()\n            new_conf = luigi.configuration.LuigiConfigParser()\n            luigi.configuration.LuigiConfigParser._instance = new_conf\n            orig_dict = {k: dict(orig_conf.items(k)) for k in orig_conf.sections()}\n            new_dict = self._make_dict(orig_dict)\n            for (section, settings) in six.iteritems(new_dict):\n                new_conf.add_section(section)\n                for (name, value) in six.iteritems(settings):\n                    new_conf.set(section, name, value)\n            try:\n                return fun(*args, **kwargs)\n            finally:\n                luigi.configuration.LuigiConfigParser._instance = orig_conf\n        return wrapper",
        "begin_line": 108,
        "end_line": 125,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.with_config.wrapper#110",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.with_config",
        "signature": "test.helpers.with_config.wrapper(*args, **kwargs)",
        "snippet": "        def wrapper(*args, **kwargs):\n            import luigi.configuration\n            orig_conf = luigi.configuration.LuigiConfigParser.instance()\n            new_conf = luigi.configuration.LuigiConfigParser()\n            luigi.configuration.LuigiConfigParser._instance = new_conf\n            orig_dict = {k: dict(orig_conf.items(k)) for k in orig_conf.sections()}\n            new_dict = self._make_dict(orig_dict)\n            for (section, settings) in six.iteritems(new_dict):\n                new_conf.add_section(section)\n                for (name, value) in six.iteritems(settings):\n                    new_conf.set(section, name, value)\n            try:\n                return fun(*args, **kwargs)\n            finally:\n                luigi.configuration.LuigiConfigParser._instance = orig_conf",
        "begin_line": 110,
        "end_line": 124,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.RunOnceTask.complete#134",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.RunOnceTask",
        "signature": "test.helpers.RunOnceTask.complete(self)",
        "snippet": "    def complete(self):\n        return self.comp",
        "begin_line": 134,
        "end_line": 135,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.RunOnceTask.run#137",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.RunOnceTask",
        "signature": "test.helpers.RunOnceTask.run(self)",
        "snippet": "    def run(self):\n        self.comp = True",
        "begin_line": 137,
        "end_line": 138,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.LuigiTestCase.setUp#147",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.LuigiTestCase",
        "signature": "test.helpers.LuigiTestCase.setUp(self)",
        "snippet": "    def setUp(self):\n        super(LuigiTestCase, self).setUp()\n        self._stashed_reg = luigi.task_register.Register._get_reg()\n        luigi.task_register.Register.clear_instance_cache()",
        "begin_line": 147,
        "end_line": 150,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.LuigiTestCase.tearDown#152",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.LuigiTestCase",
        "signature": "test.helpers.LuigiTestCase.tearDown(self)",
        "snippet": "    def tearDown(self):\n        luigi.task_register.Register._set_reg(self._stashed_reg)\n        super(LuigiTestCase, self).tearDown()\n        luigi.task_register.Register.clear_instance_cache()",
        "begin_line": 152,
        "end_line": 155,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.LuigiTestCase.run_locally#157",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.LuigiTestCase",
        "signature": "test.helpers.LuigiTestCase.run_locally(self, args)",
        "snippet": "    def run_locally(self, args):\n        \"\"\" Helper for running tests testing more of the stack, the command\n        line parsing and task from name intstantiation parts in particular. \"\"\"\n        temp = CmdlineParser._instance\n        try:\n            CmdlineParser._instance = None\n            run_exit_status = luigi.run(['--local-scheduler', '--no-lock'] + args)\n        finally:\n            CmdlineParser._instance = temp\n        return run_exit_status",
        "begin_line": 157,
        "end_line": 166,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.LuigiTestCase.run_locally_split#168",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers.LuigiTestCase",
        "signature": "test.helpers.LuigiTestCase.run_locally_split(self, space_seperated_args)",
        "snippet": "    def run_locally_split(self, space_seperated_args):\n        \"\"\" Helper for running tests testing more of the stack, the command\n        line parsing and task from name intstantiation parts in particular. \"\"\"\n        return self.run_locally(space_seperated_args.split(' '))",
        "begin_line": 168,
        "end_line": 171,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.in_parse#191",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers",
        "signature": "test.helpers.in_parse(cmds, deferred_computation)",
        "snippet": "def in_parse(cmds, deferred_computation):\n    with CmdlineParser.global_instance(cmds) as cp:\n        deferred_computation(cp.get_task_obj())",
        "begin_line": 191,
        "end_line": 193,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.helpers.temporary_unloaded_module#197",
        "src_path": "test/helpers.py",
        "class_name": "test.helpers",
        "signature": "test.helpers.temporary_unloaded_module(python_file_contents)",
        "snippet": "def temporary_unloaded_module(python_file_contents):\n    \"\"\" Create an importable module\n\n    Return the name of importable module name given its file contents (source\n    code) \"\"\"\n    with tempfile.NamedTemporaryFile(\n            dir='test/',\n            prefix=\"_test_time_generated_module\",\n            suffix='.py') as temp_module_file:\n        temp_module_file.file.write(python_file_contents)\n        temp_module_file.file.flush()\n        temp_module_path = temp_module_file.name\n        temp_module_name = re.search(r'/(_test_time_generated_module.*).py',\n                                     temp_module_path).group(1)\n        yield temp_module_name",
        "begin_line": 197,
        "end_line": 211,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.other_module.OtherModuleTask.output#24",
        "src_path": "test/other_module.py",
        "class_name": "test.other_module.OtherModuleTask",
        "signature": "test.other_module.OtherModuleTask.output(self)",
        "snippet": "    def output(self):\n        return luigi.LocalTarget(self.p)",
        "begin_line": 24,
        "end_line": 25,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.other_module.OtherModuleTask.run#27",
        "src_path": "test/other_module.py",
        "class_name": "test.other_module.OtherModuleTask",
        "signature": "test.other_module.OtherModuleTask.run(self)",
        "snippet": "    def run(self):\n        with self.output().open('w') as f:\n            f.write('Done!')",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.DummyS3CopyToTableBase.s3_load_path#51",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.DummyS3CopyToTableBase",
        "signature": "test.contrib.redshift_test.DummyS3CopyToTableBase.s3_load_path(self)",
        "snippet": "    def s3_load_path(self):\n        return 's3://%s/%s' % (BUCKET, KEY)",
        "begin_line": 51,
        "end_line": 52,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestS3CopyToTable.test_copy_missing_creds#80",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestS3CopyToTable",
        "signature": "test.contrib.redshift_test.TestS3CopyToTable.test_copy_missing_creds(self, mock_redshift_target)",
        "snippet": "    def test_copy_missing_creds(self, mock_redshift_target):\n        task = DummyS3CopyToTableBase()\n\n        # The mocked connection cursor passed to\n        # S3CopyToTable.copy(self, cursor, f).\n        mock_cursor = (mock_redshift_target.return_value\n                       .connect\n                       .return_value\n                       .cursor\n                       .return_value)\n\n        with self.assertRaises(NotImplementedError):\n            task.copy(mock_cursor, task.s3_load_path())",
        "begin_line": 80,
        "end_line": 92,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_to_table#96",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestS3CopyToTable",
        "signature": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_to_table(self, mock_redshift_target, mock_copy)",
        "snippet": "    def test_s3_copy_to_table(self, mock_redshift_target, mock_copy):\n        task = DummyS3CopyToTableKey()\n        task.run()\n\n        # The mocked connection cursor passed to\n        # S3CopyToTable.copy(self, cursor, f).\n        mock_cursor = (mock_redshift_target.return_value\n                                           .connect\n                                           .return_value\n                                           .cursor\n                                           .return_value)\n\n        # `mock_redshift_target` is the mocked `RedshiftTarget` object\n        # returned by S3CopyToTable.output(self).\n        mock_redshift_target.assert_called_with(database=task.database,\n                                                host=task.host,\n                                                update_id=task.task_id,\n                                                user=task.user,\n                                                table=task.table,\n                                                password=task.password)\n\n        # Check if the `S3CopyToTable.s3_load_path` class attribute was\n        # successfully referenced in the `S3CopyToTable.run` method, which is\n        # in-turn passed to `S3CopyToTable.copy` and other functions in `run`\n        # (see issue #995).\n        mock_copy.assert_called_with(mock_cursor, task.s3_load_path())\n\n        # Check the SQL query in `S3CopyToTable.does_table_exist`.\n        mock_cursor.execute.assert_called_with(\"select 1 as table_exists \"\n                                               \"from pg_table_def \"\n                                               \"where tablename = lower(%s) limit 1\",\n                                               (task.table,))\n\n        return",
        "begin_line": 96,
        "end_line": 129,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_to_missing_table#134",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestS3CopyToTable",
        "signature": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_to_missing_table(self, mock_redshift_target, mock_does_exist)",
        "snippet": "    def test_s3_copy_to_missing_table(self,\n                                      mock_redshift_target,\n                                      mock_does_exist):\n        \"\"\"\n        Test missing table creation\n        \"\"\"\n        # Ensure `S3CopyToTable.create_table` does not throw an error.\n        task = DummyS3CopyToTableKey()\n        task.run()\n\n        # Make sure the cursor was successfully used to create the table in\n        # `create_table` as expected.\n        mock_cursor = (mock_redshift_target.return_value\n                                           .connect\n                                           .return_value\n                                           .cursor\n                                           .return_value)\n        assert mock_cursor.execute.call_args_list[0][0][0].startswith(\n            \"CREATE  TABLE %s\" % task.table)\n\n        return",
        "begin_line": 134,
        "end_line": 154,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_to_temp_table#158",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestS3CopyToTable",
        "signature": "test.contrib.redshift_test.TestS3CopyToTable.test_s3_copy_to_temp_table(self, mock_redshift_target, mock_copy)",
        "snippet": "    def test_s3_copy_to_temp_table(self, mock_redshift_target, mock_copy):\n        task = DummyS3CopyToTempTable()\n        task.run()\n\n        # The mocked connection cursor passed to\n        # S3CopyToTable.copy(self, cursor, f).\n        mock_cursor = (mock_redshift_target.return_value\n                                           .connect\n                                           .return_value\n                                           .cursor\n                                           .return_value)\n\n        # `mock_redshift_target` is the mocked `RedshiftTarget` object\n        # returned by S3CopyToTable.output(self).\n        mock_redshift_target.assert_called_once_with(\n            database=task.database,\n            host=task.host,\n            update_id=task.task_id,\n            user=task.user,\n            table=task.table,\n            password=task.password,\n        )\n\n        # Check if the `S3CopyToTable.s3_load_path` class attribute was\n        # successfully referenced in the `S3CopyToTable.run` method, which is\n        # in-turn passed to `S3CopyToTable.copy` and other functions in `run`\n        # (see issue #995).\n        mock_copy.assert_called_once_with(mock_cursor, task.s3_load_path())\n\n        # Check the SQL query in `S3CopyToTable.does_table_exist`. # temp table\n        mock_cursor.execute.assert_any_call(\n            \"select 1 as table_exists \"\n            \"from pg_table_def \"\n            \"where tablename = lower(%s) limit 1\",\n            (task.table,),\n        )",
        "begin_line": 158,
        "end_line": 193,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestS3CopyToSchemaTable.test_s3_copy_to_table#199",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestS3CopyToSchemaTable",
        "signature": "test.contrib.redshift_test.TestS3CopyToSchemaTable.test_s3_copy_to_table(self, mock_redshift_target, mock_copy)",
        "snippet": "    def test_s3_copy_to_table(self, mock_redshift_target, mock_copy):\n        task = DummyS3CopyToTableKey(table='dummy_schema.dummy_table')\n        task.run()\n\n        # The mocked connection cursor passed to\n        # S3CopyToTable.copy(self, cursor, f).\n        mock_cursor = (mock_redshift_target.return_value\n                                           .connect\n                                           .return_value\n                                           .cursor\n                                           .return_value)\n\n        # Check the SQL query in `S3CopyToTable.does_table_exist`.\n        mock_cursor.execute.assert_called_with(\n            \"select 1 as table_exists \"\n            \"from information_schema.tables \"\n            \"where table_schema = lower(%s) and \"\n            \"table_name = lower(%s) limit 1\",\n            tuple(task.table.split('.')),\n        )",
        "begin_line": 199,
        "end_line": 218,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.DummyRedshiftUnloadTask.query#240",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.DummyRedshiftUnloadTask",
        "signature": "test.contrib.redshift_test.DummyRedshiftUnloadTask.query(self)",
        "snippet": "    def query(self):\n        return \"SELECT 'a' as col_a, current_date as col_b\"",
        "begin_line": 240,
        "end_line": 241,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.contrib.redshift_test.TestRedshiftUnloadTask.test_redshift_unload_command#246",
        "src_path": "test/contrib/redshift_test.py",
        "class_name": "test.contrib.redshift_test.TestRedshiftUnloadTask",
        "signature": "test.contrib.redshift_test.TestRedshiftUnloadTask.test_redshift_unload_command(self, mock_redshift_target)",
        "snippet": "    def test_redshift_unload_command(self, mock_redshift_target):\n\n        task = DummyRedshiftUnloadTask()\n        task.run()\n\n        # The mocked connection cursor passed to\n        # RedshiftUnloadTask.\n        mock_cursor = (mock_redshift_target.return_value\n                                           .connect\n                                           .return_value\n                                           .cursor\n                                           .return_value)\n\n        # Check the Unload query.\n        mock_cursor.execute.assert_called_with(\n            \"UNLOAD ( 'SELECT \\\\'a\\\\' as col_a, current_date as col_b' ) TO 's3://bucket/key' \"\n            \"credentials 'aws_access_key_id=AWS_ACCESS_KEY;aws_secret_access_key=AWS_SECRET_KEY' \"\n            \"DELIMITER ',' ADDQUOTES GZIP ALLOWOVERWRITE PARALLEL OFF;\"\n        )",
        "begin_line": 246,
        "end_line": 264,
        "comment": "",
        "is_bug": false
    }
]