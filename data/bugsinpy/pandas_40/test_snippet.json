[
    {
        "name": "pandas.tests.extension.decimal.array.DecimalDtype.__init__#24",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalDtype",
        "signature": "pandas.tests.extension.decimal.array.DecimalDtype.__init__(self, context=None)",
        "snippet": "    def __init__(self, context=None):\n        self.context = context or decimal.getcontext()",
        "begin_line": 24,
        "end_line": 25,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__init__#49",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__init__(self, values, dtype=None, copy=False, context=None)",
        "snippet": "    def __init__(self, values, dtype=None, copy=False, context=None):\n        for val in values:\n            if not isinstance(val, decimal.Decimal):\n                raise TypeError(\"All values must be of type \" + str(decimal.Decimal))\n        values = np.asarray(values, dtype=object)\n\n        self._data = values\n        # Some aliases for common attribute names to ensure pandas supports\n        # these\n        self._items = self.data = self._data\n        # those aliases are currently not working due to assumptions\n        # in internal code (GH-20735)\n        # self._values = self.values = self.data\n        self._dtype = DecimalDtype(context)",
        "begin_line": 49,
        "end_line": 62,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.dtype#65",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.dtype(self)",
        "snippet": "    def dtype(self):\n        return self._dtype",
        "begin_line": 65,
        "end_line": 66,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__getitem__#111",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__getitem__(self, item)",
        "snippet": "    def __getitem__(self, item):\n        if isinstance(item, numbers.Integral):\n            return self._data[item]\n        else:\n            # array, slice.\n            item = pd.api.indexers.check_array_indexer(self, item)\n            return type(self)(self._data[item])",
        "begin_line": 111,
        "end_line": 117,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.DecimalArray.__len__#148",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array.DecimalArray",
        "signature": "pandas.tests.extension.decimal.array.DecimalArray.__len__(self)",
        "snippet": "    def __len__(self) -> int:\n        return len(self._data)",
        "begin_line": 148,
        "end_line": 149,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.extension.decimal.array.to_decimal#195",
        "src_path": "pandas/tests/extension/decimal/array.py",
        "class_name": "pandas.tests.extension.decimal.array",
        "signature": "pandas.tests.extension.decimal.array.to_decimal(values, context=None)",
        "snippet": "def to_decimal(values, context=None):\n    return DecimalArray([decimal.Decimal(x) for x in values], context=context)",
        "begin_line": 195,
        "end_line": 196,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.get_test_data#37",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.get_test_data(ngroups=NGROUPS, n=N)",
        "snippet": "def get_test_data(ngroups=NGROUPS, n=N):\n    unique_groups = list(range(ngroups))\n    arr = np.asarray(np.tile(unique_groups, n // ngroups))\n\n    if len(arr) < n:\n        arr = np.asarray(list(arr) + unique_groups[: n - len(arr)])\n\n    random.shuffle(arr)\n    return arr",
        "begin_line": 37,
        "end_line": 45,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.get_series#48",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.get_series()",
        "snippet": "def get_series():\n    return [\n        pd.Series([1], dtype=\"int64\"),\n        pd.Series([1], dtype=\"Int64\"),\n        pd.Series([1.23]),\n        pd.Series([\"foo\"]),\n        pd.Series([True]),\n        pd.Series([pd.Timestamp(\"2018-01-01\")]),\n        pd.Series([pd.Timestamp(\"2018-01-01\", tz=\"US/Eastern\")]),\n    ]",
        "begin_line": 48,
        "end_line": 57,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.get_series_na#60",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.get_series_na()",
        "snippet": "def get_series_na():\n    return [\n        pd.Series([np.nan], dtype=\"Int64\"),\n        pd.Series([np.nan], dtype=\"float\"),\n        pd.Series([np.nan], dtype=\"object\"),\n        pd.Series([pd.NaT]),\n    ]",
        "begin_line": 60,
        "end_line": 66,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.series_of_dtype#70",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.series_of_dtype(request)",
        "snippet": "def series_of_dtype(request):\n    \"\"\"\n    A parametrized fixture returning a variety of Series of different\n    dtypes\n    \"\"\"\n    return request.param",
        "begin_line": 70,
        "end_line": 75,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.series_of_dtype2#79",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.series_of_dtype2(request)",
        "snippet": "def series_of_dtype2(request):\n    \"\"\"\n    A duplicate of the series_of_dtype fixture, so that it can be used\n    twice by a single function\n    \"\"\"\n    return request.param",
        "begin_line": 79,
        "end_line": 84,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.series_of_dtype_all_na#88",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.series_of_dtype_all_na(request)",
        "snippet": "def series_of_dtype_all_na(request):\n    \"\"\"\n    A parametrized fixture returning a variety of Series with all NA\n    values\n    \"\"\"\n    return request.param",
        "begin_line": 88,
        "end_line": 93,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.setup_method#97",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n        # aggregate multiple columns\n        self.df = DataFrame(\n            {\n                \"key1\": get_test_data(),\n                \"key2\": get_test_data(),\n                \"data1\": np.random.randn(N),\n                \"data2\": np.random.randn(N),\n            }\n        )\n\n        # exclude a couple keys for fun\n        self.df = self.df[self.df[\"key2\"] > 1]\n\n        self.df2 = DataFrame(\n            {\n                \"key1\": get_test_data(n=N // 5),\n                \"key2\": get_test_data(ngroups=NGROUPS // 2, n=N // 5),\n                \"value\": np.random.randn(N // 5),\n            }\n        )\n\n        self.left = DataFrame(\n            {\"key\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"e\", \"a\"], \"v1\": np.random.randn(7)}\n        )\n        self.right = DataFrame({\"v2\": np.random.randn(4)}, index=[\"d\", \"b\", \"c\", \"a\"])",
        "begin_line": 97,
        "end_line": 122,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_inner_join_empty#124",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_inner_join_empty(self)",
        "snippet": "    def test_merge_inner_join_empty(self):\n        # GH 15328\n        df_empty = pd.DataFrame()\n        df_a = pd.DataFrame({\"a\": [1, 2]}, index=[0, 1], dtype=\"int64\")\n        result = pd.merge(df_empty, df_a, left_index=True, right_index=True)\n        expected = pd.DataFrame({\"a\": []}, index=[], dtype=\"int64\")\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 124,
        "end_line": 130,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_common#132",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_common(self)",
        "snippet": "    def test_merge_common(self):\n        joined = merge(self.df, self.df2)\n        exp = merge(self.df, self.df2, on=[\"key1\", \"key2\"])\n        tm.assert_frame_equal(joined, exp)",
        "begin_line": 132,
        "end_line": 135,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_non_string_columns#137",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_non_string_columns(self)",
        "snippet": "    def test_merge_non_string_columns(self):\n        # https://github.com/pandas-dev/pandas/issues/17962\n        # Checks that method runs for non string column names\n        left = pd.DataFrame(\n            {0: [1, 0, 1, 0], 1: [0, 1, 0, 0], 2: [0, 0, 2, 0], 3: [1, 0, 0, 3]}\n        )\n\n        right = left.astype(float)\n        expected = left\n        result = pd.merge(left, right)\n        tm.assert_frame_equal(expected, result)",
        "begin_line": 137,
        "end_line": 147,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_index_as_on_arg#149",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_index_as_on_arg(self)",
        "snippet": "    def test_merge_index_as_on_arg(self):\n        # GH14355\n\n        left = self.df.set_index(\"key1\")\n        right = self.df2.set_index(\"key1\")\n        result = merge(left, right, on=\"key1\")\n        expected = merge(self.df, self.df2, on=\"key1\").set_index(\"key1\")\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 149,
        "end_line": 156,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_index_singlekey_right_vs_left#158",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_index_singlekey_right_vs_left(self)",
        "snippet": "    def test_merge_index_singlekey_right_vs_left(self):\n        left = DataFrame(\n            {\"key\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"e\", \"a\"], \"v1\": np.random.randn(7)}\n        )\n        right = DataFrame({\"v2\": np.random.randn(4)}, index=[\"d\", \"b\", \"c\", \"a\"])\n\n        merged1 = merge(\n            left, right, left_on=\"key\", right_index=True, how=\"left\", sort=False\n        )\n        merged2 = merge(\n            right, left, right_on=\"key\", left_index=True, how=\"right\", sort=False\n        )\n        tm.assert_frame_equal(merged1, merged2.loc[:, merged1.columns])\n\n        merged1 = merge(\n            left, right, left_on=\"key\", right_index=True, how=\"left\", sort=True\n        )\n        merged2 = merge(\n            right, left, right_on=\"key\", left_index=True, how=\"right\", sort=True\n        )\n        tm.assert_frame_equal(merged1, merged2.loc[:, merged1.columns])",
        "begin_line": 158,
        "end_line": 178,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_index_singlekey_inner#180",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_index_singlekey_inner(self)",
        "snippet": "    def test_merge_index_singlekey_inner(self):\n        left = DataFrame(\n            {\"key\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"e\", \"a\"], \"v1\": np.random.randn(7)}\n        )\n        right = DataFrame({\"v2\": np.random.randn(4)}, index=[\"d\", \"b\", \"c\", \"a\"])\n\n        # inner join\n        result = merge(left, right, left_on=\"key\", right_index=True, how=\"inner\")\n        expected = left.join(right, on=\"key\").loc[result.index]\n        tm.assert_frame_equal(result, expected)\n\n        result = merge(right, left, right_on=\"key\", left_index=True, how=\"inner\")\n        expected = left.join(right, on=\"key\").loc[result.index]\n        tm.assert_frame_equal(result, expected.loc[:, result.columns])",
        "begin_line": 180,
        "end_line": 193,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_misspecified#195",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_misspecified(self)",
        "snippet": "    def test_merge_misspecified(self):\n        msg = \"Must pass right_on or right_index=True\"\n        with pytest.raises(pd.errors.MergeError, match=msg):\n            merge(self.left, self.right, left_index=True)\n        msg = \"Must pass left_on or left_index=True\"\n        with pytest.raises(pd.errors.MergeError, match=msg):\n            merge(self.left, self.right, right_index=True)\n\n        msg = (\n            'Can only pass argument \"on\" OR \"left_on\" and \"right_on\", not '\n            \"a combination of both\"\n        )\n        with pytest.raises(pd.errors.MergeError, match=msg):\n            merge(self.left, self.left, left_on=\"key\", on=\"key\")\n\n        msg = r\"len\\(right_on\\) must equal len\\(left_on\\)\"\n        with pytest.raises(ValueError, match=msg):\n            merge(self.df, self.df2, left_on=[\"key1\"], right_on=[\"key1\", \"key2\"])",
        "begin_line": 195,
        "end_line": 212,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_index_and_on_parameters_confusion#214",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_index_and_on_parameters_confusion(self)",
        "snippet": "    def test_index_and_on_parameters_confusion(self):\n        msg = \"right_index parameter must be of type bool, not <class 'list'>\"\n        with pytest.raises(ValueError, match=msg):\n            merge(\n                self.df,\n                self.df2,\n                how=\"left\",\n                left_index=False,\n                right_index=[\"key1\", \"key2\"],\n            )\n        msg = \"left_index parameter must be of type bool, not <class 'list'>\"\n        with pytest.raises(ValueError, match=msg):\n            merge(\n                self.df,\n                self.df2,\n                how=\"left\",\n                left_index=[\"key1\", \"key2\"],\n                right_index=False,\n            )\n        with pytest.raises(ValueError, match=msg):\n            merge(\n                self.df,\n                self.df2,\n                how=\"left\",\n                left_index=[\"key1\", \"key2\"],\n                right_index=[\"key1\", \"key2\"],\n            )",
        "begin_line": 214,
        "end_line": 240,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_overlap#242",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_overlap(self)",
        "snippet": "    def test_merge_overlap(self):\n        merged = merge(self.left, self.left, on=\"key\")\n        exp_len = (self.left[\"key\"].value_counts() ** 2).sum()\n        assert len(merged) == exp_len\n        assert \"v1_x\" in merged\n        assert \"v1_y\" in merged",
        "begin_line": 242,
        "end_line": 247,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_different_column_key_names#249",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_different_column_key_names(self)",
        "snippet": "    def test_merge_different_column_key_names(self):\n        left = DataFrame({\"lkey\": [\"foo\", \"bar\", \"baz\", \"foo\"], \"value\": [1, 2, 3, 4]})\n        right = DataFrame({\"rkey\": [\"foo\", \"bar\", \"qux\", \"foo\"], \"value\": [5, 6, 7, 8]})\n\n        merged = left.merge(\n            right, left_on=\"lkey\", right_on=\"rkey\", how=\"outer\", sort=True\n        )\n\n        exp = pd.Series([\"bar\", \"baz\", \"foo\", \"foo\", \"foo\", \"foo\", np.nan], name=\"lkey\")\n        tm.assert_series_equal(merged[\"lkey\"], exp)\n\n        exp = pd.Series([\"bar\", np.nan, \"foo\", \"foo\", \"foo\", \"foo\", \"qux\"], name=\"rkey\")\n        tm.assert_series_equal(merged[\"rkey\"], exp)\n\n        exp = pd.Series([2, 3, 1, 1, 4, 4, np.nan], name=\"value_x\")\n        tm.assert_series_equal(merged[\"value_x\"], exp)\n\n        exp = pd.Series([6, np.nan, 5, 8, 5, 8, 7], name=\"value_y\")\n        tm.assert_series_equal(merged[\"value_y\"], exp)",
        "begin_line": 249,
        "end_line": 267,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_copy#269",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_copy(self)",
        "snippet": "    def test_merge_copy(self):\n        left = DataFrame({\"a\": 0, \"b\": 1}, index=range(10))\n        right = DataFrame({\"c\": \"foo\", \"d\": \"bar\"}, index=range(10))\n\n        merged = merge(left, right, left_index=True, right_index=True, copy=True)\n\n        merged[\"a\"] = 6\n        assert (left[\"a\"] == 0).all()\n\n        merged[\"d\"] = \"peekaboo\"\n        assert (right[\"d\"] == \"bar\").all()",
        "begin_line": 269,
        "end_line": 279,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_nocopy#281",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_nocopy(self)",
        "snippet": "    def test_merge_nocopy(self):\n        left = DataFrame({\"a\": 0, \"b\": 1}, index=range(10))\n        right = DataFrame({\"c\": \"foo\", \"d\": \"bar\"}, index=range(10))\n\n        merged = merge(left, right, left_index=True, right_index=True, copy=False)\n\n        merged[\"a\"] = 6\n        assert (left[\"a\"] == 6).all()\n\n        merged[\"d\"] = \"peekaboo\"\n        assert (right[\"d\"] == \"peekaboo\").all()",
        "begin_line": 281,
        "end_line": 291,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_intelligently_handle_join_key#293",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_intelligently_handle_join_key(self)",
        "snippet": "    def test_intelligently_handle_join_key(self):\n        # #733, be a bit more 1337 about not returning unconsolidated DataFrame\n\n        left = DataFrame(\n            {\"key\": [1, 1, 2, 2, 3], \"value\": list(range(5))}, columns=[\"value\", \"key\"]\n        )\n        right = DataFrame({\"key\": [1, 1, 2, 3, 4, 5], \"rvalue\": list(range(6))})\n\n        joined = merge(left, right, on=\"key\", how=\"outer\")\n        expected = DataFrame(\n            {\n                \"key\": [1, 1, 1, 1, 2, 2, 3, 4, 5],\n                \"value\": np.array([0, 0, 1, 1, 2, 3, 4, np.nan, np.nan]),\n                \"rvalue\": [0, 1, 0, 1, 2, 2, 3, 4, 5],\n            },\n            columns=[\"value\", \"key\", \"rvalue\"],\n        )\n        tm.assert_frame_equal(joined, expected)",
        "begin_line": 293,
        "end_line": 310,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_join_key_dtype_cast#312",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_join_key_dtype_cast(self)",
        "snippet": "    def test_merge_join_key_dtype_cast(self):\n        # #8596\n\n        df1 = DataFrame({\"key\": [1], \"v1\": [10]})\n        df2 = DataFrame({\"key\": [2], \"v1\": [20]})\n        df = merge(df1, df2, how=\"outer\")\n        assert df[\"key\"].dtype == \"int64\"\n\n        df1 = DataFrame({\"key\": [True], \"v1\": [1]})\n        df2 = DataFrame({\"key\": [False], \"v1\": [0]})\n        df = merge(df1, df2, how=\"outer\")\n\n        # GH13169\n        # this really should be bool\n        assert df[\"key\"].dtype == \"object\"\n\n        df1 = DataFrame({\"val\": [1]})\n        df2 = DataFrame({\"val\": [2]})\n        lkey = np.array([1])\n        rkey = np.array([2])\n        df = merge(df1, df2, left_on=lkey, right_on=rkey, how=\"outer\")\n        assert df[\"key_0\"].dtype == \"int64\"",
        "begin_line": 312,
        "end_line": 333,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_handle_join_key_pass_array#335",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_handle_join_key_pass_array(self)",
        "snippet": "    def test_handle_join_key_pass_array(self):\n        left = DataFrame(\n            {\"key\": [1, 1, 2, 2, 3], \"value\": np.arange(5)}, columns=[\"value\", \"key\"]\n        )\n        right = DataFrame({\"rvalue\": np.arange(6)})\n        key = np.array([1, 1, 2, 3, 4, 5])\n\n        merged = merge(left, right, left_on=\"key\", right_on=key, how=\"outer\")\n        merged2 = merge(right, left, left_on=key, right_on=\"key\", how=\"outer\")\n\n        tm.assert_series_equal(merged[\"key\"], merged2[\"key\"])\n        assert merged[\"key\"].notna().all()\n        assert merged2[\"key\"].notna().all()\n\n        left = DataFrame({\"value\": np.arange(5)}, columns=[\"value\"])\n        right = DataFrame({\"rvalue\": np.arange(6)})\n        lkey = np.array([1, 1, 2, 2, 3])\n        rkey = np.array([1, 1, 2, 3, 4, 5])\n\n        merged = merge(left, right, left_on=lkey, right_on=rkey, how=\"outer\")\n        tm.assert_series_equal(\n            merged[\"key_0\"], Series([1, 1, 1, 1, 2, 2, 3, 4, 5], name=\"key_0\")\n        )\n\n        left = DataFrame({\"value\": np.arange(3)})\n        right = DataFrame({\"rvalue\": np.arange(6)})\n\n        key = np.array([0, 1, 1, 2, 2, 3], dtype=np.int64)\n        merged = merge(left, right, left_index=True, right_on=key, how=\"outer\")\n        tm.assert_series_equal(merged[\"key_0\"], Series(key, name=\"key_0\"))",
        "begin_line": 335,
        "end_line": 364,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_no_overlap_more_informative_error#366",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_no_overlap_more_informative_error(self)",
        "snippet": "    def test_no_overlap_more_informative_error(self):\n        dt = datetime.now()\n        df1 = DataFrame({\"x\": [\"a\"]}, index=[dt])\n\n        df2 = DataFrame({\"y\": [\"b\", \"c\"]}, index=[dt, dt])\n\n        msg = (\n            \"No common columns to perform merge on. \"\n            f\"Merge options: left_on={None}, right_on={None}, \"\n            f\"left_index={False}, right_index={False}\"\n        )\n\n        with pytest.raises(MergeError, match=msg):\n            merge(df1, df2)",
        "begin_line": 366,
        "end_line": 379,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_non_unique_indexes#381",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_non_unique_indexes(self)",
        "snippet": "    def test_merge_non_unique_indexes(self):\n\n        dt = datetime(2012, 5, 1)\n        dt2 = datetime(2012, 5, 2)\n        dt3 = datetime(2012, 5, 3)\n        dt4 = datetime(2012, 5, 4)\n\n        df1 = DataFrame({\"x\": [\"a\"]}, index=[dt])\n        df2 = DataFrame({\"y\": [\"b\", \"c\"]}, index=[dt, dt])\n        _check_merge(df1, df2)\n\n        # Not monotonic\n        df1 = DataFrame({\"x\": [\"a\", \"b\", \"q\"]}, index=[dt2, dt, dt4])\n        df2 = DataFrame(\n            {\"y\": [\"c\", \"d\", \"e\", \"f\", \"g\", \"h\"]}, index=[dt3, dt3, dt2, dt2, dt, dt]\n        )\n        _check_merge(df1, df2)\n\n        df1 = DataFrame({\"x\": [\"a\", \"b\"]}, index=[dt, dt])\n        df2 = DataFrame({\"y\": [\"c\", \"d\"]}, index=[dt, dt])\n        _check_merge(df1, df2)",
        "begin_line": 381,
        "end_line": 401,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_non_unique_index_many_to_many#403",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_non_unique_index_many_to_many(self)",
        "snippet": "    def test_merge_non_unique_index_many_to_many(self):\n        dt = datetime(2012, 5, 1)\n        dt2 = datetime(2012, 5, 2)\n        dt3 = datetime(2012, 5, 3)\n        df1 = DataFrame({\"x\": [\"a\", \"b\", \"c\", \"d\"]}, index=[dt2, dt2, dt, dt])\n        df2 = DataFrame(\n            {\"y\": [\"e\", \"f\", \"g\", \" h\", \"i\"]}, index=[dt2, dt2, dt3, dt, dt]\n        )\n        _check_merge(df1, df2)",
        "begin_line": 403,
        "end_line": 411,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_left_merge_empty_dataframe#413",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_left_merge_empty_dataframe(self)",
        "snippet": "    def test_left_merge_empty_dataframe(self):\n        left = DataFrame({\"key\": [1], \"value\": [2]})\n        right = DataFrame({\"key\": []})\n\n        result = merge(left, right, on=\"key\", how=\"left\")\n        tm.assert_frame_equal(result, left)\n\n        result = merge(right, left, on=\"key\", how=\"right\")\n        tm.assert_frame_equal(result, left)",
        "begin_line": 413,
        "end_line": 421,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_left_empty_right_empty#432",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_left_empty_right_empty(self, join_type, kwarg)",
        "snippet": "    def test_merge_left_empty_right_empty(self, join_type, kwarg):\n        # GH 10824\n        left = pd.DataFrame(columns=[\"a\", \"b\", \"c\"])\n        right = pd.DataFrame(columns=[\"x\", \"y\", \"z\"])\n\n        exp_in = pd.DataFrame(\n            columns=[\"a\", \"b\", \"c\", \"x\", \"y\", \"z\"],\n            index=pd.Index([], dtype=object),\n            dtype=object,\n        )\n\n        result = pd.merge(left, right, how=join_type, **kwarg)\n        tm.assert_frame_equal(result, exp_in)",
        "begin_line": 432,
        "end_line": 444,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_left_empty_right_notempty#446",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_left_empty_right_notempty(self)",
        "snippet": "    def test_merge_left_empty_right_notempty(self):\n        # GH 10824\n        left = pd.DataFrame(columns=[\"a\", \"b\", \"c\"])\n        right = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns=[\"x\", \"y\", \"z\"])\n\n        exp_out = pd.DataFrame(\n            {\n                \"a\": np.array([np.nan] * 3, dtype=object),\n                \"b\": np.array([np.nan] * 3, dtype=object),\n                \"c\": np.array([np.nan] * 3, dtype=object),\n                \"x\": [1, 4, 7],\n                \"y\": [2, 5, 8],\n                \"z\": [3, 6, 9],\n            },\n            columns=[\"a\", \"b\", \"c\", \"x\", \"y\", \"z\"],\n        )\n        exp_in = exp_out[0:0]  # make empty DataFrame keeping dtype\n        # result will have object dtype\n        exp_in.index = exp_in.index.astype(object)\n\n        def check1(exp, kwarg):\n            result = pd.merge(left, right, how=\"inner\", **kwarg)\n            tm.assert_frame_equal(result, exp)\n            result = pd.merge(left, right, how=\"left\", **kwarg)\n            tm.assert_frame_equal(result, exp)\n\n        def check2(exp, kwarg):\n            result = pd.merge(left, right, how=\"right\", **kwarg)\n            tm.assert_frame_equal(result, exp)\n            result = pd.merge(left, right, how=\"outer\", **kwarg)\n            tm.assert_frame_equal(result, exp)\n\n        for kwarg in [\n            dict(left_index=True, right_index=True),\n            dict(left_index=True, right_on=\"x\"),\n        ]:\n            check1(exp_in, kwarg)\n            check2(exp_out, kwarg)\n\n        kwarg = dict(left_on=\"a\", right_index=True)\n        check1(exp_in, kwarg)\n        exp_out[\"a\"] = [0, 1, 2]\n        check2(exp_out, kwarg)\n\n        kwarg = dict(left_on=\"a\", right_on=\"x\")\n        check1(exp_in, kwarg)\n        exp_out[\"a\"] = np.array([np.nan] * 3, dtype=object)\n        check2(exp_out, kwarg)",
        "begin_line": 446,
        "end_line": 493,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.check1#466",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.check1(exp, kwarg)",
        "snippet": "        def check1(exp, kwarg):\n            result = pd.merge(left, right, how=\"inner\", **kwarg)\n            tm.assert_frame_equal(result, exp)\n            result = pd.merge(left, right, how=\"left\", **kwarg)\n            tm.assert_frame_equal(result, exp)",
        "begin_line": 466,
        "end_line": 470,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.check2#472",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.check2(exp, kwarg)",
        "snippet": "        def check2(exp, kwarg):\n            result = pd.merge(left, right, how=\"right\", **kwarg)\n            tm.assert_frame_equal(result, exp)\n            result = pd.merge(left, right, how=\"outer\", **kwarg)\n            tm.assert_frame_equal(result, exp)",
        "begin_line": 472,
        "end_line": 476,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_left_notempty_right_empty#495",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_left_notempty_right_empty(self)",
        "snippet": "    def test_merge_left_notempty_right_empty(self):\n        # GH 10824\n        left = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], columns=[\"a\", \"b\", \"c\"])\n        right = pd.DataFrame(columns=[\"x\", \"y\", \"z\"])\n\n        exp_out = pd.DataFrame(\n            {\n                \"a\": [1, 4, 7],\n                \"b\": [2, 5, 8],\n                \"c\": [3, 6, 9],\n                \"x\": np.array([np.nan] * 3, dtype=object),\n                \"y\": np.array([np.nan] * 3, dtype=object),\n                \"z\": np.array([np.nan] * 3, dtype=object),\n            },\n            columns=[\"a\", \"b\", \"c\", \"x\", \"y\", \"z\"],\n        )\n        exp_in = exp_out[0:0]  # make empty DataFrame keeping dtype\n        # result will have object dtype\n        exp_in.index = exp_in.index.astype(object)\n\n        def check1(exp, kwarg):\n            result = pd.merge(left, right, how=\"inner\", **kwarg)\n            tm.assert_frame_equal(result, exp)\n            result = pd.merge(left, right, how=\"right\", **kwarg)\n            tm.assert_frame_equal(result, exp)\n\n        def check2(exp, kwarg):\n            result = pd.merge(left, right, how=\"left\", **kwarg)\n            tm.assert_frame_equal(result, exp)\n            result = pd.merge(left, right, how=\"outer\", **kwarg)\n            tm.assert_frame_equal(result, exp)\n\n            for kwarg in [\n                dict(left_index=True, right_index=True),\n                dict(left_index=True, right_on=\"x\"),\n                dict(left_on=\"a\", right_index=True),\n                dict(left_on=\"a\", right_on=\"x\"),\n            ]:\n                check1(exp_in, kwarg)\n                check2(exp_out, kwarg)",
        "begin_line": 495,
        "end_line": 534,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.check1#515",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.check1(exp, kwarg)",
        "snippet": "        def check1(exp, kwarg):\n            result = pd.merge(left, right, how=\"inner\", **kwarg)\n            tm.assert_frame_equal(result, exp)\n            result = pd.merge(left, right, how=\"right\", **kwarg)\n            tm.assert_frame_equal(result, exp)",
        "begin_line": 515,
        "end_line": 519,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.check2#521",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.check2(exp, kwarg)",
        "snippet": "        def check2(exp, kwarg):\n            result = pd.merge(left, right, how=\"left\", **kwarg)\n            tm.assert_frame_equal(result, exp)\n            result = pd.merge(left, right, how=\"outer\", **kwarg)\n            tm.assert_frame_equal(result, exp)\n\n            for kwarg in [\n                dict(left_index=True, right_index=True),\n                dict(left_index=True, right_on=\"x\"),\n                dict(left_on=\"a\", right_index=True),\n                dict(left_on=\"a\", right_on=\"x\"),\n            ]:\n                check1(exp_in, kwarg)\n                check2(exp_out, kwarg)",
        "begin_line": 521,
        "end_line": 534,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_empty_frame#536",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_empty_frame(self, series_of_dtype, series_of_dtype2)",
        "snippet": "    def test_merge_empty_frame(self, series_of_dtype, series_of_dtype2):\n        # GH 25183\n        df = pd.DataFrame(\n            {\"key\": series_of_dtype, \"value\": series_of_dtype2},\n            columns=[\"key\", \"value\"],\n        )\n        df_empty = df[:0]\n        expected = pd.DataFrame(\n            {\n                \"value_x\": pd.Series(dtype=df.dtypes[\"value\"]),\n                \"key\": pd.Series(dtype=df.dtypes[\"key\"]),\n                \"value_y\": pd.Series(dtype=df.dtypes[\"value\"]),\n            },\n            columns=[\"value_x\", \"key\", \"value_y\"],\n        )\n        actual = df_empty.merge(df, on=\"key\")\n        tm.assert_frame_equal(actual, expected)",
        "begin_line": 536,
        "end_line": 552,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_all_na_column#554",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_all_na_column(self, series_of_dtype, series_of_dtype_all_na)",
        "snippet": "    def test_merge_all_na_column(self, series_of_dtype, series_of_dtype_all_na):\n        # GH 25183\n        df_left = pd.DataFrame(\n            {\"key\": series_of_dtype, \"value\": series_of_dtype_all_na},\n            columns=[\"key\", \"value\"],\n        )\n        df_right = pd.DataFrame(\n            {\"key\": series_of_dtype, \"value\": series_of_dtype_all_na},\n            columns=[\"key\", \"value\"],\n        )\n        expected = pd.DataFrame(\n            {\n                \"key\": series_of_dtype,\n                \"value_x\": series_of_dtype_all_na,\n                \"value_y\": series_of_dtype_all_na,\n            },\n            columns=[\"key\", \"value_x\", \"value_y\"],\n        )\n        actual = df_left.merge(df_right, on=\"key\")\n        tm.assert_frame_equal(actual, expected)",
        "begin_line": 554,
        "end_line": 573,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_nosort#575",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_nosort(self)",
        "snippet": "    def test_merge_nosort(self):\n        # GH#2098, TODO: anything to do?\n\n        d = {\n            \"var1\": np.random.randint(0, 10, size=10),\n            \"var2\": np.random.randint(0, 10, size=10),\n            \"var3\": [\n                datetime(2012, 1, 12),\n                datetime(2011, 2, 4),\n                datetime(2010, 2, 3),\n                datetime(2012, 1, 12),\n                datetime(2011, 2, 4),\n                datetime(2012, 4, 3),\n                datetime(2012, 3, 4),\n                datetime(2008, 5, 1),\n                datetime(2010, 2, 3),\n                datetime(2012, 2, 3),\n            ],\n        }\n        df = DataFrame.from_dict(d)\n        var3 = df.var3.unique()\n        var3.sort()\n        new = DataFrame.from_dict({\"var3\": var3, \"var8\": np.random.random(7)})\n\n        result = df.merge(new, on=\"var3\", sort=False)\n        exp = merge(df, new, on=\"var3\", sort=False)\n        tm.assert_frame_equal(result, exp)\n\n        assert (df.var3.unique() == result.var3.unique()).all()",
        "begin_line": 575,
        "end_line": 603,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_nan_right#605",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_nan_right(self)",
        "snippet": "    def test_merge_nan_right(self):\n        df1 = DataFrame({\"i1\": [0, 1], \"i2\": [0, 1]})\n        df2 = DataFrame({\"i1\": [0], \"i3\": [0]})\n        result = df1.join(df2, on=\"i1\", rsuffix=\"_\")\n        expected = (\n            DataFrame(\n                {\n                    \"i1\": {0: 0.0, 1: 1},\n                    \"i2\": {0: 0, 1: 1},\n                    \"i1_\": {0: 0, 1: np.nan},\n                    \"i3\": {0: 0.0, 1: np.nan},\n                    None: {0: 0, 1: 0},\n                }\n            )\n            .set_index(None)\n            .reset_index()[[\"i1\", \"i2\", \"i1_\", \"i3\"]]\n        )\n        tm.assert_frame_equal(result, expected, check_dtype=False)\n\n        df1 = DataFrame({\"i1\": [0, 1], \"i2\": [0.5, 1.5]})\n        df2 = DataFrame({\"i1\": [0], \"i3\": [0.7]})\n        result = df1.join(df2, rsuffix=\"_\", on=\"i1\")\n        expected = DataFrame(\n            {\n                \"i1\": {0: 0, 1: 1},\n                \"i1_\": {0: 0.0, 1: np.nan},\n                \"i2\": {0: 0.5, 1: 1.5},\n                \"i3\": {0: 0.69999999999999996, 1: np.nan},\n            }\n        )[[\"i1\", \"i2\", \"i1_\", \"i3\"]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 605,
        "end_line": 635,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_type#637",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_type(self)",
        "snippet": "    def test_merge_type(self):\n        class NotADataFrame(DataFrame):\n            @property\n            def _constructor(self):\n                return NotADataFrame\n\n        nad = NotADataFrame(self.df)\n        result = nad.merge(self.df2, on=\"key1\")\n\n        assert isinstance(result, NotADataFrame)",
        "begin_line": 637,
        "end_line": 646,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.NotADataFrame.test_merge_type#637",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.NotADataFrame",
        "signature": "pandas.tests.reshape.merge.test_merge.NotADataFrame.test_merge_type(self)",
        "snippet": "    def test_merge_type(self):\n        class NotADataFrame(DataFrame):\n            @property\n            def _constructor(self):\n                return NotADataFrame\n\n        nad = NotADataFrame(self.df)\n        result = nad.merge(self.df2, on=\"key1\")\n\n        assert isinstance(result, NotADataFrame)",
        "begin_line": 637,
        "end_line": 646,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.NotADataFrame._constructor#640",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.NotADataFrame",
        "signature": "pandas.tests.reshape.merge.test_merge.NotADataFrame._constructor(self)",
        "snippet": "            def _constructor(self):\n                return NotADataFrame",
        "begin_line": 640,
        "end_line": 641,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_join_append_timedeltas#648",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_join_append_timedeltas(self)",
        "snippet": "    def test_join_append_timedeltas(self):\n        # timedelta64 issues with join/merge\n        # GH 5695\n\n        d = {\"d\": datetime(2013, 11, 5, 5, 56), \"t\": timedelta(0, 22500)}\n        df = DataFrame(columns=list(\"dt\"))\n        df = df.append(d, ignore_index=True)\n        result = df.append(d, ignore_index=True)\n        expected = DataFrame(\n            {\n                \"d\": [datetime(2013, 11, 5, 5, 56), datetime(2013, 11, 5, 5, 56)],\n                \"t\": [timedelta(0, 22500), timedelta(0, 22500)],\n            }\n        )\n        tm.assert_frame_equal(result, expected)\n\n        td = np.timedelta64(300000000)\n        lhs = DataFrame(Series([td, td], index=[\"A\", \"B\"]))\n        rhs = DataFrame(Series([td], index=[\"A\"]))\n\n        result = lhs.join(rhs, rsuffix=\"r\", how=\"left\")\n        expected = DataFrame(\n            {\n                \"0\": Series([td, td], index=list(\"AB\")),\n                \"0r\": Series([td, pd.NaT], index=list(\"AB\")),\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 648,
        "end_line": 675,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_other_datetime_unit#677",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_other_datetime_unit(self)",
        "snippet": "    def test_other_datetime_unit(self):\n        # GH 13389\n        df1 = pd.DataFrame({\"entity_id\": [101, 102]})\n        s = pd.Series([None, None], index=[101, 102], name=\"days\")\n\n        for dtype in [\n            \"datetime64[D]\",\n            \"datetime64[h]\",\n            \"datetime64[m]\",\n            \"datetime64[s]\",\n            \"datetime64[ms]\",\n            \"datetime64[us]\",\n            \"datetime64[ns]\",\n        ]:\n\n            df2 = s.astype(dtype).to_frame(\"days\")\n            # coerces to datetime64[ns], thus should not be affected\n            assert df2[\"days\"].dtype == \"datetime64[ns]\"\n\n            result = df1.merge(df2, left_on=\"entity_id\", right_index=True)\n\n            exp = pd.DataFrame(\n                {\n                    \"entity_id\": [101, 102],\n                    \"days\": np.array([\"nat\", \"nat\"], dtype=\"datetime64[ns]\"),\n                },\n                columns=[\"entity_id\", \"days\"],\n            )\n            tm.assert_frame_equal(result, exp)",
        "begin_line": 677,
        "end_line": 705,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_other_timedelta_unit#708",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_other_timedelta_unit(self, unit)",
        "snippet": "    def test_other_timedelta_unit(self, unit):\n        # GH 13389\n        df1 = pd.DataFrame({\"entity_id\": [101, 102]})\n        s = pd.Series([None, None], index=[101, 102], name=\"days\")\n\n        dtype = f\"m8[{unit}]\"\n        df2 = s.astype(dtype).to_frame(\"days\")\n        assert df2[\"days\"].dtype == \"m8[ns]\"\n\n        result = df1.merge(df2, left_on=\"entity_id\", right_index=True)\n\n        exp = pd.DataFrame(\n            {\"entity_id\": [101, 102], \"days\": np.array([\"nat\", \"nat\"], dtype=dtype)},\n            columns=[\"entity_id\", \"days\"],\n        )\n        tm.assert_frame_equal(result, exp)",
        "begin_line": 708,
        "end_line": 723,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_overlapping_columns_error_message#725",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_overlapping_columns_error_message(self)",
        "snippet": "    def test_overlapping_columns_error_message(self):\n        df = DataFrame({\"key\": [1, 2, 3], \"v1\": [4, 5, 6], \"v2\": [7, 8, 9]})\n        df2 = DataFrame({\"key\": [1, 2, 3], \"v1\": [4, 5, 6], \"v2\": [7, 8, 9]})\n\n        df.columns = [\"key\", \"foo\", \"foo\"]\n        df2.columns = [\"key\", \"bar\", \"bar\"]\n        expected = DataFrame(\n            {\n                \"key\": [1, 2, 3],\n                \"v1\": [4, 5, 6],\n                \"v2\": [7, 8, 9],\n                \"v3\": [4, 5, 6],\n                \"v4\": [7, 8, 9],\n            }\n        )\n        expected.columns = [\"key\", \"foo\", \"foo\", \"bar\", \"bar\"]\n        tm.assert_frame_equal(merge(df, df2), expected)\n\n        # #2649, #10639\n        df2.columns = [\"key1\", \"foo\", \"foo\"]\n        msg = r\"Data columns not unique: Index\\(\\['foo', 'foo'\\], dtype='object'\\)\"\n        with pytest.raises(MergeError, match=msg):\n            merge(df, df2)",
        "begin_line": 725,
        "end_line": 747,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_on_datetime64tz#749",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_on_datetime64tz(self)",
        "snippet": "    def test_merge_on_datetime64tz(self):\n\n        # GH11405\n        left = pd.DataFrame(\n            {\n                \"key\": pd.date_range(\"20151010\", periods=2, tz=\"US/Eastern\"),\n                \"value\": [1, 2],\n            }\n        )\n        right = pd.DataFrame(\n            {\n                \"key\": pd.date_range(\"20151011\", periods=3, tz=\"US/Eastern\"),\n                \"value\": [1, 2, 3],\n            }\n        )\n\n        expected = DataFrame(\n            {\n                \"key\": pd.date_range(\"20151010\", periods=4, tz=\"US/Eastern\"),\n                \"value_x\": [1, 2, np.nan, np.nan],\n                \"value_y\": [np.nan, 1, 2, 3],\n            }\n        )\n        result = pd.merge(left, right, on=\"key\", how=\"outer\")\n        tm.assert_frame_equal(result, expected)\n\n        left = pd.DataFrame(\n            {\n                \"key\": [1, 2],\n                \"value\": pd.date_range(\"20151010\", periods=2, tz=\"US/Eastern\"),\n            }\n        )\n        right = pd.DataFrame(\n            {\n                \"key\": [2, 3],\n                \"value\": pd.date_range(\"20151011\", periods=2, tz=\"US/Eastern\"),\n            }\n        )\n        expected = DataFrame(\n            {\n                \"key\": [1, 2, 3],\n                \"value_x\": list(pd.date_range(\"20151010\", periods=2, tz=\"US/Eastern\"))\n                + [pd.NaT],\n                \"value_y\": [pd.NaT]\n                + list(pd.date_range(\"20151011\", periods=2, tz=\"US/Eastern\")),\n            }\n        )\n        result = pd.merge(left, right, on=\"key\", how=\"outer\")\n        tm.assert_frame_equal(result, expected)\n        assert result[\"value_x\"].dtype == \"datetime64[ns, US/Eastern]\"\n        assert result[\"value_y\"].dtype == \"datetime64[ns, US/Eastern]\"",
        "begin_line": 749,
        "end_line": 799,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_on_datetime64tz_empty#801",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_on_datetime64tz_empty(self)",
        "snippet": "    def test_merge_on_datetime64tz_empty(self):\n        # https://github.com/pandas-dev/pandas/issues/25014\n        dtz = pd.DatetimeTZDtype(tz=\"UTC\")\n        right = pd.DataFrame(\n            {\n                \"date\": [pd.Timestamp(\"2018\", tz=dtz.tz)],\n                \"value\": [4.0],\n                \"date2\": [pd.Timestamp(\"2019\", tz=dtz.tz)],\n            },\n            columns=[\"date\", \"value\", \"date2\"],\n        )\n        left = right[:0]\n        result = left.merge(right, on=\"date\")\n        expected = pd.DataFrame(\n            {\n                \"value_x\": pd.Series(dtype=float),\n                \"date2_x\": pd.Series(dtype=dtz),\n                \"date\": pd.Series(dtype=dtz),\n                \"value_y\": pd.Series(dtype=float),\n                \"date2_y\": pd.Series(dtype=dtz),\n            },\n            columns=[\"value_x\", \"date2_x\", \"date\", \"value_y\", \"date2_y\"],\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 801,
        "end_line": 824,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_datetime64tz_with_dst_transition#826",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_datetime64tz_with_dst_transition(self)",
        "snippet": "    def test_merge_datetime64tz_with_dst_transition(self):\n        # GH 18885\n        df1 = pd.DataFrame(\n            pd.date_range(\"2017-10-29 01:00\", periods=4, freq=\"H\", tz=\"Europe/Madrid\"),\n            columns=[\"date\"],\n        )\n        df1[\"value\"] = 1\n        df2 = pd.DataFrame(\n            {\n                \"date\": pd.to_datetime(\n                    [\n                        \"2017-10-29 03:00:00\",\n                        \"2017-10-29 04:00:00\",\n                        \"2017-10-29 05:00:00\",\n                    ]\n                ),\n                \"value\": 2,\n            }\n        )\n        df2[\"date\"] = df2[\"date\"].dt.tz_localize(\"UTC\").dt.tz_convert(\"Europe/Madrid\")\n        result = pd.merge(df1, df2, how=\"outer\", on=\"date\")\n        expected = pd.DataFrame(\n            {\n                \"date\": pd.date_range(\n                    \"2017-10-29 01:00\", periods=7, freq=\"H\", tz=\"Europe/Madrid\"\n                ),\n                \"value_x\": [1] * 4 + [np.nan] * 3,\n                \"value_y\": [np.nan] * 4 + [2] * 3,\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 826,
        "end_line": 856,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_non_unique_period_index#858",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_non_unique_period_index(self)",
        "snippet": "    def test_merge_non_unique_period_index(self):\n        # GH #16871\n        index = pd.period_range(\"2016-01-01\", periods=16, freq=\"M\")\n        df = DataFrame(list(range(len(index))), index=index, columns=[\"pnum\"])\n        df2 = concat([df, df])\n        result = df.merge(df2, left_index=True, right_index=True, how=\"inner\")\n        expected = DataFrame(\n            np.tile(np.arange(16, dtype=np.int64).repeat(2).reshape(-1, 1), 2),\n            columns=[\"pnum_x\", \"pnum_y\"],\n            index=df2.sort_index().index,\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 858,
        "end_line": 869,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_on_periods#871",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_on_periods(self)",
        "snippet": "    def test_merge_on_periods(self):\n        left = pd.DataFrame(\n            {\"key\": pd.period_range(\"20151010\", periods=2, freq=\"D\"), \"value\": [1, 2]}\n        )\n        right = pd.DataFrame(\n            {\n                \"key\": pd.period_range(\"20151011\", periods=3, freq=\"D\"),\n                \"value\": [1, 2, 3],\n            }\n        )\n\n        expected = DataFrame(\n            {\n                \"key\": pd.period_range(\"20151010\", periods=4, freq=\"D\"),\n                \"value_x\": [1, 2, np.nan, np.nan],\n                \"value_y\": [np.nan, 1, 2, 3],\n            }\n        )\n        result = pd.merge(left, right, on=\"key\", how=\"outer\")\n        tm.assert_frame_equal(result, expected)\n\n        left = pd.DataFrame(\n            {\"key\": [1, 2], \"value\": pd.period_range(\"20151010\", periods=2, freq=\"D\")}\n        )\n        right = pd.DataFrame(\n            {\"key\": [2, 3], \"value\": pd.period_range(\"20151011\", periods=2, freq=\"D\")}\n        )\n\n        exp_x = pd.period_range(\"20151010\", periods=2, freq=\"D\")\n        exp_y = pd.period_range(\"20151011\", periods=2, freq=\"D\")\n        expected = DataFrame(\n            {\n                \"key\": [1, 2, 3],\n                \"value_x\": list(exp_x) + [pd.NaT],\n                \"value_y\": [pd.NaT] + list(exp_y),\n            }\n        )\n        result = pd.merge(left, right, on=\"key\", how=\"outer\")\n        tm.assert_frame_equal(result, expected)\n        assert result[\"value_x\"].dtype == \"Period[D]\"\n        assert result[\"value_y\"].dtype == \"Period[D]\"",
        "begin_line": 871,
        "end_line": 911,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_indicator#913",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_indicator(self)",
        "snippet": "    def test_indicator(self):\n        # PR #10054. xref #7412 and closes #8790.\n        df1 = DataFrame(\n            {\"col1\": [0, 1], \"col_conflict\": [1, 2], \"col_left\": [\"a\", \"b\"]}\n        )\n        df1_copy = df1.copy()\n\n        df2 = DataFrame(\n            {\n                \"col1\": [1, 2, 3, 4, 5],\n                \"col_conflict\": [1, 2, 3, 4, 5],\n                \"col_right\": [2, 2, 2, 2, 2],\n            }\n        )\n        df2_copy = df2.copy()\n\n        df_result = DataFrame(\n            {\n                \"col1\": [0, 1, 2, 3, 4, 5],\n                \"col_conflict_x\": [1, 2, np.nan, np.nan, np.nan, np.nan],\n                \"col_left\": [\"a\", \"b\", np.nan, np.nan, np.nan, np.nan],\n                \"col_conflict_y\": [np.nan, 1, 2, 3, 4, 5],\n                \"col_right\": [np.nan, 2, 2, 2, 2, 2],\n            }\n        )\n        df_result[\"_merge\"] = Categorical(\n            [\n                \"left_only\",\n                \"both\",\n                \"right_only\",\n                \"right_only\",\n                \"right_only\",\n                \"right_only\",\n            ],\n            categories=[\"left_only\", \"right_only\", \"both\"],\n        )\n\n        df_result = df_result[\n            [\n                \"col1\",\n                \"col_conflict_x\",\n                \"col_left\",\n                \"col_conflict_y\",\n                \"col_right\",\n                \"_merge\",\n            ]\n        ]\n\n        test = merge(df1, df2, on=\"col1\", how=\"outer\", indicator=True)\n        tm.assert_frame_equal(test, df_result)\n        test = df1.merge(df2, on=\"col1\", how=\"outer\", indicator=True)\n        tm.assert_frame_equal(test, df_result)\n\n        # No side effects\n        tm.assert_frame_equal(df1, df1_copy)\n        tm.assert_frame_equal(df2, df2_copy)\n\n        # Check with custom name\n        df_result_custom_name = df_result\n        df_result_custom_name = df_result_custom_name.rename(\n            columns={\"_merge\": \"custom_name\"}\n        )\n\n        test_custom_name = merge(\n            df1, df2, on=\"col1\", how=\"outer\", indicator=\"custom_name\"\n        )\n        tm.assert_frame_equal(test_custom_name, df_result_custom_name)\n        test_custom_name = df1.merge(\n            df2, on=\"col1\", how=\"outer\", indicator=\"custom_name\"\n        )\n        tm.assert_frame_equal(test_custom_name, df_result_custom_name)\n\n        # Check only accepts strings and booleans\n        msg = \"indicator option can only accept boolean or string arguments\"\n        with pytest.raises(ValueError, match=msg):\n            merge(df1, df2, on=\"col1\", how=\"outer\", indicator=5)\n        with pytest.raises(ValueError, match=msg):\n            df1.merge(df2, on=\"col1\", how=\"outer\", indicator=5)\n\n        # Check result integrity\n\n        test2 = merge(df1, df2, on=\"col1\", how=\"left\", indicator=True)\n        assert (test2._merge != \"right_only\").all()\n        test2 = df1.merge(df2, on=\"col1\", how=\"left\", indicator=True)\n        assert (test2._merge != \"right_only\").all()\n\n        test3 = merge(df1, df2, on=\"col1\", how=\"right\", indicator=True)\n        assert (test3._merge != \"left_only\").all()\n        test3 = df1.merge(df2, on=\"col1\", how=\"right\", indicator=True)\n        assert (test3._merge != \"left_only\").all()\n\n        test4 = merge(df1, df2, on=\"col1\", how=\"inner\", indicator=True)\n        assert (test4._merge == \"both\").all()\n        test4 = df1.merge(df2, on=\"col1\", how=\"inner\", indicator=True)\n        assert (test4._merge == \"both\").all()\n\n        # Check if working name in df\n        for i in [\"_right_indicator\", \"_left_indicator\", \"_merge\"]:\n            df_badcolumn = DataFrame({\"col1\": [1, 2], i: [2, 2]})\n\n            msg = (\n                \"Cannot use `indicator=True` option when data contains a \"\n                f\"column named {i}|\"\n                \"Cannot use name of an existing column for indicator column\"\n            )\n            with pytest.raises(ValueError, match=msg):\n                merge(df1, df_badcolumn, on=\"col1\", how=\"outer\", indicator=True)\n            with pytest.raises(ValueError, match=msg):\n                df1.merge(df_badcolumn, on=\"col1\", how=\"outer\", indicator=True)\n\n        # Check for name conflict with custom name\n        df_badcolumn = DataFrame({\"col1\": [1, 2], \"custom_column_name\": [2, 2]})\n\n        msg = \"Cannot use name of an existing column for indicator column\"\n        with pytest.raises(ValueError, match=msg):\n            merge(\n                df1,\n                df_badcolumn,\n                on=\"col1\",\n                how=\"outer\",\n                indicator=\"custom_column_name\",\n            )\n        with pytest.raises(ValueError, match=msg):\n            df1.merge(\n                df_badcolumn, on=\"col1\", how=\"outer\", indicator=\"custom_column_name\"\n            )\n\n        # Merge on multiple columns\n        df3 = DataFrame({\"col1\": [0, 1], \"col2\": [\"a\", \"b\"]})\n\n        df4 = DataFrame({\"col1\": [1, 1, 3], \"col2\": [\"b\", \"x\", \"y\"]})\n\n        hand_coded_result = DataFrame(\n            {\"col1\": [0, 1, 1, 3], \"col2\": [\"a\", \"b\", \"x\", \"y\"]}\n        )\n        hand_coded_result[\"_merge\"] = Categorical(\n            [\"left_only\", \"both\", \"right_only\", \"right_only\"],\n            categories=[\"left_only\", \"right_only\", \"both\"],\n        )\n\n        test5 = merge(df3, df4, on=[\"col1\", \"col2\"], how=\"outer\", indicator=True)\n        tm.assert_frame_equal(test5, hand_coded_result)\n        test5 = df3.merge(df4, on=[\"col1\", \"col2\"], how=\"outer\", indicator=True)\n        tm.assert_frame_equal(test5, hand_coded_result)",
        "begin_line": 913,
        "end_line": 1056,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_validation#1058",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_validation(self)",
        "snippet": "    def test_validation(self):\n        left = DataFrame(\n            {\"a\": [\"a\", \"b\", \"c\", \"d\"], \"b\": [\"cat\", \"dog\", \"weasel\", \"horse\"]},\n            index=range(4),\n        )\n\n        right = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n                \"c\": [\"meow\", \"bark\", \"um... weasel noise?\", \"nay\", \"chirp\"],\n            },\n            index=range(5),\n        )\n\n        # Make sure no side effects.\n        left_copy = left.copy()\n        right_copy = right.copy()\n\n        result = merge(left, right, left_index=True, right_index=True, validate=\"1:1\")\n        tm.assert_frame_equal(left, left_copy)\n        tm.assert_frame_equal(right, right_copy)\n\n        # make sure merge still correct\n        expected = DataFrame(\n            {\n                \"a_x\": [\"a\", \"b\", \"c\", \"d\"],\n                \"b\": [\"cat\", \"dog\", \"weasel\", \"horse\"],\n                \"a_y\": [\"a\", \"b\", \"c\", \"d\"],\n                \"c\": [\"meow\", \"bark\", \"um... weasel noise?\", \"nay\"],\n            },\n            index=range(4),\n            columns=[\"a_x\", \"b\", \"a_y\", \"c\"],\n        )\n\n        result = merge(\n            left, right, left_index=True, right_index=True, validate=\"one_to_one\"\n        )\n        tm.assert_frame_equal(result, expected)\n\n        expected_2 = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", \"c\", \"d\"],\n                \"b\": [\"cat\", \"dog\", \"weasel\", \"horse\"],\n                \"c\": [\"meow\", \"bark\", \"um... weasel noise?\", \"nay\"],\n            },\n            index=range(4),\n        )\n\n        result = merge(left, right, on=\"a\", validate=\"1:1\")\n        tm.assert_frame_equal(left, left_copy)\n        tm.assert_frame_equal(right, right_copy)\n        tm.assert_frame_equal(result, expected_2)\n\n        result = merge(left, right, on=\"a\", validate=\"one_to_one\")\n        tm.assert_frame_equal(result, expected_2)\n\n        # One index, one column\n        expected_3 = DataFrame(\n            {\n                \"b\": [\"cat\", \"dog\", \"weasel\", \"horse\"],\n                \"a\": [\"a\", \"b\", \"c\", \"d\"],\n                \"c\": [\"meow\", \"bark\", \"um... weasel noise?\", \"nay\"],\n            },\n            columns=[\"b\", \"a\", \"c\"],\n            index=range(4),\n        )\n\n        left_index_reset = left.set_index(\"a\")\n        result = merge(\n            left_index_reset,\n            right,\n            left_index=True,\n            right_on=\"a\",\n            validate=\"one_to_one\",\n        )\n        tm.assert_frame_equal(result, expected_3)\n\n        # Dups on right\n        right_w_dups = right.append(pd.DataFrame({\"a\": [\"e\"], \"c\": [\"moo\"]}, index=[4]))\n        merge(\n            left,\n            right_w_dups,\n            left_index=True,\n            right_index=True,\n            validate=\"one_to_many\",\n        )\n\n        msg = \"Merge keys are not unique in right dataset; not a one-to-one merge\"\n        with pytest.raises(MergeError, match=msg):\n            merge(\n                left,\n                right_w_dups,\n                left_index=True,\n                right_index=True,\n                validate=\"one_to_one\",\n            )\n\n        with pytest.raises(MergeError, match=msg):\n            merge(left, right_w_dups, on=\"a\", validate=\"one_to_one\")\n\n        # Dups on left\n        left_w_dups = left.append(\n            pd.DataFrame({\"a\": [\"a\"], \"c\": [\"cow\"]}, index=[3]), sort=True\n        )\n        merge(\n            left_w_dups,\n            right,\n            left_index=True,\n            right_index=True,\n            validate=\"many_to_one\",\n        )\n\n        msg = \"Merge keys are not unique in left dataset; not a one-to-one merge\"\n        with pytest.raises(MergeError, match=msg):\n            merge(\n                left_w_dups,\n                right,\n                left_index=True,\n                right_index=True,\n                validate=\"one_to_one\",\n            )\n\n        with pytest.raises(MergeError, match=msg):\n            merge(left_w_dups, right, on=\"a\", validate=\"one_to_one\")\n\n        # Dups on both\n        merge(left_w_dups, right_w_dups, on=\"a\", validate=\"many_to_many\")\n\n        msg = \"Merge keys are not unique in right dataset; not a many-to-one merge\"\n        with pytest.raises(MergeError, match=msg):\n            merge(\n                left_w_dups,\n                right_w_dups,\n                left_index=True,\n                right_index=True,\n                validate=\"many_to_one\",\n            )\n\n        msg = \"Merge keys are not unique in left dataset; not a one-to-many merge\"\n        with pytest.raises(MergeError, match=msg):\n            merge(left_w_dups, right_w_dups, on=\"a\", validate=\"one_to_many\")\n\n        # Check invalid arguments\n        msg = \"Not a valid argument for validate\"\n        with pytest.raises(ValueError, match=msg):\n            merge(left, right, on=\"a\", validate=\"jibberish\")\n\n        # Two column merge, dups in both, but jointly no dups.\n        left = DataFrame(\n            {\n                \"a\": [\"a\", \"a\", \"b\", \"b\"],\n                \"b\": [0, 1, 0, 1],\n                \"c\": [\"cat\", \"dog\", \"weasel\", \"horse\"],\n            },\n            index=range(4),\n        )\n\n        right = DataFrame(\n            {\n                \"a\": [\"a\", \"a\", \"b\"],\n                \"b\": [0, 1, 0],\n                \"d\": [\"meow\", \"bark\", \"um... weasel noise?\"],\n            },\n            index=range(3),\n        )\n\n        expected_multi = DataFrame(\n            {\n                \"a\": [\"a\", \"a\", \"b\"],\n                \"b\": [0, 1, 0],\n                \"c\": [\"cat\", \"dog\", \"weasel\"],\n                \"d\": [\"meow\", \"bark\", \"um... weasel noise?\"],\n            },\n            index=range(3),\n        )\n\n        msg = (\n            \"Merge keys are not unique in either left or right dataset; \"\n            \"not a one-to-one merge\"\n        )\n        with pytest.raises(MergeError, match=msg):\n            merge(left, right, on=\"a\", validate=\"1:1\")\n\n        result = merge(left, right, on=[\"a\", \"b\"], validate=\"1:1\")\n        tm.assert_frame_equal(result, expected_multi)",
        "begin_line": 1058,
        "end_line": 1242,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_two_empty_df_no_division_error#1244",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_two_empty_df_no_division_error(self)",
        "snippet": "    def test_merge_two_empty_df_no_division_error(self):\n        # GH17776, PR #17846\n        a = pd.DataFrame({\"a\": [], \"b\": [], \"c\": []})\n        with np.errstate(divide=\"raise\"):\n            merge(a, a, on=(\"a\", \"b\"))",
        "begin_line": 1244,
        "end_line": 1248,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_on_index_with_more_values#1285",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_on_index_with_more_values(self, how, index, expected_index)",
        "snippet": "    def test_merge_on_index_with_more_values(self, how, index, expected_index):\n        # GH 24212\n        # pd.merge gets [0, 1, 2, -1, -1, -1] as left_indexer, ensure that\n        # -1 is interpreted as a missing value instead of the last element\n        df1 = pd.DataFrame({\"a\": [0, 1, 2], \"key\": [0, 1, 2]}, index=index)\n        df2 = pd.DataFrame({\"b\": [0, 1, 2, 3, 4, 5]})\n        result = df1.merge(df2, left_on=\"key\", right_index=True, how=how)\n        expected = pd.DataFrame(\n            [\n                [0, 0, 0],\n                [1, 1, 1],\n                [2, 2, 2],\n                [np.nan, 3, 3],\n                [np.nan, 4, 4],\n                [np.nan, 5, 5],\n            ],\n            columns=[\"a\", \"key\", \"b\"],\n        )\n        expected.set_index(expected_index, inplace=True)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1285,
        "end_line": 1304,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_right_index_right#1306",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_right_index_right(self)",
        "snippet": "    def test_merge_right_index_right(self):\n        # Note: the expected output here is probably incorrect.\n        # See https://github.com/pandas-dev/pandas/issues/17257 for more.\n        # We include this as a regression test for GH-24897.\n        left = pd.DataFrame({\"a\": [1, 2, 3], \"key\": [0, 1, 1]})\n        right = pd.DataFrame({\"b\": [1, 2, 3]})\n\n        expected = pd.DataFrame(\n            {\"a\": [1, 2, 3, None], \"key\": [0, 1, 1, 2], \"b\": [1, 2, 2, 3]},\n            columns=[\"a\", \"key\", \"b\"],\n            index=[0, 1, 2, np.nan],\n        )\n        result = left.merge(right, left_on=\"key\", right_index=True, how=\"right\")\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1306,
        "end_line": 1319,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_preserves_row_order#1322",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_preserves_row_order(self, how)",
        "snippet": "    def test_merge_preserves_row_order(self, how):\n        # GH 27453\n        left_df = pd.DataFrame({\"animal\": [\"dog\", \"pig\"], \"max_speed\": [40, 11]})\n        right_df = pd.DataFrame({\"animal\": [\"quetzal\", \"pig\"], \"max_speed\": [80, 11]})\n        result = left_df.merge(right_df, on=[\"animal\", \"max_speed\"], how=how)\n        if how == \"right\":\n            expected = pd.DataFrame(\n                {\"animal\": [\"quetzal\", \"pig\"], \"max_speed\": [80, 11]}\n            )\n        else:\n            expected = pd.DataFrame({\"animal\": [\"dog\", \"pig\"], \"max_speed\": [40, 11]})\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1322,
        "end_line": 1333,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_take_missing_values_from_index_of_other_dtype#1335",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_take_missing_values_from_index_of_other_dtype(self)",
        "snippet": "    def test_merge_take_missing_values_from_index_of_other_dtype(self):\n        # GH 24212\n        left = pd.DataFrame(\n            {\n                \"a\": [1, 2, 3],\n                \"key\": pd.Categorical([\"a\", \"a\", \"b\"], categories=list(\"abc\")),\n            }\n        )\n        right = pd.DataFrame(\n            {\"b\": [1, 2, 3]}, index=pd.CategoricalIndex([\"a\", \"b\", \"c\"])\n        )\n        result = left.merge(right, left_on=\"key\", right_index=True, how=\"right\")\n        expected = pd.DataFrame(\n            {\n                \"a\": [1, 2, 3, None],\n                \"key\": pd.Categorical([\"a\", \"a\", \"b\", \"c\"]),\n                \"b\": [1, 1, 2, 3],\n            },\n            index=[0, 1, 2, np.nan],\n        )\n        expected = expected.reindex(columns=[\"a\", \"key\", \"b\"])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1335,
        "end_line": 1356,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_readonly#1358",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMerge",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMerge.test_merge_readonly(self)",
        "snippet": "    def test_merge_readonly(self):\n        # https://github.com/pandas-dev/pandas/issues/27943\n        data1 = pd.DataFrame(\n            np.arange(20).reshape((4, 5)) + 1, columns=[\"a\", \"b\", \"c\", \"d\", \"e\"]\n        )\n        data2 = pd.DataFrame(\n            np.arange(20).reshape((5, 4)) + 1, columns=[\"a\", \"b\", \"x\", \"y\"]\n        )\n\n        data1._data.blocks[0].values.flags.writeable = False\n        data1.merge(data2)  # no error",
        "begin_line": 1358,
        "end_line": 1368,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge._check_merge#1371",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge._check_merge(x, y)",
        "snippet": "def _check_merge(x, y):\n    for how in [\"inner\", \"left\", \"outer\"]:\n        result = x.join(y, how=how)\n\n        expected = merge(x.reset_index(), y.reset_index(), how=how, sort=True)\n        expected = expected.set_index(\"index\")\n\n        # TODO check_names on merge?\n        tm.assert_frame_equal(result, expected, check_names=False)",
        "begin_line": 1371,
        "end_line": 1379,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes.test_different#1386",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes.test_different(self, right_vals)",
        "snippet": "    def test_different(self, right_vals):\n\n        left = DataFrame(\n            {\n                \"A\": [\"foo\", \"bar\"],\n                \"B\": Series([\"foo\", \"bar\"]).astype(\"category\"),\n                \"C\": [1, 2],\n                \"D\": [1.0, 2.0],\n                \"E\": Series([1, 2], dtype=\"uint64\"),\n                \"F\": Series([1, 2], dtype=\"int32\"),\n            }\n        )\n        right = DataFrame({\"A\": right_vals})\n\n        # GH 9780\n        # We allow merging on object and categorical cols and cast\n        # categorical cols to object\n        result = pd.merge(left, right, on=\"A\")\n        assert is_object_dtype(result.A.dtype)",
        "begin_line": 1386,
        "end_line": 1404,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes.test_join_multi_dtypes#1408",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes.test_join_multi_dtypes(self, d1, d2)",
        "snippet": "    def test_join_multi_dtypes(self, d1, d2):\n\n        dtype1 = np.dtype(d1)\n        dtype2 = np.dtype(d2)\n\n        left = DataFrame(\n            {\n                \"k1\": np.array([0, 1, 2] * 8, dtype=dtype1),\n                \"k2\": [\"foo\", \"bar\"] * 12,\n                \"v\": np.array(np.arange(24), dtype=np.int64),\n            }\n        )\n\n        index = MultiIndex.from_tuples([(2, \"bar\"), (1, \"foo\")])\n        right = DataFrame({\"v2\": np.array([5, 7], dtype=dtype2)}, index=index)\n\n        result = left.join(right, on=[\"k1\", \"k2\"])\n\n        expected = left.copy()\n\n        if dtype2.kind == \"i\":\n            dtype2 = np.dtype(\"float64\")\n        expected[\"v2\"] = np.array(np.nan, dtype=dtype2)\n        expected.loc[(expected.k1 == 2) & (expected.k2 == \"bar\"), \"v2\"] = 5\n        expected.loc[(expected.k1 == 1) & (expected.k2 == \"foo\"), \"v2\"] = 7\n\n        tm.assert_frame_equal(result, expected)\n\n        result = left.join(right, on=[\"k1\", \"k2\"], sort=True)\n        expected.sort_values([\"k1\", \"k2\"], kind=\"mergesort\", inplace=True)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1408,
        "end_line": 1438,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes.test_merge_on_ints_floats#1448",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes.test_merge_on_ints_floats(self, int_vals, float_vals, exp_vals)",
        "snippet": "    def test_merge_on_ints_floats(self, int_vals, float_vals, exp_vals):\n        # GH 16572\n        # Check that float column is not cast to object if\n        # merging on float and int columns\n        A = DataFrame({\"X\": int_vals})\n        B = DataFrame({\"Y\": float_vals})\n        expected = DataFrame(exp_vals)\n\n        result = A.merge(B, left_on=\"X\", right_on=\"Y\")\n        tm.assert_frame_equal(result, expected)\n\n        result = B.merge(A, left_on=\"Y\", right_on=\"X\")\n        tm.assert_frame_equal(result, expected[[\"Y\", \"X\"]])",
        "begin_line": 1448,
        "end_line": 1460,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes.test_merge_key_dtype_cast#1462",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes.test_merge_key_dtype_cast(self)",
        "snippet": "    def test_merge_key_dtype_cast(self):\n        # GH 17044\n        df1 = DataFrame({\"key\": [1.0, 2.0], \"v1\": [10, 20]}, columns=[\"key\", \"v1\"])\n        df2 = DataFrame({\"key\": [2], \"v2\": [200]}, columns=[\"key\", \"v2\"])\n        result = df1.merge(df2, on=\"key\", how=\"left\")\n        expected = DataFrame(\n            {\"key\": [1.0, 2.0], \"v1\": [10, 20], \"v2\": [np.nan, 200.0]},\n            columns=[\"key\", \"v1\", \"v2\"],\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1462,
        "end_line": 1471,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes.test_merge_on_ints_floats_warning#1473",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes.test_merge_on_ints_floats_warning(self)",
        "snippet": "    def test_merge_on_ints_floats_warning(self):\n        # GH 16572\n        # merge will produce a warning when merging on int and\n        # float columns where the float values are not exactly\n        # equal to their int representation\n        A = DataFrame({\"X\": [1, 2, 3]})\n        B = DataFrame({\"Y\": [1.1, 2.5, 3.0]})\n        expected = DataFrame({\"X\": [3], \"Y\": [3.0]})\n\n        with tm.assert_produces_warning(UserWarning):\n            result = A.merge(B, left_on=\"X\", right_on=\"Y\")\n            tm.assert_frame_equal(result, expected)\n\n        with tm.assert_produces_warning(UserWarning):\n            result = B.merge(A, left_on=\"Y\", right_on=\"X\")\n            tm.assert_frame_equal(result, expected[[\"Y\", \"X\"]])\n\n        # test no warning if float has NaNs\n        B = DataFrame({\"Y\": [np.nan, np.nan, 3.0]})\n\n        with tm.assert_produces_warning(None):\n            result = B.merge(A, left_on=\"Y\", right_on=\"X\")\n            tm.assert_frame_equal(result, expected[[\"Y\", \"X\"]])",
        "begin_line": 1473,
        "end_line": 1495,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes.test_merge_incompat_infer_boolean_object#1497",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes.test_merge_incompat_infer_boolean_object(self)",
        "snippet": "    def test_merge_incompat_infer_boolean_object(self):\n        # GH21119: bool + object bool merge OK\n        df1 = DataFrame({\"key\": Series([True, False], dtype=object)})\n        df2 = DataFrame({\"key\": [True, False]})\n\n        expected = DataFrame({\"key\": [True, False]}, dtype=object)\n        result = pd.merge(df1, df2, on=\"key\")\n        tm.assert_frame_equal(result, expected)\n        result = pd.merge(df2, df1, on=\"key\")\n        tm.assert_frame_equal(result, expected)\n\n        # with missing value\n        df1 = DataFrame({\"key\": Series([True, False, np.nan], dtype=object)})\n        df2 = DataFrame({\"key\": [True, False]})\n\n        expected = DataFrame({\"key\": [True, False]}, dtype=object)\n        result = pd.merge(df1, df2, on=\"key\")\n        tm.assert_frame_equal(result, expected)\n        result = pd.merge(df2, df1, on=\"key\")\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1497,
        "end_line": 1516,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes.test_merge_incompat_dtypes_are_ok#1529",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes.test_merge_incompat_dtypes_are_ok(self, df1_vals, df2_vals)",
        "snippet": "    def test_merge_incompat_dtypes_are_ok(self, df1_vals, df2_vals):\n        # these are explicitly allowed incompat merges, that pass thru\n        # the result type is dependent on if the values on the rhs are\n        # inferred, otherwise these will be coerced to object\n\n        df1 = DataFrame({\"A\": df1_vals})\n        df2 = DataFrame({\"A\": df2_vals})\n\n        result = pd.merge(df1, df2, on=[\"A\"])\n        assert is_object_dtype(result.A.dtype)\n        result = pd.merge(df2, df1, on=[\"A\"])\n        assert is_object_dtype(result.A.dtype)",
        "begin_line": 1529,
        "end_line": 1540,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes.test_merge_incompat_dtypes_error#1563",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeDtypes.test_merge_incompat_dtypes_error(self, df1_vals, df2_vals)",
        "snippet": "    def test_merge_incompat_dtypes_error(self, df1_vals, df2_vals):\n        # GH 9780, GH 15800\n        # Raise a ValueError when a user tries to merge on\n        # dtypes that are incompatible (e.g., obj and int/float)\n\n        df1 = DataFrame({\"A\": df1_vals})\n        df2 = DataFrame({\"A\": df2_vals})\n\n        msg = (\n            f\"You are trying to merge on {df1['A'].dtype} and \"\n            f\"{df2['A'].dtype} columns. If you wish to proceed \"\n            \"you should use pd.concat\"\n        )\n        msg = re.escape(msg)\n        with pytest.raises(ValueError, match=msg):\n            pd.merge(df1, df2, on=[\"A\"])\n\n        # Check that error still raised when swapping order of dataframes\n        msg = (\n            f\"You are trying to merge on {df2['A'].dtype} and \"\n            f\"{df1['A'].dtype} columns. If you wish to proceed \"\n            \"you should use pd.concat\"\n        )\n        msg = re.escape(msg)\n        with pytest.raises(ValueError, match=msg):\n            pd.merge(df2, df1, on=[\"A\"])",
        "begin_line": 1563,
        "end_line": 1588,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.left#1592",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.left()",
        "snippet": "def left():\n    np.random.seed(1234)\n    return DataFrame(\n        {\n            \"X\": Series(np.random.choice([\"foo\", \"bar\"], size=(10,))).astype(\n                CDT([\"foo\", \"bar\"])\n            ),\n            \"Y\": np.random.choice([\"one\", \"two\", \"three\"], size=(10,)),\n        }\n    )",
        "begin_line": 1592,
        "end_line": 1601,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.right#1605",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.right()",
        "snippet": "def right():\n    np.random.seed(1234)\n    return DataFrame(\n        {\"X\": Series([\"foo\", \"bar\"]).astype(CDT([\"foo\", \"bar\"])), \"Z\": [1, 2]}\n    )",
        "begin_line": 1605,
        "end_line": 1609,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.test_identical#1613",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.test_identical(self, left)",
        "snippet": "    def test_identical(self, left):\n        # merging on the same, should preserve dtypes\n        merged = pd.merge(left, left, on=\"X\")\n        result = merged.dtypes.sort_index()\n        expected = Series(\n            [CategoricalDtype(), np.dtype(\"O\"), np.dtype(\"O\")],\n            index=[\"X\", \"Y_x\", \"Y_y\"],\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1613,
        "end_line": 1621,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.test_basic#1623",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.test_basic(self, left, right)",
        "snippet": "    def test_basic(self, left, right):\n        # we have matching Categorical dtypes in X\n        # so should preserve the merged column\n        merged = pd.merge(left, right, on=\"X\")\n        result = merged.dtypes.sort_index()\n        expected = Series(\n            [CategoricalDtype(), np.dtype(\"O\"), np.dtype(\"int64\")],\n            index=[\"X\", \"Y\", \"Z\"],\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1623,
        "end_line": 1632,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.test_merge_categorical#1634",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.test_merge_categorical(self)",
        "snippet": "    def test_merge_categorical(self):\n        # GH 9426\n\n        right = DataFrame(\n            {\n                \"c\": {0: \"a\", 1: \"b\", 2: \"c\", 3: \"d\", 4: \"e\"},\n                \"d\": {0: \"null\", 1: \"null\", 2: \"null\", 3: \"null\", 4: \"null\"},\n            }\n        )\n        left = DataFrame(\n            {\n                \"a\": {0: \"f\", 1: \"f\", 2: \"f\", 3: \"f\", 4: \"f\"},\n                \"b\": {0: \"g\", 1: \"g\", 2: \"g\", 3: \"g\", 4: \"g\"},\n            }\n        )\n        df = pd.merge(left, right, how=\"left\", left_on=\"b\", right_on=\"c\")\n\n        # object-object\n        expected = df.copy()\n\n        # object-cat\n        # note that we propagate the category\n        # because we don't have any matching rows\n        cright = right.copy()\n        cright[\"d\"] = cright[\"d\"].astype(\"category\")\n        result = pd.merge(left, cright, how=\"left\", left_on=\"b\", right_on=\"c\")\n        expected[\"d\"] = expected[\"d\"].astype(CategoricalDtype([\"null\"]))\n        tm.assert_frame_equal(result, expected)\n\n        # cat-object\n        cleft = left.copy()\n        cleft[\"b\"] = cleft[\"b\"].astype(\"category\")\n        result = pd.merge(cleft, cright, how=\"left\", left_on=\"b\", right_on=\"c\")\n        tm.assert_frame_equal(result, expected)\n\n        # cat-cat\n        cright = right.copy()\n        cright[\"d\"] = cright[\"d\"].astype(\"category\")\n        cleft = left.copy()\n        cleft[\"b\"] = cleft[\"b\"].astype(\"category\")\n        result = pd.merge(cleft, cright, how=\"left\", left_on=\"b\", right_on=\"c\")\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1634,
        "end_line": 1675,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.tests_merge_categorical_unordered_equal#1677",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.tests_merge_categorical_unordered_equal(self)",
        "snippet": "    def tests_merge_categorical_unordered_equal(self):\n        # GH-19551\n        df1 = DataFrame(\n            {\n                \"Foo\": Categorical([\"A\", \"B\", \"C\"], categories=[\"A\", \"B\", \"C\"]),\n                \"Left\": [\"A0\", \"B0\", \"C0\"],\n            }\n        )\n\n        df2 = DataFrame(\n            {\n                \"Foo\": Categorical([\"C\", \"B\", \"A\"], categories=[\"C\", \"B\", \"A\"]),\n                \"Right\": [\"C1\", \"B1\", \"A1\"],\n            }\n        )\n        result = pd.merge(df1, df2, on=[\"Foo\"])\n        expected = DataFrame(\n            {\n                \"Foo\": pd.Categorical([\"A\", \"B\", \"C\"]),\n                \"Left\": [\"A0\", \"B0\", \"C0\"],\n                \"Right\": [\"A1\", \"B1\", \"C1\"],\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1677,
        "end_line": 1700,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.test_other_columns#1702",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.test_other_columns(self, left, right)",
        "snippet": "    def test_other_columns(self, left, right):\n        # non-merge columns should preserve if possible\n        right = right.assign(Z=right.Z.astype(\"category\"))\n\n        merged = pd.merge(left, right, on=\"X\")\n        result = merged.dtypes.sort_index()\n        expected = Series(\n            [CategoricalDtype(), np.dtype(\"O\"), CategoricalDtype()],\n            index=[\"X\", \"Y\", \"Z\"],\n        )\n        tm.assert_series_equal(result, expected)\n\n        # categories are preserved\n        assert left.X.values.is_dtype_equal(merged.X.values)\n        assert right.Z.values.is_dtype_equal(merged.Z.values)",
        "begin_line": 1702,
        "end_line": 1716,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.test_dtype_on_merged_different#1726",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.test_dtype_on_merged_different(self, change, join_type, left, right)",
        "snippet": "    def test_dtype_on_merged_different(self, change, join_type, left, right):\n        # our merging columns, X now has 2 different dtypes\n        # so we must be object as a result\n\n        X = change(right.X.astype(\"object\"))\n        right = right.assign(X=X)\n        assert is_categorical_dtype(left.X.values)\n        # assert not left.X.values.is_dtype_equal(right.X.values)\n\n        merged = pd.merge(left, right, on=\"X\", how=join_type)\n\n        result = merged.dtypes.sort_index()\n        expected = Series(\n            [np.dtype(\"O\"), np.dtype(\"O\"), np.dtype(\"int64\")], index=[\"X\", \"Y\", \"Z\"]\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1726,
        "end_line": 1741,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.test_self_join_multiple_categories#1743",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.test_self_join_multiple_categories(self)",
        "snippet": "    def test_self_join_multiple_categories(self):\n        # GH 16767\n        # non-duplicates should work with multiple categories\n        m = 5\n        df = pd.DataFrame(\n            {\n                \"a\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"] * m,\n                \"b\": [\"t\", \"w\", \"x\", \"y\", \"z\"] * 2 * m,\n                \"c\": [\n                    letter\n                    for each in [\"m\", \"n\", \"u\", \"p\", \"o\"]\n                    for letter in [each] * 2 * m\n                ],\n                \"d\": [\n                    letter\n                    for each in [\n                        \"aa\",\n                        \"bb\",\n                        \"cc\",\n                        \"dd\",\n                        \"ee\",\n                        \"ff\",\n                        \"gg\",\n                        \"hh\",\n                        \"ii\",\n                        \"jj\",\n                    ]\n                    for letter in [each] * m\n                ],\n            }\n        )\n\n        # change them all to categorical variables\n        df = df.apply(lambda x: x.astype(\"category\"))\n\n        # self-join should equal ourselves\n        result = pd.merge(df, df, on=list(df.columns))\n\n        tm.assert_frame_equal(result, df)",
        "begin_line": 1743,
        "end_line": 1781,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.test_dtype_on_categorical_dates#1783",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.test_dtype_on_categorical_dates(self)",
        "snippet": "    def test_dtype_on_categorical_dates(self):\n        # GH 16900\n        # dates should not be coerced to ints\n\n        df = pd.DataFrame(\n            [[date(2001, 1, 1), 1.1], [date(2001, 1, 2), 1.3]], columns=[\"date\", \"num2\"]\n        )\n        df[\"date\"] = df[\"date\"].astype(\"category\")\n\n        df2 = pd.DataFrame(\n            [[date(2001, 1, 1), 1.3], [date(2001, 1, 3), 1.4]], columns=[\"date\", \"num4\"]\n        )\n        df2[\"date\"] = df2[\"date\"].astype(\"category\")\n\n        expected_outer = pd.DataFrame(\n            [\n                [pd.Timestamp(\"2001-01-01\"), 1.1, 1.3],\n                [pd.Timestamp(\"2001-01-02\"), 1.3, np.nan],\n                [pd.Timestamp(\"2001-01-03\"), np.nan, 1.4],\n            ],\n            columns=[\"date\", \"num2\", \"num4\"],\n        )\n        result_outer = pd.merge(df, df2, how=\"outer\", on=[\"date\"])\n        tm.assert_frame_equal(result_outer, expected_outer)\n\n        expected_inner = pd.DataFrame(\n            [[pd.Timestamp(\"2001-01-01\"), 1.1, 1.3]], columns=[\"date\", \"num2\", \"num4\"]\n        )\n        result_inner = pd.merge(df, df2, how=\"inner\", on=[\"date\"])\n        tm.assert_frame_equal(result_inner, expected_inner)",
        "begin_line": 1783,
        "end_line": 1812,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.test_merging_with_bool_or_int_cateorical_column#1823",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.test_merging_with_bool_or_int_cateorical_column(self, category_column, categories, expected_categories, ordered)",
        "snippet": "    def test_merging_with_bool_or_int_cateorical_column(\n        self, category_column, categories, expected_categories, ordered\n    ):\n        # GH 17187\n        # merging with a boolean/int categorical column\n        df1 = pd.DataFrame({\"id\": [1, 2, 3, 4], \"cat\": category_column})\n        df1[\"cat\"] = df1[\"cat\"].astype(CDT(categories, ordered=ordered))\n        df2 = pd.DataFrame({\"id\": [2, 4], \"num\": [1, 9]})\n        result = df1.merge(df2)\n        expected = pd.DataFrame(\n            {\"id\": [2, 4], \"cat\": expected_categories, \"num\": [1, 9]}\n        )\n        expected[\"cat\"] = expected[\"cat\"].astype(CDT(categories, ordered=ordered))\n        tm.assert_frame_equal(expected, result)",
        "begin_line": 1823,
        "end_line": 1836,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.test_merge_on_int_array#1838",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeCategorical.test_merge_on_int_array(self)",
        "snippet": "    def test_merge_on_int_array(self):\n        # GH 23020\n        df = pd.DataFrame({\"A\": pd.Series([1, 2, np.nan], dtype=\"Int64\"), \"B\": 1})\n        result = pd.merge(df, df, on=\"A\")\n        expected = pd.DataFrame(\n            {\"A\": pd.Series([1, 2, np.nan], dtype=\"Int64\"), \"B_x\": 1, \"B_y\": 1}\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1838,
        "end_line": 1845,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.left_df#1849",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.left_df()",
        "snippet": "def left_df():\n    return DataFrame({\"a\": [20, 10, 0]}, index=[2, 1, 0])",
        "begin_line": 1849,
        "end_line": 1850,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.right_df#1854",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.right_df()",
        "snippet": "def right_df():\n    return DataFrame({\"b\": [300, 100, 200]}, index=[3, 1, 2])",
        "begin_line": 1854,
        "end_line": 1855,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.TestMergeOnIndexes.test_merge_on_indexes#1906",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge.TestMergeOnIndexes",
        "signature": "pandas.tests.reshape.merge.test_merge.TestMergeOnIndexes.test_merge_on_indexes(self, left_df, right_df, how, sort, expected)",
        "snippet": "    def test_merge_on_indexes(self, left_df, right_df, how, sort, expected):\n        result = pd.merge(\n            left_df, right_df, left_index=True, right_index=True, how=how, sort=sort\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1906,
        "end_line": 1910,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.test_merge_index_types#1925",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.test_merge_index_types(index)",
        "snippet": "def test_merge_index_types(index):\n    # gh-20777\n    # assert key access is consistent across index types\n    left = DataFrame({\"left_data\": [1, 2]}, index=index)\n    right = DataFrame({\"right_data\": [1.0, 2.0]}, index=index)\n\n    result = left.merge(right, on=[\"index_col\"])\n\n    expected = DataFrame(\n        OrderedDict([(\"left_data\", [1, 2]), (\"right_data\", [1.0, 2.0])]), index=index\n    )\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 1925,
        "end_line": 1936,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.test_merge_series#1952",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.test_merge_series(on, left_on, right_on, left_index, right_index, nm)",
        "snippet": "def test_merge_series(on, left_on, right_on, left_index, right_index, nm):\n    # GH 21220\n    a = pd.DataFrame(\n        {\"A\": [1, 2, 3, 4]},\n        index=pd.MultiIndex.from_product(\n            [[\"a\", \"b\"], [0, 1]], names=[\"outer\", \"inner\"]\n        ),\n    )\n    b = pd.Series(\n        [1, 2, 3, 4],\n        index=pd.MultiIndex.from_product(\n            [[\"a\", \"b\"], [1, 2]], names=[\"outer\", \"inner\"]\n        ),\n        name=nm,\n    )\n    expected = pd.DataFrame(\n        {\"A\": [2, 4], \"B\": [1, 3]},\n        index=pd.MultiIndex.from_product([[\"a\", \"b\"], [1]], names=[\"outer\", \"inner\"]),\n    )\n    if nm is not None:\n        result = pd.merge(\n            a,\n            b,\n            on=on,\n            left_on=left_on,\n            right_on=right_on,\n            left_index=left_index,\n            right_index=right_index,\n        )\n        tm.assert_frame_equal(result, expected)\n    else:\n        msg = \"Cannot merge a Series without a name\"\n        with pytest.raises(ValueError, match=msg):\n            result = pd.merge(\n                a,\n                b,\n                on=on,\n                left_on=left_on,\n                right_on=right_on,\n                left_index=left_index,\n                right_index=right_index,\n            )",
        "begin_line": 1952,
        "end_line": 1993,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.test_merge_suffix#2013",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.test_merge_suffix(col1, col2, kwargs, expected_cols)",
        "snippet": "def test_merge_suffix(col1, col2, kwargs, expected_cols):\n    # issue: 24782\n    a = pd.DataFrame({col1: [1, 2, 3]})\n    b = pd.DataFrame({col2: [4, 5, 6]})\n\n    expected = pd.DataFrame([[1, 4], [2, 5], [3, 6]], columns=expected_cols)\n\n    result = a.merge(b, left_index=True, right_index=True, **kwargs)\n    tm.assert_frame_equal(result, expected)\n\n    result = pd.merge(a, b, left_index=True, right_index=True, **kwargs)\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 2013,
        "end_line": 2024,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.test_merge_suffix_error#2037",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.test_merge_suffix_error(col1, col2, suffixes)",
        "snippet": "def test_merge_suffix_error(col1, col2, suffixes):\n    # issue: 24782\n    a = pd.DataFrame({col1: [1, 2, 3]})\n    b = pd.DataFrame({col2: [3, 4, 5]})\n\n    # TODO: might reconsider current raise behaviour, see issue 24782\n    msg = \"columns overlap but no suffix specified\"\n    with pytest.raises(ValueError, match=msg):\n        pd.merge(a, b, left_index=True, right_index=True, suffixes=suffixes)",
        "begin_line": 2037,
        "end_line": 2045,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.test_merge_suffix_none_error#2049",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.test_merge_suffix_none_error(col1, col2, suffixes)",
        "snippet": "def test_merge_suffix_none_error(col1, col2, suffixes):\n    # issue: 24782\n    a = pd.DataFrame({col1: [1, 2, 3]})\n    b = pd.DataFrame({col2: [3, 4, 5]})\n\n    # TODO: might reconsider current raise behaviour, see GH24782\n    msg = \"iterable\"\n    with pytest.raises(TypeError, match=msg):\n        pd.merge(a, b, left_index=True, right_index=True, suffixes=suffixes)",
        "begin_line": 2049,
        "end_line": 2057,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.test_merge_equal_cat_dtypes#2062",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.test_merge_equal_cat_dtypes(cat_dtype, reverse)",
        "snippet": "def test_merge_equal_cat_dtypes(cat_dtype, reverse):\n    # see gh-22501\n    cat_dtypes = {\n        \"one\": CategoricalDtype(categories=[\"a\", \"b\", \"c\"], ordered=False),\n        \"two\": CategoricalDtype(categories=[\"a\", \"b\", \"c\"], ordered=False),\n    }\n\n    df1 = DataFrame(\n        {\"foo\": Series([\"a\", \"b\", \"c\"]).astype(cat_dtypes[\"one\"]), \"left\": [1, 2, 3]}\n    ).set_index(\"foo\")\n\n    data_foo = [\"a\", \"b\", \"c\"]\n    data_right = [1, 2, 3]\n\n    if reverse:\n        data_foo.reverse()\n        data_right.reverse()\n\n    df2 = DataFrame(\n        {\"foo\": Series(data_foo).astype(cat_dtypes[cat_dtype]), \"right\": data_right}\n    ).set_index(\"foo\")\n\n    result = df1.merge(df2, left_index=True, right_index=True)\n\n    expected = DataFrame(\n        {\n            \"left\": [1, 2, 3],\n            \"right\": [1, 2, 3],\n            \"foo\": Series([\"a\", \"b\", \"c\"]).astype(cat_dtypes[\"one\"]),\n        }\n    ).set_index(\"foo\")\n\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 2062,
        "end_line": 2094,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.test_merge_equal_cat_dtypes2#2097",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.test_merge_equal_cat_dtypes2()",
        "snippet": "def test_merge_equal_cat_dtypes2():\n    # see gh-22501\n    cat_dtype = CategoricalDtype(categories=[\"a\", \"b\", \"c\"], ordered=False)\n\n    # Test Data\n    df1 = DataFrame(\n        {\"foo\": Series([\"a\", \"b\"]).astype(cat_dtype), \"left\": [1, 2]}\n    ).set_index(\"foo\")\n\n    df2 = DataFrame(\n        {\"foo\": Series([\"a\", \"b\", \"c\"]).astype(cat_dtype), \"right\": [3, 2, 1]}\n    ).set_index(\"foo\")\n\n    result = df1.merge(df2, left_index=True, right_index=True)\n\n    expected = DataFrame(\n        {\"left\": [1, 2], \"right\": [3, 2], \"foo\": Series([\"a\", \"b\"]).astype(cat_dtype)}\n    ).set_index(\"foo\")\n\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 2097,
        "end_line": 2116,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.test_merge_on_cat_and_ext_array#2119",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.test_merge_on_cat_and_ext_array()",
        "snippet": "def test_merge_on_cat_and_ext_array():\n    # GH 28668\n    right = DataFrame(\n        {\"a\": Series([pd.Interval(0, 1), pd.Interval(1, 2)], dtype=\"interval\")}\n    )\n    left = right.copy()\n    left[\"a\"] = left[\"a\"].astype(\"category\")\n\n    result = pd.merge(left, right, how=\"inner\", on=\"a\")\n    expected = right.copy()\n\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 2119,
        "end_line": 2130,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.test_merge_multiindex_columns#2133",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.test_merge_multiindex_columns()",
        "snippet": "def test_merge_multiindex_columns():\n    # Issue #28518\n    # Verify that merging two dataframes give the expected labels\n    # The original cause of this issue come from a bug lexsort_depth and is tested in\n    # test_lexsort_depth\n\n    letters = [\"a\", \"b\", \"c\", \"d\"]\n    numbers = [\"1\", \"2\", \"3\"]\n    index = pd.MultiIndex.from_product((letters, numbers), names=[\"outer\", \"inner\"])\n\n    frame_x = pd.DataFrame(columns=index)\n    frame_x[\"id\"] = \"\"\n    frame_y = pd.DataFrame(columns=index)\n    frame_y[\"id\"] = \"\"\n\n    l_suf = \"_x\"\n    r_suf = \"_y\"\n    result = frame_x.merge(frame_y, on=\"id\", suffixes=((l_suf, r_suf)))\n\n    # Constructing the expected results\n    expected_labels = [l + l_suf for l in letters] + [l + r_suf for l in letters]\n    expected_index = pd.MultiIndex.from_product(\n        [expected_labels, numbers], names=[\"outer\", \"inner\"]\n    )\n    expected = pd.DataFrame(columns=expected_index)\n    expected[\"id\"] = \"\"\n\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 2133,
        "end_line": 2160,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.test_merge_datetime_upcast_dtype#2163",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.test_merge_datetime_upcast_dtype()",
        "snippet": "def test_merge_datetime_upcast_dtype():\n    # https://github.com/pandas-dev/pandas/issues/31208\n    df1 = pd.DataFrame({\"x\": [\"a\", \"b\", \"c\"], \"y\": [\"1\", \"2\", \"4\"]})\n    df2 = pd.DataFrame(\n        {\"y\": [\"1\", \"2\", \"3\"], \"z\": pd.to_datetime([\"2000\", \"2001\", \"2002\"])}\n    )\n    result = pd.merge(df1, df2, how=\"left\", on=\"y\")\n    expected = pd.DataFrame(\n        {\n            \"x\": [\"a\", \"b\", \"c\"],\n            \"y\": [\"1\", \"2\", \"4\"],\n            \"z\": pd.to_datetime([\"2000\", \"2001\", \"NaT\"]),\n        }\n    )\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 2163,
        "end_line": 2177,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.reshape.merge.test_merge.test_categorical_non_unique_monotonic#2181",
        "src_path": "pandas/tests/reshape/merge/test_merge.py",
        "class_name": "pandas.tests.reshape.merge.test_merge",
        "signature": "pandas.tests.reshape.merge.test_merge.test_categorical_non_unique_monotonic(n_categories)",
        "snippet": "def test_categorical_non_unique_monotonic(n_categories):\n    # GH 28189\n    # With n_categories as 5, we test the int8 case is hit in libjoin,\n    # with n_categories as 128 we test the int16 case.\n    left_index = CategoricalIndex([0] + list(range(n_categories)))\n    df1 = DataFrame(range(n_categories + 1), columns=[\"value\"], index=left_index)\n    df2 = DataFrame(\n        [[6]],\n        columns=[\"value\"],\n        index=CategoricalIndex([0], categories=np.arange(n_categories)),\n    )\n\n    result = merge(df1, df2, how=\"left\", left_index=True, right_index=True)\n    expected = DataFrame(\n        [[i, 6.0] if i < 2 else [i, np.nan] for i in range(n_categories + 1)],\n        columns=[\"value_x\", \"value_y\"],\n        index=left_index,\n    )\n    tm.assert_frame_equal(expected, result)",
        "begin_line": 2181,
        "end_line": 2199,
        "comment": "",
        "is_bug": false
    }
]