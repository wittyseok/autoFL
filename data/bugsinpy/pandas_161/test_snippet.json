[
    {
        "name": "pandas.tests.series.indexing.conftest.test_data#7",
        "src_path": "pandas/tests/series/indexing/conftest.py",
        "class_name": "pandas.tests.series.indexing.conftest",
        "signature": "pandas.tests.series.indexing.conftest.test_data()",
        "snippet": "def test_data():\n    return TestData()",
        "begin_line": 7,
        "end_line": 8,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.common.TestData.ts#11",
        "src_path": "pandas/tests/series/common.py",
        "class_name": "pandas.tests.series.common.TestData",
        "signature": "pandas.tests.series.common.TestData.ts(self)",
        "snippet": "    def ts(self):\n        ts = _ts.copy()\n        ts.name = \"ts\"\n        return ts",
        "begin_line": 11,
        "end_line": 14,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.common.TestData.series#17",
        "src_path": "pandas/tests/series/common.py",
        "class_name": "pandas.tests.series.common.TestData",
        "signature": "pandas.tests.series.common.TestData.series(self)",
        "snippet": "    def series(self):\n        series = tm.makeStringSeries()\n        series.name = \"series\"\n        return series",
        "begin_line": 17,
        "end_line": 20,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.common.TestData.objSeries#23",
        "src_path": "pandas/tests/series/common.py",
        "class_name": "pandas.tests.series.common.TestData",
        "signature": "pandas.tests.series.common.TestData.objSeries(self)",
        "snippet": "    def objSeries(self):\n        objSeries = tm.makeObjectSeries()\n        objSeries.name = \"objects\"\n        return objSeries",
        "begin_line": 23,
        "end_line": 26,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.common.TestData.empty#29",
        "src_path": "pandas/tests/series/common.py",
        "class_name": "pandas.tests.series.common.TestData",
        "signature": "pandas.tests.series.common.TestData.empty(self)",
        "snippet": "    def empty(self):\n        return pd.Series([], index=[])",
        "begin_line": 29,
        "end_line": 30,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing._skip_if_no_pchip#30",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing",
        "signature": "pandas.tests.series.test_missing._skip_if_no_pchip()",
        "snippet": "def _skip_if_no_pchip():\n    try:\n        from scipy.interpolate import pchip_interpolate  # noqa\n    except ImportError:\n        import pytest\n\n        pytest.skip(\"scipy.interpolate.pchip missing\")",
        "begin_line": 30,
        "end_line": 36,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing._skip_if_no_akima#39",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing",
        "signature": "pandas.tests.series.test_missing._skip_if_no_akima()",
        "snippet": "def _skip_if_no_akima():\n    try:\n        from scipy.interpolate import Akima1DInterpolator  # noqa\n    except ImportError:\n        import pytest\n\n        pytest.skip(\"scipy.interpolate.Akima1DInterpolator missing\")",
        "begin_line": 39,
        "end_line": 45,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing._simple_ts#48",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing",
        "signature": "pandas.tests.series.test_missing._simple_ts(start, end, freq='D')",
        "snippet": "def _simple_ts(start, end, freq=\"D\"):\n    rng = date_range(start, end, freq=freq)\n    return Series(np.random.randn(len(rng)), index=rng)",
        "begin_line": 48,
        "end_line": 50,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_remove_na_deprecation#54",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_remove_na_deprecation(self)",
        "snippet": "    def test_remove_na_deprecation(self):\n        # see gh-16971\n        with tm.assert_produces_warning(FutureWarning):\n            remove_na(Series([]))",
        "begin_line": 54,
        "end_line": 57,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_timedelta_fillna#59",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_timedelta_fillna(self)",
        "snippet": "    def test_timedelta_fillna(self):\n        # GH 3371\n        s = Series(\n            [\n                Timestamp(\"20130101\"),\n                Timestamp(\"20130101\"),\n                Timestamp(\"20130102\"),\n                Timestamp(\"20130103 9:01:01\"),\n            ]\n        )\n        td = s.diff()\n\n        # reg fillna\n        with tm.assert_produces_warning(FutureWarning):\n            result = td.fillna(0)\n        expected = Series(\n            [\n                timedelta(0),\n                timedelta(0),\n                timedelta(1),\n                timedelta(days=1, seconds=9 * 3600 + 60 + 1),\n            ]\n        )\n        assert_series_equal(result, expected)\n\n        # interpreted as seconds, deprecated\n        with tm.assert_produces_warning(FutureWarning):\n            result = td.fillna(1)\n        expected = Series(\n            [\n                timedelta(seconds=1),\n                timedelta(0),\n                timedelta(1),\n                timedelta(days=1, seconds=9 * 3600 + 60 + 1),\n            ]\n        )\n        assert_series_equal(result, expected)\n\n        result = td.fillna(timedelta(days=1, seconds=1))\n        expected = Series(\n            [\n                timedelta(days=1, seconds=1),\n                timedelta(0),\n                timedelta(1),\n                timedelta(days=1, seconds=9 * 3600 + 60 + 1),\n            ]\n        )\n        assert_series_equal(result, expected)\n\n        result = td.fillna(np.timedelta64(int(1e9)))\n        expected = Series(\n            [\n                timedelta(seconds=1),\n                timedelta(0),\n                timedelta(1),\n                timedelta(days=1, seconds=9 * 3600 + 60 + 1),\n            ]\n        )\n        assert_series_equal(result, expected)\n\n        result = td.fillna(NaT)\n        expected = Series(\n            [\n                NaT,\n                timedelta(0),\n                timedelta(1),\n                timedelta(days=1, seconds=9 * 3600 + 60 + 1),\n            ],\n            dtype=\"m8[ns]\",\n        )\n        assert_series_equal(result, expected)\n\n        # ffill\n        td[2] = np.nan\n        result = td.ffill()\n        with tm.assert_produces_warning(FutureWarning):\n            expected = td.fillna(0)\n        expected[0] = np.nan\n        assert_series_equal(result, expected)\n\n        # bfill\n        td[2] = np.nan\n        result = td.bfill()\n        with tm.assert_produces_warning(FutureWarning):\n            expected = td.fillna(0)\n        expected[2] = timedelta(days=1, seconds=9 * 3600 + 60 + 1)\n        assert_series_equal(result, expected)",
        "begin_line": 59,
        "end_line": 145,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_datetime64_fillna#147",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_datetime64_fillna(self)",
        "snippet": "    def test_datetime64_fillna(self):\n\n        s = Series(\n            [\n                Timestamp(\"20130101\"),\n                Timestamp(\"20130101\"),\n                Timestamp(\"20130102\"),\n                Timestamp(\"20130103 9:01:01\"),\n            ]\n        )\n        s[2] = np.nan\n\n        # reg fillna\n        result = s.fillna(Timestamp(\"20130104\"))\n        expected = Series(\n            [\n                Timestamp(\"20130101\"),\n                Timestamp(\"20130101\"),\n                Timestamp(\"20130104\"),\n                Timestamp(\"20130103 9:01:01\"),\n            ]\n        )\n        assert_series_equal(result, expected)\n\n        result = s.fillna(NaT)\n        expected = s\n        assert_series_equal(result, expected)\n\n        # ffill\n        result = s.ffill()\n        expected = Series(\n            [\n                Timestamp(\"20130101\"),\n                Timestamp(\"20130101\"),\n                Timestamp(\"20130101\"),\n                Timestamp(\"20130103 9:01:01\"),\n            ]\n        )\n        assert_series_equal(result, expected)\n\n        # bfill\n        result = s.bfill()\n        expected = Series(\n            [\n                Timestamp(\"20130101\"),\n                Timestamp(\"20130101\"),\n                Timestamp(\"20130103 9:01:01\"),\n                Timestamp(\"20130103 9:01:01\"),\n            ]\n        )\n        assert_series_equal(result, expected)\n\n        # GH 6587\n        # make sure that we are treating as integer when filling\n        # this also tests inference of a datetime-like with NaT's\n        s = Series([pd.NaT, pd.NaT, \"2013-08-05 15:30:00.000001\"])\n        expected = Series(\n            [\n                \"2013-08-05 15:30:00.000001\",\n                \"2013-08-05 15:30:00.000001\",\n                \"2013-08-05 15:30:00.000001\",\n            ],\n            dtype=\"M8[ns]\",\n        )\n        result = s.fillna(method=\"backfill\")\n        assert_series_equal(result, expected)",
        "begin_line": 147,
        "end_line": 212,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_datetime64_tz_fillna#214",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_datetime64_tz_fillna(self)",
        "snippet": "    def test_datetime64_tz_fillna(self):\n\n        for tz in [\"US/Eastern\", \"Asia/Tokyo\"]:\n            # DatetimeBlock\n            s = Series(\n                [\n                    Timestamp(\"2011-01-01 10:00\"),\n                    pd.NaT,\n                    Timestamp(\"2011-01-03 10:00\"),\n                    pd.NaT,\n                ]\n            )\n            null_loc = pd.Series([False, True, False, True])\n\n            result = s.fillna(pd.Timestamp(\"2011-01-02 10:00\"))\n            expected = Series(\n                [\n                    Timestamp(\"2011-01-01 10:00\"),\n                    Timestamp(\"2011-01-02 10:00\"),\n                    Timestamp(\"2011-01-03 10:00\"),\n                    Timestamp(\"2011-01-02 10:00\"),\n                ]\n            )\n            tm.assert_series_equal(expected, result)\n            # check s is not changed\n            tm.assert_series_equal(pd.isna(s), null_loc)\n\n            result = s.fillna(pd.Timestamp(\"2011-01-02 10:00\", tz=tz))\n            expected = Series(\n                [\n                    Timestamp(\"2011-01-01 10:00\"),\n                    Timestamp(\"2011-01-02 10:00\", tz=tz),\n                    Timestamp(\"2011-01-03 10:00\"),\n                    Timestamp(\"2011-01-02 10:00\", tz=tz),\n                ]\n            )\n            tm.assert_series_equal(expected, result)\n            tm.assert_series_equal(pd.isna(s), null_loc)\n\n            result = s.fillna(\"AAA\")\n            expected = Series(\n                [\n                    Timestamp(\"2011-01-01 10:00\"),\n                    \"AAA\",\n                    Timestamp(\"2011-01-03 10:00\"),\n                    \"AAA\",\n                ],\n                dtype=object,\n            )\n            tm.assert_series_equal(expected, result)\n            tm.assert_series_equal(pd.isna(s), null_loc)\n\n            result = s.fillna(\n                {\n                    1: pd.Timestamp(\"2011-01-02 10:00\", tz=tz),\n                    3: pd.Timestamp(\"2011-01-04 10:00\"),\n                }\n            )\n            expected = Series(\n                [\n                    Timestamp(\"2011-01-01 10:00\"),\n                    Timestamp(\"2011-01-02 10:00\", tz=tz),\n                    Timestamp(\"2011-01-03 10:00\"),\n                    Timestamp(\"2011-01-04 10:00\"),\n                ]\n            )\n            tm.assert_series_equal(expected, result)\n            tm.assert_series_equal(pd.isna(s), null_loc)\n\n            result = s.fillna(\n                {\n                    1: pd.Timestamp(\"2011-01-02 10:00\"),\n                    3: pd.Timestamp(\"2011-01-04 10:00\"),\n                }\n            )\n            expected = Series(\n                [\n                    Timestamp(\"2011-01-01 10:00\"),\n                    Timestamp(\"2011-01-02 10:00\"),\n                    Timestamp(\"2011-01-03 10:00\"),\n                    Timestamp(\"2011-01-04 10:00\"),\n                ]\n            )\n            tm.assert_series_equal(expected, result)\n            tm.assert_series_equal(pd.isna(s), null_loc)\n\n            # DatetimeBlockTZ\n            idx = pd.DatetimeIndex(\n                [\"2011-01-01 10:00\", pd.NaT, \"2011-01-03 10:00\", pd.NaT], tz=tz\n            )\n            s = pd.Series(idx)\n            assert s.dtype == \"datetime64[ns, {0}]\".format(tz)\n            tm.assert_series_equal(pd.isna(s), null_loc)\n\n            result = s.fillna(pd.Timestamp(\"2011-01-02 10:00\"))\n            expected = Series(\n                [\n                    Timestamp(\"2011-01-01 10:00\", tz=tz),\n                    Timestamp(\"2011-01-02 10:00\"),\n                    Timestamp(\"2011-01-03 10:00\", tz=tz),\n                    Timestamp(\"2011-01-02 10:00\"),\n                ]\n            )\n            tm.assert_series_equal(expected, result)\n            tm.assert_series_equal(pd.isna(s), null_loc)\n\n            result = s.fillna(pd.Timestamp(\"2011-01-02 10:00\", tz=tz))\n            idx = pd.DatetimeIndex(\n                [\n                    \"2011-01-01 10:00\",\n                    \"2011-01-02 10:00\",\n                    \"2011-01-03 10:00\",\n                    \"2011-01-02 10:00\",\n                ],\n                tz=tz,\n            )\n            expected = Series(idx)\n            tm.assert_series_equal(expected, result)\n            tm.assert_series_equal(pd.isna(s), null_loc)\n\n            result = s.fillna(pd.Timestamp(\"2011-01-02 10:00\", tz=tz).to_pydatetime())\n            idx = pd.DatetimeIndex(\n                [\n                    \"2011-01-01 10:00\",\n                    \"2011-01-02 10:00\",\n                    \"2011-01-03 10:00\",\n                    \"2011-01-02 10:00\",\n                ],\n                tz=tz,\n            )\n            expected = Series(idx)\n            tm.assert_series_equal(expected, result)\n            tm.assert_series_equal(pd.isna(s), null_loc)\n\n            result = s.fillna(\"AAA\")\n            expected = Series(\n                [\n                    Timestamp(\"2011-01-01 10:00\", tz=tz),\n                    \"AAA\",\n                    Timestamp(\"2011-01-03 10:00\", tz=tz),\n                    \"AAA\",\n                ],\n                dtype=object,\n            )\n            tm.assert_series_equal(expected, result)\n            tm.assert_series_equal(pd.isna(s), null_loc)\n\n            result = s.fillna(\n                {\n                    1: pd.Timestamp(\"2011-01-02 10:00\", tz=tz),\n                    3: pd.Timestamp(\"2011-01-04 10:00\"),\n                }\n            )\n            expected = Series(\n                [\n                    Timestamp(\"2011-01-01 10:00\", tz=tz),\n                    Timestamp(\"2011-01-02 10:00\", tz=tz),\n                    Timestamp(\"2011-01-03 10:00\", tz=tz),\n                    Timestamp(\"2011-01-04 10:00\"),\n                ]\n            )\n            tm.assert_series_equal(expected, result)\n            tm.assert_series_equal(pd.isna(s), null_loc)\n\n            result = s.fillna(\n                {\n                    1: pd.Timestamp(\"2011-01-02 10:00\", tz=tz),\n                    3: pd.Timestamp(\"2011-01-04 10:00\", tz=tz),\n                }\n            )\n            expected = Series(\n                [\n                    Timestamp(\"2011-01-01 10:00\", tz=tz),\n                    Timestamp(\"2011-01-02 10:00\", tz=tz),\n                    Timestamp(\"2011-01-03 10:00\", tz=tz),\n                    Timestamp(\"2011-01-04 10:00\", tz=tz),\n                ]\n            )\n            tm.assert_series_equal(expected, result)\n            tm.assert_series_equal(pd.isna(s), null_loc)\n\n            # filling with a naive/other zone, coerce to object\n            result = s.fillna(Timestamp(\"20130101\"))\n            expected = Series(\n                [\n                    Timestamp(\"2011-01-01 10:00\", tz=tz),\n                    Timestamp(\"2013-01-01\"),\n                    Timestamp(\"2011-01-03 10:00\", tz=tz),\n                    Timestamp(\"2013-01-01\"),\n                ]\n            )\n            tm.assert_series_equal(expected, result)\n            tm.assert_series_equal(pd.isna(s), null_loc)\n\n            result = s.fillna(Timestamp(\"20130101\", tz=\"US/Pacific\"))\n            expected = Series(\n                [\n                    Timestamp(\"2011-01-01 10:00\", tz=tz),\n                    Timestamp(\"2013-01-01\", tz=\"US/Pacific\"),\n                    Timestamp(\"2011-01-03 10:00\", tz=tz),\n                    Timestamp(\"2013-01-01\", tz=\"US/Pacific\"),\n                ]\n            )\n            tm.assert_series_equal(expected, result)\n            tm.assert_series_equal(pd.isna(s), null_loc)\n\n        # with timezone\n        # GH 15855\n        df = pd.Series([pd.Timestamp(\"2012-11-11 00:00:00+01:00\"), pd.NaT])\n        exp = pd.Series(\n            [\n                pd.Timestamp(\"2012-11-11 00:00:00+01:00\"),\n                pd.Timestamp(\"2012-11-11 00:00:00+01:00\"),\n            ]\n        )\n        assert_series_equal(df.fillna(method=\"pad\"), exp)\n\n        df = pd.Series([pd.NaT, pd.Timestamp(\"2012-11-11 00:00:00+01:00\")])\n        exp = pd.Series(\n            [\n                pd.Timestamp(\"2012-11-11 00:00:00+01:00\"),\n                pd.Timestamp(\"2012-11-11 00:00:00+01:00\"),\n            ]\n        )\n        assert_series_equal(df.fillna(method=\"bfill\"), exp)",
        "begin_line": 214,
        "end_line": 438,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_datetime64_non_nano_fillna#440",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_datetime64_non_nano_fillna(self)",
        "snippet": "    def test_datetime64_non_nano_fillna(self):\n        # GH#27419\n        ser = Series([Timestamp(\"2010-01-01\"), pd.NaT, Timestamp(\"2000-01-01\")])\n        val = np.datetime64(\"1975-04-05\", \"ms\")\n\n        result = ser.fillna(val)\n        expected = Series(\n            [Timestamp(\"2010-01-01\"), Timestamp(\"1975-04-05\"), Timestamp(\"2000-01-01\")]\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 440,
        "end_line": 449,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_consistency#451",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_consistency(self)",
        "snippet": "    def test_fillna_consistency(self):\n        # GH 16402\n        # fillna with a tz aware to a tz-naive, should result in object\n\n        s = Series([Timestamp(\"20130101\"), pd.NaT])\n\n        result = s.fillna(Timestamp(\"20130101\", tz=\"US/Eastern\"))\n        expected = Series(\n            [Timestamp(\"20130101\"), Timestamp(\"2013-01-01\", tz=\"US/Eastern\")],\n            dtype=\"object\",\n        )\n        assert_series_equal(result, expected)\n\n        # where (we ignore the errors=)\n        result = s.where(\n            [True, False], Timestamp(\"20130101\", tz=\"US/Eastern\"), errors=\"ignore\"\n        )\n        assert_series_equal(result, expected)\n\n        result = s.where(\n            [True, False], Timestamp(\"20130101\", tz=\"US/Eastern\"), errors=\"ignore\"\n        )\n        assert_series_equal(result, expected)\n\n        # with a non-datetime\n        result = s.fillna(\"foo\")\n        expected = Series([Timestamp(\"20130101\"), \"foo\"])\n        assert_series_equal(result, expected)\n\n        # assignment\n        s2 = s.copy()\n        s2[1] = \"foo\"\n        assert_series_equal(s2, expected)",
        "begin_line": 451,
        "end_line": 483,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_datetime64tz_fillna_round_issue#485",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_datetime64tz_fillna_round_issue(self)",
        "snippet": "    def test_datetime64tz_fillna_round_issue(self):\n        # GH 14872\n\n        data = pd.Series(\n            [pd.NaT, pd.NaT, datetime(2016, 12, 12, 22, 24, 6, 100001, tzinfo=pytz.utc)]\n        )\n\n        filled = data.fillna(method=\"bfill\")\n\n        expected = pd.Series(\n            [\n                datetime(2016, 12, 12, 22, 24, 6, 100001, tzinfo=pytz.utc),\n                datetime(2016, 12, 12, 22, 24, 6, 100001, tzinfo=pytz.utc),\n                datetime(2016, 12, 12, 22, 24, 6, 100001, tzinfo=pytz.utc),\n            ]\n        )\n\n        assert_series_equal(filled, expected)",
        "begin_line": 485,
        "end_line": 502,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_downcast#504",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_downcast(self)",
        "snippet": "    def test_fillna_downcast(self):\n        # GH 15277\n        # infer int64 from float64\n        s = pd.Series([1.0, np.nan])\n        result = s.fillna(0, downcast=\"infer\")\n        expected = pd.Series([1, 0])\n        assert_series_equal(result, expected)\n\n        # infer int64 from float64 when fillna value is a dict\n        s = pd.Series([1.0, np.nan])\n        result = s.fillna({1: 0}, downcast=\"infer\")\n        expected = pd.Series([1, 0])\n        assert_series_equal(result, expected)",
        "begin_line": 504,
        "end_line": 516,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_int#518",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_int(self)",
        "snippet": "    def test_fillna_int(self):\n        s = Series(np.random.randint(-100, 100, 50))\n        s.fillna(method=\"ffill\", inplace=True)\n        assert_series_equal(s.fillna(method=\"ffill\", inplace=False), s)",
        "begin_line": 518,
        "end_line": 521,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_raise#523",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_raise(self)",
        "snippet": "    def test_fillna_raise(self):\n        s = Series(np.random.randint(-100, 100, 50))\n        msg = '\"value\" parameter must be a scalar or dict, but you passed a' ' \"list\"'\n        with pytest.raises(TypeError, match=msg):\n            s.fillna([1, 2])\n\n        msg = '\"value\" parameter must be a scalar or dict, but you passed a' ' \"tuple\"'\n        with pytest.raises(TypeError, match=msg):\n            s.fillna((1, 2))\n\n        # related GH 9217, make sure limit is an int and greater than 0\n        s = Series([1, 2, 3, None])\n        msg = (\n            r\"Cannot specify both 'value' and 'method'\\.|\"\n            r\"Limit must be greater than 0|\"\n            \"Limit must be an integer\"\n        )\n        for limit in [-1, 0, 1.0, 2.0]:\n            for method in [\"backfill\", \"bfill\", \"pad\", \"ffill\", None]:\n                with pytest.raises(ValueError, match=msg):\n                    s.fillna(1, limit=limit, method=method)",
        "begin_line": 523,
        "end_line": 543,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_categorical_nan_equality#545",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_categorical_nan_equality(self)",
        "snippet": "    def test_categorical_nan_equality(self):\n        cat = Series(Categorical([\"a\", \"b\", \"c\", np.nan]))\n        exp = Series([True, True, True, False])\n        res = cat == cat\n        tm.assert_series_equal(res, exp)",
        "begin_line": 545,
        "end_line": 549,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_categorical_nan_handling#551",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_categorical_nan_handling(self)",
        "snippet": "    def test_categorical_nan_handling(self):\n\n        # NaNs are represented as -1 in labels\n        s = Series(Categorical([\"a\", \"b\", np.nan, \"a\"]))\n        tm.assert_index_equal(s.cat.categories, Index([\"a\", \"b\"]))\n        tm.assert_numpy_array_equal(\n            s.values.codes, np.array([0, 1, -1, 0], dtype=np.int8)\n        )",
        "begin_line": 551,
        "end_line": 558,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_categorical#573",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_categorical(self, fill_value, expected_output)",
        "snippet": "    def test_fillna_categorical(self, fill_value, expected_output):\n        # GH 17033\n        # Test fillna for a Categorical series\n        data = [\"a\", np.nan, \"b\", np.nan, np.nan]\n        s = Series(Categorical(data, categories=[\"a\", \"b\"]))\n        exp = Series(Categorical(expected_output, categories=[\"a\", \"b\"]))\n        tm.assert_series_equal(s.fillna(fill_value), exp)",
        "begin_line": 573,
        "end_line": 579,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_categorical_with_new_categories#596",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_categorical_with_new_categories(self, fill_value, expected_output)",
        "snippet": "    def test_fillna_categorical_with_new_categories(self, fill_value, expected_output):\n        # GH 26215\n        data = [\"a\", np.nan, \"b\", np.nan, np.nan]\n        s = Series(Categorical(data, categories=[\"a\", \"b\", \"c\", \"d\", \"e\"]))\n        exp = Series(Categorical(expected_output, categories=[\"a\", \"b\", \"c\", \"d\", \"e\"]))\n        tm.assert_series_equal(s.fillna(fill_value), exp)",
        "begin_line": 596,
        "end_line": 601,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_categorical_raise#603",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_categorical_raise(self)",
        "snippet": "    def test_fillna_categorical_raise(self):\n        data = [\"a\", np.nan, \"b\", np.nan, np.nan]\n        s = Series(Categorical(data, categories=[\"a\", \"b\"]))\n\n        with pytest.raises(ValueError, match=\"fill value must be in categories\"):\n            s.fillna(\"d\")\n\n        with pytest.raises(ValueError, match=\"fill value must be in categories\"):\n            s.fillna(Series(\"d\"))\n\n        with pytest.raises(ValueError, match=\"fill value must be in categories\"):\n            s.fillna({1: \"d\", 3: \"a\"})\n\n        msg = '\"value\" parameter must be a scalar or ' 'dict, but you passed a \"list\"'\n        with pytest.raises(TypeError, match=msg):\n            s.fillna([\"a\", \"b\"])\n\n        msg = '\"value\" parameter must be a scalar or ' 'dict, but you passed a \"tuple\"'\n        with pytest.raises(TypeError, match=msg):\n            s.fillna((\"a\", \"b\"))\n\n        msg = (\n            '\"value\" parameter must be a scalar, dict '\n            'or Series, but you passed a \"DataFrame\"'\n        )\n        with pytest.raises(TypeError, match=msg):\n            s.fillna(DataFrame({1: [\"a\"], 3: [\"b\"]}))",
        "begin_line": 603,
        "end_line": 629,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_nat#631",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_nat(self)",
        "snippet": "    def test_fillna_nat(self):\n        series = Series([0, 1, 2, iNaT], dtype=\"M8[ns]\")\n\n        filled = series.fillna(method=\"pad\")\n        filled2 = series.fillna(value=series.values[2])\n\n        expected = series.copy()\n        expected.values[3] = expected.values[2]\n\n        assert_series_equal(filled, expected)\n        assert_series_equal(filled2, expected)\n\n        df = DataFrame({\"A\": series})\n        filled = df.fillna(method=\"pad\")\n        filled2 = df.fillna(value=series.values[2])\n        expected = DataFrame({\"A\": expected})\n        assert_frame_equal(filled, expected)\n        assert_frame_equal(filled2, expected)\n\n        series = Series([iNaT, 0, 1, 2], dtype=\"M8[ns]\")\n\n        filled = series.fillna(method=\"bfill\")\n        filled2 = series.fillna(value=series[1])\n\n        expected = series.copy()\n        expected[0] = expected[1]\n\n        assert_series_equal(filled, expected)\n        assert_series_equal(filled2, expected)\n\n        df = DataFrame({\"A\": series})\n        filled = df.fillna(method=\"bfill\")\n        filled2 = df.fillna(value=series[1])\n        expected = DataFrame({\"A\": expected})\n        assert_frame_equal(filled, expected)\n        assert_frame_equal(filled2, expected)",
        "begin_line": 631,
        "end_line": 666,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_isna_for_inf#668",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_isna_for_inf(self)",
        "snippet": "    def test_isna_for_inf(self):\n        s = Series([\"a\", np.inf, np.nan, 1.0])\n        with pd.option_context(\"mode.use_inf_as_na\", True):\n            r = s.isna()\n            dr = s.dropna()\n        e = Series([False, True, True, False])\n        de = Series([\"a\", 1.0], index=[0, 3])\n        tm.assert_series_equal(r, e)\n        tm.assert_series_equal(dr, de)",
        "begin_line": 668,
        "end_line": 676,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_isnull_for_inf_deprecated#678",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_isnull_for_inf_deprecated(self)",
        "snippet": "    def test_isnull_for_inf_deprecated(self):\n        # gh-17115\n        s = Series([\"a\", np.inf, np.nan, 1.0])\n        with pd.option_context(\"mode.use_inf_as_null\", True):\n            r = s.isna()\n            dr = s.dropna()\n\n        e = Series([False, True, True, False])\n        de = Series([\"a\", 1.0], index=[0, 3])\n        tm.assert_series_equal(r, e)\n        tm.assert_series_equal(dr, de)",
        "begin_line": 678,
        "end_line": 688,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna#690",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna(self, datetime_series)",
        "snippet": "    def test_fillna(self, datetime_series):\n        ts = Series([0.0, 1.0, 2.0, 3.0, 4.0], index=tm.makeDateIndex(5))\n\n        tm.assert_series_equal(ts, ts.fillna(method=\"ffill\"))\n\n        ts[2] = np.NaN\n\n        exp = Series([0.0, 1.0, 1.0, 3.0, 4.0], index=ts.index)\n        tm.assert_series_equal(ts.fillna(method=\"ffill\"), exp)\n\n        exp = Series([0.0, 1.0, 3.0, 3.0, 4.0], index=ts.index)\n        tm.assert_series_equal(ts.fillna(method=\"backfill\"), exp)\n\n        exp = Series([0.0, 1.0, 5.0, 3.0, 4.0], index=ts.index)\n        tm.assert_series_equal(ts.fillna(value=5), exp)\n\n        msg = \"Must specify a fill 'value' or 'method'\"\n        with pytest.raises(ValueError, match=msg):\n            ts.fillna()\n\n        msg = \"Cannot specify both 'value' and 'method'\"\n        with pytest.raises(ValueError, match=msg):\n            datetime_series.fillna(value=0, method=\"ffill\")\n\n        # GH 5703\n        s1 = Series([np.nan])\n        s2 = Series([1])\n        result = s1.fillna(s2)\n        expected = Series([1.0])\n        assert_series_equal(result, expected)\n        result = s1.fillna({})\n        assert_series_equal(result, s1)\n        result = s1.fillna(Series(()))\n        assert_series_equal(result, s1)\n        result = s2.fillna(s1)\n        assert_series_equal(result, s2)\n        result = s1.fillna({0: 1})\n        assert_series_equal(result, expected)\n        result = s1.fillna({1: 1})\n        assert_series_equal(result, Series([np.nan]))\n        result = s1.fillna({0: 1, 1: 1})\n        assert_series_equal(result, expected)\n        result = s1.fillna(Series({0: 1, 1: 1}))\n        assert_series_equal(result, expected)\n        result = s1.fillna(Series({0: 1, 1: 1}, index=[4, 5]))\n        assert_series_equal(result, s1)\n\n        s1 = Series([0, 1, 2], list(\"abc\"))\n        s2 = Series([0, np.nan, 2], list(\"bac\"))\n        result = s2.fillna(s1)\n        expected = Series([0, 0, 2.0], list(\"bac\"))\n        assert_series_equal(result, expected)\n\n        # limit\n        s = Series(np.nan, index=[0, 1, 2])\n        result = s.fillna(999, limit=1)\n        expected = Series([999, np.nan, np.nan], index=[0, 1, 2])\n        assert_series_equal(result, expected)\n\n        result = s.fillna(999, limit=2)\n        expected = Series([999, 999, np.nan], index=[0, 1, 2])\n        assert_series_equal(result, expected)\n\n        # GH 9043\n        # make sure a string representation of int/float values can be filled\n        # correctly without raising errors or being converted\n        vals = [\"0\", \"1.5\", \"-0.3\"]\n        for val in vals:\n            s = Series([0, 1, np.nan, np.nan, 4], dtype=\"float64\")\n            result = s.fillna(val)\n            expected = Series([0, 1, val, val, 4], dtype=\"object\")\n            assert_series_equal(result, expected)",
        "begin_line": 690,
        "end_line": 761,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_bug#763",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_bug(self)",
        "snippet": "    def test_fillna_bug(self):\n        x = Series([nan, 1.0, nan, 3.0, nan], [\"z\", \"a\", \"b\", \"c\", \"d\"])\n        filled = x.fillna(method=\"ffill\")\n        expected = Series([nan, 1.0, 1.0, 3.0, 3.0], x.index)\n        assert_series_equal(filled, expected)\n\n        filled = x.fillna(method=\"bfill\")\n        expected = Series([1.0, 1.0, 3.0, 3.0, nan], x.index)\n        assert_series_equal(filled, expected)",
        "begin_line": 763,
        "end_line": 771,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_inplace#773",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_inplace(self)",
        "snippet": "    def test_fillna_inplace(self):\n        x = Series([nan, 1.0, nan, 3.0, nan], [\"z\", \"a\", \"b\", \"c\", \"d\"])\n        y = x.copy()\n\n        y.fillna(value=0, inplace=True)\n\n        expected = x.fillna(value=0)\n        assert_series_equal(y, expected)",
        "begin_line": 773,
        "end_line": 780,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_invalid_method#782",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fillna_invalid_method(self, datetime_series)",
        "snippet": "    def test_fillna_invalid_method(self, datetime_series):\n        try:\n            datetime_series.fillna(method=\"ffil\")\n        except ValueError as inst:\n            assert \"ffil\" in str(inst)",
        "begin_line": 782,
        "end_line": 786,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_ffill#788",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_ffill(self)",
        "snippet": "    def test_ffill(self):\n        ts = Series([0.0, 1.0, 2.0, 3.0, 4.0], index=tm.makeDateIndex(5))\n        ts[2] = np.NaN\n        assert_series_equal(ts.ffill(), ts.fillna(method=\"ffill\"))",
        "begin_line": 788,
        "end_line": 791,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_ffill_mixed_dtypes_without_missing_data#793",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_ffill_mixed_dtypes_without_missing_data(self)",
        "snippet": "    def test_ffill_mixed_dtypes_without_missing_data(self):\n        # GH14956\n        series = pd.Series([datetime(2015, 1, 1, tzinfo=pytz.utc), 1])\n        result = series.ffill()\n        assert_series_equal(series, result)",
        "begin_line": 793,
        "end_line": 797,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_bfill#799",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_bfill(self)",
        "snippet": "    def test_bfill(self):\n        ts = Series([0.0, 1.0, 2.0, 3.0, 4.0], index=tm.makeDateIndex(5))\n        ts[2] = np.NaN\n        assert_series_equal(ts.bfill(), ts.fillna(method=\"bfill\"))",
        "begin_line": 799,
        "end_line": 802,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_timedelta64_nan#804",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_timedelta64_nan(self)",
        "snippet": "    def test_timedelta64_nan(self):\n\n        td = Series([timedelta(days=i) for i in range(10)])\n\n        # nan ops on timedeltas\n        td1 = td.copy()\n        td1[0] = np.nan\n        assert isna(td1[0])\n        assert td1[0].value == iNaT\n        td1[0] = td[0]\n        assert not isna(td1[0])\n\n        # GH#16674 iNaT is treated as an integer when given by the user\n        td1[1] = iNaT\n        assert not isna(td1[1])\n        assert td1.dtype == np.object_\n        assert td1[1] == iNaT\n        td1[1] = td[1]\n        assert not isna(td1[1])\n\n        td1[2] = NaT\n        assert isna(td1[2])\n        assert td1[2].value == iNaT\n        td1[2] = td[2]\n        assert not isna(td1[2])",
        "begin_line": 804,
        "end_line": 828,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_dropna_empty#845",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_dropna_empty(self)",
        "snippet": "    def test_dropna_empty(self):\n        s = Series([])\n        assert len(s.dropna()) == 0\n        s.dropna(inplace=True)\n        assert len(s) == 0\n\n        # invalid axis\n        msg = \"No axis named 1 for object type <class 'pandas.core.series.Series'>\"\n        with pytest.raises(ValueError, match=msg):\n            s.dropna(axis=1)",
        "begin_line": 845,
        "end_line": 854,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_datetime64_tz_dropna#856",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_datetime64_tz_dropna(self)",
        "snippet": "    def test_datetime64_tz_dropna(self):\n        # DatetimeBlock\n        s = Series(\n            [\n                Timestamp(\"2011-01-01 10:00\"),\n                pd.NaT,\n                Timestamp(\"2011-01-03 10:00\"),\n                pd.NaT,\n            ]\n        )\n        result = s.dropna()\n        expected = Series(\n            [Timestamp(\"2011-01-01 10:00\"), Timestamp(\"2011-01-03 10:00\")], index=[0, 2]\n        )\n        tm.assert_series_equal(result, expected)\n\n        # DatetimeBlockTZ\n        idx = pd.DatetimeIndex(\n            [\"2011-01-01 10:00\", pd.NaT, \"2011-01-03 10:00\", pd.NaT], tz=\"Asia/Tokyo\"\n        )\n        s = pd.Series(idx)\n        assert s.dtype == \"datetime64[ns, Asia/Tokyo]\"\n        result = s.dropna()\n        expected = Series(\n            [\n                Timestamp(\"2011-01-01 10:00\", tz=\"Asia/Tokyo\"),\n                Timestamp(\"2011-01-03 10:00\", tz=\"Asia/Tokyo\"),\n            ],\n            index=[0, 2],\n        )\n        assert result.dtype == \"datetime64[ns, Asia/Tokyo]\"\n        tm.assert_series_equal(result, expected)",
        "begin_line": 856,
        "end_line": 887,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_dropna_no_nan#889",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_dropna_no_nan(self)",
        "snippet": "    def test_dropna_no_nan(self):\n        for s in [Series([1, 2, 3], name=\"x\"), Series([False, True, False], name=\"x\")]:\n\n            result = s.dropna()\n            tm.assert_series_equal(result, s)\n            assert result is not s\n\n            s2 = s.copy()\n            s2.dropna(inplace=True)\n            tm.assert_series_equal(s2, s)",
        "begin_line": 889,
        "end_line": 898,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_dropna_intervals#900",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_dropna_intervals(self)",
        "snippet": "    def test_dropna_intervals(self):\n        s = Series(\n            [np.nan, 1, 2, 3],\n            IntervalIndex.from_arrays([np.nan, 0, 1, 2], [np.nan, 1, 2, 3]),\n        )\n\n        result = s.dropna()\n        expected = s.iloc[1:]\n        assert_series_equal(result, expected)",
        "begin_line": 900,
        "end_line": 908,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_valid#910",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_valid(self, datetime_series)",
        "snippet": "    def test_valid(self, datetime_series):\n        ts = datetime_series.copy()\n        ts[::2] = np.NaN\n\n        result = ts.dropna()\n        assert len(result) == ts.count()\n        tm.assert_series_equal(result, ts[1::2])\n        tm.assert_series_equal(result, ts[pd.notna(ts)])",
        "begin_line": 910,
        "end_line": 917,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_isna#919",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_isna(self)",
        "snippet": "    def test_isna(self):\n        ser = Series([0, 5.4, 3, nan, -0.001])\n        expected = Series([False, False, False, True, False])\n        tm.assert_series_equal(ser.isna(), expected)\n\n        ser = Series([\"hi\", \"\", nan])\n        expected = Series([False, False, True])\n        tm.assert_series_equal(ser.isna(), expected)",
        "begin_line": 919,
        "end_line": 926,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_notna#928",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_notna(self)",
        "snippet": "    def test_notna(self):\n        ser = Series([0, 5.4, 3, nan, -0.001])\n        expected = Series([True, True, True, False, True])\n        tm.assert_series_equal(ser.notna(), expected)\n\n        ser = Series([\"hi\", \"\", nan])\n        expected = Series([True, True, False])\n        tm.assert_series_equal(ser.notna(), expected)",
        "begin_line": 928,
        "end_line": 935,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_pad_nan#937",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_pad_nan(self)",
        "snippet": "    def test_pad_nan(self):\n        x = Series(\n            [np.nan, 1.0, np.nan, 3.0, np.nan], [\"z\", \"a\", \"b\", \"c\", \"d\"], dtype=float\n        )\n\n        x.fillna(method=\"pad\", inplace=True)\n\n        expected = Series(\n            [np.nan, 1.0, 1.0, 3.0, 3.0], [\"z\", \"a\", \"b\", \"c\", \"d\"], dtype=float\n        )\n        assert_series_equal(x[1:], expected[1:])\n        assert np.isnan(x[0]), np.isnan(expected[0])",
        "begin_line": 937,
        "end_line": 948,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_pad_require_monotonicity#950",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_pad_require_monotonicity(self)",
        "snippet": "    def test_pad_require_monotonicity(self):\n        rng = date_range(\"1/1/2000\", \"3/1/2000\", freq=\"B\")\n\n        # neither monotonic increasing or decreasing\n        rng2 = rng[[1, 0, 2]]\n\n        msg = \"index must be monotonic increasing or decreasing\"\n        with pytest.raises(ValueError, match=msg):\n            rng2.get_indexer(rng, method=\"pad\")",
        "begin_line": 950,
        "end_line": 958,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_dropna_preserve_name#960",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_dropna_preserve_name(self, datetime_series)",
        "snippet": "    def test_dropna_preserve_name(self, datetime_series):\n        datetime_series[:5] = np.nan\n        result = datetime_series.dropna()\n        assert result.name == datetime_series.name\n        name = datetime_series.name\n        ts = datetime_series.copy()\n        ts.dropna(inplace=True)\n        assert ts.name == name",
        "begin_line": 960,
        "end_line": 967,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fill_value_when_combine_const#969",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_fill_value_when_combine_const(self)",
        "snippet": "    def test_fill_value_when_combine_const(self):\n        # GH12723\n        s = Series([0, 1, np.nan, 3, 4, 5])\n\n        exp = s.fillna(0).add(2)\n        res = s.add(2, fill_value=0)\n        assert_series_equal(res, exp)",
        "begin_line": 969,
        "end_line": 975,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_series_fillna_limit#977",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_series_fillna_limit(self)",
        "snippet": "    def test_series_fillna_limit(self):\n        index = np.arange(10)\n        s = Series(np.random.randn(10), index=index)\n\n        result = s[:2].reindex(index)\n        result = result.fillna(method=\"pad\", limit=5)\n\n        expected = s[:2].reindex(index).fillna(method=\"pad\")\n        expected[-3:] = np.nan\n        assert_series_equal(result, expected)\n\n        result = s[-2:].reindex(index)\n        result = result.fillna(method=\"bfill\", limit=5)\n\n        expected = s[-2:].reindex(index).fillna(method=\"backfill\")\n        expected[:3] = np.nan\n        assert_series_equal(result, expected)",
        "begin_line": 977,
        "end_line": 993,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_sparse_series_fillna_limit#997",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_sparse_series_fillna_limit(self)",
        "snippet": "    def test_sparse_series_fillna_limit(self):\n        index = np.arange(10)\n        s = Series(np.random.randn(10), index=index)\n\n        ss = s[:2].reindex(index).to_sparse()\n        # TODO: what is this test doing? why are result an expected\n        # the same call to fillna?\n        with tm.assert_produces_warning(\n            PerformanceWarning, raise_on_extra_warnings=False\n        ):\n            # TODO: release-note fillna performance warning\n            result = ss.fillna(method=\"pad\", limit=5)\n            expected = ss.fillna(method=\"pad\", limit=5)\n        expected = expected.to_dense()\n        expected[-3:] = np.nan\n        expected = expected.to_sparse()\n        assert_series_equal(result, expected)\n\n        ss = s[-2:].reindex(index).to_sparse()\n        with tm.assert_produces_warning(\n            PerformanceWarning, raise_on_extra_warnings=False\n        ):\n            result = ss.fillna(method=\"backfill\", limit=5)\n            expected = ss.fillna(method=\"backfill\")\n        expected = expected.to_dense()\n        expected[:3] = np.nan\n        expected = expected.to_sparse()\n        assert_series_equal(result, expected)",
        "begin_line": 997,
        "end_line": 1024,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_sparse_series_pad_backfill_limit#1028",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_sparse_series_pad_backfill_limit(self)",
        "snippet": "    def test_sparse_series_pad_backfill_limit(self):\n        index = np.arange(10)\n        s = Series(np.random.randn(10), index=index)\n        s = s.to_sparse()\n\n        result = s[:2].reindex(index, method=\"pad\", limit=5)\n        with tm.assert_produces_warning(\n            PerformanceWarning, raise_on_extra_warnings=False\n        ):\n            expected = s[:2].reindex(index).fillna(method=\"pad\")\n        expected = expected.to_dense()\n        expected[-3:] = np.nan\n        expected = expected.to_sparse()\n        assert_series_equal(result, expected)\n\n        result = s[-2:].reindex(index, method=\"backfill\", limit=5)\n        with tm.assert_produces_warning(\n            PerformanceWarning, raise_on_extra_warnings=False\n        ):\n            expected = s[-2:].reindex(index).fillna(method=\"backfill\")\n        expected = expected.to_dense()\n        expected[:3] = np.nan\n        expected = expected.to_sparse()\n        assert_series_equal(result, expected)",
        "begin_line": 1028,
        "end_line": 1051,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesMissingData.test_series_pad_backfill_limit#1054",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesMissingData",
        "signature": "pandas.tests.series.test_missing.TestSeriesMissingData.test_series_pad_backfill_limit(self)",
        "snippet": "    def test_series_pad_backfill_limit(self):\n        index = np.arange(10)\n        s = Series(np.random.randn(10), index=index)\n\n        result = s[:2].reindex(index, method=\"pad\", limit=5)\n\n        expected = s[:2].reindex(index).fillna(method=\"pad\")\n        expected[-3:] = np.nan\n        assert_series_equal(result, expected)\n\n        result = s[-2:].reindex(index, method=\"backfill\", limit=5)\n\n        expected = s[-2:].reindex(index).fillna(method=\"backfill\")\n        expected[:3] = np.nan\n        assert_series_equal(result, expected)",
        "begin_line": 1054,
        "end_line": 1068,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.nontemporal_method#1091",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing",
        "signature": "pandas.tests.series.test_missing.nontemporal_method(request)",
        "snippet": "def nontemporal_method(request):\n    \"\"\" Fixture that returns an (method name, required kwargs) pair.\n\n    This fixture does not include method 'time' as a parameterization; that\n    method requires a Series with a DatetimeIndex, and is generally tested\n    separately from these non-temporal methods.\n    \"\"\"\n    method = request.param\n    kwargs = dict(order=1) if method in (\"spline\", \"polynomial\") else dict()\n    return method, kwargs",
        "begin_line": 1091,
        "end_line": 1100,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.interp_methods_ind#1120",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing",
        "signature": "pandas.tests.series.test_missing.interp_methods_ind(request)",
        "snippet": "def interp_methods_ind(request):\n    \"\"\" Fixture that returns a (method name, required kwargs) pair to\n    be tested for various Index types.\n\n    This fixture does not include methods - 'time', 'index', 'nearest',\n    'values' as a parameterization\n    \"\"\"\n    method = request.param\n    kwargs = dict(order=1) if method in (\"spline\", \"polynomial\") else dict()\n    return method, kwargs",
        "begin_line": 1120,
        "end_line": 1129,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate#1133",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate(self, datetime_series, string_series)",
        "snippet": "    def test_interpolate(self, datetime_series, string_series):\n        ts = Series(np.arange(len(datetime_series), dtype=float), datetime_series.index)\n\n        ts_copy = ts.copy()\n        ts_copy[5:10] = np.NaN\n\n        linear_interp = ts_copy.interpolate(method=\"linear\")\n        tm.assert_series_equal(linear_interp, ts)\n\n        ord_ts = Series(\n            [d.toordinal() for d in datetime_series.index], index=datetime_series.index\n        ).astype(float)\n\n        ord_ts_copy = ord_ts.copy()\n        ord_ts_copy[5:10] = np.NaN\n\n        time_interp = ord_ts_copy.interpolate(method=\"time\")\n        tm.assert_series_equal(time_interp, ord_ts)",
        "begin_line": 1133,
        "end_line": 1150,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_time_raises_for_non_timeseries#1152",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_time_raises_for_non_timeseries(self)",
        "snippet": "    def test_interpolate_time_raises_for_non_timeseries(self):\n        # When method='time' is used on a non-TimeSeries that contains a null\n        # value, a ValueError should be raised.\n        non_ts = Series([0, 1, 2, np.NaN])\n        msg = \"time-weighted interpolation only works on Series.* with a DatetimeIndex\"\n        with pytest.raises(ValueError, match=msg):\n            non_ts.interpolate(method=\"time\")",
        "begin_line": 1152,
        "end_line": 1158,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_pchip#1161",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_pchip(self)",
        "snippet": "    def test_interpolate_pchip(self):\n        _skip_if_no_pchip()\n\n        ser = Series(np.sort(np.random.uniform(size=100)))\n\n        # interpolate at new_index\n        new_index = ser.index.union(\n            Index([49.25, 49.5, 49.75, 50.25, 50.5, 50.75])\n        ).astype(float)\n        interp_s = ser.reindex(new_index).interpolate(method=\"pchip\")\n        # does not blow up, GH5977\n        interp_s[49:51]",
        "begin_line": 1161,
        "end_line": 1172,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_akima#1175",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_akima(self)",
        "snippet": "    def test_interpolate_akima(self):\n        _skip_if_no_akima()\n\n        ser = Series([10, 11, 12, 13])\n\n        expected = Series(\n            [11.00, 11.25, 11.50, 11.75, 12.00, 12.25, 12.50, 12.75, 13.00],\n            index=Index([1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]),\n        )\n        # interpolate at new_index\n        new_index = ser.index.union(Index([1.25, 1.5, 1.75, 2.25, 2.5, 2.75])).astype(\n            float\n        )\n        interp_s = ser.reindex(new_index).interpolate(method=\"akima\")\n        assert_series_equal(interp_s[1:3], expected)",
        "begin_line": 1175,
        "end_line": 1189,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_piecewise_polynomial#1192",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_piecewise_polynomial(self)",
        "snippet": "    def test_interpolate_piecewise_polynomial(self):\n        ser = Series([10, 11, 12, 13])\n\n        expected = Series(\n            [11.00, 11.25, 11.50, 11.75, 12.00, 12.25, 12.50, 12.75, 13.00],\n            index=Index([1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]),\n        )\n        # interpolate at new_index\n        new_index = ser.index.union(Index([1.25, 1.5, 1.75, 2.25, 2.5, 2.75])).astype(\n            float\n        )\n        interp_s = ser.reindex(new_index).interpolate(method=\"piecewise_polynomial\")\n        assert_series_equal(interp_s[1:3], expected)",
        "begin_line": 1192,
        "end_line": 1204,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_from_derivatives#1207",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_from_derivatives(self)",
        "snippet": "    def test_interpolate_from_derivatives(self):\n        ser = Series([10, 11, 12, 13])\n\n        expected = Series(\n            [11.00, 11.25, 11.50, 11.75, 12.00, 12.25, 12.50, 12.75, 13.00],\n            index=Index([1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]),\n        )\n        # interpolate at new_index\n        new_index = ser.index.union(Index([1.25, 1.5, 1.75, 2.25, 2.5, 2.75])).astype(\n            float\n        )\n        interp_s = ser.reindex(new_index).interpolate(method=\"from_derivatives\")\n        assert_series_equal(interp_s[1:3], expected)",
        "begin_line": 1207,
        "end_line": 1219,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_corners#1230",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_corners(self, kwargs)",
        "snippet": "    def test_interpolate_corners(self, kwargs):\n        s = Series([np.nan, np.nan])\n        assert_series_equal(s.interpolate(**kwargs), s)\n\n        s = Series([]).interpolate()\n        assert_series_equal(s.interpolate(**kwargs), s)",
        "begin_line": 1230,
        "end_line": 1235,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_index_values#1237",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_index_values(self)",
        "snippet": "    def test_interpolate_index_values(self):\n        s = Series(np.nan, index=np.sort(np.random.rand(30)))\n        s[::3] = np.random.randn(10)\n\n        vals = s.index.values.astype(float)\n\n        result = s.interpolate(method=\"index\")\n\n        expected = s.copy()\n        bad = isna(expected.values)\n        good = ~bad\n        expected = Series(\n            np.interp(vals[bad], vals[good], s.values[good]), index=s.index[bad]\n        )\n\n        assert_series_equal(result[bad], expected)\n\n        # 'values' is synonymous with 'index' for the method kwarg\n        other_result = s.interpolate(method=\"values\")\n\n        assert_series_equal(other_result, result)\n        assert_series_equal(other_result[bad], expected)",
        "begin_line": 1237,
        "end_line": 1258,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_non_ts#1260",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_non_ts(self)",
        "snippet": "    def test_interpolate_non_ts(self):\n        s = Series([1, 3, np.nan, np.nan, np.nan, 11])\n        msg = (\n            \"time-weighted interpolation only works on Series or DataFrames\"\n            \" with a DatetimeIndex\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            s.interpolate(method=\"time\")",
        "begin_line": 1260,
        "end_line": 1267,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_nan_interpolate#1278",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_nan_interpolate(self, kwargs)",
        "snippet": "    def test_nan_interpolate(self, kwargs):\n        s = Series([0, 1, np.nan, 3])\n        result = s.interpolate(**kwargs)\n        expected = Series([0.0, 1.0, 2.0, 3.0])\n        assert_series_equal(result, expected)",
        "begin_line": 1278,
        "end_line": 1282,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_nan_irregular_index#1284",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_nan_irregular_index(self)",
        "snippet": "    def test_nan_irregular_index(self):\n        s = Series([1, 2, np.nan, 4], index=[1, 3, 5, 9])\n        result = s.interpolate()\n        expected = Series([1.0, 2.0, 3.0, 4.0], index=[1, 3, 5, 9])\n        assert_series_equal(result, expected)",
        "begin_line": 1284,
        "end_line": 1288,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_nan_str_index#1290",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_nan_str_index(self)",
        "snippet": "    def test_nan_str_index(self):\n        s = Series([0, 1, 2, np.nan], index=list(\"abcd\"))\n        result = s.interpolate()\n        expected = Series([0.0, 1.0, 2.0, 2.0], index=list(\"abcd\"))\n        assert_series_equal(result, expected)",
        "begin_line": 1290,
        "end_line": 1294,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_quad#1297",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_quad(self)",
        "snippet": "    def test_interp_quad(self):\n        sq = Series([1, 4, np.nan, 16], index=[1, 2, 3, 4])\n        result = sq.interpolate(method=\"quadratic\")\n        expected = Series([1.0, 4.0, 9.0, 16.0], index=[1, 2, 3, 4])\n        assert_series_equal(result, expected)",
        "begin_line": 1297,
        "end_line": 1301,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_scipy_basic#1304",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_scipy_basic(self)",
        "snippet": "    def test_interp_scipy_basic(self):\n        s = Series([1, 3, np.nan, 12, np.nan, 25])\n        # slinear\n        expected = Series([1.0, 3.0, 7.5, 12.0, 18.5, 25.0])\n        result = s.interpolate(method=\"slinear\")\n        assert_series_equal(result, expected)\n\n        result = s.interpolate(method=\"slinear\", downcast=\"infer\")\n        assert_series_equal(result, expected)\n        # nearest\n        expected = Series([1, 3, 3, 12, 12, 25])\n        result = s.interpolate(method=\"nearest\")\n        assert_series_equal(result, expected.astype(\"float\"))\n\n        result = s.interpolate(method=\"nearest\", downcast=\"infer\")\n        assert_series_equal(result, expected)\n        # zero\n        expected = Series([1, 3, 3, 12, 12, 25])\n        result = s.interpolate(method=\"zero\")\n        assert_series_equal(result, expected.astype(\"float\"))\n\n        result = s.interpolate(method=\"zero\", downcast=\"infer\")\n        assert_series_equal(result, expected)\n        # quadratic\n        # GH #15662.\n        expected = Series([1, 3.0, 6.823529, 12.0, 18.058824, 25.0])\n        result = s.interpolate(method=\"quadratic\")\n        assert_series_equal(result, expected)\n\n        result = s.interpolate(method=\"quadratic\", downcast=\"infer\")\n        assert_series_equal(result, expected)\n        # cubic\n        expected = Series([1.0, 3.0, 6.8, 12.0, 18.2, 25.0])\n        result = s.interpolate(method=\"cubic\")\n        assert_series_equal(result, expected)",
        "begin_line": 1304,
        "end_line": 1338,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_limit#1340",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_limit(self)",
        "snippet": "    def test_interp_limit(self):\n        s = Series([1, 3, np.nan, np.nan, np.nan, 11])\n\n        expected = Series([1.0, 3.0, 5.0, 7.0, np.nan, 11.0])\n        result = s.interpolate(method=\"linear\", limit=2)\n        assert_series_equal(result, expected)",
        "begin_line": 1340,
        "end_line": 1345,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_invalid_nonpositive_limit#1348",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_invalid_nonpositive_limit(self, nontemporal_method, limit)",
        "snippet": "    def test_interpolate_invalid_nonpositive_limit(self, nontemporal_method, limit):\n        # GH 9217: make sure limit is greater than zero.\n        s = pd.Series([1, 2, np.nan, 4])\n        method, kwargs = nontemporal_method\n        with pytest.raises(ValueError, match=\"Limit must be greater than 0\"):\n            s.interpolate(limit=limit, method=method, **kwargs)",
        "begin_line": 1348,
        "end_line": 1353,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_invalid_float_limit#1355",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_invalid_float_limit(self, nontemporal_method)",
        "snippet": "    def test_interpolate_invalid_float_limit(self, nontemporal_method):\n        # GH 9217: make sure limit is an integer.\n        s = pd.Series([1, 2, np.nan, 4])\n        method, kwargs = nontemporal_method\n        limit = 2.0\n        with pytest.raises(ValueError, match=\"Limit must be an integer\"):\n            s.interpolate(limit=limit, method=method, **kwargs)",
        "begin_line": 1355,
        "end_line": 1361,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_invalid_method#1364",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_invalid_method(self, invalid_method)",
        "snippet": "    def test_interp_invalid_method(self, invalid_method):\n        s = Series([1, 3, np.nan, 12, np.nan, 25])\n\n        msg = \"method must be one of.* Got '{}' instead\".format(invalid_method)\n        with pytest.raises(ValueError, match=msg):\n            s.interpolate(method=invalid_method)\n\n        # When an invalid method and invalid limit (such as -1) are\n        # provided, the error message reflects the invalid method.\n        with pytest.raises(ValueError, match=msg):\n            s.interpolate(method=invalid_method, limit=-1)",
        "begin_line": 1364,
        "end_line": 1374,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_limit_forward#1376",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_limit_forward(self)",
        "snippet": "    def test_interp_limit_forward(self):\n        s = Series([1, 3, np.nan, np.nan, np.nan, 11])\n\n        # Provide 'forward' (the default) explicitly here.\n        expected = Series([1.0, 3.0, 5.0, 7.0, np.nan, 11.0])\n\n        result = s.interpolate(method=\"linear\", limit=2, limit_direction=\"forward\")\n        assert_series_equal(result, expected)\n\n        result = s.interpolate(method=\"linear\", limit=2, limit_direction=\"FORWARD\")\n        assert_series_equal(result, expected)",
        "begin_line": 1376,
        "end_line": 1386,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_unlimited#1388",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_unlimited(self)",
        "snippet": "    def test_interp_unlimited(self):\n        # these test are for issue #16282 default Limit=None is unlimited\n        s = Series([np.nan, 1.0, 3.0, np.nan, np.nan, np.nan, 11.0, np.nan])\n        expected = Series([1.0, 1.0, 3.0, 5.0, 7.0, 9.0, 11.0, 11.0])\n        result = s.interpolate(method=\"linear\", limit_direction=\"both\")\n        assert_series_equal(result, expected)\n\n        expected = Series([np.nan, 1.0, 3.0, 5.0, 7.0, 9.0, 11.0, 11.0])\n        result = s.interpolate(method=\"linear\", limit_direction=\"forward\")\n        assert_series_equal(result, expected)\n\n        expected = Series([1.0, 1.0, 3.0, 5.0, 7.0, 9.0, 11.0, np.nan])\n        result = s.interpolate(method=\"linear\", limit_direction=\"backward\")\n        assert_series_equal(result, expected)",
        "begin_line": 1388,
        "end_line": 1401,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_limit_bad_direction#1403",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_limit_bad_direction(self)",
        "snippet": "    def test_interp_limit_bad_direction(self):\n        s = Series([1, 3, np.nan, np.nan, np.nan, 11])\n\n        msg = (\n            r\"Invalid limit_direction: expecting one of \\['forward',\"\n            r\" 'backward', 'both'\\], got 'abc'\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            s.interpolate(method=\"linear\", limit=2, limit_direction=\"abc\")\n\n        # raises an error even if no limit is specified.\n        with pytest.raises(ValueError, match=msg):\n            s.interpolate(method=\"linear\", limit_direction=\"abc\")",
        "begin_line": 1403,
        "end_line": 1415,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_limit_area#1418",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_limit_area(self)",
        "snippet": "    def test_interp_limit_area(self):\n        # These tests are for issue #9218 -- fill NaNs in both directions.\n        s = Series([nan, nan, 3, nan, nan, nan, 7, nan, nan])\n\n        expected = Series([nan, nan, 3.0, 4.0, 5.0, 6.0, 7.0, nan, nan])\n        result = s.interpolate(method=\"linear\", limit_area=\"inside\")\n        assert_series_equal(result, expected)\n\n        expected = Series([nan, nan, 3.0, 4.0, nan, nan, 7.0, nan, nan])\n        result = s.interpolate(method=\"linear\", limit_area=\"inside\", limit=1)\n\n        expected = Series([nan, nan, 3.0, 4.0, nan, 6.0, 7.0, nan, nan])\n        result = s.interpolate(\n            method=\"linear\", limit_area=\"inside\", limit_direction=\"both\", limit=1\n        )\n        assert_series_equal(result, expected)\n\n        expected = Series([nan, nan, 3.0, nan, nan, nan, 7.0, 7.0, 7.0])\n        result = s.interpolate(method=\"linear\", limit_area=\"outside\")\n        assert_series_equal(result, expected)\n\n        expected = Series([nan, nan, 3.0, nan, nan, nan, 7.0, 7.0, nan])\n        result = s.interpolate(method=\"linear\", limit_area=\"outside\", limit=1)\n\n        expected = Series([nan, 3.0, 3.0, nan, nan, nan, 7.0, 7.0, nan])\n        result = s.interpolate(\n            method=\"linear\", limit_area=\"outside\", limit_direction=\"both\", limit=1\n        )\n        assert_series_equal(result, expected)\n\n        expected = Series([3.0, 3.0, 3.0, nan, nan, nan, 7.0, nan, nan])\n        result = s.interpolate(\n            method=\"linear\", limit_area=\"outside\", direction=\"backward\"\n        )\n\n        # raises an error even if limit type is wrong.\n        msg = r\"Invalid limit_area: expecting one of \\['inside', 'outside'\\], got abc\"\n        with pytest.raises(ValueError, match=msg):\n            s.interpolate(method=\"linear\", limit_area=\"abc\")",
        "begin_line": 1418,
        "end_line": 1456,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_limit_direction#1458",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_limit_direction(self)",
        "snippet": "    def test_interp_limit_direction(self):\n        # These tests are for issue #9218 -- fill NaNs in both directions.\n        s = Series([1, 3, np.nan, np.nan, np.nan, 11])\n\n        expected = Series([1.0, 3.0, np.nan, 7.0, 9.0, 11.0])\n        result = s.interpolate(method=\"linear\", limit=2, limit_direction=\"backward\")\n        assert_series_equal(result, expected)\n\n        expected = Series([1.0, 3.0, 5.0, np.nan, 9.0, 11.0])\n        result = s.interpolate(method=\"linear\", limit=1, limit_direction=\"both\")\n        assert_series_equal(result, expected)\n\n        # Check that this works on a longer series of nans.\n        s = Series([1, 3, np.nan, np.nan, np.nan, 7, 9, np.nan, np.nan, 12, np.nan])\n\n        expected = Series([1.0, 3.0, 4.0, 5.0, 6.0, 7.0, 9.0, 10.0, 11.0, 12.0, 12.0])\n        result = s.interpolate(method=\"linear\", limit=2, limit_direction=\"both\")\n        assert_series_equal(result, expected)\n\n        expected = Series(\n            [1.0, 3.0, 4.0, np.nan, 6.0, 7.0, 9.0, 10.0, 11.0, 12.0, 12.0]\n        )\n        result = s.interpolate(method=\"linear\", limit=1, limit_direction=\"both\")\n        assert_series_equal(result, expected)",
        "begin_line": 1458,
        "end_line": 1481,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_limit_to_ends#1483",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_limit_to_ends(self)",
        "snippet": "    def test_interp_limit_to_ends(self):\n        # These test are for issue #10420 -- flow back to beginning.\n        s = Series([np.nan, np.nan, 5, 7, 9, np.nan])\n\n        expected = Series([5.0, 5.0, 5.0, 7.0, 9.0, np.nan])\n        result = s.interpolate(method=\"linear\", limit=2, limit_direction=\"backward\")\n        assert_series_equal(result, expected)\n\n        expected = Series([5.0, 5.0, 5.0, 7.0, 9.0, 9.0])\n        result = s.interpolate(method=\"linear\", limit=2, limit_direction=\"both\")\n        assert_series_equal(result, expected)",
        "begin_line": 1483,
        "end_line": 1493,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_limit_before_ends#1495",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_limit_before_ends(self)",
        "snippet": "    def test_interp_limit_before_ends(self):\n        # These test are for issue #11115 -- limit ends properly.\n        s = Series([np.nan, np.nan, 5, 7, np.nan, np.nan])\n\n        expected = Series([np.nan, np.nan, 5.0, 7.0, 7.0, np.nan])\n        result = s.interpolate(method=\"linear\", limit=1, limit_direction=\"forward\")\n        assert_series_equal(result, expected)\n\n        expected = Series([np.nan, 5.0, 5.0, 7.0, np.nan, np.nan])\n        result = s.interpolate(method=\"linear\", limit=1, limit_direction=\"backward\")\n        assert_series_equal(result, expected)\n\n        expected = Series([np.nan, 5.0, 5.0, 7.0, 7.0, np.nan])\n        result = s.interpolate(method=\"linear\", limit=1, limit_direction=\"both\")\n        assert_series_equal(result, expected)",
        "begin_line": 1495,
        "end_line": 1509,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_all_good#1512",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_all_good(self)",
        "snippet": "    def test_interp_all_good(self):\n        s = Series([1, 2, 3])\n        result = s.interpolate(method=\"polynomial\", order=1)\n        assert_series_equal(result, s)\n\n        # non-scipy\n        result = s.interpolate()\n        assert_series_equal(result, s)",
        "begin_line": 1512,
        "end_line": 1519,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_multiIndex#1524",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_multiIndex(self, check_scipy)",
        "snippet": "    def test_interp_multiIndex(self, check_scipy):\n        idx = MultiIndex.from_tuples([(0, \"a\"), (1, \"b\"), (2, \"c\")])\n        s = Series([1, 2, np.nan], index=idx)\n\n        expected = s.copy()\n        expected.loc[2] = 2\n        result = s.interpolate()\n        assert_series_equal(result, expected)\n\n        msg = \"Only `method=linear` interpolation is supported on MultiIndexes\"\n        if check_scipy:\n            with pytest.raises(ValueError, match=msg):\n                s.interpolate(method=\"polynomial\", order=1)",
        "begin_line": 1524,
        "end_line": 1536,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_nonmono_raise#1539",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_nonmono_raise(self)",
        "snippet": "    def test_interp_nonmono_raise(self):\n        s = Series([1, np.nan, 3], index=[0, 2, 1])\n        msg = \"krogh interpolation requires that the index be monotonic\"\n        with pytest.raises(ValueError, match=msg):\n            s.interpolate(method=\"krogh\")",
        "begin_line": 1539,
        "end_line": 1543,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_datetime64#1547",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_datetime64(self, method, tz_naive_fixture)",
        "snippet": "    def test_interp_datetime64(self, method, tz_naive_fixture):\n        df = Series(\n            [1, np.nan, 3], index=date_range(\"1/1/2000\", periods=3, tz=tz_naive_fixture)\n        )\n        result = df.interpolate(method=method)\n        expected = Series(\n            [1.0, 1.0, 3.0],\n            index=date_range(\"1/1/2000\", periods=3, tz=tz_naive_fixture),\n        )\n        assert_series_equal(result, expected)",
        "begin_line": 1547,
        "end_line": 1556,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_pad_datetime64tz_values#1558",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_pad_datetime64tz_values(self)",
        "snippet": "    def test_interp_pad_datetime64tz_values(self):\n        # GH#27628 missing.interpolate_2d should handle datetimetz values\n        dti = pd.date_range(\"2015-04-05\", periods=3, tz=\"US/Central\")\n        ser = pd.Series(dti)\n        ser[1] = pd.NaT\n        result = ser.interpolate(method=\"pad\")\n\n        expected = pd.Series(dti)\n        expected[1] = expected[0]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1558,
        "end_line": 1567,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_limit_no_nans#1569",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_limit_no_nans(self)",
        "snippet": "    def test_interp_limit_no_nans(self):\n        # GH 7173\n        s = pd.Series([1.0, 2.0, 3.0])\n        result = s.interpolate(limit=1)\n        expected = s\n        assert_series_equal(result, expected)",
        "begin_line": 1569,
        "end_line": 1574,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_no_order#1578",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_no_order(self, method)",
        "snippet": "    def test_no_order(self, method):\n        # see GH-10633, GH-24014\n        s = Series([0, 1, np.nan, 3])\n        msg = \"You must specify the order of the spline or polynomial\"\n        with pytest.raises(ValueError, match=msg):\n            s.interpolate(method=method)",
        "begin_line": 1578,
        "end_line": 1583,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_spline_invalid_order#1587",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_spline_invalid_order(self, order)",
        "snippet": "    def test_interpolate_spline_invalid_order(self, order):\n        s = Series([0, 1, np.nan, 3])\n        msg = \"order needs to be specified and greater than 0\"\n        with pytest.raises(ValueError, match=msg):\n            s.interpolate(method=\"spline\", order=order)",
        "begin_line": 1587,
        "end_line": 1591,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_spline#1594",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_spline(self)",
        "snippet": "    def test_spline(self):\n        s = Series([1, 2, np.nan, 4, 5, np.nan, 7])\n        result = s.interpolate(method=\"spline\", order=1)\n        expected = Series([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0])\n        assert_series_equal(result, expected)",
        "begin_line": 1594,
        "end_line": 1598,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_spline_extrapolate#1601",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_spline_extrapolate(self)",
        "snippet": "    def test_spline_extrapolate(self):\n        s = Series([1, 2, 3, 4, np.nan, 6, np.nan])\n        result3 = s.interpolate(method=\"spline\", order=1, ext=3)\n        expected3 = Series([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 6.0])\n        assert_series_equal(result3, expected3)\n\n        result1 = s.interpolate(method=\"spline\", order=1, ext=0)\n        expected1 = Series([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0])\n        assert_series_equal(result1, expected1)",
        "begin_line": 1601,
        "end_line": 1609,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_spline_smooth#1612",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_spline_smooth(self)",
        "snippet": "    def test_spline_smooth(self):\n        s = Series([1, 2, np.nan, 4, 5.1, np.nan, 7])\n        assert (\n            s.interpolate(method=\"spline\", order=3, s=0)[5]\n            != s.interpolate(method=\"spline\", order=3)[5]\n        )",
        "begin_line": 1612,
        "end_line": 1617,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_spline_interpolation#1620",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_spline_interpolation(self)",
        "snippet": "    def test_spline_interpolation(self):\n        s = Series(np.arange(10) ** 2)\n        s[np.random.randint(0, 9, 3)] = np.nan\n        result1 = s.interpolate(method=\"spline\", order=1)\n        expected1 = s.interpolate(method=\"spline\", order=1)\n        assert_series_equal(result1, expected1)",
        "begin_line": 1620,
        "end_line": 1625,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_timedelta64#1627",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_timedelta64(self)",
        "snippet": "    def test_interp_timedelta64(self):\n        # GH 6424\n        df = Series([1, np.nan, 3], index=pd.to_timedelta([1, 2, 3]))\n        result = df.interpolate(method=\"time\")\n        expected = Series([1.0, 2.0, 3.0], index=pd.to_timedelta([1, 2, 3]))\n        assert_series_equal(result, expected)\n\n        # test for non uniform spacing\n        df = Series([1, np.nan, 3], index=pd.to_timedelta([1, 2, 4]))\n        result = df.interpolate(method=\"time\")\n        expected = Series([1.0, 1.666667, 3.0], index=pd.to_timedelta([1, 2, 4]))\n        assert_series_equal(result, expected)",
        "begin_line": 1627,
        "end_line": 1638,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_series_interpolate_method_values#1640",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_series_interpolate_method_values(self)",
        "snippet": "    def test_series_interpolate_method_values(self):\n        # #1646\n        ts = _simple_ts(\"1/1/2000\", \"1/20/2000\")\n        ts[::2] = np.nan\n\n        result = ts.interpolate(method=\"values\")\n        exp = ts.interpolate()\n        assert_series_equal(result, exp)",
        "begin_line": 1640,
        "end_line": 1647,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_series_interpolate_intraday#1649",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_series_interpolate_intraday(self)",
        "snippet": "    def test_series_interpolate_intraday(self):\n        # #1698\n        index = pd.date_range(\"1/1/2012\", periods=4, freq=\"12D\")\n        ts = pd.Series([0, 12, 24, 36], index)\n        new_index = index.append(index + pd.DateOffset(days=1)).sort_values()\n\n        exp = ts.reindex(new_index).interpolate(method=\"time\")\n\n        index = pd.date_range(\"1/1/2012\", periods=4, freq=\"12H\")\n        ts = pd.Series([0, 12, 24, 36], index)\n        new_index = index.append(index + pd.DateOffset(hours=1)).sort_values()\n        result = ts.reindex(new_index).interpolate(method=\"time\")\n\n        tm.assert_numpy_array_equal(result.values, exp.values)",
        "begin_line": 1649,
        "end_line": 1662,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_nonzero_warning#1664",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_nonzero_warning(self)",
        "snippet": "    def test_nonzero_warning(self):\n        # GH 24048\n        ser = pd.Series([1, 0, 3, 4])\n        with tm.assert_produces_warning(FutureWarning):\n            ser.nonzero()",
        "begin_line": 1664,
        "end_line": 1668,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_non_timedelta_index#1678",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interp_non_timedelta_index(self, interp_methods_ind, ind)",
        "snippet": "    def test_interp_non_timedelta_index(self, interp_methods_ind, ind):\n        # gh 21662\n        df = pd.DataFrame([0, 1, np.nan, 3], index=ind)\n\n        method, kwargs = interp_methods_ind\n        if method == \"pchip\":\n            _skip_if_no_pchip()\n\n        if method == \"linear\":\n            result = df[0].interpolate(**kwargs)\n            expected = pd.Series([0.0, 1.0, 2.0, 3.0], name=0, index=ind)\n            assert_series_equal(result, expected)\n        else:\n            expected_error = (\n                \"Index column must be numeric or datetime type when \"\n                \"using {method} method other than linear. \"\n                \"Try setting a numeric or datetime index column before \"\n                \"interpolating.\".format(method=method)\n            )\n            with pytest.raises(ValueError, match=expected_error):\n                df[0].interpolate(method=method, **kwargs)",
        "begin_line": 1678,
        "end_line": 1698,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_timedelta_index#1700",
        "src_path": "pandas/tests/series/test_missing.py",
        "class_name": "pandas.tests.series.test_missing.TestSeriesInterpolateData",
        "signature": "pandas.tests.series.test_missing.TestSeriesInterpolateData.test_interpolate_timedelta_index(self, interp_methods_ind)",
        "snippet": "    def test_interpolate_timedelta_index(self, interp_methods_ind):\n        \"\"\"\n        Tests for non numerical index types  - object, period, timedelta\n        Note that all methods except time, index, nearest and values\n        are tested here.\n        \"\"\"\n        # gh 21662\n        ind = pd.timedelta_range(start=1, periods=4)\n        df = pd.DataFrame([0, 1, np.nan, 3], index=ind)\n\n        method, kwargs = interp_methods_ind\n        if method == \"pchip\":\n            _skip_if_no_pchip()\n\n        if method in {\"linear\", \"pchip\"}:\n            result = df[0].interpolate(method=method, **kwargs)\n            expected = pd.Series([0.0, 1.0, 2.0, 3.0], name=0, index=ind)\n            assert_series_equal(result, expected)\n        else:\n            pytest.skip(\n                \"This interpolation method is not supported for Timedelta Index yet.\"\n            )",
        "begin_line": 1700,
        "end_line": 1721,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.conftest.datetime_series#7",
        "src_path": "pandas/tests/series/conftest.py",
        "class_name": "pandas.tests.series.conftest",
        "signature": "pandas.tests.series.conftest.datetime_series()",
        "snippet": "def datetime_series():\n    \"\"\"\n    Fixture for Series of floats with DatetimeIndex\n    \"\"\"\n    s = tm.makeTimeSeries()\n    s.name = \"ts\"\n    return s",
        "begin_line": 7,
        "end_line": 13,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.conftest.string_series#17",
        "src_path": "pandas/tests/series/conftest.py",
        "class_name": "pandas.tests.series.conftest",
        "signature": "pandas.tests.series.conftest.string_series()",
        "snippet": "def string_series():\n    \"\"\"\n    Fixture for Series of floats with Index of unique strings\n    \"\"\"\n    s = tm.makeStringSeries()\n    s.name = \"series\"\n    return s",
        "begin_line": 17,
        "end_line": 23,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.conftest.object_series#27",
        "src_path": "pandas/tests/series/conftest.py",
        "class_name": "pandas.tests.series.conftest",
        "signature": "pandas.tests.series.conftest.object_series()",
        "snippet": "def object_series():\n    \"\"\"\n    Fixture for Series of dtype datetime64[ns] with Index of unique strings\n    \"\"\"\n    s = tm.makeObjectSeries()\n    s.name = \"objects\"\n    return s",
        "begin_line": 27,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    }
]