[
    {
        "name": "pandas.tests.indexes.conftest.indices#28",
        "src_path": "pandas/tests/indexes/conftest.py",
        "class_name": "pandas.tests.indexes.conftest",
        "signature": "pandas.tests.indexes.conftest.indices(request)",
        "snippet": "def indices(request):\n    return request.param",
        "begin_line": 28,
        "end_line": 29,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.conftest.one#33",
        "src_path": "pandas/tests/indexes/conftest.py",
        "class_name": "pandas.tests.indexes.conftest",
        "signature": "pandas.tests.indexes.conftest.one(request)",
        "snippet": "def one(request):\n    # zero-dim integer array behaves like an integer\n    return request.param",
        "begin_line": 33,
        "end_line": 35,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem#40",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem(self, float_frame)",
        "snippet": "    def test_getitem(self, float_frame):\n        # Slicing\n        sl = float_frame[:20]\n        assert len(sl.index) == 20\n\n        # Column access\n        for _, series in sl.items():\n            assert len(series.index) == 20\n            assert tm.equalContents(series.index, sl.index)\n\n        for key, _ in float_frame._series.items():\n            assert float_frame[key] is not None\n\n        assert \"random\" not in float_frame\n        with pytest.raises(KeyError, match=\"random\"):\n            float_frame[\"random\"]\n\n        df = float_frame.copy()\n        df[\"$10\"] = np.random.randn(len(df))\n\n        ad = np.random.randn(len(df))\n        df[\"@awesome_domain\"] = ad\n\n        with pytest.raises(KeyError, match=re.escape(\"'df[\\\"$10\\\"]'\")):\n            df.__getitem__('df[\"$10\"]')\n\n        res = df[\"@awesome_domain\"]\n        tm.assert_numpy_array_equal(ad, res.values)",
        "begin_line": 40,
        "end_line": 67,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_dupe_cols#69",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_dupe_cols(self)",
        "snippet": "    def test_getitem_dupe_cols(self):\n        df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=[\"a\", \"a\", \"b\"])\n        msg = \"\\\"None of [Index(['baf'], dtype='object')] are in the [columns]\\\"\"\n        with pytest.raises(KeyError, match=re.escape(msg)):\n            df[[\"baf\"]]",
        "begin_line": 69,
        "end_line": 73,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_get#75",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_get(self, float_frame)",
        "snippet": "    def test_get(self, float_frame):\n        b = float_frame.get(\"B\")\n        assert_series_equal(b, float_frame[\"B\"])\n\n        assert float_frame.get(\"foo\") is None\n        assert_series_equal(float_frame.get(\"foo\", float_frame[\"B\"]), float_frame[\"B\"])",
        "begin_line": 75,
        "end_line": 80,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_get_none#90",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_get_none(self, df)",
        "snippet": "    def test_get_none(self, df):\n        # see gh-5652\n        assert df.get(None) is None",
        "begin_line": 90,
        "end_line": 92,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_loc_iterable#95",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_loc_iterable(self, float_frame, key_type)",
        "snippet": "    def test_loc_iterable(self, float_frame, key_type):\n        idx = key_type([\"A\", \"B\", \"C\"])\n        result = float_frame.loc[:, idx]\n        expected = float_frame.loc[:, [\"A\", \"B\", \"C\"]]\n        assert_frame_equal(result, expected)",
        "begin_line": 95,
        "end_line": 99,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_listlike#114",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_listlike(self, idx_type, levels, float_frame)",
        "snippet": "    def test_getitem_listlike(self, idx_type, levels, float_frame):\n        # GH 21294\n\n        if levels == 1:\n            frame, missing = float_frame, \"food\"\n        else:\n            # MultiIndex columns\n            frame = DataFrame(\n                np.random.randn(8, 3),\n                columns=Index(\n                    [(\"foo\", \"bar\"), (\"baz\", \"qux\"), (\"peek\", \"aboo\")],\n                    name=(\"sth\", \"sth2\"),\n                ),\n            )\n            missing = (\"good\", \"food\")\n\n        keys = [frame.columns[1], frame.columns[0]]\n        idx = idx_type(keys)\n        idx_check = list(idx_type(keys))\n\n        result = frame[idx]\n\n        expected = frame.loc[:, idx_check]\n        expected.columns.names = frame.columns.names\n\n        assert_frame_equal(result, expected)\n\n        idx = idx_type(keys + [missing])\n        with pytest.raises(KeyError, match=\"not in index\"):\n            frame[idx]",
        "begin_line": 114,
        "end_line": 143,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_loc_uint64#148",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_loc_uint64(self, val, expected)",
        "snippet": "    def test_loc_uint64(self, val, expected):\n        # see gh-19399\n        df = DataFrame([1, 2], index=[2 ** 63 - 1, 2 ** 63])\n        result = df.loc[val]\n\n        expected.name = val\n        tm.assert_series_equal(result, expected)",
        "begin_line": 148,
        "end_line": 154,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_callable#156",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_callable(self, float_frame)",
        "snippet": "    def test_getitem_callable(self, float_frame):\n        # GH 12533\n        result = float_frame[lambda x: \"A\"]\n        tm.assert_series_equal(result, float_frame.loc[:, \"A\"])\n\n        result = float_frame[lambda x: [\"A\", \"B\"]]\n        tm.assert_frame_equal(result, float_frame.loc[:, [\"A\", \"B\"]])\n\n        df = float_frame[:3]\n        result = df[lambda x: [True, False, True]]\n        tm.assert_frame_equal(result, float_frame.iloc[[0, 2], :])",
        "begin_line": 156,
        "end_line": 166,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_list#168",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_list(self, float_frame)",
        "snippet": "    def test_setitem_list(self, float_frame):\n\n        float_frame[\"E\"] = \"foo\"\n        data = float_frame[[\"A\", \"B\"]]\n        float_frame[[\"B\", \"A\"]] = data\n\n        assert_series_equal(float_frame[\"B\"], data[\"A\"], check_names=False)\n        assert_series_equal(float_frame[\"A\"], data[\"B\"], check_names=False)\n\n        msg = \"Columns must be same length as key\"\n        with pytest.raises(ValueError, match=msg):\n            data[[\"A\"]] = float_frame[[\"A\", \"B\"]]\n\n        msg = \"Length of values does not match length of index\"\n        with pytest.raises(ValueError, match=msg):\n            data[\"A\"] = range(len(data.index) - 1)\n\n        df = DataFrame(0, index=range(3), columns=[\"tt1\", \"tt2\"], dtype=np.int_)\n        df.loc[1, [\"tt1\", \"tt2\"]] = [1, 2]\n\n        result = df.loc[df.index[1], [\"tt1\", \"tt2\"]]\n        expected = Series([1, 2], df.columns, dtype=np.int_, name=1)\n        assert_series_equal(result, expected)\n\n        df[\"tt1\"] = df[\"tt2\"] = \"0\"\n        df.loc[df.index[1], [\"tt1\", \"tt2\"]] = [\"1\", \"2\"]\n        result = df.loc[df.index[1], [\"tt1\", \"tt2\"]]\n        expected = Series([\"1\", \"2\"], df.columns, name=1)\n        assert_series_equal(result, expected)",
        "begin_line": 168,
        "end_line": 196,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_list_not_dataframe#198",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_list_not_dataframe(self, float_frame)",
        "snippet": "    def test_setitem_list_not_dataframe(self, float_frame):\n        data = np.random.randn(len(float_frame), 2)\n        float_frame[[\"A\", \"B\"]] = data\n        assert_almost_equal(float_frame[[\"A\", \"B\"]].values, data)",
        "begin_line": 198,
        "end_line": 201,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_list_of_tuples#203",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_list_of_tuples(self, float_frame)",
        "snippet": "    def test_setitem_list_of_tuples(self, float_frame):\n        tuples = list(zip(float_frame[\"A\"], float_frame[\"B\"]))\n        float_frame[\"tuples\"] = tuples\n\n        result = float_frame[\"tuples\"]\n        expected = Series(tuples, index=float_frame.index, name=\"tuples\")\n        assert_series_equal(result, expected)",
        "begin_line": 203,
        "end_line": 209,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_mulit_index#211",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_mulit_index(self)",
        "snippet": "    def test_setitem_mulit_index(self):\n        # GH7655, test that assigning to a sub-frame of a frame\n        # with multi-index columns aligns both rows and columns\n        it = [\"jim\", \"joe\", \"jolie\"], [\"first\", \"last\"], [\"left\", \"center\", \"right\"]\n\n        cols = MultiIndex.from_product(it)\n        index = pd.date_range(\"20141006\", periods=20)\n        vals = np.random.randint(1, 1000, (len(index), len(cols)))\n        df = pd.DataFrame(vals, columns=cols, index=index)\n\n        i, j = df.index.values.copy(), it[-1][:]\n\n        np.random.shuffle(i)\n        df[\"jim\"] = df[\"jolie\"].loc[i, ::-1]\n        assert_frame_equal(df[\"jim\"], df[\"jolie\"])\n\n        np.random.shuffle(j)\n        df[(\"joe\", \"first\")] = df[(\"jolie\", \"last\")].loc[i, j]\n        assert_frame_equal(df[(\"joe\", \"first\")], df[(\"jolie\", \"last\")])\n\n        np.random.shuffle(j)\n        df[(\"joe\", \"last\")] = df[(\"jolie\", \"first\")].loc[i, j]\n        assert_frame_equal(df[(\"joe\", \"last\")], df[(\"jolie\", \"first\")])",
        "begin_line": 211,
        "end_line": 233,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_callable#235",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_callable(self)",
        "snippet": "    def test_setitem_callable(self):\n        # GH 12533\n        df = pd.DataFrame({\"A\": [1, 2, 3, 4], \"B\": [5, 6, 7, 8]})\n        df[lambda x: \"A\"] = [11, 12, 13, 14]\n\n        exp = pd.DataFrame({\"A\": [11, 12, 13, 14], \"B\": [5, 6, 7, 8]})\n        tm.assert_frame_equal(df, exp)",
        "begin_line": 235,
        "end_line": 241,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_other_callable#243",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_other_callable(self)",
        "snippet": "    def test_setitem_other_callable(self):\n        # GH 13299\n        def inc(x):\n            return x + 1\n\n        df = pd.DataFrame([[-1, 1], [1, -1]])\n        df[df > 0] = inc\n\n        expected = pd.DataFrame([[-1, inc], [inc, -1]])\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 243,
        "end_line": 252,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.inc#245",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.inc(x)",
        "snippet": "        def inc(x):\n            return x + 1",
        "begin_line": 245,
        "end_line": 246,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_boolean#254",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_boolean(self, float_string_frame, mixed_float_frame, mixed_int_frame, datetime_frame)",
        "snippet": "    def test_getitem_boolean(\n        self, float_string_frame, mixed_float_frame, mixed_int_frame, datetime_frame\n    ):\n        # boolean indexing\n        d = datetime_frame.index[10]\n        indexer = datetime_frame.index > d\n        indexer_obj = indexer.astype(object)\n\n        subindex = datetime_frame.index[indexer]\n        subframe = datetime_frame[indexer]\n\n        tm.assert_index_equal(subindex, subframe.index)\n        with pytest.raises(ValueError, match=\"Item wrong length\"):\n            datetime_frame[indexer[:-1]]\n\n        subframe_obj = datetime_frame[indexer_obj]\n        assert_frame_equal(subframe_obj, subframe)\n\n        with pytest.raises(ValueError, match=\"Boolean array expected\"):\n            datetime_frame[datetime_frame]\n\n        # test that Series work\n        indexer_obj = Series(indexer_obj, datetime_frame.index)\n\n        subframe_obj = datetime_frame[indexer_obj]\n        assert_frame_equal(subframe_obj, subframe)\n\n        # test that Series indexers reindex\n        # we are producing a warning that since the passed boolean\n        # key is not the same as the given index, we will reindex\n        # not sure this is really necessary\n        with tm.assert_produces_warning(UserWarning, check_stacklevel=False):\n            indexer_obj = indexer_obj.reindex(datetime_frame.index[::-1])\n            subframe_obj = datetime_frame[indexer_obj]\n            assert_frame_equal(subframe_obj, subframe)\n\n        # test df[df > 0]\n        for df in [\n            datetime_frame,\n            float_string_frame,\n            mixed_float_frame,\n            mixed_int_frame,\n        ]:\n            if df is float_string_frame:\n                continue\n\n            data = df._get_numeric_data()\n            bif = df[df > 0]\n            bifw = DataFrame(\n                {c: np.where(data[c] > 0, data[c], np.nan) for c in data.columns},\n                index=data.index,\n                columns=data.columns,\n            )\n\n            # add back other columns to compare\n            for c in df.columns:\n                if c not in bifw:\n                    bifw[c] = df[c]\n            bifw = bifw.reindex(columns=df.columns)\n\n            assert_frame_equal(bif, bifw, check_dtype=False)\n            for c in df.columns:\n                if bif[c].dtype != bifw[c].dtype:\n                    assert bif[c].dtype == df[c].dtype",
        "begin_line": 254,
        "end_line": 317,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_boolean_casting#319",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_boolean_casting(self, datetime_frame)",
        "snippet": "    def test_getitem_boolean_casting(self, datetime_frame):\n\n        # don't upcast if we don't need to\n        df = datetime_frame.copy()\n        df[\"E\"] = 1\n        df[\"E\"] = df[\"E\"].astype(\"int32\")\n        df[\"E1\"] = df[\"E\"].copy()\n        df[\"F\"] = 1\n        df[\"F\"] = df[\"F\"].astype(\"int64\")\n        df[\"F1\"] = df[\"F\"].copy()\n\n        casted = df[df > 0]\n        result = casted.dtypes\n        expected = Series(\n            [np.dtype(\"float64\")] * 4\n            + [np.dtype(\"int32\")] * 2\n            + [np.dtype(\"int64\")] * 2,\n            index=[\"A\", \"B\", \"C\", \"D\", \"E\", \"E1\", \"F\", \"F1\"],\n        )\n        assert_series_equal(result, expected)\n\n        # int block splitting\n        df.loc[df.index[1:3], [\"E1\", \"F1\"]] = 0\n        casted = df[df > 0]\n        result = casted.dtypes\n        expected = Series(\n            [np.dtype(\"float64\")] * 4\n            + [np.dtype(\"int32\")]\n            + [np.dtype(\"float64\")]\n            + [np.dtype(\"int64\")]\n            + [np.dtype(\"float64\")],\n            index=[\"A\", \"B\", \"C\", \"D\", \"E\", \"E1\", \"F\", \"F1\"],\n        )\n        assert_series_equal(result, expected)\n\n        # where dtype conversions\n        # GH 3733\n        df = DataFrame(data=np.random.randn(100, 50))\n        df = df.where(df > 0)  # create nans\n        bools = df > 0\n        mask = isna(df)\n        expected = bools.astype(float).mask(mask)\n        result = bools.mask(mask)\n        assert_frame_equal(result, expected)",
        "begin_line": 319,
        "end_line": 362,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_boolean_list#364",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_boolean_list(self)",
        "snippet": "    def test_getitem_boolean_list(self):\n        df = DataFrame(np.arange(12).reshape(3, 4))\n\n        def _checkit(lst):\n            result = df[lst]\n            expected = df.loc[df.index[lst]]\n            assert_frame_equal(result, expected)\n\n        _checkit([True, False, True])\n        _checkit([True, True, True])\n        _checkit([False, False, False])",
        "begin_line": 364,
        "end_line": 374,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing._checkit#367",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing._checkit(lst)",
        "snippet": "        def _checkit(lst):\n            result = df[lst]\n            expected = df.loc[df.index[lst]]\n            assert_frame_equal(result, expected)",
        "begin_line": 367,
        "end_line": 370,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_boolean_iadd#376",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_boolean_iadd(self)",
        "snippet": "    def test_getitem_boolean_iadd(self):\n        arr = np.random.randn(5, 5)\n\n        df = DataFrame(arr.copy(), columns=[\"A\", \"B\", \"C\", \"D\", \"E\"])\n\n        df[df < 0] += 1\n        arr[arr < 0] += 1\n\n        assert_almost_equal(df.values, arr)",
        "begin_line": 376,
        "end_line": 384,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_boolean_index_empty_corner#386",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_boolean_index_empty_corner(self)",
        "snippet": "    def test_boolean_index_empty_corner(self):\n        # #2096\n        blah = DataFrame(np.empty([0, 1]), columns=[\"A\"], index=DatetimeIndex([]))\n\n        # both of these should succeed trivially\n        k = np.array([], bool)\n\n        blah[k]\n        blah[k] = 0",
        "begin_line": 386,
        "end_line": 394,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_ix_mixed_integer#396",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_ix_mixed_integer(self)",
        "snippet": "    def test_getitem_ix_mixed_integer(self):\n        df = DataFrame(\n            np.random.randn(4, 3), index=[1, 10, \"C\", \"E\"], columns=[1, 2, 3]\n        )\n\n        result = df.iloc[:-1]\n        expected = df.loc[df.index[:-1]]\n        assert_frame_equal(result, expected)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            result = df.ix[[1, 10]]\n            expected = df.ix[Index([1, 10], dtype=object)]\n        assert_frame_equal(result, expected)\n\n        # 11320\n        df = pd.DataFrame(\n            {\n                \"rna\": (1.5, 2.2, 3.2, 4.5),\n                -1000: [11, 21, 36, 40],\n                0: [10, 22, 43, 34],\n                1000: [0, 10, 20, 30],\n            },\n            columns=[\"rna\", -1000, 0, 1000],\n        )\n        result = df[[1000]]\n        expected = df.iloc[:, [3]]\n        assert_frame_equal(result, expected)\n        result = df[[-1000]]\n        expected = df.iloc[:, [1]]\n        assert_frame_equal(result, expected)",
        "begin_line": 396,
        "end_line": 426,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_setitem_ix_negative_integers#428",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_setitem_ix_negative_integers(self, float_frame)",
        "snippet": "    def test_getitem_setitem_ix_negative_integers(self, float_frame):\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            result = float_frame.ix[:, -1]\n        assert_series_equal(result, float_frame[\"D\"])\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            result = float_frame.ix[:, [-1]]\n        assert_frame_equal(result, float_frame[[\"D\"]])\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            result = float_frame.ix[:, [-1, -2]]\n        assert_frame_equal(result, float_frame[[\"D\", \"C\"]])\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            float_frame.ix[:, [-1]] = 0\n        assert (float_frame[\"D\"] == 0).all()\n\n        df = DataFrame(np.random.randn(8, 4))\n        # ix does label-based indexing when having an integer index\n        msg = \"\\\"None of [Int64Index([-1], dtype='int64')] are in the [index]\\\"\"\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            with pytest.raises(KeyError, match=re.escape(msg)):\n                df.ix[[-1]]\n\n        msg = \"\\\"None of [Int64Index([-1], dtype='int64')] are in the [columns]\\\"\"\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            with pytest.raises(KeyError, match=re.escape(msg)):\n                df.ix[:, [-1]]\n\n        # #1942\n        a = DataFrame(np.random.randn(20, 2), index=[chr(x + 65) for x in range(20)])\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            a.ix[-1] = a.ix[-2]\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            assert_series_equal(a.ix[-1], a.ix[-2], check_names=False)\n            assert a.ix[-1].name == \"T\"\n            assert a.ix[-2].name == \"S\"",
        "begin_line": 428,
        "end_line": 473,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getattr#475",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getattr(self, float_frame)",
        "snippet": "    def test_getattr(self, float_frame):\n        assert_series_equal(float_frame.A, float_frame[\"A\"])\n        msg = \"'DataFrame' object has no attribute 'NONEXISTENT_NAME'\"\n        with pytest.raises(AttributeError, match=msg):\n            float_frame.NONEXISTENT_NAME",
        "begin_line": 475,
        "end_line": 479,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setattr_column#481",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setattr_column(self)",
        "snippet": "    def test_setattr_column(self):\n        df = DataFrame({\"foobar\": 1}, index=range(10))\n\n        df.foobar = 5\n        assert (df.foobar == 5).all()",
        "begin_line": 481,
        "end_line": 485,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem#487",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem(self, float_frame)",
        "snippet": "    def test_setitem(self, float_frame):\n        # not sure what else to do here\n        series = float_frame[\"A\"][::2]\n        float_frame[\"col5\"] = series\n        assert \"col5\" in float_frame\n\n        assert len(series) == 15\n        assert len(float_frame) == 30\n\n        exp = np.ravel(np.column_stack((series.values, [np.nan] * 15)))\n        exp = Series(exp, index=float_frame.index, name=\"col5\")\n        tm.assert_series_equal(float_frame[\"col5\"], exp)\n\n        series = float_frame[\"A\"]\n        float_frame[\"col6\"] = series\n        tm.assert_series_equal(series, float_frame[\"col6\"], check_names=False)\n\n        msg = (\n            r\"\\\"None of \\[Float64Index\\(\\[.*dtype='float64'\\)\\] are in the\"\n            r\" \\[columns\\]\\\"\"\n        )\n        with pytest.raises(KeyError, match=msg):\n            float_frame[np.random.randn(len(float_frame) + 1)] = 1\n\n        # set ndarray\n        arr = np.random.randn(len(float_frame))\n        float_frame[\"col9\"] = arr\n        assert (float_frame[\"col9\"] == arr).all()\n\n        float_frame[\"col7\"] = 5\n        assert (float_frame[\"col7\"] == 5).all()\n\n        float_frame[\"col0\"] = 3.14\n        assert (float_frame[\"col0\"] == 3.14).all()\n\n        float_frame[\"col8\"] = \"foo\"\n        assert (float_frame[\"col8\"] == \"foo\").all()\n\n        # this is partially a view (e.g. some blocks are view)\n        # so raise/warn\n        smaller = float_frame[:2]\n\n        with pytest.raises(com.SettingWithCopyError):\n            smaller[\"col10\"] = [\"1\", \"2\"]\n\n        assert smaller[\"col10\"].dtype == np.object_\n        assert (smaller[\"col10\"] == [\"1\", \"2\"]).all()\n\n        # dtype changing GH4204\n        df = DataFrame([[0, 0]])\n        df.iloc[0] = np.nan\n        expected = DataFrame([[np.nan, np.nan]])\n        assert_frame_equal(df, expected)\n\n        df = DataFrame([[0, 0]])\n        df.loc[0] = np.nan\n        assert_frame_equal(df, expected)",
        "begin_line": 487,
        "end_line": 543,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_dtype#546",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_dtype(self, dtype, float_frame)",
        "snippet": "    def test_setitem_dtype(self, dtype, float_frame):\n        arr = np.random.randn(len(float_frame))\n\n        float_frame[dtype] = np.array(arr, dtype=dtype)\n        assert float_frame[dtype].dtype.name == dtype",
        "begin_line": 546,
        "end_line": 550,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_tuple#552",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_tuple(self, float_frame)",
        "snippet": "    def test_setitem_tuple(self, float_frame):\n        float_frame[\"A\", \"B\"] = float_frame[\"A\"]\n        assert_series_equal(float_frame[\"A\", \"B\"], float_frame[\"A\"], check_names=False)",
        "begin_line": 552,
        "end_line": 554,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_always_copy#556",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_always_copy(self, float_frame)",
        "snippet": "    def test_setitem_always_copy(self, float_frame):\n        s = float_frame[\"A\"].copy()\n        float_frame[\"E\"] = s\n\n        float_frame[\"E\"][5:10] = np.nan\n        assert notna(s[5:10]).all()",
        "begin_line": 556,
        "end_line": 561,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_boolean#563",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_boolean(self, float_frame)",
        "snippet": "    def test_setitem_boolean(self, float_frame):\n        df = float_frame.copy()\n        values = float_frame.values\n\n        df[df[\"A\"] > 0] = 4\n        values[values[:, 0] > 0] = 4\n        assert_almost_equal(df.values, values)\n\n        # test that column reindexing works\n        series = df[\"A\"] == 4\n        series = series.reindex(df.index[::-1])\n        df[series] = 1\n        values[values[:, 0] == 4] = 1\n        assert_almost_equal(df.values, values)\n\n        df[df > 0] = 5\n        values[values > 0] = 5\n        assert_almost_equal(df.values, values)\n\n        df[df == 5] = 0\n        values[values == 5] = 0\n        assert_almost_equal(df.values, values)\n\n        # a df that needs alignment first\n        df[df[:-1] < 0] = 2\n        np.putmask(values[:-1], values[:-1] < 0, 2)\n        assert_almost_equal(df.values, values)\n\n        # indexed with same shape but rows-reversed df\n        df[df[::-1] == 2] = 3\n        values[values == 2] = 3\n        assert_almost_equal(df.values, values)\n\n        msg = \"Must pass DataFrame or 2-d ndarray with boolean values only\"\n        with pytest.raises(TypeError, match=msg):\n            df[df * 0] = 2\n\n        # index with DataFrame\n        mask = df > np.abs(df)\n        expected = df.copy()\n        df[df > np.abs(df)] = np.nan\n        expected.values[mask.values] = np.nan\n        assert_frame_equal(df, expected)\n\n        # set from DataFrame\n        expected = df.copy()\n        df[df > np.abs(df)] = df * 2\n        np.putmask(expected.values, mask.values, df.values * 2)\n        assert_frame_equal(df, expected)",
        "begin_line": 563,
        "end_line": 611,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_boolean_mask#618",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_boolean_mask(self, mask_type, float_frame)",
        "snippet": "    def test_setitem_boolean_mask(self, mask_type, float_frame):\n\n        # Test for issue #18582\n        df = float_frame.copy()\n        mask = mask_type(df)\n\n        # index with boolean mask\n        result = df.copy()\n        result[mask] = np.nan\n\n        expected = df.copy()\n        expected.values[np.array(mask)] = np.nan\n        assert_frame_equal(result, expected)",
        "begin_line": 618,
        "end_line": 630,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_cast#632",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_cast(self, float_frame)",
        "snippet": "    def test_setitem_cast(self, float_frame):\n        float_frame[\"D\"] = float_frame[\"D\"].astype(\"i8\")\n        assert float_frame[\"D\"].dtype == np.int64\n\n        # #669, should not cast?\n        # this is now set to int64, which means a replacement of the column to\n        # the value dtype (and nothing to do with the existing dtype)\n        float_frame[\"B\"] = 0\n        assert float_frame[\"B\"].dtype == np.int64\n\n        # cast if pass array of course\n        float_frame[\"B\"] = np.arange(len(float_frame))\n        assert issubclass(float_frame[\"B\"].dtype.type, np.integer)\n\n        float_frame[\"foo\"] = \"bar\"\n        float_frame[\"foo\"] = 0\n        assert float_frame[\"foo\"].dtype == np.int64\n\n        float_frame[\"foo\"] = \"bar\"\n        float_frame[\"foo\"] = 2.5\n        assert float_frame[\"foo\"].dtype == np.float64\n\n        float_frame[\"something\"] = 0\n        assert float_frame[\"something\"].dtype == np.int64\n        float_frame[\"something\"] = 2\n        assert float_frame[\"something\"].dtype == np.int64\n        float_frame[\"something\"] = 2.5\n        assert float_frame[\"something\"].dtype == np.float64\n\n        # GH 7704\n        # dtype conversion on setting\n        df = DataFrame(np.random.rand(30, 3), columns=tuple(\"ABC\"))\n        df[\"event\"] = np.nan\n        df.loc[10, \"event\"] = \"foo\"\n        result = df.dtypes\n        expected = Series(\n            [np.dtype(\"float64\")] * 3 + [np.dtype(\"object\")],\n            index=[\"A\", \"B\", \"C\", \"event\"],\n        )\n        assert_series_equal(result, expected)\n\n        # Test that data type is preserved . #5782\n        df = DataFrame({\"one\": np.arange(6, dtype=np.int8)})\n        df.loc[1, \"one\"] = 6\n        assert df.dtypes.one == np.dtype(np.int8)\n        df.one = np.int8(7)\n        assert df.dtypes.one == np.dtype(np.int8)",
        "begin_line": 632,
        "end_line": 678,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_boolean_column#680",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_boolean_column(self, float_frame)",
        "snippet": "    def test_setitem_boolean_column(self, float_frame):\n        expected = float_frame.copy()\n        mask = float_frame[\"A\"] > 0\n\n        float_frame.loc[mask, \"B\"] = 0\n        expected.values[mask.values, 1] = 0\n\n        assert_frame_equal(float_frame, expected)",
        "begin_line": 680,
        "end_line": 687,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_frame_setitem_timestamp#689",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_frame_setitem_timestamp(self)",
        "snippet": "    def test_frame_setitem_timestamp(self):\n        # GH#2155\n        columns = date_range(start=\"1/1/2012\", end=\"2/1/2012\", freq=BDay())\n        data = DataFrame(columns=columns, index=range(10))\n        t = datetime(2012, 11, 1)\n        ts = Timestamp(t)\n        data[ts] = np.nan  # works, mostly a smoke-test\n        assert np.isnan(data[ts]).all()",
        "begin_line": 689,
        "end_line": 696,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_corner#698",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_corner(self, float_frame)",
        "snippet": "    def test_setitem_corner(self, float_frame):\n        # corner case\n        df = DataFrame({\"B\": [1.0, 2.0, 3.0], \"C\": [\"a\", \"b\", \"c\"]}, index=np.arange(3))\n        del df[\"B\"]\n        df[\"B\"] = [1.0, 2.0, 3.0]\n        assert \"B\" in df\n        assert len(df.columns) == 2\n\n        df[\"A\"] = \"beginning\"\n        df[\"E\"] = \"foo\"\n        df[\"D\"] = \"bar\"\n        df[datetime.now()] = \"date\"\n        df[datetime.now()] = 5.0\n\n        # what to do when empty frame with index\n        dm = DataFrame(index=float_frame.index)\n        dm[\"A\"] = \"foo\"\n        dm[\"B\"] = \"bar\"\n        assert len(dm.columns) == 2\n        assert dm.values.dtype == np.object_\n\n        # upcast\n        dm[\"C\"] = 1\n        assert dm[\"C\"].dtype == np.int64\n\n        dm[\"E\"] = 1.0\n        assert dm[\"E\"].dtype == np.float64\n\n        # set existing column\n        dm[\"A\"] = \"bar\"\n        assert \"bar\" == dm[\"A\"][0]\n\n        dm = DataFrame(index=np.arange(3))\n        dm[\"A\"] = 1\n        dm[\"foo\"] = \"bar\"\n        del dm[\"foo\"]\n        dm[\"foo\"] = \"bar\"\n        assert dm[\"foo\"].dtype == np.object_\n\n        dm[\"coercable\"] = [\"1\", \"2\", \"3\"]\n        assert dm[\"coercable\"].dtype == np.object_",
        "begin_line": 698,
        "end_line": 738,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_corner2#740",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_corner2(self)",
        "snippet": "    def test_setitem_corner2(self):\n        data = {\n            \"title\": [\"foobar\", \"bar\", \"foobar\"] + [\"foobar\"] * 17,\n            \"cruft\": np.random.random(20),\n        }\n\n        df = DataFrame(data)\n        ix = df[df[\"title\"] == \"bar\"].index\n\n        df.loc[ix, [\"title\"]] = \"foobar\"\n        df.loc[ix, [\"cruft\"]] = 0\n\n        assert df.loc[1, \"title\"] == \"foobar\"\n        assert df.loc[1, \"cruft\"] == 0",
        "begin_line": 740,
        "end_line": 753,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_ambig#755",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_ambig(self)",
        "snippet": "    def test_setitem_ambig(self):\n        # Difficulties with mixed-type data\n        from decimal import Decimal\n\n        # Created as float type\n        dm = DataFrame(index=range(3), columns=range(3))\n\n        coercable_series = Series([Decimal(1) for _ in range(3)], index=range(3))\n        uncoercable_series = Series([\"foo\", \"bzr\", \"baz\"], index=range(3))\n\n        dm[0] = np.ones(3)\n        assert len(dm.columns) == 3\n\n        dm[1] = coercable_series\n        assert len(dm.columns) == 3\n\n        dm[2] = uncoercable_series\n        assert len(dm.columns) == 3\n        assert dm[2].dtype == np.object_",
        "begin_line": 755,
        "end_line": 773,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_clear_caches#775",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_clear_caches(self)",
        "snippet": "    def test_setitem_clear_caches(self):\n        # see gh-304\n        df = DataFrame(\n            {\"x\": [1.1, 2.1, 3.1, 4.1], \"y\": [5.1, 6.1, 7.1, 8.1]}, index=[0, 1, 2, 3]\n        )\n        df.insert(2, \"z\", np.nan)\n\n        # cache it\n        foo = df[\"z\"]\n        df.loc[df.index[2:], \"z\"] = 42\n\n        expected = Series([np.nan, np.nan, 42, 42], index=df.index, name=\"z\")\n\n        assert df[\"z\"] is not foo\n        tm.assert_series_equal(df[\"z\"], expected)",
        "begin_line": 775,
        "end_line": 789,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_None#791",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_None(self, float_frame)",
        "snippet": "    def test_setitem_None(self, float_frame):\n        # GH #766\n        float_frame[None] = float_frame[\"A\"]\n        assert_series_equal(\n            float_frame.iloc[:, -1], float_frame[\"A\"], check_names=False\n        )\n        assert_series_equal(\n            float_frame.loc[:, None], float_frame[\"A\"], check_names=False\n        )\n        assert_series_equal(float_frame[None], float_frame[\"A\"], check_names=False)\n        repr(float_frame)",
        "begin_line": 791,
        "end_line": 801,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_empty#803",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_empty(self)",
        "snippet": "    def test_setitem_empty(self):\n        # GH 9596\n        df = pd.DataFrame(\n            {\"a\": [\"1\", \"2\", \"3\"], \"b\": [\"11\", \"22\", \"33\"], \"c\": [\"111\", \"222\", \"333\"]}\n        )\n\n        result = df.copy()\n        result.loc[result.b.isna(), \"a\"] = result.a\n        assert_frame_equal(result, df)",
        "begin_line": 803,
        "end_line": 811,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_empty_frame_with_boolean#815",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_empty_frame_with_boolean(self, dtype, kwargs)",
        "snippet": "    def test_setitem_empty_frame_with_boolean(self, dtype, kwargs):\n        # see gh-10126\n        kwargs[\"dtype\"] = dtype\n        df = DataFrame(**kwargs)\n\n        df2 = df.copy()\n        df[df > df2] = 47\n        assert_frame_equal(df, df2)",
        "begin_line": 815,
        "end_line": 822,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_with_empty_listlike#824",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_with_empty_listlike(self)",
        "snippet": "    def test_setitem_with_empty_listlike(self):\n        # GH #17101\n        index = pd.Index([], name=\"idx\")\n        result = pd.DataFrame(columns=[\"A\"], index=index)\n        result[\"A\"] = []\n        expected = pd.DataFrame(columns=[\"A\"], index=index)\n        tm.assert_index_equal(result.index, expected.index)",
        "begin_line": 824,
        "end_line": 830,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_scalars_no_index#832",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_scalars_no_index(self)",
        "snippet": "    def test_setitem_scalars_no_index(self):\n        # GH16823 / 17894\n        df = DataFrame()\n        df[\"foo\"] = 1\n        expected = DataFrame(columns=[\"foo\"]).astype(np.int64)\n        assert_frame_equal(df, expected)",
        "begin_line": 832,
        "end_line": 837,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_empty_frame_with_boolean#839",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_empty_frame_with_boolean(self)",
        "snippet": "    def test_getitem_empty_frame_with_boolean(self):\n        # Test for issue #11859\n\n        df = pd.DataFrame()\n        df2 = df[df > 0]\n        assert_frame_equal(df, df2)",
        "begin_line": 839,
        "end_line": 844,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_delitem_corner#846",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_delitem_corner(self, float_frame)",
        "snippet": "    def test_delitem_corner(self, float_frame):\n        f = float_frame.copy()\n        del f[\"D\"]\n        assert len(f.columns) == 3\n        with pytest.raises(KeyError, match=r\"^'D'$\"):\n            del f[\"D\"]\n        del f[\"B\"]\n        assert len(f.columns) == 2",
        "begin_line": 846,
        "end_line": 853,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_fancy_2d#855",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_fancy_2d(self, float_frame)",
        "snippet": "    def test_getitem_fancy_2d(self, float_frame):\n        f = float_frame\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            assert_frame_equal(f.ix[:, [\"B\", \"A\"]], f.reindex(columns=[\"B\", \"A\"]))\n\n        subidx = float_frame.index[[5, 4, 1]]\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            assert_frame_equal(\n                f.ix[subidx, [\"B\", \"A\"]], f.reindex(index=subidx, columns=[\"B\", \"A\"])\n            )\n\n        # slicing rows, etc.\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            assert_frame_equal(f.ix[5:10], f[5:10])\n            assert_frame_equal(f.ix[5:10, :], f[5:10])\n            assert_frame_equal(\n                f.ix[:5, [\"A\", \"B\"]], f.reindex(index=f.index[:5], columns=[\"A\", \"B\"])\n            )\n\n        # slice rows with labels, inclusive!\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            expected = f.ix[5:11]\n            result = f.ix[f.index[5] : f.index[10]]\n        assert_frame_equal(expected, result)\n\n        # slice columns\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            assert_frame_equal(f.ix[:, :2], f.reindex(columns=[\"A\", \"B\"]))\n\n        # get view\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            exp = f.copy()\n            f.ix[5:10].values[:] = 5\n            exp.values[5:10] = 5\n            assert_frame_equal(f, exp)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            msg = \"Cannot index with multidimensional key\"\n            with pytest.raises(ValueError, match=msg):\n                f.ix[f > 0.5]",
        "begin_line": 855,
        "end_line": 902,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_slice_floats#904",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_slice_floats(self)",
        "snippet": "    def test_slice_floats(self):\n        index = [52195.504153, 52196.303147, 52198.369883]\n        df = DataFrame(np.random.rand(3, 2), index=index)\n\n        s1 = df.loc[52195.1:52196.5]\n        assert len(s1) == 2\n\n        s1 = df.loc[52195.1:52196.6]\n        assert len(s1) == 2\n\n        s1 = df.loc[52195.1:52198.9]\n        assert len(s1) == 3",
        "begin_line": 904,
        "end_line": 915,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_fancy_slice_integers_step#917",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_fancy_slice_integers_step(self)",
        "snippet": "    def test_getitem_fancy_slice_integers_step(self):\n        df = DataFrame(np.random.randn(10, 5))\n\n        # this is OK\n        result = df.iloc[:8:2]  # noqa\n        df.iloc[:8:2] = np.nan\n        assert isna(df.iloc[:8:2]).values.all()",
        "begin_line": 917,
        "end_line": 923,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_setitem_integer_slice_keyerrors#925",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_setitem_integer_slice_keyerrors(self)",
        "snippet": "    def test_getitem_setitem_integer_slice_keyerrors(self):\n        df = DataFrame(np.random.randn(10, 5), index=range(0, 20, 2))\n\n        # this is OK\n        cp = df.copy()\n        cp.iloc[4:10] = 0\n        assert (cp.iloc[4:10] == 0).values.all()\n\n        # so is this\n        cp = df.copy()\n        cp.iloc[3:11] = 0\n        assert (cp.iloc[3:11] == 0).values.all()\n\n        result = df.iloc[2:6]\n        result2 = df.loc[3:11]\n        expected = df.reindex([4, 6, 8, 10])\n\n        assert_frame_equal(result, expected)\n        assert_frame_equal(result2, expected)\n\n        # non-monotonic, raise KeyError\n        df2 = df.iloc[list(range(5)) + list(range(5, 10))[::-1]]\n        with pytest.raises(KeyError, match=r\"^3$\"):\n            df2.loc[3:11]\n        with pytest.raises(KeyError, match=r\"^3$\"):\n            df2.loc[3:11] = 0",
        "begin_line": 925,
        "end_line": 950,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_fancy_2d#952",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_fancy_2d(self, float_frame)",
        "snippet": "    def test_setitem_fancy_2d(self, float_frame):\n\n        # case 1\n        frame = float_frame.copy()\n        expected = frame.copy()\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            frame.ix[:, [\"B\", \"A\"]] = 1\n        expected[\"B\"] = 1.0\n        expected[\"A\"] = 1.0\n        assert_frame_equal(frame, expected)\n\n        # case 2\n        frame = float_frame.copy()\n        frame2 = float_frame.copy()\n\n        expected = frame.copy()\n\n        subidx = float_frame.index[[5, 4, 1]]\n        values = np.random.randn(3, 2)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            frame.ix[subidx, [\"B\", \"A\"]] = values\n            frame2.ix[[5, 4, 1], [\"B\", \"A\"]] = values\n\n            expected[\"B\"].ix[subidx] = values[:, 0]\n            expected[\"A\"].ix[subidx] = values[:, 1]\n\n        assert_frame_equal(frame, expected)\n        assert_frame_equal(frame2, expected)\n\n        # case 3: slicing rows, etc.\n        frame = float_frame.copy()\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            expected1 = float_frame.copy()\n            frame.ix[5:10] = 1.0\n            expected1.values[5:10] = 1.0\n        assert_frame_equal(frame, expected1)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            expected2 = float_frame.copy()\n            arr = np.random.randn(5, len(frame.columns))\n            frame.ix[5:10] = arr\n            expected2.values[5:10] = arr\n        assert_frame_equal(frame, expected2)\n\n        # case 4\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            frame = float_frame.copy()\n            frame.ix[5:10, :] = 1.0\n            assert_frame_equal(frame, expected1)\n            frame.ix[5:10, :] = arr\n        assert_frame_equal(frame, expected2)\n\n        # case 5\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            frame = float_frame.copy()\n            frame2 = float_frame.copy()\n\n            expected = float_frame.copy()\n            values = np.random.randn(5, 2)\n\n            frame.ix[:5, [\"A\", \"B\"]] = values\n            expected[\"A\"][:5] = values[:, 0]\n            expected[\"B\"][:5] = values[:, 1]\n        assert_frame_equal(frame, expected)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            frame2.ix[:5, [0, 1]] = values\n        assert_frame_equal(frame2, expected)\n\n        # case 6: slice rows with labels, inclusive!\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            frame = float_frame.copy()\n            expected = float_frame.copy()\n\n            frame.ix[frame.index[5] : frame.index[10]] = 5.0\n            expected.values[5:11] = 5\n        assert_frame_equal(frame, expected)\n\n        # case 7: slice columns\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            frame = float_frame.copy()\n            frame2 = float_frame.copy()\n            expected = float_frame.copy()\n\n            # slice indices\n            frame.ix[:, 1:3] = 4.0\n            expected.values[:, 1:3] = 4.0\n            assert_frame_equal(frame, expected)\n\n            # slice with labels\n            frame.ix[:, \"B\":\"C\"] = 4.0\n            assert_frame_equal(frame, expected)\n\n        # new corner case of boolean slicing / setting\n        frame = DataFrame(zip([2, 3, 9, 6, 7], [np.nan] * 5), columns=[\"a\", \"b\"])\n        lst = [100]\n        lst.extend([np.nan] * 4)\n        expected = DataFrame(zip([100, 3, 9, 6, 7], lst), columns=[\"a\", \"b\"])\n        frame[frame[\"a\"] == 2] = 100\n        assert_frame_equal(frame, expected)",
        "begin_line": 952,
        "end_line": 1063,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_fancy_getitem_slice_mixed#1065",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_fancy_getitem_slice_mixed(self, float_frame, float_string_frame)",
        "snippet": "    def test_fancy_getitem_slice_mixed(self, float_frame, float_string_frame):\n        sliced = float_string_frame.iloc[:, -3:]\n        assert sliced[\"D\"].dtype == np.float64\n\n        # get view with single block\n        # setting it triggers setting with copy\n        sliced = float_frame.iloc[:, -3:]\n\n        with pytest.raises(com.SettingWithCopyError):\n            sliced[\"C\"] = 4.0\n\n        assert (float_frame[\"C\"] == 4).all()",
        "begin_line": 1065,
        "end_line": 1076,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_fancy_setitem_int_labels#1078",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_fancy_setitem_int_labels(self)",
        "snippet": "    def test_fancy_setitem_int_labels(self):\n        # integer index defers to label-based indexing\n\n        df = DataFrame(np.random.randn(10, 5), index=np.arange(0, 20, 2))\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            tmp = df.copy()\n            exp = df.copy()\n            tmp.ix[[0, 2, 4]] = 5\n            exp.values[:3] = 5\n        assert_frame_equal(tmp, exp)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            tmp = df.copy()\n            exp = df.copy()\n            tmp.ix[6] = 5\n            exp.values[3] = 5\n        assert_frame_equal(tmp, exp)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            tmp = df.copy()\n            exp = df.copy()\n            tmp.ix[:, 2] = 5\n\n        # tmp correctly sets the dtype\n        # so match the exp way\n        exp[2] = 5\n        assert_frame_equal(tmp, exp)",
        "begin_line": 1078,
        "end_line": 1108,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_fancy_getitem_int_labels#1110",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_fancy_getitem_int_labels(self)",
        "snippet": "    def test_fancy_getitem_int_labels(self):\n        df = DataFrame(np.random.randn(10, 5), index=np.arange(0, 20, 2))\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            result = df.ix[[4, 2, 0], [2, 0]]\n            expected = df.reindex(index=[4, 2, 0], columns=[2, 0])\n        assert_frame_equal(result, expected)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            result = df.ix[[4, 2, 0]]\n            expected = df.reindex(index=[4, 2, 0])\n        assert_frame_equal(result, expected)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            result = df.ix[4]\n            expected = df.xs(4)\n        assert_series_equal(result, expected)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            result = df.ix[:, 3]\n            expected = df[3]\n        assert_series_equal(result, expected)",
        "begin_line": 1110,
        "end_line": 1135,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_fancy_index_int_labels_exceptions#1137",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_fancy_index_int_labels_exceptions(self, float_frame)",
        "snippet": "    def test_fancy_index_int_labels_exceptions(self, float_frame):\n        df = DataFrame(np.random.randn(10, 5), index=np.arange(0, 20, 2))\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n\n            # labels that aren't contained\n            with pytest.raises(KeyError, match=r\"\\[1\\] not in index\"):\n                df.ix[[0, 1, 2], [2, 3, 4]] = 5\n\n            # try to set indices not contained in frame\n            msg = (\n                r\"None of \\[Index\\(\\['foo', 'bar', 'baz'\\],\"\n                r\" dtype='object'\\)\\] are in the \\[index\\]\"\n            )\n            with pytest.raises(KeyError, match=msg):\n                float_frame.ix[[\"foo\", \"bar\", \"baz\"]] = 1\n            msg = (\n                r\"None of \\[Index\\(\\['E'\\], dtype='object'\\)\\] are in the\"\n                r\" \\[columns\\]\"\n            )\n            with pytest.raises(KeyError, match=msg):\n                float_frame.ix[:, [\"E\"]] = 1",
        "begin_line": 1137,
        "end_line": 1159,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_fancy_mixed_2d#1166",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_fancy_mixed_2d(self, float_string_frame)",
        "snippet": "    def test_setitem_fancy_mixed_2d(self, float_string_frame):\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            self.mixed_frame.ix[:5, [\"C\", \"B\", \"A\"]] = 5\n            result = self.mixed_frame.ix[:5, [\"C\", \"B\", \"A\"]]\n            assert (result.values == 5).all()\n\n            float_string_frame.ix[5] = np.nan\n            assert isna(float_string_frame.ix[5]).all()\n\n            float_string_frame.ix[5] = float_string_frame.ix[6]\n            assert_series_equal(\n                float_string_frame.ix[5], float_string_frame.ix[6], check_names=False\n            )\n\n        # #1432\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            df = DataFrame({1: [1.0, 2.0, 3.0], 2: [3, 4, 5]})\n            assert df._is_mixed_type\n\n            df.ix[1] = [5, 10]\n\n            expected = DataFrame({1: [1.0, 5.0, 3.0], 2: [3, 10, 5]})\n\n            assert_frame_equal(df, expected)",
        "begin_line": 1166,
        "end_line": 1192,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_ix_align#1194",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_ix_align(self)",
        "snippet": "    def test_ix_align(self):\n        b = Series(np.random.randn(10), name=0).sort_values()\n        df_orig = DataFrame(np.random.randn(10, 4))\n        df = df_orig.copy()\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            df.ix[:, 0] = b\n            assert_series_equal(df.ix[:, 0].reindex(b.index), b)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            dft = df_orig.T\n            dft.ix[0, :] = b\n            assert_series_equal(dft.ix[0, :].reindex(b.index), b)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            df = df_orig.copy()\n            df.ix[:5, 0] = b\n            s = df.ix[:5, 0]\n            assert_series_equal(s, b.reindex(s.index))\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            dft = df_orig.T\n            dft.ix[0, :5] = b\n            s = dft.ix[0, :5]\n            assert_series_equal(s, b.reindex(s.index))\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            df = df_orig.copy()\n            idx = [0, 1, 3, 5]\n            df.ix[idx, 0] = b\n            s = df.ix[idx, 0]\n            assert_series_equal(s, b.reindex(s.index))\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            dft = df_orig.T\n            dft.ix[0, idx] = b\n            s = dft.ix[0, idx]\n            assert_series_equal(s, b.reindex(s.index))",
        "begin_line": 1194,
        "end_line": 1237,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_ix_frame_align#1239",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_ix_frame_align(self)",
        "snippet": "    def test_ix_frame_align(self):\n        b = DataFrame(np.random.randn(3, 4))\n        df_orig = DataFrame(np.random.randn(10, 4))\n        df = df_orig.copy()\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            df.ix[:3] = b\n            out = b.ix[:3]\n            assert_frame_equal(out, b)\n\n        b.sort_index(inplace=True)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            df = df_orig.copy()\n            df.ix[[0, 1, 2]] = b\n            out = df.ix[[0, 1, 2]].reindex(b.index)\n            assert_frame_equal(out, b)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            df = df_orig.copy()\n            df.ix[:3] = b\n            out = df.ix[:3]\n            assert_frame_equal(out, b.reindex(out.index))",
        "begin_line": 1239,
        "end_line": 1264,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_setitem_non_ix_labels#1266",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_setitem_non_ix_labels(self)",
        "snippet": "    def test_getitem_setitem_non_ix_labels(self):\n        df = tm.makeTimeDataFrame()\n\n        start, end = df.index[[5, 10]]\n\n        result = df.loc[start:end]\n        result2 = df[start:end]\n        expected = df[5:11]\n        assert_frame_equal(result, expected)\n        assert_frame_equal(result2, expected)\n\n        result = df.copy()\n        result.loc[start:end] = 0\n        result2 = df.copy()\n        result2[start:end] = 0\n        expected = df.copy()\n        expected[5:11] = 0\n        assert_frame_equal(result, expected)\n        assert_frame_equal(result2, expected)",
        "begin_line": 1266,
        "end_line": 1284,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_ix_multi_take#1286",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_ix_multi_take(self)",
        "snippet": "    def test_ix_multi_take(self):\n        df = DataFrame(np.random.randn(3, 2))\n        rs = df.loc[df.index == 0, :]\n        xp = df.reindex([0])\n        assert_frame_equal(rs, xp)\n\n        \"\"\" #1321\n        df = DataFrame(np.random.randn(3, 2))\n        rs = df.loc[df.index==0, df.columns==1]\n        xp = df.reindex([0], [1])\n        assert_frame_equal(rs, xp)\n        \"\"\"",
        "begin_line": 1286,
        "end_line": 1297,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_ix_multi_take_nonint_index#1299",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_ix_multi_take_nonint_index(self)",
        "snippet": "    def test_ix_multi_take_nonint_index(self):\n        df = DataFrame(np.random.randn(3, 2), index=[\"x\", \"y\", \"z\"], columns=[\"a\", \"b\"])\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            rs = df.ix[[0], [0]]\n        xp = df.reindex([\"x\"], columns=[\"a\"])\n        assert_frame_equal(rs, xp)",
        "begin_line": 1299,
        "end_line": 1305,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_ix_multi_take_multiindex#1307",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_ix_multi_take_multiindex(self)",
        "snippet": "    def test_ix_multi_take_multiindex(self):\n        df = DataFrame(\n            np.random.randn(3, 2),\n            index=[\"x\", \"y\", \"z\"],\n            columns=[[\"a\", \"b\"], [\"1\", \"2\"]],\n        )\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            rs = df.ix[[0], [0]]\n        xp = df.reindex([\"x\"], columns=[(\"a\", \"1\")])\n        assert_frame_equal(rs, xp)",
        "begin_line": 1307,
        "end_line": 1317,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_ix_dup#1319",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_ix_dup(self)",
        "snippet": "    def test_ix_dup(self):\n        idx = Index([\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"])\n        df = DataFrame(np.random.randn(len(idx), 3), idx)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            sub = df.ix[:\"d\"]\n            assert_frame_equal(sub, df)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            sub = df.ix[\"a\":\"c\"]\n            assert_frame_equal(sub, df.ix[0:4])\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            sub = df.ix[\"b\":\"d\"]\n            assert_frame_equal(sub, df.ix[2:])",
        "begin_line": 1319,
        "end_line": 1336,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_fancy_1d#1338",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_fancy_1d(self, float_frame, float_string_frame)",
        "snippet": "    def test_getitem_fancy_1d(self, float_frame, float_string_frame):\n        f = float_frame\n\n        # return self if no slicing...for now\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            assert f.ix[:, :] is f\n\n        # low dimensional slice\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            xs1 = f.ix[2, [\"C\", \"B\", \"A\"]]\n        xs2 = f.xs(f.index[2]).reindex([\"C\", \"B\", \"A\"])\n        tm.assert_series_equal(xs1, xs2)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            ts1 = f.ix[5:10, 2]\n        ts2 = f[f.columns[2]][5:10]\n        tm.assert_series_equal(ts1, ts2)\n\n        # positional xs\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            xs1 = f.ix[0]\n        xs2 = f.xs(f.index[0])\n        tm.assert_series_equal(xs1, xs2)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            xs1 = f.ix[f.index[5]]\n        xs2 = f.xs(f.index[5])\n        tm.assert_series_equal(xs1, xs2)\n\n        # single column\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            assert_series_equal(f.ix[:, \"A\"], f[\"A\"])\n\n        # return view\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            exp = f.copy()\n            exp.values[5] = 4\n            f.ix[5][:] = 4\n        tm.assert_frame_equal(exp, f)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            exp.values[:, 1] = 6\n            f.ix[:, 1][:] = 6\n        tm.assert_frame_equal(exp, f)\n\n        # slice of mixed-frame\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            xs = float_string_frame.ix[5]\n        exp = float_string_frame.xs(float_string_frame.index[5])\n        tm.assert_series_equal(xs, exp)",
        "begin_line": 1338,
        "end_line": 1396,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_fancy_1d#1398",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_fancy_1d(self, float_frame)",
        "snippet": "    def test_setitem_fancy_1d(self, float_frame):\n\n        # case 1: set cross-section for indices\n        frame = float_frame.copy()\n        expected = float_frame.copy()\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            frame.ix[2, [\"C\", \"B\", \"A\"]] = [1.0, 2.0, 3.0]\n        expected[\"C\"][2] = 1.0\n        expected[\"B\"][2] = 2.0\n        expected[\"A\"][2] = 3.0\n        assert_frame_equal(frame, expected)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            frame2 = float_frame.copy()\n            frame2.ix[2, [3, 2, 1]] = [1.0, 2.0, 3.0]\n        assert_frame_equal(frame, expected)\n\n        # case 2, set a section of a column\n        frame = float_frame.copy()\n        expected = float_frame.copy()\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            vals = np.random.randn(5)\n            expected.values[5:10, 2] = vals\n            frame.ix[5:10, 2] = vals\n        assert_frame_equal(frame, expected)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            frame2 = float_frame.copy()\n            frame2.ix[5:10, \"B\"] = vals\n        assert_frame_equal(frame, expected)\n\n        # case 3: full xs\n        frame = float_frame.copy()\n        expected = float_frame.copy()\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            frame.ix[4] = 5.0\n            expected.values[4] = 5.0\n        assert_frame_equal(frame, expected)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            frame.ix[frame.index[4]] = 6.0\n            expected.values[4] = 6.0\n        assert_frame_equal(frame, expected)\n\n        # single column\n        frame = float_frame.copy()\n        expected = float_frame.copy()\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            frame.ix[:, \"A\"] = 7.0\n            expected[\"A\"] = 7.0\n        assert_frame_equal(frame, expected)",
        "begin_line": 1398,
        "end_line": 1459,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_fancy_scalar#1461",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_fancy_scalar(self, float_frame)",
        "snippet": "    def test_getitem_fancy_scalar(self, float_frame):\n        f = float_frame\n        ix = f.loc\n\n        # individual value\n        for col in f.columns:\n            ts = f[col]\n            for idx in f.index[::5]:\n                assert ix[idx, col] == ts[idx]",
        "begin_line": 1461,
        "end_line": 1469,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_fancy_scalar#1471",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_fancy_scalar(self, float_frame)",
        "snippet": "    def test_setitem_fancy_scalar(self, float_frame):\n        f = float_frame\n        expected = float_frame.copy()\n        ix = f.loc\n\n        # individual value\n        for j, col in enumerate(f.columns):\n            ts = f[col]  # noqa\n            for idx in f.index[::5]:\n                i = f.index.get_loc(idx)\n                val = np.random.randn()\n                expected.values[i, j] = val\n\n                ix[idx, col] = val\n                assert_frame_equal(f, expected)",
        "begin_line": 1471,
        "end_line": 1485,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_fancy_boolean#1487",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_fancy_boolean(self, float_frame)",
        "snippet": "    def test_getitem_fancy_boolean(self, float_frame):\n        f = float_frame\n        ix = f.loc\n\n        expected = f.reindex(columns=[\"B\", \"D\"])\n        result = ix[:, [False, True, False, True]]\n        assert_frame_equal(result, expected)\n\n        expected = f.reindex(index=f.index[5:10], columns=[\"B\", \"D\"])\n        result = ix[f.index[5:10], [False, True, False, True]]\n        assert_frame_equal(result, expected)\n\n        boolvec = f.index > f.index[7]\n        expected = f.reindex(index=f.index[boolvec])\n        result = ix[boolvec]\n        assert_frame_equal(result, expected)\n        result = ix[boolvec, :]\n        assert_frame_equal(result, expected)\n\n        result = ix[boolvec, f.columns[2:]]\n        expected = f.reindex(index=f.index[boolvec], columns=[\"C\", \"D\"])\n        assert_frame_equal(result, expected)",
        "begin_line": 1487,
        "end_line": 1508,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_fancy_boolean#1510",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_fancy_boolean(self, float_frame)",
        "snippet": "    def test_setitem_fancy_boolean(self, float_frame):\n        # from 2d, set with booleans\n        frame = float_frame.copy()\n        expected = float_frame.copy()\n\n        mask = frame[\"A\"] > 0\n        frame.loc[mask] = 0.0\n        expected.values[mask.values] = 0.0\n        assert_frame_equal(frame, expected)\n\n        frame = float_frame.copy()\n        expected = float_frame.copy()\n        frame.loc[mask, [\"A\", \"B\"]] = 0.0\n        expected.values[mask.values, :2] = 0.0\n        assert_frame_equal(frame, expected)",
        "begin_line": 1510,
        "end_line": 1524,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_fancy_ints#1526",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_fancy_ints(self, float_frame)",
        "snippet": "    def test_getitem_fancy_ints(self, float_frame):\n        result = float_frame.iloc[[1, 4, 7]]\n        expected = float_frame.loc[float_frame.index[[1, 4, 7]]]\n        assert_frame_equal(result, expected)\n\n        result = float_frame.iloc[:, [2, 0, 1]]\n        expected = float_frame.loc[:, float_frame.columns[[2, 0, 1]]]\n        assert_frame_equal(result, expected)",
        "begin_line": 1526,
        "end_line": 1533,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_setitem_fancy_exceptions#1535",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_setitem_fancy_exceptions(self, float_frame)",
        "snippet": "    def test_getitem_setitem_fancy_exceptions(self, float_frame):\n        ix = float_frame.iloc\n        with pytest.raises(IndexingError, match=\"Too many indexers\"):\n            ix[:, :, :]\n\n        with pytest.raises(IndexingError):\n            ix[:, :, :] = 1",
        "begin_line": 1535,
        "end_line": 1541,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_setitem_boolean_misaligned#1543",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_setitem_boolean_misaligned(self, float_frame)",
        "snippet": "    def test_getitem_setitem_boolean_misaligned(self, float_frame):\n        # boolean index misaligned labels\n        mask = float_frame[\"A\"][::-1] > 1\n\n        result = float_frame.loc[mask]\n        expected = float_frame.loc[mask[::-1]]\n        assert_frame_equal(result, expected)\n\n        cp = float_frame.copy()\n        expected = float_frame.copy()\n        cp.loc[mask] = 0\n        expected.loc[mask] = 0\n        assert_frame_equal(cp, expected)",
        "begin_line": 1543,
        "end_line": 1555,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_setitem_boolean_multi#1557",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_setitem_boolean_multi(self)",
        "snippet": "    def test_getitem_setitem_boolean_multi(self):\n        df = DataFrame(np.random.randn(3, 2))\n\n        # get\n        k1 = np.array([True, False, True])\n        k2 = np.array([False, True])\n        result = df.loc[k1, k2]\n        expected = df.loc[[0, 2], [1]]\n        assert_frame_equal(result, expected)\n\n        expected = df.copy()\n        df.loc[np.array([True, False, True]), np.array([False, True])] = 5\n        expected.loc[[0, 2], [1]] = 5\n        assert_frame_equal(df, expected)",
        "begin_line": 1557,
        "end_line": 1570,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_setitem_float_labels#1572",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_setitem_float_labels(self)",
        "snippet": "    def test_getitem_setitem_float_labels(self):\n        index = Index([1.5, 2, 3, 4, 5])\n        df = DataFrame(np.random.randn(5, 5), index=index)\n\n        result = df.loc[1.5:4]\n        expected = df.reindex([1.5, 2, 3, 4])\n        assert_frame_equal(result, expected)\n        assert len(result) == 4\n\n        result = df.loc[4:5]\n        expected = df.reindex([4, 5])  # reindex with int\n        assert_frame_equal(result, expected, check_index_type=False)\n        assert len(result) == 2\n\n        result = df.loc[4:5]\n        expected = df.reindex([4.0, 5.0])  # reindex with float\n        assert_frame_equal(result, expected)\n        assert len(result) == 2\n\n        # loc_float changes this to work properly\n        result = df.loc[1:2]\n        expected = df.iloc[0:2]\n        assert_frame_equal(result, expected)\n\n        df.loc[1:2] = 0\n        result = df[1:2]\n        assert (result == 0).all().all()\n\n        # #2727\n        index = Index([1.0, 2.5, 3.5, 4.5, 5.0])\n        df = DataFrame(np.random.randn(5, 5), index=index)\n\n        # positional slicing only via iloc!\n        msg = (\n            \"cannot do slice indexing on\"\n            r\" <class 'pandas\\.core\\.indexes\\.numeric\\.Float64Index'> with\"\n            r\" these indexers \\[1.0\\] of <class 'float'>\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            df.iloc[1.0:5]\n\n        result = df.iloc[4:5]\n        expected = df.reindex([5.0])\n        assert_frame_equal(result, expected)\n        assert len(result) == 1\n\n        cp = df.copy()\n\n        with pytest.raises(TypeError):\n            cp.iloc[1.0:5] = 0\n\n        with pytest.raises(TypeError):\n            result = cp.iloc[1.0:5] == 0  # noqa\n\n        assert result.values.all()\n        assert (cp.iloc[0:1] == df.iloc[0:1]).values.all()\n\n        cp = df.copy()\n        cp.iloc[4:5] = 0\n        assert (cp.iloc[4:5] == 0).values.all()\n        assert (cp.iloc[0:4] == df.iloc[0:4]).values.all()\n\n        # float slicing\n        result = df.loc[1.0:5]\n        expected = df\n        assert_frame_equal(result, expected)\n        assert len(result) == 5\n\n        result = df.loc[1.1:5]\n        expected = df.reindex([2.5, 3.5, 4.5, 5.0])\n        assert_frame_equal(result, expected)\n        assert len(result) == 4\n\n        result = df.loc[4.51:5]\n        expected = df.reindex([5.0])\n        assert_frame_equal(result, expected)\n        assert len(result) == 1\n\n        result = df.loc[1.0:5.0]\n        expected = df.reindex([1.0, 2.5, 3.5, 4.5, 5.0])\n        assert_frame_equal(result, expected)\n        assert len(result) == 5\n\n        cp = df.copy()\n        cp.loc[1.0:5.0] = 0\n        result = cp.loc[1.0:5.0]\n        assert (result == 0).values.all()",
        "begin_line": 1572,
        "end_line": 1658,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_single_column_mixed#1660",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_single_column_mixed(self)",
        "snippet": "    def test_setitem_single_column_mixed(self):\n        df = DataFrame(\n            np.random.randn(5, 3),\n            index=[\"a\", \"b\", \"c\", \"d\", \"e\"],\n            columns=[\"foo\", \"bar\", \"baz\"],\n        )\n        df[\"str\"] = \"qux\"\n        df.loc[df.index[::2], \"str\"] = np.nan\n        expected = np.array([np.nan, \"qux\", np.nan, \"qux\", np.nan], dtype=object)\n        assert_almost_equal(df[\"str\"].values, expected)",
        "begin_line": 1660,
        "end_line": 1669,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_single_column_mixed_datetime#1671",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_single_column_mixed_datetime(self)",
        "snippet": "    def test_setitem_single_column_mixed_datetime(self):\n        df = DataFrame(\n            np.random.randn(5, 3),\n            index=[\"a\", \"b\", \"c\", \"d\", \"e\"],\n            columns=[\"foo\", \"bar\", \"baz\"],\n        )\n\n        df[\"timestamp\"] = Timestamp(\"20010102\")\n\n        # check our dtypes\n        result = df.dtypes\n        expected = Series(\n            [np.dtype(\"float64\")] * 3 + [np.dtype(\"datetime64[ns]\")],\n            index=[\"foo\", \"bar\", \"baz\", \"timestamp\"],\n        )\n        assert_series_equal(result, expected)\n\n        # GH#16674 iNaT is treated as an integer when given by the user\n        df.loc[\"b\", \"timestamp\"] = iNaT\n        assert not isna(df.loc[\"b\", \"timestamp\"])\n        assert df[\"timestamp\"].dtype == np.object_\n        assert df.loc[\"b\", \"timestamp\"] == iNaT\n\n        # allow this syntax\n        df.loc[\"c\", \"timestamp\"] = np.nan\n        assert isna(df.loc[\"c\", \"timestamp\"])\n\n        # allow this syntax\n        df.loc[\"d\", :] = np.nan\n        assert not isna(df.loc[\"c\", :]).all()",
        "begin_line": 1671,
        "end_line": 1700,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_mixed_datetime#1708",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_mixed_datetime(self)",
        "snippet": "    def test_setitem_mixed_datetime(self):\n        # GH 9336\n        expected = DataFrame(\n            {\n                \"a\": [0, 0, 0, 0, 13, 14],\n                \"b\": [\n                    pd.datetime(2012, 1, 1),\n                    1,\n                    \"x\",\n                    \"y\",\n                    pd.datetime(2013, 1, 1),\n                    pd.datetime(2014, 1, 1),\n                ],\n            }\n        )\n        df = pd.DataFrame(0, columns=list(\"ab\"), index=range(6))\n        df[\"b\"] = pd.NaT\n        df.loc[0, \"b\"] = pd.datetime(2012, 1, 1)\n        df.loc[1, \"b\"] = 1\n        df.loc[[2, 3], \"b\"] = \"x\", \"y\"\n        A = np.array(\n            [\n                [13, np.datetime64(\"2013-01-01T00:00:00\")],\n                [14, np.datetime64(\"2014-01-01T00:00:00\")],\n            ]\n        )\n        df.loc[[4, 5], [\"a\", \"b\"]] = A\n        assert_frame_equal(df, expected)",
        "begin_line": 1708,
        "end_line": 1735,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_frame_float#1737",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_frame_float(self, float_frame)",
        "snippet": "    def test_setitem_frame_float(self, float_frame):\n        piece = float_frame.loc[float_frame.index[:2], [\"A\", \"B\"]]\n        float_frame.loc[float_frame.index[-2] :, [\"A\", \"B\"]] = piece.values\n        result = float_frame.loc[float_frame.index[-2:], [\"A\", \"B\"]].values\n        expected = piece.values\n        assert_almost_equal(result, expected)",
        "begin_line": 1737,
        "end_line": 1742,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_frame_mixed#1744",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_frame_mixed(self, float_string_frame)",
        "snippet": "    def test_setitem_frame_mixed(self, float_string_frame):\n        # GH 3216\n\n        # already aligned\n        f = float_string_frame.copy()\n        piece = DataFrame(\n            [[1.0, 2.0], [3.0, 4.0]], index=f.index[0:2], columns=[\"A\", \"B\"]\n        )\n        key = (slice(None, 2), [\"A\", \"B\"])\n        f.loc[key] = piece\n        assert_almost_equal(f.loc[f.index[0:2], [\"A\", \"B\"]].values, piece.values)\n\n        # rows unaligned\n        f = float_string_frame.copy()\n        piece = DataFrame(\n            [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0], [7.0, 8.0]],\n            index=list(f.index[0:2]) + [\"foo\", \"bar\"],\n            columns=[\"A\", \"B\"],\n        )\n        key = (slice(None, 2), [\"A\", \"B\"])\n        f.loc[key] = piece\n        assert_almost_equal(f.loc[f.index[0:2:], [\"A\", \"B\"]].values, piece.values[0:2])\n\n        # key is unaligned with values\n        f = float_string_frame.copy()\n        piece = f.loc[f.index[:2], [\"A\"]]\n        piece.index = f.index[-2:]\n        key = (slice(-2, None), [\"A\", \"B\"])\n        f.loc[key] = piece\n        piece[\"B\"] = np.nan\n        assert_almost_equal(f.loc[f.index[-2:], [\"A\", \"B\"]].values, piece.values)\n\n        # ndarray\n        f = float_string_frame.copy()\n        piece = float_string_frame.loc[f.index[:2], [\"A\", \"B\"]]\n        key = (slice(-2, None), [\"A\", \"B\"])\n        f.loc[key] = piece.values\n        assert_almost_equal(f.loc[f.index[-2:], [\"A\", \"B\"]].values, piece.values)",
        "begin_line": 1744,
        "end_line": 1781,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_frame_upcast#1783",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_frame_upcast(self)",
        "snippet": "    def test_setitem_frame_upcast(self):\n        # needs upcasting\n        df = DataFrame([[1, 2, \"foo\"], [3, 4, \"bar\"]], columns=[\"A\", \"B\", \"C\"])\n        df2 = df.copy()\n        df2.loc[:, [\"A\", \"B\"]] = df.loc[:, [\"A\", \"B\"]] + 0.5\n        expected = df.reindex(columns=[\"A\", \"B\"])\n        expected += 0.5\n        expected[\"C\"] = df[\"C\"]\n        assert_frame_equal(df2, expected)",
        "begin_line": 1783,
        "end_line": 1791,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_frame_align#1793",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_frame_align(self, float_frame)",
        "snippet": "    def test_setitem_frame_align(self, float_frame):\n        piece = float_frame.loc[float_frame.index[:2], [\"A\", \"B\"]]\n        piece.index = float_frame.index[-2:]\n        piece.columns = [\"A\", \"B\"]\n        float_frame.loc[float_frame.index[-2:], [\"A\", \"B\"]] = piece\n        result = float_frame.loc[float_frame.index[-2:], [\"A\", \"B\"]].values\n        expected = piece.values\n        assert_almost_equal(result, expected)",
        "begin_line": 1793,
        "end_line": 1800,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_setitem_ix_duplicates#1802",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_setitem_ix_duplicates(self)",
        "snippet": "    def test_getitem_setitem_ix_duplicates(self):\n        # #1201\n        df = DataFrame(np.random.randn(5, 3), index=[\"foo\", \"foo\", \"bar\", \"baz\", \"bar\"])\n\n        result = df.loc[\"foo\"]\n        expected = df[:2]\n        assert_frame_equal(result, expected)\n\n        result = df.loc[\"bar\"]\n        expected = df.iloc[[2, 4]]\n        assert_frame_equal(result, expected)\n\n        result = df.loc[\"baz\"]\n        expected = df.iloc[3]\n        assert_series_equal(result, expected)",
        "begin_line": 1802,
        "end_line": 1816,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_ix_boolean_duplicates_multiple#1818",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_ix_boolean_duplicates_multiple(self)",
        "snippet": "    def test_getitem_ix_boolean_duplicates_multiple(self):\n        # #1201\n        df = DataFrame(np.random.randn(5, 3), index=[\"foo\", \"foo\", \"bar\", \"baz\", \"bar\"])\n\n        result = df.loc[[\"bar\"]]\n        exp = df.iloc[[2, 4]]\n        assert_frame_equal(result, exp)\n\n        result = df.loc[df[1] > 0]\n        exp = df[df[1] > 0]\n        assert_frame_equal(result, exp)\n\n        result = df.loc[df[0] > 0]\n        exp = df[df[0] > 0]\n        assert_frame_equal(result, exp)",
        "begin_line": 1818,
        "end_line": 1832,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_setitem_ix_bool_keyerror#1834",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_setitem_ix_bool_keyerror(self)",
        "snippet": "    def test_getitem_setitem_ix_bool_keyerror(self):\n        # #2199\n        df = DataFrame({\"a\": [1, 2, 3]})\n\n        with pytest.raises(KeyError, match=r\"^False$\"):\n            df.loc[False]\n        with pytest.raises(KeyError, match=r\"^True$\"):\n            df.loc[True]\n\n        msg = \"cannot use a single bool to index into setitem\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[False] = 0\n        with pytest.raises(KeyError, match=msg):\n            df.loc[True] = 0",
        "begin_line": 1834,
        "end_line": 1847,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_list_duplicates#1849",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_list_duplicates(self)",
        "snippet": "    def test_getitem_list_duplicates(self):\n        # #1943\n        df = DataFrame(np.random.randn(4, 4), columns=list(\"AABC\"))\n        df.columns.name = \"foo\"\n\n        result = df[[\"B\", \"C\"]]\n        assert result.columns.name == \"foo\"\n\n        expected = df.iloc[:, 2:]\n        assert_frame_equal(result, expected)",
        "begin_line": 1849,
        "end_line": 1858,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_get_value#1860",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_get_value(self, float_frame)",
        "snippet": "    def test_get_value(self, float_frame):\n        for idx in float_frame.index:\n            for col in float_frame.columns:\n                result = float_frame._get_value(idx, col)\n                expected = float_frame[col][idx]\n                assert result == expected",
        "begin_line": 1860,
        "end_line": 1865,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_lookup_float#1867",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_lookup_float(self, float_frame)",
        "snippet": "    def test_lookup_float(self, float_frame):\n        df = float_frame\n        rows = list(df.index) * len(df.columns)\n        cols = list(df.columns) * len(df.index)\n        result = df.lookup(rows, cols)\n\n        expected = np.array([df.loc[r, c] for r, c in zip(rows, cols)])\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 1867,
        "end_line": 1874,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_lookup_mixed#1876",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_lookup_mixed(self, float_string_frame)",
        "snippet": "    def test_lookup_mixed(self, float_string_frame):\n        df = float_string_frame\n        rows = list(df.index) * len(df.columns)\n        cols = list(df.columns) * len(df.index)\n        result = df.lookup(rows, cols)\n\n        expected = np.array(\n            [df.loc[r, c] for r, c in zip(rows, cols)], dtype=np.object_\n        )\n        tm.assert_almost_equal(result, expected)",
        "begin_line": 1876,
        "end_line": 1885,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_lookup_bool#1887",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_lookup_bool(self)",
        "snippet": "    def test_lookup_bool(self):\n        df = DataFrame(\n            {\n                \"label\": [\"a\", \"b\", \"a\", \"c\"],\n                \"mask_a\": [True, True, False, True],\n                \"mask_b\": [True, False, False, False],\n                \"mask_c\": [False, True, False, True],\n            }\n        )\n        df[\"mask\"] = df.lookup(df.index, \"mask_\" + df[\"label\"])\n\n        exp_mask = np.array(\n            [df.loc[r, c] for r, c in zip(df.index, \"mask_\" + df[\"label\"])]\n        )\n\n        tm.assert_series_equal(df[\"mask\"], pd.Series(exp_mask, name=\"mask\"))\n        assert df[\"mask\"].dtype == np.bool_",
        "begin_line": 1887,
        "end_line": 1903,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_lookup_raises#1905",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_lookup_raises(self, float_frame)",
        "snippet": "    def test_lookup_raises(self, float_frame):\n        with pytest.raises(KeyError, match=\"'One or more row labels was not found'\"):\n            float_frame.lookup([\"xyz\"], [\"A\"])\n\n        with pytest.raises(KeyError, match=\"'One or more column labels was not found'\"):\n            float_frame.lookup([float_frame.index[0]], [\"xyz\"])\n\n        with pytest.raises(ValueError, match=\"same size\"):\n            float_frame.lookup([\"a\", \"b\", \"c\"], [\"a\"])",
        "begin_line": 1905,
        "end_line": 1913,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_set_value#1915",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_set_value(self, float_frame)",
        "snippet": "    def test_set_value(self, float_frame):\n        for idx in float_frame.index:\n            for col in float_frame.columns:\n                float_frame._set_value(idx, col, 1)\n                assert float_frame[col][idx] == 1",
        "begin_line": 1915,
        "end_line": 1919,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_set_value_resize#1921",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_set_value_resize(self, float_frame)",
        "snippet": "    def test_set_value_resize(self, float_frame):\n\n        res = float_frame._set_value(\"foobar\", \"B\", 0)\n        assert res is float_frame\n        assert res.index[-1] == \"foobar\"\n        assert res._get_value(\"foobar\", \"B\") == 0\n\n        float_frame.loc[\"foobar\", \"qux\"] = 0\n        assert float_frame._get_value(\"foobar\", \"qux\") == 0\n\n        res = float_frame.copy()\n        res3 = res._set_value(\"foobar\", \"baz\", \"sam\")\n        assert res3[\"baz\"].dtype == np.object_\n\n        res = float_frame.copy()\n        res3 = res._set_value(\"foobar\", \"baz\", True)\n        assert res3[\"baz\"].dtype == np.object_\n\n        res = float_frame.copy()\n        res3 = res._set_value(\"foobar\", \"baz\", 5)\n        assert is_float_dtype(res3[\"baz\"])\n        assert isna(res3[\"baz\"].drop([\"foobar\"])).all()\n        msg = \"could not convert string to float: 'sam'\"\n        with pytest.raises(ValueError, match=msg):\n            res3._set_value(\"foobar\", \"baz\", \"sam\")",
        "begin_line": 1921,
        "end_line": 1945,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_set_value_with_index_dtype_change#1947",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_set_value_with_index_dtype_change(self)",
        "snippet": "    def test_set_value_with_index_dtype_change(self):\n        df_orig = DataFrame(np.random.randn(3, 3), index=range(3), columns=list(\"ABC\"))\n\n        # this is actually ambiguous as the 2 is interpreted as a positional\n        # so column is not created\n        df = df_orig.copy()\n        df._set_value(\"C\", 2, 1.0)\n        assert list(df.index) == list(df_orig.index) + [\"C\"]\n        # assert list(df.columns) == list(df_orig.columns) + [2]\n\n        df = df_orig.copy()\n        df.loc[\"C\", 2] = 1.0\n        assert list(df.index) == list(df_orig.index) + [\"C\"]\n        # assert list(df.columns) == list(df_orig.columns) + [2]\n\n        # create both new\n        df = df_orig.copy()\n        df._set_value(\"C\", \"D\", 1.0)\n        assert list(df.index) == list(df_orig.index) + [\"C\"]\n        assert list(df.columns) == list(df_orig.columns) + [\"D\"]\n\n        df = df_orig.copy()\n        df.loc[\"C\", \"D\"] = 1.0\n        assert list(df.index) == list(df_orig.index) + [\"C\"]\n        assert list(df.columns) == list(df_orig.columns) + [\"D\"]",
        "begin_line": 1947,
        "end_line": 1971,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_get_set_value_no_partial_indexing#1973",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_get_set_value_no_partial_indexing(self)",
        "snippet": "    def test_get_set_value_no_partial_indexing(self):\n        # partial w/ MultiIndex raise exception\n        index = MultiIndex.from_tuples([(0, 1), (0, 2), (1, 1), (1, 2)])\n        df = DataFrame(index=index, columns=range(4))\n        with pytest.raises(KeyError, match=r\"^0$\"):\n            df._get_value(0, 1)",
        "begin_line": 1973,
        "end_line": 1978,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_single_element_ix_dont_upcast#1980",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_single_element_ix_dont_upcast(self, float_frame)",
        "snippet": "    def test_single_element_ix_dont_upcast(self, float_frame):\n        float_frame[\"E\"] = 1\n        assert issubclass(float_frame[\"E\"].dtype.type, (int, np.integer))\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            result = float_frame.ix[float_frame.index[5], \"E\"]\n            assert is_integer(result)\n\n        result = float_frame.loc[float_frame.index[5], \"E\"]\n        assert is_integer(result)\n\n        # GH 11617\n        df = pd.DataFrame(dict(a=[1.23]))\n        df[\"b\"] = 666\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            result = df.ix[0, \"b\"]\n        assert is_integer(result)\n        result = df.loc[0, \"b\"]\n        assert is_integer(result)\n\n        expected = Series([666], [0], name=\"b\")\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            result = df.ix[[0], \"b\"]\n        assert_series_equal(result, expected)\n        result = df.loc[[0], \"b\"]\n        assert_series_equal(result, expected)",
        "begin_line": 1980,
        "end_line": 2009,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_iloc_row#2011",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_iloc_row(self)",
        "snippet": "    def test_iloc_row(self):\n        df = DataFrame(np.random.randn(10, 4), index=range(0, 20, 2))\n\n        result = df.iloc[1]\n        exp = df.loc[2]\n        assert_series_equal(result, exp)\n\n        result = df.iloc[2]\n        exp = df.loc[4]\n        assert_series_equal(result, exp)\n\n        # slice\n        result = df.iloc[slice(4, 8)]\n        expected = df.loc[8:14]\n        assert_frame_equal(result, expected)\n\n        # verify slice is view\n        # setting it makes it raise/warn\n        with pytest.raises(com.SettingWithCopyError):\n            result[2] = 0.0\n\n        exp_col = df[2].copy()\n        exp_col[4:8] = 0.0\n        assert_series_equal(df[2], exp_col)\n\n        # list of integers\n        result = df.iloc[[1, 2, 4, 6]]\n        expected = df.reindex(df.index[[1, 2, 4, 6]])\n        assert_frame_equal(result, expected)",
        "begin_line": 2011,
        "end_line": 2039,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_iloc_col#2041",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_iloc_col(self)",
        "snippet": "    def test_iloc_col(self):\n\n        df = DataFrame(np.random.randn(4, 10), columns=range(0, 20, 2))\n\n        result = df.iloc[:, 1]\n        exp = df.loc[:, 2]\n        assert_series_equal(result, exp)\n\n        result = df.iloc[:, 2]\n        exp = df.loc[:, 4]\n        assert_series_equal(result, exp)\n\n        # slice\n        result = df.iloc[:, slice(4, 8)]\n        expected = df.loc[:, 8:14]\n        assert_frame_equal(result, expected)\n\n        # verify slice is view\n        # and that we are setting a copy\n        with pytest.raises(com.SettingWithCopyError):\n            result[8] = 0.0\n\n        assert (df[8] == 0).all()\n\n        # list of integers\n        result = df.iloc[:, [1, 2, 4, 6]]\n        expected = df.reindex(columns=df.columns[[1, 2, 4, 6]])\n        assert_frame_equal(result, expected)",
        "begin_line": 2041,
        "end_line": 2068,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_iloc_duplicates#2070",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_iloc_duplicates(self)",
        "snippet": "    def test_iloc_duplicates(self):\n\n        df = DataFrame(np.random.rand(3, 3), columns=list(\"ABC\"), index=list(\"aab\"))\n\n        result = df.iloc[0]\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            result2 = df.ix[0]\n        assert isinstance(result, Series)\n        assert_almost_equal(result.values, df.values[0])\n        assert_series_equal(result, result2)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            result = df.T.iloc[:, 0]\n            result2 = df.T.ix[:, 0]\n        assert isinstance(result, Series)\n        assert_almost_equal(result.values, df.values[0])\n        assert_series_equal(result, result2)\n\n        # multiindex\n        df = DataFrame(\n            np.random.randn(3, 3),\n            columns=[[\"i\", \"i\", \"j\"], [\"A\", \"A\", \"B\"]],\n            index=[[\"i\", \"i\", \"j\"], [\"X\", \"X\", \"Y\"]],\n        )\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            rs = df.iloc[0]\n            xp = df.ix[0]\n        assert_series_equal(rs, xp)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            rs = df.iloc[:, 0]\n            xp = df.T.ix[0]\n        assert_series_equal(rs, xp)\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            rs = df.iloc[:, [0]]\n            xp = df.ix[:, [0]]\n        assert_frame_equal(rs, xp)\n\n        # #2259\n        df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=[1, 1, 2])\n        result = df.iloc[:, [0]]\n        expected = df.take([0], axis=1)\n        assert_frame_equal(result, expected)",
        "begin_line": 2070,
        "end_line": 2119,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_loc_duplicates#2121",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_loc_duplicates(self)",
        "snippet": "    def test_loc_duplicates(self):\n        # gh-17105\n\n        # insert a duplicate element to the index\n        trange = pd.date_range(\n            start=pd.Timestamp(year=2017, month=1, day=1),\n            end=pd.Timestamp(year=2017, month=1, day=5),\n        )\n\n        trange = trange.insert(loc=5, item=pd.Timestamp(year=2017, month=1, day=5))\n\n        df = pd.DataFrame(0, index=trange, columns=[\"A\", \"B\"])\n        bool_idx = np.array([False, False, False, False, False, True])\n\n        # assignment\n        df.loc[trange[bool_idx], \"A\"] = 6\n\n        expected = pd.DataFrame(\n            {\"A\": [0, 0, 0, 0, 6, 6], \"B\": [0, 0, 0, 0, 0, 0]}, index=trange\n        )\n        tm.assert_frame_equal(df, expected)\n\n        # in-place\n        df = pd.DataFrame(0, index=trange, columns=[\"A\", \"B\"])\n        df.loc[trange[bool_idx], \"A\"] += 6\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 2121,
        "end_line": 2146,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_iat#2148",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_iat(self, float_frame)",
        "snippet": "    def test_iat(self, float_frame):\n\n        for i, row in enumerate(float_frame.index):\n            for j, col in enumerate(float_frame.columns):\n                result = float_frame.iat[i, j]\n                expected = float_frame.at[row, col]\n                assert result == expected",
        "begin_line": 2148,
        "end_line": 2154,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_reindex_methods#2164",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_reindex_methods(self, method, expected_values)",
        "snippet": "    def test_reindex_methods(self, method, expected_values):\n        df = pd.DataFrame({\"x\": list(range(5))})\n        target = np.array([-0.1, 0.9, 1.1, 1.5])\n\n        expected = pd.DataFrame({\"x\": expected_values}, index=target)\n        actual = df.reindex(target, method=method)\n        assert_frame_equal(expected, actual)\n\n        actual = df.reindex_like(df, method=method, tolerance=0)\n        assert_frame_equal(df, actual)\n        actual = df.reindex_like(df, method=method, tolerance=[0, 0, 0, 0])\n        assert_frame_equal(df, actual)\n\n        actual = df.reindex(target, method=method, tolerance=1)\n        assert_frame_equal(expected, actual)\n        actual = df.reindex(target, method=method, tolerance=[1, 1, 1, 1])\n        assert_frame_equal(expected, actual)\n\n        e2 = expected[::-1]\n        actual = df.reindex(target[::-1], method=method)\n        assert_frame_equal(e2, actual)\n\n        new_order = [3, 0, 2, 1]\n        e2 = expected.iloc[new_order]\n        actual = df.reindex(target[new_order], method=method)\n        assert_frame_equal(e2, actual)\n\n        switched_method = (\n            \"pad\" if method == \"backfill\" else \"backfill\" if method == \"pad\" else method\n        )\n        actual = df[::-1].reindex(target, method=switched_method)\n        assert_frame_equal(expected, actual)",
        "begin_line": 2164,
        "end_line": 2195,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_reindex_methods_nearest_special#2197",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_reindex_methods_nearest_special(self)",
        "snippet": "    def test_reindex_methods_nearest_special(self):\n        df = pd.DataFrame({\"x\": list(range(5))})\n        target = np.array([-0.1, 0.9, 1.1, 1.5])\n\n        expected = pd.DataFrame({\"x\": [0, 1, 1, np.nan]}, index=target)\n        actual = df.reindex(target, method=\"nearest\", tolerance=0.2)\n        assert_frame_equal(expected, actual)\n\n        expected = pd.DataFrame({\"x\": [0, np.nan, 1, np.nan]}, index=target)\n        actual = df.reindex(target, method=\"nearest\", tolerance=[0.5, 0.01, 0.4, 0.1])\n        assert_frame_equal(expected, actual)",
        "begin_line": 2197,
        "end_line": 2207,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_reindex_frame_add_nat#2209",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_reindex_frame_add_nat(self)",
        "snippet": "    def test_reindex_frame_add_nat(self):\n        rng = date_range(\"1/1/2000 00:00:00\", periods=10, freq=\"10s\")\n        df = DataFrame({\"A\": np.random.randn(len(rng)), \"B\": rng})\n\n        result = df.reindex(range(15))\n        assert np.issubdtype(result[\"B\"].dtype, np.dtype(\"M8[ns]\"))\n\n        mask = com.isna(result)[\"B\"]\n        assert mask[-5:].all()\n        assert not mask[:-5].any()",
        "begin_line": 2209,
        "end_line": 2218,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_reindex_limit#2220",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_reindex_limit(self)",
        "snippet": "    def test_reindex_limit(self):\n        # GH 28631\n        data = [[\"A\", \"A\", \"A\"], [\"B\", \"B\", \"B\"], [\"C\", \"C\", \"C\"], [\"D\", \"D\", \"D\"]]\n        exp_data = [\n            [\"A\", \"A\", \"A\"],\n            [\"B\", \"B\", \"B\"],\n            [\"C\", \"C\", \"C\"],\n            [\"D\", \"D\", \"D\"],\n            [\"D\", \"D\", \"D\"],\n            [np.nan, np.nan, np.nan],\n        ]\n        df = DataFrame(data)\n        result = df.reindex([0, 1, 2, 3, 4, 5], method=\"ffill\", limit=1)\n        expected = DataFrame(exp_data)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2220,
        "end_line": 2234,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_set_dataframe_column_ns_dtype#2236",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_set_dataframe_column_ns_dtype(self)",
        "snippet": "    def test_set_dataframe_column_ns_dtype(self):\n        x = DataFrame([datetime.now(), datetime.now()])\n        assert x[0].dtype == np.dtype(\"M8[ns]\")",
        "begin_line": 2236,
        "end_line": 2238,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_non_monotonic_reindex_methods#2240",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_non_monotonic_reindex_methods(self)",
        "snippet": "    def test_non_monotonic_reindex_methods(self):\n        dr = pd.date_range(\"2013-08-01\", periods=6, freq=\"B\")\n        data = np.random.randn(6, 1)\n        df = pd.DataFrame(data, index=dr, columns=list(\"A\"))\n        df_rev = pd.DataFrame(data, index=dr[[3, 4, 5] + [0, 1, 2]], columns=list(\"A\"))\n        # index is not monotonic increasing or decreasing\n        msg = \"index must be monotonic increasing or decreasing\"\n        with pytest.raises(ValueError, match=msg):\n            df_rev.reindex(df.index, method=\"pad\")\n        with pytest.raises(ValueError, match=msg):\n            df_rev.reindex(df.index, method=\"ffill\")\n        with pytest.raises(ValueError, match=msg):\n            df_rev.reindex(df.index, method=\"bfill\")\n        with pytest.raises(ValueError, match=msg):\n            df_rev.reindex(df.index, method=\"nearest\")",
        "begin_line": 2240,
        "end_line": 2254,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_reindex_level#2256",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_reindex_level(self)",
        "snippet": "    def test_reindex_level(self):\n        from itertools import permutations\n\n        icol = [\"jim\", \"joe\", \"jolie\"]\n\n        def verify_first_level(df, level, idx, check_index_type=True):\n            def f(val):\n                return np.nonzero((df[level] == val).to_numpy())[0]\n\n            i = np.concatenate(list(map(f, idx)))\n            left = df.set_index(icol).reindex(idx, level=level)\n            right = df.iloc[i].set_index(icol)\n            assert_frame_equal(left, right, check_index_type=check_index_type)\n\n        def verify(df, level, idx, indexer, check_index_type=True):\n            left = df.set_index(icol).reindex(idx, level=level)\n            right = df.iloc[indexer].set_index(icol)\n            assert_frame_equal(left, right, check_index_type=check_index_type)\n\n        df = pd.DataFrame(\n            {\n                \"jim\": list(\"B\" * 4 + \"A\" * 2 + \"C\" * 3),\n                \"joe\": list(\"abcdeabcd\")[::-1],\n                \"jolie\": [10, 20, 30] * 3,\n                \"joline\": np.random.randint(0, 1000, 9),\n            }\n        )\n\n        target = [\n            [\"C\", \"B\", \"A\"],\n            [\"F\", \"C\", \"A\", \"D\"],\n            [\"A\"],\n            [\"A\", \"B\", \"C\"],\n            [\"C\", \"A\", \"B\"],\n            [\"C\", \"B\"],\n            [\"C\", \"A\"],\n            [\"A\", \"B\"],\n            [\"B\", \"A\", \"C\"],\n        ]\n\n        for idx in target:\n            verify_first_level(df, \"jim\", idx)\n\n        # reindex by these causes different MultiIndex levels\n        for idx in [[\"D\", \"F\"], [\"A\", \"C\", \"B\"]]:\n            verify_first_level(df, \"jim\", idx, check_index_type=False)\n\n        verify(df, \"joe\", list(\"abcde\"), [3, 2, 1, 0, 5, 4, 8, 7, 6])\n        verify(df, \"joe\", list(\"abcd\"), [3, 2, 1, 0, 5, 8, 7, 6])\n        verify(df, \"joe\", list(\"abc\"), [3, 2, 1, 8, 7, 6])\n        verify(df, \"joe\", list(\"eca\"), [1, 3, 4, 6, 8])\n        verify(df, \"joe\", list(\"edc\"), [0, 1, 4, 5, 6])\n        verify(df, \"joe\", list(\"eadbc\"), [3, 0, 2, 1, 4, 5, 8, 7, 6])\n        verify(df, \"joe\", list(\"edwq\"), [0, 4, 5])\n        verify(df, \"joe\", list(\"wq\"), [], check_index_type=False)\n\n        df = DataFrame(\n            {\n                \"jim\": [\"mid\"] * 5 + [\"btm\"] * 8 + [\"top\"] * 7,\n                \"joe\": [\"3rd\"] * 2\n                + [\"1st\"] * 3\n                + [\"2nd\"] * 3\n                + [\"1st\"] * 2\n                + [\"3rd\"] * 3\n                + [\"1st\"] * 2\n                + [\"3rd\"] * 3\n                + [\"2nd\"] * 2,\n                # this needs to be jointly unique with jim and joe or\n                # reindexing will fail ~1.5% of the time, this works\n                # out to needing unique groups of same size as joe\n                \"jolie\": np.concatenate(\n                    [\n                        np.random.choice(1000, x, replace=False)\n                        for x in [2, 3, 3, 2, 3, 2, 3, 2]\n                    ]\n                ),\n                \"joline\": np.random.randn(20).round(3) * 10,\n            }\n        )\n\n        for idx in permutations(df[\"jim\"].unique()):\n            for i in range(3):\n                verify_first_level(df, \"jim\", idx[: i + 1])\n\n        i = [2, 3, 4, 0, 1, 8, 9, 5, 6, 7, 10, 11, 12, 13, 14, 18, 19, 15, 16, 17]\n        verify(df, \"joe\", [\"1st\", \"2nd\", \"3rd\"], i)\n\n        i = [0, 1, 2, 3, 4, 10, 11, 12, 5, 6, 7, 8, 9, 15, 16, 17, 18, 19, 13, 14]\n        verify(df, \"joe\", [\"3rd\", \"2nd\", \"1st\"], i)\n\n        i = [0, 1, 5, 6, 7, 10, 11, 12, 18, 19, 15, 16, 17]\n        verify(df, \"joe\", [\"2nd\", \"3rd\"], i)\n\n        i = [0, 1, 2, 3, 4, 10, 11, 12, 8, 9, 15, 16, 17, 13, 14]\n        verify(df, \"joe\", [\"3rd\", \"1st\"], i)",
        "begin_line": 2256,
        "end_line": 2350,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.verify_first_level#2261",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.verify_first_level(df, level, idx, check_index_type=True)",
        "snippet": "        def verify_first_level(df, level, idx, check_index_type=True):\n            def f(val):\n                return np.nonzero((df[level] == val).to_numpy())[0]\n\n            i = np.concatenate(list(map(f, idx)))\n            left = df.set_index(icol).reindex(idx, level=level)\n            right = df.iloc[i].set_index(icol)\n            assert_frame_equal(left, right, check_index_type=check_index_type)",
        "begin_line": 2261,
        "end_line": 2268,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.f#2262",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.f(val)",
        "snippet": "            def f(val):\n                return np.nonzero((df[level] == val).to_numpy())[0]",
        "begin_line": 2262,
        "end_line": 2263,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.verify#2270",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.verify(df, level, idx, indexer, check_index_type=True)",
        "snippet": "        def verify(df, level, idx, indexer, check_index_type=True):\n            left = df.set_index(icol).reindex(idx, level=level)\n            right = df.iloc[indexer].set_index(icol)\n            assert_frame_equal(left, right, check_index_type=check_index_type)",
        "begin_line": 2270,
        "end_line": 2273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_ix_float_duplicates#2352",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_ix_float_duplicates(self)",
        "snippet": "    def test_getitem_ix_float_duplicates(self):\n        df = pd.DataFrame(\n            np.random.randn(3, 3), index=[0.1, 0.2, 0.2], columns=list(\"abc\")\n        )\n        expect = df.iloc[1:]\n        assert_frame_equal(df.loc[0.2], expect)\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            assert_frame_equal(df.ix[0.2], expect)\n\n        expect = df.iloc[1:, 0]\n        assert_series_equal(df.loc[0.2, \"a\"], expect)\n\n        df.index = [1, 0.2, 0.2]\n        expect = df.iloc[1:]\n        assert_frame_equal(df.loc[0.2], expect)\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            assert_frame_equal(df.ix[0.2], expect)\n\n        expect = df.iloc[1:, 0]\n        assert_series_equal(df.loc[0.2, \"a\"], expect)\n\n        df = pd.DataFrame(\n            np.random.randn(4, 3), index=[1, 0.2, 0.2, 1], columns=list(\"abc\")\n        )\n        expect = df.iloc[1:-1]\n        assert_frame_equal(df.loc[0.2], expect)\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            assert_frame_equal(df.ix[0.2], expect)\n\n        expect = df.iloc[1:-1, 0]\n        assert_series_equal(df.loc[0.2, \"a\"], expect)\n\n        df.index = [0.1, 0.2, 2, 0.2]\n        expect = df.iloc[[1, -1]]\n        assert_frame_equal(df.loc[0.2], expect)\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            assert_frame_equal(df.ix[0.2], expect)\n\n        expect = df.iloc[[1, -1], 0]\n        assert_series_equal(df.loc[0.2, \"a\"], expect)",
        "begin_line": 2352,
        "end_line": 2395,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_sparse_column#2397",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_getitem_sparse_column(self)",
        "snippet": "    def test_getitem_sparse_column(self):\n        # https://github.com/pandas-dev/pandas/issues/23559\n        data = pd.SparseArray([0, 1])\n        df = pd.DataFrame({\"A\": data})\n        expected = pd.Series(data, name=\"A\")\n        result = df[\"A\"]\n        tm.assert_series_equal(result, expected)\n\n        result = df.iloc[:, 0]\n        tm.assert_series_equal(result, expected)\n\n        result = df.loc[:, \"A\"]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 2397,
        "end_line": 2409,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_with_sparse_value#2411",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_with_sparse_value(self)",
        "snippet": "    def test_setitem_with_sparse_value(self):\n        # GH8131\n        df = pd.DataFrame({\"c_1\": [\"a\", \"b\", \"c\"], \"n_1\": [1.0, 2.0, 3.0]})\n        sp_array = pd.SparseArray([0, 0, 1])\n        df[\"new_column\"] = sp_array\n        assert_series_equal(\n            df[\"new_column\"], pd.Series(sp_array, name=\"new_column\"), check_names=False\n        )",
        "begin_line": 2411,
        "end_line": 2418,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_with_unaligned_sparse_value#2420",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_with_unaligned_sparse_value(self)",
        "snippet": "    def test_setitem_with_unaligned_sparse_value(self):\n        df = pd.DataFrame({\"c_1\": [\"a\", \"b\", \"c\"], \"n_1\": [1.0, 2.0, 3.0]})\n        sp_series = pd.Series(pd.SparseArray([0, 0, 1]), index=[2, 1, 0])\n        df[\"new_column\"] = sp_series\n        exp = pd.Series(pd.SparseArray([1, 0, 0]), name=\"new_column\")\n        assert_series_equal(df[\"new_column\"], exp)",
        "begin_line": 2420,
        "end_line": 2425,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_with_unaligned_tz_aware_datetime_column#2427",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_with_unaligned_tz_aware_datetime_column(self)",
        "snippet": "    def test_setitem_with_unaligned_tz_aware_datetime_column(self):\n        # GH 12981\n        # Assignment of unaligned offset-aware datetime series.\n        # Make sure timezone isn't lost\n        column = pd.Series(\n            pd.date_range(\"2015-01-01\", periods=3, tz=\"utc\"), name=\"dates\"\n        )\n        df = pd.DataFrame({\"dates\": column})\n        df[\"dates\"] = column[[1, 0, 2]]\n        assert_series_equal(df[\"dates\"], column)\n\n        df = pd.DataFrame({\"dates\": column})\n        df.loc[[0, 1, 2], \"dates\"] = column[[1, 0, 2]]\n        assert_series_equal(df[\"dates\"], column)",
        "begin_line": 2427,
        "end_line": 2440,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_datetime_coercion#2442",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_datetime_coercion(self)",
        "snippet": "    def test_setitem_datetime_coercion(self):\n        # gh-1048\n        df = pd.DataFrame({\"c\": [pd.Timestamp(\"2010-10-01\")] * 3})\n        df.loc[0:1, \"c\"] = np.datetime64(\"2008-08-08\")\n        assert pd.Timestamp(\"2008-08-08\") == df.loc[0, \"c\"]\n        assert pd.Timestamp(\"2008-08-08\") == df.loc[1, \"c\"]\n        df.loc[2, \"c\"] = date(2005, 5, 5)\n        assert pd.Timestamp(\"2005-05-05\") == df.loc[2, \"c\"]",
        "begin_line": 2442,
        "end_line": 2449,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_datetimelike_with_inference#2451",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_datetimelike_with_inference(self)",
        "snippet": "    def test_setitem_datetimelike_with_inference(self):\n        # GH 7592\n        # assignment of timedeltas with NaT\n\n        one_hour = timedelta(hours=1)\n        df = DataFrame(index=date_range(\"20130101\", periods=4))\n        df[\"A\"] = np.array([1 * one_hour] * 4, dtype=\"m8[ns]\")\n        df.loc[:, \"B\"] = np.array([2 * one_hour] * 4, dtype=\"m8[ns]\")\n        df.loc[:3, \"C\"] = np.array([3 * one_hour] * 3, dtype=\"m8[ns]\")\n        df.loc[:, \"D\"] = np.array([4 * one_hour] * 4, dtype=\"m8[ns]\")\n        df.loc[df.index[:3], \"E\"] = np.array([5 * one_hour] * 3, dtype=\"m8[ns]\")\n        df[\"F\"] = np.timedelta64(\"NaT\")\n        df.loc[df.index[:-1], \"F\"] = np.array([6 * one_hour] * 3, dtype=\"m8[ns]\")\n        df.loc[df.index[-3] :, \"G\"] = date_range(\"20130101\", periods=3)\n        df[\"H\"] = np.datetime64(\"NaT\")\n        result = df.dtypes\n        expected = Series(\n            [np.dtype(\"timedelta64[ns]\")] * 6 + [np.dtype(\"datetime64[ns]\")] * 2,\n            index=list(\"ABCDEFGH\"),\n        )\n        assert_series_equal(result, expected)",
        "begin_line": 2451,
        "end_line": 2471,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_datetimeindex_tz#2474",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_setitem_datetimeindex_tz(self, idxer, tz_naive_fixture)",
        "snippet": "    def test_setitem_datetimeindex_tz(self, idxer, tz_naive_fixture):\n        # GH 11365\n        tz = tz_naive_fixture\n        idx = date_range(start=\"2015-07-12\", periods=3, freq=\"H\", tz=tz)\n        expected = DataFrame(1.2, index=idx, columns=[\"var\"])\n        result = DataFrame(index=idx, columns=[\"var\"])\n        result.loc[:, idxer] = expected\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2474,
        "end_line": 2481,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_at_time_between_time_datetimeindex#2483",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_at_time_between_time_datetimeindex(self)",
        "snippet": "    def test_at_time_between_time_datetimeindex(self):\n        index = date_range(\"2012-01-01\", \"2012-01-05\", freq=\"30min\")\n        df = DataFrame(np.random.randn(len(index), 5), index=index)\n        akey = time(12, 0, 0)\n        bkey = slice(time(13, 0, 0), time(14, 0, 0))\n        ainds = [24, 72, 120, 168]\n        binds = [26, 27, 28, 74, 75, 76, 122, 123, 124, 170, 171, 172]\n\n        result = df.at_time(akey)\n        expected = df.loc[akey]\n        expected2 = df.iloc[ainds]\n        assert_frame_equal(result, expected)\n        assert_frame_equal(result, expected2)\n        assert len(result) == 4\n\n        result = df.between_time(bkey.start, bkey.stop)\n        expected = df.loc[bkey]\n        expected2 = df.iloc[binds]\n        assert_frame_equal(result, expected)\n        assert_frame_equal(result, expected2)\n        assert len(result) == 12\n\n        result = df.copy()\n        result.loc[akey] = 0\n        result = result.loc[akey]\n        expected = df.loc[akey].copy()\n        expected.loc[:] = 0\n        assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.loc[akey] = 0\n        result.loc[akey] = df.iloc[ainds]\n        assert_frame_equal(result, df)\n\n        result = df.copy()\n        result.loc[bkey] = 0\n        result = result.loc[bkey]\n        expected = df.loc[bkey].copy()\n        expected.loc[:] = 0\n        assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.loc[bkey] = 0\n        result.loc[bkey] = df.iloc[binds]\n        assert_frame_equal(result, df)",
        "begin_line": 2483,
        "end_line": 2527,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_xs#2529",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_xs(self, float_frame, datetime_frame)",
        "snippet": "    def test_xs(self, float_frame, datetime_frame):\n        idx = float_frame.index[5]\n        xs = float_frame.xs(idx)\n        for item, value in xs.items():\n            if np.isnan(value):\n                assert np.isnan(float_frame[item][idx])\n            else:\n                assert value == float_frame[item][idx]\n\n        # mixed-type xs\n        test_data = {\"A\": {\"1\": 1, \"2\": 2}, \"B\": {\"1\": \"1\", \"2\": \"2\", \"3\": \"3\"}}\n        frame = DataFrame(test_data)\n        xs = frame.xs(\"1\")\n        assert xs.dtype == np.object_\n        assert xs[\"A\"] == 1\n        assert xs[\"B\"] == \"1\"\n\n        with pytest.raises(\n            KeyError, match=re.escape(\"Timestamp('1999-12-31 00:00:00', freq='B')\")\n        ):\n            datetime_frame.xs(datetime_frame.index[0] - BDay())\n\n        # xs get column\n        series = float_frame.xs(\"A\", axis=1)\n        expected = float_frame[\"A\"]\n        assert_series_equal(series, expected)\n\n        # view is returned if possible\n        series = float_frame.xs(\"A\", axis=1)\n        series[:] = 5\n        assert (expected == 5).all()",
        "begin_line": 2529,
        "end_line": 2559,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_xs_corner#2561",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_xs_corner(self)",
        "snippet": "    def test_xs_corner(self):\n        # pathological mixed-type reordering case\n        df = DataFrame(index=[0])\n        df[\"A\"] = 1.0\n        df[\"B\"] = \"foo\"\n        df[\"C\"] = 2.0\n        df[\"D\"] = \"bar\"\n        df[\"E\"] = 3.0\n\n        xs = df.xs(0)\n        exp = pd.Series([1.0, \"foo\", 2.0, \"bar\", 3.0], index=list(\"ABCDE\"), name=0)\n        tm.assert_series_equal(xs, exp)\n\n        # no columns but Index(dtype=object)\n        df = DataFrame(index=[\"a\", \"b\", \"c\"])\n        result = df.xs(\"a\")\n        expected = Series([], name=\"a\", index=pd.Index([], dtype=object))\n        assert_series_equal(result, expected)",
        "begin_line": 2561,
        "end_line": 2578,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_xs_duplicates#2580",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_xs_duplicates(self)",
        "snippet": "    def test_xs_duplicates(self):\n        df = DataFrame(np.random.randn(5, 2), index=[\"b\", \"b\", \"c\", \"b\", \"a\"])\n\n        cross = df.xs(\"c\")\n        exp = df.iloc[2]\n        assert_series_equal(cross, exp)",
        "begin_line": 2580,
        "end_line": 2585,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_xs_keep_level#2587",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_xs_keep_level(self)",
        "snippet": "    def test_xs_keep_level(self):\n        df = DataFrame(\n            {\n                \"day\": {0: \"sat\", 1: \"sun\"},\n                \"flavour\": {0: \"strawberry\", 1: \"strawberry\"},\n                \"sales\": {0: 10, 1: 12},\n                \"year\": {0: 2008, 1: 2008},\n            }\n        ).set_index([\"year\", \"flavour\", \"day\"])\n        result = df.xs(\"sat\", level=\"day\", drop_level=False)\n        expected = df[:1]\n        assert_frame_equal(result, expected)\n\n        result = df.xs([2008, \"sat\"], level=[\"year\", \"day\"], drop_level=False)\n        assert_frame_equal(result, expected)",
        "begin_line": 2587,
        "end_line": 2601,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_xs_view#2603",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_xs_view(self)",
        "snippet": "    def test_xs_view(self):\n        # in 0.14 this will return a view if possible a copy otherwise, but\n        # this is numpy dependent\n\n        dm = DataFrame(np.arange(20.0).reshape(4, 5), index=range(4), columns=range(5))\n\n        dm.xs(2)[:] = 10\n        assert (dm.xs(2) == 10).all()",
        "begin_line": 2603,
        "end_line": 2610,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_index_namedtuple#2612",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_index_namedtuple(self)",
        "snippet": "    def test_index_namedtuple(self):\n        from collections import namedtuple\n\n        IndexType = namedtuple(\"IndexType\", [\"a\", \"b\"])\n        idx1 = IndexType(\"foo\", \"bar\")\n        idx2 = IndexType(\"baz\", \"bof\")\n        index = Index([idx1, idx2], name=\"composite_index\", tupleize_cols=False)\n        df = DataFrame([(1, 2), (3, 4)], index=index, columns=[\"A\", \"B\"])\n\n        with catch_warnings(record=True):\n            simplefilter(\"ignore\", FutureWarning)\n            result = df.ix[IndexType(\"foo\", \"bar\")][\"A\"]\n        assert result == 1\n\n        result = df.loc[IndexType(\"foo\", \"bar\")][\"A\"]\n        assert result == 1",
        "begin_line": 2612,
        "end_line": 2627,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_boolean_indexing#2629",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_boolean_indexing(self)",
        "snippet": "    def test_boolean_indexing(self):\n        idx = list(range(3))\n        cols = [\"A\", \"B\", \"C\"]\n        df1 = DataFrame(\n            index=idx,\n            columns=cols,\n            data=np.array(\n                [[0.0, 0.5, 1.0], [1.5, 2.0, 2.5], [3.0, 3.5, 4.0]], dtype=float\n            ),\n        )\n        df2 = DataFrame(index=idx, columns=cols, data=np.ones((len(idx), len(cols))))\n\n        expected = DataFrame(\n            index=idx,\n            columns=cols,\n            data=np.array([[0.0, 0.5, 1.0], [1.5, 2.0, -1], [-1, -1, -1]], dtype=float),\n        )\n\n        df1[df1 > 2.0 * df2] = -1\n        assert_frame_equal(df1, expected)\n        with pytest.raises(ValueError, match=\"Item wrong length\"):\n            df1[df1.index[:-1] > 2] = -1",
        "begin_line": 2629,
        "end_line": 2650,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_boolean_indexing_mixed#2652",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_boolean_indexing_mixed(self)",
        "snippet": "    def test_boolean_indexing_mixed(self):\n        df = DataFrame(\n            {\n                0: {35: np.nan, 40: np.nan, 43: np.nan, 49: np.nan, 50: np.nan},\n                1: {\n                    35: np.nan,\n                    40: 0.32632316859446198,\n                    43: np.nan,\n                    49: 0.32632316859446198,\n                    50: 0.39114724480578139,\n                },\n                2: {\n                    35: np.nan,\n                    40: np.nan,\n                    43: 0.29012581014105987,\n                    49: np.nan,\n                    50: np.nan,\n                },\n                3: {35: np.nan, 40: np.nan, 43: np.nan, 49: np.nan, 50: np.nan},\n                4: {\n                    35: 0.34215328467153283,\n                    40: np.nan,\n                    43: np.nan,\n                    49: np.nan,\n                    50: np.nan,\n                },\n                \"y\": {35: 0, 40: 0, 43: 0, 49: 0, 50: 1},\n            }\n        )\n\n        # mixed int/float ok\n        df2 = df.copy()\n        df2[df2 > 0.3] = 1\n        expected = df.copy()\n        expected.loc[40, 1] = 1\n        expected.loc[49, 1] = 1\n        expected.loc[50, 1] = 1\n        expected.loc[35, 4] = 1\n        assert_frame_equal(df2, expected)\n\n        df[\"foo\"] = \"test\"\n        msg = \"not supported between instances|unorderable types\"\n\n        with pytest.raises(TypeError, match=msg):\n            df[df > 0.3] = 1",
        "begin_line": 2652,
        "end_line": 2696,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where#2698",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where(self, float_string_frame, mixed_float_frame, mixed_int_frame)",
        "snippet": "    def test_where(self, float_string_frame, mixed_float_frame, mixed_int_frame):\n        default_frame = DataFrame(np.random.randn(5, 3), columns=[\"A\", \"B\", \"C\"])\n\n        def _safe_add(df):\n            # only add to the numeric items\n            def is_ok(s):\n                return (\n                    issubclass(s.dtype.type, (np.integer, np.floating))\n                    and s.dtype != \"uint8\"\n                )\n\n            return DataFrame(\n                dict((c, s + 1) if is_ok(s) else (c, s) for c, s in df.items())\n            )\n\n        def _check_get(df, cond, check_dtypes=True):\n            other1 = _safe_add(df)\n            rs = df.where(cond, other1)\n            rs2 = df.where(cond.values, other1)\n            for k, v in rs.items():\n                exp = Series(np.where(cond[k], df[k], other1[k]), index=v.index)\n                assert_series_equal(v, exp, check_names=False)\n            assert_frame_equal(rs, rs2)\n\n            # dtypes\n            if check_dtypes:\n                assert (rs.dtypes == df.dtypes).all()\n\n        # check getting\n        for df in [\n            default_frame,\n            float_string_frame,\n            mixed_float_frame,\n            mixed_int_frame,\n        ]:\n            if df is float_string_frame:\n                with pytest.raises(TypeError):\n                    df > 0\n                continue\n            cond = df > 0\n            _check_get(df, cond)\n\n        # upcasting case (GH # 2794)\n        df = DataFrame(\n            {\n                c: Series([1] * 3, dtype=c)\n                for c in [\"float32\", \"float64\", \"int32\", \"int64\"]\n            }\n        )\n        df.iloc[1, :] = 0\n        result = df.dtypes\n        expected = Series(\n            [\n                np.dtype(\"float32\"),\n                np.dtype(\"float64\"),\n                np.dtype(\"int32\"),\n                np.dtype(\"int64\"),\n            ],\n            index=[\"float32\", \"float64\", \"int32\", \"int64\"],\n        )\n\n        # when we don't preserve boolean casts\n        #\n        # expected = Series({ 'float32' : 1, 'float64' : 3 })\n\n        assert_series_equal(result, expected)\n\n        # aligning\n        def _check_align(df, cond, other, check_dtypes=True):\n            rs = df.where(cond, other)\n            for i, k in enumerate(rs.columns):\n                result = rs[k]\n                d = df[k].values\n                c = cond[k].reindex(df[k].index).fillna(False).values\n\n                if is_scalar(other):\n                    o = other\n                else:\n                    if isinstance(other, np.ndarray):\n                        o = Series(other[:, i], index=result.index).values\n                    else:\n                        o = other[k].values\n\n                new_values = d if c.all() else np.where(c, d, o)\n                expected = Series(new_values, index=result.index, name=k)\n\n                # since we can't always have the correct numpy dtype\n                # as numpy doesn't know how to downcast, don't check\n                assert_series_equal(result, expected, check_dtype=False)\n\n            # dtypes\n            # can't check dtype when other is an ndarray\n\n            if check_dtypes and not isinstance(other, np.ndarray):\n                assert (rs.dtypes == df.dtypes).all()\n\n        for df in [float_string_frame, mixed_float_frame, mixed_int_frame]:\n            if df is float_string_frame:\n                with pytest.raises(TypeError):\n                    df > 0\n                continue\n\n            # other is a frame\n            cond = (df > 0)[1:]\n            _check_align(df, cond, _safe_add(df))\n\n            # check other is ndarray\n            cond = df > 0\n            _check_align(df, cond, (_safe_add(df).values))\n\n            # integers are upcast, so don't check the dtypes\n            cond = df > 0\n            check_dtypes = all(not issubclass(s.type, np.integer) for s in df.dtypes)\n            _check_align(df, cond, np.nan, check_dtypes=check_dtypes)\n\n        # invalid conditions\n        df = default_frame\n        err1 = (df + 1).values[0:2, :]\n        msg = \"other must be the same shape as self when an ndarray\"\n        with pytest.raises(ValueError, match=msg):\n            df.where(cond, err1)\n\n        err2 = cond.iloc[:2, :].values\n        other1 = _safe_add(df)\n        msg = \"Array conditional must be same shape as self\"\n        with pytest.raises(ValueError, match=msg):\n            df.where(err2, other1)\n\n        with pytest.raises(ValueError, match=msg):\n            df.mask(True)\n        with pytest.raises(ValueError, match=msg):\n            df.mask(0)\n\n        # where inplace\n        def _check_set(df, cond, check_dtypes=True):\n            dfi = df.copy()\n            econd = cond.reindex_like(df).fillna(True)\n            expected = dfi.mask(~econd)\n\n            dfi.where(cond, np.nan, inplace=True)\n            assert_frame_equal(dfi, expected)\n\n            # dtypes (and confirm upcasts)x\n            if check_dtypes:\n                for k, v in df.dtypes.items():\n                    if issubclass(v.type, np.integer) and not cond[k].all():\n                        v = np.dtype(\"float64\")\n                    assert dfi[k].dtype == v\n\n        for df in [\n            default_frame,\n            float_string_frame,\n            mixed_float_frame,\n            mixed_int_frame,\n        ]:\n            if df is float_string_frame:\n                with pytest.raises(TypeError):\n                    df > 0\n                continue\n\n            cond = df > 0\n            _check_set(df, cond)\n\n            cond = df >= 0\n            _check_set(df, cond)\n\n            # aligning\n            cond = (df >= 0)[1:]\n            _check_set(df, cond)\n\n        # GH 10218\n        # test DataFrame.where with Series slicing\n        df = DataFrame({\"a\": range(3), \"b\": range(4, 7)})\n        result = df.where(df[\"a\"] == 1)\n        expected = df[df[\"a\"] == 1].reindex(df.index)\n        assert_frame_equal(result, expected)",
        "begin_line": 2698,
        "end_line": 2873,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing._safe_add#2701",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing._safe_add(df)",
        "snippet": "        def _safe_add(df):\n            # only add to the numeric items\n            def is_ok(s):\n                return (\n                    issubclass(s.dtype.type, (np.integer, np.floating))\n                    and s.dtype != \"uint8\"\n                )\n\n            return DataFrame(\n                dict((c, s + 1) if is_ok(s) else (c, s) for c, s in df.items())\n            )",
        "begin_line": 2701,
        "end_line": 2711,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.is_ok#2703",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.is_ok(s)",
        "snippet": "            def is_ok(s):\n                return (\n                    issubclass(s.dtype.type, (np.integer, np.floating))\n                    and s.dtype != \"uint8\"\n                )",
        "begin_line": 2703,
        "end_line": 2707,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing._check_get#2713",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing._check_get(df, cond, check_dtypes=True)",
        "snippet": "        def _check_get(df, cond, check_dtypes=True):\n            other1 = _safe_add(df)\n            rs = df.where(cond, other1)\n            rs2 = df.where(cond.values, other1)\n            for k, v in rs.items():\n                exp = Series(np.where(cond[k], df[k], other1[k]), index=v.index)\n                assert_series_equal(v, exp, check_names=False)\n            assert_frame_equal(rs, rs2)\n\n            # dtypes\n            if check_dtypes:\n                assert (rs.dtypes == df.dtypes).all()",
        "begin_line": 2713,
        "end_line": 2724,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing._check_align#2766",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing._check_align(df, cond, other, check_dtypes=True)",
        "snippet": "        def _check_align(df, cond, other, check_dtypes=True):\n            rs = df.where(cond, other)\n            for i, k in enumerate(rs.columns):\n                result = rs[k]\n                d = df[k].values\n                c = cond[k].reindex(df[k].index).fillna(False).values\n\n                if is_scalar(other):\n                    o = other\n                else:\n                    if isinstance(other, np.ndarray):\n                        o = Series(other[:, i], index=result.index).values\n                    else:\n                        o = other[k].values\n\n                new_values = d if c.all() else np.where(c, d, o)\n                expected = Series(new_values, index=result.index, name=k)\n\n                # since we can't always have the correct numpy dtype\n                # as numpy doesn't know how to downcast, don't check\n                assert_series_equal(result, expected, check_dtype=False)\n\n            # dtypes\n            # can't check dtype when other is an ndarray\n\n            if check_dtypes and not isinstance(other, np.ndarray):\n                assert (rs.dtypes == df.dtypes).all()",
        "begin_line": 2766,
        "end_line": 2792,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing._check_set#2832",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing._check_set(df, cond, check_dtypes=True)",
        "snippet": "        def _check_set(df, cond, check_dtypes=True):\n            dfi = df.copy()\n            econd = cond.reindex_like(df).fillna(True)\n            expected = dfi.mask(~econd)\n\n            dfi.where(cond, np.nan, inplace=True)\n            assert_frame_equal(dfi, expected)\n\n            # dtypes (and confirm upcasts)x\n            if check_dtypes:\n                for k, v in df.dtypes.items():\n                    if issubclass(v.type, np.integer) and not cond[k].all():\n                        v = np.dtype(\"float64\")\n                    assert dfi[k].dtype == v",
        "begin_line": 2832,
        "end_line": 2845,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_array_like#2876",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_array_like(self, klass)",
        "snippet": "    def test_where_array_like(self, klass):\n        # see gh-15414\n        df = DataFrame({\"a\": [1, 2, 3]})\n        cond = [[False], [True], [True]]\n        expected = DataFrame({\"a\": [np.nan, 2, 3]})\n\n        result = df.where(klass(cond))\n        assert_frame_equal(result, expected)\n\n        df[\"b\"] = 2\n        expected[\"b\"] = [2, np.nan, 2]\n        cond = [[False, True], [True, False], [True, True]]\n\n        result = df.where(klass(cond))\n        assert_frame_equal(result, expected)",
        "begin_line": 2876,
        "end_line": 2890,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_invalid_input_single#2902",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_invalid_input_single(self, cond)",
        "snippet": "    def test_where_invalid_input_single(self, cond):\n        # see gh-15414: only boolean arrays accepted\n        df = DataFrame({\"a\": [1, 2, 3]})\n        msg = \"Boolean array expected for the condition\"\n\n        with pytest.raises(ValueError, match=msg):\n            df.where(cond)",
        "begin_line": 2902,
        "end_line": 2908,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_invalid_input_multiple#2924",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_invalid_input_multiple(self, cond)",
        "snippet": "    def test_where_invalid_input_multiple(self, cond):\n        # see gh-15414: only boolean arrays accepted\n        df = DataFrame({\"a\": [1, 2, 3], \"b\": [2, 2, 2]})\n        msg = \"Boolean array expected for the condition\"\n\n        with pytest.raises(ValueError, match=msg):\n            df.where(cond)",
        "begin_line": 2924,
        "end_line": 2930,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_dataframe_col_match#2932",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_dataframe_col_match(self)",
        "snippet": "    def test_where_dataframe_col_match(self):\n        df = DataFrame([[1, 2, 3], [4, 5, 6]])\n        cond = DataFrame([[True, False, True], [False, False, True]])\n\n        result = df.where(cond)\n        expected = DataFrame([[1.0, np.nan, 3], [np.nan, np.nan, 6]])\n        tm.assert_frame_equal(result, expected)\n\n        # this *does* align, though has no matching columns\n        cond.columns = [\"a\", \"b\", \"c\"]\n        result = df.where(cond)\n        expected = DataFrame(np.nan, index=df.index, columns=df.columns)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 2932,
        "end_line": 2944,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_ndframe_align#2946",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_ndframe_align(self)",
        "snippet": "    def test_where_ndframe_align(self):\n        msg = \"Array conditional must be same shape as self\"\n        df = DataFrame([[1, 2, 3], [4, 5, 6]])\n\n        cond = [True]\n        with pytest.raises(ValueError, match=msg):\n            df.where(cond)\n\n        expected = DataFrame([[1, 2, 3], [np.nan, np.nan, np.nan]])\n\n        out = df.where(Series(cond))\n        tm.assert_frame_equal(out, expected)\n\n        cond = np.array([False, True, False, True])\n        with pytest.raises(ValueError, match=msg):\n            df.where(cond)\n\n        expected = DataFrame([[np.nan, np.nan, np.nan], [4, 5, 6]])\n\n        out = df.where(Series(cond))\n        tm.assert_frame_equal(out, expected)",
        "begin_line": 2946,
        "end_line": 2966,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_bug#2968",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_bug(self)",
        "snippet": "    def test_where_bug(self):\n        # see gh-2793\n        df = DataFrame(\n            {\"a\": [1.0, 2.0, 3.0, 4.0], \"b\": [4.0, 3.0, 2.0, 1.0]}, dtype=\"float64\"\n        )\n        expected = DataFrame(\n            {\"a\": [np.nan, np.nan, 3.0, 4.0], \"b\": [4.0, 3.0, np.nan, np.nan]},\n            dtype=\"float64\",\n        )\n        result = df.where(df > 2, np.nan)\n        assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.where(result > 2, np.nan, inplace=True)\n        assert_frame_equal(result, expected)",
        "begin_line": 2968,
        "end_line": 2982,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_bug_mixed#2984",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_bug_mixed(self, sint_dtype)",
        "snippet": "    def test_where_bug_mixed(self, sint_dtype):\n        # see gh-2793\n        df = DataFrame(\n            {\n                \"a\": np.array([1, 2, 3, 4], dtype=sint_dtype),\n                \"b\": np.array([4.0, 3.0, 2.0, 1.0], dtype=\"float64\"),\n            }\n        )\n\n        expected = DataFrame(\n            {\"a\": [np.nan, np.nan, 3.0, 4.0], \"b\": [4.0, 3.0, np.nan, np.nan]},\n            dtype=\"float64\",\n        )\n\n        result = df.where(df > 2, np.nan)\n        assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.where(result > 2, np.nan, inplace=True)\n        assert_frame_equal(result, expected)",
        "begin_line": 2984,
        "end_line": 3003,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_bug_transposition#3005",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_bug_transposition(self)",
        "snippet": "    def test_where_bug_transposition(self):\n        # see gh-7506\n        a = DataFrame({0: [1, 2], 1: [3, 4], 2: [5, 6]})\n        b = DataFrame({0: [np.nan, 8], 1: [9, np.nan], 2: [np.nan, np.nan]})\n        do_not_replace = b.isna() | (a > b)\n\n        expected = a.copy()\n        expected[~do_not_replace] = b\n\n        result = a.where(do_not_replace, b)\n        assert_frame_equal(result, expected)\n\n        a = DataFrame({0: [4, 6], 1: [1, 0]})\n        b = DataFrame({0: [np.nan, 3], 1: [3, np.nan]})\n        do_not_replace = b.isna() | (a > b)\n\n        expected = a.copy()\n        expected[~do_not_replace] = b\n\n        result = a.where(do_not_replace, b)\n        assert_frame_equal(result, expected)",
        "begin_line": 3005,
        "end_line": 3025,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_datetime#3027",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_datetime(self)",
        "snippet": "    def test_where_datetime(self):\n\n        # GH 3311\n        df = DataFrame(\n            dict(\n                A=date_range(\"20130102\", periods=5),\n                B=date_range(\"20130104\", periods=5),\n                C=np.random.randn(5),\n            )\n        )\n\n        stamp = datetime(2013, 1, 3)\n        with pytest.raises(TypeError):\n            df > stamp\n\n        result = df[df.iloc[:, :-1] > stamp]\n\n        expected = df.copy()\n        expected.loc[[0, 1], \"A\"] = np.nan\n        expected.loc[:, \"C\"] = np.nan\n        assert_frame_equal(result, expected)",
        "begin_line": 3027,
        "end_line": 3047,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_none#3049",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_none(self)",
        "snippet": "    def test_where_none(self):\n        # GH 4667\n        # setting with None changes dtype\n        df = DataFrame({\"series\": Series(range(10))}).astype(float)\n        df[df > 7] = None\n        expected = DataFrame(\n            {\"series\": Series([0, 1, 2, 3, 4, 5, 6, 7, np.nan, np.nan])}\n        )\n        assert_frame_equal(df, expected)\n\n        # GH 7656\n        df = DataFrame(\n            [\n                {\"A\": 1, \"B\": np.nan, \"C\": \"Test\"},\n                {\"A\": np.nan, \"B\": \"Test\", \"C\": np.nan},\n            ]\n        )\n        msg = \"boolean setting on mixed-type\"\n\n        with pytest.raises(TypeError, match=msg):\n            df.where(~isna(df), None, inplace=True)",
        "begin_line": 3049,
        "end_line": 3069,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_empty_df_and_empty_cond_having_non_bool_dtypes#3071",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_empty_df_and_empty_cond_having_non_bool_dtypes(self)",
        "snippet": "    def test_where_empty_df_and_empty_cond_having_non_bool_dtypes(self):\n        # see gh-21947\n        df = pd.DataFrame(columns=[\"a\"])\n        cond = df.applymap(lambda x: x > 0)\n\n        result = df.where(cond)\n        tm.assert_frame_equal(result, df)",
        "begin_line": 3071,
        "end_line": 3077,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_align#3079",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_align(self)",
        "snippet": "    def test_where_align(self):\n        def create():\n            df = DataFrame(np.random.randn(10, 3))\n            df.iloc[3:5, 0] = np.nan\n            df.iloc[4:6, 1] = np.nan\n            df.iloc[5:8, 2] = np.nan\n            return df\n\n        # series\n        df = create()\n        expected = df.fillna(df.mean())\n        result = df.where(pd.notna(df), df.mean(), axis=\"columns\")\n        assert_frame_equal(result, expected)\n\n        df.where(pd.notna(df), df.mean(), inplace=True, axis=\"columns\")\n        assert_frame_equal(df, expected)\n\n        df = create().fillna(0)\n        expected = df.apply(lambda x, y: x.where(x > 0, y), y=df[0])\n        result = df.where(df > 0, df[0], axis=\"index\")\n        assert_frame_equal(result, expected)\n        result = df.where(df > 0, df[0], axis=\"rows\")\n        assert_frame_equal(result, expected)\n\n        # frame\n        df = create()\n        expected = df.fillna(1)\n        result = df.where(\n            pd.notna(df), DataFrame(1, index=df.index, columns=df.columns)\n        )\n        assert_frame_equal(result, expected)",
        "begin_line": 3079,
        "end_line": 3109,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.create#3080",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.create()",
        "snippet": "        def create():\n            df = DataFrame(np.random.randn(10, 3))\n            df.iloc[3:5, 0] = np.nan\n            df.iloc[4:6, 1] = np.nan\n            df.iloc[5:8, 2] = np.nan\n            return df",
        "begin_line": 3080,
        "end_line": 3085,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_complex#3111",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_complex(self)",
        "snippet": "    def test_where_complex(self):\n        # GH 6345\n        expected = DataFrame([[1 + 1j, 2], [np.nan, 4 + 1j]], columns=[\"a\", \"b\"])\n        df = DataFrame([[1 + 1j, 2], [5 + 1j, 4 + 1j]], columns=[\"a\", \"b\"])\n        df[df.abs() >= 5] = np.nan\n        assert_frame_equal(df, expected)",
        "begin_line": 3111,
        "end_line": 3116,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_axis#3118",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_axis(self)",
        "snippet": "    def test_where_axis(self):\n        # GH 9736\n        df = DataFrame(np.random.randn(2, 2))\n        mask = DataFrame([[False, False], [False, False]])\n        s = Series([0, 1])\n\n        expected = DataFrame([[0, 0], [1, 1]], dtype=\"float64\")\n        result = df.where(mask, s, axis=\"index\")\n        assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.where(mask, s, axis=\"index\", inplace=True)\n        assert_frame_equal(result, expected)\n\n        expected = DataFrame([[0, 1], [0, 1]], dtype=\"float64\")\n        result = df.where(mask, s, axis=\"columns\")\n        assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.where(mask, s, axis=\"columns\", inplace=True)\n        assert_frame_equal(result, expected)\n\n        # Upcast needed\n        df = DataFrame([[1, 2], [3, 4]], dtype=\"int64\")\n        mask = DataFrame([[False, False], [False, False]])\n        s = Series([0, np.nan])\n\n        expected = DataFrame([[0, 0], [np.nan, np.nan]], dtype=\"float64\")\n        result = df.where(mask, s, axis=\"index\")\n        assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.where(mask, s, axis=\"index\", inplace=True)\n        assert_frame_equal(result, expected)\n\n        expected = DataFrame([[0, np.nan], [0, np.nan]])\n        result = df.where(mask, s, axis=\"columns\")\n        assert_frame_equal(result, expected)\n\n        expected = DataFrame(\n            {\n                0: np.array([0, 0], dtype=\"int64\"),\n                1: np.array([np.nan, np.nan], dtype=\"float64\"),\n            }\n        )\n        result = df.copy()\n        result.where(mask, s, axis=\"columns\", inplace=True)\n        assert_frame_equal(result, expected)\n\n        # Multiple dtypes (=> multiple Blocks)\n        df = pd.concat(\n            [\n                DataFrame(np.random.randn(10, 2)),\n                DataFrame(np.random.randint(0, 10, size=(10, 2)), dtype=\"int64\"),\n            ],\n            ignore_index=True,\n            axis=1,\n        )\n        mask = DataFrame(False, columns=df.columns, index=df.index)\n        s1 = Series(1, index=df.columns)\n        s2 = Series(2, index=df.index)\n\n        result = df.where(mask, s1, axis=\"columns\")\n        expected = DataFrame(1.0, columns=df.columns, index=df.index)\n        expected[2] = expected[2].astype(\"int64\")\n        expected[3] = expected[3].astype(\"int64\")\n        assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.where(mask, s1, axis=\"columns\", inplace=True)\n        assert_frame_equal(result, expected)\n\n        result = df.where(mask, s2, axis=\"index\")\n        expected = DataFrame(2.0, columns=df.columns, index=df.index)\n        expected[2] = expected[2].astype(\"int64\")\n        expected[3] = expected[3].astype(\"int64\")\n        assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.where(mask, s2, axis=\"index\", inplace=True)\n        assert_frame_equal(result, expected)\n\n        # DataFrame vs DataFrame\n        d1 = df.copy().drop(1, axis=0)\n        expected = df.copy()\n        expected.loc[1, :] = np.nan\n\n        result = df.where(mask, d1)\n        assert_frame_equal(result, expected)\n        result = df.where(mask, d1, axis=\"index\")\n        assert_frame_equal(result, expected)\n        result = df.copy()\n        result.where(mask, d1, inplace=True)\n        assert_frame_equal(result, expected)\n        result = df.copy()\n        result.where(mask, d1, inplace=True, axis=\"index\")\n        assert_frame_equal(result, expected)\n\n        d2 = df.copy().drop(1, axis=1)\n        expected = df.copy()\n        expected.loc[:, 1] = np.nan\n\n        result = df.where(mask, d2)\n        assert_frame_equal(result, expected)\n        result = df.where(mask, d2, axis=\"columns\")\n        assert_frame_equal(result, expected)\n        result = df.copy()\n        result.where(mask, d2, inplace=True)\n        assert_frame_equal(result, expected)\n        result = df.copy()\n        result.where(mask, d2, inplace=True, axis=\"columns\")\n        assert_frame_equal(result, expected)",
        "begin_line": 3118,
        "end_line": 3229,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_callable#3231",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_callable(self)",
        "snippet": "    def test_where_callable(self):\n        # GH 12533\n        df = DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        result = df.where(lambda x: x > 4, lambda x: x + 1)\n        exp = DataFrame([[2, 3, 4], [5, 5, 6], [7, 8, 9]])\n        tm.assert_frame_equal(result, exp)\n        tm.assert_frame_equal(result, df.where(df > 4, df + 1))\n\n        # return ndarray and scalar\n        result = df.where(lambda x: (x % 2 == 0).values, lambda x: 99)\n        exp = DataFrame([[99, 2, 99], [4, 99, 6], [99, 8, 99]])\n        tm.assert_frame_equal(result, exp)\n        tm.assert_frame_equal(result, df.where(df % 2 == 0, 99))\n\n        # chain\n        result = (df + 2).where(lambda x: x > 8, lambda x: x + 10)\n        exp = DataFrame([[13, 14, 15], [16, 17, 18], [9, 10, 11]])\n        tm.assert_frame_equal(result, exp)\n        tm.assert_frame_equal(result, (df + 2).where((df + 2) > 8, (df + 2) + 10))",
        "begin_line": 3231,
        "end_line": 3249,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_tz_values#3251",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_where_tz_values(self, tz_naive_fixture)",
        "snippet": "    def test_where_tz_values(self, tz_naive_fixture):\n        df1 = DataFrame(\n            DatetimeIndex([\"20150101\", \"20150102\", \"20150103\"], tz=tz_naive_fixture),\n            columns=[\"date\"],\n        )\n        df2 = DataFrame(\n            DatetimeIndex([\"20150103\", \"20150104\", \"20150105\"], tz=tz_naive_fixture),\n            columns=[\"date\"],\n        )\n        mask = DataFrame([True, True, False], columns=[\"date\"])\n        exp = DataFrame(\n            DatetimeIndex([\"20150101\", \"20150102\", \"20150105\"], tz=tz_naive_fixture),\n            columns=[\"date\"],\n        )\n        result = df1.where(mask, df2)\n        assert_frame_equal(exp, result)",
        "begin_line": 3251,
        "end_line": 3266,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_mask#3268",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_mask(self)",
        "snippet": "    def test_mask(self):\n        df = DataFrame(np.random.randn(5, 3))\n        cond = df > 0\n\n        rs = df.where(cond, np.nan)\n        assert_frame_equal(rs, df.mask(df <= 0))\n        assert_frame_equal(rs, df.mask(~cond))\n\n        other = DataFrame(np.random.randn(5, 3))\n        rs = df.where(cond, other)\n        assert_frame_equal(rs, df.mask(df <= 0, other))\n        assert_frame_equal(rs, df.mask(~cond, other))\n\n        # see gh-21891\n        df = DataFrame([1, 2])\n        res = df.mask([[True], [False]])\n\n        exp = DataFrame([np.nan, 2])\n        tm.assert_frame_equal(res, exp)",
        "begin_line": 3268,
        "end_line": 3286,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_mask_inplace#3288",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_mask_inplace(self)",
        "snippet": "    def test_mask_inplace(self):\n        # GH8801\n        df = DataFrame(np.random.randn(5, 3))\n        cond = df > 0\n\n        rdf = df.copy()\n\n        rdf.where(cond, inplace=True)\n        assert_frame_equal(rdf, df.where(cond))\n        assert_frame_equal(rdf, df.mask(~cond))\n\n        rdf = df.copy()\n        rdf.where(cond, -df, inplace=True)\n        assert_frame_equal(rdf, df.where(cond, -df))\n        assert_frame_equal(rdf, df.mask(~cond, -df))",
        "begin_line": 3288,
        "end_line": 3302,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_mask_edge_case_1xN_frame#3304",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_mask_edge_case_1xN_frame(self)",
        "snippet": "    def test_mask_edge_case_1xN_frame(self):\n        # GH4071\n        df = DataFrame([[1, 2]])\n        res = df.mask(DataFrame([[True, False]]))\n        expec = DataFrame([[np.nan, 2]])\n        assert_frame_equal(res, expec)",
        "begin_line": 3304,
        "end_line": 3309,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_mask_callable#3311",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_mask_callable(self)",
        "snippet": "    def test_mask_callable(self):\n        # GH 12533\n        df = DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        result = df.mask(lambda x: x > 4, lambda x: x + 1)\n        exp = DataFrame([[1, 2, 3], [4, 6, 7], [8, 9, 10]])\n        tm.assert_frame_equal(result, exp)\n        tm.assert_frame_equal(result, df.mask(df > 4, df + 1))\n\n        # return ndarray and scalar\n        result = df.mask(lambda x: (x % 2 == 0).values, lambda x: 99)\n        exp = DataFrame([[1, 99, 3], [99, 5, 99], [7, 99, 9]])\n        tm.assert_frame_equal(result, exp)\n        tm.assert_frame_equal(result, df.mask(df % 2 == 0, 99))\n\n        # chain\n        result = (df + 2).mask(lambda x: x > 8, lambda x: x + 10)\n        exp = DataFrame([[3, 4, 5], [6, 7, 8], [19, 20, 21]])\n        tm.assert_frame_equal(result, exp)\n        tm.assert_frame_equal(result, (df + 2).mask((df + 2) > 8, (df + 2) + 10))",
        "begin_line": 3311,
        "end_line": 3329,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_head_tail#3331",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_head_tail(self, float_frame)",
        "snippet": "    def test_head_tail(self, float_frame):\n        assert_frame_equal(float_frame.head(), float_frame[:5])\n        assert_frame_equal(float_frame.tail(), float_frame[-5:])\n\n        assert_frame_equal(float_frame.head(0), float_frame[0:0])\n        assert_frame_equal(float_frame.tail(0), float_frame[0:0])\n\n        assert_frame_equal(float_frame.head(-1), float_frame[:-1])\n        assert_frame_equal(float_frame.tail(-1), float_frame[1:])\n        assert_frame_equal(float_frame.head(1), float_frame[:1])\n        assert_frame_equal(float_frame.tail(1), float_frame[-1:])\n        # with a float index\n        df = float_frame.copy()\n        df.index = np.arange(len(float_frame)) + 0.1\n        assert_frame_equal(df.head(), df.iloc[:5])\n        assert_frame_equal(df.tail(), df.iloc[-5:])\n        assert_frame_equal(df.head(0), df[0:0])\n        assert_frame_equal(df.tail(0), df[0:0])\n        assert_frame_equal(df.head(-1), df.iloc[:-1])\n        assert_frame_equal(df.tail(-1), df.iloc[1:])\n        # test empty dataframe\n        empty_df = DataFrame()\n        assert_frame_equal(empty_df.tail(), empty_df)\n        assert_frame_equal(empty_df.head(), empty_df)",
        "begin_line": 3331,
        "end_line": 3354,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_type_error_multiindex#3356",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_type_error_multiindex(self)",
        "snippet": "    def test_type_error_multiindex(self):\n        # See gh-12218\n        df = DataFrame(\n            columns=[\"i\", \"c\", \"x\", \"y\"],\n            data=[[0, 0, 1, 2], [1, 0, 3, 4], [0, 1, 1, 2], [1, 1, 3, 4]],\n        )\n        dg = df.pivot_table(index=\"i\", columns=\"c\", values=[\"x\", \"y\"])\n\n        with pytest.raises(TypeError, match=\"is an invalid key\"):\n            str(dg[:, 0])\n\n        index = Index(range(2), name=\"i\")\n        columns = MultiIndex(\n            levels=[[\"x\", \"y\"], [0, 1]], codes=[[0, 1], [0, 0]], names=[None, \"c\"]\n        )\n        expected = DataFrame([[1, 2], [3, 4]], columns=columns, index=index)\n\n        result = dg.loc[:, (slice(None), 0)]\n        assert_frame_equal(result, expected)\n\n        name = (\"x\", 0)\n        index = Index(range(2), name=\"i\")\n        expected = Series([1, 3], index=index, name=name)\n\n        result = dg[\"x\", 0]\n        assert_series_equal(result, expected)",
        "begin_line": 3356,
        "end_line": 3381,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_interval_index#3383",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexing",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexing.test_interval_index(self)",
        "snippet": "    def test_interval_index(self):\n        # GH 19977\n        index = pd.interval_range(start=0, periods=3)\n        df = pd.DataFrame(\n            [[1, 2, 3], [4, 5, 6], [7, 8, 9]], index=index, columns=[\"A\", \"B\", \"C\"]\n        )\n\n        expected = 1\n        result = df.loc[0.5, \"A\"]\n        assert_almost_equal(result, expected)\n\n        index = pd.interval_range(start=0, periods=3, closed=\"both\")\n        df = pd.DataFrame(\n            [[1, 2, 3], [4, 5, 6], [7, 8, 9]], index=index, columns=[\"A\", \"B\", \"C\"]\n        )\n\n        index_exp = pd.interval_range(start=0, periods=2, freq=1, closed=\"both\")\n        expected = pd.Series([1, 4], index=index_exp, name=\"A\")\n        result = df.loc[1, \"A\"]\n        assert_series_equal(result, expected)",
        "begin_line": 3383,
        "end_line": 3402,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingDatetimeWithTZ.test_setitem#3406",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingDatetimeWithTZ",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexingDatetimeWithTZ.test_setitem(self, timezone_frame)",
        "snippet": "    def test_setitem(self, timezone_frame):\n\n        df = timezone_frame\n        idx = df[\"B\"].rename(\"foo\")\n\n        # setitem\n        df[\"C\"] = idx\n        assert_series_equal(df[\"C\"], Series(idx, name=\"C\"))\n\n        df[\"D\"] = \"foo\"\n        df[\"D\"] = idx\n        assert_series_equal(df[\"D\"], Series(idx, name=\"D\"))\n        del df[\"D\"]\n\n        # assert that A & C are not sharing the same base (e.g. they\n        # are copies)\n        b1 = df._data.blocks[1]\n        b2 = df._data.blocks[2]\n        tm.assert_extension_array_equal(b1.values, b2.values)\n        assert id(b1.values._data.base) != id(b2.values._data.base)\n\n        # with nan\n        df2 = df.copy()\n        df2.iloc[1, 1] = pd.NaT\n        df2.iloc[1, 2] = pd.NaT\n        result = df2[\"B\"]\n        assert_series_equal(notna(result), Series([True, False, True], name=\"B\"))\n        assert_series_equal(df2.dtypes, df.dtypes)",
        "begin_line": 3406,
        "end_line": 3433,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingDatetimeWithTZ.test_set_reset#3435",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingDatetimeWithTZ",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexingDatetimeWithTZ.test_set_reset(self)",
        "snippet": "    def test_set_reset(self):\n\n        idx = Index(date_range(\"20130101\", periods=3, tz=\"US/Eastern\"), name=\"foo\")\n\n        # set/reset\n        df = DataFrame({\"A\": [0, 1, 2]}, index=idx)\n        result = df.reset_index()\n        assert result[\"foo\"].dtype, \"M8[ns, US/Eastern\"\n\n        df = result.set_index(\"foo\")\n        tm.assert_index_equal(df.index, idx)",
        "begin_line": 3435,
        "end_line": 3445,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingDatetimeWithTZ.test_transpose#3447",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingDatetimeWithTZ",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexingDatetimeWithTZ.test_transpose(self, timezone_frame)",
        "snippet": "    def test_transpose(self, timezone_frame):\n\n        result = timezone_frame.T\n        expected = DataFrame(timezone_frame.values.T)\n        expected.index = [\"A\", \"B\", \"C\"]\n        assert_frame_equal(result, expected)",
        "begin_line": 3447,
        "end_line": 3452,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingDatetimeWithTZ.test_scalar_assignment#3454",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingDatetimeWithTZ",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexingDatetimeWithTZ.test_scalar_assignment(self)",
        "snippet": "    def test_scalar_assignment(self):\n        # issue #19843\n        df = pd.DataFrame(index=(0, 1, 2))\n        df[\"now\"] = pd.Timestamp(\"20130101\", tz=\"UTC\")\n        expected = pd.DataFrame(\n            {\"now\": pd.Timestamp(\"20130101\", tz=\"UTC\")}, index=[0, 1, 2]\n        )\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 3454,
        "end_line": 3461,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingUInt64.test_setitem#3465",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingUInt64",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexingUInt64.test_setitem(self, uint64_frame)",
        "snippet": "    def test_setitem(self, uint64_frame):\n\n        df = uint64_frame\n        idx = df[\"A\"].rename(\"foo\")\n\n        # setitem\n        df[\"C\"] = idx\n        assert_series_equal(df[\"C\"], Series(idx, name=\"C\"))\n\n        df[\"D\"] = \"foo\"\n        df[\"D\"] = idx\n        assert_series_equal(df[\"D\"], Series(idx, name=\"D\"))\n        del df[\"D\"]\n\n        # With NaN: because uint64 has no NaN element,\n        # the column should be cast to object.\n        df2 = df.copy()\n        df2.iloc[1, 1] = pd.NaT\n        df2.iloc[1, 2] = pd.NaT\n        result = df2[\"B\"]\n        assert_series_equal(notna(result), Series([True, False, True], name=\"B\"))\n        assert_series_equal(\n            df2.dtypes,\n            Series(\n                [np.dtype(\"uint64\"), np.dtype(\"O\"), np.dtype(\"O\")],\n                index=[\"A\", \"B\", \"C\"],\n            ),\n        )",
        "begin_line": 3465,
        "end_line": 3492,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingUInt64.test_set_reset#3494",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingUInt64",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexingUInt64.test_set_reset(self)",
        "snippet": "    def test_set_reset(self):\n\n        idx = Index([2 ** 63, 2 ** 63 + 5, 2 ** 63 + 10], name=\"foo\")\n\n        # set/reset\n        df = DataFrame({\"A\": [0, 1, 2]}, index=idx)\n        result = df.reset_index()\n        assert result[\"foo\"].dtype == np.dtype(\"uint64\")\n\n        df = result.set_index(\"foo\")\n        tm.assert_index_equal(df.index, idx)",
        "begin_line": 3494,
        "end_line": 3504,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingUInt64.test_transpose#3506",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingUInt64",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexingUInt64.test_transpose(self, uint64_frame)",
        "snippet": "    def test_transpose(self, uint64_frame):\n\n        result = uint64_frame.T\n        expected = DataFrame(uint64_frame.values.T)\n        expected.index = [\"A\", \"B\"]\n        assert_frame_equal(result, expected)",
        "begin_line": 3506,
        "end_line": 3511,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingCategorical.test_assignment#3515",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingCategorical",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexingCategorical.test_assignment(self)",
        "snippet": "    def test_assignment(self):\n        # assignment\n        df = DataFrame(\n            {\"value\": np.array(np.random.randint(0, 10000, 100), dtype=\"int32\")}\n        )\n        labels = Categorical(\n            [\"{0} - {1}\".format(i, i + 499) for i in range(0, 10000, 500)]\n        )\n\n        df = df.sort_values(by=[\"value\"], ascending=True)\n        s = pd.cut(df.value, range(0, 10500, 500), right=False, labels=labels)\n        d = s.values\n        df[\"D\"] = d\n        str(df)\n\n        result = df.dtypes\n        expected = Series(\n            [np.dtype(\"int32\"), CategoricalDtype(categories=labels, ordered=False)],\n            index=[\"value\", \"D\"],\n        )\n        tm.assert_series_equal(result, expected)\n\n        df[\"E\"] = s\n        str(df)\n\n        result = df.dtypes\n        expected = Series(\n            [\n                np.dtype(\"int32\"),\n                CategoricalDtype(categories=labels, ordered=False),\n                CategoricalDtype(categories=labels, ordered=False),\n            ],\n            index=[\"value\", \"D\", \"E\"],\n        )\n        tm.assert_series_equal(result, expected)\n\n        result1 = df[\"D\"]\n        result2 = df[\"E\"]\n        tm.assert_categorical_equal(result1._data._block.values, d)\n\n        # sorting\n        s.name = \"E\"\n        tm.assert_series_equal(result2.sort_index(), s.sort_index())\n\n        cat = Categorical([1, 2, 3, 10], categories=[1, 2, 3, 4, 10])\n        df = DataFrame(Series(cat))",
        "begin_line": 3515,
        "end_line": 3560,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingCategorical.test_assigning_ops#3562",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingCategorical",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexingCategorical.test_assigning_ops(self)",
        "snippet": "    def test_assigning_ops(self):\n        # systematically test the assigning operations:\n        # for all slicing ops:\n        #  for value in categories and value not in categories:\n\n        #   - assign a single value -> exp_single_cats_value\n\n        #   - assign a complete row (mixed values) -> exp_single_row\n\n        # assign multiple rows (mixed values) (-> array) -> exp_multi_row\n\n        # assign a part of a column with dtype == categorical ->\n        # exp_parts_cats_col\n\n        # assign a part of a column with dtype != categorical ->\n        # exp_parts_cats_col\n\n        cats = Categorical([\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"], categories=[\"a\", \"b\"])\n        idx = Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        values = [1, 1, 1, 1, 1, 1, 1]\n        orig = DataFrame({\"cats\": cats, \"values\": values}, index=idx)\n\n        # the expected values\n        # changed single row\n        cats1 = Categorical([\"a\", \"a\", \"b\", \"a\", \"a\", \"a\", \"a\"], categories=[\"a\", \"b\"])\n        idx1 = Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        values1 = [1, 1, 2, 1, 1, 1, 1]\n        exp_single_row = DataFrame({\"cats\": cats1, \"values\": values1}, index=idx1)\n\n        # changed multiple rows\n        cats2 = Categorical([\"a\", \"a\", \"b\", \"b\", \"a\", \"a\", \"a\"], categories=[\"a\", \"b\"])\n        idx2 = Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        values2 = [1, 1, 2, 2, 1, 1, 1]\n        exp_multi_row = DataFrame({\"cats\": cats2, \"values\": values2}, index=idx2)\n\n        # changed part of the cats column\n        cats3 = Categorical([\"a\", \"a\", \"b\", \"b\", \"a\", \"a\", \"a\"], categories=[\"a\", \"b\"])\n        idx3 = Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        values3 = [1, 1, 1, 1, 1, 1, 1]\n        exp_parts_cats_col = DataFrame({\"cats\": cats3, \"values\": values3}, index=idx3)\n\n        # changed single value in cats col\n        cats4 = Categorical([\"a\", \"a\", \"b\", \"a\", \"a\", \"a\", \"a\"], categories=[\"a\", \"b\"])\n        idx4 = Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        values4 = [1, 1, 1, 1, 1, 1, 1]\n        exp_single_cats_value = DataFrame(\n            {\"cats\": cats4, \"values\": values4}, index=idx4\n        )\n\n        #  iloc\n        # ###############\n        #   - assign a single value -> exp_single_cats_value\n        df = orig.copy()\n        df.iloc[2, 0] = \"b\"\n        tm.assert_frame_equal(df, exp_single_cats_value)\n\n        df = orig.copy()\n        df.iloc[df.index == \"j\", 0] = \"b\"\n        tm.assert_frame_equal(df, exp_single_cats_value)\n\n        #   - assign a single value not in the current categories set\n        with pytest.raises(ValueError):\n            df = orig.copy()\n            df.iloc[2, 0] = \"c\"\n\n        #   - assign a complete row (mixed values) -> exp_single_row\n        df = orig.copy()\n        df.iloc[2, :] = [\"b\", 2]\n        tm.assert_frame_equal(df, exp_single_row)\n\n        #   - assign a complete row (mixed values) not in categories set\n        with pytest.raises(ValueError):\n            df = orig.copy()\n            df.iloc[2, :] = [\"c\", 2]\n\n        #   - assign multiple rows (mixed values) -> exp_multi_row\n        df = orig.copy()\n        df.iloc[2:4, :] = [[\"b\", 2], [\"b\", 2]]\n        tm.assert_frame_equal(df, exp_multi_row)\n\n        with pytest.raises(ValueError):\n            df = orig.copy()\n            df.iloc[2:4, :] = [[\"c\", 2], [\"c\", 2]]\n\n        # assign a part of a column with dtype == categorical ->\n        # exp_parts_cats_col\n        df = orig.copy()\n        df.iloc[2:4, 0] = Categorical([\"b\", \"b\"], categories=[\"a\", \"b\"])\n        tm.assert_frame_equal(df, exp_parts_cats_col)\n\n        with pytest.raises(ValueError):\n            # different categories -> not sure if this should fail or pass\n            df = orig.copy()\n            df.iloc[2:4, 0] = Categorical(list(\"bb\"), categories=list(\"abc\"))\n\n        with pytest.raises(ValueError):\n            # different values\n            df = orig.copy()\n            df.iloc[2:4, 0] = Categorical(list(\"cc\"), categories=list(\"abc\"))\n\n        # assign a part of a column with dtype != categorical ->\n        # exp_parts_cats_col\n        df = orig.copy()\n        df.iloc[2:4, 0] = [\"b\", \"b\"]\n        tm.assert_frame_equal(df, exp_parts_cats_col)\n\n        with pytest.raises(ValueError):\n            df.iloc[2:4, 0] = [\"c\", \"c\"]\n\n        #  loc\n        # ##############\n        #   - assign a single value -> exp_single_cats_value\n        df = orig.copy()\n        df.loc[\"j\", \"cats\"] = \"b\"\n        tm.assert_frame_equal(df, exp_single_cats_value)\n\n        df = orig.copy()\n        df.loc[df.index == \"j\", \"cats\"] = \"b\"\n        tm.assert_frame_equal(df, exp_single_cats_value)\n\n        #   - assign a single value not in the current categories set\n        with pytest.raises(ValueError):\n            df = orig.copy()\n            df.loc[\"j\", \"cats\"] = \"c\"\n\n        #   - assign a complete row (mixed values) -> exp_single_row\n        df = orig.copy()\n        df.loc[\"j\", :] = [\"b\", 2]\n        tm.assert_frame_equal(df, exp_single_row)\n\n        #   - assign a complete row (mixed values) not in categories set\n        with pytest.raises(ValueError):\n            df = orig.copy()\n            df.loc[\"j\", :] = [\"c\", 2]\n\n        #   - assign multiple rows (mixed values) -> exp_multi_row\n        df = orig.copy()\n        df.loc[\"j\":\"k\", :] = [[\"b\", 2], [\"b\", 2]]\n        tm.assert_frame_equal(df, exp_multi_row)\n\n        with pytest.raises(ValueError):\n            df = orig.copy()\n            df.loc[\"j\":\"k\", :] = [[\"c\", 2], [\"c\", 2]]\n\n        # assign a part of a column with dtype == categorical ->\n        # exp_parts_cats_col\n        df = orig.copy()\n        df.loc[\"j\":\"k\", \"cats\"] = Categorical([\"b\", \"b\"], categories=[\"a\", \"b\"])\n        tm.assert_frame_equal(df, exp_parts_cats_col)\n\n        with pytest.raises(ValueError):\n            # different categories -> not sure if this should fail or pass\n            df = orig.copy()\n            df.loc[\"j\":\"k\", \"cats\"] = Categorical(\n                [\"b\", \"b\"], categories=[\"a\", \"b\", \"c\"]\n            )\n\n        with pytest.raises(ValueError):\n            # different values\n            df = orig.copy()\n            df.loc[\"j\":\"k\", \"cats\"] = Categorical(\n                [\"c\", \"c\"], categories=[\"a\", \"b\", \"c\"]\n            )\n\n        # assign a part of a column with dtype != categorical ->\n        # exp_parts_cats_col\n        df = orig.copy()\n        df.loc[\"j\":\"k\", \"cats\"] = [\"b\", \"b\"]\n        tm.assert_frame_equal(df, exp_parts_cats_col)\n\n        with pytest.raises(ValueError):\n            df.loc[\"j\":\"k\", \"cats\"] = [\"c\", \"c\"]\n\n        #  loc\n        # ##############\n        #   - assign a single value -> exp_single_cats_value\n        df = orig.copy()\n        df.loc[\"j\", df.columns[0]] = \"b\"\n        tm.assert_frame_equal(df, exp_single_cats_value)\n\n        df = orig.copy()\n        df.loc[df.index == \"j\", df.columns[0]] = \"b\"\n        tm.assert_frame_equal(df, exp_single_cats_value)\n\n        #   - assign a single value not in the current categories set\n        with pytest.raises(ValueError):\n            df = orig.copy()\n            df.loc[\"j\", df.columns[0]] = \"c\"\n\n        #   - assign a complete row (mixed values) -> exp_single_row\n        df = orig.copy()\n        df.loc[\"j\", :] = [\"b\", 2]\n        tm.assert_frame_equal(df, exp_single_row)\n\n        #   - assign a complete row (mixed values) not in categories set\n        with pytest.raises(ValueError):\n            df = orig.copy()\n            df.loc[\"j\", :] = [\"c\", 2]\n\n        #   - assign multiple rows (mixed values) -> exp_multi_row\n        df = orig.copy()\n        df.loc[\"j\":\"k\", :] = [[\"b\", 2], [\"b\", 2]]\n        tm.assert_frame_equal(df, exp_multi_row)\n\n        with pytest.raises(ValueError):\n            df = orig.copy()\n            df.loc[\"j\":\"k\", :] = [[\"c\", 2], [\"c\", 2]]\n\n        # assign a part of a column with dtype == categorical ->\n        # exp_parts_cats_col\n        df = orig.copy()\n        df.loc[\"j\":\"k\", df.columns[0]] = Categorical([\"b\", \"b\"], categories=[\"a\", \"b\"])\n        tm.assert_frame_equal(df, exp_parts_cats_col)\n\n        with pytest.raises(ValueError):\n            # different categories -> not sure if this should fail or pass\n            df = orig.copy()\n            df.loc[\"j\":\"k\", df.columns[0]] = Categorical(\n                [\"b\", \"b\"], categories=[\"a\", \"b\", \"c\"]\n            )\n\n        with pytest.raises(ValueError):\n            # different values\n            df = orig.copy()\n            df.loc[\"j\":\"k\", df.columns[0]] = Categorical(\n                [\"c\", \"c\"], categories=[\"a\", \"b\", \"c\"]\n            )\n\n        # assign a part of a column with dtype != categorical ->\n        # exp_parts_cats_col\n        df = orig.copy()\n        df.loc[\"j\":\"k\", df.columns[0]] = [\"b\", \"b\"]\n        tm.assert_frame_equal(df, exp_parts_cats_col)\n\n        with pytest.raises(ValueError):\n            df.loc[\"j\":\"k\", df.columns[0]] = [\"c\", \"c\"]\n\n        # iat\n        df = orig.copy()\n        df.iat[2, 0] = \"b\"\n        tm.assert_frame_equal(df, exp_single_cats_value)\n\n        #   - assign a single value not in the current categories set\n        with pytest.raises(ValueError):\n            df = orig.copy()\n            df.iat[2, 0] = \"c\"\n\n        # at\n        #   - assign a single value -> exp_single_cats_value\n        df = orig.copy()\n        df.at[\"j\", \"cats\"] = \"b\"\n        tm.assert_frame_equal(df, exp_single_cats_value)\n\n        #   - assign a single value not in the current categories set\n        with pytest.raises(ValueError):\n            df = orig.copy()\n            df.at[\"j\", \"cats\"] = \"c\"\n\n        # fancy indexing\n        catsf = Categorical(\n            [\"a\", \"a\", \"c\", \"c\", \"a\", \"a\", \"a\"], categories=[\"a\", \"b\", \"c\"]\n        )\n        idxf = Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        valuesf = [1, 1, 3, 3, 1, 1, 1]\n        df = DataFrame({\"cats\": catsf, \"values\": valuesf}, index=idxf)\n\n        exp_fancy = exp_multi_row.copy()\n        exp_fancy[\"cats\"].cat.set_categories([\"a\", \"b\", \"c\"], inplace=True)\n\n        df[df[\"cats\"] == \"c\"] = [\"b\", 2]\n        # category c is kept in .categories\n        tm.assert_frame_equal(df, exp_fancy)\n\n        # set_value\n        df = orig.copy()\n        df.at[\"j\", \"cats\"] = \"b\"\n        tm.assert_frame_equal(df, exp_single_cats_value)\n\n        with pytest.raises(ValueError):\n            df = orig.copy()\n            df.at[\"j\", \"cats\"] = \"c\"\n\n        # Assigning a Category to parts of a int/... column uses the values of\n        # the Categorical\n        df = DataFrame({\"a\": [1, 1, 1, 1, 1], \"b\": list(\"aaaaa\")})\n        exp = DataFrame({\"a\": [1, \"b\", \"b\", 1, 1], \"b\": list(\"aabba\")})\n        df.loc[1:2, \"a\"] = Categorical([\"b\", \"b\"], categories=[\"a\", \"b\"])\n        df.loc[2:3, \"b\"] = Categorical([\"b\", \"b\"], categories=[\"a\", \"b\"])\n        tm.assert_frame_equal(df, exp)",
        "begin_line": 3562,
        "end_line": 3850,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingCategorical.test_functions_no_warnings#3852",
        "src_path": "pandas/tests/frame/test_indexing.py",
        "class_name": "pandas.tests.frame.test_indexing.TestDataFrameIndexingCategorical",
        "signature": "pandas.tests.frame.test_indexing.TestDataFrameIndexingCategorical.test_functions_no_warnings(self)",
        "snippet": "    def test_functions_no_warnings(self):\n        df = DataFrame({\"value\": np.random.randint(0, 100, 20)})\n        labels = [\"{0} - {1}\".format(i, i + 9) for i in range(0, 100, 10)]\n        with tm.assert_produces_warning(False):\n            df[\"group\"] = pd.cut(\n                df.value, range(0, 105, 10), right=False, labels=labels\n            )",
        "begin_line": 3852,
        "end_line": 3858,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.setup_method#25",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n        self.indices = dict(\n            index=RangeIndex(0, 20, 2, name=\"foo\"),\n            index_dec=RangeIndex(18, -1, -2, name=\"bar\"),\n        )\n        self.setup_indices()",
        "begin_line": 25,
        "end_line": 30,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.create_index#32",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.create_index(self)",
        "snippet": "    def create_index(self):\n        return RangeIndex(5)",
        "begin_line": 32,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_can_hold_identifiers#35",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_can_hold_identifiers(self)",
        "snippet": "    def test_can_hold_identifiers(self):\n        idx = self.create_index()\n        key = idx[0]\n        assert idx._can_hold_identifiers_and_holds_name(key) is False",
        "begin_line": 35,
        "end_line": 38,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_too_many_names#40",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_too_many_names(self)",
        "snippet": "    def test_too_many_names(self):\n        with pytest.raises(ValueError, match=\"^Length\"):\n            self.index.names = [\"roger\", \"harold\"]",
        "begin_line": 40,
        "end_line": 42,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor#57",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor(self, args, kwargs, start, stop, step, name)",
        "snippet": "    def test_constructor(self, args, kwargs, start, stop, step, name):\n        result = RangeIndex(*args, name=name, **kwargs)\n        expected = Index(np.arange(start, stop, step, dtype=np.int64), name=name)\n        assert isinstance(result, RangeIndex)\n        assert result.name is name\n        assert result._range == range(start, stop, step)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 57,
        "end_line": 63,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_invalid_args#65",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_invalid_args(self)",
        "snippet": "    def test_constructor_invalid_args(self):\n        msg = \"RangeIndex\\\\(\\\\.\\\\.\\\\.\\\\) must be called with integers\"\n        with pytest.raises(TypeError, match=msg):\n            RangeIndex()\n\n        with pytest.raises(TypeError, match=msg):\n            RangeIndex(name=\"Foo\")\n\n        # invalid args\n        for i in [\n            Index([\"a\", \"b\"]),\n            Series([\"a\", \"b\"]),\n            np.array([\"a\", \"b\"]),\n            [],\n            \"foo\",\n            datetime(2000, 1, 1, 0, 0),\n            np.arange(0, 10),\n            np.array([1]),\n            [1],\n        ]:\n            with pytest.raises(TypeError):\n                RangeIndex(i)\n\n        # we don't allow on a bare Index\n        msg = (\n            r\"Index\\(\\.\\.\\.\\) must be called with a collection of some \"\n            r\"kind, 0 was passed\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            Index(0, 1000)",
        "begin_line": 65,
        "end_line": 94,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_same#96",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_same(self)",
        "snippet": "    def test_constructor_same(self):\n\n        # pass thru w and w/o copy\n        index = RangeIndex(1, 5, 2)\n        result = RangeIndex(index, copy=False)\n        assert result.identical(index)\n\n        result = RangeIndex(index, copy=True)\n        tm.assert_index_equal(result, index, exact=True)\n\n        result = RangeIndex(index)\n        tm.assert_index_equal(result, index, exact=True)\n\n        with pytest.raises(TypeError):\n            RangeIndex(index, dtype=\"float64\")",
        "begin_line": 96,
        "end_line": 110,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_range#112",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_range(self)",
        "snippet": "    def test_constructor_range(self):\n\n        msg = \"Value needs to be a scalar value, was type <class 'range'>\"\n        with pytest.raises(TypeError, match=msg):\n            result = RangeIndex(range(1, 5, 2))\n\n        result = RangeIndex.from_range(range(1, 5, 2))\n        expected = RangeIndex(1, 5, 2)\n        tm.assert_index_equal(result, expected, exact=True)\n\n        result = RangeIndex.from_range(range(5, 6))\n        expected = RangeIndex(5, 6, 1)\n        tm.assert_index_equal(result, expected, exact=True)\n\n        # an invalid range\n        result = RangeIndex.from_range(range(5, 1))\n        expected = RangeIndex(0, 0, 1)\n        tm.assert_index_equal(result, expected, exact=True)\n\n        result = RangeIndex.from_range(range(5))\n        expected = RangeIndex(0, 5, 1)\n        tm.assert_index_equal(result, expected, exact=True)\n\n        result = Index(range(1, 5, 2))\n        expected = RangeIndex(1, 5, 2)\n        tm.assert_index_equal(result, expected, exact=True)\n\n        with pytest.raises(TypeError):\n            Index(range(1, 5, 2), dtype=\"float64\")\n        msg = r\"^from_range\\(\\) got an unexpected keyword argument\"\n        with pytest.raises(TypeError, match=msg):\n            pd.RangeIndex.from_range(range(10), copy=True)",
        "begin_line": 112,
        "end_line": 143,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_name#145",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_name(self)",
        "snippet": "    def test_constructor_name(self):\n        # GH12288\n        orig = RangeIndex(10)\n        orig.name = \"original\"\n\n        copy = RangeIndex(orig)\n        copy.name = \"copy\"\n\n        assert orig.name == \"original\"\n        assert copy.name == \"copy\"\n\n        new = Index(copy)\n        assert new.name == \"copy\"\n\n        new.name = \"new\"\n        assert orig.name == \"original\"\n        assert copy.name == \"copy\"\n        assert new.name == \"new\"",
        "begin_line": 145,
        "end_line": 162,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_corner#164",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_corner(self)",
        "snippet": "    def test_constructor_corner(self):\n        arr = np.array([1, 2, 3, 4], dtype=object)\n        index = RangeIndex(1, 5)\n        assert index.values.dtype == np.int64\n        tm.assert_index_equal(index, Index(arr))\n\n        # non-int raise Exception\n        with pytest.raises(TypeError):\n            RangeIndex(\"1\", \"10\", \"1\")\n        with pytest.raises(TypeError):\n            RangeIndex(1.1, 10.2, 1.3)\n\n        # invalid passed type\n        with pytest.raises(TypeError):\n            RangeIndex(1, 5, dtype=\"float64\")",
        "begin_line": 164,
        "end_line": 178,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_start_stop_step_attrs#189",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_start_stop_step_attrs(self, index, start, stop, step)",
        "snippet": "    def test_start_stop_step_attrs(self, index, start, stop, step):\n        # GH 25710\n        assert index.start == start\n        assert index.stop == stop\n        assert index.step == step",
        "begin_line": 189,
        "end_line": 193,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_deprecated_start_stop_step_attrs#196",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_deprecated_start_stop_step_attrs(self, attr_name)",
        "snippet": "    def test_deprecated_start_stop_step_attrs(self, attr_name):\n        # GH 26581\n        idx = self.create_index()\n        with tm.assert_produces_warning(DeprecationWarning):\n            getattr(idx, attr_name)",
        "begin_line": 196,
        "end_line": 200,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_copy#202",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_copy(self)",
        "snippet": "    def test_copy(self):\n        i = RangeIndex(5, name=\"Foo\")\n        i_copy = i.copy()\n        assert i_copy is not i\n        assert i_copy.identical(i)\n        assert i_copy._range == range(0, 5, 1)\n        assert i_copy.name == \"Foo\"",
        "begin_line": 202,
        "end_line": 208,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_repr#210",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_repr(self)",
        "snippet": "    def test_repr(self):\n        i = RangeIndex(5, name=\"Foo\")\n        result = repr(i)\n        expected = \"RangeIndex(start=0, stop=5, step=1, name='Foo')\"\n        assert result == expected\n\n        result = eval(result)\n        tm.assert_index_equal(result, i, exact=True)\n\n        i = RangeIndex(5, 0, -1)\n        result = repr(i)\n        expected = \"RangeIndex(start=5, stop=0, step=-1)\"\n        assert result == expected\n\n        result = eval(result)\n        tm.assert_index_equal(result, i, exact=True)",
        "begin_line": 210,
        "end_line": 225,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_insert#227",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_insert(self)",
        "snippet": "    def test_insert(self):\n\n        idx = RangeIndex(5, name=\"Foo\")\n        result = idx[1:4]\n\n        # test 0th element\n        tm.assert_index_equal(idx[0:4], result.insert(0, idx[0]))\n\n        # GH 18295 (test missing)\n        expected = Float64Index([0, np.nan, 1, 2, 3, 4])\n        for na in (np.nan, pd.NaT, None):\n            result = RangeIndex(5).insert(1, na)\n            tm.assert_index_equal(result, expected)",
        "begin_line": 227,
        "end_line": 239,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_delete#241",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_delete(self)",
        "snippet": "    def test_delete(self):\n\n        idx = RangeIndex(5, name=\"Foo\")\n        expected = idx[1:].astype(int)\n        result = idx.delete(0)\n        tm.assert_index_equal(result, expected)\n        assert result.name == expected.name\n\n        expected = idx[:-1].astype(int)\n        result = idx.delete(-1)\n        tm.assert_index_equal(result, expected)\n        assert result.name == expected.name\n\n        with pytest.raises((IndexError, ValueError)):\n            # either depending on numpy version\n            result = idx.delete(len(idx))",
        "begin_line": 241,
        "end_line": 256,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_view#258",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_view(self)",
        "snippet": "    def test_view(self):\n        i = RangeIndex(0, name=\"Foo\")\n        i_view = i.view()\n        assert i_view.name == \"Foo\"\n\n        i_view = i.view(\"i8\")\n        tm.assert_numpy_array_equal(i.values, i_view)\n\n        i_view = i.view(RangeIndex)\n        tm.assert_index_equal(i, i_view)",
        "begin_line": 258,
        "end_line": 267,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_dtype#269",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_dtype(self)",
        "snippet": "    def test_dtype(self):\n        assert self.index.dtype == np.int64",
        "begin_line": 269,
        "end_line": 270,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_cached_data#272",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_cached_data(self)",
        "snippet": "    def test_cached_data(self):\n        # GH 26565, GH26617\n        # Calling RangeIndex._data caches an int64 array of the same length at\n        # self._cached_data. This test checks whether _cached_data has been set\n        idx = RangeIndex(0, 100, 10)\n\n        assert idx._cached_data is None\n\n        repr(idx)\n        assert idx._cached_data is None\n\n        str(idx)\n        assert idx._cached_data is None\n\n        idx.get_loc(20)\n        assert idx._cached_data is None\n\n        90 in idx\n        assert idx._cached_data is None\n\n        91 in idx\n        assert idx._cached_data is None\n\n        with tm.assert_produces_warning(FutureWarning):\n            idx.contains(90)\n        assert idx._cached_data is None\n\n        with tm.assert_produces_warning(FutureWarning):\n            idx.contains(91)\n        assert idx._cached_data is None\n\n        idx.all()\n        assert idx._cached_data is None\n\n        idx.any()\n        assert idx._cached_data is None\n\n        df = pd.DataFrame({\"a\": range(10)}, index=idx)\n\n        df.loc[50]\n        assert idx._cached_data is None\n\n        with pytest.raises(KeyError, match=\"51\"):\n            df.loc[51]\n        assert idx._cached_data is None\n\n        df.loc[10:50]\n        assert idx._cached_data is None\n\n        df.iloc[5:10]\n        assert idx._cached_data is None\n\n        # actually calling idx._data\n        assert isinstance(idx._data, np.ndarray)\n        assert isinstance(idx._cached_data, np.ndarray)",
        "begin_line": 272,
        "end_line": 326,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_is_monotonic#328",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_is_monotonic(self)",
        "snippet": "    def test_is_monotonic(self):\n        assert self.index.is_monotonic is True\n        assert self.index.is_monotonic_increasing is True\n        assert self.index.is_monotonic_decreasing is False\n        assert self.index._is_strictly_monotonic_increasing is True\n        assert self.index._is_strictly_monotonic_decreasing is False\n\n        index = RangeIndex(4, 0, -1)\n        assert index.is_monotonic is False\n        assert index._is_strictly_monotonic_increasing is False\n        assert index.is_monotonic_decreasing is True\n        assert index._is_strictly_monotonic_decreasing is True\n\n        index = RangeIndex(1, 2)\n        assert index.is_monotonic is True\n        assert index.is_monotonic_increasing is True\n        assert index.is_monotonic_decreasing is True\n        assert index._is_strictly_monotonic_increasing is True\n        assert index._is_strictly_monotonic_decreasing is True\n\n        index = RangeIndex(2, 1)\n        assert index.is_monotonic is True\n        assert index.is_monotonic_increasing is True\n        assert index.is_monotonic_decreasing is True\n        assert index._is_strictly_monotonic_increasing is True\n        assert index._is_strictly_monotonic_decreasing is True\n\n        index = RangeIndex(1, 1)\n        assert index.is_monotonic is True\n        assert index.is_monotonic_increasing is True\n        assert index.is_monotonic_decreasing is True\n        assert index._is_strictly_monotonic_increasing is True\n        assert index._is_strictly_monotonic_decreasing is True",
        "begin_line": 328,
        "end_line": 360,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_equals_range#362",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_equals_range(self)",
        "snippet": "    def test_equals_range(self):\n        equiv_pairs = [\n            (RangeIndex(0, 9, 2), RangeIndex(0, 10, 2)),\n            (RangeIndex(0), RangeIndex(1, -1, 3)),\n            (RangeIndex(1, 2, 3), RangeIndex(1, 3, 4)),\n            (RangeIndex(0, -9, -2), RangeIndex(0, -10, -2)),\n        ]\n        for left, right in equiv_pairs:\n            assert left.equals(right)\n            assert right.equals(left)",
        "begin_line": 362,
        "end_line": 371,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_logical_compat#373",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_logical_compat(self)",
        "snippet": "    def test_logical_compat(self):\n        idx = self.create_index()\n        assert idx.all() == idx.values.all()\n        assert idx.any() == idx.values.any()",
        "begin_line": 373,
        "end_line": 376,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_identical#378",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_identical(self)",
        "snippet": "    def test_identical(self):\n        i = Index(self.index.copy())\n        assert i.identical(self.index)\n\n        # we don't allow object dtype for RangeIndex\n        if isinstance(self.index, RangeIndex):\n            return\n\n        same_values_different_type = Index(i, dtype=object)\n        assert not i.identical(same_values_different_type)\n\n        i = self.index.copy(dtype=object)\n        i = i.rename(\"foo\")\n        same_values = Index(i, dtype=object)\n        assert same_values.identical(self.index.copy(dtype=object))\n\n        assert not i.identical(self.index)\n        assert Index(same_values, name=\"foo\", dtype=object).identical(i)\n\n        assert not self.index.copy(dtype=object).identical(\n            self.index.copy(dtype=\"int64\")\n        )",
        "begin_line": 378,
        "end_line": 399,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_get_indexer#401",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_get_indexer(self)",
        "snippet": "    def test_get_indexer(self):\n        target = RangeIndex(10)\n        indexer = self.index.get_indexer(target)\n        expected = np.array([0, -1, 1, -1, 2, -1, 3, -1, 4, -1], dtype=np.intp)\n        tm.assert_numpy_array_equal(indexer, expected)",
        "begin_line": 401,
        "end_line": 405,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_get_indexer_pad#407",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_get_indexer_pad(self)",
        "snippet": "    def test_get_indexer_pad(self):\n        target = RangeIndex(10)\n        indexer = self.index.get_indexer(target, method=\"pad\")\n        expected = np.array([0, 0, 1, 1, 2, 2, 3, 3, 4, 4], dtype=np.intp)\n        tm.assert_numpy_array_equal(indexer, expected)",
        "begin_line": 407,
        "end_line": 411,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_get_indexer_backfill#413",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_get_indexer_backfill(self)",
        "snippet": "    def test_get_indexer_backfill(self):\n        target = RangeIndex(10)\n        indexer = self.index.get_indexer(target, method=\"backfill\")\n        expected = np.array([0, 1, 1, 2, 2, 3, 3, 4, 4, 5], dtype=np.intp)\n        tm.assert_numpy_array_equal(indexer, expected)",
        "begin_line": 413,
        "end_line": 417,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_get_indexer_limit#419",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_get_indexer_limit(self)",
        "snippet": "    def test_get_indexer_limit(self):\n        # GH 28631\n        idx = RangeIndex(4)\n        target = RangeIndex(6)\n        result = idx.get_indexer(target, method=\"pad\", limit=1)\n        expected = np.array([0, 1, 2, 3, 3, -1], dtype=np.intp)\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 419,
        "end_line": 425,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_outer#427",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_outer(self)",
        "snippet": "    def test_join_outer(self):\n        # join with Int64Index\n        other = Int64Index(np.arange(25, 14, -1))\n\n        res, lidx, ridx = self.index.join(other, how=\"outer\", return_indexers=True)\n        noidx_res = self.index.join(other, how=\"outer\")\n        tm.assert_index_equal(res, noidx_res)\n\n        eres = Int64Index(\n            [0, 2, 4, 6, 8, 10, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n        )\n        elidx = np.array(\n            [0, 1, 2, 3, 4, 5, 6, 7, -1, 8, -1, 9, -1, -1, -1, -1, -1, -1, -1],\n            dtype=np.intp,\n        )\n        eridx = np.array(\n            [-1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0],\n            dtype=np.intp,\n        )\n\n        assert isinstance(res, Int64Index)\n        assert not isinstance(res, RangeIndex)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)\n\n        # join with RangeIndex\n        other = RangeIndex(25, 14, -1)\n\n        res, lidx, ridx = self.index.join(other, how=\"outer\", return_indexers=True)\n        noidx_res = self.index.join(other, how=\"outer\")\n        tm.assert_index_equal(res, noidx_res)\n\n        assert isinstance(res, Int64Index)\n        assert not isinstance(res, RangeIndex)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)",
        "begin_line": 427,
        "end_line": 464,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_inner#466",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_inner(self)",
        "snippet": "    def test_join_inner(self):\n        # Join with non-RangeIndex\n        other = Int64Index(np.arange(25, 14, -1))\n\n        res, lidx, ridx = self.index.join(other, how=\"inner\", return_indexers=True)\n\n        # no guarantee of sortedness, so sort for comparison purposes\n        ind = res.argsort()\n        res = res.take(ind)\n        lidx = lidx.take(ind)\n        ridx = ridx.take(ind)\n\n        eres = Int64Index([16, 18])\n        elidx = np.array([8, 9], dtype=np.intp)\n        eridx = np.array([9, 7], dtype=np.intp)\n\n        assert isinstance(res, Int64Index)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)\n\n        # Join two RangeIndex\n        other = RangeIndex(25, 14, -1)\n\n        res, lidx, ridx = self.index.join(other, how=\"inner\", return_indexers=True)\n\n        assert isinstance(res, RangeIndex)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)",
        "begin_line": 466,
        "end_line": 495,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_left#497",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_left(self)",
        "snippet": "    def test_join_left(self):\n        # Join with Int64Index\n        other = Int64Index(np.arange(25, 14, -1))\n\n        res, lidx, ridx = self.index.join(other, how=\"left\", return_indexers=True)\n        eres = self.index\n        eridx = np.array([-1, -1, -1, -1, -1, -1, -1, -1, 9, 7], dtype=np.intp)\n\n        assert isinstance(res, RangeIndex)\n        tm.assert_index_equal(res, eres)\n        assert lidx is None\n        tm.assert_numpy_array_equal(ridx, eridx)\n\n        # Join withRangeIndex\n        other = Int64Index(np.arange(25, 14, -1))\n\n        res, lidx, ridx = self.index.join(other, how=\"left\", return_indexers=True)\n\n        assert isinstance(res, RangeIndex)\n        tm.assert_index_equal(res, eres)\n        assert lidx is None\n        tm.assert_numpy_array_equal(ridx, eridx)",
        "begin_line": 497,
        "end_line": 518,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_right#520",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_right(self)",
        "snippet": "    def test_join_right(self):\n        # Join with Int64Index\n        other = Int64Index(np.arange(25, 14, -1))\n\n        res, lidx, ridx = self.index.join(other, how=\"right\", return_indexers=True)\n        eres = other\n        elidx = np.array([-1, -1, -1, -1, -1, -1, -1, 9, -1, 8, -1], dtype=np.intp)\n\n        assert isinstance(other, Int64Index)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        assert ridx is None\n\n        # Join withRangeIndex\n        other = RangeIndex(25, 14, -1)\n\n        res, lidx, ridx = self.index.join(other, how=\"right\", return_indexers=True)\n        eres = other\n\n        assert isinstance(other, RangeIndex)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        assert ridx is None",
        "begin_line": 520,
        "end_line": 542,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_non_int_index#544",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_non_int_index(self)",
        "snippet": "    def test_join_non_int_index(self):\n        other = Index([3, 6, 7, 8, 10], dtype=object)\n\n        outer = self.index.join(other, how=\"outer\")\n        outer2 = other.join(self.index, how=\"outer\")\n        expected = Index([0, 2, 3, 4, 6, 7, 8, 10, 12, 14, 16, 18])\n        tm.assert_index_equal(outer, outer2)\n        tm.assert_index_equal(outer, expected)\n\n        inner = self.index.join(other, how=\"inner\")\n        inner2 = other.join(self.index, how=\"inner\")\n        expected = Index([6, 8, 10])\n        tm.assert_index_equal(inner, inner2)\n        tm.assert_index_equal(inner, expected)\n\n        left = self.index.join(other, how=\"left\")\n        tm.assert_index_equal(left, self.index.astype(object))\n\n        left2 = other.join(self.index, how=\"left\")\n        tm.assert_index_equal(left2, other)\n\n        right = self.index.join(other, how=\"right\")\n        tm.assert_index_equal(right, other)\n\n        right2 = other.join(self.index, how=\"right\")\n        tm.assert_index_equal(right2, self.index.astype(object))",
        "begin_line": 544,
        "end_line": 569,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_non_unique#571",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_non_unique(self)",
        "snippet": "    def test_join_non_unique(self):\n        other = Index([4, 4, 3, 3])\n\n        res, lidx, ridx = self.index.join(other, return_indexers=True)\n\n        eres = Int64Index([0, 2, 4, 4, 6, 8, 10, 12, 14, 16, 18])\n        elidx = np.array([0, 1, 2, 2, 3, 4, 5, 6, 7, 8, 9], dtype=np.intp)\n        eridx = np.array([-1, -1, 0, 1, -1, -1, -1, -1, -1, -1, -1], dtype=np.intp)\n\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)",
        "begin_line": 571,
        "end_line": 582,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_self#584",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_self(self)",
        "snippet": "    def test_join_self(self):\n        kinds = \"outer\", \"inner\", \"left\", \"right\"\n        for kind in kinds:\n            joined = self.index.join(self.index, how=kind)\n            assert self.index is joined",
        "begin_line": 584,
        "end_line": 588,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_intersection#591",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_intersection(self, sort)",
        "snippet": "    def test_intersection(self, sort):\n        # intersect with Int64Index\n        other = Index(np.arange(1, 6))\n        result = self.index.intersection(other, sort=sort)\n        expected = Index(np.sort(np.intersect1d(self.index.values, other.values)))\n        tm.assert_index_equal(result, expected)\n\n        result = other.intersection(self.index, sort=sort)\n        expected = Index(\n            np.sort(np.asarray(np.intersect1d(self.index.values, other.values)))\n        )\n        tm.assert_index_equal(result, expected)\n\n        # intersect with increasing RangeIndex\n        other = RangeIndex(1, 6)\n        result = self.index.intersection(other, sort=sort)\n        expected = Index(np.sort(np.intersect1d(self.index.values, other.values)))\n        tm.assert_index_equal(result, expected)\n\n        # intersect with decreasing RangeIndex\n        other = RangeIndex(5, 0, -1)\n        result = self.index.intersection(other, sort=sort)\n        expected = Index(np.sort(np.intersect1d(self.index.values, other.values)))\n        tm.assert_index_equal(result, expected)\n\n        # reversed (GH 17296)\n        result = other.intersection(self.index, sort=sort)\n        tm.assert_index_equal(result, expected)\n\n        # GH 17296: intersect two decreasing RangeIndexes\n        first = RangeIndex(10, -2, -2)\n        other = RangeIndex(5, -4, -1)\n        expected = first.astype(int).intersection(other.astype(int), sort=sort)\n        result = first.intersection(other, sort=sort).astype(int)\n        tm.assert_index_equal(result, expected)\n\n        # reversed\n        result = other.intersection(first, sort=sort).astype(int)\n        tm.assert_index_equal(result, expected)\n\n        index = RangeIndex(5)\n\n        # intersect of non-overlapping indices\n        other = RangeIndex(5, 10, 1)\n        result = index.intersection(other, sort=sort)\n        expected = RangeIndex(0, 0, 1)\n        tm.assert_index_equal(result, expected)\n\n        other = RangeIndex(-1, -5, -1)\n        result = index.intersection(other, sort=sort)\n        expected = RangeIndex(0, 0, 1)\n        tm.assert_index_equal(result, expected)\n\n        # intersection of empty indices\n        other = RangeIndex(0, 0, 1)\n        result = index.intersection(other, sort=sort)\n        expected = RangeIndex(0, 0, 1)\n        tm.assert_index_equal(result, expected)\n\n        result = other.intersection(index, sort=sort)\n        tm.assert_index_equal(result, expected)\n\n        # intersection of non-overlapping values based on start value and gcd\n        index = RangeIndex(1, 10, 2)\n        other = RangeIndex(0, 10, 4)\n        result = index.intersection(other, sort=sort)\n        expected = RangeIndex(0, 0, 1)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 591,
        "end_line": 658,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_union_noncomparable#661",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_union_noncomparable(self, sort)",
        "snippet": "    def test_union_noncomparable(self, sort):\n        from datetime import datetime, timedelta\n\n        # corner case, non-Int64Index\n        now = datetime.now()\n        other = Index([now + timedelta(i) for i in range(4)], dtype=object)\n        result = self.index.union(other, sort=sort)\n        expected = Index(np.concatenate((self.index, other)))\n        tm.assert_index_equal(result, expected)\n\n        result = other.union(self.index, sort=sort)\n        expected = Index(np.concatenate((other, self.index)))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 661,
        "end_line": 673,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.unions#741",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.unions(self, request)",
        "snippet": "    def unions(self, request):\n        \"\"\"Inputs and expected outputs for RangeIndex.union tests\"\"\"\n\n        return request.param",
        "begin_line": 741,
        "end_line": 744,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_union_sorted#746",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_union_sorted(self, unions)",
        "snippet": "    def test_union_sorted(self, unions):\n\n        idx1, idx2, expected_sorted, expected_notsorted = unions\n\n        res1 = idx1.union(idx2, sort=None)\n        tm.assert_index_equal(res1, expected_sorted, exact=True)\n\n        res1 = idx1.union(idx2, sort=False)\n        tm.assert_index_equal(res1, expected_notsorted, exact=True)\n\n        res2 = idx2.union(idx1, sort=None)\n        res3 = idx1._int64index.union(idx2, sort=None)\n        tm.assert_index_equal(res2, expected_sorted, exact=True)\n        tm.assert_index_equal(res3, expected_sorted)",
        "begin_line": 746,
        "end_line": 759,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_nbytes#761",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_nbytes(self)",
        "snippet": "    def test_nbytes(self):\n\n        # memory savings vs int index\n        i = RangeIndex(0, 1000)\n        assert i.nbytes < i._int64index.nbytes / 10\n\n        # constant memory usage\n        i2 = RangeIndex(0, 10)\n        assert i.nbytes == i2.nbytes",
        "begin_line": 761,
        "end_line": 769,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_cant_or_shouldnt_cast#771",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_cant_or_shouldnt_cast(self)",
        "snippet": "    def test_cant_or_shouldnt_cast(self):\n        # can't\n        with pytest.raises(TypeError):\n            RangeIndex(\"foo\", \"bar\", \"baz\")\n\n        # shouldn't\n        with pytest.raises(TypeError):\n            RangeIndex(\"0\", \"1\", \"2\")",
        "begin_line": 771,
        "end_line": 778,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_view_Index#780",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_view_Index(self)",
        "snippet": "    def test_view_Index(self):\n        self.index.view(Index)",
        "begin_line": 780,
        "end_line": 781,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_prevent_casting#783",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_prevent_casting(self)",
        "snippet": "    def test_prevent_casting(self):\n        result = self.index.astype(\"O\")\n        assert result.dtype == np.object_",
        "begin_line": 783,
        "end_line": 785,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_take_preserve_name#787",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_take_preserve_name(self)",
        "snippet": "    def test_take_preserve_name(self):\n        index = RangeIndex(1, 5, name=\"foo\")\n        taken = index.take([3, 0, 1])\n        assert index.name == taken.name",
        "begin_line": 787,
        "end_line": 790,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_take_fill_value#792",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_take_fill_value(self)",
        "snippet": "    def test_take_fill_value(self):\n        # GH 12631\n        idx = pd.RangeIndex(1, 4, name=\"xxx\")\n        result = idx.take(np.array([1, 0, -1]))\n        expected = pd.Int64Index([2, 1, 3], name=\"xxx\")\n        tm.assert_index_equal(result, expected)\n\n        # fill_value\n        msg = \"Unable to fill values because RangeIndex cannot contain NA\"\n        with pytest.raises(ValueError, match=msg):\n            idx.take(np.array([1, 0, -1]), fill_value=True)\n\n        # allow_fill=False\n        result = idx.take(np.array([1, 0, -1]), allow_fill=False, fill_value=True)\n        expected = pd.Int64Index([2, 1, 3], name=\"xxx\")\n        tm.assert_index_equal(result, expected)\n\n        msg = \"Unable to fill values because RangeIndex cannot contain NA\"\n        with pytest.raises(ValueError, match=msg):\n            idx.take(np.array([1, 0, -2]), fill_value=True)\n        with pytest.raises(ValueError, match=msg):\n            idx.take(np.array([1, 0, -5]), fill_value=True)\n\n        with pytest.raises(IndexError):\n            idx.take(np.array([1, -5]))",
        "begin_line": 792,
        "end_line": 816,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_print_unicode_columns#818",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_print_unicode_columns(self)",
        "snippet": "    def test_print_unicode_columns(self):\n        df = pd.DataFrame({\"\\u05d0\": [1, 2, 3], \"\\u05d1\": [4, 5, 6], \"c\": [7, 8, 9]})\n        repr(df.columns)  # should not raise UnicodeDecodeError",
        "begin_line": 818,
        "end_line": 820,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_repr_roundtrip#822",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_repr_roundtrip(self)",
        "snippet": "    def test_repr_roundtrip(self):\n        tm.assert_index_equal(eval(repr(self.index)), self.index)",
        "begin_line": 822,
        "end_line": 823,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_slice_keep_name#825",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_slice_keep_name(self)",
        "snippet": "    def test_slice_keep_name(self):\n        idx = RangeIndex(1, 2, name=\"asdf\")\n        assert idx.name == idx[1:].name",
        "begin_line": 825,
        "end_line": 827,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_explicit_conversions#829",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_explicit_conversions(self)",
        "snippet": "    def test_explicit_conversions(self):\n\n        # GH 8608\n        # add/sub are overridden explicitly for Float/Int Index\n        idx = RangeIndex(5)\n\n        # float conversions\n        arr = np.arange(5, dtype=\"int64\") * 3.2\n        expected = Float64Index(arr)\n        fidx = idx * 3.2\n        tm.assert_index_equal(fidx, expected)\n        fidx = 3.2 * idx\n        tm.assert_index_equal(fidx, expected)\n\n        # interops with numpy arrays\n        expected = Float64Index(arr)\n        a = np.zeros(5, dtype=\"float64\")\n        result = fidx - a\n        tm.assert_index_equal(result, expected)\n\n        expected = Float64Index(-arr)\n        a = np.zeros(5, dtype=\"float64\")\n        result = a - fidx\n        tm.assert_index_equal(result, expected)",
        "begin_line": 829,
        "end_line": 852,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_has_duplicates#854",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_has_duplicates(self)",
        "snippet": "    def test_has_duplicates(self):\n        for ind in self.indices:\n            if not len(ind):\n                continue\n            idx = self.indices[ind]\n            assert idx.is_unique\n            assert not idx.has_duplicates",
        "begin_line": 854,
        "end_line": 860,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_extended_gcd#862",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_extended_gcd(self)",
        "snippet": "    def test_extended_gcd(self):\n        result = self.index._extended_gcd(6, 10)\n        assert result[0] == result[1] * 6 + result[2] * 10\n        assert 2 == result[0]\n\n        result = self.index._extended_gcd(10, 6)\n        assert 2 == result[1] * 10 + result[2] * 6\n        assert 2 == result[0]",
        "begin_line": 862,
        "end_line": 869,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_min_fitting_element#871",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_min_fitting_element(self)",
        "snippet": "    def test_min_fitting_element(self):\n        result = RangeIndex(0, 20, 2)._min_fitting_element(1)\n        assert 2 == result\n\n        result = RangeIndex(1, 6)._min_fitting_element(1)\n        assert 1 == result\n\n        result = RangeIndex(18, -2, -2)._min_fitting_element(1)\n        assert 2 == result\n\n        result = RangeIndex(5, 0, -1)._min_fitting_element(1)\n        assert 1 == result\n\n        big_num = 500000000000000000000000\n\n        result = RangeIndex(5, big_num * 2, 1)._min_fitting_element(big_num)\n        assert big_num == result",
        "begin_line": 871,
        "end_line": 887,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_max_fitting_element#889",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_max_fitting_element(self)",
        "snippet": "    def test_max_fitting_element(self):\n        result = RangeIndex(0, 20, 2)._max_fitting_element(17)\n        assert 16 == result\n\n        result = RangeIndex(1, 6)._max_fitting_element(4)\n        assert 4 == result\n\n        result = RangeIndex(18, -2, -2)._max_fitting_element(17)\n        assert 16 == result\n\n        result = RangeIndex(5, 0, -1)._max_fitting_element(4)\n        assert 4 == result\n\n        big_num = 500000000000000000000000\n\n        result = RangeIndex(5, big_num * 2, 1)._max_fitting_element(big_num)\n        assert big_num == result",
        "begin_line": 889,
        "end_line": 905,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_pickle_compat_construction#907",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_pickle_compat_construction(self)",
        "snippet": "    def test_pickle_compat_construction(self):\n        # RangeIndex() is a valid constructor\n        pass",
        "begin_line": 907,
        "end_line": 909,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_slice_specialised#911",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_slice_specialised(self)",
        "snippet": "    def test_slice_specialised(self):\n\n        # scalar indexing\n        res = self.index[1]\n        expected = 2\n        assert res == expected\n\n        res = self.index[-1]\n        expected = 18\n        assert res == expected\n\n        # slicing\n        # slice value completion\n        index = self.index[:]\n        expected = self.index\n        tm.assert_index_equal(index, expected)\n\n        # positive slice values\n        index = self.index[7:10:2]\n        expected = Index(np.array([14, 18]), name=\"foo\")\n        tm.assert_index_equal(index, expected)\n\n        # negative slice values\n        index = self.index[-1:-5:-2]\n        expected = Index(np.array([18, 14]), name=\"foo\")\n        tm.assert_index_equal(index, expected)\n\n        # stop overshoot\n        index = self.index[2:100:4]\n        expected = Index(np.array([4, 12]), name=\"foo\")\n        tm.assert_index_equal(index, expected)\n\n        # reverse\n        index = self.index[::-1]\n        expected = Index(self.index.values[::-1], name=\"foo\")\n        tm.assert_index_equal(index, expected)\n\n        index = self.index[-8::-1]\n        expected = Index(np.array([4, 2, 0]), name=\"foo\")\n        tm.assert_index_equal(index, expected)\n\n        index = self.index[-40::-1]\n        expected = Index(np.array([], dtype=np.int64), name=\"foo\")\n        tm.assert_index_equal(index, expected)\n\n        index = self.index[40::-1]\n        expected = Index(self.index.values[40::-1], name=\"foo\")\n        tm.assert_index_equal(index, expected)\n\n        index = self.index[10::-1]\n        expected = Index(self.index.values[::-1], name=\"foo\")\n        tm.assert_index_equal(index, expected)",
        "begin_line": 911,
        "end_line": 962,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_len_specialised#964",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_len_specialised(self)",
        "snippet": "    def test_len_specialised(self):\n\n        # make sure that our len is the same as\n        # np.arange calc\n\n        for step in np.arange(1, 6, 1):\n\n            arr = np.arange(0, 5, step)\n            i = RangeIndex(0, 5, step)\n            assert len(i) == len(arr)\n\n            i = RangeIndex(5, 0, step)\n            assert len(i) == 0\n\n        for step in np.arange(-6, -1, 1):\n\n            arr = np.arange(5, 0, step)\n            i = RangeIndex(5, 0, step)\n            assert len(i) == len(arr)\n\n            i = RangeIndex(0, 5, step)\n            assert len(i) == 0",
        "begin_line": 964,
        "end_line": 985,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.appends#1010",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.appends(self, request)",
        "snippet": "    def appends(self, request):\n        \"\"\"Inputs and expected outputs for RangeIndex.append test\"\"\"\n\n        return request.param",
        "begin_line": 1010,
        "end_line": 1013,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_append#1015",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_append(self, appends)",
        "snippet": "    def test_append(self, appends):\n        # GH16212\n\n        indices, expected = appends\n\n        result = indices[0].append(indices[1:])\n        tm.assert_index_equal(result, expected, exact=True)\n\n        if len(indices) == 2:\n            # Append single item rather than list\n            result2 = indices[0].append(indices[1])\n            tm.assert_index_equal(result2, expected, exact=True)",
        "begin_line": 1015,
        "end_line": 1026,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_engineless_lookup#1028",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_engineless_lookup(self)",
        "snippet": "    def test_engineless_lookup(self):\n        # GH 16685\n        # Standard lookup on RangeIndex should not require the engine to be\n        # created\n        idx = RangeIndex(2, 10, 3)\n\n        assert idx.get_loc(5) == 1\n        tm.assert_numpy_array_equal(\n            idx.get_indexer([2, 8]), ensure_platform_int(np.array([0, 2]))\n        )\n        with pytest.raises(KeyError, match=\"3\"):\n            idx.get_loc(3)\n\n        assert \"_engine\" not in idx._cache\n\n        # The engine is still required for lookup of a different dtype scalar:\n        with pytest.raises(KeyError, match=\"'a'\"):\n            assert idx.get_loc(\"a\") == -1\n\n        assert \"_engine\" in idx._cache",
        "begin_line": 1028,
        "end_line": 1047,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.setup_indices#36",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.setup_indices(self)",
        "snippet": "    def setup_indices(self):\n        for name, idx in self.indices.items():\n            setattr(self, name, idx)",
        "begin_line": 36,
        "end_line": 38,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_pickle_compat_construction#40",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_pickle_compat_construction(self)",
        "snippet": "    def test_pickle_compat_construction(self):\n        # need an object to create with\n        msg = (\n            r\"Index\\(\\.\\.\\.\\) must be called with a collection of some\"\n            r\" kind, None was passed|\"\n            r\"__new__\\(\\) missing 1 required positional argument: 'data'|\"\n            r\"__new__\\(\\) takes at least 2 arguments \\(1 given\\)\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            self._holder()",
        "begin_line": 40,
        "end_line": 49,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_series#51",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_series(self)",
        "snippet": "    def test_to_series(self):\n        # assert that we are creating a copy of the index\n\n        idx = self.create_index()\n        s = idx.to_series()\n        assert s.values is not idx.values\n        assert s.index is not idx\n        assert s.name == idx.name",
        "begin_line": 51,
        "end_line": 58,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_series_with_arguments#60",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_series_with_arguments(self)",
        "snippet": "    def test_to_series_with_arguments(self):\n        # GH18699\n\n        # index kwarg\n        idx = self.create_index()\n        s = idx.to_series(index=idx)\n\n        assert s.values is not idx.values\n        assert s.index is idx\n        assert s.name == idx.name\n\n        # name kwarg\n        idx = self.create_index()\n        s = idx.to_series(name=\"__test\")\n\n        assert s.values is not idx.values\n        assert s.index is not idx\n        assert s.name != idx.name",
        "begin_line": 60,
        "end_line": 77,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_frame#80",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_frame(self, name)",
        "snippet": "    def test_to_frame(self, name):\n        # see GH-15230, GH-22580\n        idx = self.create_index()\n\n        if name:\n            idx_name = name\n        else:\n            idx_name = idx.name or 0\n\n        df = idx.to_frame(name=idx_name)\n\n        assert df.index is idx\n        assert len(df.columns) == 1\n        assert df.columns[0] == idx_name\n        assert df[idx_name].values is not idx.values\n\n        df = idx.to_frame(index=False, name=idx_name)\n        assert df.index is not idx",
        "begin_line": 80,
        "end_line": 97,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_frame_datetime_tz#99",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_frame_datetime_tz(self)",
        "snippet": "    def test_to_frame_datetime_tz(self):\n        # GH 25809\n        idx = pd.date_range(start=\"2019-01-01\", end=\"2019-01-30\", freq=\"D\")\n        idx = idx.tz_localize(\"UTC\")\n        result = idx.to_frame()\n        expected = pd.DataFrame(idx, index=idx)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 99,
        "end_line": 105,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_shift#107",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_shift(self)",
        "snippet": "    def test_shift(self):\n\n        # GH8083 test the base class for shift\n        idx = self.create_index()\n        msg = \"Not supported for type {}\".format(type(idx).__name__)\n        with pytest.raises(NotImplementedError, match=msg):\n            idx.shift(1)\n        with pytest.raises(NotImplementedError, match=msg):\n            idx.shift(1, 2)",
        "begin_line": 107,
        "end_line": 115,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_create_index_existing_name#117",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_create_index_existing_name(self)",
        "snippet": "    def test_create_index_existing_name(self):\n\n        # GH11193, when an existing index is passed, and a new name is not\n        # specified, the new index should inherit the previous object name\n        expected = self.create_index()\n        if not isinstance(expected, MultiIndex):\n            expected.name = \"foo\"\n            result = pd.Index(expected)\n            tm.assert_index_equal(result, expected)\n\n            result = pd.Index(expected, name=\"bar\")\n            expected.name = \"bar\"\n            tm.assert_index_equal(result, expected)\n        else:\n            expected.names = [\"foo\", \"bar\"]\n            result = pd.Index(expected)\n            tm.assert_index_equal(\n                result,\n                Index(\n                    Index(\n                        [\n                            (\"foo\", \"one\"),\n                            (\"foo\", \"two\"),\n                            (\"bar\", \"one\"),\n                            (\"baz\", \"two\"),\n                            (\"qux\", \"one\"),\n                            (\"qux\", \"two\"),\n                        ],\n                        dtype=\"object\",\n                    ),\n                    names=[\"foo\", \"bar\"],\n                ),\n            )\n\n            result = pd.Index(expected, names=[\"A\", \"B\"])\n            tm.assert_index_equal(\n                result,\n                Index(\n                    Index(\n                        [\n                            (\"foo\", \"one\"),\n                            (\"foo\", \"two\"),\n                            (\"bar\", \"one\"),\n                            (\"baz\", \"two\"),\n                            (\"qux\", \"one\"),\n                            (\"qux\", \"two\"),\n                        ],\n                        dtype=\"object\",\n                    ),\n                    names=[\"A\", \"B\"],\n                ),\n            )",
        "begin_line": 117,
        "end_line": 168,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numeric_compat#170",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numeric_compat(self)",
        "snippet": "    def test_numeric_compat(self):\n\n        idx = self.create_index()\n        with pytest.raises(TypeError, match=\"cannot perform __mul__\"):\n            idx * 1\n        with pytest.raises(TypeError, match=\"cannot perform __rmul__\"):\n            1 * idx\n\n        div_err = \"cannot perform __truediv__\"\n        with pytest.raises(TypeError, match=div_err):\n            idx / 1\n\n        div_err = div_err.replace(\" __\", \" __r\")\n        with pytest.raises(TypeError, match=div_err):\n            1 / idx\n        with pytest.raises(TypeError, match=\"cannot perform __floordiv__\"):\n            idx // 1\n        with pytest.raises(TypeError, match=\"cannot perform __rfloordiv__\"):\n            1 // idx",
        "begin_line": 170,
        "end_line": 188,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_logical_compat#190",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_logical_compat(self)",
        "snippet": "    def test_logical_compat(self):\n        idx = self.create_index()\n        with pytest.raises(TypeError, match=\"cannot perform all\"):\n            idx.all()\n        with pytest.raises(TypeError, match=\"cannot perform any\"):\n            idx.any()",
        "begin_line": 190,
        "end_line": 195,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_boolean_context_compat#197",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_boolean_context_compat(self)",
        "snippet": "    def test_boolean_context_compat(self):\n\n        # boolean context compat\n        idx = self.create_index()\n\n        with pytest.raises(ValueError, match=\"The truth value of a\"):\n            if idx:\n                pass",
        "begin_line": 197,
        "end_line": 204,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_reindex_base#206",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_reindex_base(self)",
        "snippet": "    def test_reindex_base(self):\n        idx = self.create_index()\n        expected = np.arange(idx.size, dtype=np.intp)\n\n        actual = idx.get_indexer(idx)\n        tm.assert_numpy_array_equal(expected, actual)\n\n        with pytest.raises(ValueError, match=\"Invalid fill method\"):\n            idx.get_indexer(idx, method=\"invalid\")",
        "begin_line": 206,
        "end_line": 214,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_get_indexer_consistency#216",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_get_indexer_consistency(self)",
        "snippet": "    def test_get_indexer_consistency(self):\n        # See GH 16819\n        for name, index in self.indices.items():\n            if isinstance(index, IntervalIndex):\n                continue\n\n            if index.is_unique or isinstance(index, CategoricalIndex):\n                indexer = index.get_indexer(index[0:2])\n                assert isinstance(indexer, np.ndarray)\n                assert indexer.dtype == np.intp\n            else:\n                e = \"Reindexing only valid with uniquely valued Index objects\"\n                with pytest.raises(InvalidIndexError, match=e):\n                    index.get_indexer(index[0:2])\n\n            indexer, _ = index.get_indexer_non_unique(index[0:2])\n            assert isinstance(indexer, np.ndarray)\n            assert indexer.dtype == np.intp",
        "begin_line": 216,
        "end_line": 233,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_ndarray_compat_properties#235",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_ndarray_compat_properties(self)",
        "snippet": "    def test_ndarray_compat_properties(self):\n        idx = self.create_index()\n        assert idx.T.equals(idx)\n        assert idx.transpose().equals(idx)\n\n        values = idx.values\n        for prop in self._compat_props:\n            assert getattr(idx, prop) == getattr(values, prop)\n\n        # test for validity\n        idx.nbytes\n        idx.values.nbytes",
        "begin_line": 235,
        "end_line": 246,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repr_roundtrip#248",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repr_roundtrip(self)",
        "snippet": "    def test_repr_roundtrip(self):\n\n        idx = self.create_index()\n        tm.assert_index_equal(eval(repr(idx)), idx)",
        "begin_line": 248,
        "end_line": 251,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_str#253",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_str(self)",
        "snippet": "    def test_str(self):\n\n        # test the string repr\n        idx = self.create_index()\n        idx.name = \"foo\"\n        assert \"'foo'\" in str(idx)\n        assert idx.__class__.__name__ in str(idx)",
        "begin_line": 253,
        "end_line": 259,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repr_max_seq_item_setting#261",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repr_max_seq_item_setting(self)",
        "snippet": "    def test_repr_max_seq_item_setting(self):\n        # GH10182\n        idx = self.create_index()\n        idx = idx.repeat(50)\n        with pd.option_context(\"display.max_seq_items\", None):\n            repr(idx)\n            assert \"...\" not in str(idx)",
        "begin_line": 261,
        "end_line": 267,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_copy_name#269",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_copy_name(self)",
        "snippet": "    def test_copy_name(self):\n        # gh-12309: Check that the \"name\" argument\n        # passed at initialization is honored.\n\n        for name, index in self.indices.items():\n            if isinstance(index, MultiIndex):\n                continue\n\n            first = index.__class__(index, copy=True, name=\"mario\")\n            second = first.__class__(first, copy=False)\n\n            # Even though \"copy=False\", we want a new object.\n            assert first is not second\n\n            # Not using tm.assert_index_equal() since names differ.\n            assert index.equals(first)\n\n            assert first.name == \"mario\"\n            assert second.name == \"mario\"\n\n            s1 = Series(2, index=first)\n            s2 = Series(3, index=second[:-1])\n\n            if not isinstance(index, CategoricalIndex):\n                # See gh-13365\n                s3 = s1 * s2\n                assert s3.index.name == \"mario\"",
        "begin_line": 269,
        "end_line": 295,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_ensure_copied_data#297",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_ensure_copied_data(self)",
        "snippet": "    def test_ensure_copied_data(self):\n        # Check the \"copy\" argument of each Index.__new__ is honoured\n        # GH12309\n        for name, index in self.indices.items():\n            init_kwargs = {}\n            if isinstance(index, PeriodIndex):\n                # Needs \"freq\" specification:\n                init_kwargs[\"freq\"] = index.freq\n            elif isinstance(index, (RangeIndex, MultiIndex, CategoricalIndex)):\n                # RangeIndex cannot be initialized from data\n                # MultiIndex and CategoricalIndex are tested separately\n                continue\n\n            index_type = index.__class__\n            result = index_type(index.values, copy=True, **init_kwargs)\n            tm.assert_index_equal(index, result)\n            tm.assert_numpy_array_equal(\n                index._ndarray_values, result._ndarray_values, check_same=\"copy\"\n            )\n\n            if isinstance(index, PeriodIndex):\n                # .values an object array of Period, thus copied\n                result = index_type(ordinal=index.asi8, copy=False, **init_kwargs)\n                tm.assert_numpy_array_equal(\n                    index._ndarray_values, result._ndarray_values, check_same=\"same\"\n                )\n            elif isinstance(index, IntervalIndex):\n                # checked in test_interval.py\n                pass\n            else:\n                result = index_type(index.values, copy=False, **init_kwargs)\n                tm.assert_numpy_array_equal(\n                    index.values, result.values, check_same=\"same\"\n                )\n                tm.assert_numpy_array_equal(\n                    index._ndarray_values, result._ndarray_values, check_same=\"same\"\n                )",
        "begin_line": 297,
        "end_line": 333,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_memory_usage#335",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_memory_usage(self)",
        "snippet": "    def test_memory_usage(self):\n        for name, index in self.indices.items():\n            result = index.memory_usage()\n            if len(index):\n                index.get_loc(index[0])\n                result2 = index.memory_usage()\n                result3 = index.memory_usage(deep=True)\n\n                # RangeIndex, IntervalIndex\n                # don't have engines\n                if not isinstance(index, (RangeIndex, IntervalIndex)):\n                    assert result2 > result\n\n                if index.inferred_type == \"object\":\n                    assert result3 > result2\n\n            else:\n\n                # we report 0 for no-length\n                assert result == 0",
        "begin_line": 335,
        "end_line": 354,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_argsort#356",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_argsort(self)",
        "snippet": "    def test_argsort(self):\n        for k, ind in self.indices.items():\n\n            # separately tested\n            if k in [\"catIndex\"]:\n                continue\n\n            result = ind.argsort()\n            expected = np.array(ind).argsort()\n            tm.assert_numpy_array_equal(result, expected, check_dtype=False)",
        "begin_line": 356,
        "end_line": 365,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numpy_argsort#367",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numpy_argsort(self)",
        "snippet": "    def test_numpy_argsort(self):\n        for k, ind in self.indices.items():\n            result = np.argsort(ind)\n            expected = ind.argsort()\n            tm.assert_numpy_array_equal(result, expected)\n\n            # these are the only two types that perform\n            # pandas compatibility input validation - the\n            # rest already perform separate (or no) such\n            # validation via their 'values' attribute as\n            # defined in pandas.core.indexes/base.py - they\n            # cannot be changed at the moment due to\n            # backwards compatibility concerns\n            if isinstance(type(ind), (CategoricalIndex, RangeIndex)):\n                msg = \"the 'axis' parameter is not supported\"\n                with pytest.raises(ValueError, match=msg):\n                    np.argsort(ind, axis=1)\n\n                msg = \"the 'kind' parameter is not supported\"\n                with pytest.raises(ValueError, match=msg):\n                    np.argsort(ind, kind=\"mergesort\")\n\n                msg = \"the 'order' parameter is not supported\"\n                with pytest.raises(ValueError, match=msg):\n                    np.argsort(ind, order=(\"a\", \"b\"))",
        "begin_line": 367,
        "end_line": 391,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_take#393",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_take(self)",
        "snippet": "    def test_take(self):\n        indexer = [4, 3, 0, 2]\n        for k, ind in self.indices.items():\n\n            # separate\n            if k in [\"boolIndex\", \"tuples\", \"empty\"]:\n                continue\n\n            result = ind.take(indexer)\n            expected = ind[indexer]\n            assert result.equals(expected)\n\n            if not isinstance(ind, (DatetimeIndex, PeriodIndex, TimedeltaIndex)):\n                # GH 10791\n                with pytest.raises(AttributeError):\n                    ind.freq",
        "begin_line": 393,
        "end_line": 408,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_take_invalid_kwargs#410",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_take_invalid_kwargs(self)",
        "snippet": "    def test_take_invalid_kwargs(self):\n        idx = self.create_index()\n        indices = [1, 2]\n\n        msg = r\"take\\(\\) got an unexpected keyword argument 'foo'\"\n        with pytest.raises(TypeError, match=msg):\n            idx.take(indices, foo=2)\n\n        msg = \"the 'out' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            idx.take(indices, out=indices)\n\n        msg = \"the 'mode' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            idx.take(indices, mode=\"clip\")",
        "begin_line": 410,
        "end_line": 424,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repeat#426",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repeat(self)",
        "snippet": "    def test_repeat(self):\n        rep = 2\n        i = self.create_index()\n        expected = pd.Index(i.values.repeat(rep), name=i.name)\n        tm.assert_index_equal(i.repeat(rep), expected)\n\n        i = self.create_index()\n        rep = np.arange(len(i))\n        expected = pd.Index(i.values.repeat(rep), name=i.name)\n        tm.assert_index_equal(i.repeat(rep), expected)",
        "begin_line": 426,
        "end_line": 435,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numpy_repeat#437",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numpy_repeat(self)",
        "snippet": "    def test_numpy_repeat(self):\n        rep = 2\n        i = self.create_index()\n        expected = i.repeat(rep)\n        tm.assert_index_equal(np.repeat(i, rep), expected)\n\n        msg = \"the 'axis' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            np.repeat(i, rep, axis=0)",
        "begin_line": 437,
        "end_line": 445,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_where#448",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_where(self, klass)",
        "snippet": "    def test_where(self, klass):\n        i = self.create_index()\n\n        cond = [True] * len(i)\n        result = i.where(klass(cond))\n        expected = i\n        tm.assert_index_equal(result, expected)\n\n        cond = [False] + [True] * len(i[1:])\n        expected = pd.Index([i._na_value] + i[1:].tolist(), dtype=i.dtype)\n        result = i.where(klass(cond))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 448,
        "end_line": 459,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_set_ops_error_cases#465",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_set_ops_error_cases(self, case, method)",
        "snippet": "    def test_set_ops_error_cases(self, case, method):\n        for name, idx in self.indices.items():\n            # non-iterable input\n\n            msg = \"Input must be Index or array-like\"\n            with pytest.raises(TypeError, match=msg):\n                getattr(idx, method)(case)",
        "begin_line": 465,
        "end_line": 471,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_intersection_base#473",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_intersection_base(self)",
        "snippet": "    def test_intersection_base(self):\n        for name, idx in self.indices.items():\n            first = idx[:5]\n            second = idx[:3]\n            intersect = first.intersection(second)\n\n            if isinstance(idx, CategoricalIndex):\n                pass\n            else:\n                assert tm.equalContents(intersect, second)\n\n            # GH 10149\n            cases = [klass(second.values) for klass in [np.array, Series, list]]\n            for case in cases:\n                if isinstance(idx, CategoricalIndex):\n                    pass\n                else:\n                    result = first.intersection(case)\n                    assert tm.equalContents(result, second)\n\n            if isinstance(idx, MultiIndex):\n                msg = \"other must be a MultiIndex or a list of tuples\"\n                with pytest.raises(TypeError, match=msg):\n                    first.intersection([1, 2, 3])",
        "begin_line": 473,
        "end_line": 496,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_union_base#498",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_union_base(self)",
        "snippet": "    def test_union_base(self):\n        for name, idx in self.indices.items():\n            first = idx[3:]\n            second = idx[:5]\n            everything = idx\n            union = first.union(second)\n            assert tm.equalContents(union, everything)\n\n            # GH 10149\n            cases = [klass(second.values) for klass in [np.array, Series, list]]\n            for case in cases:\n                if isinstance(idx, CategoricalIndex):\n                    pass\n                else:\n                    result = first.union(case)\n                    assert tm.equalContents(result, everything)\n\n            if isinstance(idx, MultiIndex):\n                msg = \"other must be a MultiIndex or a list of tuples\"\n                with pytest.raises(TypeError, match=msg):\n                    first.union([1, 2, 3])",
        "begin_line": 498,
        "end_line": 518,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_difference_base#521",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_difference_base(self, sort)",
        "snippet": "    def test_difference_base(self, sort):\n        for name, idx in self.indices.items():\n            first = idx[2:]\n            second = idx[:4]\n            answer = idx[4:]\n            result = first.difference(second, sort)\n\n            if isinstance(idx, CategoricalIndex):\n                pass\n            else:\n                assert tm.equalContents(result, answer)\n\n            # GH 10149\n            cases = [klass(second.values) for klass in [np.array, Series, list]]\n            for case in cases:\n                if isinstance(idx, CategoricalIndex):\n                    pass\n                elif isinstance(idx, (DatetimeIndex, TimedeltaIndex)):\n                    assert result.__class__ == answer.__class__\n                    tm.assert_numpy_array_equal(\n                        result.sort_values().asi8, answer.sort_values().asi8\n                    )\n                else:\n                    result = first.difference(case, sort)\n                    assert tm.equalContents(result, answer)\n\n            if isinstance(idx, MultiIndex):\n                msg = \"other must be a MultiIndex or a list of tuples\"\n                with pytest.raises(TypeError, match=msg):\n                    first.difference([1, 2, 3], sort)",
        "begin_line": 521,
        "end_line": 550,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_symmetric_difference#552",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_symmetric_difference(self)",
        "snippet": "    def test_symmetric_difference(self):\n        for name, idx in self.indices.items():\n            first = idx[1:]\n            second = idx[:-1]\n            if isinstance(idx, CategoricalIndex):\n                pass\n            else:\n                answer = idx[[0, -1]]\n                result = first.symmetric_difference(second)\n                assert tm.equalContents(result, answer)\n\n            # GH 10149\n            cases = [klass(second.values) for klass in [np.array, Series, list]]\n            for case in cases:\n                if isinstance(idx, CategoricalIndex):\n                    pass\n                else:\n                    result = first.symmetric_difference(case)\n                    assert tm.equalContents(result, answer)\n\n            if isinstance(idx, MultiIndex):\n                msg = \"other must be a MultiIndex or a list of tuples\"\n                with pytest.raises(TypeError, match=msg):\n                    first.symmetric_difference([1, 2, 3])",
        "begin_line": 552,
        "end_line": 575,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_insert_base#577",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_insert_base(self)",
        "snippet": "    def test_insert_base(self):\n\n        for name, idx in self.indices.items():\n            result = idx[1:4]\n\n            if not len(idx):\n                continue\n\n            # test 0th element\n            assert idx[0:4].equals(result.insert(0, idx[0]))",
        "begin_line": 577,
        "end_line": 586,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_delete_base#588",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_delete_base(self)",
        "snippet": "    def test_delete_base(self):\n\n        for name, idx in self.indices.items():\n\n            if not len(idx):\n                continue\n\n            if isinstance(idx, RangeIndex):\n                # tested in class\n                continue\n\n            expected = idx[1:]\n            result = idx.delete(0)\n            assert result.equals(expected)\n            assert result.name == expected.name\n\n            expected = idx[:-1]\n            result = idx.delete(-1)\n            assert result.equals(expected)\n            assert result.name == expected.name\n\n            with pytest.raises((IndexError, ValueError)):\n                # either depending on numpy version\n                idx.delete(len(idx))",
        "begin_line": 588,
        "end_line": 611,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_equals#613",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_equals(self)",
        "snippet": "    def test_equals(self):\n\n        for name, idx in self.indices.items():\n            assert idx.equals(idx)\n            assert idx.equals(idx.copy())\n            assert idx.equals(idx.astype(object))\n\n            assert not idx.equals(list(idx))\n            assert not idx.equals(np.array(idx))\n\n            # Cannot pass in non-int64 dtype to RangeIndex\n            if not isinstance(idx, RangeIndex):\n                same_values = Index(idx, dtype=object)\n                assert idx.equals(same_values)\n                assert same_values.equals(idx)\n\n            if idx.nlevels == 1:\n                # do not test MultiIndex\n                assert not idx.equals(pd.Series(idx))",
        "begin_line": 613,
        "end_line": 631,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_equals_op#633",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_equals_op(self)",
        "snippet": "    def test_equals_op(self):\n        # GH9947, GH10637\n        index_a = self.create_index()\n        if isinstance(index_a, PeriodIndex):\n            pytest.skip(\"Skip check for PeriodIndex\")\n\n        n = len(index_a)\n        index_b = index_a[0:-1]\n        index_c = index_a[0:-1].append(index_a[-2:-1])\n        index_d = index_a[0:1]\n\n        msg = \"Lengths must match|could not be broadcast\"\n        with pytest.raises(ValueError, match=msg):\n            index_a == index_b\n        expected1 = np.array([True] * n)\n        expected2 = np.array([True] * (n - 1) + [False])\n        tm.assert_numpy_array_equal(index_a == index_a, expected1)\n        tm.assert_numpy_array_equal(index_a == index_c, expected2)\n\n        # test comparisons with numpy arrays\n        array_a = np.array(index_a)\n        array_b = np.array(index_a[0:-1])\n        array_c = np.array(index_a[0:-1].append(index_a[-2:-1]))\n        array_d = np.array(index_a[0:1])\n        with pytest.raises(ValueError, match=msg):\n            index_a == array_b\n        tm.assert_numpy_array_equal(index_a == array_a, expected1)\n        tm.assert_numpy_array_equal(index_a == array_c, expected2)\n\n        # test comparisons with Series\n        series_a = Series(array_a)\n        series_b = Series(array_b)\n        series_c = Series(array_c)\n        series_d = Series(array_d)\n        with pytest.raises(ValueError, match=msg):\n            index_a == series_b\n\n        tm.assert_numpy_array_equal(index_a == series_a, expected1)\n        tm.assert_numpy_array_equal(index_a == series_c, expected2)\n\n        # cases where length is 1 for one of them\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == index_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == series_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == array_d\n        msg = \"Can only compare identically-labeled Series objects\"\n        with pytest.raises(ValueError, match=msg):\n            series_a == series_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            series_a == array_d\n\n        # comparing with a scalar should broadcast; note that we are excluding\n        # MultiIndex because in this case each item in the index is a tuple of\n        # length 2, and therefore is considered an array of length 2 in the\n        # comparison instead of a scalar\n        if not isinstance(index_a, MultiIndex):\n            expected3 = np.array([False] * (len(index_a) - 2) + [True, False])\n            # assuming the 2nd to last item is unique in the data\n            item = index_a[-2]\n            tm.assert_numpy_array_equal(index_a == item, expected3)\n            tm.assert_series_equal(series_a == item, Series(expected3))",
        "begin_line": 633,
        "end_line": 695,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_hasnans_isnans#697",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_hasnans_isnans(self)",
        "snippet": "    def test_hasnans_isnans(self):\n        # GH 11343, added tests for hasnans / isnans\n\n        for name, index in self.indices.items():\n            if isinstance(index, MultiIndex):\n                pass\n            else:\n                idx = index.copy()\n\n                # cases in indices doesn't include NaN\n                expected = np.array([False] * len(idx), dtype=bool)\n                tm.assert_numpy_array_equal(idx._isnan, expected)\n                assert idx.hasnans is False\n\n                idx = index.copy()\n                values = np.asarray(idx.values)\n\n                if len(index) == 0:\n                    continue\n                elif isinstance(index, DatetimeIndexOpsMixin):\n                    values[1] = iNaT\n                elif isinstance(index, (Int64Index, UInt64Index)):\n                    continue\n                else:\n                    values[1] = np.nan\n\n                if isinstance(index, PeriodIndex):\n                    idx = index.__class__(values, freq=index.freq)\n                else:\n                    idx = index.__class__(values)\n\n                expected = np.array([False] * len(idx), dtype=bool)\n                expected[1] = True\n                tm.assert_numpy_array_equal(idx._isnan, expected)\n                assert idx.hasnans is True",
        "begin_line": 697,
        "end_line": 731,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_fillna#733",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_fillna(self)",
        "snippet": "    def test_fillna(self):\n        # GH 11343\n        for name, index in self.indices.items():\n            if len(index) == 0:\n                pass\n            elif isinstance(index, MultiIndex):\n                idx = index.copy()\n                msg = \"isna is not defined for MultiIndex\"\n                with pytest.raises(NotImplementedError, match=msg):\n                    idx.fillna(idx[0])\n            else:\n                idx = index.copy()\n                result = idx.fillna(idx[0])\n                tm.assert_index_equal(result, idx)\n                assert result is not idx\n\n                msg = \"'value' must be a scalar, passed: \"\n                with pytest.raises(TypeError, match=msg):\n                    idx.fillna([idx[0]])\n\n                idx = index.copy()\n                values = np.asarray(idx.values)\n\n                if isinstance(index, DatetimeIndexOpsMixin):\n                    values[1] = iNaT\n                elif isinstance(index, (Int64Index, UInt64Index)):\n                    continue\n                else:\n                    values[1] = np.nan\n\n                if isinstance(index, PeriodIndex):\n                    idx = index.__class__(values, freq=index.freq)\n                else:\n                    idx = index.__class__(values)\n\n                expected = np.array([False] * len(idx), dtype=bool)\n                expected[1] = True\n                tm.assert_numpy_array_equal(idx._isnan, expected)\n                assert idx.hasnans is True",
        "begin_line": 733,
        "end_line": 771,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_nulls#773",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_nulls(self)",
        "snippet": "    def test_nulls(self):\n        # this is really a smoke test for the methods\n        # as these are adequately tested for function elsewhere\n\n        for name, index in self.indices.items():\n            if len(index) == 0:\n                tm.assert_numpy_array_equal(index.isna(), np.array([], dtype=bool))\n            elif isinstance(index, MultiIndex):\n                idx = index.copy()\n                msg = \"isna is not defined for MultiIndex\"\n                with pytest.raises(NotImplementedError, match=msg):\n                    idx.isna()\n            else:\n\n                if not index.hasnans:\n                    tm.assert_numpy_array_equal(\n                        index.isna(), np.zeros(len(index), dtype=bool)\n                    )\n                    tm.assert_numpy_array_equal(\n                        index.notna(), np.ones(len(index), dtype=bool)\n                    )\n                else:\n                    result = isna(index)\n                    tm.assert_numpy_array_equal(index.isna(), result)\n                    tm.assert_numpy_array_equal(index.notna(), ~result)",
        "begin_line": 773,
        "end_line": 797,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_empty#799",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_empty(self)",
        "snippet": "    def test_empty(self):\n        # GH 15270\n        index = self.create_index()\n        assert not index.empty\n        assert index[:0].empty",
        "begin_line": 799,
        "end_line": 803,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_join_self_unique#805",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_join_self_unique(self, join_type)",
        "snippet": "    def test_join_self_unique(self, join_type):\n        index = self.create_index()\n        if index.is_unique:\n            joined = index.join(index, how=join_type)\n            assert (index == joined).all()",
        "begin_line": 805,
        "end_line": 809,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_map#811",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_map(self)",
        "snippet": "    def test_map(self):\n        # callable\n        index = self.create_index()\n\n        # we don't infer UInt64\n        if isinstance(index, pd.UInt64Index):\n            expected = index.astype(\"int64\")\n        else:\n            expected = index\n\n        result = index.map(lambda x: x)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 811,
        "end_line": 822,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_map_dictlike#831",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_map_dictlike(self, mapper)",
        "snippet": "    def test_map_dictlike(self, mapper):\n\n        index = self.create_index()\n        if isinstance(index, (pd.CategoricalIndex, pd.IntervalIndex)):\n            pytest.skip(\"skipping tests for {}\".format(type(index)))\n\n        identity = mapper(index.values, index)\n\n        # we don't infer to UInt64 for a dict\n        if isinstance(index, pd.UInt64Index) and isinstance(identity, dict):\n            expected = index.astype(\"int64\")\n        else:\n            expected = index\n\n        result = index.map(identity)\n        tm.assert_index_equal(result, expected)\n\n        # empty mappable\n        expected = pd.Index([np.nan] * len(index))\n        result = index.map(mapper(expected, index))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 831,
        "end_line": 851,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_putmask_with_wrong_mask#853",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_putmask_with_wrong_mask(self)",
        "snippet": "    def test_putmask_with_wrong_mask(self):\n        # GH18368\n        index = self.create_index()\n\n        with pytest.raises(ValueError):\n            index.putmask(np.ones(len(index) + 1, np.bool), 1)\n\n        with pytest.raises(ValueError):\n            index.putmask(np.ones(len(index) - 1, np.bool), 1)\n\n        with pytest.raises(ValueError):\n            index.putmask(\"foo\", 1)",
        "begin_line": 853,
        "end_line": 864,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_astype_category#869",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_astype_category(self, copy, name, ordered)",
        "snippet": "    def test_astype_category(self, copy, name, ordered):\n        # GH 18630\n        index = self.create_index()\n        if name:\n            index = index.rename(name)\n\n        # standard categories\n        dtype = CategoricalDtype(ordered=ordered)\n        result = index.astype(dtype, copy=copy)\n        expected = CategoricalIndex(index.values, name=name, ordered=ordered)\n        tm.assert_index_equal(result, expected)\n\n        # non-standard categories\n        dtype = CategoricalDtype(index.unique().tolist()[:-1], ordered)\n        result = index.astype(dtype, copy=copy)\n        expected = CategoricalIndex(index.values, name=name, dtype=dtype)\n        tm.assert_index_equal(result, expected)\n\n        if ordered is False:\n            # dtype='category' defaults to ordered=False, so only test once\n            result = index.astype(\"category\", copy=copy)\n            expected = CategoricalIndex(index.values, name=name)\n            tm.assert_index_equal(result, expected)",
        "begin_line": 869,
        "end_line": 891,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_is_unique#893",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_is_unique(self)",
        "snippet": "    def test_is_unique(self):\n        # initialize a unique index\n        index = self.create_index().drop_duplicates()\n        assert index.is_unique is True\n\n        # empty index should be unique\n        index_empty = index[:0]\n        assert index_empty.is_unique is True\n\n        # test basic dupes\n        index_dup = index.insert(0, index[0])\n        assert index_dup.is_unique is False\n\n        # single NA should be unique\n        index_na = index.insert(0, np.nan)\n        assert index_na.is_unique is True\n\n        # multiple NA should not be unique\n        index_na_dup = index_na.insert(0, np.nan)\n        assert index_na_dup.is_unique is False",
        "begin_line": 893,
        "end_line": 912,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_engine_reference_cycle#914",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_engine_reference_cycle(self)",
        "snippet": "    def test_engine_reference_cycle(self):\n        # GH27585\n        index = self.create_index()\n        nrefs_pre = len(gc.get_referrers(index))\n        index._engine\n        assert len(gc.get_referrers(index)) == nrefs_pre",
        "begin_line": 914,
        "end_line": 919,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.idx#9",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.idx()",
        "snippet": "def idx():\n    # a MultiIndex used to test the general functionality of the\n    # general functionality of this object\n    major_axis = Index([\"foo\", \"bar\", \"baz\", \"qux\"])\n    minor_axis = Index([\"one\", \"two\"])\n\n    major_codes = np.array([0, 0, 1, 2, 3, 3])\n    minor_codes = np.array([0, 1, 0, 1, 0, 1])\n    index_names = [\"first\", \"second\"]\n    mi = MultiIndex(\n        levels=[major_axis, minor_axis],\n        codes=[major_codes, minor_codes],\n        names=index_names,\n        verify_integrity=False,\n    )\n    return mi",
        "begin_line": 9,
        "end_line": 24,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.idx_dup#28",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.idx_dup()",
        "snippet": "def idx_dup():\n    # compare tests/indexes/multi/conftest.py\n    major_axis = Index([\"foo\", \"bar\", \"baz\", \"qux\"])\n    minor_axis = Index([\"one\", \"two\"])\n\n    major_codes = np.array([0, 0, 1, 0, 1, 1])\n    minor_codes = np.array([0, 1, 0, 1, 0, 1])\n    index_names = [\"first\", \"second\"]\n    mi = MultiIndex(\n        levels=[major_axis, minor_axis],\n        codes=[major_codes, minor_codes],\n        names=index_names,\n        verify_integrity=False,\n    )\n    return mi",
        "begin_line": 28,
        "end_line": 42,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.index_names#46",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.index_names()",
        "snippet": "def index_names():\n    # names that match those in the idx fixture for testing equality of\n    # names assigned to the idx\n    return [\"first\", \"second\"]",
        "begin_line": 46,
        "end_line": 49,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.holder#53",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.holder()",
        "snippet": "def holder():\n    # the MultiIndex constructor used to base compatibility with pickle\n    return MultiIndex",
        "begin_line": 53,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.compat_props#59",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.compat_props()",
        "snippet": "def compat_props():\n    # a MultiIndex must have these properties associated with it\n    return [\"shape\", \"ndim\", \"size\"]",
        "begin_line": 59,
        "end_line": 61,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.narrow_multi_index#65",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.narrow_multi_index()",
        "snippet": "def narrow_multi_index():\n    \"\"\"\n    Return a MultiIndex that is narrower than the display (<80 characters).\n    \"\"\"\n    n = 1000\n    ci = pd.CategoricalIndex(list(\"a\" * n) + ([\"abc\"] * n))\n    dti = pd.date_range(\"2000-01-01\", freq=\"s\", periods=n * 2)\n    return pd.MultiIndex.from_arrays([ci, ci.codes + 9, dti], names=[\"a\", \"b\", \"dti\"])",
        "begin_line": 65,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.wide_multi_index#76",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.wide_multi_index()",
        "snippet": "def wide_multi_index():\n    \"\"\"\n    Return a MultiIndex that is wider than the display (>80 characters).\n    \"\"\"\n    n = 1000\n    ci = pd.CategoricalIndex(list(\"a\" * n) + ([\"abc\"] * n))\n    dti = pd.date_range(\"2000-01-01\", freq=\"s\", periods=n * 2)\n    levels = [ci, ci.codes + 9, dti, dti, dti]\n    names = [\"a\", \"b\", \"dti_1\", \"dti_2\", \"dti_3\"]\n    return pd.MultiIndex.from_arrays(levels, names=names)",
        "begin_line": 76,
        "end_line": 85,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_argmax_axis_invalid#12",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_argmax_axis_invalid(self)",
        "snippet": "    def test_argmax_axis_invalid(self):\n        # GH#23081\n        rng = self.create_index()\n        with pytest.raises(ValueError):\n            rng.argmax(axis=1)\n        with pytest.raises(ValueError):\n            rng.argmin(axis=2)\n        with pytest.raises(ValueError):\n            rng.min(axis=-2)\n        with pytest.raises(ValueError):\n            rng.max(axis=-3)",
        "begin_line": 12,
        "end_line": 22,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_can_hold_identifiers#24",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_can_hold_identifiers(self)",
        "snippet": "    def test_can_hold_identifiers(self):\n        idx = self.create_index()\n        key = idx[0]\n        assert idx._can_hold_identifiers_and_holds_name(key) is False",
        "begin_line": 24,
        "end_line": 27,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_shift_identity#29",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_shift_identity(self)",
        "snippet": "    def test_shift_identity(self):\n\n        idx = self.create_index()\n        tm.assert_index_equal(idx, idx.shift(0))",
        "begin_line": 29,
        "end_line": 32,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_str#34",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_str(self)",
        "snippet": "    def test_str(self):\n\n        # test the string repr\n        idx = self.create_index()\n        idx.name = \"foo\"\n        assert not \"length={}\".format(len(idx)) in str(idx)\n        assert \"'foo'\" in str(idx)\n        assert idx.__class__.__name__ in str(idx)\n\n        if hasattr(idx, \"tz\"):\n            if idx.tz is not None:\n                assert idx.tz in str(idx)\n        if hasattr(idx, \"freq\"):\n            assert \"freq='{idx.freqstr}'\".format(idx=idx) in str(idx)",
        "begin_line": 34,
        "end_line": 47,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_view#49",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_view(self)",
        "snippet": "    def test_view(self):\n        i = self.create_index()\n\n        i_view = i.view(\"i8\")\n        result = self._holder(i)\n        tm.assert_index_equal(result, i)\n\n        i_view = i.view(self._holder)\n        result = self._holder(i)\n        tm.assert_index_equal(result, i_view)",
        "begin_line": 49,
        "end_line": 58,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_callable#60",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_callable(self)",
        "snippet": "    def test_map_callable(self):\n        expected = self.index + self.index.freq\n        result = self.index.map(lambda x: x + x.freq)\n        tm.assert_index_equal(result, expected)\n\n        # map to NaT\n        result = self.index.map(lambda x: pd.NaT if x == self.index[0] else x)\n        expected = pd.Index([pd.NaT] + self.index[1:].tolist())\n        tm.assert_index_equal(result, expected)",
        "begin_line": 60,
        "end_line": 68,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_dictlike#77",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_dictlike(self, mapper)",
        "snippet": "    def test_map_dictlike(self, mapper):\n        expected = self.index + self.index.freq\n\n        # don't compare the freqs\n        if isinstance(expected, pd.DatetimeIndex):\n            expected.freq = None\n\n        result = self.index.map(mapper(expected, self.index))\n        tm.assert_index_equal(result, expected)\n\n        expected = pd.Index([pd.NaT] + self.index[1:].tolist())\n        result = self.index.map(mapper(expected, self.index))\n        tm.assert_index_equal(result, expected)\n\n        # empty map; these map to np.nan because we cannot know\n        # to re-infer things\n        expected = pd.Index([np.nan] * len(self.index))\n        result = self.index.map(mapper([], []))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 77,
        "end_line": 95,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_asobject_deprecated#97",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_asobject_deprecated(self)",
        "snippet": "    def test_asobject_deprecated(self):\n        # GH18572\n        d = self.create_index()\n        with tm.assert_produces_warning(FutureWarning):\n            i = d.asobject\n        assert isinstance(i, pd.Index)",
        "begin_line": 97,
        "end_line": 102,
        "comment": "",
        "is_bug": false
    }
]