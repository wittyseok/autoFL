[
    {
        "name": "lib.matplotlib.tests.test_colors.test_makeMappingArray#24",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_makeMappingArray(N, result)",
        "snippet": "def test_makeMappingArray(N, result):\n    data = [(0.0, 1.0, 1.0), (0.5, 0.2, 0.2), (1.0, 0.0, 0.0)]\n    assert_array_almost_equal(mcolors.makeMappingArray(N, data), result)",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_resample#29",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_resample()",
        "snippet": "def test_resample():\n    \"\"\"\n    Github issue #6025 pointed to incorrect ListedColormap._resample;\n    here we test the method for LinearSegmentedColormap as well.\n    \"\"\"\n    n = 101\n    colorlist = np.empty((n, 4), float)\n    colorlist[:, 0] = np.linspace(0, 1, n)\n    colorlist[:, 1] = 0.2\n    colorlist[:, 2] = np.linspace(1, 0, n)\n    colorlist[:, 3] = 0.7\n    lsc = mcolors.LinearSegmentedColormap.from_list('lsc', colorlist)\n    lc = mcolors.ListedColormap(colorlist)\n    lsc3 = lsc._resample(3)\n    lc3 = lc._resample(3)\n    expected = np.array([[0.0, 0.2, 1.0, 0.7],\n                         [0.5, 0.2, 0.5, 0.7],\n                         [1.0, 0.2, 0.0, 0.7]], float)\n    assert_array_almost_equal(lsc3([0, 0.5, 1]), expected)\n    assert_array_almost_equal(lc3([0, 0.5, 1]), expected)",
        "begin_line": 29,
        "end_line": 48,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_colormap_copy#51",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_colormap_copy()",
        "snippet": "def test_colormap_copy():\n    cm = plt.cm.Reds\n    cm_copy = copy.copy(cm)\n    with np.errstate(invalid='ignore'):\n        ret1 = cm_copy([-1, 0, .5, 1, np.nan, np.inf])\n    cm2 = copy.copy(cm_copy)\n    cm2.set_bad('g')\n    with np.errstate(invalid='ignore'):\n        ret2 = cm_copy([-1, 0, .5, 1, np.nan, np.inf])\n    assert_array_equal(ret1, ret2)",
        "begin_line": 51,
        "end_line": 60,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_colormap_endian#63",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_colormap_endian()",
        "snippet": "def test_colormap_endian():\n    \"\"\"\n    Github issue #1005: a bug in putmask caused erroneous\n    mapping of 1.0 when input from a non-native-byteorder\n    array.\n    \"\"\"\n    cmap = cm.get_cmap(\"jet\")\n    # Test under, over, and invalid along with values 0 and 1.\n    a = [-0.5, 0, 0.5, 1, 1.5, np.nan]\n    for dt in [\"f2\", \"f4\", \"f8\"]:\n        anative = np.ma.masked_invalid(np.array(a, dtype=dt))\n        aforeign = anative.byteswap().newbyteorder()\n        assert_array_equal(cmap(anative), cmap(aforeign))",
        "begin_line": 63,
        "end_line": 75,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_BoundaryNorm#78",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_BoundaryNorm()",
        "snippet": "def test_BoundaryNorm():\n    \"\"\"\n    Github issue #1258: interpolation was failing with numpy\n    1.7 pre-release.\n    \"\"\"\n\n    boundaries = [0, 1.1, 2.2]\n    vals = [-1, 0, 1, 2, 2.2, 4]\n\n    # Without interpolation\n    expected = [-1, 0, 0, 1, 2, 2]\n    ncolors = len(boundaries) - 1\n    bn = mcolors.BoundaryNorm(boundaries, ncolors)\n    assert_array_equal(bn(vals), expected)\n\n    # ncolors != len(boundaries) - 1 triggers interpolation\n    expected = [-1, 0, 0, 2, 3, 3]\n    ncolors = len(boundaries)\n    bn = mcolors.BoundaryNorm(boundaries, ncolors)\n    assert_array_equal(bn(vals), expected)\n\n    # more boundaries for a third color\n    boundaries = [0, 1, 2, 3]\n    vals = [-1, 0.1, 1.1, 2.2, 4]\n    ncolors = 5\n    expected = [-1, 0, 2, 4, 5]\n    bn = mcolors.BoundaryNorm(boundaries, ncolors)\n    assert_array_equal(bn(vals), expected)\n\n    # a scalar as input should not trigger an error and should return a scalar\n    boundaries = [0, 1, 2]\n    vals = [-1, 0.1, 1.1, 2.2]\n    bn = mcolors.BoundaryNorm(boundaries, 2)\n    expected = [-1, 0, 1, 2]\n    for v, ex in zip(vals, expected):\n        ret = bn(v)\n        assert isinstance(ret, int)\n        assert_array_equal(ret, ex)\n        assert_array_equal(bn([v]), ex)\n\n    # same with interp\n    bn = mcolors.BoundaryNorm(boundaries, 3)\n    expected = [-1, 0, 2, 3]\n    for v, ex in zip(vals, expected):\n        ret = bn(v)\n        assert isinstance(ret, int)\n        assert_array_equal(ret, ex)\n        assert_array_equal(bn([v]), ex)\n\n    # Clipping\n    bn = mcolors.BoundaryNorm(boundaries, 3, clip=True)\n    expected = [0, 0, 2, 2]\n    for v, ex in zip(vals, expected):\n        ret = bn(v)\n        assert isinstance(ret, int)\n        assert_array_equal(ret, ex)\n        assert_array_equal(bn([v]), ex)\n\n    # Masked arrays\n    boundaries = [0, 1.1, 2.2]\n    vals = np.ma.masked_invalid([-1., np.NaN, 0, 1.4, 9])\n\n    # Without interpolation\n    ncolors = len(boundaries) - 1\n    bn = mcolors.BoundaryNorm(boundaries, ncolors)\n    expected = np.ma.masked_array([-1, -99, 0, 1, 2], mask=[0, 1, 0, 0, 0])\n    assert_array_equal(bn(vals), expected)\n\n    # With interpolation\n    bn = mcolors.BoundaryNorm(boundaries, len(boundaries))\n    expected = np.ma.masked_array([-1, -99, 0, 2, 3], mask=[0, 1, 0, 0, 0])\n    assert_array_equal(bn(vals), expected)\n\n    # Non-trivial masked arrays\n    vals = np.ma.masked_invalid([np.Inf, np.NaN])\n    assert np.all(bn(vals).mask)\n    vals = np.ma.masked_invalid([np.Inf])\n    assert np.all(bn(vals).mask)",
        "begin_line": 78,
        "end_line": 155,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_LogNorm#158",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_LogNorm()",
        "snippet": "def test_LogNorm():\n    \"\"\"\n    LogNorm ignored clip, now it has the same\n    behavior as Normalize, e.g., values > vmax are bigger than 1\n    without clip, with clip they are 1.\n    \"\"\"\n    ln = mcolors.LogNorm(clip=True, vmax=5)\n    assert_array_equal(ln([1, 6]), [0, 1.0])",
        "begin_line": 158,
        "end_line": 165,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_PowerNorm#168",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_PowerNorm()",
        "snippet": "def test_PowerNorm():\n    a = np.array([0, 0.5, 1, 1.5], dtype=float)\n    pnorm = mcolors.PowerNorm(1)\n    norm = mcolors.Normalize()\n    assert_array_almost_equal(norm(a), pnorm(a))\n\n    a = np.array([-0.5, 0, 2, 4, 8], dtype=float)\n    expected = [0, 0, 1/16, 1/4, 1]\n    pnorm = mcolors.PowerNorm(2, vmin=0, vmax=8)\n    assert_array_almost_equal(pnorm(a), expected)\n    assert pnorm(a[0]) == expected[0]\n    assert pnorm(a[2]) == expected[2]\n    assert_array_almost_equal(a[1:], pnorm.inverse(pnorm(a))[1:])\n\n    # Clip = True\n    a = np.array([-0.5, 0, 1, 8, 16], dtype=float)\n    expected = [0, 0, 0, 1, 1]\n    pnorm = mcolors.PowerNorm(2, vmin=2, vmax=8, clip=True)\n    assert_array_almost_equal(pnorm(a), expected)\n    assert pnorm(a[0]) == expected[0]\n    assert pnorm(a[-1]) == expected[-1]\n\n    # Clip = True at call time\n    a = np.array([-0.5, 0, 1, 8, 16], dtype=float)\n    expected = [0, 0, 0, 1, 1]\n    pnorm = mcolors.PowerNorm(2, vmin=2, vmax=8, clip=False)\n    assert_array_almost_equal(pnorm(a, clip=True), expected)\n    assert pnorm(a[0], clip=True) == expected[0]\n    assert pnorm(a[-1], clip=True) == expected[-1]",
        "begin_line": 168,
        "end_line": 196,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_PowerNorm_translation_invariance#199",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_PowerNorm_translation_invariance()",
        "snippet": "def test_PowerNorm_translation_invariance():\n    a = np.array([0, 1/2, 1], dtype=float)\n    expected = [0, 1/8, 1]\n    pnorm = mcolors.PowerNorm(vmin=0, vmax=1, gamma=3)\n    assert_array_almost_equal(pnorm(a), expected)\n    pnorm = mcolors.PowerNorm(vmin=-2, vmax=-1, gamma=3)\n    assert_array_almost_equal(pnorm(a - 2), expected)",
        "begin_line": 199,
        "end_line": 205,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_Normalize#208",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_Normalize()",
        "snippet": "def test_Normalize():\n    norm = mcolors.Normalize()\n    vals = np.arange(-10, 10, 1, dtype=float)\n    _inverse_tester(norm, vals)\n    _scalar_tester(norm, vals)\n    _mask_tester(norm, vals)\n\n    # Handle integer input correctly (don't overflow when computing max-min,\n    # i.e. 127-(-128) here).\n    vals = np.array([-128, 127], dtype=np.int8)\n    norm = mcolors.Normalize(vals.min(), vals.max())\n    assert_array_equal(np.asarray(norm(vals)), [0, 1])\n\n    # Don't lose precision on longdoubles (float128 on Linux):\n    # for array inputs...\n    vals = np.array([1.2345678901, 9.8765432109], dtype=np.longdouble)\n    norm = mcolors.Normalize(vals.min(), vals.max())\n    assert_array_equal(np.asarray(norm(vals)), [0, 1])\n    # and for scalar ones.\n    eps = np.finfo(np.longdouble).resolution\n    norm = plt.Normalize(1, 1 + 100 * eps)\n    # This returns exactly 0.5 when longdouble is extended precision (80-bit),\n    # but only a value close to it when it is quadruple precision (128-bit).\n    assert 0 < norm(1 + 50 * eps) < 1",
        "begin_line": 208,
        "end_line": 231,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_DivergingNorm_autoscale#234",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_DivergingNorm_autoscale()",
        "snippet": "def test_DivergingNorm_autoscale():\n    norm = mcolors.DivergingNorm(vcenter=20)\n    norm.autoscale([10, 20, 30, 40])\n    assert norm.vmin == 10.\n    assert norm.vmax == 40.",
        "begin_line": 234,
        "end_line": 238,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_DivergingNorm_autoscale_None_vmin#241",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_DivergingNorm_autoscale_None_vmin()",
        "snippet": "def test_DivergingNorm_autoscale_None_vmin():\n    norm = mcolors.DivergingNorm(2, vmin=0, vmax=None)\n    norm.autoscale_None([1, 2, 3, 4, 5])\n    assert norm(5) == 1\n    assert norm.vmax == 5",
        "begin_line": 241,
        "end_line": 245,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_DivergingNorm_autoscale_None_vmax#248",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_DivergingNorm_autoscale_None_vmax()",
        "snippet": "def test_DivergingNorm_autoscale_None_vmax():\n    norm = mcolors.DivergingNorm(2, vmin=None, vmax=10)\n    norm.autoscale_None([1, 2, 3, 4, 5])\n    assert norm(1) == 0\n    assert norm.vmin == 1",
        "begin_line": 248,
        "end_line": 252,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_DivergingNorm_scale#255",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_DivergingNorm_scale()",
        "snippet": "def test_DivergingNorm_scale():\n    norm = mcolors.DivergingNorm(2)\n    assert norm.scaled() is False\n    norm([1, 2, 3, 4])\n    assert norm.scaled() is True",
        "begin_line": 255,
        "end_line": 259,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_DivergingNorm_scaleout_center#262",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_DivergingNorm_scaleout_center()",
        "snippet": "def test_DivergingNorm_scaleout_center():\n    # test the vmin never goes above vcenter\n    norm = mcolors.DivergingNorm(vcenter=0)\n    x = norm([1, 2, 3, 5])\n    assert norm.vmin == 0\n    assert norm.vmax == 5",
        "begin_line": 262,
        "end_line": 267,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_DivergingNorm_scaleout_center_max#270",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_DivergingNorm_scaleout_center_max()",
        "snippet": "def test_DivergingNorm_scaleout_center_max():\n    # test the vmax never goes below vcenter\n    norm = mcolors.DivergingNorm(vcenter=0)\n    x = norm([-1, -2, -3, -5])\n    assert norm.vmax == 0\n    assert norm.vmin == -5",
        "begin_line": 270,
        "end_line": 275,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_DivergingNorm_Even#278",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_DivergingNorm_Even()",
        "snippet": "def test_DivergingNorm_Even():\n    norm = mcolors.DivergingNorm(vmin=-1, vcenter=0, vmax=4)\n    vals = np.array([-1.0, -0.5, 0.0, 1.0, 2.0, 3.0, 4.0])\n    expected = np.array([0.0, 0.25, 0.5, 0.625, 0.75, 0.875, 1.0])\n    assert_array_equal(norm(vals), expected)",
        "begin_line": 278,
        "end_line": 282,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_DivergingNorm_Odd#285",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_DivergingNorm_Odd()",
        "snippet": "def test_DivergingNorm_Odd():\n    norm = mcolors.DivergingNorm(vmin=-2, vcenter=0, vmax=5)\n    vals = np.array([-2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0])\n    expected = np.array([0.0, 0.25, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])\n    assert_array_equal(norm(vals), expected)",
        "begin_line": 285,
        "end_line": 289,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_DivergingNorm_VminEqualsVcenter#292",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_DivergingNorm_VminEqualsVcenter()",
        "snippet": "def test_DivergingNorm_VminEqualsVcenter():\n    with pytest.raises(ValueError):\n        norm = mcolors.DivergingNorm(vmin=-2, vcenter=-2, vmax=2)",
        "begin_line": 292,
        "end_line": 294,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_DivergingNorm_VmaxEqualsVcenter#297",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_DivergingNorm_VmaxEqualsVcenter()",
        "snippet": "def test_DivergingNorm_VmaxEqualsVcenter():\n    with pytest.raises(ValueError):\n        norm = mcolors.DivergingNorm(vmin=-2, vcenter=2, vmax=2)",
        "begin_line": 297,
        "end_line": 299,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_DivergingNorm_VminGTVcenter#302",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_DivergingNorm_VminGTVcenter()",
        "snippet": "def test_DivergingNorm_VminGTVcenter():\n    with pytest.raises(ValueError):\n        norm = mcolors.DivergingNorm(vmin=10, vcenter=0, vmax=20)",
        "begin_line": 302,
        "end_line": 304,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_DivergingNorm_DivergingNorm_VminGTVmax#307",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_DivergingNorm_DivergingNorm_VminGTVmax()",
        "snippet": "def test_DivergingNorm_DivergingNorm_VminGTVmax():\n    with pytest.raises(ValueError):\n        norm = mcolors.DivergingNorm(vmin=10, vcenter=0, vmax=5)",
        "begin_line": 307,
        "end_line": 309,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_DivergingNorm_VcenterGTVmax#312",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_DivergingNorm_VcenterGTVmax()",
        "snippet": "def test_DivergingNorm_VcenterGTVmax():\n    vals = np.arange(50)\n    with pytest.raises(ValueError):\n        norm = mcolors.DivergingNorm(vmin=10, vcenter=25, vmax=20)",
        "begin_line": 312,
        "end_line": 315,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_DivergingNorm_premature_scaling#318",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_DivergingNorm_premature_scaling()",
        "snippet": "def test_DivergingNorm_premature_scaling():\n    norm = mcolors.DivergingNorm(vcenter=2)\n    with pytest.raises(ValueError):\n        norm.inverse(np.array([0.1, 0.5, 0.9]))",
        "begin_line": 318,
        "end_line": 321,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_SymLogNorm#324",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_SymLogNorm()",
        "snippet": "def test_SymLogNorm():\n    \"\"\"\n    Test SymLogNorm behavior\n    \"\"\"\n    norm = mcolors.SymLogNorm(3, vmax=5, linscale=1.2)\n    vals = np.array([-30, -1, 2, 6], dtype=float)\n    normed_vals = norm(vals)\n    expected = [0., 0.53980074, 0.826991, 1.02758204]\n    assert_array_almost_equal(normed_vals, expected)\n    _inverse_tester(norm, vals)\n    _scalar_tester(norm, vals)\n    _mask_tester(norm, vals)\n\n    # Ensure that specifying vmin returns the same result as above\n    norm = mcolors.SymLogNorm(3, vmin=-30, vmax=5, linscale=1.2)\n    normed_vals = norm(vals)\n    assert_array_almost_equal(normed_vals, expected)",
        "begin_line": 324,
        "end_line": 340,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_SymLogNorm_colorbar#343",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_SymLogNorm_colorbar()",
        "snippet": "def test_SymLogNorm_colorbar():\n    \"\"\"\n    Test un-called SymLogNorm in a colorbar.\n    \"\"\"\n    norm = mcolors.SymLogNorm(0.1, vmin=-1, vmax=1, linscale=1)\n    fig = plt.figure()\n    cbar = mcolorbar.ColorbarBase(fig.add_subplot(111), norm=norm)\n    plt.close(fig)",
        "begin_line": 343,
        "end_line": 350,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_SymLogNorm_single_zero#353",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_SymLogNorm_single_zero()",
        "snippet": "def test_SymLogNorm_single_zero():\n    \"\"\"\n    Test SymLogNorm to ensure it is not adding sub-ticks to zero label\n    \"\"\"\n    fig = plt.figure()\n    norm = mcolors.SymLogNorm(1e-5, vmin=-1, vmax=1)\n    cbar = mcolorbar.ColorbarBase(fig.add_subplot(111), norm=norm)\n    ticks = cbar.get_ticks()\n    assert sum(ticks == 0) == 1\n    plt.close(fig)",
        "begin_line": 353,
        "end_line": 362,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors._inverse_tester#365",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors._inverse_tester(norm_instance, vals)",
        "snippet": "def _inverse_tester(norm_instance, vals):\n    \"\"\"\n    Checks if the inverse of the given normalization is working.\n    \"\"\"\n    assert_array_almost_equal(norm_instance.inverse(norm_instance(vals)), vals)",
        "begin_line": 365,
        "end_line": 369,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors._scalar_tester#372",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors._scalar_tester(norm_instance, vals)",
        "snippet": "def _scalar_tester(norm_instance, vals):\n    \"\"\"\n    Checks if scalars and arrays are handled the same way.\n    Tests only for float.\n    \"\"\"\n    scalar_result = [norm_instance(float(v)) for v in vals]\n    assert_array_almost_equal(scalar_result, norm_instance(vals))",
        "begin_line": 372,
        "end_line": 378,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors._mask_tester#381",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors._mask_tester(norm_instance, vals)",
        "snippet": "def _mask_tester(norm_instance, vals):\n    \"\"\"\n    Checks mask handling\n    \"\"\"\n    masked_array = np.ma.array(vals)\n    masked_array[0] = np.ma.masked\n    assert_array_equal(masked_array.mask, norm_instance(masked_array).mask)",
        "begin_line": 381,
        "end_line": 387,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_cmap_and_norm_from_levels_and_colors#392",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_cmap_and_norm_from_levels_and_colors()",
        "snippet": "def test_cmap_and_norm_from_levels_and_colors():\n    data = np.linspace(-2, 4, 49).reshape(7, 7)\n    levels = [-1, 2, 2.5, 3]\n    colors = ['red', 'green', 'blue', 'yellow', 'black']\n    extend = 'both'\n    cmap, norm = mcolors.from_levels_and_colors(levels, colors, extend=extend)\n\n    ax = plt.axes()\n    m = plt.pcolormesh(data, cmap=cmap, norm=norm)\n    plt.colorbar(m)\n\n    # Hide the axes labels (but not the colorbar ones, as they are useful)\n    ax.tick_params(labelleft=False, labelbottom=False)",
        "begin_line": 392,
        "end_line": 404,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_cmap_and_norm_from_levels_and_colors2#407",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_cmap_and_norm_from_levels_and_colors2()",
        "snippet": "def test_cmap_and_norm_from_levels_and_colors2():\n    levels = [-1, 2, 2.5, 3]\n    colors = ['red', (0, 1, 0), 'blue', (0.5, 0.5, 0.5), (0.0, 0.0, 0.0, 1.0)]\n    clr = mcolors.to_rgba_array(colors)\n    bad = (0.1, 0.1, 0.1, 0.1)\n    no_color = (0.0, 0.0, 0.0, 0.0)\n    masked_value = 'masked_value'\n\n    # Define the test values which are of interest.\n    # Note: levels are lev[i] <= v < lev[i+1]\n    tests = [('both', None, {-2: clr[0],\n                             -1: clr[1],\n                             2: clr[2],\n                             2.25: clr[2],\n                             3: clr[4],\n                             3.5: clr[4],\n                             masked_value: bad}),\n\n             ('min', -1, {-2: clr[0],\n                          -1: clr[1],\n                          2: clr[2],\n                          2.25: clr[2],\n                          3: no_color,\n                          3.5: no_color,\n                          masked_value: bad}),\n\n             ('max', -1, {-2: no_color,\n                          -1: clr[0],\n                          2: clr[1],\n                          2.25: clr[1],\n                          3: clr[3],\n                          3.5: clr[3],\n                          masked_value: bad}),\n\n             ('neither', -2, {-2: no_color,\n                              -1: clr[0],\n                              2: clr[1],\n                              2.25: clr[1],\n                              3: no_color,\n                              3.5: no_color,\n                              masked_value: bad}),\n             ]\n\n    for extend, i1, cases in tests:\n        cmap, norm = mcolors.from_levels_and_colors(levels, colors[0:i1],\n                                                    extend=extend)\n        cmap.set_bad(bad)\n        for d_val, expected_color in cases.items():\n            if d_val == masked_value:\n                d_val = np.ma.array([1], mask=True)\n            else:\n                d_val = [d_val]\n            assert_array_equal(expected_color, cmap(norm(d_val))[0],\n                               'Wih extend={0!r} and data '\n                               'value={1!r}'.format(extend, d_val))\n\n    with pytest.raises(ValueError):\n        mcolors.from_levels_and_colors(levels, colors)",
        "begin_line": 407,
        "end_line": 464,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_rgb_hsv_round_trip#467",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_rgb_hsv_round_trip()",
        "snippet": "def test_rgb_hsv_round_trip():\n    for a_shape in [(500, 500, 3), (500, 3), (1, 3), (3,)]:\n        np.random.seed(0)\n        tt = np.random.random(a_shape)\n        assert_array_almost_equal(tt,\n            mcolors.hsv_to_rgb(mcolors.rgb_to_hsv(tt)))\n        assert_array_almost_equal(tt,\n            mcolors.rgb_to_hsv(mcolors.hsv_to_rgb(tt)))",
        "begin_line": 467,
        "end_line": 474,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_autoscale_masked#477",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_autoscale_masked()",
        "snippet": "def test_autoscale_masked():\n    # Test for #2336. Previously fully masked data would trigger a ValueError.\n    data = np.ma.masked_all((12, 20))\n    plt.pcolor(data)\n    plt.draw()",
        "begin_line": 477,
        "end_line": 481,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_colors_no_float#484",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_colors_no_float()",
        "snippet": "def test_colors_no_float():\n    # Gray must be a string to distinguish 3-4 grays from RGB or RGBA.\n    with pytest.raises(ValueError):\n        mcolors.to_rgba(0.4)",
        "begin_line": 484,
        "end_line": 487,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_light_source_topo_surface#492",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_light_source_topo_surface()",
        "snippet": "def test_light_source_topo_surface():\n    \"\"\"Shades a DEM using different v.e.'s and blend modes.\"\"\"\n    with cbook.get_sample_data('jacksboro_fault_dem.npz') as file, \\\n         np.load(file) as dem:\n        elev = dem['elevation']\n        dx, dy = dem['dx'], dem['dy']\n        # Get the true cellsize in meters for accurate vertical exaggeration\n        # Convert from decimal degrees to meters\n        dx = 111320.0 * dx * np.cos(dem['ymin'])\n        dy = 111320.0 * dy\n\n    ls = mcolors.LightSource(315, 45)\n    cmap = cm.gist_earth\n\n    fig, axes = plt.subplots(nrows=3, ncols=3)\n    for row, mode in zip(axes, ['hsv', 'overlay', 'soft']):\n        for ax, ve in zip(row, [0.1, 1, 10]):\n            rgb = ls.shade(elev, cmap, vert_exag=ve, dx=dx, dy=dy,\n                           blend_mode=mode)\n            ax.imshow(rgb)\n            ax.set(xticks=[], yticks=[])",
        "begin_line": 492,
        "end_line": 512,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_light_source_shading_default#515",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_light_source_shading_default()",
        "snippet": "def test_light_source_shading_default():\n    \"\"\"Array comparison test for the default \"hsv\" blend mode. Ensure the\n    default result doesn't change without warning.\"\"\"\n    y, x = np.mgrid[-1.2:1.2:8j, -1.2:1.2:8j]\n    z = 10 * np.cos(x**2 + y**2)\n\n    cmap = plt.cm.copper\n    ls = mcolors.LightSource(315, 45)\n    rgb = ls.shade(z, cmap)\n\n    # Result stored transposed and rounded for more compact display...\n    expect = np.array(\n        [[[0.00, 0.45, 0.90, 0.90, 0.82, 0.62, 0.28, 0.00],\n          [0.45, 0.94, 0.99, 1.00, 1.00, 0.96, 0.65, 0.17],\n          [0.90, 0.99, 1.00, 1.00, 1.00, 1.00, 0.94, 0.35],\n          [0.90, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 0.49],\n          [0.82, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 0.41],\n          [0.62, 0.96, 1.00, 1.00, 1.00, 1.00, 0.90, 0.07],\n          [0.28, 0.65, 0.94, 1.00, 1.00, 0.90, 0.35, 0.01],\n          [0.00, 0.17, 0.35, 0.49, 0.41, 0.07, 0.01, 0.00]],\n\n         [[0.00, 0.28, 0.59, 0.72, 0.62, 0.40, 0.18, 0.00],\n          [0.28, 0.78, 0.93, 0.92, 0.83, 0.66, 0.39, 0.11],\n          [0.59, 0.93, 0.99, 1.00, 0.92, 0.75, 0.50, 0.21],\n          [0.72, 0.92, 1.00, 0.99, 0.93, 0.76, 0.51, 0.18],\n          [0.62, 0.83, 0.92, 0.93, 0.87, 0.68, 0.42, 0.08],\n          [0.40, 0.66, 0.75, 0.76, 0.68, 0.52, 0.23, 0.02],\n          [0.18, 0.39, 0.50, 0.51, 0.42, 0.23, 0.00, 0.00],\n          [0.00, 0.11, 0.21, 0.18, 0.08, 0.02, 0.00, 0.00]],\n\n         [[0.00, 0.18, 0.38, 0.46, 0.39, 0.26, 0.11, 0.00],\n          [0.18, 0.50, 0.70, 0.75, 0.64, 0.44, 0.25, 0.07],\n          [0.38, 0.70, 0.91, 0.98, 0.81, 0.51, 0.29, 0.13],\n          [0.46, 0.75, 0.98, 0.96, 0.84, 0.48, 0.22, 0.12],\n          [0.39, 0.64, 0.81, 0.84, 0.71, 0.31, 0.11, 0.05],\n          [0.26, 0.44, 0.51, 0.48, 0.31, 0.10, 0.03, 0.01],\n          [0.11, 0.25, 0.29, 0.22, 0.11, 0.03, 0.00, 0.00],\n          [0.00, 0.07, 0.13, 0.12, 0.05, 0.01, 0.00, 0.00]],\n\n         [[1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00]]\n        ]).T\n\n    assert_array_almost_equal(rgb, expect, decimal=2)",
        "begin_line": 515,
        "end_line": 564,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_light_source_masked_shading#570",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_light_source_masked_shading()",
        "snippet": "def test_light_source_masked_shading():\n    \"\"\"Array comparison test for a surface with a masked portion. Ensures that\n    we don't wind up with \"fringes\" of odd colors around masked regions.\"\"\"\n    y, x = np.mgrid[-1.2:1.2:8j, -1.2:1.2:8j]\n    z = 10 * np.cos(x**2 + y**2)\n\n    z = np.ma.masked_greater(z, 9.9)\n\n    cmap = plt.cm.copper\n    ls = mcolors.LightSource(315, 45)\n    rgb = ls.shade(z, cmap)\n\n    # Result stored transposed and rounded for more compact display...\n    expect = np.array(\n        [[[0.00, 0.46, 0.91, 0.91, 0.84, 0.64, 0.29, 0.00],\n          [0.46, 0.96, 1.00, 1.00, 1.00, 0.97, 0.67, 0.18],\n          [0.91, 1.00, 1.00, 1.00, 1.00, 1.00, 0.96, 0.36],\n          [0.91, 1.00, 1.00, 0.00, 0.00, 1.00, 1.00, 0.51],\n          [0.84, 1.00, 1.00, 0.00, 0.00, 1.00, 1.00, 0.44],\n          [0.64, 0.97, 1.00, 1.00, 1.00, 1.00, 0.94, 0.09],\n          [0.29, 0.67, 0.96, 1.00, 1.00, 0.94, 0.38, 0.01],\n          [0.00, 0.18, 0.36, 0.51, 0.44, 0.09, 0.01, 0.00]],\n\n         [[0.00, 0.29, 0.61, 0.75, 0.64, 0.41, 0.18, 0.00],\n          [0.29, 0.81, 0.95, 0.93, 0.85, 0.68, 0.40, 0.11],\n          [0.61, 0.95, 1.00, 0.78, 0.78, 0.77, 0.52, 0.22],\n          [0.75, 0.93, 0.78, 0.00, 0.00, 0.78, 0.54, 0.19],\n          [0.64, 0.85, 0.78, 0.00, 0.00, 0.78, 0.45, 0.08],\n          [0.41, 0.68, 0.77, 0.78, 0.78, 0.55, 0.25, 0.02],\n          [0.18, 0.40, 0.52, 0.54, 0.45, 0.25, 0.00, 0.00],\n          [0.00, 0.11, 0.22, 0.19, 0.08, 0.02, 0.00, 0.00]],\n\n         [[0.00, 0.19, 0.39, 0.48, 0.41, 0.26, 0.12, 0.00],\n          [0.19, 0.52, 0.73, 0.78, 0.66, 0.46, 0.26, 0.07],\n          [0.39, 0.73, 0.95, 0.50, 0.50, 0.53, 0.30, 0.14],\n          [0.48, 0.78, 0.50, 0.00, 0.00, 0.50, 0.23, 0.12],\n          [0.41, 0.66, 0.50, 0.00, 0.00, 0.50, 0.11, 0.05],\n          [0.26, 0.46, 0.53, 0.50, 0.50, 0.11, 0.03, 0.01],\n          [0.12, 0.26, 0.30, 0.23, 0.11, 0.03, 0.00, 0.00],\n          [0.00, 0.07, 0.14, 0.12, 0.05, 0.01, 0.00, 0.00]],\n\n         [[1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 0.00, 0.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 0.00, 0.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00]],\n        ]).T\n\n    assert_array_almost_equal(rgb, expect, decimal=2)",
        "begin_line": 570,
        "end_line": 621,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_light_source_hillshading#624",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_light_source_hillshading()",
        "snippet": "def test_light_source_hillshading():\n    \"\"\"Compare the current hillshading method against one that should be\n    mathematically equivalent. Illuminates a cone from a range of angles.\"\"\"\n\n    def alternative_hillshade(azimuth, elev, z):\n        illum = _sph2cart(*_azimuth2math(azimuth, elev))\n        illum = np.array(illum)\n\n        dy, dx = np.gradient(-z)\n        dy = -dy\n        dz = np.ones_like(dy)\n        normals = np.dstack([dx, dy, dz])\n        normals /= np.linalg.norm(normals, axis=2)[..., None]\n\n        intensity = np.tensordot(normals, illum, axes=(2, 0))\n        intensity -= intensity.min()\n        intensity /= intensity.ptp()\n        return intensity\n\n    y, x = np.mgrid[5:0:-1, :5]\n    z = -np.hypot(x - x.mean(), y - y.mean())\n\n    for az, elev in itertools.product(range(0, 390, 30), range(0, 105, 15)):\n        ls = mcolors.LightSource(az, elev)\n        h1 = ls.hillshade(z)\n        h2 = alternative_hillshade(az, elev, z)\n        assert_array_almost_equal(h1, h2)",
        "begin_line": 624,
        "end_line": 650,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.alternative_hillshade#628",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.alternative_hillshade(azimuth, elev, z)",
        "snippet": "    def alternative_hillshade(azimuth, elev, z):\n        illum = _sph2cart(*_azimuth2math(azimuth, elev))\n        illum = np.array(illum)\n\n        dy, dx = np.gradient(-z)\n        dy = -dy\n        dz = np.ones_like(dy)\n        normals = np.dstack([dx, dy, dz])\n        normals /= np.linalg.norm(normals, axis=2)[..., None]\n\n        intensity = np.tensordot(normals, illum, axes=(2, 0))\n        intensity -= intensity.min()\n        intensity /= intensity.ptp()\n        return intensity",
        "begin_line": 628,
        "end_line": 641,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_light_source_planar_hillshading#653",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_light_source_planar_hillshading()",
        "snippet": "def test_light_source_planar_hillshading():\n    \"\"\"Ensure that the illumination intensity is correct for planar\n    surfaces.\"\"\"\n\n    def plane(azimuth, elevation, x, y):\n        \"\"\"Create a plane whose normal vector is at the given azimuth and\n        elevation.\"\"\"\n        theta, phi = _azimuth2math(azimuth, elevation)\n        a, b, c = _sph2cart(theta, phi)\n        z = -(a*x + b*y) / c\n        return z\n\n    def angled_plane(azimuth, elevation, angle, x, y):\n        \"\"\"Create a plane whose normal vector is at an angle from the given\n        azimuth and elevation.\"\"\"\n        elevation = elevation + angle\n        if elevation > 90:\n            azimuth = (azimuth + 180) % 360\n            elevation = (90 - elevation) % 90\n        return plane(azimuth, elevation, x, y)\n\n    y, x = np.mgrid[5:0:-1, :5]\n    for az, elev in itertools.product(range(0, 390, 30), range(0, 105, 15)):\n        ls = mcolors.LightSource(az, elev)\n\n        # Make a plane at a range of angles to the illumination\n        for angle in range(0, 105, 15):\n            z = angled_plane(az, elev, angle, x, y)\n            h = ls.hillshade(z)\n            assert_array_almost_equal(h, np.cos(np.radians(angle)))",
        "begin_line": 653,
        "end_line": 682,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.plane#657",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.plane(azimuth, elevation, x, y)",
        "snippet": "    def plane(azimuth, elevation, x, y):\n        \"\"\"Create a plane whose normal vector is at the given azimuth and\n        elevation.\"\"\"\n        theta, phi = _azimuth2math(azimuth, elevation)\n        a, b, c = _sph2cart(theta, phi)\n        z = -(a*x + b*y) / c\n        return z",
        "begin_line": 657,
        "end_line": 663,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.angled_plane#665",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.angled_plane(azimuth, elevation, angle, x, y)",
        "snippet": "    def angled_plane(azimuth, elevation, angle, x, y):\n        \"\"\"Create a plane whose normal vector is at an angle from the given\n        azimuth and elevation.\"\"\"\n        elevation = elevation + angle\n        if elevation > 90:\n            azimuth = (azimuth + 180) % 360\n            elevation = (90 - elevation) % 90\n        return plane(azimuth, elevation, x, y)",
        "begin_line": 665,
        "end_line": 672,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_color_names#685",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_color_names()",
        "snippet": "def test_color_names():\n    assert mcolors.to_hex(\"blue\") == \"#0000ff\"\n    assert mcolors.to_hex(\"xkcd:blue\") == \"#0343df\"\n    assert mcolors.to_hex(\"tab:blue\") == \"#1f77b4\"",
        "begin_line": 685,
        "end_line": 688,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors._sph2cart#691",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors._sph2cart(theta, phi)",
        "snippet": "def _sph2cart(theta, phi):\n    x = np.cos(theta) * np.sin(phi)\n    y = np.sin(theta) * np.sin(phi)\n    z = np.cos(phi)\n    return x, y, z",
        "begin_line": 691,
        "end_line": 695,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors._azimuth2math#698",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors._azimuth2math(azimuth, elevation)",
        "snippet": "def _azimuth2math(azimuth, elevation):\n    \"\"\"Converts from clockwise-from-north and up-from-horizontal to\n    mathematical conventions.\"\"\"\n    theta = np.radians((90 - azimuth) % 360)\n    phi = np.radians(90 - elevation)\n    return theta, phi",
        "begin_line": 698,
        "end_line": 703,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_pandas_iterable#706",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_pandas_iterable(pd)",
        "snippet": "def test_pandas_iterable(pd):\n    # Using a list or series yields equivalent\n    # color maps, i.e the series isn't seen as\n    # a single color\n    lst = ['red', 'blue', 'green']\n    s = pd.Series(lst)\n    cm1 = mcolors.ListedColormap(lst, N=5)\n    cm2 = mcolors.ListedColormap(s, N=5)\n    assert_array_equal(cm1.colors, cm2.colors)",
        "begin_line": 706,
        "end_line": 714,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_colormap_reversing#718",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_colormap_reversing(name)",
        "snippet": "def test_colormap_reversing(name):\n    \"\"\"Check the generated _lut data of a colormap and corresponding\n    reversed colormap if they are almost the same.\"\"\"\n    cmap = plt.get_cmap(name)\n    cmap_r = cmap.reversed()\n    if not cmap_r._isinit:\n        cmap._init()\n        cmap_r._init()\n    assert_array_almost_equal(cmap._lut[:-3], cmap_r._lut[-4::-1])",
        "begin_line": 718,
        "end_line": 726,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_cn#729",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_cn()",
        "snippet": "def test_cn():\n    matplotlib.rcParams['axes.prop_cycle'] = cycler('color',\n                                                    ['blue', 'r'])\n    assert mcolors.to_hex(\"C0\") == '#0000ff'\n    assert mcolors.to_hex(\"C1\") == '#ff0000'\n\n    matplotlib.rcParams['axes.prop_cycle'] = cycler('color',\n                                                    ['xkcd:blue', 'r'])\n    assert mcolors.to_hex(\"C0\") == '#0343df'\n    assert mcolors.to_hex(\"C1\") == '#ff0000'\n    assert mcolors.to_hex(\"C10\") == '#0343df'\n    assert mcolors.to_hex(\"C11\") == '#ff0000'\n\n    matplotlib.rcParams['axes.prop_cycle'] = cycler('color', ['8e4585', 'r'])\n\n    assert mcolors.to_hex(\"C0\") == '#8e4585'\n    # if '8e4585' gets parsed as a float before it gets detected as a hex\n    # colour it will be interpreted as a very large number.\n    # this mustn't happen.\n    assert mcolors.to_rgb(\"C0\")[0] != np.inf",
        "begin_line": 729,
        "end_line": 748,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_conversions#751",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_conversions()",
        "snippet": "def test_conversions():\n    # to_rgba_array(\"none\") returns a (0, 4) array.\n    assert_array_equal(mcolors.to_rgba_array(\"none\"), np.zeros((0, 4)))\n    # a list of grayscale levels, not a single color.\n    assert_array_equal(\n        mcolors.to_rgba_array([\".2\", \".5\", \".8\"]),\n        np.vstack([mcolors.to_rgba(c) for c in [\".2\", \".5\", \".8\"]]))\n    # alpha is properly set.\n    assert mcolors.to_rgba((1, 1, 1), .5) == (1, 1, 1, .5)\n    assert mcolors.to_rgba(\".1\", .5) == (.1, .1, .1, .5)\n    # builtin round differs between py2 and py3.\n    assert mcolors.to_hex((.7, .7, .7)) == \"#b2b2b2\"\n    # hex roundtrip.\n    hex_color = \"#1234abcd\"\n    assert mcolors.to_hex(mcolors.to_rgba(hex_color), keep_alpha=True) == \\\n        hex_color",
        "begin_line": 751,
        "end_line": 766,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_grey_gray#769",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_grey_gray()",
        "snippet": "def test_grey_gray():\n    color_mapping = mcolors._colors_full_map\n    for k in color_mapping.keys():\n        if 'grey' in k:\n            assert color_mapping[k] == color_mapping[k.replace('grey', 'gray')]\n        if 'gray' in k:\n            assert color_mapping[k] == color_mapping[k.replace('gray', 'grey')]",
        "begin_line": 769,
        "end_line": 775,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_tableau_order#778",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_tableau_order()",
        "snippet": "def test_tableau_order():\n    dflt_cycle = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728',\n                  '#9467bd', '#8c564b', '#e377c2', '#7f7f7f',\n                  '#bcbd22', '#17becf']\n\n    assert list(mcolors.TABLEAU_COLORS.values()) == dflt_cycle",
        "begin_line": 778,
        "end_line": 783,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_ndarray_subclass_norm#786",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_ndarray_subclass_norm(recwarn)",
        "snippet": "def test_ndarray_subclass_norm(recwarn):\n    # Emulate an ndarray subclass that handles units\n    # which objects when adding or subtracting with other\n    # arrays. See #6622 and #8696\n    class MyArray(np.ndarray):\n        def __isub__(self, other):\n            raise RuntimeError\n\n        def __add__(self, other):\n            raise RuntimeError\n\n    data = np.arange(-10, 10, 1, dtype=float).reshape((10, 2))\n    mydata = data.view(MyArray)\n\n    for norm in [mcolors.Normalize(), mcolors.LogNorm(),\n                 mcolors.SymLogNorm(3, vmax=5, linscale=1),\n                 mcolors.Normalize(vmin=mydata.min(), vmax=mydata.max()),\n                 mcolors.SymLogNorm(3, vmin=mydata.min(), vmax=mydata.max()),\n                 mcolors.PowerNorm(1)]:\n        assert_array_equal(norm(mydata), norm(data))\n        fig, ax = plt.subplots()\n        ax.imshow(mydata, norm=norm)\n        fig.canvas.draw()\n        assert len(recwarn) == 0\n        recwarn.clear()",
        "begin_line": 786,
        "end_line": 810,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.MyArray.test_ndarray_subclass_norm#786",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors.MyArray",
        "signature": "lib.matplotlib.tests.test_colors.MyArray.test_ndarray_subclass_norm(recwarn)",
        "snippet": "def test_ndarray_subclass_norm(recwarn):\n    # Emulate an ndarray subclass that handles units\n    # which objects when adding or subtracting with other\n    # arrays. See #6622 and #8696\n    class MyArray(np.ndarray):\n        def __isub__(self, other):\n            raise RuntimeError\n\n        def __add__(self, other):\n            raise RuntimeError\n\n    data = np.arange(-10, 10, 1, dtype=float).reshape((10, 2))\n    mydata = data.view(MyArray)\n\n    for norm in [mcolors.Normalize(), mcolors.LogNorm(),\n                 mcolors.SymLogNorm(3, vmax=5, linscale=1),\n                 mcolors.Normalize(vmin=mydata.min(), vmax=mydata.max()),\n                 mcolors.SymLogNorm(3, vmin=mydata.min(), vmax=mydata.max()),\n                 mcolors.PowerNorm(1)]:\n        assert_array_equal(norm(mydata), norm(data))\n        fig, ax = plt.subplots()\n        ax.imshow(mydata, norm=norm)\n        fig.canvas.draw()\n        assert len(recwarn) == 0\n        recwarn.clear()",
        "begin_line": 786,
        "end_line": 810,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.MyArray.__isub__#791",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors.MyArray",
        "signature": "lib.matplotlib.tests.test_colors.MyArray.__isub__(self, other)",
        "snippet": "        def __isub__(self, other):\n            raise RuntimeError",
        "begin_line": 791,
        "end_line": 792,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.MyArray.__add__#794",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors.MyArray",
        "signature": "lib.matplotlib.tests.test_colors.MyArray.__add__(self, other)",
        "snippet": "        def __add__(self, other):\n            raise RuntimeError",
        "begin_line": 794,
        "end_line": 795,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_same_color#813",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_same_color()",
        "snippet": "def test_same_color():\n    assert mcolors.same_color('k', (0, 0, 0))\n    assert not mcolors.same_color('w', (1, 1, 0))",
        "begin_line": 813,
        "end_line": 815,
        "comment": "",
        "is_bug": false
    }
]