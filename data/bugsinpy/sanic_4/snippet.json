[
    {
        "name": "sanic.blueprints.Blueprint.__init__#34",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.__init__(self, name, url_prefix=None, host=None, version=None, strict_slashes=None)",
        "snippet": "    def __init__(\n        self,\n        name,\n        url_prefix=None,\n        host=None,\n        version=None,\n        strict_slashes=None,\n    ):\n        \"\"\"\n        In *Sanic* terminology, a **Blueprint** is a logical collection of\n        URLs that perform a specific set of tasks which can be identified by\n        a unique name.\n\n        :param name: unique name of the blueprint\n        :param url_prefix: URL to be prefixed before all route URLs\n        :param host: IP Address of FQDN for the sanic server to use.\n        :param version: Blueprint Version\n        :param strict_slashes: Enforce the API urls are requested with a\n            training */*\n        \"\"\"\n        self.name = name\n        self.url_prefix = url_prefix\n        self.host = host\n\n        self.routes = []\n        self.websocket_routes = []\n        self.exceptions = []\n        self.listeners = defaultdict(list)\n        self.middlewares = []\n        self.statics = []\n        self.version = version\n        self.strict_slashes = strict_slashes",
        "begin_line": 34,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00034746351633078526,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.chain#77",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.chain(nested)",
        "snippet": "        def chain(nested):\n            \"\"\"itertools.chain() but leaves strings untouched\"\"\"\n            for i in nested:\n                if isinstance(i, (list, tuple)):\n                    yield from chain(i)\n                elif isinstance(i, BlueprintGroup):\n                    yield from i.blueprints\n                else:\n                    yield i",
        "begin_line": 77,
        "end_line": 85,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0006317119393556538,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.group#68",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.group(*blueprints, url_prefix='')",
        "snippet": "    def group(*blueprints, url_prefix=\"\"):\n        \"\"\"\n        Create a list of blueprints, optionally grouping them under a\n        general URL prefix.\n\n        :param blueprints: blueprints to be registered as a group\n        :param url_prefix: URL route to be prepended to all sub-prefixes\n        \"\"\"\n\n        def chain(nested):\n            \"\"\"itertools.chain() but leaves strings untouched\"\"\"\n            for i in nested:\n                if isinstance(i, (list, tuple)):\n                    yield from chain(i)\n                elif isinstance(i, BlueprintGroup):\n                    yield from i.blueprints\n                else:\n                    yield i\n\n        bps = BlueprintGroup(url_prefix=url_prefix)\n        for bp in chain(blueprints):\n            if bp.url_prefix is None:\n                bp.url_prefix = \"\"\n            bp.url_prefix = url_prefix + bp.url_prefix\n            bps.append(bp)\n        return bps",
        "begin_line": 68,
        "end_line": 93,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.register#95",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.register(self, app, options)",
        "snippet": "    def register(self, app, options):\n        \"\"\"\n        Register the blueprint to the sanic app.\n\n        :param app: Instance of :class:`sanic.app.Sanic` class\n        :param options: Options to be used while registering the\n            blueprint into the app.\n            *url_prefix* - URL Prefix to override the blueprint prefix\n        \"\"\"\n\n        url_prefix = options.get(\"url_prefix\", self.url_prefix)\n\n        # Routes\n        for future in self.routes:\n            # attach the blueprint name to the handler so that it can be\n            # prefixed properly in the router\n            future.handler.__blueprintname__ = self.name\n            # Prepend the blueprint URI prefix if available\n            uri = url_prefix + future.uri if url_prefix else future.uri\n\n            version = future.version or self.version\n\n            app.route(\n                uri=uri[1:] if uri.startswith(\"//\") else uri,\n                methods=future.methods,\n                host=future.host or self.host,\n                strict_slashes=future.strict_slashes,\n                stream=future.stream,\n                version=version,\n                name=future.name,\n            )(future.handler)\n\n        for future in self.websocket_routes:\n            # attach the blueprint name to the handler so that it can be\n            # prefixed properly in the router\n            future.handler.__blueprintname__ = self.name\n            # Prepend the blueprint URI prefix if available\n            uri = url_prefix + future.uri if url_prefix else future.uri\n            app.websocket(\n                uri=uri,\n                host=future.host or self.host,\n                strict_slashes=future.strict_slashes,\n                name=future.name,\n            )(future.handler)\n\n        # Middleware\n        for future in self.middlewares:\n            if future.args or future.kwargs:\n                app.register_middleware(\n                    future.middleware, *future.args, **future.kwargs\n                )\n            else:\n                app.register_middleware(future.middleware)\n\n        # Exceptions\n        for future in self.exceptions:\n            app.exception(*future.args, **future.kwargs)(future.handler)\n\n        # Static Files\n        for future in self.statics:\n            # Prepend the blueprint URI prefix if available\n            uri = url_prefix + future.uri if url_prefix else future.uri\n            app.static(\n                uri, future.file_or_directory, *future.args, **future.kwargs\n            )\n\n        # Event listeners\n        for event, listeners in self.listeners.items():\n            for listener in listeners:\n                app.listener(event)(listener)",
        "begin_line": 95,
        "end_line": 164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.route#166",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.route(self, uri, methods=frozenset({'GET'}), host=None, strict_slashes=None, stream=False, version=None, name=None)",
        "snippet": "    def route(\n        self,\n        uri,\n        methods=frozenset({\"GET\"}),\n        host=None,\n        strict_slashes=None,\n        stream=False,\n        version=None,\n        name=None,\n    ):\n        \"\"\"Create a blueprint route from a decorated function.\n\n        :param uri: endpoint at which the route will be accessible.\n        :param methods: list of acceptable HTTP methods.\n        :param host: IP Address of FQDN for the sanic server to use.\n        :param strict_slashes: Enforce the API urls are requested with a\n            training */*\n        :param stream: If the route should provide a streaming support\n        :param version: Blueprint Version\n        :param name: Unique name to identify the Route\n\n        :return a decorated method that when invoked will return an object\n            of type :class:`FutureRoute`\n        \"\"\"\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        def decorator(handler):\n            route = FutureRoute(\n                handler,\n                uri,\n                methods,\n                host,\n                strict_slashes,\n                stream,\n                version,\n                name,\n            )\n            self.routes.append(route)\n            return handler\n\n        return decorator",
        "begin_line": 166,
        "end_line": 207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0003894080996884735,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.decorator#193",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.decorator(handler)",
        "snippet": "        def decorator(handler):\n            route = FutureRoute(\n                handler,\n                uri,\n                methods,\n                host,\n                strict_slashes,\n                stream,\n                version,\n                name,\n            )\n            self.routes.append(route)\n            return handler",
        "begin_line": 193,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.add_route#209",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.add_route(self, handler, uri, methods=frozenset({'GET'}), host=None, strict_slashes=None, version=None, name=None, stream=False)",
        "snippet": "    def add_route(\n        self,\n        handler,\n        uri,\n        methods=frozenset({\"GET\"}),\n        host=None,\n        strict_slashes=None,\n        version=None,\n        name=None,\n        stream=False,\n    ):\n        \"\"\"Create a blueprint route from a function.\n\n        :param handler: function for handling uri requests. Accepts function,\n                        or class instance with a view_class method.\n        :param uri: endpoint at which the route will be accessible.\n        :param methods: list of acceptable HTTP methods.\n        :param host: IP Address of FQDN for the sanic server to use.\n        :param strict_slashes: Enforce the API urls are requested with a\n            training */*\n        :param version: Blueprint Version\n        :param name: user defined route name for url_for\n        :param stream: boolean specifying if the handler is a stream handler\n        :return: function or class instance\n        \"\"\"\n        # Handle HTTPMethodView differently\n        if hasattr(handler, \"view_class\"):\n            methods = set()\n\n            for method in HTTP_METHODS:\n                if getattr(handler.view_class, method.lower(), None):\n                    methods.add(method)\n\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        # handle composition view differently\n        if isinstance(handler, CompositionView):\n            methods = handler.handlers.keys()\n\n        self.route(\n            uri=uri,\n            methods=methods,\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )(handler)\n        return handler",
        "begin_line": 209,
        "end_line": 258,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.websocket#260",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.websocket(self, uri, host=None, strict_slashes=None, version=None, name=None)",
        "snippet": "    def websocket(\n        self, uri, host=None, strict_slashes=None, version=None, name=None\n    ):\n        \"\"\"Create a blueprint websocket route from a decorated function.\n\n        :param uri: endpoint at which the route will be accessible.\n        :param host: IP Address of FQDN for the sanic server to use.\n        :param strict_slashes: Enforce the API urls are requested with a\n            training */*\n        :param version: Blueprint Version\n        :param name: Unique name to identify the Websocket Route\n        \"\"\"\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        def decorator(handler):\n            route = FutureRoute(\n                handler, uri, [], host, strict_slashes, False, version, name\n            )\n            self.websocket_routes.append(route)\n            return handler\n\n        return decorator",
        "begin_line": 260,
        "end_line": 282,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.decorator#275",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.decorator(handler)",
        "snippet": "        def decorator(handler):\n            route = FutureRoute(\n                handler, uri, [], host, strict_slashes, False, version, name\n            )\n            self.websocket_routes.append(route)\n            return handler",
        "begin_line": 275,
        "end_line": 280,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.add_websocket_route#284",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.add_websocket_route(self, handler, uri, host=None, version=None, name=None)",
        "snippet": "    def add_websocket_route(\n        self, handler, uri, host=None, version=None, name=None\n    ):\n        \"\"\"Create a blueprint websocket route from a function.\n\n        :param handler: function for handling uri requests. Accepts function,\n                        or class instance with a view_class method.\n        :param uri: endpoint at which the route will be accessible.\n        :param host: IP Address of FQDN for the sanic server to use.\n        :param version: Blueprint Version\n        :param name: Unique name to identify the Websocket Route\n        :return: function or class instance\n        \"\"\"\n        self.websocket(uri=uri, host=host, version=version, name=name)(handler)\n        return handler",
        "begin_line": 284,
        "end_line": 298,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.listener#300",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.listener(self, event)",
        "snippet": "    def listener(self, event):\n        \"\"\"Create a listener from a decorated function.\n\n        :param event: Event to listen to.\n        \"\"\"\n\n        def decorator(listener):\n            self.listeners[event].append(listener)\n            return listener\n\n        return decorator",
        "begin_line": 300,
        "end_line": 310,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.decorator#306",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.decorator(listener)",
        "snippet": "        def decorator(listener):\n            self.listeners[event].append(listener)\n            return listener",
        "begin_line": 306,
        "end_line": 308,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.middleware#312",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.middleware(self, *args, **kwargs)",
        "snippet": "    def middleware(self, *args, **kwargs):\n        \"\"\"\n        Create a blueprint middleware from a decorated function.\n\n        :param args: Positional arguments to be used while invoking the\n            middleware\n        :param kwargs: optional keyword args that can be used with the\n            middleware.\n        \"\"\"\n\n        def register_middleware(_middleware):\n            future_middleware = FutureMiddleware(_middleware, args, kwargs)\n            self.middlewares.append(future_middleware)\n            return _middleware\n\n        # Detect which way this was called, @middleware or @middleware('AT')\n        if len(args) == 1 and len(kwargs) == 0 and callable(args[0]):\n            middleware = args[0]\n            args = []\n            return register_middleware(middleware)\n        else:\n            if kwargs.get(\"bp_group\") and callable(args[0]):\n                middleware = args[0]\n                args = args[1:]\n                kwargs.pop(\"bp_group\")\n                return register_middleware(middleware)\n            else:\n                return register_middleware",
        "begin_line": 312,
        "end_line": 339,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.register_middleware#322",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.register_middleware(_middleware)",
        "snippet": "        def register_middleware(_middleware):\n            future_middleware = FutureMiddleware(_middleware, args, kwargs)\n            self.middlewares.append(future_middleware)\n            return _middleware",
        "begin_line": 322,
        "end_line": 325,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.exception#341",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.exception(self, *args, **kwargs)",
        "snippet": "    def exception(self, *args, **kwargs):\n        \"\"\"\n        This method enables the process of creating a global exception\n        handler for the current blueprint under question.\n\n        :param args: List of Python exceptions to be caught by the handler\n        :param kwargs: Additional optional arguments to be passed to the\n            exception handler\n\n        :return a decorated method to handle global exceptions for any\n            route registered under this blueprint.\n        \"\"\"\n\n        def decorator(handler):\n            exception = FutureException(handler, args, kwargs)\n            self.exceptions.append(exception)\n            return handler\n\n        return decorator",
        "begin_line": 341,
        "end_line": 359,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.decorator#354",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.decorator(handler)",
        "snippet": "        def decorator(handler):\n            exception = FutureException(handler, args, kwargs)\n            self.exceptions.append(exception)\n            return handler",
        "begin_line": 354,
        "end_line": 357,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.static#361",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.static(self, uri, file_or_directory, *args, **kwargs)",
        "snippet": "    def static(self, uri, file_or_directory, *args, **kwargs):\n        \"\"\"Create a blueprint static route from a decorated function.\n\n        :param uri: endpoint at which the route will be accessible.\n        :param file_or_directory: Static asset.\n        \"\"\"\n        name = kwargs.pop(\"name\", \"static\")\n        if not name.startswith(self.name + \".\"):\n            name = \"{}.{}\".format(self.name, name)\n        kwargs.update(name=name)\n\n        strict_slashes = kwargs.get(\"strict_slashes\")\n        if strict_slashes is None and self.strict_slashes is not None:\n            kwargs.update(strict_slashes=self.strict_slashes)\n\n        static = FutureStatic(uri, file_or_directory, args, kwargs)\n        self.statics.append(static)",
        "begin_line": 361,
        "end_line": 377,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004084967320261438,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.get#380",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.get(self, uri, host=None, strict_slashes=None, version=None, name=None)",
        "snippet": "    def get(\n        self, uri, host=None, strict_slashes=None, version=None, name=None\n    ):\n        \"\"\"\n        Add an API URL under the **GET** *HTTP* method\n\n        :param uri: URL to be tagged to **GET** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`sanic.app.Sanic` to check\n            if the request URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"GET\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n        )",
        "begin_line": 380,
        "end_line": 401,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00045433893684688776,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.post#403",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.post(self, uri, host=None, strict_slashes=None, stream=False, version=None, name=None)",
        "snippet": "    def post(\n        self,\n        uri,\n        host=None,\n        strict_slashes=None,\n        stream=False,\n        version=None,\n        name=None,\n    ):\n        \"\"\"\n        Add an API URL under the **POST** *HTTP* method\n\n        :param uri: URL to be tagged to **POST** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`sanic.app.Sanic` to check\n            if the request URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"POST\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )",
        "begin_line": 403,
        "end_line": 431,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00048449612403100775,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.put#433",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.put(self, uri, host=None, strict_slashes=None, stream=False, version=None, name=None)",
        "snippet": "    def put(\n        self,\n        uri,\n        host=None,\n        strict_slashes=None,\n        stream=False,\n        version=None,\n        name=None,\n    ):\n        \"\"\"\n        Add an API URL under the **PUT** *HTTP* method\n\n        :param uri: URL to be tagged to **PUT** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`sanic.app.Sanic` to check\n            if the request URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"PUT\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )",
        "begin_line": 433,
        "end_line": 461,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.head#463",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.head(self, uri, host=None, strict_slashes=None, version=None, name=None)",
        "snippet": "    def head(\n        self, uri, host=None, strict_slashes=None, version=None, name=None\n    ):\n        \"\"\"\n        Add an API URL under the **HEAD** *HTTP* method\n\n        :param uri: URL to be tagged to **HEAD** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`sanic.app.Sanic` to check\n            if the request URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"HEAD\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n        )",
        "begin_line": 463,
        "end_line": 484,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.options#486",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.options(self, uri, host=None, strict_slashes=None, version=None, name=None)",
        "snippet": "    def options(\n        self, uri, host=None, strict_slashes=None, version=None, name=None\n    ):\n        \"\"\"\n        Add an API URL under the **OPTIONS** *HTTP* method\n\n        :param uri: URL to be tagged to **OPTIONS** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`sanic.app.Sanic` to check\n            if the request URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"OPTIONS\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n        )",
        "begin_line": 486,
        "end_line": 507,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.patch#509",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.patch(self, uri, host=None, strict_slashes=None, stream=False, version=None, name=None)",
        "snippet": "    def patch(\n        self,\n        uri,\n        host=None,\n        strict_slashes=None,\n        stream=False,\n        version=None,\n        name=None,\n    ):\n        \"\"\"\n        Add an API URL under the **PATCH** *HTTP* method\n\n        :param uri: URL to be tagged to **PATCH** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`sanic.app.Sanic` to check\n            if the request URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"PATCH\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )",
        "begin_line": 509,
        "end_line": 537,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprints.Blueprint.delete#539",
        "src_path": "sanic/blueprints.py",
        "class_name": "sanic.blueprints.Blueprint",
        "signature": "sanic.blueprints.Blueprint.delete(self, uri, host=None, strict_slashes=None, version=None, name=None)",
        "snippet": "    def delete(\n        self, uri, host=None, strict_slashes=None, version=None, name=None\n    ):\n        \"\"\"\n        Add an API URL under the **DELETE** *HTTP* method\n\n        :param uri: URL to be tagged to **DELETE** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`sanic.app.Sanic` to check\n            if the request URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"DELETE\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n        )",
        "begin_line": 539,
        "end_line": 560,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.config.Config.__init__#37",
        "src_path": "sanic/config.py",
        "class_name": "sanic.config.Config",
        "signature": "sanic.config.Config.__init__(self, defaults=None, load_env=True, keep_alive=None)",
        "snippet": "    def __init__(self, defaults=None, load_env=True, keep_alive=None):\n        defaults = defaults or {}\n        super().__init__({**DEFAULT_CONFIG, **defaults})\n\n        self.LOGO = BASE_LOGO\n\n        if keep_alive is not None:\n            self.KEEP_ALIVE = keep_alive\n\n        if load_env:\n            prefix = SANIC_PREFIX if load_env is True else load_env\n            self.load_environment_vars(prefix=prefix)",
        "begin_line": 37,
        "end_line": 48,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012987012987012987,
            "pseudo_dstar_susp": 0.0015290519877675841,
            "pseudo_tarantula_susp": 0.0012987012987012987,
            "pseudo_op2_susp": 0.0015290519877675841,
            "pseudo_barinel_susp": 0.0012987012987012987
        }
    },
    {
        "name": "sanic.config.Config.__getattr__#50",
        "src_path": "sanic/config.py",
        "class_name": "sanic.config.Config",
        "signature": "sanic.config.Config.__getattr__(self, attr)",
        "snippet": "    def __getattr__(self, attr):\n        try:\n            return self[attr]\n        except KeyError as ke:\n            raise AttributeError(\"Config has no '{}'\".format(ke.args[0]))",
        "begin_line": 50,
        "end_line": 54,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.030303030303030304,
            "pseudo_dstar_susp": 0.0019455252918287938,
            "pseudo_tarantula_susp": 0.030303030303030304,
            "pseudo_op2_susp": 0.0019455252918287938,
            "pseudo_barinel_susp": 0.030303030303030304
        }
    },
    {
        "name": "sanic.config.Config.__setattr__#56",
        "src_path": "sanic/config.py",
        "class_name": "sanic.config.Config",
        "signature": "sanic.config.Config.__setattr__(self, attr, value)",
        "snippet": "    def __setattr__(self, attr, value):\n        self[attr] = value",
        "begin_line": 56,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012836970474967907,
            "pseudo_dstar_susp": 0.0015082956259426848,
            "pseudo_tarantula_susp": 0.001282051282051282,
            "pseudo_op2_susp": 0.0015082956259426848,
            "pseudo_barinel_susp": 0.001282051282051282
        }
    },
    {
        "name": "sanic.config.Config.from_envvar#59",
        "src_path": "sanic/config.py",
        "class_name": "sanic.config.Config",
        "signature": "sanic.config.Config.from_envvar(self, variable_name)",
        "snippet": "    def from_envvar(self, variable_name):\n        \"\"\"Load a configuration from an environment variable pointing to\n        a configuration file.\n\n        :param variable_name: name of the environment variable\n        :return: bool. ``True`` if able to load config, ``False`` otherwise.\n        \"\"\"\n        config_file = os.environ.get(variable_name)\n        if not config_file:\n            raise RuntimeError(\n                \"The environment variable %r is not set and \"\n                \"thus configuration could not be loaded.\" % variable_name\n            )\n        return self.from_pyfile(config_file)",
        "begin_line": 59,
        "end_line": 72,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.config.Config.from_pyfile#74",
        "src_path": "sanic/config.py",
        "class_name": "sanic.config.Config",
        "signature": "sanic.config.Config.from_pyfile(self, filename)",
        "snippet": "    def from_pyfile(self, filename):\n        \"\"\"Update the values in the config from a Python file.\n        Only the uppercase variables in that module are stored in the config.\n\n        :param filename: an absolute path to the config file\n        \"\"\"\n        module = types.ModuleType(\"config\")\n        module.__file__ = filename\n        try:\n            with open(filename) as config_file:\n                exec(  # nosec\n                    compile(config_file.read(), filename, \"exec\"),\n                    module.__dict__,\n                )\n        except IOError as e:\n            e.strerror = \"Unable to load configuration file (%s)\" % e.strerror\n            raise\n        except Exception as e:\n            raise PyFileError(filename) from e\n\n        self.from_object(module)\n        return True",
        "begin_line": 74,
        "end_line": 95,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.config.Config.from_object#97",
        "src_path": "sanic/config.py",
        "class_name": "sanic.config.Config",
        "signature": "sanic.config.Config.from_object(self, obj)",
        "snippet": "    def from_object(self, obj):\n        \"\"\"Update the values from the given object.\n        Objects are usually either modules or classes.\n\n        Just the uppercase variables in that object are stored in the config.\n        Example usage::\n\n            from yourapplication import default_config\n            app.config.from_object(default_config)\n\n            or also:\n            app.config.from_object('myproject.config.MyConfigClass')\n\n        You should not use this function to load the actual configuration but\n        rather configuration defaults. The actual config should be loaded\n        with :meth:`from_pyfile` and ideally from a location not within the\n        package because the package might be installed system wide.\n\n        :param obj: an object holding the configuration\n        \"\"\"\n        if isinstance(obj, str):\n            obj = import_string(obj)\n        for key in dir(obj):\n            if key.isupper():\n                self[key] = getattr(obj, key)",
        "begin_line": 97,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.config.Config.load_environment_vars#123",
        "src_path": "sanic/config.py",
        "class_name": "sanic.config.Config",
        "signature": "sanic.config.Config.load_environment_vars(self, prefix=SANIC_PREFIX)",
        "snippet": "    def load_environment_vars(self, prefix=SANIC_PREFIX):\n        \"\"\"\n        Looks for prefixed environment variables and applies\n        them to the configuration if present.\n        \"\"\"\n        for k, v in os.environ.items():\n            if k.startswith(prefix):\n                _, config_key = k.split(prefix, 1)\n                try:\n                    self[config_key] = int(v)\n                except ValueError:\n                    try:\n                        self[config_key] = float(v)\n                    except ValueError:\n                        try:\n                            self[config_key] = strtobool(v)\n                        except ValueError:\n                            self[config_key] = v",
        "begin_line": 123,
        "end_line": 140,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012987012987012987,
            "pseudo_dstar_susp": 0.0015290519877675841,
            "pseudo_tarantula_susp": 0.0012987012987012987,
            "pseudo_op2_susp": 0.0015290519877675841,
            "pseudo_barinel_susp": 0.0012987012987012987
        }
    },
    {
        "name": "sanic.config.strtobool#143",
        "src_path": "sanic/config.py",
        "class_name": "sanic.config",
        "signature": "sanic.config.strtobool(val)",
        "snippet": "def strtobool(val):\n    \"\"\"\n    This function was borrowed from distutils.utils. While distutils\n    is part of stdlib, it feels odd to use distutils in main application code.\n\n    The function was modified to walk its talk and actually return bool\n    and not int.\n    \"\"\"\n    val = val.lower()\n    if val in (\"y\", \"yes\", \"t\", \"true\", \"on\", \"1\"):\n        return True\n    elif val in (\"n\", \"no\", \"f\", \"false\", \"off\", \"0\"):\n        return False\n    else:\n        raise ValueError(\"invalid truth value %r\" % (val,))",
        "begin_line": 143,
        "end_line": 157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.cookies._quote#24",
        "src_path": "sanic/cookies.py",
        "class_name": "sanic.cookies",
        "signature": "sanic.cookies._quote(str)",
        "snippet": "def _quote(str):\n    r\"\"\"Quote a string for use in a cookie header.\n    If the string does not need to be double-quoted, then just return the\n    string.  Otherwise, surround the string in doublequotes and quote\n    (with a \\) special characters.\n    \"\"\"\n    if str is None or _is_legal_key(str):\n        return str\n    else:\n        return '\"' + str.translate(_Translator) + '\"'",
        "begin_line": 24,
        "end_line": 33,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005393743257820927,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.cookies.CookieJar.__init__#49",
        "src_path": "sanic/cookies.py",
        "class_name": "sanic.cookies.CookieJar",
        "signature": "sanic.cookies.CookieJar.__init__(self, headers)",
        "snippet": "    def __init__(self, headers):\n        super().__init__()\n        self.headers = headers\n        self.cookie_headers = {}\n        self.header_key = \"Set-Cookie\"",
        "begin_line": 49,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00035112359550561797,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.cookies.CookieJar.__setitem__#55",
        "src_path": "sanic/cookies.py",
        "class_name": "sanic.cookies.CookieJar",
        "signature": "sanic.cookies.CookieJar.__setitem__(self, key, value)",
        "snippet": "    def __setitem__(self, key, value):\n        # If this cookie doesn't exist, add it to the header keys\n        if not self.cookie_headers.get(key):\n            cookie = Cookie(key, value)\n            cookie[\"path\"] = \"/\"\n            self.cookie_headers[key] = self.header_key\n            self.headers.add(self.header_key, cookie)\n            return super().__setitem__(key, cookie)\n        else:\n            self[key].value = value",
        "begin_line": 55,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.cookies.CookieJar.__delitem__#66",
        "src_path": "sanic/cookies.py",
        "class_name": "sanic.cookies.CookieJar",
        "signature": "sanic.cookies.CookieJar.__delitem__(self, key)",
        "snippet": "    def __delitem__(self, key):\n        if key not in self.cookie_headers:\n            self[key] = \"\"\n            self[key][\"max-age\"] = 0\n        else:\n            cookie_header = self.cookie_headers[key]\n            # remove it from header\n            cookies = self.headers.popall(cookie_header)\n            for cookie in cookies:\n                if cookie.key != key:\n                    self.headers.add(cookie_header, cookie)\n            del self.cookie_headers[key]\n            return super().__delitem__(key)",
        "begin_line": 66,
        "end_line": 78,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.cookies.Cookie.__init__#97",
        "src_path": "sanic/cookies.py",
        "class_name": "sanic.cookies.Cookie",
        "signature": "sanic.cookies.Cookie.__init__(self, key, value)",
        "snippet": "    def __init__(self, key, value):\n        if key in self._keys:\n            raise KeyError(\"Cookie name is a reserved word\")\n        if not _is_legal_key(key):\n            raise KeyError(\"Cookie key contains illegal characters\")\n        self.key = key\n        self.value = value\n        super().__init__()",
        "begin_line": 97,
        "end_line": 104,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.cookies.Cookie.__setitem__#106",
        "src_path": "sanic/cookies.py",
        "class_name": "sanic.cookies.Cookie",
        "signature": "sanic.cookies.Cookie.__setitem__(self, key, value)",
        "snippet": "    def __setitem__(self, key, value):\n        if key not in self._keys:\n            raise KeyError(\"Unknown cookie property\")\n        if value is not False:\n            if key.lower() == \"max-age\":\n                if not str(value).isdigit():\n                    value = DEFAULT_MAX_AGE\n            elif key.lower() == \"expires\":\n                if not isinstance(value, datetime):\n                    raise TypeError(\n                        \"Cookie 'expires' property must be a datetime\"\n                    )\n            return super().__setitem__(key, value)",
        "begin_line": 106,
        "end_line": 118,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.cookies.Cookie.encode#120",
        "src_path": "sanic/cookies.py",
        "class_name": "sanic.cookies.Cookie",
        "signature": "sanic.cookies.Cookie.encode(self, encoding)",
        "snippet": "    def encode(self, encoding):\n        \"\"\"\n        Encode the cookie content in a specific type of encoding instructed\n        by the developer. Leverages the :func:`str.encode` method provided\n        by python.\n\n        This method can be used to encode and embed ``utf-8`` content into\n        the cookies.\n\n        :param encoding: Encoding to be used with the cookie\n        :return: Cookie encoded in a codec of choosing.\n        :except: UnicodeEncodeError\n        \"\"\"\n        output = [\"%s=%s\" % (self.key, _quote(self.value))]\n        for key, value in self.items():\n            if key == \"max-age\":\n                try:\n                    output.append(\"%s=%d\" % (self._keys[key], value))\n                except TypeError:\n                    output.append(\"%s=%s\" % (self._keys[key], value))\n            elif key == \"expires\":\n                output.append(\n                    \"%s=%s\"\n                    % (self._keys[key], value.strftime(\"%a, %d-%b-%Y %T GMT\"))\n                )\n            elif key in self._flags and self[key]:\n                output.append(self._keys[key])\n            else:\n                output.append(\"%s=%s\" % (self._keys[key], value))\n\n        return \"; \".join(output).encode(encoding)",
        "begin_line": 120,
        "end_line": 150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.worker.GunicornWorker.init_process#44",
        "src_path": "sanic/worker.py",
        "class_name": "sanic.worker.GunicornWorker",
        "signature": "sanic.worker.GunicornWorker.init_process(self)",
        "snippet": "    def init_process(self):\n        # create new event_loop after fork\n        asyncio.get_event_loop().close()\n\n        self.loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self.loop)\n\n        super().init_process()",
        "begin_line": 44,
        "end_line": 51,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.worker.GunicornWorker.close#101",
        "src_path": "sanic/worker.py",
        "class_name": "sanic.worker.GunicornWorker",
        "signature": "sanic.worker.GunicornWorker.close(self)",
        "snippet": "    async def close(self):\n        if self.servers:\n            # stop accepting connections\n            self.log.info(\n                \"Stopping server: %s, connections: %s\",\n                self.pid,\n                len(self.connections),\n            )\n            for server in self.servers:\n                server.close()\n                await server.wait_closed()\n            self.servers.clear()\n\n            # prepare connections for closing\n            self.signal.stopped = True\n            for conn in self.connections:\n                conn.close_if_idle()\n\n            # gracefully shutdown timeout\n            start_shutdown = 0\n            graceful_shutdown_timeout = self.cfg.graceful_timeout\n            while self.connections and (\n                start_shutdown < graceful_shutdown_timeout\n            ):\n                await asyncio.sleep(0.1)\n                start_shutdown = start_shutdown + 0.1\n\n            # Force close non-idle connection after waiting for\n            # graceful_shutdown_timeout\n            coros = []\n            for conn in self.connections:\n                if hasattr(conn, \"websocket\") and conn.websocket:\n                    coros.append(conn.websocket.close_connection())\n                else:\n                    conn.close()\n            _shutdown = asyncio.gather(*coros, loop=self.loop)\n            await _shutdown",
        "begin_line": 101,
        "end_line": 137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.worker.GunicornWorker._check_alive#152",
        "src_path": "sanic/worker.py",
        "class_name": "sanic.worker.GunicornWorker",
        "signature": "sanic.worker.GunicornWorker._check_alive(self)",
        "snippet": "    async def _check_alive(self):\n        # If our parent changed then we shut down.\n        pid = os.getpid()\n        try:\n            while self.alive:\n                self.notify()\n\n                req_count = sum(\n                    self.servers[srv][\"requests_count\"] for srv in self.servers\n                )\n                if self.max_requests and req_count > self.max_requests:\n                    self.alive = False\n                    self.log.info(\n                        \"Max requests exceeded, shutting down: %s\", self\n                    )\n                elif pid == os.getpid() and self.ppid != os.getppid():\n                    self.alive = False\n                    self.log.info(\"Parent changed, shutting down: %s\", self)\n                else:\n                    await asyncio.sleep(1.0, loop=self.loop)\n        except (Exception, BaseException, GeneratorExit, KeyboardInterrupt):\n            pass",
        "begin_line": 152,
        "end_line": 173,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.worker.GunicornWorker.init_signals#189",
        "src_path": "sanic/worker.py",
        "class_name": "sanic.worker.GunicornWorker",
        "signature": "sanic.worker.GunicornWorker.init_signals(self)",
        "snippet": "    def init_signals(self):\n        # Set up signals through the event loop API.\n\n        self.loop.add_signal_handler(\n            signal.SIGQUIT, self.handle_quit, signal.SIGQUIT, None\n        )\n\n        self.loop.add_signal_handler(\n            signal.SIGTERM, self.handle_exit, signal.SIGTERM, None\n        )\n\n        self.loop.add_signal_handler(\n            signal.SIGINT, self.handle_quit, signal.SIGINT, None\n        )\n\n        self.loop.add_signal_handler(\n            signal.SIGWINCH, self.handle_winch, signal.SIGWINCH, None\n        )\n\n        self.loop.add_signal_handler(\n            signal.SIGUSR1, self.handle_usr1, signal.SIGUSR1, None\n        )\n\n        self.loop.add_signal_handler(\n            signal.SIGABRT, self.handle_abort, signal.SIGABRT, None\n        )\n\n        # Don't let SIGTERM and SIGUSR1 disturb active requests\n        # by interrupting system calls\n        signal.siginterrupt(signal.SIGTERM, False)\n        signal.siginterrupt(signal.SIGUSR1, False)",
        "begin_line": 189,
        "end_line": 219,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.worker.GunicornWorker.handle_quit#221",
        "src_path": "sanic/worker.py",
        "class_name": "sanic.worker.GunicornWorker",
        "signature": "sanic.worker.GunicornWorker.handle_quit(self, sig, frame)",
        "snippet": "    def handle_quit(self, sig, frame):\n        self.alive = False\n        self.app.callable.is_running = False\n        self.cfg.worker_int(self)",
        "begin_line": 221,
        "end_line": 224,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.worker.GunicornWorker.handle_abort#226",
        "src_path": "sanic/worker.py",
        "class_name": "sanic.worker.GunicornWorker",
        "signature": "sanic.worker.GunicornWorker.handle_abort(self, sig, frame)",
        "snippet": "    def handle_abort(self, sig, frame):\n        self.alive = False\n        self.exit_code = 1\n        self.cfg.worker_abort(self)\n        sys.exit(1)",
        "begin_line": 226,
        "end_line": 230,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.helpers.has_message_body#102",
        "src_path": "sanic/helpers.py",
        "class_name": "sanic.helpers",
        "signature": "sanic.helpers.has_message_body(status)",
        "snippet": "def has_message_body(status):\n    \"\"\"\n    According to the following RFC message body and length SHOULD NOT\n    be included in responses status 1XX, 204 and 304.\n    https://tools.ietf.org/html/rfc2616#section-4.4\n    https://tools.ietf.org/html/rfc2616#section-4.3\n    \"\"\"\n    return status not in (204, 304) and not (100 <= status < 200)",
        "begin_line": 102,
        "end_line": 109,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005291005291005291,
            "pseudo_dstar_susp": 0.0136986301369863,
            "pseudo_tarantula_susp": 0.005555555555555556,
            "pseudo_op2_susp": 0.0136986301369863,
            "pseudo_barinel_susp": 0.005555555555555556
        }
    },
    {
        "name": "sanic.helpers.is_entity_header#112",
        "src_path": "sanic/helpers.py",
        "class_name": "sanic.helpers",
        "signature": "sanic.helpers.is_entity_header(header)",
        "snippet": "def is_entity_header(header):\n    \"\"\"Checks if the given header is an Entity Header\"\"\"\n    return header.lower() in _ENTITY_HEADERS",
        "begin_line": 112,
        "end_line": 114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005393743257820927,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.helpers.is_hop_by_hop_header#117",
        "src_path": "sanic/helpers.py",
        "class_name": "sanic.helpers",
        "signature": "sanic.helpers.is_hop_by_hop_header(header)",
        "snippet": "def is_hop_by_hop_header(header):\n    \"\"\"Checks if the given header is a Hop By Hop header\"\"\"\n    return header.lower() in _HOP_BY_HOP_HEADERS",
        "begin_line": 117,
        "end_line": 119,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.helpers.remove_entity_headers#122",
        "src_path": "sanic/helpers.py",
        "class_name": "sanic.helpers",
        "signature": "sanic.helpers.remove_entity_headers(headers, allowed=('content-location', 'expires'))",
        "snippet": "def remove_entity_headers(headers, allowed=(\"content-location\", \"expires\")):\n    \"\"\"\n    Removes all the entity headers present in the headers given.\n    According to RFC 2616 Section 10.3.5,\n    Content-Location and Expires are allowed as for the\n    \"strong cache validator\".\n    https://tools.ietf.org/html/rfc2616#section-10.3.5\n\n    returns the headers without the entity headers\n    \"\"\"\n    allowed = set([h.lower() for h in allowed])\n    headers = {\n        header: value\n        for header, value in headers.items()\n        if not is_entity_header(header) or header.lower() in allowed\n    }\n    return headers",
        "begin_line": 122,
        "end_line": 138,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.helpers.import_string#141",
        "src_path": "sanic/helpers.py",
        "class_name": "sanic.helpers",
        "signature": "sanic.helpers.import_string(module_name, package=None)",
        "snippet": "def import_string(module_name, package=None):\n    \"\"\"\n    import a module or class by string path.\n\n    :module_name: str with path of module or path to import and\n    instanciate a class\n    :returns: a module object or one instance from class if\n    module_name is a valid path to class\n\n    \"\"\"\n    module, klass = module_name.rsplit(\".\", 1)\n    module = import_module(module, package=package)\n    obj = getattr(module, klass)\n    if ismodule(obj):\n        return obj\n    return obj()",
        "begin_line": 141,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.headers.parse_content_header#26",
        "src_path": "sanic/headers.py",
        "class_name": "sanic.headers",
        "signature": "sanic.headers.parse_content_header(value: str)",
        "snippet": "def parse_content_header(value: str) -> Tuple[str, Options]:\n    \"\"\"Parse content-type and content-disposition header values.\n\n    E.g. 'form-data; name=upload; filename=\\\"file.txt\\\"' to\n    ('form-data', {'name': 'upload', 'filename': 'file.txt'})\n\n    Mostly identical to cgi.parse_header and werkzeug.parse_options_header\n    but runs faster and handles special characters better. Unescapes quotes.\n    \"\"\"\n    value = _firefox_quote_escape.sub(\"%22\", value)\n    pos = value.find(\";\")\n    if pos == -1:\n        options: Dict[str, Union[int, str]] = {}\n    else:\n        options = {\n            m.group(1).lower(): m.group(2) or m.group(3).replace(\"%22\", '\"')\n            for m in _param.finditer(value[pos:])\n        }\n        value = value[:pos]\n    return value.strip().lower(), options",
        "begin_line": 26,
        "end_line": 45,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004338394793926247,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.headers.parse_forwarded#56",
        "src_path": "sanic/headers.py",
        "class_name": "sanic.headers",
        "signature": "sanic.headers.parse_forwarded(headers, config)",
        "snippet": "def parse_forwarded(headers, config) -> Optional[Options]:\n    \"\"\"Parse RFC 7239 Forwarded headers.\n    The value of `by` or `secret` must match `config.FORWARDED_SECRET`\n    :return: dict with keys and values, or None if nothing matched\n    \"\"\"\n    header = headers.getall(\"forwarded\", None)\n    secret = config.FORWARDED_SECRET\n    if header is None or not secret:\n        return None\n    header = \",\".join(header)  # Join multiple header lines\n    if secret not in header:\n        return None\n    # Loop over <separator><key>=<value> elements from right to left\n    sep = pos = None\n    options: List[Tuple[str, str]] = []\n    found = False\n    for m in _rparam.finditer(header[::-1]):\n        # Start of new element? (on parser skips and non-semicolon right sep)\n        if m.start() != pos or sep != \";\":\n            # Was the previous element (from right) what we wanted?\n            if found:\n                break\n            # Clear values and parse as new element\n            del options[:]\n        pos = m.end()\n        val_token, val_quoted, key, sep = m.groups()\n        key = key.lower()[::-1]\n        val = (val_token or val_quoted.replace('\"\\\\', '\"'))[::-1]\n        options.append((key, val))\n        if key in (\"secret\", \"by\") and val == secret:\n            found = True\n        # Check if we would return on next round, to avoid useless parse\n        if found and sep != \";\":\n            break\n    # If secret was found, return the matching options in left-to-right order\n    return fwd_normalize(reversed(options)) if found else None",
        "begin_line": 56,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00267379679144385,
            "pseudo_dstar_susp": 0.003875968992248062,
            "pseudo_tarantula_susp": 0.0027247956403269754,
            "pseudo_op2_susp": 0.003875968992248062,
            "pseudo_barinel_susp": 0.0027247956403269754
        }
    },
    {
        "name": "sanic.headers.parse_xforwarded#94",
        "src_path": "sanic/headers.py",
        "class_name": "sanic.headers",
        "signature": "sanic.headers.parse_xforwarded(headers, config)",
        "snippet": "def parse_xforwarded(headers, config) -> Optional[Options]:\n    \"\"\"Parse traditional proxy headers.\"\"\"\n    real_ip_header = config.REAL_IP_HEADER\n    proxies_count = config.PROXIES_COUNT\n    addr = real_ip_header and headers.get(real_ip_header)\n    if not addr and proxies_count:\n        assert proxies_count > 0\n        try:\n            # Combine, split and filter multiple headers' entries\n            forwarded_for = headers.getall(config.FORWARDED_FOR_HEADER)\n            proxies = [\n                p\n                for p in (\n                    p.strip() for h in forwarded_for for p in h.split(\",\")\n                )\n                if p\n            ]\n            addr = proxies[-proxies_count]\n        except (KeyError, IndexError):\n            pass\n    # No processing of other headers if no address is found\n    if not addr:\n        return None\n\n    def options():\n        yield \"for\", addr\n        for key, header in (\n            (\"proto\", \"x-scheme\"),\n            (\"proto\", \"x-forwarded-proto\"),  # Overrides X-Scheme if present\n            (\"host\", \"x-forwarded-host\"),\n            (\"port\", \"x-forwarded-port\"),\n            (\"path\", \"x-forwarded-path\"),\n        ):\n            yield key, headers.get(header)\n\n    return fwd_normalize(options())",
        "begin_line": 94,
        "end_line": 129,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035460992907801418,
            "pseudo_dstar_susp": 0.006024096385542169,
            "pseudo_tarantula_susp": 0.0036496350364963502,
            "pseudo_op2_susp": 0.006024096385542169,
            "pseudo_barinel_susp": 0.0036496350364963502
        }
    },
    {
        "name": "sanic.headers.options#118",
        "src_path": "sanic/headers.py",
        "class_name": "sanic.headers",
        "signature": "sanic.headers.options()",
        "snippet": "    def options():\n        yield \"for\", addr\n        for key, header in (\n            (\"proto\", \"x-scheme\"),\n            (\"proto\", \"x-forwarded-proto\"),  # Overrides X-Scheme if present\n            (\"host\", \"x-forwarded-host\"),\n            (\"port\", \"x-forwarded-port\"),\n            (\"path\", \"x-forwarded-path\"),\n        ):\n            yield key, headers.get(header)",
        "begin_line": 118,
        "end_line": 127,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00046728971962616824,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.headers.fwd_normalize#132",
        "src_path": "sanic/headers.py",
        "class_name": "sanic.headers",
        "signature": "sanic.headers.fwd_normalize(fwd: OptionsIterable)",
        "snippet": "def fwd_normalize(fwd: OptionsIterable) -> Options:\n    \"\"\"Normalize and convert values extracted from forwarded headers.\"\"\"\n    ret: Dict[str, Union[int, str]] = {}\n    for key, val in fwd:\n        if val is not None:\n            try:\n                if key in (\"by\", \"for\"):\n                    ret[key] = fwd_normalize_address(val)\n                elif key in (\"host\", \"proto\"):\n                    ret[key] = val.lower()\n                elif key == \"port\":\n                    ret[key] = int(val)\n                elif key == \"path\":\n                    ret[key] = unquote(val)\n                else:\n                    ret[key] = val\n            except ValueError:\n                pass\n    return ret",
        "begin_line": 132,
        "end_line": 150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.headers.fwd_normalize_address#153",
        "src_path": "sanic/headers.py",
        "class_name": "sanic.headers",
        "signature": "sanic.headers.fwd_normalize_address(addr: str)",
        "snippet": "def fwd_normalize_address(addr: str) -> str:\n    \"\"\"Normalize address fields of proxy headers.\"\"\"\n    if addr == \"unknown\":\n        raise ValueError()  # omit unknown value identifiers\n    if addr.startswith(\"_\"):\n        return addr  # do not lower-case obfuscated strings\n    if _ipv6_re.fullmatch(addr):\n        addr = f\"[{addr}]\"  # bracket IPv6\n    return addr.lower()",
        "begin_line": 153,
        "end_line": 161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.headers.parse_host#164",
        "src_path": "sanic/headers.py",
        "class_name": "sanic.headers",
        "signature": "sanic.headers.parse_host(host: str)",
        "snippet": "def parse_host(host: str) -> Tuple[Optional[str], Optional[int]]:\n    \"\"\"Split host:port into hostname and port.\n    :return: None in place of missing elements\n    \"\"\"\n    m = _host_re.fullmatch(host)\n    if not m:\n        return None, None\n    host, port = m.groups()\n    return host.lower(), int(port) if port is not None else None",
        "begin_line": 164,
        "end_line": 172,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.RequestParameters.get#40",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.RequestParameters",
        "signature": "sanic.request.RequestParameters.get(self, name, default=None)",
        "snippet": "    def get(self, name, default=None):\n        \"\"\"Return the first value, either the default or actual\"\"\"\n        return super().get(name, [default])[0]",
        "begin_line": 40,
        "end_line": 42,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004084967320261438,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.RequestParameters.getlist#44",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.RequestParameters",
        "signature": "sanic.request.RequestParameters.getlist(self, name, default=None)",
        "snippet": "    def getlist(self, name, default=None):\n        \"\"\"Return the entire list\"\"\"\n        return super().get(name, default)",
        "begin_line": 44,
        "end_line": 46,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004997501249375312,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.StreamBuffer.__init__#50",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.StreamBuffer",
        "signature": "sanic.request.StreamBuffer.__init__(self, buffer_size=100)",
        "snippet": "    def __init__(self, buffer_size=100):\n        self._queue = asyncio.Queue(buffer_size)",
        "begin_line": 50,
        "end_line": 51,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.020833333333333332,
            "pseudo_dstar_susp": 0.001402524544179523,
            "pseudo_tarantula_susp": 0.020833333333333332,
            "pseudo_op2_susp": 0.001402524544179523,
            "pseudo_barinel_susp": 0.020833333333333332
        }
    },
    {
        "name": "sanic.request.StreamBuffer.read#53",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.StreamBuffer",
        "signature": "sanic.request.StreamBuffer.read(self)",
        "snippet": "    async def read(self):\n        \"\"\" Stop reading when gets None \"\"\"\n        payload = await self._queue.get()\n        self._queue.task_done()\n        return payload",
        "begin_line": 53,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.023809523809523808,
            "pseudo_dstar_susp": 0.0014144271570014145,
            "pseudo_tarantula_susp": 0.023809523809523808,
            "pseudo_op2_susp": 0.0014144271570014145,
            "pseudo_barinel_susp": 0.023809523809523808
        }
    },
    {
        "name": "sanic.request.StreamBuffer.put#59",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.StreamBuffer",
        "signature": "sanic.request.StreamBuffer.put(self, payload)",
        "snippet": "    async def put(self, payload):\n        await self._queue.put(payload)",
        "begin_line": 59,
        "end_line": 60,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.020833333333333332,
            "pseudo_dstar_susp": 0.001402524544179523,
            "pseudo_tarantula_susp": 0.020833333333333332,
            "pseudo_op2_susp": 0.001402524544179523,
            "pseudo_barinel_susp": 0.020833333333333332
        }
    },
    {
        "name": "sanic.request.StreamBuffer.is_full#62",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.StreamBuffer",
        "signature": "sanic.request.StreamBuffer.is_full(self)",
        "snippet": "    def is_full(self):\n        return self._queue.full()",
        "begin_line": 62,
        "end_line": 63,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.030303030303030304,
            "pseudo_dstar_susp": 0.0014326647564469914,
            "pseudo_tarantula_susp": 0.030303030303030304,
            "pseudo_op2_susp": 0.0014326647564469914,
            "pseudo_barinel_susp": 0.030303030303030304
        }
    },
    {
        "name": "sanic.request.Request.__init__#96",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.__init__(self, url_bytes, headers, version, method, transport, app)",
        "snippet": "    def __init__(self, url_bytes, headers, version, method, transport, app):\n        self.raw_url = url_bytes\n        # TODO: Content-Encoding detection\n        self._parsed_url = parse_url(url_bytes)\n        self.app = app\n\n        self.headers = headers\n        self.version = version\n        self.method = method\n        self.transport = transport\n\n        # Init but do not inhale\n        self.body_init()\n        self.ctx = SimpleNamespace()\n        self.parsed_forwarded = None\n        self.parsed_json = None\n        self.parsed_form = None\n        self.parsed_files = None\n        self.parsed_args = defaultdict(RequestParameters)\n        self.parsed_not_grouped_args = defaultdict(list)\n        self.uri_template = None\n        self._cookies = None\n        self.stream = None\n        self.endpoint = None",
        "begin_line": 96,
        "end_line": 119,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015313935681470138,
            "pseudo_dstar_susp": 0.00186219739292365,
            "pseudo_tarantula_susp": 0.0015384615384615385,
            "pseudo_op2_susp": 0.00186219739292365,
            "pseudo_barinel_susp": 0.0015384615384615385
        }
    },
    {
        "name": "sanic.request.Request.__repr__#121",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return \"<{0}: {1} {2}>\".format(\n            self.__class__.__name__, self.method, self.path\n        )",
        "begin_line": 121,
        "end_line": 124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005586592178770949,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.get#126",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.get(self, key, default=None)",
        "snippet": "    def get(self, key, default=None):\n        \"\"\".. deprecated:: 19.9\n           Custom context is now stored in `request.custom_context.yourkey`\"\"\"\n        return self.ctx.__dict__.get(key, default)",
        "begin_line": 126,
        "end_line": 129,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.__contains__#131",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.__contains__(self, key)",
        "snippet": "    def __contains__(self, key):\n        \"\"\".. deprecated:: 19.9\n           Custom context is now stored in `request.custom_context.yourkey`\"\"\"\n        return key in self.ctx.__dict__",
        "begin_line": 131,
        "end_line": 134,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.__getitem__#136",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.__getitem__(self, key)",
        "snippet": "    def __getitem__(self, key):\n        \"\"\".. deprecated:: 19.9\n           Custom context is now stored in `request.custom_context.yourkey`\"\"\"\n        return self.ctx.__dict__[key]",
        "begin_line": 136,
        "end_line": 139,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.__delitem__#141",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.__delitem__(self, key)",
        "snippet": "    def __delitem__(self, key):\n        \"\"\".. deprecated:: 19.9\n           Custom context is now stored in `request.custom_context.yourkey`\"\"\"\n        del self.ctx.__dict__[key]",
        "begin_line": 141,
        "end_line": 144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.__setitem__#146",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.__setitem__(self, key, value)",
        "snippet": "    def __setitem__(self, key, value):\n        \"\"\".. deprecated:: 19.9\n           Custom context is now stored in `request.custom_context.yourkey`\"\"\"\n        setattr(self.ctx, key, value)",
        "begin_line": 146,
        "end_line": 149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.body_init#151",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.body_init(self)",
        "snippet": "    def body_init(self):\n        self.body = []",
        "begin_line": 151,
        "end_line": 152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015748031496062992,
            "pseudo_dstar_susp": 0.0019267822736030828,
            "pseudo_tarantula_susp": 0.0015822784810126582,
            "pseudo_op2_susp": 0.0019267822736030828,
            "pseudo_barinel_susp": 0.0015822784810126582
        }
    },
    {
        "name": "sanic.request.Request.body_push#154",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.body_push(self, data)",
        "snippet": "    def body_push(self, data):\n        self.body.append(data)",
        "begin_line": 154,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004084967320261438,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.body_finish#157",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.body_finish(self)",
        "snippet": "    def body_finish(self):\n        self.body = b\"\".join(self.body)",
        "begin_line": 157,
        "end_line": 158,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012254901960784314,
            "pseudo_dstar_susp": 0.0012254901960784314,
            "pseudo_tarantula_susp": 0.0012254901960784314,
            "pseudo_op2_susp": 0.0012254901960784314,
            "pseudo_barinel_susp": 0.0012254901960784314
        }
    },
    {
        "name": "sanic.request.Request.json#161",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.json(self)",
        "snippet": "    def json(self):\n        if self.parsed_json is None:\n            self.load_json()\n\n        return self.parsed_json",
        "begin_line": 161,
        "end_line": 165,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005393743257820927,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.load_json#167",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.load_json(self, loads=json_loads)",
        "snippet": "    def load_json(self, loads=json_loads):\n        try:\n            self.parsed_json = loads(self.body)\n        except Exception:\n            if not self.body:\n                return None\n            raise InvalidUsage(\"Failed when parsing body as json\")\n\n        return self.parsed_json",
        "begin_line": 167,
        "end_line": 175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.token#178",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.token(self)",
        "snippet": "    def token(self):\n        \"\"\"Attempt to return the auth header token.\n\n        :return: token related to request\n        \"\"\"\n        prefixes = (\"Bearer\", \"Token\")\n        auth_header = self.headers.get(\"Authorization\")\n\n        if auth_header is not None:\n            for prefix in prefixes:\n                if prefix in auth_header:\n                    return auth_header.partition(prefix)[-1].strip()\n\n        return auth_header",
        "begin_line": 178,
        "end_line": 191,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.form#194",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.form(self)",
        "snippet": "    def form(self):\n        if self.parsed_form is None:\n            self.parsed_form = RequestParameters()\n            self.parsed_files = RequestParameters()\n            content_type = self.headers.get(\n                \"Content-Type\", DEFAULT_HTTP_CONTENT_TYPE\n            )\n            content_type, parameters = parse_content_header(content_type)\n            try:\n                if content_type == \"application/x-www-form-urlencoded\":\n                    self.parsed_form = RequestParameters(\n                        parse_qs(self.body.decode(\"utf-8\"))\n                    )\n                elif content_type == \"multipart/form-data\":\n                    # TODO: Stream this instead of reading to/from memory\n                    boundary = parameters[\"boundary\"].encode(\"utf-8\")\n                    self.parsed_form, self.parsed_files = parse_multipart_form(\n                        self.body, boundary\n                    )\n            except Exception:\n                error_logger.exception(\"Failed when parsing form\")\n\n        return self.parsed_form",
        "begin_line": 194,
        "end_line": 216,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.files#219",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.files(self)",
        "snippet": "    def files(self):\n        if self.parsed_files is None:\n            self.form  # compute form to get files\n\n        return self.parsed_files",
        "begin_line": 219,
        "end_line": 223,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004338394793926247,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.get_args#225",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.get_args(self, keep_blank_values: bool=False, strict_parsing: bool=False, encoding: str='utf-8', errors: str='replace')",
        "snippet": "    def get_args(\n        self,\n        keep_blank_values: bool = False,\n        strict_parsing: bool = False,\n        encoding: str = \"utf-8\",\n        errors: str = \"replace\",\n    ) -> RequestParameters:\n        \"\"\"\n        Method to parse `query_string` using `urllib.parse.parse_qs`.\n        This methods is used by `args` property.\n        Can be used directly if you need to change default parameters.\n\n        :param keep_blank_values:\n            flag indicating whether blank values in\n            percent-encoded queries should be treated as blank strings.\n            A true value indicates that blanks should be retained as blank\n            strings.  The default false value indicates that blank values\n            are to be ignored and treated as if they were  not included.\n        :type keep_blank_values: bool\n        :param strict_parsing:\n            flag indicating what to do with parsing errors.\n            If false (the default), errors are silently ignored. If true,\n            errors raise a ValueError exception.\n        :type strict_parsing: bool\n        :param encoding:\n            specify how to decode percent-encoded sequences\n            into Unicode characters, as accepted by the bytes.decode() method.\n        :type encoding: str\n        :param errors:\n            specify how to decode percent-encoded sequences\n            into Unicode characters, as accepted by the bytes.decode() method.\n        :type errors: str\n        :return: RequestParameters\n        \"\"\"\n        if not self.parsed_args[\n            (keep_blank_values, strict_parsing, encoding, errors)\n        ]:\n            if self.query_string:\n                self.parsed_args[\n                    (keep_blank_values, strict_parsing, encoding, errors)\n                ] = RequestParameters(\n                    parse_qs(\n                        qs=self.query_string,\n                        keep_blank_values=keep_blank_values,\n                        strict_parsing=strict_parsing,\n                        encoding=encoding,\n                        errors=errors,\n                    )\n                )\n\n        return self.parsed_args[\n            (keep_blank_values, strict_parsing, encoding, errors)\n        ]",
        "begin_line": 225,
        "end_line": 277,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005184033177812338,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.raw_args#282",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.raw_args(self)",
        "snippet": "    def raw_args(self) -> dict:\n        if self.app.debug:  # pragma: no cover\n            warnings.simplefilter(\"default\")\n        warnings.warn(\n            \"Use of raw_args will be deprecated in \"\n            \"the future versions. Please use args or query_args \"\n            \"properties instead\",\n            DeprecationWarning,\n        )\n        return {k: v[0] for k, v in self.args.items()}",
        "begin_line": 282,
        "end_line": 291,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.get_query_args#293",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.get_query_args(self, keep_blank_values: bool=False, strict_parsing: bool=False, encoding: str='utf-8', errors: str='replace')",
        "snippet": "    def get_query_args(\n        self,\n        keep_blank_values: bool = False,\n        strict_parsing: bool = False,\n        encoding: str = \"utf-8\",\n        errors: str = \"replace\",\n    ) -> list:\n        \"\"\"\n        Method to parse `query_string` using `urllib.parse.parse_qsl`.\n        This methods is used by `query_args` property.\n        Can be used directly if you need to change default parameters.\n\n        :param keep_blank_values:\n            flag indicating whether blank values in\n            percent-encoded queries should be treated as blank strings.\n            A true value indicates that blanks should be retained as blank\n            strings.  The default false value indicates that blank values\n            are to be ignored and treated as if they were  not included.\n        :type keep_blank_values: bool\n        :param strict_parsing:\n            flag indicating what to do with parsing errors.\n            If false (the default), errors are silently ignored. If true,\n            errors raise a ValueError exception.\n        :type strict_parsing: bool\n        :param encoding:\n            specify how to decode percent-encoded sequences\n            into Unicode characters, as accepted by the bytes.decode() method.\n        :type encoding: str\n        :param errors:\n            specify how to decode percent-encoded sequences\n            into Unicode characters, as accepted by the bytes.decode() method.\n        :type errors: str\n        :return: list\n        \"\"\"\n        if not self.parsed_not_grouped_args[\n            (keep_blank_values, strict_parsing, encoding, errors)\n        ]:\n            if self.query_string:\n                self.parsed_not_grouped_args[\n                    (keep_blank_values, strict_parsing, encoding, errors)\n                ] = parse_qsl(\n                    qs=self.query_string,\n                    keep_blank_values=keep_blank_values,\n                    strict_parsing=strict_parsing,\n                    encoding=encoding,\n                    errors=errors,\n                )\n        return self.parsed_not_grouped_args[\n            (keep_blank_values, strict_parsing, encoding, errors)\n        ]",
        "begin_line": 293,
        "end_line": 342,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.cookies#347",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.cookies(self)",
        "snippet": "    def cookies(self):\n        if self._cookies is None:\n            cookie = self.headers.get(\"Cookie\")\n            if cookie is not None:\n                cookies = SimpleCookie()\n                cookies.load(cookie)\n                self._cookies = {\n                    name: cookie.value for name, cookie in cookies.items()\n                }\n            else:\n                self._cookies = {}\n        return self._cookies",
        "begin_line": 347,
        "end_line": 358,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.ip#361",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.ip(self)",
        "snippet": "    def ip(self):\n        \"\"\"\n        :return: peer ip of the socket\n        \"\"\"\n        if not hasattr(self, \"_socket\"):\n            self._get_address()\n        return self._ip",
        "begin_line": 361,
        "end_line": 367,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0045871559633027525,
            "pseudo_dstar_susp": 0.00980392156862745,
            "pseudo_tarantula_susp": 0.004784688995215311,
            "pseudo_op2_susp": 0.00980392156862745,
            "pseudo_barinel_susp": 0.004784688995215311
        }
    },
    {
        "name": "sanic.request.Request.port#370",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.port(self)",
        "snippet": "    def port(self):\n        \"\"\"\n        :return: peer port of the socket\n        \"\"\"\n        if not hasattr(self, \"_socket\"):\n            self._get_address()\n        return self._port",
        "begin_line": 370,
        "end_line": 376,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004807692307692308,
            "pseudo_dstar_susp": 0.010869565217391304,
            "pseudo_tarantula_susp": 0.005025125628140704,
            "pseudo_op2_susp": 0.010869565217391304,
            "pseudo_barinel_susp": 0.005025125628140704
        }
    },
    {
        "name": "sanic.request.Request.socket#379",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.socket(self)",
        "snippet": "    def socket(self):\n        if not hasattr(self, \"_socket\"):\n            self._get_address()\n        return self._socket",
        "begin_line": 379,
        "end_line": 382,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request._get_address#384",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request._get_address(self)",
        "snippet": "    def _get_address(self):\n        self._socket = self.transport.get_extra_info(\"peername\") or (\n            None,\n            None,\n        )\n        self._ip = self._socket[0]\n        self._port = self._socket[1]",
        "begin_line": 384,
        "end_line": 390,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004329004329004329,
            "pseudo_dstar_susp": 0.008695652173913044,
            "pseudo_tarantula_susp": 0.0045045045045045045,
            "pseudo_op2_susp": 0.008695652173913044,
            "pseudo_barinel_susp": 0.0045045045045045045
        }
    },
    {
        "name": "sanic.request.Request.server_name#393",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.server_name(self)",
        "snippet": "    def server_name(self):\n        \"\"\"\n        Attempt to get the server's external hostname in this order:\n        `config.SERVER_NAME`, proxied or direct Host headers\n        :func:`Request.host`\n\n        :return: the server name without port number\n        :rtype: str\n        \"\"\"\n        server_name = self.app.config.get(\"SERVER_NAME\")\n        if server_name:\n            host = server_name.split(\"//\", 1)[-1].split(\"/\", 1)[0]\n            return parse_host(host)[0]\n        return parse_host(self.host)[0]",
        "begin_line": 393,
        "end_line": 406,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.forwarded#409",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.forwarded(self)",
        "snippet": "    def forwarded(self):\n        if self.parsed_forwarded is None:\n            self.parsed_forwarded = (\n                parse_forwarded(self.headers, self.app.config)\n                or parse_xforwarded(self.headers, self.app.config)\n                or {}\n            )\n        return self.parsed_forwarded",
        "begin_line": 409,
        "end_line": 416,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035460992907801418,
            "pseudo_dstar_susp": 0.006024096385542169,
            "pseudo_tarantula_susp": 0.0036496350364963502,
            "pseudo_op2_susp": 0.006024096385542169,
            "pseudo_barinel_susp": 0.0036496350364963502
        }
    },
    {
        "name": "sanic.request.Request.server_port#419",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.server_port(self)",
        "snippet": "    def server_port(self):\n        \"\"\"\n        Attempt to get the server's external port number in this order:\n        `config.SERVER_NAME`, proxied or direct Host headers\n        :func:`Request.host`,\n        actual port used by the transport layer socket.\n        :return: server port\n        :rtype: int\n        \"\"\"\n        if self.forwarded:\n            return self.forwarded.get(\"port\") or (\n                80 if self.scheme in (\"http\", \"ws\") else 443\n            )\n        return (\n            parse_host(self.host)[1]\n            or self.transport.get_extra_info(\"sockname\")[1]\n        )",
        "begin_line": 419,
        "end_line": 435,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.remote_addr#438",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.remote_addr(self)",
        "snippet": "    def remote_addr(self):\n        \"\"\"Attempt to return the original client ip based on `forwarded`,\n        `x-forwarded-for` or `x-real-ip`. If HTTP headers are unavailable or\n        untrusted, returns an empty string.\n\n        :return: original client ip.\n        \"\"\"\n        if not hasattr(self, \"_remote_addr\"):\n            self._remote_addr = self.forwarded.get(\"for\", \"\")\n        return self._remote_addr",
        "begin_line": 438,
        "end_line": 447,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00048449612403100775,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.scheme#450",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.scheme(self)",
        "snippet": "    def scheme(self):\n        \"\"\"\n        Attempt to get the request scheme.\n        Seeking the value in this order:\n        `forwarded` header, `x-forwarded-proto` header,\n        `x-scheme` header, the sanic app itself.\n\n        :return: http|https|ws|wss or arbitrary value given by the headers.\n        :rtype: str\n        \"\"\"\n        forwarded_proto = self.forwarded.get(\"proto\")\n        if forwarded_proto:\n            return forwarded_proto\n\n        if (\n            self.app.websocket_enabled\n            and self.headers.get(\"upgrade\") == \"websocket\"\n        ):\n            scheme = \"ws\"\n        else:\n            scheme = \"http\"\n\n        if self.transport.get_extra_info(\"sslcontext\"):\n            scheme += \"s\"\n\n        return scheme",
        "begin_line": 450,
        "end_line": 475,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00411522633744856,
            "pseudo_dstar_susp": 0.007874015748031496,
            "pseudo_tarantula_susp": 0.004273504273504274,
            "pseudo_op2_susp": 0.007874015748031496,
            "pseudo_barinel_susp": 0.004273504273504274
        }
    },
    {
        "name": "sanic.request.Request.host#478",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.host(self)",
        "snippet": "    def host(self):\n        \"\"\"\n        :return: proxied or direct Host header. Hostname and port number may be\n          separated by sanic.headers.parse_host(request.host).\n        \"\"\"\n        return self.forwarded.get(\"host\", self.headers.get(\"Host\", \"\"))",
        "begin_line": 478,
        "end_line": 483,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003861003861003861,
            "pseudo_dstar_susp": 0.006993006993006993,
            "pseudo_tarantula_susp": 0.00398406374501992,
            "pseudo_op2_susp": 0.006993006993006993,
            "pseudo_barinel_susp": 0.00398406374501992
        }
    },
    {
        "name": "sanic.request.Request.content_type#486",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.content_type(self)",
        "snippet": "    def content_type(self):\n        return self.headers.get(\"Content-Type\", DEFAULT_HTTP_CONTENT_TYPE)",
        "begin_line": 486,
        "end_line": 487,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.match_info#490",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.match_info(self)",
        "snippet": "    def match_info(self):\n        \"\"\"return matched info after resolving route\"\"\"\n        return self.app.router.get(self)[2]",
        "begin_line": 490,
        "end_line": 492,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.request.Request.path#495",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.path(self)",
        "snippet": "    def path(self):\n        return self._parsed_url.path.decode(\"utf-8\")",
        "begin_line": 495,
        "end_line": 496,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015313935681470138,
            "pseudo_dstar_susp": 0.00186219739292365,
            "pseudo_tarantula_susp": 0.0015384615384615385,
            "pseudo_op2_susp": 0.00186219739292365,
            "pseudo_barinel_susp": 0.0015384615384615385
        }
    },
    {
        "name": "sanic.request.Request.query_string#499",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.query_string(self)",
        "snippet": "    def query_string(self):\n        if self._parsed_url.query:\n            return self._parsed_url.query.decode(\"utf-8\")\n        else:\n            return \"\"",
        "begin_line": 499,
        "end_line": 503,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0051813471502590676,
            "pseudo_dstar_susp": 0.012987012987012988,
            "pseudo_tarantula_susp": 0.005434782608695652,
            "pseudo_op2_susp": 0.012987012987012988,
            "pseudo_barinel_susp": 0.005434782608695652
        }
    },
    {
        "name": "sanic.request.Request.url#506",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.url(self)",
        "snippet": "    def url(self):\n        return urlunparse(\n            (self.scheme, self.host, self.path, None, self.query_string, None)\n        )",
        "begin_line": 506,
        "end_line": 509,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00398406374501992,
            "pseudo_dstar_susp": 0.007407407407407408,
            "pseudo_tarantula_susp": 0.00411522633744856,
            "pseudo_op2_susp": 0.007407407407407408,
            "pseudo_barinel_susp": 0.00411522633744856
        }
    },
    {
        "name": "sanic.request.Request.url_for#511",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request.Request",
        "signature": "sanic.request.Request.url_for(self, view_name, **kwargs)",
        "snippet": "    def url_for(self, view_name, **kwargs):\n        \"\"\"\n        Same as :func:`sanic.Sanic.url_for`, but automatically determine\n        `scheme` and `netloc` base on the request. Since this method is aiming\n        to generate correct schema & netloc, `_external` is implied.\n\n        :param kwargs: takes same parameters as in :func:`sanic.Sanic.url_for`\n        :return: an absolute url to the given view\n        :rtype: str\n        \"\"\"\n        # Full URL SERVER_NAME can only be handled in app.url_for\n        if \"//\" in self.app.config.SERVER_NAME:\n            return self.app.url_for(view_name, _external=True, **kwargs)\n\n        scheme = self.scheme\n        host = self.server_name\n        port = self.server_port\n\n        if (scheme.lower() in (\"http\", \"ws\") and port == 80) or (\n            scheme.lower() in (\"https\", \"wss\") and port == 443\n        ):\n            netloc = host\n        else:\n            netloc = \"{}:{}\".format(host, port)\n\n        return self.app.url_for(\n            view_name, _external=True, _scheme=scheme, _server=netloc, **kwargs\n        )",
        "begin_line": 511,
        "end_line": 538,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.1,
            "pseudo_dstar_susp": 0.0014814814814814814,
            "pseudo_tarantula_susp": 0.1,
            "pseudo_op2_susp": 0.0014814814814814814,
            "pseudo_barinel_susp": 0.1
        }
    },
    {
        "name": "sanic.request.parse_multipart_form#544",
        "src_path": "sanic/request.py",
        "class_name": "sanic.request",
        "signature": "sanic.request.parse_multipart_form(body, boundary)",
        "snippet": "def parse_multipart_form(body, boundary):\n    \"\"\"Parse a request body and returns fields and files\n\n    :param body: bytes request body\n    :param boundary: bytes multipart boundary\n    :return: fields (RequestParameters), files (RequestParameters)\n    \"\"\"\n    files = RequestParameters()\n    fields = RequestParameters()\n\n    form_parts = body.split(boundary)\n    for form_part in form_parts[1:-1]:\n        file_name = None\n        content_type = \"text/plain\"\n        content_charset = \"utf-8\"\n        field_name = None\n        line_index = 2\n        line_end_index = 0\n        while not line_end_index == -1:\n            line_end_index = form_part.find(b\"\\r\\n\", line_index)\n            form_line = form_part[line_index:line_end_index].decode(\"utf-8\")\n            line_index = line_end_index + 2\n\n            if not form_line:\n                break\n\n            colon_index = form_line.index(\":\")\n            form_header_field = form_line[0:colon_index].lower()\n            form_header_value, form_parameters = parse_content_header(\n                form_line[colon_index + 2 :]\n            )\n\n            if form_header_field == \"content-disposition\":\n                field_name = form_parameters.get(\"name\")\n                file_name = form_parameters.get(\"filename\")\n\n                # non-ASCII filenames in RFC2231, \"filename*\" format\n                if file_name is None and form_parameters.get(\"filename*\"):\n                    encoding, _, value = email.utils.decode_rfc2231(\n                        form_parameters[\"filename*\"]\n                    )\n                    file_name = unquote(value, encoding=encoding)\n            elif form_header_field == \"content-type\":\n                content_type = form_header_value\n                content_charset = form_parameters.get(\"charset\", \"utf-8\")\n\n        if field_name:\n            post_data = form_part[line_index:-4]\n            if file_name is None:\n                value = post_data.decode(content_charset)\n                if field_name in fields:\n                    fields[field_name].append(value)\n                else:\n                    fields[field_name] = [value]\n            else:\n                form_file = File(\n                    type=content_type, name=file_name, body=post_data\n                )\n                if field_name in files:\n                    files[field_name].append(form_file)\n                else:\n                    files[field_name] = [form_file]\n        else:\n            logger.debug(\n                \"Form-data field does not have a 'name' parameter \"\n                \"in the Content-Disposition header\"\n            )\n\n    return fields, files",
        "begin_line": 544,
        "end_line": 612,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.views.HTTPMethodView.dispatch_request#44",
        "src_path": "sanic/views.py",
        "class_name": "sanic.views.HTTPMethodView",
        "signature": "sanic.views.HTTPMethodView.dispatch_request(self, request, *args, **kwargs)",
        "snippet": "    def dispatch_request(self, request, *args, **kwargs):\n        handler = getattr(self, request.method.lower(), None)\n        return handler(request, *args, **kwargs)",
        "begin_line": 44,
        "end_line": 46,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.011764705882352941,
            "pseudo_dstar_susp": 0.0013422818791946308,
            "pseudo_tarantula_susp": 0.0125,
            "pseudo_op2_susp": 0.0013422818791946308,
            "pseudo_barinel_susp": 0.0125
        }
    },
    {
        "name": "sanic.views.HTTPMethodView.view#54",
        "src_path": "sanic/views.py",
        "class_name": "sanic.views.HTTPMethodView",
        "signature": "sanic.views.HTTPMethodView.view(*args, **kwargs)",
        "snippet": "        def view(*args, **kwargs):\n            self = view.view_class(*class_args, **class_kwargs)\n            return self.dispatch_request(*args, **kwargs)",
        "begin_line": 54,
        "end_line": 56,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.019230769230769232,
            "pseudo_dstar_susp": 0.1,
            "pseudo_tarantula_susp": 0.0125,
            "pseudo_op2_susp": 0.1,
            "pseudo_barinel_susp": 0.0125
        }
    },
    {
        "name": "sanic.views.HTTPMethodView.as_view#49",
        "src_path": "sanic/views.py",
        "class_name": "sanic.views.HTTPMethodView",
        "signature": "sanic.views.HTTPMethodView.as_view(cls, *class_args, **class_kwargs)",
        "snippet": "    def as_view(cls, *class_args, **class_kwargs):\n        \"\"\"Return view function for use with the routing system, that\n        dispatches request to appropriate handler method.\n        \"\"\"\n\n        def view(*args, **kwargs):\n            self = view.view_class(*class_args, **class_kwargs)\n            return self.dispatch_request(*args, **kwargs)\n\n        if cls.decorators:\n            view.__module__ = cls.__module__\n            for decorator in cls.decorators:\n                view = decorator(view)\n\n        view.view_class = cls\n        view.__doc__ = cls.__doc__\n        view.__module__ = cls.__module__\n        view.__name__ = cls.__name__\n        return view",
        "begin_line": 49,
        "end_line": 67,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01098901098901099,
            "pseudo_dstar_susp": 0.0013315579227696406,
            "pseudo_tarantula_susp": 0.011494252873563218,
            "pseudo_op2_susp": 0.0013315579227696406,
            "pseudo_barinel_susp": 0.011494252873563218
        }
    },
    {
        "name": "sanic.views.stream#70",
        "src_path": "sanic/views.py",
        "class_name": "sanic.views",
        "signature": "sanic.views.stream(func)",
        "snippet": "def stream(func):\n    func.is_stream = True\n    return func",
        "begin_line": 70,
        "end_line": 72,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.06666666666666667,
            "pseudo_dstar_susp": 0.0014705882352941176,
            "pseudo_tarantula_susp": 0.06666666666666667,
            "pseudo_op2_susp": 0.0014705882352941176,
            "pseudo_barinel_susp": 0.06666666666666667
        }
    },
    {
        "name": "sanic.views.CompositionView.__init__#91",
        "src_path": "sanic/views.py",
        "class_name": "sanic.views.CompositionView",
        "signature": "sanic.views.CompositionView.__init__(self)",
        "snippet": "    def __init__(self):\n        self.handlers = {}",
        "begin_line": 91,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0003957261574990107,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.views.CompositionView.add#94",
        "src_path": "sanic/views.py",
        "class_name": "sanic.views.CompositionView",
        "signature": "sanic.views.CompositionView.add(self, methods, handler, stream=False)",
        "snippet": "    def add(self, methods, handler, stream=False):\n        if stream:\n            handler.is_stream = stream\n        for method in methods:\n            if method not in HTTP_METHODS:\n                raise InvalidUsage(\n                    \"{} is not a valid HTTP method.\".format(method)\n                )\n\n            if method in self.handlers:\n                raise InvalidUsage(\n                    \"Method {} is already registered.\".format(method)\n                )\n            self.handlers[method] = handler",
        "begin_line": 94,
        "end_line": 107,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.views.CompositionView.__call__#109",
        "src_path": "sanic/views.py",
        "class_name": "sanic.views.CompositionView",
        "signature": "sanic.views.CompositionView.__call__(self, request, *args, **kwargs)",
        "snippet": "    def __call__(self, request, *args, **kwargs):\n        handler = self.handlers[request.method.upper()]\n        return handler(request, *args, **kwargs)",
        "begin_line": 109,
        "end_line": 111,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005586592178770949,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.__init__#35",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.__init__(self, name=None, router=None, error_handler=None, load_env=True, request_class=None, strict_slashes=False, log_config=None, configure_logging=True)",
        "snippet": "    def __init__(\n        self,\n        name=None,\n        router=None,\n        error_handler=None,\n        load_env=True,\n        request_class=None,\n        strict_slashes=False,\n        log_config=None,\n        configure_logging=True,\n    ):\n\n        # Get name from previous stack frame\n        if name is None:\n            warnings.warn(\n                \"Sanic(name=None) is deprecated and None value support \"\n                \"for `name` will be removed in the next release. \"\n                \"Please use Sanic(name='your_application_name') instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            frame_records = stack()[1]\n            name = getmodulename(frame_records[1])\n\n        # logging\n        if configure_logging:\n            logging.config.dictConfig(log_config or LOGGING_CONFIG_DEFAULTS)\n\n        self.name = name\n        self.asgi = False\n        self.router = router or Router()\n        self.request_class = request_class\n        self.error_handler = error_handler or ErrorHandler()\n        self.config = Config(load_env=load_env)\n        self.request_middleware = deque()\n        self.response_middleware = deque()\n        self.blueprints = {}\n        self._blueprint_order = []\n        self.configure_logging = configure_logging\n        self.debug = None\n        self.sock = None\n        self.strict_slashes = strict_slashes\n        self.listeners = defaultdict(list)\n        self.is_running = False\n        self.is_request_stream = False\n        self.websocket_enabled = False\n        self.websocket_tasks = set()\n\n        # Register alternative method names\n        self.go_fast = self.run",
        "begin_line": 35,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013458950201884253,
            "pseudo_dstar_susp": 0.001594896331738437,
            "pseudo_tarantula_susp": 0.0013458950201884253,
            "pseudo_op2_susp": 0.001594896331738437,
            "pseudo_barinel_susp": 0.0013458950201884253
        }
    },
    {
        "name": "sanic.app.Sanic.loop#87",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.loop(self)",
        "snippet": "    def loop(self):\n        \"\"\"Synonymous with asyncio.get_event_loop().\n\n        Only supported when using the `app.run` method.\n        \"\"\"\n        if not self.is_running and self.asgi is False:\n            raise SanicException(\n                \"Loop can only be retrieved after the app has started \"\n                \"running. Not supported with `create_server` function\"\n            )\n        return get_event_loop()",
        "begin_line": 87,
        "end_line": 97,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0006317119393556538,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.add_task#103",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.add_task(self, task)",
        "snippet": "    def add_task(self, task):\n        \"\"\"Schedule a task to run later, after the loop has started.\n        Different from asyncio.ensure_future in that it does not\n        also return a future, and the actual ensure_future call\n        is delayed until before server start.\n\n        :param task: future, couroutine or awaitable\n        \"\"\"\n        try:\n            if callable(task):\n                try:\n                    self.loop.create_task(task(self))\n                except TypeError:\n                    self.loop.create_task(task())\n            else:\n                self.loop.create_task(task)\n        except SanicException:\n\n            @self.listener(\"before_server_start\")\n            def run(app, loop):\n                if callable(task):\n                    try:\n                        loop.create_task(task(self))\n                    except TypeError:\n                        loop.create_task(task())\n                else:\n                    loop.create_task(task)",
        "begin_line": 103,
        "end_line": 129,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.run#122",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.run(app, loop)",
        "snippet": "            def run(app, loop):\n                if callable(task):\n                    try:\n                        loop.create_task(task(self))\n                    except TypeError:\n                        loop.create_task(task())\n                else:\n                    loop.create_task(task)",
        "begin_line": 122,
        "end_line": 129,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.listener#132",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.listener(self, event)",
        "snippet": "    def listener(self, event):\n        \"\"\"Create a listener from a decorated function.\n\n        :param event: event to listen to\n        \"\"\"\n\n        def decorator(listener):\n            self.listeners[event].append(listener)\n            return listener\n\n        return decorator",
        "begin_line": 132,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016722408026755853,
            "pseudo_dstar_susp": 0.002074688796680498,
            "pseudo_tarantula_susp": 0.0016835016835016834,
            "pseudo_op2_susp": 0.002074688796680498,
            "pseudo_barinel_susp": 0.0016835016835016834
        }
    },
    {
        "name": "sanic.app.Sanic.decorator#138",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.decorator(listener)",
        "snippet": "        def decorator(listener):\n            self.listeners[event].append(listener)\n            return listener",
        "begin_line": 138,
        "end_line": 140,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007936507936507936,
            "pseudo_dstar_susp": 0.2,
            "pseudo_tarantula_susp": 0.0016835016835016834,
            "pseudo_op2_susp": 0.2,
            "pseudo_barinel_susp": 0.0016835016835016834
        }
    },
    {
        "name": "sanic.app.Sanic.register_listener#144",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.register_listener(self, listener, event)",
        "snippet": "    def register_listener(self, listener, event):\n        \"\"\"\n        Register the listener for a given event.\n\n        :param listener: callable i.e. setup_db(app, loop)\n        :param event: when to register listener i.e. 'before_server_start'\n        :return: listener\n        \"\"\"\n\n        return self.listener(event)(listener)",
        "begin_line": 144,
        "end_line": 153,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.route#156",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.route(self, uri, methods=frozenset({'GET'}), host=None, strict_slashes=None, stream=False, version=None, name=None)",
        "snippet": "    def route(\n        self,\n        uri,\n        methods=frozenset({\"GET\"}),\n        host=None,\n        strict_slashes=None,\n        stream=False,\n        version=None,\n        name=None,\n    ):\n        \"\"\"Decorate a function to be registered as a route\n\n        :param uri: path of the URL\n        :param methods: list or tuple of methods allowed\n        :param host:\n        :param strict_slashes:\n        :param stream:\n        :param version:\n        :param name: user defined route name for url_for\n        :return: decorated function\n        \"\"\"\n\n        # Fix case where the user did not prefix the URL with a /\n        # and will probably get confused as to why it's not working\n        if not uri.startswith(\"/\"):\n            uri = \"/\" + uri\n\n        if stream:\n            self.is_request_stream = True\n\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        def response(handler):\n            args = list(signature(handler).parameters.keys())\n\n            if not args:\n                raise ValueError(\n                    \"Required parameter `request` missing \"\n                    \"in the {0}() route?\".format(handler.__name__)\n                )\n\n            if stream:\n                handler.is_stream = stream\n\n            self.router.add(\n                uri=uri,\n                methods=methods,\n                handler=handler,\n                host=host,\n                strict_slashes=strict_slashes,\n                version=version,\n                name=name,\n            )\n            return handler\n\n        return response",
        "begin_line": 156,
        "end_line": 212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01818181818181818,
            "pseudo_dstar_susp": 0.0017605633802816902,
            "pseudo_tarantula_susp": 0.018518518518518517,
            "pseudo_op2_susp": 0.0017605633802816902,
            "pseudo_barinel_susp": 0.018518518518518517
        }
    },
    {
        "name": "sanic.app.Sanic.response#189",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.response(handler)",
        "snippet": "        def response(handler):\n            args = list(signature(handler).parameters.keys())\n\n            if not args:\n                raise ValueError(\n                    \"Required parameter `request` missing \"\n                    \"in the {0}() route?\".format(handler.__name__)\n                )\n\n            if stream:\n                handler.is_stream = stream\n\n            self.router.add(\n                uri=uri,\n                methods=methods,\n                handler=handler,\n                host=host,\n                strict_slashes=strict_slashes,\n                version=version,\n                name=name,\n            )\n            return handler",
        "begin_line": 189,
        "end_line": 210,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01818181818181818,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.018518518518518517,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.018518518518518517
        }
    },
    {
        "name": "sanic.app.Sanic.get#215",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.get(self, uri, host=None, strict_slashes=None, version=None, name=None)",
        "snippet": "    def get(\n        self, uri, host=None, strict_slashes=None, version=None, name=None\n    ):\n        \"\"\"\n        Add an API URL under the **GET** *HTTP* method\n\n        :param uri: URL to be tagged to **GET** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"GET\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n        )",
        "begin_line": 215,
        "end_line": 236,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0003456619426201175,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.post#238",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.post(self, uri, host=None, strict_slashes=None, stream=False, version=None, name=None)",
        "snippet": "    def post(\n        self,\n        uri,\n        host=None,\n        strict_slashes=None,\n        stream=False,\n        version=None,\n        name=None,\n    ):\n        \"\"\"\n        Add an API URL under the **POST** *HTTP* method\n\n        :param uri: URL to be tagged to **POST** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"POST\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )",
        "begin_line": 238,
        "end_line": 266,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000441306266548985,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.put#268",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.put(self, uri, host=None, strict_slashes=None, stream=False, version=None, name=None)",
        "snippet": "    def put(\n        self,\n        uri,\n        host=None,\n        strict_slashes=None,\n        stream=False,\n        version=None,\n        name=None,\n    ):\n        \"\"\"\n        Add an API URL under the **PUT** *HTTP* method\n\n        :param uri: URL to be tagged to **PUT** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"PUT\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )",
        "begin_line": 268,
        "end_line": 296,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005184033177812338,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.head#298",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.head(self, uri, host=None, strict_slashes=None, version=None, name=None)",
        "snippet": "    def head(\n        self, uri, host=None, strict_slashes=None, version=None, name=None\n    ):\n        return self.route(\n            uri,\n            methods=frozenset({\"HEAD\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n        )",
        "begin_line": 298,
        "end_line": 308,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005393743257820927,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.options#310",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.options(self, uri, host=None, strict_slashes=None, version=None, name=None)",
        "snippet": "    def options(\n        self, uri, host=None, strict_slashes=None, version=None, name=None\n    ):\n        \"\"\"\n        Add an API URL under the **OPTIONS** *HTTP* method\n\n        :param uri: URL to be tagged to **OPTIONS** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"OPTIONS\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n        )",
        "begin_line": 310,
        "end_line": 331,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005184033177812338,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.patch#333",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.patch(self, uri, host=None, strict_slashes=None, stream=False, version=None, name=None)",
        "snippet": "    def patch(\n        self,\n        uri,\n        host=None,\n        strict_slashes=None,\n        stream=False,\n        version=None,\n        name=None,\n    ):\n        \"\"\"\n        Add an API URL under the **PATCH** *HTTP* method\n\n        :param uri: URL to be tagged to **PATCH** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"PATCH\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )",
        "begin_line": 333,
        "end_line": 361,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005393743257820927,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.delete#363",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.delete(self, uri, host=None, strict_slashes=None, version=None, name=None)",
        "snippet": "    def delete(\n        self, uri, host=None, strict_slashes=None, version=None, name=None\n    ):\n        \"\"\"\n        Add an API URL under the **DELETE** *HTTP* method\n\n        :param uri: URL to be tagged to **DELETE** method of *HTTP*\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param version: API Version\n        :param name: Unique name that can be used to identify the Route\n        :return: Object decorated with :func:`route` method\n        \"\"\"\n        return self.route(\n            uri,\n            methods=frozenset({\"DELETE\"}),\n            host=host,\n            strict_slashes=strict_slashes,\n            version=version,\n            name=name,\n        )",
        "begin_line": 363,
        "end_line": 384,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00048449612403100775,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.add_route#386",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.add_route(self, handler, uri, methods=frozenset({'GET'}), host=None, strict_slashes=None, version=None, name=None, stream=False)",
        "snippet": "    def add_route(\n        self,\n        handler,\n        uri,\n        methods=frozenset({\"GET\"}),\n        host=None,\n        strict_slashes=None,\n        version=None,\n        name=None,\n        stream=False,\n    ):\n        \"\"\"A helper method to register class instance or\n        functions as a handler to the application url\n        routes.\n\n        :param handler: function or class instance\n        :param uri: path of the URL\n        :param methods: list or tuple of methods allowed, these are overridden\n                        if using a HTTPMethodView\n        :param host:\n        :param strict_slashes:\n        :param version:\n        :param name: user defined route name for url_for\n        :param stream: boolean specifying if the handler is a stream handler\n        :return: function or class instance\n        \"\"\"\n        # Handle HTTPMethodView differently\n        if hasattr(handler, \"view_class\"):\n            methods = set()\n\n            for method in HTTP_METHODS:\n                _handler = getattr(handler.view_class, method.lower(), None)\n                if _handler:\n                    methods.add(method)\n                    if hasattr(_handler, \"is_stream\"):\n                        stream = True\n\n        # handle composition view differently\n        if isinstance(handler, CompositionView):\n            methods = handler.handlers.keys()\n            for _handler in handler.handlers.values():\n                if hasattr(_handler, \"is_stream\"):\n                    stream = True\n                    break\n\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        self.route(\n            uri=uri,\n            methods=methods,\n            host=host,\n            strict_slashes=strict_slashes,\n            stream=stream,\n            version=version,\n            name=name,\n        )(handler)\n        return handler",
        "begin_line": 386,
        "end_line": 443,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.06666666666666667,
            "pseudo_dstar_susp": 0.0014705882352941176,
            "pseudo_tarantula_susp": 0.06666666666666667,
            "pseudo_op2_susp": 0.0014705882352941176,
            "pseudo_barinel_susp": 0.06666666666666667
        }
    },
    {
        "name": "sanic.app.Sanic.websocket#446",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.websocket(self, uri, host=None, strict_slashes=None, subprotocols=None, name=None)",
        "snippet": "    def websocket(\n        self, uri, host=None, strict_slashes=None, subprotocols=None, name=None\n    ):\n        \"\"\"\n        Decorate a function to be registered as a websocket route\n\n        :param uri: path of the URL\n        :param host: Host IP or FQDN details\n        :param strict_slashes: If the API endpoint needs to terminate\n                               with a \"/\" or not\n        :param subprotocols: optional list of str with supported subprotocols\n        :param name: A unique name assigned to the URL so that it can\n                     be used with :func:`url_for`\n        :return: decorated function\n        \"\"\"\n        self.enable_websocket()\n\n        # Fix case where the user did not prefix the URL with a /\n        # and will probably get confused as to why it's not working\n        if not uri.startswith(\"/\"):\n            uri = \"/\" + uri\n\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        def response(handler):\n            async def websocket_handler(request, *args, **kwargs):\n                request.app = self\n                if not getattr(handler, \"__blueprintname__\", False):\n                    request.endpoint = handler.__name__\n                else:\n                    request.endpoint = (\n                        getattr(handler, \"__blueprintname__\", \"\")\n                        + handler.__name__\n                    )\n\n                    pass\n\n                if self.asgi:\n                    ws = request.transport.get_websocket_connection()\n                else:\n                    try:\n                        protocol = request.transport.get_protocol()\n                    except AttributeError:\n                        # On Python3.5 the Transport classes in asyncio do not\n                        # have a get_protocol() method as in uvloop\n                        protocol = request.transport._protocol\n                    protocol.app = self\n\n                    ws = await protocol.websocket_handshake(\n                        request, subprotocols\n                    )\n\n                # schedule the application handler\n                # its future is kept in self.websocket_tasks in case it\n                # needs to be cancelled due to the server being stopped\n                fut = ensure_future(handler(request, ws, *args, **kwargs))\n                self.websocket_tasks.add(fut)\n                try:\n                    await fut\n                except (CancelledError, ConnectionClosed):\n                    pass\n                finally:\n                    self.websocket_tasks.remove(fut)\n                await ws.close()\n\n            self.router.add(\n                uri=uri,\n                handler=websocket_handler,\n                methods=frozenset({\"GET\"}),\n                host=host,\n                strict_slashes=strict_slashes,\n                name=name,\n            )\n            return handler\n\n        return response",
        "begin_line": 446,
        "end_line": 522,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.response#471",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.response(handler)",
        "snippet": "        def response(handler):\n            async def websocket_handler(request, *args, **kwargs):\n                request.app = self\n                if not getattr(handler, \"__blueprintname__\", False):\n                    request.endpoint = handler.__name__\n                else:\n                    request.endpoint = (\n                        getattr(handler, \"__blueprintname__\", \"\")\n                        + handler.__name__\n                    )\n\n                    pass\n\n                if self.asgi:\n                    ws = request.transport.get_websocket_connection()\n                else:\n                    try:\n                        protocol = request.transport.get_protocol()\n                    except AttributeError:\n                        # On Python3.5 the Transport classes in asyncio do not\n                        # have a get_protocol() method as in uvloop\n                        protocol = request.transport._protocol\n                    protocol.app = self\n\n                    ws = await protocol.websocket_handshake(\n                        request, subprotocols\n                    )\n\n                # schedule the application handler\n                # its future is kept in self.websocket_tasks in case it\n                # needs to be cancelled due to the server being stopped\n                fut = ensure_future(handler(request, ws, *args, **kwargs))\n                self.websocket_tasks.add(fut)\n                try:\n                    await fut\n                except (CancelledError, ConnectionClosed):\n                    pass\n                finally:\n                    self.websocket_tasks.remove(fut)\n                await ws.close()\n\n            self.router.add(\n                uri=uri,\n                handler=websocket_handler,\n                methods=frozenset({\"GET\"}),\n                host=host,\n                strict_slashes=strict_slashes,\n                name=name,\n            )\n            return handler",
        "begin_line": 471,
        "end_line": 520,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01818181818181818,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.018518518518518517,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.018518518518518517
        }
    },
    {
        "name": "sanic.app.Sanic.websocket_handler#472",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.websocket_handler(request, *args, **kwargs)",
        "snippet": "            async def websocket_handler(request, *args, **kwargs):\n                request.app = self\n                if not getattr(handler, \"__blueprintname__\", False):\n                    request.endpoint = handler.__name__\n                else:\n                    request.endpoint = (\n                        getattr(handler, \"__blueprintname__\", \"\")\n                        + handler.__name__\n                    )\n\n                    pass\n\n                if self.asgi:\n                    ws = request.transport.get_websocket_connection()\n                else:\n                    try:\n                        protocol = request.transport.get_protocol()\n                    except AttributeError:\n                        # On Python3.5 the Transport classes in asyncio do not\n                        # have a get_protocol() method as in uvloop\n                        protocol = request.transport._protocol\n                    protocol.app = self\n\n                    ws = await protocol.websocket_handshake(\n                        request, subprotocols\n                    )\n\n                # schedule the application handler\n                # its future is kept in self.websocket_tasks in case it\n                # needs to be cancelled due to the server being stopped\n                fut = ensure_future(handler(request, ws, *args, **kwargs))\n                self.websocket_tasks.add(fut)\n                try:\n                    await fut\n                except (CancelledError, ConnectionClosed):\n                    pass\n                finally:\n                    self.websocket_tasks.remove(fut)\n                await ws.close()",
        "begin_line": 472,
        "end_line": 510,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.add_websocket_route#524",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.add_websocket_route(self, handler, uri, host=None, strict_slashes=None, subprotocols=None, name=None)",
        "snippet": "    def add_websocket_route(\n        self,\n        handler,\n        uri,\n        host=None,\n        strict_slashes=None,\n        subprotocols=None,\n        name=None,\n    ):\n        \"\"\"\n        A helper method to register a function as a websocket route.\n\n        :param handler: a callable function or instance of a class\n                        that can handle the websocket request\n        :param host: Host IP or FQDN details\n        :param uri: URL path that will be mapped to the websocket\n                    handler\n        :param strict_slashes: If the API endpoint needs to terminate\n                with a \"/\" or not\n        :param subprotocols: Subprotocols to be used with websocket\n                handshake\n        :param name: A unique name assigned to the URL so that it can\n                be used with :func:`url_for`\n        :return: Objected decorated by :func:`websocket`\n        \"\"\"\n        if strict_slashes is None:\n            strict_slashes = self.strict_slashes\n\n        return self.websocket(\n            uri,\n            host=host,\n            strict_slashes=strict_slashes,\n            subprotocols=subprotocols,\n            name=name,\n        )(handler)",
        "begin_line": 524,
        "end_line": 558,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.enable_websocket#560",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.enable_websocket(self, enable=True)",
        "snippet": "    def enable_websocket(self, enable=True):\n        \"\"\"Enable or disable the support for websocket.\n\n        Websocket is enabled automatically if websocket routes are\n        added to the application.\n        \"\"\"\n        if not self.websocket_enabled:\n            # if the server is stopped, we want to cancel any ongoing\n            # websocket tasks, to allow the server to exit promptly\n            @self.listener(\"before_server_stop\")\n            def cancel_websocket_tasks(app, loop):\n                for task in self.websocket_tasks:\n                    task.cancel()\n\n        self.websocket_enabled = enable",
        "begin_line": 560,
        "end_line": 574,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004338394793926247,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.cancel_websocket_tasks#570",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.cancel_websocket_tasks(app, loop)",
        "snippet": "            def cancel_websocket_tasks(app, loop):\n                for task in self.websocket_tasks:\n                    task.cancel()",
        "begin_line": 570,
        "end_line": 572,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00046728971962616824,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.remove_route#576",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.remove_route(self, uri, clean_cache=True, host=None)",
        "snippet": "    def remove_route(self, uri, clean_cache=True, host=None):\n        \"\"\"\n        This method provides the app user a mechanism by which an already\n        existing route can be removed from the :class:`Sanic` object\n\n        .. warning::\n            remove_route is deprecated in v19.06 and will be removed\n            from future versions.\n\n        :param uri: URL Path to be removed from the app\n        :param clean_cache: Instruct sanic if it needs to clean up the LRU\n            route cache\n        :param host: IP address or FQDN specific to the host\n        :return: None\n        \"\"\"\n        warnings.warn(\n            \"remove_route is deprecated and will be removed \"\n            \"from future versions.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.router.remove(uri, clean_cache, host)",
        "begin_line": 576,
        "end_line": 597,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005184033177812338,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.exception#600",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.exception(self, *exceptions)",
        "snippet": "    def exception(self, *exceptions):\n        \"\"\"Decorate a function to be registered as a handler for exceptions\n\n        :param exceptions: exceptions\n        :return: decorated function\n        \"\"\"\n\n        def response(handler):\n            for exception in exceptions:\n                if isinstance(exception, (tuple, list)):\n                    for e in exception:\n                        self.error_handler.add(e, handler)\n                else:\n                    self.error_handler.add(exception, handler)\n            return handler\n\n        return response",
        "begin_line": 600,
        "end_line": 616,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024449877750611247,
            "pseudo_dstar_susp": 0.0034129692832764505,
            "pseudo_tarantula_susp": 0.0024813895781637717,
            "pseudo_op2_susp": 0.0034129692832764505,
            "pseudo_barinel_susp": 0.0024813895781637717
        }
    },
    {
        "name": "sanic.app.Sanic.response#607",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.response(handler)",
        "snippet": "        def response(handler):\n            for exception in exceptions:\n                if isinstance(exception, (tuple, list)):\n                    for e in exception:\n                        self.error_handler.add(e, handler)\n                else:\n                    self.error_handler.add(exception, handler)\n            return handler",
        "begin_line": 607,
        "end_line": 614,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.01818181818181818,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.018518518518518517,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.018518518518518517
        }
    },
    {
        "name": "sanic.app.Sanic.register_middleware#618",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.register_middleware(self, middleware, attach_to='request')",
        "snippet": "    def register_middleware(self, middleware, attach_to=\"request\"):\n        \"\"\"\n        Register an application level middleware that will be attached\n        to all the API URLs registered under this application.\n\n        This method is internally invoked by the :func:`middleware`\n        decorator provided at the app level.\n\n        :param middleware: Callback method to be attached to the\n            middleware\n        :param attach_to: The state at which the middleware needs to be\n            invoked in the lifecycle of an *HTTP Request*.\n            **request** - Invoke before the request is processed\n            **response** - Invoke before the response is returned back\n        :return: decorated method\n        \"\"\"\n        if attach_to == \"request\":\n            if middleware not in self.request_middleware:\n                self.request_middleware.append(middleware)\n        if attach_to == \"response\":\n            if middleware not in self.response_middleware:\n                self.response_middleware.appendleft(middleware)\n        return middleware",
        "begin_line": 618,
        "end_line": 640,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00046728971962616824,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.middleware#643",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.middleware(self, middleware_or_request)",
        "snippet": "    def middleware(self, middleware_or_request):\n        \"\"\"\n        Decorate and register middleware to be called before a request.\n        Can either be called as *@app.middleware* or\n        *@app.middleware('request')*\n\n        :param: middleware_or_request: Optional parameter to use for\n            identifying which type of middleware is being registered.\n        \"\"\"\n        # Detect which way this was called, @middleware or @middleware('AT')\n        if callable(middleware_or_request):\n            return self.register_middleware(middleware_or_request)\n\n        else:\n            return partial(\n                self.register_middleware, attach_to=middleware_or_request\n            )",
        "begin_line": 643,
        "end_line": 659,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0006317119393556538,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.static#662",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.static(self, uri, file_or_directory, pattern='/?.+', use_modified_since=True, use_content_range=False, stream_large_files=False, name='static', host=None, strict_slashes=None, content_type=None)",
        "snippet": "    def static(\n        self,\n        uri,\n        file_or_directory,\n        pattern=r\"/?.+\",\n        use_modified_since=True,\n        use_content_range=False,\n        stream_large_files=False,\n        name=\"static\",\n        host=None,\n        strict_slashes=None,\n        content_type=None,\n    ):\n        \"\"\"\n        Register a root to serve files from. The input can either be a\n        file or a directory. This method will enable an easy and simple way\n        to setup the :class:`Route` necessary to serve the static files.\n\n        :param uri: URL path to be used for serving static content\n        :param file_or_directory: Path for the Static file/directory with\n            static files\n        :param pattern: Regex Pattern identifying the valid static files\n        :param use_modified_since: If true, send file modified time, and return\n            not modified if the browser's matches the server's\n        :param use_content_range: If true, process header for range requests\n            and sends the file part that is requested\n        :param stream_large_files: If true, use the\n            :func:`StreamingHTTPResponse.file_stream` handler rather\n            than the :func:`HTTPResponse.file` handler to send the file.\n            If this is an integer, this represents the threshold size to\n            switch to :func:`StreamingHTTPResponse.file_stream`\n        :param name: user defined name used for url_for\n        :param host: Host IP or FQDN for the service to use\n        :param strict_slashes: Instruct :class:`Sanic` to check if the request\n            URLs need to terminate with a */*\n        :param content_type: user defined content type for header\n        :return: None\n        \"\"\"\n        static_register(\n            self,\n            uri,\n            file_or_directory,\n            pattern,\n            use_modified_since,\n            use_content_range,\n            stream_large_files,\n            name,\n            host,\n            strict_slashes,\n            content_type,\n        )",
        "begin_line": 662,
        "end_line": 712,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0003427004797806717,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.blueprint#714",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.blueprint(self, blueprint, **options)",
        "snippet": "    def blueprint(self, blueprint, **options):\n        \"\"\"Register a blueprint on the application.\n\n        :param blueprint: Blueprint object or (list, tuple) thereof\n        :param options: option dictionary with blueprint defaults\n        :return: Nothing\n        \"\"\"\n        if isinstance(blueprint, (list, tuple, BlueprintGroup)):\n            for item in blueprint:\n                self.blueprint(item, **options)\n            return\n        if blueprint.name in self.blueprints:\n            assert self.blueprints[blueprint.name] is blueprint, (\n                'A blueprint with the name \"%s\" is already registered.  '\n                \"Blueprint names must be unique.\" % (blueprint.name,)\n            )\n        else:\n            self.blueprints[blueprint.name] = blueprint\n            self._blueprint_order.append(blueprint)\n        blueprint.register(self, options)",
        "begin_line": 714,
        "end_line": 733,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.register_blueprint#735",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.register_blueprint(self, *args, **kwargs)",
        "snippet": "    def register_blueprint(self, *args, **kwargs):\n        \"\"\"\n        Proxy method provided for invoking the :func:`blueprint` method\n\n        .. note::\n            To be deprecated in 1.0. Use :func:`blueprint` instead.\n\n        :param args: Blueprint object or (list, tuple) thereof\n        :param kwargs: option dictionary with blueprint defaults\n        :return: None\n        \"\"\"\n\n        if self.debug:\n            warnings.simplefilter(\"default\")\n        warnings.warn(\n            \"Use of register_blueprint will be deprecated in \"\n            \"version 1.0.  Please use the blueprint method\"\n            \" instead\",\n            DeprecationWarning,\n        )\n        return self.blueprint(*args, **kwargs)",
        "begin_line": 735,
        "end_line": 755,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.url_for#757",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.url_for(self, view_name: str, **kwargs)",
        "snippet": "    def url_for(self, view_name: str, **kwargs):\n        r\"\"\"Build a URL based on a view name and the values provided.\n\n        In order to build a URL, all request parameters must be supplied as\n        keyword arguments, and each parameter must pass the test for the\n        specified parameter type. If these conditions are not met, a\n        `URLBuildError` will be thrown.\n\n        Keyword arguments that are not request parameters will be included in\n        the output URL's query string.\n\n        :param view_name: string referencing the view name\n        :param \\**kwargs: keys and values that are used to build request\n            parameters and query string arguments.\n\n        :return: the built URL\n\n        Raises:\n            URLBuildError\n        \"\"\"\n        # find the route by the supplied view name\n        kw: Dict[str, str] = {}\n        # special static files url_for\n        if view_name == \"static\":\n            kw.update(name=kwargs.pop(\"name\", \"static\"))\n        elif view_name.endswith(\".static\"):  # blueprint.static\n            kwargs.pop(\"name\", None)\n            kw.update(name=view_name)\n\n        uri, route = self.router.find_route_by_view_name(view_name, **kw)\n        if not (uri and route):\n            raise URLBuildError(\n                \"Endpoint with name `{}` was not found\".format(view_name)\n            )\n\n        if view_name == \"static\" or view_name.endswith(\".static\"):\n            filename = kwargs.pop(\"filename\", None)\n            # it's static folder\n            if \"<file_uri:\" in uri:\n                folder_ = uri.split(\"<file_uri:\", 1)[0]\n                if folder_.endswith(\"/\"):\n                    folder_ = folder_[:-1]\n\n                if filename.startswith(\"/\"):\n                    filename = filename[1:]\n\n                uri = \"{}/{}\".format(folder_, filename)\n\n        if uri != \"/\" and uri.endswith(\"/\"):\n            uri = uri[:-1]\n\n        out = uri\n\n        # find all the parameters we will need to build in the URL\n        matched_params = re.findall(self.router.parameter_pattern, uri)\n\n        # _method is only a placeholder now, don't know how to support it\n        kwargs.pop(\"_method\", None)\n        anchor = kwargs.pop(\"_anchor\", \"\")\n        # _external need SERVER_NAME in config or pass _server arg\n        external = kwargs.pop(\"_external\", False)\n        scheme = kwargs.pop(\"_scheme\", \"\")\n        if scheme and not external:\n            raise ValueError(\"When specifying _scheme, _external must be True\")\n\n        netloc = kwargs.pop(\"_server\", None)\n        if netloc is None and external:\n            netloc = self.config.get(\"SERVER_NAME\", \"\")\n\n        if external:\n            if not scheme:\n                if \":\" in netloc[:8]:\n                    scheme = netloc[:8].split(\":\", 1)[0]\n                else:\n                    scheme = \"http\"\n\n            if \"://\" in netloc[:8]:\n                netloc = netloc.split(\"://\", 1)[-1]\n\n        for match in matched_params:\n            name, _type, pattern = self.router.parse_parameter_string(match)\n            # we only want to match against each individual parameter\n            specific_pattern = \"^{}$\".format(pattern)\n            supplied_param = None\n\n            if name in kwargs:\n                supplied_param = kwargs.get(name)\n                del kwargs[name]\n            else:\n                raise URLBuildError(\n                    \"Required parameter `{}` was not passed to url_for\".format(\n                        name\n                    )\n                )\n\n            supplied_param = str(supplied_param)\n            # determine if the parameter supplied by the caller passes the test\n            # in the URL\n            passes_pattern = re.match(specific_pattern, supplied_param)\n\n            if not passes_pattern:\n                if _type != str:\n                    msg = (\n                        'Value \"{}\" for parameter `{}` does not '\n                        \"match pattern for type `{}`: {}\".format(\n                            supplied_param, name, _type.__name__, pattern\n                        )\n                    )\n                else:\n                    msg = (\n                        'Value \"{}\" for parameter `{}` '\n                        \"does not satisfy pattern {}\".format(\n                            supplied_param, name, pattern\n                        )\n                    )\n                raise URLBuildError(msg)\n\n            # replace the parameter in the URL with the supplied value\n            replacement_regex = \"(<{}.*?>)\".format(name)\n\n            out = re.sub(replacement_regex, supplied_param, out)\n\n        # parse the remainder of the keyword arguments into a querystring\n        query_string = urlencode(kwargs, doseq=True) if kwargs else \"\"\n        # scheme://netloc/path;parameters?query#fragment\n        out = urlunparse((scheme, netloc, out, \"\", query_string, anchor))\n\n        return out",
        "begin_line": 757,
        "end_line": 884,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.handle_request#896",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.handle_request(self, request, write_callback, stream_callback)",
        "snippet": "    async def handle_request(self, request, write_callback, stream_callback):\n        \"\"\"Take a request from the HTTP Server and return a response object\n        to be sent back The HTTP Server only expects a response object, so\n        exception handling must be done here\n\n        :param request: HTTP Request object\n        :param write_callback: Synchronous response function to be\n            called with the response as the only argument\n        :param stream_callback: Coroutine that handles streaming a\n            StreamingHTTPResponse if produced by the handler.\n\n        :return: Nothing\n        \"\"\"\n        # Define `response` var here to remove warnings about\n        # allocation before assignment below.\n        response = None\n        cancelled = False\n        try:\n            # -------------------------------------------- #\n            # Request Middleware\n            # -------------------------------------------- #\n            response = await self._run_request_middleware(request)\n            # No middleware results\n            if not response:\n                # -------------------------------------------- #\n                # Execute Handler\n                # -------------------------------------------- #\n\n                # Fetch handler from router\n                handler, args, kwargs, uri = self.router.get(request)\n\n                request.uri_template = uri\n                if handler is None:\n                    raise ServerError(\n                        (\n                            \"'None' was returned while requesting a \"\n                            \"handler from the router\"\n                        )\n                    )\n                else:\n                    if not getattr(handler, \"__blueprintname__\", False):\n                        request.endpoint = self._build_endpoint_name(\n                            handler.__name__\n                        )\n                    else:\n                        request.endpoint = self._build_endpoint_name(\n                            getattr(handler, \"__blueprintname__\", \"\"),\n                            handler.__name__,\n                        )\n\n                # Run response handler\n                response = handler(request, *args, **kwargs)\n                if isawaitable(response):\n                    response = await response\n        except CancelledError:\n            # If response handler times out, the server handles the error\n            # and cancels the handle_request job.\n            # In this case, the transport is already closed and we cannot\n            # issue a response.\n            response = None\n            cancelled = True\n        except Exception as e:\n            # -------------------------------------------- #\n            # Response Generation Failed\n            # -------------------------------------------- #\n\n            try:\n                response = self.error_handler.response(request, e)\n                if isawaitable(response):\n                    response = await response\n            except Exception as e:\n                if isinstance(e, SanicException):\n                    response = self.error_handler.default(\n                        request=request, exception=e\n                    )\n                elif self.debug:\n                    response = HTTPResponse(\n                        \"Error while handling error: {}\\nStack: {}\".format(\n                            e, format_exc()\n                        ),\n                        status=500,\n                    )\n                else:\n                    response = HTTPResponse(\n                        \"An error occurred while handling an error\", status=500\n                    )\n        finally:\n            # -------------------------------------------- #\n            # Response Middleware\n            # -------------------------------------------- #\n            # Don't run response middleware if response is None\n            if response is not None:\n                try:\n                    response = await self._run_response_middleware(\n                        request, response\n                    )\n                except CancelledError:\n                    # Response middleware can timeout too, as above.\n                    response = None\n                    cancelled = True\n                except BaseException:\n                    error_logger.exception(\n                        \"Exception occurred in one of response \"\n                        \"middleware handlers\"\n                    )\n            if cancelled:\n                raise CancelledError()\n\n        # pass the response to the correct callback\n        if write_callback is None or isinstance(\n            response, StreamingHTTPResponse\n        ):\n            if stream_callback:\n                await stream_callback(response)\n            else:\n                # Should only end here IF it is an ASGI websocket.\n                # TODO:\n                # - Add exception handling\n                pass\n        else:\n            write_callback(response)",
        "begin_line": 896,
        "end_line": 1016,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.015625,
            "pseudo_dstar_susp": 0.03333333333333333,
            "pseudo_tarantula_susp": 0.015873015873015872,
            "pseudo_op2_susp": 0.03333333333333333,
            "pseudo_barinel_susp": 0.015873015873015872
        }
    },
    {
        "name": "sanic.app.Sanic.test_client#1023",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.test_client(self)",
        "snippet": "    def test_client(self):\n        return SanicTestClient(self)",
        "begin_line": 1023,
        "end_line": 1024,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00398406374501992,
            "pseudo_dstar_susp": 0.007407407407407408,
            "pseudo_tarantula_susp": 0.00411522633744856,
            "pseudo_op2_susp": 0.007407407407407408,
            "pseudo_barinel_susp": 0.00411522633744856
        }
    },
    {
        "name": "sanic.app.Sanic.asgi_client#1027",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.asgi_client(self)",
        "snippet": "    def asgi_client(self):\n        return SanicASGITestClient(self)",
        "begin_line": 1027,
        "end_line": 1028,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00036310820624546115,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.run#1034",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.run(self, host: Optional[str]=None, port: Optional[int]=None, debug: bool=False, ssl: Union[dict, SSLContext, None]=None, sock: Optional[socket]=None, workers: int=1, protocol: Type[Protocol]=None, backlog: int=100, stop_event: Any=None, register_sys_signals: bool=True, access_log: Optional[bool]=None, **kwargs: Any)",
        "snippet": "    def run(\n        self,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        debug: bool = False,\n        ssl: Union[dict, SSLContext, None] = None,\n        sock: Optional[socket] = None,\n        workers: int = 1,\n        protocol: Type[Protocol] = None,\n        backlog: int = 100,\n        stop_event: Any = None,\n        register_sys_signals: bool = True,\n        access_log: Optional[bool] = None,\n        **kwargs: Any\n    ) -> None:\n        \"\"\"Run the HTTP Server and listen until keyboard interrupt or term\n        signal. On termination, drain connections before closing.\n\n        :param host: Address to host on\n        :type host: str\n        :param port: Port to host on\n        :type port: int\n        :param debug: Enables debug output (slows server)\n        :type debug: bool\n        :param ssl: SSLContext, or location of certificate and key\n                    for SSL encryption of worker(s)\n        :type ssl: SSLContext or dict\n        :param sock: Socket for the server to accept connections from\n        :type sock: socket\n        :param workers: Number of processes received before it is respected\n        :type workers: int\n        :param protocol: Subclass of asyncio Protocol class\n        :type protocol: type[Protocol]\n        :param backlog: a number of unaccepted connections that the system\n                        will allow before refusing new connections\n        :type backlog: int\n        :param stop_event: event to be triggered\n                           before stopping the app - deprecated\n        :type stop_event: None\n        :param register_sys_signals: Register SIG* events\n        :type register_sys_signals: bool\n        :param access_log: Enables writing access logs (slows server)\n        :type access_log: bool\n        :return: Nothing\n        \"\"\"\n        if \"loop\" in kwargs:\n            raise TypeError(\n                \"loop is not a valid argument. To use an existing loop, \"\n                \"change to create_server().\\nSee more: \"\n                \"https://sanic.readthedocs.io/en/latest/sanic/deploying.html\"\n                \"#asynchronous-support\"\n            )\n\n        # Default auto_reload to false\n        auto_reload = False\n        # If debug is set, default it to true (unless on windows)\n        if debug and os.name == \"posix\":\n            auto_reload = True\n        # Allow for overriding either of the defaults\n        auto_reload = kwargs.get(\"auto_reload\", auto_reload)\n\n        if sock is None:\n            host, port = host or \"127.0.0.1\", port or 8000\n\n        if protocol is None:\n            protocol = (\n                WebSocketProtocol if self.websocket_enabled else HttpProtocol\n            )\n        if stop_event is not None:\n            if debug:\n                warnings.simplefilter(\"default\")\n            warnings.warn(\n                \"stop_event will be removed from future versions.\",\n                DeprecationWarning,\n            )\n        # if access_log is passed explicitly change config.ACCESS_LOG\n        if access_log is not None:\n            self.config.ACCESS_LOG = access_log\n\n        server_settings = self._helper(\n            host=host,\n            port=port,\n            debug=debug,\n            ssl=ssl,\n            sock=sock,\n            workers=workers,\n            protocol=protocol,\n            backlog=backlog,\n            register_sys_signals=register_sys_signals,\n            auto_reload=auto_reload,\n        )\n\n        try:\n            self.is_running = True\n            if workers == 1:\n                if auto_reload and os.name != \"posix\":\n                    # This condition must be removed after implementing\n                    # auto reloader for other operating systems.\n                    raise NotImplementedError\n\n                if (\n                    auto_reload\n                    and os.environ.get(\"SANIC_SERVER_RUNNING\") != \"true\"\n                ):\n                    reloader_helpers.watchdog(2)\n                else:\n                    serve(**server_settings)\n            else:\n                serve_multiple(server_settings, workers)\n        except BaseException:\n            error_logger.exception(\n                \"Experienced exception while trying to serve\"\n            )\n            raise\n        finally:\n            self.is_running = False\n        logger.info(\"Server Stopped\")",
        "begin_line": 1034,
        "end_line": 1150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002352941176470588,
            "pseudo_dstar_susp": 0.003236245954692557,
            "pseudo_tarantula_susp": 0.002386634844868735,
            "pseudo_op2_susp": 0.003236245954692557,
            "pseudo_barinel_susp": 0.002386634844868735
        }
    },
    {
        "name": "sanic.app.Sanic.stop#1152",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.stop(self)",
        "snippet": "    def stop(self):\n        \"\"\"This kills the Sanic\"\"\"\n        get_event_loop().stop()",
        "begin_line": 1152,
        "end_line": 1154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002331002331002331,
            "pseudo_dstar_susp": 0.003194888178913738,
            "pseudo_tarantula_susp": 0.002364066193853428,
            "pseudo_op2_susp": 0.003194888178913738,
            "pseudo_barinel_susp": 0.002364066193853428
        }
    },
    {
        "name": "sanic.app.Sanic.create_server#1156",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.create_server(self, host: Optional[str]=None, port: Optional[int]=None, debug: bool=False, ssl: Union[dict, SSLContext, None]=None, sock: Optional[socket]=None, protocol: Type[Protocol]=None, backlog: int=100, stop_event: Any=None, access_log: Optional[bool]=None, return_asyncio_server=False, asyncio_server_kwargs=None)",
        "snippet": "    async def create_server(\n        self,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        debug: bool = False,\n        ssl: Union[dict, SSLContext, None] = None,\n        sock: Optional[socket] = None,\n        protocol: Type[Protocol] = None,\n        backlog: int = 100,\n        stop_event: Any = None,\n        access_log: Optional[bool] = None,\n        return_asyncio_server=False,\n        asyncio_server_kwargs=None,\n    ) -> None:\n        \"\"\"\n        Asynchronous version of :func:`run`.\n\n        This method will take care of the operations necessary to invoke\n        the *before_start* events via :func:`trigger_events` method invocation\n        before starting the *sanic* app in Async mode.\n\n        .. note::\n            This does not support multiprocessing and is not the preferred\n            way to run a :class:`Sanic` application.\n\n        :param host: Address to host on\n        :type host: str\n        :param port: Port to host on\n        :type port: int\n        :param debug: Enables debug output (slows server)\n        :type debug: bool\n        :param ssl: SSLContext, or location of certificate and key\n                    for SSL encryption of worker(s)\n        :type ssl: SSLContext or dict\n        :param sock: Socket for the server to accept connections from\n        :type sock: socket\n        :param protocol: Subclass of asyncio Protocol class\n        :type protocol: type[Protocol]\n        :param backlog: a number of unaccepted connections that the system\n                        will allow before refusing new connections\n        :type backlog: int\n        :param stop_event: event to be triggered\n                           before stopping the app - deprecated\n        :type stop_event: None\n        :param access_log: Enables writing access logs (slows server)\n        :type access_log: bool\n        :param return_asyncio_server: flag that defines whether there's a need\n                                      to return asyncio.Server or\n                                      start it serving right away\n        :type return_asyncio_server: bool\n        :param asyncio_server_kwargs: key-value arguments for\n                                      asyncio/uvloop create_server method\n        :type asyncio_server_kwargs: dict\n        :return: Nothing\n        \"\"\"\n\n        if sock is None:\n            host, port = host or \"127.0.0.1\", port or 8000\n\n        if protocol is None:\n            protocol = (\n                WebSocketProtocol if self.websocket_enabled else HttpProtocol\n            )\n        if stop_event is not None:\n            if debug:\n                warnings.simplefilter(\"default\")\n            warnings.warn(\n                \"stop_event will be removed from future versions.\",\n                DeprecationWarning,\n            )\n        # if access_log is passed explicitly change config.ACCESS_LOG\n        if access_log is not None:\n            self.config.ACCESS_LOG = access_log\n\n        server_settings = self._helper(\n            host=host,\n            port=port,\n            debug=debug,\n            ssl=ssl,\n            sock=sock,\n            loop=get_event_loop(),\n            protocol=protocol,\n            backlog=backlog,\n            run_async=return_asyncio_server,\n        )\n\n        # Trigger before_start events\n        await self.trigger_events(\n            server_settings.get(\"before_start\", []),\n            server_settings.get(\"loop\"),\n        )\n\n        return await serve(\n            asyncio_server_kwargs=asyncio_server_kwargs, **server_settings\n        )",
        "begin_line": 1156,
        "end_line": 1250,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic.trigger_events#1252",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.trigger_events(self, events, loop)",
        "snippet": "    async def trigger_events(self, events, loop):\n        \"\"\"Trigger events (functions or async)\n        :param events: one or more sync or async functions to execute\n        :param loop: event loop\n        \"\"\"\n        for event in events:\n            result = event(loop)\n            if isawaitable(result):\n                await result",
        "begin_line": 1252,
        "end_line": 1260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.app.Sanic._run_request_middleware#1262",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic._run_request_middleware(self, request)",
        "snippet": "    async def _run_request_middleware(self, request):\n        # The if improves speed.  I don't know why\n        if self.request_middleware:\n            for middleware in self.request_middleware:\n                response = middleware(request)\n                if isawaitable(response):\n                    response = await response\n                if response:\n                    return response\n        return None",
        "begin_line": 1262,
        "end_line": 1271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00398406374501992,
            "pseudo_dstar_susp": 0.007407407407407408,
            "pseudo_tarantula_susp": 0.00411522633744856,
            "pseudo_op2_susp": 0.007407407407407408,
            "pseudo_barinel_susp": 0.00411522633744856
        }
    },
    {
        "name": "sanic.app.Sanic._run_response_middleware#1273",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic._run_response_middleware(self, request, response)",
        "snippet": "    async def _run_response_middleware(self, request, response):\n        if self.response_middleware:\n            for middleware in self.response_middleware:\n                _response = middleware(request, response)\n                if isawaitable(_response):\n                    _response = await _response\n                if _response:\n                    response = _response\n                    break\n        return response",
        "begin_line": 1273,
        "end_line": 1282,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012091898428053204,
            "pseudo_dstar_susp": 0.0012091898428053204,
            "pseudo_tarantula_susp": 0.0012091898428053204,
            "pseudo_op2_susp": 0.0012091898428053204,
            "pseudo_barinel_susp": 0.0012091898428053204
        }
    },
    {
        "name": "sanic.app.Sanic._helper#1284",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic._helper(self, host=None, port=None, debug=False, ssl=None, sock=None, workers=1, loop=None, protocol=HttpProtocol, backlog=100, stop_event=None, register_sys_signals=True, run_async=False, auto_reload=False)",
        "snippet": "    def _helper(\n        self,\n        host=None,\n        port=None,\n        debug=False,\n        ssl=None,\n        sock=None,\n        workers=1,\n        loop=None,\n        protocol=HttpProtocol,\n        backlog=100,\n        stop_event=None,\n        register_sys_signals=True,\n        run_async=False,\n        auto_reload=False,\n    ):\n        \"\"\"Helper function used by `run` and `create_server`.\"\"\"\n        if isinstance(ssl, dict):\n            # try common aliaseses\n            cert = ssl.get(\"cert\") or ssl.get(\"certificate\")\n            key = ssl.get(\"key\") or ssl.get(\"keyfile\")\n            if cert is None or key is None:\n                raise ValueError(\"SSLContext or certificate and key required.\")\n            context = create_default_context(purpose=Purpose.CLIENT_AUTH)\n            context.load_cert_chain(cert, keyfile=key)\n            ssl = context\n        if stop_event is not None:\n            if debug:\n                warnings.simplefilter(\"default\")\n            warnings.warn(\n                \"stop_event will be removed from future versions.\",\n                DeprecationWarning,\n            )\n        if self.config.PROXIES_COUNT and self.config.PROXIES_COUNT < 0:\n            raise ValueError(\n                \"PROXIES_COUNT cannot be negative. \"\n                \"https://sanic.readthedocs.io/en/latest/sanic/config.html\"\n                \"#proxy-configuration\"\n            )\n\n        self.error_handler.debug = debug\n        self.debug = debug\n\n        server_settings = {\n            \"protocol\": protocol,\n            \"request_class\": self.request_class,\n            \"is_request_stream\": self.is_request_stream,\n            \"router\": self.router,\n            \"host\": host,\n            \"port\": port,\n            \"sock\": sock,\n            \"ssl\": ssl,\n            \"app\": self,\n            \"signal\": Signal(),\n            \"debug\": debug,\n            \"request_handler\": self.handle_request,\n            \"error_handler\": self.error_handler,\n            \"request_timeout\": self.config.REQUEST_TIMEOUT,\n            \"response_timeout\": self.config.RESPONSE_TIMEOUT,\n            \"keep_alive_timeout\": self.config.KEEP_ALIVE_TIMEOUT,\n            \"request_max_size\": self.config.REQUEST_MAX_SIZE,\n            \"request_buffer_queue_size\": self.config.REQUEST_BUFFER_QUEUE_SIZE,\n            \"keep_alive\": self.config.KEEP_ALIVE,\n            \"loop\": loop,\n            \"register_sys_signals\": register_sys_signals,\n            \"backlog\": backlog,\n            \"access_log\": self.config.ACCESS_LOG,\n            \"websocket_max_size\": self.config.WEBSOCKET_MAX_SIZE,\n            \"websocket_max_queue\": self.config.WEBSOCKET_MAX_QUEUE,\n            \"websocket_read_limit\": self.config.WEBSOCKET_READ_LIMIT,\n            \"websocket_write_limit\": self.config.WEBSOCKET_WRITE_LIMIT,\n            \"graceful_shutdown_timeout\": self.config.GRACEFUL_SHUTDOWN_TIMEOUT,\n        }\n\n        # -------------------------------------------- #\n        # Register start/stop events\n        # -------------------------------------------- #\n\n        for event_name, settings_name, reverse in (\n            (\"before_server_start\", \"before_start\", False),\n            (\"after_server_start\", \"after_start\", False),\n            (\"before_server_stop\", \"before_stop\", True),\n            (\"after_server_stop\", \"after_stop\", True),\n        ):\n            listeners = self.listeners[event_name].copy()\n            if reverse:\n                listeners.reverse()\n            # Prepend sanic to the arguments when listeners are triggered\n            listeners = [partial(listener, self) for listener in listeners]\n            server_settings[settings_name] = listeners\n\n        if self.configure_logging and debug:\n            logger.setLevel(logging.DEBUG)\n\n        if (\n            self.config.LOGO\n            and os.environ.get(\"SANIC_SERVER_RUNNING\") != \"true\"\n        ):\n            logger.debug(\n                self.config.LOGO\n                if isinstance(self.config.LOGO, str)\n                else BASE_LOGO\n            )\n\n        if run_async:\n            server_settings[\"run_async\"] = True\n\n        # Serve\n        if host and port and os.environ.get(\"SANIC_SERVER_RUNNING\") != \"true\":\n            proto = \"http\"\n            if ssl is not None:\n                proto = \"https\"\n            logger.info(\"Goin' Fast @ {}://{}:{}\".format(proto, host, port))\n\n        return server_settings",
        "begin_line": 1284,
        "end_line": 1398,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008,
            "pseudo_dstar_susp": 0.25,
            "pseudo_tarantula_susp": 0.001869158878504673,
            "pseudo_op2_susp": 0.25,
            "pseudo_barinel_susp": 0.001869158878504673
        }
    },
    {
        "name": "sanic.app.Sanic._build_endpoint_name#1400",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic._build_endpoint_name(self, *parts)",
        "snippet": "    def _build_endpoint_name(self, *parts):\n        parts = [self.name, *parts]\n        return \".\".join(parts)",
        "begin_line": 1400,
        "end_line": 1402,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016474464579901153,
            "pseudo_dstar_susp": 0.002036659877800407,
            "pseudo_tarantula_susp": 0.0016556291390728477,
            "pseudo_op2_susp": 0.002036659877800407,
            "pseudo_barinel_susp": 0.0016556291390728477
        }
    },
    {
        "name": "sanic.app.Sanic.__call__#1408",
        "src_path": "sanic/app.py",
        "class_name": "sanic.app.Sanic",
        "signature": "sanic.app.Sanic.__call__(self, scope, receive, send)",
        "snippet": "    async def __call__(self, scope, receive, send):\n        \"\"\"To be ASGI compliant, our instance must be a callable that accepts\n        three arguments: scope, receive, send. See the ASGI reference for more\n        details: https://asgi.readthedocs.io/en/latest/\"\"\"\n        self.asgi = True\n        asgi_app = await ASGIApp.create(self, scope, receive, send)\n        await asgi_app()",
        "begin_line": 1408,
        "end_line": 1414,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.router.url_hash#34",
        "src_path": "sanic/router.py",
        "class_name": "sanic.router",
        "signature": "sanic.router.url_hash(url)",
        "snippet": "def url_hash(url):\n    return url.count(\"/\")",
        "begin_line": 34,
        "end_line": 35,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0003368137420006736,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.router.Router.__init__#82",
        "src_path": "sanic/router.py",
        "class_name": "sanic.router.Router",
        "signature": "sanic.router.Router.__init__(self)",
        "snippet": "    def __init__(self):\n        self.routes_all = {}\n        self.routes_names = {}\n        self.routes_static_files = {}\n        self.routes_static = {}\n        self.routes_dynamic = defaultdict(list)\n        self.routes_always_check = []\n        self.hosts = set()",
        "begin_line": 82,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001310615989515072,
            "pseudo_dstar_susp": 0.0015455950540958269,
            "pseudo_tarantula_susp": 0.001310615989515072,
            "pseudo_op2_susp": 0.0015455950540958269,
            "pseudo_barinel_susp": 0.001310615989515072
        }
    },
    {
        "name": "sanic.router.Router.parse_parameter_string#92",
        "src_path": "sanic/router.py",
        "class_name": "sanic.router.Router",
        "signature": "sanic.router.Router.parse_parameter_string(cls, parameter_string)",
        "snippet": "    def parse_parameter_string(cls, parameter_string):\n        \"\"\"Parse a parameter string into its constituent name, type, and\n        pattern\n\n        For example::\n\n            parse_parameter_string('<param_one:[A-z]>')` ->\n                ('param_one', str, '[A-z]')\n\n        :param parameter_string: String to parse\n        :return: tuple containing\n            (parameter_name, parameter_type, parameter_pattern)\n        \"\"\"\n        # We could receive NAME or NAME:PATTERN\n        name = parameter_string\n        pattern = \"string\"\n        if \":\" in parameter_string:\n            name, pattern = parameter_string.split(\":\", 1)\n            if not name:\n                raise ValueError(\n                    \"Invalid parameter syntax: {}\".format(parameter_string)\n                )\n\n        default = (str, pattern)\n        # Pull from pre-configured types\n        _type, pattern = REGEX_TYPES.get(pattern, default)\n\n        return name, _type, pattern",
        "begin_line": 92,
        "end_line": 119,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.router.Router.add#121",
        "src_path": "sanic/router.py",
        "class_name": "sanic.router.Router",
        "signature": "sanic.router.Router.add(self, uri, methods, handler, host=None, strict_slashes=False, version=None, name=None)",
        "snippet": "    def add(\n        self,\n        uri,\n        methods,\n        handler,\n        host=None,\n        strict_slashes=False,\n        version=None,\n        name=None,\n    ):\n        \"\"\"Add a handler to the route list\n\n        :param uri: path to match\n        :param methods: sequence of accepted method names. If none are\n            provided, any method is allowed\n        :param handler: request handler function.\n            When executed, it should provide a response object.\n        :param strict_slashes: strict to trailing slash\n        :param version: current version of the route or blueprint. See\n            docs for further details.\n        :return: Nothing\n        \"\"\"\n        if version is not None:\n            version = re.escape(str(version).strip(\"/\").lstrip(\"v\"))\n            uri = \"/\".join([\"/v{}\".format(version), uri.lstrip(\"/\")])\n        # add regular version\n        self._add(uri, methods, handler, host, name)\n\n        if strict_slashes:\n            return\n\n        if not isinstance(host, str) and host is not None:\n            # we have gotten back to the top of the recursion tree where the\n            # host was originally a list. By now, we've processed the strict\n            # slashes logic on the leaf nodes (the individual host strings in\n            # the list of host)\n            return\n\n        # Add versions with and without trailing /\n        slashed_methods = self.routes_all.get(uri + \"/\", frozenset({}))\n        unslashed_methods = self.routes_all.get(uri[:-1], frozenset({}))\n        if isinstance(methods, Iterable):\n            _slash_is_missing = all(\n                method in slashed_methods for method in methods\n            )\n            _without_slash_is_missing = all(\n                method in unslashed_methods for method in methods\n            )\n        else:\n            _slash_is_missing = methods in slashed_methods\n            _without_slash_is_missing = methods in unslashed_methods\n\n        slash_is_missing = not uri[-1] == \"/\" and not _slash_is_missing\n        without_slash_is_missing = (\n            uri[-1] == \"/\" and not _without_slash_is_missing and not uri == \"/\"\n        )\n        # add version with trailing slash\n        if slash_is_missing:\n            self._add(uri + \"/\", methods, handler, host, name)\n        # add version without trailing slash\n        elif without_slash_is_missing:\n            self._add(uri[:-1], methods, handler, host, name)",
        "begin_line": 121,
        "end_line": 182,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007751937984496124,
            "pseudo_dstar_susp": 0.125,
            "pseudo_tarantula_susp": 0.006896551724137931,
            "pseudo_op2_susp": 0.125,
            "pseudo_barinel_susp": 0.006896551724137931
        }
    },
    {
        "name": "sanic.router.Router._add#184",
        "src_path": "sanic/router.py",
        "class_name": "sanic.router.Router",
        "signature": "sanic.router.Router._add(self, uri, methods, handler, host=None, name=None)",
        "snippet": "    def _add(self, uri, methods, handler, host=None, name=None):\n        \"\"\"Add a handler to the route list\n\n        :param uri: path to match\n        :param methods: sequence of accepted method names. If none are\n            provided, any method is allowed\n        :param handler: request handler function.\n            When executed, it should provide a response object.\n        :param name: user defined route name for url_for\n        :return: Nothing\n        \"\"\"\n        if host is not None:\n            if isinstance(host, str):\n                uri = host + uri\n                self.hosts.add(host)\n\n            else:\n                if not isinstance(host, Iterable):\n                    raise ValueError(\n                        \"Expected either string or Iterable of \"\n                        \"host strings, not {!r}\".format(host)\n                    )\n\n                for host_ in host:\n                    self.add(uri, methods, handler, host_, name)\n                return\n\n        # Dict for faster lookups of if method allowed\n        if methods:\n            methods = frozenset(methods)\n\n        parameters = []\n        parameter_names = set()\n        properties = {\"unhashable\": None}\n\n        def add_parameter(match):\n            name = match.group(1)\n            name, _type, pattern = self.parse_parameter_string(name)\n\n            if name in parameter_names:\n                raise ParameterNameConflicts(\n                    \"Multiple parameter named <{name}> \"\n                    \"in route uri {uri}\".format(name=name, uri=uri)\n                )\n            parameter_names.add(name)\n\n            parameter = Parameter(name=name, cast=_type)\n            parameters.append(parameter)\n\n            # Mark the whole route as unhashable if it has the hash key in it\n            if re.search(r\"(^|[^^]){1}/\", pattern):\n                properties[\"unhashable\"] = True\n            # Mark the route as unhashable if it matches the hash key\n            elif re.search(r\"/\", pattern):\n                properties[\"unhashable\"] = True\n\n            return \"({})\".format(pattern)\n\n        pattern_string = re.sub(self.parameter_pattern, add_parameter, uri)\n        pattern = re.compile(r\"^{}$\".format(pattern_string))\n\n        def merge_route(route, methods, handler):\n            # merge to the existing route when possible.\n            if not route.methods or not methods:\n                # method-unspecified routes are not mergeable.\n                raise RouteExists(\"Route already registered: {}\".format(uri))\n            elif route.methods.intersection(methods):\n                # already existing method is not overloadable.\n                duplicated = methods.intersection(route.methods)\n                raise RouteExists(\n                    \"Route already registered: {} [{}]\".format(\n                        uri, \",\".join(list(duplicated))\n                    )\n                )\n            if isinstance(route.handler, CompositionView):\n                view = route.handler\n            else:\n                view = CompositionView()\n                view.add(route.methods, route.handler)\n            view.add(methods, handler)\n            route = route._replace(\n                handler=view, methods=methods.union(route.methods)\n            )\n            return route\n\n        if parameters:\n            # TODO: This is too complex, we need to reduce the complexity\n            if properties[\"unhashable\"]:\n                routes_to_check = self.routes_always_check\n                ndx, route = self.check_dynamic_route_exists(\n                    pattern, routes_to_check, parameters\n                )\n            else:\n                routes_to_check = self.routes_dynamic[url_hash(uri)]\n                ndx, route = self.check_dynamic_route_exists(\n                    pattern, routes_to_check, parameters\n                )\n            if ndx != -1:\n                # Pop the ndx of the route, no dups of the same route\n                routes_to_check.pop(ndx)\n        else:\n            route = self.routes_all.get(uri)\n\n        # prefix the handler name with the blueprint name\n        # if available\n        # special prefix for static files\n        is_static = False\n        if name and name.startswith(\"_static_\"):\n            is_static = True\n            name = name.split(\"_static_\", 1)[-1]\n\n        if hasattr(handler, \"__blueprintname__\"):\n            handler_name = \"{}.{}\".format(\n                handler.__blueprintname__, name or handler.__name__\n            )\n        else:\n            handler_name = name or getattr(handler, \"__name__\", None)\n\n        if route:\n            route = merge_route(route, methods, handler)\n        else:\n            route = Route(\n                handler=handler,\n                methods=methods,\n                pattern=pattern,\n                parameters=parameters,\n                name=handler_name,\n                uri=uri,\n            )\n\n        self.routes_all[uri] = route\n        if is_static:\n            pair = self.routes_static_files.get(handler_name)\n            if not (pair and (pair[0] + \"/\" == uri or uri + \"/\" == pair[0])):\n                self.routes_static_files[handler_name] = (uri, route)\n\n        else:\n            pair = self.routes_names.get(handler_name)\n            if not (pair and (pair[0] + \"/\" == uri or uri + \"/\" == pair[0])):\n                self.routes_names[handler_name] = (uri, route)\n\n        if properties[\"unhashable\"]:\n            self.routes_always_check.append(route)\n        elif parameters:\n            self.routes_dynamic[url_hash(uri)].append(route)\n        else:\n            self.routes_static[uri] = route",
        "begin_line": 184,
        "end_line": 330,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004329004329004329,
            "pseudo_dstar_susp": 0.008695652173913044,
            "pseudo_tarantula_susp": 0.0045045045045045045,
            "pseudo_op2_susp": 0.008695652173913044,
            "pseudo_barinel_susp": 0.0045045045045045045
        }
    },
    {
        "name": "sanic.router.Router.add_parameter#219",
        "src_path": "sanic/router.py",
        "class_name": "sanic.router.Router",
        "signature": "sanic.router.Router.add_parameter(match)",
        "snippet": "        def add_parameter(match):\n            name = match.group(1)\n            name, _type, pattern = self.parse_parameter_string(name)\n\n            if name in parameter_names:\n                raise ParameterNameConflicts(\n                    \"Multiple parameter named <{name}> \"\n                    \"in route uri {uri}\".format(name=name, uri=uri)\n                )\n            parameter_names.add(name)\n\n            parameter = Parameter(name=name, cast=_type)\n            parameters.append(parameter)\n\n            # Mark the whole route as unhashable if it has the hash key in it\n            if re.search(r\"(^|[^^]){1}/\", pattern):\n                properties[\"unhashable\"] = True\n            # Mark the route as unhashable if it matches the hash key\n            elif re.search(r\"/\", pattern):\n                properties[\"unhashable\"] = True\n\n            return \"({})\".format(pattern)",
        "begin_line": 219,
        "end_line": 240,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012804097311139564,
            "pseudo_dstar_susp": 0.0015037593984962407,
            "pseudo_tarantula_susp": 0.0012787723785166241,
            "pseudo_op2_susp": 0.0015037593984962407,
            "pseudo_barinel_susp": 0.0012787723785166241
        }
    },
    {
        "name": "sanic.router.Router.merge_route#245",
        "src_path": "sanic/router.py",
        "class_name": "sanic.router.Router",
        "signature": "sanic.router.Router.merge_route(route, methods, handler)",
        "snippet": "        def merge_route(route, methods, handler):\n            # merge to the existing route when possible.\n            if not route.methods or not methods:\n                # method-unspecified routes are not mergeable.\n                raise RouteExists(\"Route already registered: {}\".format(uri))\n            elif route.methods.intersection(methods):\n                # already existing method is not overloadable.\n                duplicated = methods.intersection(route.methods)\n                raise RouteExists(\n                    \"Route already registered: {} [{}]\".format(\n                        uri, \",\".join(list(duplicated))\n                    )\n                )\n            if isinstance(route.handler, CompositionView):\n                view = route.handler\n            else:\n                view = CompositionView()\n                view.add(route.methods, route.handler)\n            view.add(methods, handler)\n            route = route._replace(\n                handler=view, methods=methods.union(route.methods)\n            )\n            return route",
        "begin_line": 245,
        "end_line": 267,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0013717421124828531,
            "pseudo_dstar_susp": 0.0016313213703099511,
            "pseudo_tarantula_susp": 0.0013717421124828531,
            "pseudo_op2_susp": 0.0016313213703099511,
            "pseudo_barinel_susp": 0.0013717421124828531
        }
    },
    {
        "name": "sanic.router.Router.check_dynamic_route_exists#333",
        "src_path": "sanic/router.py",
        "class_name": "sanic.router.Router",
        "signature": "sanic.router.Router.check_dynamic_route_exists(pattern, routes_to_check, parameters)",
        "snippet": "    def check_dynamic_route_exists(pattern, routes_to_check, parameters):\n        \"\"\"\n        Check if a URL pattern exists in a list of routes provided based on\n        the comparison of URL pattern and the parameters.\n\n        :param pattern: URL parameter pattern\n        :param routes_to_check: list of dynamic routes either hashable or\n            unhashable routes.\n        :param parameters: List of :class:`Parameter` items\n        :return: Tuple of index and route if matching route exists else\n            -1 for index and None for route\n        \"\"\"\n        for ndx, route in enumerate(routes_to_check):\n            if route.pattern == pattern and route.parameters == parameters:\n                return ndx, route\n        else:\n            return -1, None",
        "begin_line": 333,
        "end_line": 349,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004997501249375312,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.router.Router.remove#351",
        "src_path": "sanic/router.py",
        "class_name": "sanic.router.Router",
        "signature": "sanic.router.Router.remove(self, uri, clean_cache=True, host=None)",
        "snippet": "    def remove(self, uri, clean_cache=True, host=None):\n        if host is not None:\n            uri = host + uri\n        try:\n            route = self.routes_all.pop(uri)\n            for handler_name, pairs in self.routes_names.items():\n                if pairs[0] == uri:\n                    self.routes_names.pop(handler_name)\n                    break\n\n            for handler_name, pairs in self.routes_static_files.items():\n                if pairs[0] == uri:\n                    self.routes_static_files.pop(handler_name)\n                    break\n\n        except KeyError:\n            raise RouteDoesNotExist(\"Route was not registered: {}\".format(uri))\n\n        if route in self.routes_always_check:\n            self.routes_always_check.remove(route)\n        elif (\n            url_hash(uri) in self.routes_dynamic\n            and route in self.routes_dynamic[url_hash(uri)]\n        ):\n            self.routes_dynamic[url_hash(uri)].remove(route)\n        else:\n            self.routes_static.pop(uri)\n\n        if clean_cache:\n            self._get.cache_clear()",
        "begin_line": 351,
        "end_line": 380,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.router.Router.find_route_by_view_name#383",
        "src_path": "sanic/router.py",
        "class_name": "sanic.router.Router",
        "signature": "sanic.router.Router.find_route_by_view_name(self, view_name, name=None)",
        "snippet": "    def find_route_by_view_name(self, view_name, name=None):\n        \"\"\"Find a route in the router based on the specified view name.\n\n        :param view_name: string of view name to search by\n        :param kwargs: additional params, usually for static files\n        :return: tuple containing (uri, Route)\n        \"\"\"\n        if not view_name:\n            return (None, None)\n\n        if view_name == \"static\" or view_name.endswith(\".static\"):\n            return self.routes_static_files.get(name, (None, None))\n\n        return self.routes_names.get(view_name, (None, None))",
        "begin_line": 383,
        "end_line": 396,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004149377593360996,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.router.Router.get#398",
        "src_path": "sanic/router.py",
        "class_name": "sanic.router.Router",
        "signature": "sanic.router.Router.get(self, request)",
        "snippet": "    def get(self, request):\n        \"\"\"Get a request handler based on the URL of the request, or raises an\n        error\n\n        :param request: Request object\n        :return: handler, arguments, keyword arguments\n        \"\"\"\n        # No virtual hosts specified; default behavior\n        if not self.hosts:\n            return self._get(request.path, request.method, \"\")\n        # virtual hosts specified; try to match route to the host header\n\n        try:\n            return self._get(\n                request.path, request.method, request.headers.get(\"Host\", \"\")\n            )\n        # try default hosts\n        except NotFound:\n            return self._get(request.path, request.method, \"\")",
        "begin_line": 398,
        "end_line": 416,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016366612111292963,
            "pseudo_dstar_susp": 0.00202020202020202,
            "pseudo_tarantula_susp": 0.001644736842105263,
            "pseudo_op2_susp": 0.00202020202020202,
            "pseudo_barinel_susp": 0.001644736842105263
        }
    },
    {
        "name": "sanic.router.Router.get_supported_methods#418",
        "src_path": "sanic/router.py",
        "class_name": "sanic.router.Router",
        "signature": "sanic.router.Router.get_supported_methods(self, url)",
        "snippet": "    def get_supported_methods(self, url):\n        \"\"\"Get a list of supported methods for a url and optional host.\n\n        :param url: URL string (including host)\n        :return: frozenset of supported methods\n        \"\"\"\n        route = self.routes_all.get(url)\n        # if methods are None then this logic will prevent an error\n        return getattr(route, \"methods\", None) or frozenset()",
        "begin_line": 418,
        "end_line": 426,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016129032258064516,
            "pseudo_dstar_susp": 0.001984126984126984,
            "pseudo_tarantula_susp": 0.0016207455429497568,
            "pseudo_op2_susp": 0.001984126984126984,
            "pseudo_barinel_susp": 0.0016207455429497568
        }
    },
    {
        "name": "sanic.router.Router._get#429",
        "src_path": "sanic/router.py",
        "class_name": "sanic.router.Router",
        "signature": "sanic.router.Router._get(self, url, method, host)",
        "snippet": "    def _get(self, url, method, host):\n        \"\"\"Get a request handler based on the URL of the request, or raises an\n        error.  Internal method for caching.\n\n        :param url: request URL\n        :param method: request method\n        :return: handler, arguments, keyword arguments\n        \"\"\"\n        url = unquote(host + url)\n        # Check against known static routes\n        route = self.routes_static.get(url)\n        method_not_supported = MethodNotSupported(\n            \"Method {} not allowed for URL {}\".format(method, url),\n            method=method,\n            allowed_methods=self.get_supported_methods(url),\n        )\n        if route:\n            if route.methods and method not in route.methods:\n                raise method_not_supported\n            match = route.pattern.match(url)\n        else:\n            route_found = False\n            # Move on to testing all regex routes\n            for route in self.routes_dynamic[url_hash(url)]:\n                match = route.pattern.match(url)\n                route_found |= match is not None\n                # Do early method checking\n                if match and method in route.methods:\n                    break\n            else:\n                # Lastly, check against all regex routes that cannot be hashed\n                for route in self.routes_always_check:\n                    match = route.pattern.match(url)\n                    route_found |= match is not None\n                    # Do early method checking\n                    if match and method in route.methods:\n                        break\n                else:\n                    # Route was found but the methods didn't match\n                    if route_found:\n                        raise method_not_supported\n                    raise NotFound(\"Requested URL {} not found\".format(url))\n\n        kwargs = {\n            p.name: p.cast(value)\n            for value, p in zip(match.groups(1), route.parameters)\n        }\n        route_handler = route.handler\n        if hasattr(route_handler, \"handlers\"):\n            route_handler = route_handler.handlers[method]\n        return route_handler, [], kwargs, route.uri",
        "begin_line": 429,
        "end_line": 479,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007874015748031496,
            "pseudo_dstar_susp": 0.16666666666666666,
            "pseudo_tarantula_susp": 0.006493506493506494,
            "pseudo_op2_susp": 0.16666666666666666,
            "pseudo_barinel_susp": 0.006493506493506494
        }
    },
    {
        "name": "sanic.router.Router.is_stream_handler#481",
        "src_path": "sanic/router.py",
        "class_name": "sanic.router.Router",
        "signature": "sanic.router.Router.is_stream_handler(self, request)",
        "snippet": "    def is_stream_handler(self, request):\n        \"\"\" Handler for request is stream or not.\n        :param request: Request object\n        :return: bool\n        \"\"\"\n        try:\n            handler = self.get(request)[0]\n        except (NotFound, MethodNotSupported):\n            return False\n        if hasattr(handler, \"view_class\") and hasattr(\n            handler.view_class, request.method.lower()\n        ):\n            handler = getattr(handler.view_class, request.method.lower())\n        return hasattr(handler, \"is_stream\")",
        "begin_line": 481,
        "end_line": 494,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.06666666666666667,
            "pseudo_dstar_susp": 0.0014705882352941176,
            "pseudo_tarantula_susp": 0.06666666666666667,
            "pseudo_op2_susp": 0.0014705882352941176,
            "pseudo_barinel_susp": 0.06666666666666667
        }
    },
    {
        "name": "sanic.compat.Header.get_all#5",
        "src_path": "sanic/compat.py",
        "class_name": "sanic.compat.Header",
        "signature": "sanic.compat.Header.get_all(self, key)",
        "snippet": "    def get_all(self, key):\n        return self.getall(key, default=[])",
        "begin_line": 5,
        "end_line": 6,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004997501249375312,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.websocket.WebSocketProtocol.__init__#29",
        "src_path": "sanic/websocket.py",
        "class_name": "sanic.websocket.WebSocketProtocol",
        "signature": "sanic.websocket.WebSocketProtocol.__init__(self, *args, websocket_timeout=10, websocket_max_size=None, websocket_max_queue=None, websocket_read_limit=2 ** 16, websocket_write_limit=2 ** 16, **kwargs)",
        "snippet": "    def __init__(\n        self,\n        *args,\n        websocket_timeout=10,\n        websocket_max_size=None,\n        websocket_max_queue=None,\n        websocket_read_limit=2 ** 16,\n        websocket_write_limit=2 ** 16,\n        **kwargs\n    ):\n        super().__init__(*args, **kwargs)\n        self.websocket = None\n        # self.app = None\n        self.websocket_timeout = websocket_timeout\n        self.websocket_max_size = websocket_max_size\n        self.websocket_max_queue = websocket_max_queue\n        self.websocket_read_limit = websocket_read_limit\n        self.websocket_write_limit = websocket_write_limit",
        "begin_line": 29,
        "end_line": 46,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00046728971962616824,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.websocket.WebSocketProtocol.request_timeout_callback#49",
        "src_path": "sanic/websocket.py",
        "class_name": "sanic.websocket.WebSocketProtocol",
        "signature": "sanic.websocket.WebSocketProtocol.request_timeout_callback(self)",
        "snippet": "    def request_timeout_callback(self):\n        if self.websocket is None:\n            super().request_timeout_callback()",
        "begin_line": 49,
        "end_line": 51,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.websocket.WebSocketProtocol.connection_lost#61",
        "src_path": "sanic/websocket.py",
        "class_name": "sanic.websocket.WebSocketProtocol",
        "signature": "sanic.websocket.WebSocketProtocol.connection_lost(self, exc)",
        "snippet": "    def connection_lost(self, exc):\n        if self.websocket is not None:\n            self.websocket.connection_lost(exc)\n        super().connection_lost(exc)",
        "begin_line": 61,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004997501249375312,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.websocket.WebSocketProtocol.data_received#66",
        "src_path": "sanic/websocket.py",
        "class_name": "sanic.websocket.WebSocketProtocol",
        "signature": "sanic.websocket.WebSocketProtocol.data_received(self, data)",
        "snippet": "    def data_received(self, data):\n        if self.websocket is not None:\n            # pass the data to the websocket protocol\n            self.websocket.data_received(data)\n        else:\n            try:\n                super().data_received(data)\n            except HttpParserUpgrade:\n                # this is okay, it just indicates we've got an upgrade request\n                pass",
        "begin_line": 66,
        "end_line": 75,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004997501249375312,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.websocket.WebSocketProtocol.write_response#77",
        "src_path": "sanic/websocket.py",
        "class_name": "sanic.websocket.WebSocketProtocol",
        "signature": "sanic.websocket.WebSocketProtocol.write_response(self, response)",
        "snippet": "    def write_response(self, response):\n        if self.websocket is not None:\n            # websocket requests do not write a response\n            self.transport.close()\n        else:\n            super().write_response(response)",
        "begin_line": 77,
        "end_line": 82,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.websocket.WebSocketProtocol.websocket_handshake#84",
        "src_path": "sanic/websocket.py",
        "class_name": "sanic.websocket.WebSocketProtocol",
        "signature": "sanic.websocket.WebSocketProtocol.websocket_handshake(self, request, subprotocols=None)",
        "snippet": "    async def websocket_handshake(self, request, subprotocols=None):\n        # let the websockets package do the handshake with the client\n        headers = {}\n\n        try:\n            key = handshake.check_request(request.headers)\n            handshake.build_response(headers, key)\n        except InvalidHandshake:\n            raise InvalidUsage(\"Invalid websocket request\")\n\n        subprotocol = None\n        if subprotocols and \"Sec-Websocket-Protocol\" in request.headers:\n            # select a subprotocol\n            client_subprotocols = [\n                p.strip()\n                for p in request.headers[\"Sec-Websocket-Protocol\"].split(\",\")\n            ]\n            for p in client_subprotocols:\n                if p in subprotocols:\n                    subprotocol = p\n                    headers[\"Sec-Websocket-Protocol\"] = subprotocol\n                    break\n\n        # write the 101 response back to the client\n        rv = b\"HTTP/1.1 101 Switching Protocols\\r\\n\"\n        for k, v in headers.items():\n            rv += k.encode(\"utf-8\") + b\": \" + v.encode(\"utf-8\") + b\"\\r\\n\"\n        rv += b\"\\r\\n\"\n        request.transport.write(rv)\n\n        # hook up the websocket protocol\n        self.websocket = WebSocketCommonProtocol(\n            timeout=self.websocket_timeout,\n            max_size=self.websocket_max_size,\n            max_queue=self.websocket_max_queue,\n            read_limit=self.websocket_read_limit,\n            write_limit=self.websocket_write_limit,\n        )\n        # Following two lines are required for websockets 8.x\n        self.websocket.is_client = False\n        self.websocket.side = \"server\"\n        self.websocket.subprotocol = subprotocol\n        self.websocket.connection_made(request.transport)\n        self.websocket.connection_open()\n        return self.websocket",
        "begin_line": 84,
        "end_line": 128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.websocket.WebSocketConnection.__init__#136",
        "src_path": "sanic/websocket.py",
        "class_name": "sanic.websocket.WebSocketConnection",
        "signature": "sanic.websocket.WebSocketConnection.__init__(self, send: Callable[[ASIMessage], Awaitable[None]], receive: Callable[[], Awaitable[ASIMessage]])",
        "snippet": "    def __init__(\n        self,\n        send: Callable[[ASIMessage], Awaitable[None]],\n        receive: Callable[[], Awaitable[ASIMessage]],\n    ) -> None:\n        self._send = send\n        self._receive = receive",
        "begin_line": 136,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005586592178770949,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.websocket.WebSocketConnection.send#144",
        "src_path": "sanic/websocket.py",
        "class_name": "sanic.websocket.WebSocketConnection",
        "signature": "sanic.websocket.WebSocketConnection.send(self, data: Union[str, bytes], *args, **kwargs)",
        "snippet": "    async def send(self, data: Union[str, bytes], *args, **kwargs) -> None:\n        message: Dict[str, Union[str, bytes]] = {\"type\": \"websocket.send\"}\n\n        if isinstance(data, bytes):\n            message.update({\"bytes\": data})\n        else:\n            message.update({\"text\": str(data)})\n\n        await self._send(message)",
        "begin_line": 144,
        "end_line": 152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.websocket.WebSocketConnection.recv#154",
        "src_path": "sanic/websocket.py",
        "class_name": "sanic.websocket.WebSocketConnection",
        "signature": "sanic.websocket.WebSocketConnection.recv(self, *args, **kwargs)",
        "snippet": "    async def recv(self, *args, **kwargs) -> Optional[str]:\n        message = await self._receive()\n\n        if message[\"type\"] == \"websocket.receive\":\n            return message[\"text\"]\n        elif message[\"type\"] == \"websocket.disconnect\":\n            pass\n\n        return None",
        "begin_line": 154,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.websocket.WebSocketConnection.accept#166",
        "src_path": "sanic/websocket.py",
        "class_name": "sanic.websocket.WebSocketConnection",
        "signature": "sanic.websocket.WebSocketConnection.accept(self)",
        "snippet": "    async def accept(self) -> None:\n        await self._send({\"type\": \"websocket.accept\", \"subprotocol\": \"\"})",
        "begin_line": 166,
        "end_line": 167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.websocket.WebSocketConnection.close#169",
        "src_path": "sanic/websocket.py",
        "class_name": "sanic.websocket.WebSocketConnection",
        "signature": "sanic.websocket.WebSocketConnection.close(self)",
        "snippet": "    async def close(self) -> None:\n        pass",
        "begin_line": 169,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.MockProtocol.__init__#38",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.MockProtocol",
        "signature": "sanic.asgi.MockProtocol.__init__(self, transport: 'MockTransport', loop)",
        "snippet": "    def __init__(self, transport: \"MockTransport\", loop):\n        self.transport = transport\n        self._not_paused = asyncio.Event(loop=loop)\n        self._not_paused.set()\n        self._complete = asyncio.Event(loop=loop)",
        "begin_line": 38,
        "end_line": 42,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.MockProtocol.pause_writing#44",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.MockProtocol",
        "signature": "sanic.asgi.MockProtocol.pause_writing(self)",
        "snippet": "    def pause_writing(self) -> None:\n        self._not_paused.clear()",
        "begin_line": 44,
        "end_line": 45,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.MockProtocol.resume_writing#47",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.MockProtocol",
        "signature": "sanic.asgi.MockProtocol.resume_writing(self)",
        "snippet": "    def resume_writing(self) -> None:\n        self._not_paused.set()",
        "begin_line": 47,
        "end_line": 48,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.MockProtocol.complete#50",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.MockProtocol",
        "signature": "sanic.asgi.MockProtocol.complete(self)",
        "snippet": "    async def complete(self) -> None:\n        self._not_paused.set()\n        await self.transport.send(\n            {\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False}\n        )",
        "begin_line": 50,
        "end_line": 54,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.MockProtocol.is_complete#57",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.MockProtocol",
        "signature": "sanic.asgi.MockProtocol.is_complete(self)",
        "snippet": "    def is_complete(self) -> bool:\n        return self._complete.is_set()",
        "begin_line": 57,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.MockProtocol.push_data#60",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.MockProtocol",
        "signature": "sanic.asgi.MockProtocol.push_data(self, data: bytes)",
        "snippet": "    async def push_data(self, data: bytes) -> None:\n        if not self.is_complete:\n            await self.transport.send(\n                {\"type\": \"http.response.body\", \"body\": data, \"more_body\": True}\n            )",
        "begin_line": 60,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.MockTransport.__init__#73",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.MockTransport",
        "signature": "sanic.asgi.MockTransport.__init__(self, scope: ASGIScope, receive: ASGIReceive, send: ASGISend)",
        "snippet": "    def __init__(\n        self, scope: ASGIScope, receive: ASGIReceive, send: ASGISend\n    ) -> None:\n        self.scope = scope\n        self._receive = receive\n        self._send = send\n        self._protocol = None\n        self.loop = None",
        "begin_line": 73,
        "end_line": 80,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00035790980672870435,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.MockTransport.get_protocol#82",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.MockTransport",
        "signature": "sanic.asgi.MockTransport.get_protocol(self)",
        "snippet": "    def get_protocol(self) -> MockProtocol:\n        if not self._protocol:\n            self._protocol = MockProtocol(self, self.loop)\n        return self._protocol",
        "begin_line": 82,
        "end_line": 85,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.MockTransport.get_extra_info#87",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.MockTransport",
        "signature": "sanic.asgi.MockTransport.get_extra_info(self, info: str)",
        "snippet": "    def get_extra_info(self, info: str) -> Union[str, bool, None]:\n        if info == \"peername\":\n            return self.scope.get(\"server\")\n        elif info == \"sslcontext\":\n            return self.scope.get(\"scheme\") in [\"https\", \"wss\"]\n        return None",
        "begin_line": 87,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.MockTransport.get_websocket_connection#94",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.MockTransport",
        "signature": "sanic.asgi.MockTransport.get_websocket_connection(self)",
        "snippet": "    def get_websocket_connection(self) -> WebSocketConnection:\n        try:\n            return self._websocket_connection\n        except AttributeError:\n            raise InvalidUsage(\"Improper websocket connection.\")",
        "begin_line": 94,
        "end_line": 98,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.MockTransport.create_websocket_connection#100",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.MockTransport",
        "signature": "sanic.asgi.MockTransport.create_websocket_connection(self, send: ASGISend, receive: ASGIReceive)",
        "snippet": "    def create_websocket_connection(\n        self, send: ASGISend, receive: ASGIReceive\n    ) -> WebSocketConnection:\n        self._websocket_connection = WebSocketConnection(send, receive)\n        return self._websocket_connection",
        "begin_line": 100,
        "end_line": 104,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0006317119393556538,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.MockTransport.send#109",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.MockTransport",
        "signature": "sanic.asgi.MockTransport.send(self, data)",
        "snippet": "    async def send(self, data) -> None:\n        # TODO:\n        # - Validation on data and that it is formatted properly and is valid\n        await self._send(data)",
        "begin_line": 109,
        "end_line": 112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0003766478342749529,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.MockTransport.receive#114",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.MockTransport",
        "signature": "sanic.asgi.MockTransport.receive(self)",
        "snippet": "    async def receive(self) -> ASGIMessage:\n        return await self._receive()",
        "begin_line": 114,
        "end_line": 115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00036010082823190496,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.Lifespan.__init__#119",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.Lifespan",
        "signature": "sanic.asgi.Lifespan.__init__(self, asgi_app: 'ASGIApp')",
        "snippet": "    def __init__(self, asgi_app: \"ASGIApp\") -> None:\n        self.asgi_app = asgi_app\n\n        if \"before_server_start\" in self.asgi_app.sanic_app.listeners:\n            warnings.warn(\n                'You have set a listener for \"before_server_start\" '\n                \"in ASGI mode. \"\n                \"It will be executed as early as possible, but not before \"\n                \"the ASGI server is started.\"\n            )\n        if \"after_server_stop\" in self.asgi_app.sanic_app.listeners:\n            warnings.warn(\n                'You have set a listener for \"after_server_stop\" '\n                \"in ASGI mode. \"\n                \"It will be executed as late as possible, but not after \"\n                \"the ASGI server is stopped.\"\n            )",
        "begin_line": 119,
        "end_line": 135,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.Lifespan.startup#137",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.Lifespan",
        "signature": "sanic.asgi.Lifespan.startup(self)",
        "snippet": "    async def startup(self) -> None:\n        \"\"\"\n        Gather the listeners to fire on server start.\n        Because we are using a third-party server and not Sanic server, we do\n        not have access to fire anything BEFORE the server starts.\n        Therefore, we fire before_server_start and after_server_start\n        in sequence since the ASGI lifespan protocol only supports a single\n        startup event.\n        \"\"\"\n        listeners = self.asgi_app.sanic_app.listeners.get(\n            \"before_server_start\", []\n        ) + self.asgi_app.sanic_app.listeners.get(\"after_server_start\", [])\n\n        for handler in listeners:\n            response = handler(\n                self.asgi_app.sanic_app, self.asgi_app.sanic_app.loop\n            )\n            if isawaitable(response):\n                await response",
        "begin_line": 137,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.Lifespan.shutdown#157",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.Lifespan",
        "signature": "sanic.asgi.Lifespan.shutdown(self)",
        "snippet": "    async def shutdown(self) -> None:\n        \"\"\"\n        Gather the listeners to fire on server stop.\n        Because we are using a third-party server and not Sanic server, we do\n        not have access to fire anything AFTER the server stops.\n        Therefore, we fire before_server_stop and after_server_stop\n        in sequence since the ASGI lifespan protocol only supports a single\n        shutdown event.\n        \"\"\"\n        listeners = self.asgi_app.sanic_app.listeners.get(\n            \"before_server_stop\", []\n        ) + self.asgi_app.sanic_app.listeners.get(\"after_server_stop\", [])\n\n        for handler in listeners:\n            response = handler(\n                self.asgi_app.sanic_app, self.asgi_app.sanic_app.loop\n            )\n            if isawaitable(response):\n                await response",
        "begin_line": 157,
        "end_line": 175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.Lifespan.__call__#177",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.Lifespan",
        "signature": "sanic.asgi.Lifespan.__call__(self, scope: ASGIScope, receive: ASGIReceive, send: ASGISend)",
        "snippet": "    async def __call__(\n        self, scope: ASGIScope, receive: ASGIReceive, send: ASGISend\n    ) -> None:\n        message = await receive()\n        if message[\"type\"] == \"lifespan.startup\":\n            await self.startup()\n            await send({\"type\": \"lifespan.startup.complete\"})\n\n        message = await receive()\n        if message[\"type\"] == \"lifespan.shutdown\":\n            await self.shutdown()\n            await send({\"type\": \"lifespan.shutdown.complete\"})",
        "begin_line": 177,
        "end_line": 188,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.ASGIApp.__init__#199",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.ASGIApp",
        "signature": "sanic.asgi.ASGIApp.__init__(self)",
        "snippet": "    def __init__(self) -> None:\n        self.ws = None",
        "begin_line": 199,
        "end_line": 200,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00036010082823190496,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.ASGIApp.create#203",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.ASGIApp",
        "signature": "sanic.asgi.ASGIApp.create(cls, sanic_app, scope: ASGIScope, receive: ASGIReceive, send: ASGISend)",
        "snippet": "    async def create(\n        cls, sanic_app, scope: ASGIScope, receive: ASGIReceive, send: ASGISend\n    ) -> \"ASGIApp\":\n        instance = cls()\n        instance.sanic_app = sanic_app\n        instance.transport = MockTransport(scope, receive, send)\n        instance.transport.loop = sanic_app.loop\n        setattr(instance.transport, \"add_task\", sanic_app.loop.create_task)\n\n        headers = Header(\n            [\n                (key.decode(\"latin-1\"), value.decode(\"latin-1\"))\n                for key, value in scope.get(\"headers\", [])\n            ]\n        )\n        instance.do_stream = (\n            True if headers.get(\"expect\") == \"100-continue\" else False\n        )\n        instance.lifespan = Lifespan(instance)\n\n        if scope[\"type\"] == \"lifespan\":\n            await instance.lifespan(scope, receive, send)\n        else:\n            url_bytes = scope.get(\"root_path\", \"\") + quote(scope[\"path\"])\n            url_bytes = url_bytes.encode(\"latin-1\")\n            url_bytes += b\"?\" + scope[\"query_string\"]\n\n            if scope[\"type\"] == \"http\":\n                version = scope[\"http_version\"]\n                method = scope[\"method\"]\n            elif scope[\"type\"] == \"websocket\":\n                version = \"1.1\"\n                method = \"GET\"\n\n                instance.ws = instance.transport.create_websocket_connection(\n                    send, receive\n                )\n                await instance.ws.accept()\n            else:\n                pass\n                # TODO:\n                # - close connection\n\n            request_class = sanic_app.request_class or Request\n            instance.request = request_class(\n                url_bytes,\n                headers,\n                version,\n                method,\n                instance.transport,\n                sanic_app,\n            )\n\n            if sanic_app.is_request_stream:\n                is_stream_handler = sanic_app.router.is_stream_handler(\n                    instance.request\n                )\n                if is_stream_handler:\n                    instance.request.stream = StreamBuffer(\n                        sanic_app.config.REQUEST_BUFFER_QUEUE_SIZE\n                    )\n                    instance.do_stream = True\n\n        return instance",
        "begin_line": 203,
        "end_line": 266,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.ASGIApp.read_body#268",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.ASGIApp",
        "signature": "sanic.asgi.ASGIApp.read_body(self)",
        "snippet": "    async def read_body(self) -> bytes:\n        \"\"\"\n        Read and return the entire body from an incoming ASGI message.\n        \"\"\"\n        body = b\"\"\n        more_body = True\n        while more_body:\n            message = await self.transport.receive()\n            body += message.get(\"body\", b\"\")\n            more_body = message.get(\"more_body\", False)\n\n        return body",
        "begin_line": 268,
        "end_line": 279,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00037383177570093456,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.ASGIApp.stream_body#281",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.ASGIApp",
        "signature": "sanic.asgi.ASGIApp.stream_body(self)",
        "snippet": "    async def stream_body(self) -> None:\n        \"\"\"\n        Read and stream the body in chunks from an incoming ASGI message.\n        \"\"\"\n        more_body = True\n\n        while more_body:\n            message = await self.transport.receive()\n            chunk = message.get(\"body\", b\"\")\n            await self.request.stream.put(chunk)\n\n            more_body = message.get(\"more_body\", False)\n\n        await self.request.stream.put(None)",
        "begin_line": 281,
        "end_line": 294,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.ASGIApp.__call__#296",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.ASGIApp",
        "signature": "sanic.asgi.ASGIApp.__call__(self)",
        "snippet": "    async def __call__(self) -> None:\n        \"\"\"\n        Handle the incoming request.\n        \"\"\"\n        if not self.do_stream:\n            self.request.body = await self.read_body()\n        else:\n            self.sanic_app.loop.create_task(self.stream_body())\n\n        handler = self.sanic_app.handle_request\n        callback = None if self.ws else self.stream_callback\n        await handler(self.request, None, callback)",
        "begin_line": 296,
        "end_line": 307,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.asgi.ASGIApp.stream_callback#309",
        "src_path": "sanic/asgi.py",
        "class_name": "sanic.asgi.ASGIApp",
        "signature": "sanic.asgi.ASGIApp.stream_callback(self, response: HTTPResponse)",
        "snippet": "    async def stream_callback(self, response: HTTPResponse) -> None:\n        \"\"\"\n        Write the response.\n        \"\"\"\n        headers: List[Tuple[bytes, bytes]] = []\n        cookies: Dict[str, str] = {}\n        try:\n            cookies = {\n                v.key: v\n                for _, v in list(\n                    filter(\n                        lambda item: item[0].lower() == \"set-cookie\",\n                        response.headers.items(),\n                    )\n                )\n            }\n            headers += [\n                (str(name).encode(\"latin-1\"), str(value).encode(\"latin-1\"))\n                for name, value in response.headers.items()\n                if name.lower() not in [\"set-cookie\"]\n            ]\n        except AttributeError:\n            logger.error(\n                \"Invalid response object for url %s, \"\n                \"Expected Type: HTTPResponse, Actual Type: %s\",\n                self.request.url,\n                type(response),\n            )\n            exception = ServerError(\"Invalid response type\")\n            response = self.sanic_app.error_handler.response(\n                self.request, exception\n            )\n            headers = [\n                (str(name).encode(\"latin-1\"), str(value).encode(\"latin-1\"))\n                for name, value in response.headers.items()\n                if name not in (b\"Set-Cookie\",)\n            ]\n\n        if \"content-length\" not in response.headers and not isinstance(\n            response, StreamingHTTPResponse\n        ):\n            headers += [\n                (b\"content-length\", str(len(response.body)).encode(\"latin-1\"))\n            ]\n\n        if \"content-type\" not in response.headers:\n            headers += [\n                (b\"content-type\", str(response.content_type).encode(\"latin-1\"))\n            ]\n\n        if response.cookies:\n            cookies.update(\n                {\n                    v.key: v\n                    for _, v in response.cookies.items()\n                    if v.key not in cookies.keys()\n                }\n            )\n\n        headers += [\n            (b\"set-cookie\", cookie.encode(\"utf-8\"))\n            for k, cookie in cookies.items()\n        ]\n\n        await self.transport.send(\n            {\n                \"type\": \"http.response.start\",\n                \"status\": response.status,\n                \"headers\": headers,\n            }\n        )\n\n        if isinstance(response, StreamingHTTPResponse):\n            response.protocol = self.transport.get_protocol()\n            await response.stream()\n            await response.protocol.complete()\n\n        else:\n            await self.transport.send(\n                {\n                    \"type\": \"http.response.body\",\n                    \"body\": response.body,\n                    \"more_body\": False,\n                }\n            )",
        "begin_line": 309,
        "end_line": 393,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.handlers.ErrorHandler.__init__#38",
        "src_path": "sanic/handlers.py",
        "class_name": "sanic.handlers.ErrorHandler",
        "signature": "sanic.handlers.ErrorHandler.__init__(self)",
        "snippet": "    def __init__(self):\n        self.handlers = []\n        self.cached_handlers = {}\n        self.debug = False",
        "begin_line": 38,
        "end_line": 41,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001321003963011889,
            "pseudo_dstar_susp": 0.0015600624024961,
            "pseudo_tarantula_susp": 0.001321003963011889,
            "pseudo_op2_susp": 0.0015600624024961,
            "pseudo_barinel_susp": 0.001321003963011889
        }
    },
    {
        "name": "sanic.handlers.ErrorHandler._render_exception#43",
        "src_path": "sanic/handlers.py",
        "class_name": "sanic.handlers.ErrorHandler",
        "signature": "sanic.handlers.ErrorHandler._render_exception(self, exception)",
        "snippet": "    def _render_exception(self, exception):\n        frames = extract_tb(exception.__traceback__)\n\n        frame_html = []\n        for frame in frames:\n            frame_html.append(TRACEBACK_LINE_HTML.format(frame))\n\n        return TRACEBACK_WRAPPER_INNER_HTML.format(\n            exc_name=exception.__class__.__name__,\n            exc_value=exception,\n            frame_html=\"\".join(frame_html),\n        )",
        "begin_line": 43,
        "end_line": 54,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.handlers.ErrorHandler._render_traceback_html#56",
        "src_path": "sanic/handlers.py",
        "class_name": "sanic.handlers.ErrorHandler",
        "signature": "sanic.handlers.ErrorHandler._render_traceback_html(self, exception, request)",
        "snippet": "    def _render_traceback_html(self, exception, request):\n        exc_type, exc_value, tb = sys.exc_info()\n        exceptions = []\n\n        while exc_value:\n            exceptions.append(self._render_exception(exc_value))\n            exc_value = exc_value.__cause__\n\n        return TRACEBACK_WRAPPER_HTML.format(\n            style=TRACEBACK_STYLE,\n            exc_name=exception.__class__.__name__,\n            exc_value=exception,\n            inner_html=TRACEBACK_BORDER.join(reversed(exceptions)),\n            path=request.path,\n        )",
        "begin_line": 56,
        "end_line": 70,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.handlers.ErrorHandler.add#72",
        "src_path": "sanic/handlers.py",
        "class_name": "sanic.handlers.ErrorHandler",
        "signature": "sanic.handlers.ErrorHandler.add(self, exception, handler)",
        "snippet": "    def add(self, exception, handler):\n        \"\"\"\n        Add a new exception handler to an already existing handler object.\n\n        :param exception: Type of exception that need to be handled\n        :param handler: Reference to the method that will handle the exception\n\n        :type exception: :class:`sanic.exceptions.SanicException` or\n            :class:`Exception`\n        :type handler: ``function``\n\n        :return: None\n        \"\"\"\n        self.handlers.append((exception, handler))",
        "begin_line": 72,
        "end_line": 85,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024096385542168677,
            "pseudo_dstar_susp": 0.0033444816053511705,
            "pseudo_tarantula_susp": 0.0024449877750611247,
            "pseudo_op2_susp": 0.0033444816053511705,
            "pseudo_barinel_susp": 0.0024449877750611247
        }
    },
    {
        "name": "sanic.handlers.ErrorHandler.lookup#87",
        "src_path": "sanic/handlers.py",
        "class_name": "sanic.handlers.ErrorHandler",
        "signature": "sanic.handlers.ErrorHandler.lookup(self, exception)",
        "snippet": "    def lookup(self, exception):\n        \"\"\"\n        Lookup the existing instance of :class:`ErrorHandler` and fetch the\n        registered handler for a specific type of exception.\n\n        This method leverages a dict lookup to speedup the retrieval process.\n\n        :param exception: Type of exception\n\n        :type exception: :class:`sanic.exceptions.SanicException` or\n            :class:`Exception`\n\n        :return: Registered function if found ``None`` otherwise\n        \"\"\"\n        handler = self.cached_handlers.get(type(exception), self._missing)\n        if handler is self._missing:\n            for exception_class, handler in self.handlers:\n                if isinstance(exception, exception_class):\n                    self.cached_handlers[type(exception)] = handler\n                    return handler\n            self.cached_handlers[type(exception)] = None\n            handler = None\n        return handler",
        "begin_line": 87,
        "end_line": 109,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0136986301369863,
            "pseudo_dstar_susp": 0.09090909090909091,
            "pseudo_tarantula_susp": 0.010752688172043012,
            "pseudo_op2_susp": 0.09090909090909091,
            "pseudo_barinel_susp": 0.010752688172043012
        }
    },
    {
        "name": "sanic.handlers.ErrorHandler.response#111",
        "src_path": "sanic/handlers.py",
        "class_name": "sanic.handlers.ErrorHandler",
        "signature": "sanic.handlers.ErrorHandler.response(self, request, exception)",
        "snippet": "    def response(self, request, exception):\n        \"\"\"Fetches and executes an exception handler and returns a response\n        object\n\n        :param request: Instance of :class:`sanic.request.Request`\n        :param exception: Exception to handle\n\n        :type request: :class:`sanic.request.Request`\n        :type exception: :class:`sanic.exceptions.SanicException` or\n            :class:`Exception`\n\n        :return: Wrap the return value obtained from :func:`default`\n            or registered handler for that type of exception.\n        \"\"\"\n        handler = self.lookup(exception)\n        response = None\n        try:\n            if handler:\n                response = handler(request, exception)\n            if response is None:\n                response = self.default(request, exception)\n        except Exception:\n            self.log(format_exc())\n            try:\n                url = repr(request.url)\n            except AttributeError:\n                url = \"unknown\"\n            response_message = (\n                \"Exception raised in exception handler \" '\"%s\" for uri: %s'\n            )\n            logger.exception(response_message, handler.__name__, url)\n\n            if self.debug:\n                return text(response_message % (handler.__name__, url), 500)\n            else:\n                return text(\"An error occurred while handling an error\", 500)\n        return response",
        "begin_line": 111,
        "end_line": 147,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.013333333333333334,
            "pseudo_dstar_susp": 0.07692307692307693,
            "pseudo_tarantula_susp": 0.010526315789473684,
            "pseudo_op2_susp": 0.07692307692307693,
            "pseudo_barinel_susp": 0.010526315789473684
        }
    },
    {
        "name": "sanic.handlers.ErrorHandler.log#149",
        "src_path": "sanic/handlers.py",
        "class_name": "sanic.handlers.ErrorHandler",
        "signature": "sanic.handlers.ErrorHandler.log(self, message, level='error')",
        "snippet": "    def log(self, message, level=\"error\"):\n        \"\"\"\n        Deprecated, do not use.\n        \"\"\"",
        "begin_line": 149,
        "end_line": 152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00980392156862745,
            "pseudo_dstar_susp": 0.045454545454545456,
            "pseudo_tarantula_susp": 0.009615384615384616,
            "pseudo_op2_susp": 0.045454545454545456,
            "pseudo_barinel_susp": 0.009615384615384616
        }
    },
    {
        "name": "sanic.handlers.ErrorHandler.default#154",
        "src_path": "sanic/handlers.py",
        "class_name": "sanic.handlers.ErrorHandler",
        "signature": "sanic.handlers.ErrorHandler.default(self, request, exception)",
        "snippet": "    def default(self, request, exception):\n        \"\"\"\n        Provide a default behavior for the objects of :class:`ErrorHandler`.\n        If a developer chooses to extent the :class:`ErrorHandler` they can\n        provide a custom implementation for this method to behave in a way\n        they see fit.\n\n        :param request: Incoming request\n        :param exception: Exception object\n\n        :type request: :class:`sanic.request.Request`\n        :type exception: :class:`sanic.exceptions.SanicException` or\n            :class:`Exception`\n        :return:\n        \"\"\"\n        self.log(format_exc())\n        try:\n            url = repr(request.url)\n        except AttributeError:\n            url = \"unknown\"\n\n        response_message = \"Exception occurred while handling uri: %s\"\n        logger.exception(response_message, url)\n\n        if issubclass(type(exception), SanicException):\n            return text(\n                \"Error: {}\".format(exception),\n                status=getattr(exception, \"status_code\", 500),\n                headers=getattr(exception, \"headers\", dict()),\n            )\n        elif self.debug:\n            html_output = self._render_traceback_html(exception, request)\n\n            return html(html_output, status=500)\n        else:\n            return html(INTERNAL_SERVER_ERROR_HTML, status=500)",
        "begin_line": 154,
        "end_line": 189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.06666666666666667,
            "pseudo_dstar_susp": 0.05555555555555555,
            "pseudo_tarantula_susp": 0.06666666666666667,
            "pseudo_op2_susp": 0.05555555555555555,
            "pseudo_barinel_susp": 0.06666666666666667
        }
    },
    {
        "name": "sanic.handlers.ContentRangeHandler.__init__#213",
        "src_path": "sanic/handlers.py",
        "class_name": "sanic.handlers.ContentRangeHandler",
        "signature": "sanic.handlers.ContentRangeHandler.__init__(self, request, stats)",
        "snippet": "    def __init__(self, request, stats):\n        self.total = stats.st_size\n        _range = request.headers.get(\"Range\")\n        if _range is None:\n            raise HeaderNotFound(\"Range Header Not Found\")\n        unit, _, value = tuple(map(str.strip, _range.partition(\"=\")))\n        if unit != \"bytes\":\n            raise InvalidRangeType(\n                \"%s is not a valid Range Type\" % (unit,), self\n            )\n        start_b, _, end_b = tuple(map(str.strip, value.partition(\"-\")))\n        try:\n            self.start = int(start_b) if start_b else None\n        except ValueError:\n            raise ContentRangeError(\n                \"'%s' is invalid for Content Range\" % (start_b,), self\n            )\n        try:\n            self.end = int(end_b) if end_b else None\n        except ValueError:\n            raise ContentRangeError(\n                \"'%s' is invalid for Content Range\" % (end_b,), self\n            )\n        if self.end is None:\n            if self.start is None:\n                raise ContentRangeError(\n                    \"Invalid for Content Range parameters\", self\n                )\n            else:\n                # this case represents `Content-Range: bytes 5-`\n                self.end = self.total - 1\n        else:\n            if self.start is None:\n                # this case represents `Content-Range: bytes -5`\n                self.start = self.total - self.end\n                self.end = self.total - 1\n        if self.start >= self.end:\n            raise ContentRangeError(\n                \"Invalid for Content Range parameters\", self\n            )\n        self.size = self.end - self.start + 1\n        self.headers = {\n            \"Content-Range\": \"bytes %s-%s/%s\"\n            % (self.start, self.end, self.total)\n        }",
        "begin_line": 213,
        "end_line": 257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.handlers.ContentRangeHandler.__bool__#259",
        "src_path": "sanic/handlers.py",
        "class_name": "sanic.handlers.ContentRangeHandler",
        "signature": "sanic.handlers.ContentRangeHandler.__bool__(self)",
        "snippet": "    def __bool__(self):\n        return self.size > 0",
        "begin_line": 259,
        "end_line": 260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprint_group.BlueprintGroup.__init__#16",
        "src_path": "sanic/blueprint_group.py",
        "class_name": "sanic.blueprint_group.BlueprintGroup",
        "signature": "sanic.blueprint_group.BlueprintGroup.__init__(self, url_prefix=None)",
        "snippet": "    def __init__(self, url_prefix=None):\n        \"\"\"\n        Create a new Blueprint Group\n\n        :param url_prefix: URL: to be prefixed before all the Blueprint Prefix\n        \"\"\"\n        self._blueprints = []\n        self._url_prefix = url_prefix",
        "begin_line": 16,
        "end_line": 23,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005393743257820927,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprint_group.BlueprintGroup.url_prefix#26",
        "src_path": "sanic/blueprint_group.py",
        "class_name": "sanic.blueprint_group.BlueprintGroup",
        "signature": "sanic.blueprint_group.BlueprintGroup.url_prefix(self)",
        "snippet": "    def url_prefix(self):\n        \"\"\"\n        Retrieve the URL prefix being used for the Current Blueprint Group\n        :return: string with url prefix\n        \"\"\"\n        return self._url_prefix",
        "begin_line": 26,
        "end_line": 31,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprint_group.BlueprintGroup.blueprints#34",
        "src_path": "sanic/blueprint_group.py",
        "class_name": "sanic.blueprint_group.BlueprintGroup",
        "signature": "sanic.blueprint_group.BlueprintGroup.blueprints(self)",
        "snippet": "    def blueprints(self):\n        \"\"\"\n        Retrieve a list of all the available blueprints under this group.\n        :return: List of Blueprint instance\n        \"\"\"\n        return self._blueprints",
        "begin_line": 34,
        "end_line": 39,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprint_group.BlueprintGroup.__iter__#41",
        "src_path": "sanic/blueprint_group.py",
        "class_name": "sanic.blueprint_group.BlueprintGroup",
        "signature": "sanic.blueprint_group.BlueprintGroup.__iter__(self)",
        "snippet": "    def __iter__(self):\n        \"\"\"Tun the class Blueprint Group into an Iterable item\"\"\"\n        return iter(self._blueprints)",
        "begin_line": 41,
        "end_line": 43,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprint_group.BlueprintGroup.__getitem__#45",
        "src_path": "sanic/blueprint_group.py",
        "class_name": "sanic.blueprint_group.BlueprintGroup",
        "signature": "sanic.blueprint_group.BlueprintGroup.__getitem__(self, item)",
        "snippet": "    def __getitem__(self, item):\n        \"\"\"\n        This method returns a blueprint inside the group specified by\n        an index value. This will enable indexing, splice and slicing\n        of the blueprint group like we can do with regular list/tuple.\n\n        This method is provided to ensure backward compatibility with\n        any of the pre-existing usage that might break.\n\n        :param item: Index of the Blueprint item in the group\n        :return: Blueprint object\n        \"\"\"\n        return self._blueprints[item]",
        "begin_line": 45,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprint_group.BlueprintGroup.__setitem__#59",
        "src_path": "sanic/blueprint_group.py",
        "class_name": "sanic.blueprint_group.BlueprintGroup",
        "signature": "sanic.blueprint_group.BlueprintGroup.__setitem__(self, index, item)",
        "snippet": "    def __setitem__(self, index, item) -> None:\n        \"\"\"\n        Abstract method implemented to turn the `BlueprintGroup` class\n        into a list like object to support all the existing behavior.\n\n        This method is used to perform the list's indexed setter operation.\n\n        :param index: Index to use for inserting a new Blueprint item\n        :param item: New `Blueprint` object.\n        :return: None\n        \"\"\"\n        self._blueprints[index] = item",
        "begin_line": 59,
        "end_line": 70,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprint_group.BlueprintGroup.__delitem__#72",
        "src_path": "sanic/blueprint_group.py",
        "class_name": "sanic.blueprint_group.BlueprintGroup",
        "signature": "sanic.blueprint_group.BlueprintGroup.__delitem__(self, index)",
        "snippet": "    def __delitem__(self, index) -> None:\n        \"\"\"\n        Abstract method implemented to turn the `BlueprintGroup` class\n        into a list like object to support all the existing behavior.\n\n        This method is used to delete an item from the list of blueprint\n        groups like it can be done on a regular list with index.\n\n        :param index: Index to use for removing a new Blueprint item\n        :return: None\n        \"\"\"\n        del self._blueprints[index]",
        "begin_line": 72,
        "end_line": 83,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprint_group.BlueprintGroup.__len__#85",
        "src_path": "sanic/blueprint_group.py",
        "class_name": "sanic.blueprint_group.BlueprintGroup",
        "signature": "sanic.blueprint_group.BlueprintGroup.__len__(self)",
        "snippet": "    def __len__(self) -> int:\n        \"\"\"\n        Get the Length of the blueprint group object.\n        :return: Length of Blueprint group object\n        \"\"\"\n        return len(self._blueprints)",
        "begin_line": 85,
        "end_line": 90,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005393743257820927,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprint_group.BlueprintGroup.insert#92",
        "src_path": "sanic/blueprint_group.py",
        "class_name": "sanic.blueprint_group.BlueprintGroup",
        "signature": "sanic.blueprint_group.BlueprintGroup.insert(self, index: int, item: object)",
        "snippet": "    def insert(self, index: int, item: object) -> None:\n        \"\"\"\n        The Abstract class `MutableSequence` leverages this insert method to\n        perform the `BlueprintGroup.append` operation.\n\n        :param index: Index to use for removing a new Blueprint item\n        :param item: New `Blueprint` object.\n        :return: None\n        \"\"\"\n        self._blueprints.insert(index, item)",
        "begin_line": 92,
        "end_line": 101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005393743257820927,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprint_group.BlueprintGroup.middleware#103",
        "src_path": "sanic/blueprint_group.py",
        "class_name": "sanic.blueprint_group.BlueprintGroup",
        "signature": "sanic.blueprint_group.BlueprintGroup.middleware(self, *args, **kwargs)",
        "snippet": "    def middleware(self, *args, **kwargs):\n        \"\"\"\n        A decorator that can be used to implement a Middleware plugin to\n        all of the Blueprints that belongs to this specific Blueprint Group.\n\n        In case of nested Blueprint Groups, the same middleware is applied\n        across each of the Blueprints recursively.\n\n        :param args: Optional positional Parameters to be use middleware\n        :param kwargs: Optional Keyword arg to use with Middleware\n        :return: Partial function to apply the middleware\n        \"\"\"\n        kwargs[\"bp_group\"] = True\n\n        def register_middleware_for_blueprints(fn):\n            for blueprint in self.blueprints:\n                blueprint.middleware(fn, *args, **kwargs)\n\n        return register_middleware_for_blueprints",
        "begin_line": 103,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.blueprint_group.BlueprintGroup.register_middleware_for_blueprints#117",
        "src_path": "sanic/blueprint_group.py",
        "class_name": "sanic.blueprint_group.BlueprintGroup",
        "signature": "sanic.blueprint_group.BlueprintGroup.register_middleware_for_blueprints(fn)",
        "snippet": "        def register_middleware_for_blueprints(fn):\n            for blueprint in self.blueprints:\n                blueprint.middleware(fn, *args, **kwargs)",
        "begin_line": 117,
        "end_line": 119,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.exceptions.SanicException.__init__#138",
        "src_path": "sanic/exceptions.py",
        "class_name": "sanic.exceptions.SanicException",
        "signature": "sanic.exceptions.SanicException.__init__(self, message, status_code=None)",
        "snippet": "    def __init__(self, message, status_code=None):\n        super().__init__(message)\n\n        if status_code is not None:\n            self.status_code = status_code",
        "begin_line": 138,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001375515818431912,
            "pseudo_dstar_susp": 0.0016366612111292963,
            "pseudo_tarantula_susp": 0.001375515818431912,
            "pseudo_op2_susp": 0.0016366612111292963,
            "pseudo_barinel_susp": 0.001375515818431912
        }
    },
    {
        "name": "sanic.exceptions.MethodNotSupported.__init__#157",
        "src_path": "sanic/exceptions.py",
        "class_name": "sanic.exceptions.MethodNotSupported",
        "signature": "sanic.exceptions.MethodNotSupported.__init__(self, message, method, allowed_methods)",
        "snippet": "    def __init__(self, message, method, allowed_methods):\n        super().__init__(message)\n        self.headers = dict()\n        self.headers[\"Allow\"] = \", \".join(allowed_methods)\n        if method in [\"HEAD\", \"PATCH\", \"PUT\", \"DELETE\"]:\n            self.headers[\"Content-Length\"] = 0",
        "begin_line": 157,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016129032258064516,
            "pseudo_dstar_susp": 0.001984126984126984,
            "pseudo_tarantula_susp": 0.0016207455429497568,
            "pseudo_op2_susp": 0.001984126984126984,
            "pseudo_barinel_susp": 0.0016207455429497568
        }
    },
    {
        "name": "sanic.exceptions.FileNotFound.__init__#183",
        "src_path": "sanic/exceptions.py",
        "class_name": "sanic.exceptions.FileNotFound",
        "signature": "sanic.exceptions.FileNotFound.__init__(self, message, path, relative_url)",
        "snippet": "    def __init__(self, message, path, relative_url):\n        super().__init__(message)\n        self.path = path\n        self.relative_url = relative_url",
        "begin_line": 183,
        "end_line": 186,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.exceptions.ContentRangeError.__init__#213",
        "src_path": "sanic/exceptions.py",
        "class_name": "sanic.exceptions.ContentRangeError",
        "signature": "sanic.exceptions.ContentRangeError.__init__(self, message, content_range)",
        "snippet": "    def __init__(self, message, content_range):\n        super().__init__(message)\n        self.headers = {\n            \"Content-Type\": \"text/plain\",\n            \"Content-Range\": \"bytes */%s\" % (content_range.total,),\n        }",
        "begin_line": 213,
        "end_line": 218,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000449034575662326,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.exceptions.PyFileError.__init__#236",
        "src_path": "sanic/exceptions.py",
        "class_name": "sanic.exceptions.PyFileError",
        "signature": "sanic.exceptions.PyFileError.__init__(self, file)",
        "snippet": "    def __init__(self, file):\n        super().__init__(\"could not execute config file %s\", file)",
        "begin_line": 236,
        "end_line": 237,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.exceptions.Unauthorized.__init__#276",
        "src_path": "sanic/exceptions.py",
        "class_name": "sanic.exceptions.Unauthorized",
        "signature": "sanic.exceptions.Unauthorized.__init__(self, message, status_code=None, scheme=None, **kwargs)",
        "snippet": "    def __init__(self, message, status_code=None, scheme=None, **kwargs):\n        super().__init__(message, status_code)\n\n        # if auth-scheme is specified, set \"WWW-Authenticate\" header\n        if scheme is not None:\n            values = ['{!s}=\"{!s}\"'.format(k, v) for k, v in kwargs.items()]\n            challenge = \", \".join(values)\n\n            self.headers = {\n                \"WWW-Authenticate\": \"{} {}\".format(scheme, challenge).rstrip()\n            }",
        "begin_line": 276,
        "end_line": 286,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.exceptions.abort#289",
        "src_path": "sanic/exceptions.py",
        "class_name": "sanic.exceptions",
        "signature": "sanic.exceptions.abort(status_code, message=None)",
        "snippet": "def abort(status_code, message=None):\n    \"\"\"\n    Raise an exception based on SanicException. Returns the HTTP response\n    message appropriate for the given status code, unless provided.\n\n    :param status_code: The HTTP status code to return.\n    :param message: The HTTP response body. Defaults to the messages\n                    in response.py for the given status code.\n    \"\"\"\n    if message is None:\n        message = STATUS_CODES.get(status_code)\n        # These are stored as bytes in the STATUS_CODES dict\n        message = message.decode(\"utf8\")\n    sanic_exception = _sanic_exceptions.get(status_code, SanicException)\n    raise sanic_exception(message=message, status_code=status_code)",
        "begin_line": 289,
        "end_line": 303,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.server.HttpProtocol.__init__#91",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.__init__(self, *, loop, app, request_handler, error_handler, signal=Signal(), connections=None, request_timeout=60, response_timeout=60, keep_alive_timeout=5, request_max_size=None, request_buffer_queue_size=100, request_class=None, access_log=True, keep_alive=True, is_request_stream=False, router=None, state=None, debug=False, **kwargs)",
        "snippet": "    def __init__(\n        self,\n        *,\n        loop,\n        app,\n        request_handler,\n        error_handler,\n        signal=Signal(),\n        connections=None,\n        request_timeout=60,\n        response_timeout=60,\n        keep_alive_timeout=5,\n        request_max_size=None,\n        request_buffer_queue_size=100,\n        request_class=None,\n        access_log=True,\n        keep_alive=True,\n        is_request_stream=False,\n        router=None,\n        state=None,\n        debug=False,\n        **kwargs\n    ):\n        self.loop = loop\n        self.app = app\n        self.transport = None\n        self.request = None\n        self.parser = None\n        self.url = None\n        self.headers = None\n        self.router = router\n        self.signal = signal\n        self.access_log = access_log\n        self.connections = connections if connections is not None else set()\n        self.request_handler = request_handler\n        self.error_handler = error_handler\n        self.request_timeout = request_timeout\n        self.request_buffer_queue_size = request_buffer_queue_size\n        self.response_timeout = response_timeout\n        self.keep_alive_timeout = keep_alive_timeout\n        self.request_max_size = request_max_size\n        self.request_class = request_class or Request\n        self.is_request_stream = is_request_stream\n        self._is_stream_handler = False\n        self._not_paused = asyncio.Event(loop=loop)\n        self._total_request_size = 0\n        self._request_timeout_handler = None\n        self._response_timeout_handler = None\n        self._keep_alive_timeout_handler = None\n        self._last_request_time = None\n        self._last_response_time = None\n        self._request_handler_task = None\n        self._request_stream_task = None\n        self._keep_alive = keep_alive\n        self._header_fragment = b\"\"\n        self.state = state if state else {}\n        if \"requests_count\" not in self.state:\n            self.state[\"requests_count\"] = 0\n        self._debug = debug\n        self._not_paused.set()",
        "begin_line": 91,
        "end_line": 150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00267379679144385,
            "pseudo_dstar_susp": 0.003875968992248062,
            "pseudo_tarantula_susp": 0.0027247956403269754,
            "pseudo_op2_susp": 0.003875968992248062,
            "pseudo_barinel_susp": 0.0027247956403269754
        }
    },
    {
        "name": "sanic.server.HttpProtocol.keep_alive#153",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.keep_alive(self)",
        "snippet": "    def keep_alive(self):\n        \"\"\"\n        Check if the connection needs to be kept alive based on the params\n        attached to the `_keep_alive` attribute, :attr:`Signal.stopped`\n        and :func:`HttpProtocol.parser.should_keep_alive`\n\n        :return: ``True`` if connection is to be kept alive ``False`` else\n        \"\"\"\n        return (\n            self._keep_alive\n            and not self.signal.stopped\n            and self.parser.should_keep_alive()\n        )",
        "begin_line": 153,
        "end_line": 165,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004329004329004329,
            "pseudo_dstar_susp": 0.008695652173913044,
            "pseudo_tarantula_susp": 0.0045045045045045045,
            "pseudo_op2_susp": 0.008695652173913044,
            "pseudo_barinel_susp": 0.0045045045045045045
        }
    },
    {
        "name": "sanic.server.HttpProtocol.connection_made#171",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.connection_made(self, transport)",
        "snippet": "    def connection_made(self, transport):\n        self.connections.add(self)\n        self._request_timeout_handler = self.loop.call_later(\n            self.request_timeout, self.request_timeout_callback\n        )\n        self.transport = transport\n        self._last_request_time = time()",
        "begin_line": 171,
        "end_line": 177,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00267379679144385,
            "pseudo_dstar_susp": 0.003875968992248062,
            "pseudo_tarantula_susp": 0.0027247956403269754,
            "pseudo_op2_susp": 0.003875968992248062,
            "pseudo_barinel_susp": 0.0027247956403269754
        }
    },
    {
        "name": "sanic.server.HttpProtocol.connection_lost#179",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.connection_lost(self, exc)",
        "snippet": "    def connection_lost(self, exc):\n        self.connections.discard(self)\n        if self._request_handler_task:\n            self._request_handler_task.cancel()\n        if self._request_stream_task:\n            self._request_stream_task.cancel()\n        if self._request_timeout_handler:\n            self._request_timeout_handler.cancel()\n        if self._response_timeout_handler:\n            self._response_timeout_handler.cancel()\n        if self._keep_alive_timeout_handler:\n            self._keep_alive_timeout_handler.cancel()",
        "begin_line": 179,
        "end_line": 190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.5,
            "pseudo_dstar_susp": 0.004629629629629629,
            "pseudo_tarantula_susp": 0.5,
            "pseudo_op2_susp": 0.004629629629629629,
            "pseudo_barinel_susp": 0.5
        }
    },
    {
        "name": "sanic.server.HttpProtocol.request_timeout_callback#198",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.request_timeout_callback(self)",
        "snippet": "    def request_timeout_callback(self):\n        # See the docstring in the RequestTimeout exception, to see\n        # exactly what this timeout is checking for.\n        # Check if elapsed time since request initiated exceeds our\n        # configured maximum request timeout value\n        time_elapsed = time() - self._last_request_time\n        if time_elapsed < self.request_timeout:\n            time_left = self.request_timeout - time_elapsed\n            self._request_timeout_handler = self.loop.call_later(\n                time_left, self.request_timeout_callback\n            )\n        else:\n            if self._request_stream_task:\n                self._request_stream_task.cancel()\n            if self._request_handler_task:\n                self._request_handler_task.cancel()\n            self.write_error(RequestTimeout(\"Request Timeout\"))",
        "begin_line": 198,
        "end_line": 214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.server.HttpProtocol.response_timeout_callback#216",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.response_timeout_callback(self)",
        "snippet": "    def response_timeout_callback(self):\n        # Check if elapsed time since response was initiated exceeds our\n        # configured maximum request timeout value\n        time_elapsed = time() - self._last_request_time\n        if time_elapsed < self.response_timeout:\n            time_left = self.response_timeout - time_elapsed\n            self._response_timeout_handler = self.loop.call_later(\n                time_left, self.response_timeout_callback\n            )\n        else:\n            if self._request_stream_task:\n                self._request_stream_task.cancel()\n            if self._request_handler_task:\n                self._request_handler_task.cancel()\n            self.write_error(ServiceUnavailable(\"Response Timeout\"))",
        "begin_line": 216,
        "end_line": 230,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.server.HttpProtocol.data_received#255",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.data_received(self, data)",
        "snippet": "    def data_received(self, data):\n        # Check for the request itself getting too large and exceeding\n        # memory limits\n        self._total_request_size += len(data)\n        if self._total_request_size > self.request_max_size:\n            self.write_error(PayloadTooLarge(\"Payload Too Large\"))\n\n        # Create parser if this is the first time we're receiving data\n        if self.parser is None:\n            assert self.request is None\n            self.headers = []\n            self.parser = HttpRequestParser(self)\n\n        # requests count\n        self.state[\"requests_count\"] = self.state[\"requests_count\"] + 1\n\n        # Parse request chunk or close connection\n        try:\n            self.parser.feed_data(data)\n        except HttpParserError:\n            message = \"Bad Request\"\n            if self._debug:\n                message += \"\\n\" + traceback.format_exc()\n            self.write_error(InvalidUsage(message))",
        "begin_line": 255,
        "end_line": 278,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003215434083601286,
            "pseudo_dstar_susp": 0.005128205128205128,
            "pseudo_tarantula_susp": 0.0033003300330033004,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0033003300330033004
        }
    },
    {
        "name": "sanic.server.HttpProtocol.on_url#280",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.on_url(self, url)",
        "snippet": "    def on_url(self, url):\n        if not self.url:\n            self.url = url\n        else:\n            self.url += url",
        "begin_line": 280,
        "end_line": 284,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035460992907801418,
            "pseudo_dstar_susp": 0.006024096385542169,
            "pseudo_tarantula_susp": 0.0036496350364963502,
            "pseudo_op2_susp": 0.006024096385542169,
            "pseudo_barinel_susp": 0.0036496350364963502
        }
    },
    {
        "name": "sanic.server.HttpProtocol.on_header#286",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.on_header(self, name, value)",
        "snippet": "    def on_header(self, name, value):\n        self._header_fragment += name\n\n        if value is not None:\n            if (\n                self._header_fragment == b\"Content-Length\"\n                and int(value) > self.request_max_size\n            ):\n                self.write_error(PayloadTooLarge(\"Payload Too Large\"))\n            try:\n                value = value.decode()\n            except UnicodeDecodeError:\n                value = value.decode(\"latin_1\")\n            self.headers.append(\n                (self._header_fragment.decode().casefold(), value)\n            )\n\n            self._header_fragment = b\"\"",
        "begin_line": 286,
        "end_line": 303,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035460992907801418,
            "pseudo_dstar_susp": 0.006024096385542169,
            "pseudo_tarantula_susp": 0.0036496350364963502,
            "pseudo_op2_susp": 0.006024096385542169,
            "pseudo_barinel_susp": 0.0036496350364963502
        }
    },
    {
        "name": "sanic.server.HttpProtocol.on_headers_complete#305",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.on_headers_complete(self)",
        "snippet": "    def on_headers_complete(self):\n        self.request = self.request_class(\n            url_bytes=self.url,\n            headers=Header(self.headers),\n            version=self.parser.get_http_version(),\n            method=self.parser.get_method().decode(),\n            transport=self.transport,\n            app=self.app,\n        )\n        # Remove any existing KeepAlive handler here,\n        # It will be recreated if required on the new request.\n        if self._keep_alive_timeout_handler:\n            self._keep_alive_timeout_handler.cancel()\n            self._keep_alive_timeout_handler = None\n\n        if self.request.headers.get(EXPECT_HEADER):\n            self.expect_handler()\n\n        if self.is_request_stream:\n            self._is_stream_handler = self.router.is_stream_handler(\n                self.request\n            )\n            if self._is_stream_handler:\n                self.request.stream = StreamBuffer(\n                    self.request_buffer_queue_size\n                )\n                self.execute_request_handler()",
        "begin_line": 305,
        "end_line": 331,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.14285714285714285,
            "pseudo_dstar_susp": 0.006024096385542169,
            "pseudo_tarantula_susp": 0.14285714285714285,
            "pseudo_op2_susp": 0.006024096385542169,
            "pseudo_barinel_susp": 0.14285714285714285
        }
    },
    {
        "name": "sanic.server.HttpProtocol.expect_handler#333",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.expect_handler(self)",
        "snippet": "    def expect_handler(self):\n        \"\"\"\n        Handler for Expect Header.\n        \"\"\"\n        expect = self.request.headers.get(EXPECT_HEADER)\n        if self.request.version == \"1.1\":\n            if expect.lower() == \"100-continue\":\n                self.transport.write(b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")\n            else:\n                self.write_error(\n                    HeaderExpectationFailed(\n                        \"Unknown Expect: {expect}\".format(expect=expect)\n                    )\n                )",
        "begin_line": 333,
        "end_line": 346,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.5,
            "pseudo_dstar_susp": 0.0014992503748125937,
            "pseudo_tarantula_susp": 0.5,
            "pseudo_op2_susp": 0.0014992503748125937,
            "pseudo_barinel_susp": 0.5
        }
    },
    {
        "name": "sanic.server.HttpProtocol.on_body#348",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.on_body(self, body)",
        "snippet": "    def on_body(self, body):\n        if self.is_request_stream and self._is_stream_handler:\n            self._request_stream_task = self.loop.create_task(\n                self.body_append(body)\n            )\n        else:\n            self.request.body_push(body)",
        "begin_line": 348,
        "end_line": 354,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.030303030303030304,
            "pseudo_dstar_susp": 0.0014326647564469914,
            "pseudo_tarantula_susp": 0.030303030303030304,
            "pseudo_op2_susp": 0.0014326647564469914,
            "pseudo_barinel_susp": 0.030303030303030304
        }
    },
    {
        "name": "sanic.server.HttpProtocol.body_append#356",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.body_append(self, body)",
        "snippet": "    async def body_append(self, body):\n        if self.request.stream.is_full():\n            self.transport.pause_reading()\n            await self.request.stream.put(body)\n            self.transport.resume_reading()\n        else:\n            await self.request.stream.put(body)",
        "begin_line": 356,
        "end_line": 362,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.030303030303030304,
            "pseudo_dstar_susp": 0.0014326647564469914,
            "pseudo_tarantula_susp": 0.030303030303030304,
            "pseudo_op2_susp": 0.0014326647564469914,
            "pseudo_barinel_susp": 0.030303030303030304
        }
    },
    {
        "name": "sanic.server.HttpProtocol.on_message_complete#364",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.on_message_complete(self)",
        "snippet": "    def on_message_complete(self):\n        # Entire request (headers and whole body) is received.\n        # We can cancel and remove the request timeout handler now.\n        if self._request_timeout_handler:\n            self._request_timeout_handler.cancel()\n            self._request_timeout_handler = None\n        if self.is_request_stream and self._is_stream_handler:\n            self._request_stream_task = self.loop.create_task(\n                self.request.stream.put(None)\n            )\n            return\n        self.request.body_finish()\n        self.execute_request_handler()",
        "begin_line": 364,
        "end_line": 376,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012224938875305623,
            "pseudo_dstar_susp": 0.0012224938875305623,
            "pseudo_tarantula_susp": 0.0012224938875305623,
            "pseudo_op2_susp": 0.0012224938875305623,
            "pseudo_barinel_susp": 0.0012224938875305623
        }
    },
    {
        "name": "sanic.server.HttpProtocol.execute_request_handler#378",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.execute_request_handler(self)",
        "snippet": "    def execute_request_handler(self):\n        \"\"\"\n        Invoke the request handler defined by the\n        :func:`sanic.app.Sanic.handle_request` method\n\n        :return: None\n        \"\"\"\n        self._response_timeout_handler = self.loop.call_later(\n            self.response_timeout, self.response_timeout_callback\n        )\n        self._last_request_time = time()\n        self._request_handler_task = self.loop.create_task(\n            self.request_handler(\n                self.request, self.write_response, self.stream_response\n            )\n        )",
        "begin_line": 378,
        "end_line": 393,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035460992907801418,
            "pseudo_dstar_susp": 0.006024096385542169,
            "pseudo_tarantula_susp": 0.0036496350364963502,
            "pseudo_op2_susp": 0.006024096385542169,
            "pseudo_barinel_susp": 0.0036496350364963502
        }
    },
    {
        "name": "sanic.server.HttpProtocol.log_response#398",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.log_response(self, response)",
        "snippet": "    def log_response(self, response):\n        \"\"\"\n        Helper method provided to enable the logging of responses in case if\n        the :attr:`HttpProtocol.access_log` is enabled.\n\n        :param response: Response generated for the current request\n\n        :type response: :class:`sanic.response.HTTPResponse` or\n            :class:`sanic.response.StreamingHTTPResponse`\n\n        :return: None\n        \"\"\"\n        if self.access_log:\n            extra = {\"status\": getattr(response, \"status\", 0)}\n\n            if isinstance(response, HTTPResponse):\n                extra[\"byte\"] = len(response.body)\n            else:\n                extra[\"byte\"] = -1\n\n            extra[\"host\"] = \"UNKNOWN\"\n            if self.request is not None:\n                if self.request.ip:\n                    extra[\"host\"] = \"{0}:{1}\".format(\n                        self.request.ip, self.request.port\n                    )\n\n                extra[\"request\"] = \"{0} {1}\".format(\n                    self.request.method, self.request.url\n                )\n            else:\n                extra[\"request\"] = \"nil\"\n\n            access_logger.info(\"\", extra=extra)",
        "begin_line": 398,
        "end_line": 431,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006024096385542169,
            "pseudo_dstar_susp": 0.02,
            "pseudo_tarantula_susp": 0.006369426751592357,
            "pseudo_op2_susp": 0.02,
            "pseudo_barinel_susp": 0.006369426751592357
        }
    },
    {
        "name": "sanic.server.HttpProtocol.write_response#433",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.write_response(self, response)",
        "snippet": "    def write_response(self, response):\n        \"\"\"\n        Writes response content synchronously to the transport.\n        \"\"\"\n        if self._response_timeout_handler:\n            self._response_timeout_handler.cancel()\n            self._response_timeout_handler = None\n        try:\n            keep_alive = self.keep_alive\n            self.transport.write(\n                response.output(\n                    self.request.version, keep_alive, self.keep_alive_timeout\n                )\n            )\n            self.log_response(response)\n        except AttributeError:\n            logger.error(\n                \"Invalid response object for url %s, \"\n                \"Expected Type: HTTPResponse, Actual Type: %s\",\n                self.url,\n                type(response),\n            )\n            self.write_error(ServerError(\"Invalid response type\"))\n        except RuntimeError:\n            if self._debug:\n                logger.error(\n                    \"Connection lost before response written @ %s\",\n                    self.request.ip,\n                )\n            keep_alive = False\n        except Exception as e:\n            self.bail_out(\n                \"Writing response failed, connection closed {}\".format(repr(e))\n            )\n        finally:\n            if not keep_alive:\n                self.transport.close()\n                self.transport = None\n            else:\n                self._keep_alive_timeout_handler = self.loop.call_later(\n                    self.keep_alive_timeout, self.keep_alive_timeout_callback\n                )\n                self._last_response_time = time()\n                self.cleanup()",
        "begin_line": 433,
        "end_line": 476,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012690355329949238,
            "pseudo_dstar_susp": 0.0012690355329949238,
            "pseudo_tarantula_susp": 0.0012690355329949238,
            "pseudo_op2_susp": 0.0012690355329949238,
            "pseudo_barinel_susp": 0.0012690355329949238
        }
    },
    {
        "name": "sanic.server.HttpProtocol.drain#478",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.drain(self)",
        "snippet": "    async def drain(self):\n        await self._not_paused.wait()",
        "begin_line": 478,
        "end_line": 479,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004149377593360996,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.server.HttpProtocol.push_data#481",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.push_data(self, data)",
        "snippet": "    async def push_data(self, data):\n        self.transport.write(data)",
        "begin_line": 481,
        "end_line": 482,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004149377593360996,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.server.HttpProtocol.stream_response#484",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.stream_response(self, response)",
        "snippet": "    async def stream_response(self, response):\n        \"\"\"\n        Streams a response to the client asynchronously. Attaches\n        the transport to the response so the response consumer can\n        write to the response as needed.\n        \"\"\"\n        if self._response_timeout_handler:\n            self._response_timeout_handler.cancel()\n            self._response_timeout_handler = None\n\n        try:\n            keep_alive = self.keep_alive\n            response.protocol = self\n            await response.stream(\n                self.request.version, keep_alive, self.keep_alive_timeout\n            )\n            self.log_response(response)\n        except AttributeError:\n            logger.error(\n                \"Invalid response object for url %s, \"\n                \"Expected Type: HTTPResponse, Actual Type: %s\",\n                self.url,\n                type(response),\n            )\n            self.write_error(ServerError(\"Invalid response type\"))\n        except RuntimeError:\n            if self._debug:\n                logger.error(\n                    \"Connection lost before response written @ %s\",\n                    self.request.ip,\n                )\n            keep_alive = False\n        except Exception as e:\n            self.bail_out(\n                \"Writing response failed, connection closed {}\".format(repr(e))\n            )\n        finally:\n            if not keep_alive:\n                self.transport.close()\n                self.transport = None\n            else:\n                self._keep_alive_timeout_handler = self.loop.call_later(\n                    self.keep_alive_timeout, self.keep_alive_timeout_callback\n                )\n                self._last_response_time = time()\n                self.cleanup()",
        "begin_line": 484,
        "end_line": 529,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004149377593360996,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.server.HttpProtocol.write_error#531",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.write_error(self, exception)",
        "snippet": "    def write_error(self, exception):\n        # An error _is_ a response.\n        # Don't throw a response timeout, when a response _is_ given.\n        if self._response_timeout_handler:\n            self._response_timeout_handler.cancel()\n            self._response_timeout_handler = None\n        response = None\n        try:\n            response = self.error_handler.response(self.request, exception)\n            version = self.request.version if self.request else \"1.1\"\n            self.transport.write(response.output(version))\n        except RuntimeError:\n            if self._debug:\n                logger.error(\n                    \"Connection lost before error written @ %s\",\n                    self.request.ip if self.request else \"Unknown\",\n                )\n        except Exception as e:\n            self.bail_out(\n                \"Writing error failed, connection closed {}\".format(repr(e)),\n                from_error=True,\n            )\n        finally:\n            if self.parser and (\n                self.keep_alive or getattr(response, \"status\", 0) == 408\n            ):\n                self.log_response(response)\n            try:\n                self.transport.close()\n            except AttributeError:\n                logger.debug(\"Connection lost before server could close it.\")",
        "begin_line": 531,
        "end_line": 561,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.030303030303030304,
            "pseudo_dstar_susp": 0.0014326647564469914,
            "pseudo_tarantula_susp": 0.030303030303030304,
            "pseudo_op2_susp": 0.0014326647564469914,
            "pseudo_barinel_susp": 0.030303030303030304
        }
    },
    {
        "name": "sanic.server.HttpProtocol.cleanup#593",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.HttpProtocol",
        "signature": "sanic.server.HttpProtocol.cleanup(self)",
        "snippet": "    def cleanup(self):\n        \"\"\"This is called when KeepAlive feature is used,\n        it resets the connection in order for it to be able\n        to handle receiving another request on the same connection.\"\"\"\n        self.parser = None\n        self.request = None\n        self.url = None\n        self.headers = None\n        self._request_handler_task = None\n        self._request_stream_task = None\n        self._total_request_size = 0\n        self._is_stream_handler = False",
        "begin_line": 593,
        "end_line": 604,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012345679012345679,
            "pseudo_dstar_susp": 0.0012345679012345679,
            "pseudo_tarantula_susp": 0.0012345679012345679,
            "pseudo_op2_susp": 0.0012345679012345679,
            "pseudo_barinel_susp": 0.0012345679012345679
        }
    },
    {
        "name": "sanic.server.trigger_events#625",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server",
        "signature": "sanic.server.trigger_events(events, loop)",
        "snippet": "def trigger_events(events, loop):\n    \"\"\"Trigger event callbacks (functions or async)\n\n    :param events: one or more sync or async functions to execute\n    :param loop: event loop\n    \"\"\"\n    for event in events:\n        result = event(loop)\n        if isawaitable(result):\n            loop.run_until_complete(result)",
        "begin_line": 625,
        "end_line": 634,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002036659877800407,
            "pseudo_dstar_susp": 0.0026666666666666666,
            "pseudo_tarantula_susp": 0.002061855670103093,
            "pseudo_op2_susp": 0.0026666666666666666,
            "pseudo_barinel_susp": 0.002061855670103093
        }
    },
    {
        "name": "sanic.server.AsyncioServer.__init__#653",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.AsyncioServer",
        "signature": "sanic.server.AsyncioServer.__init__(self, loop, serve_coro, connections, after_start, before_stop, after_stop)",
        "snippet": "    def __init__(\n        self,\n        loop,\n        serve_coro,\n        connections,\n        after_start,\n        before_stop,\n        after_stop,\n    ):\n        # Note, Sanic already called \"before_server_start\" events\n        # before this helper was even created. So we don't need it here.\n        self.loop = loop\n        self.serve_coro = serve_coro\n        self._after_start = after_start\n        self._before_stop = before_stop\n        self._after_stop = after_stop\n        self.server = None\n        self.connections = connections",
        "begin_line": 653,
        "end_line": 670,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00046728971962616824,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.server.AsyncioServer.after_start#672",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.AsyncioServer",
        "signature": "sanic.server.AsyncioServer.after_start(self)",
        "snippet": "    def after_start(self):\n        \"\"\"Trigger \"after_server_start\" events\"\"\"\n        trigger_events(self._after_start, self.loop)",
        "begin_line": 672,
        "end_line": 674,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.server.AsyncioServer.before_stop#676",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.AsyncioServer",
        "signature": "sanic.server.AsyncioServer.before_stop(self)",
        "snippet": "    def before_stop(self):\n        \"\"\"Trigger \"before_server_stop\" events\"\"\"\n        trigger_events(self._before_stop, self.loop)",
        "begin_line": 676,
        "end_line": 678,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.server.AsyncioServer.after_stop#680",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.AsyncioServer",
        "signature": "sanic.server.AsyncioServer.after_stop(self)",
        "snippet": "    def after_stop(self):\n        \"\"\"Trigger \"after_server_stop\" events\"\"\"\n        trigger_events(self._after_stop, self.loop)",
        "begin_line": 680,
        "end_line": 682,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.server.AsyncioServer.wait_closed#689",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.AsyncioServer",
        "signature": "sanic.server.AsyncioServer.wait_closed(self)",
        "snippet": "    def wait_closed(self):\n        if self.server:\n            return self.server.wait_closed()",
        "begin_line": 689,
        "end_line": 691,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004997501249375312,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.server.AsyncioServer.close#693",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.AsyncioServer",
        "signature": "sanic.server.AsyncioServer.close(self)",
        "snippet": "    def close(self):\n        if self.server:\n            self.server.close()\n            coro = self.wait_closed()\n            task = asyncio.ensure_future(coro, loop=self.loop)\n            return task",
        "begin_line": 693,
        "end_line": 698,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004997501249375312,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.server.AsyncioServer.__await__#700",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server.AsyncioServer",
        "signature": "sanic.server.AsyncioServer.__await__(self)",
        "snippet": "    def __await__(self):\n        \"\"\"Starts the asyncio server, returns AsyncServerCoro\"\"\"\n        task = asyncio.ensure_future(self.serve_coro)\n        while not task.done():\n            yield\n        self.server = task.result()\n        return self",
        "begin_line": 700,
        "end_line": 706,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00046728971962616824,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.server.serve#709",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server",
        "signature": "sanic.server.serve(host, port, app, request_handler, error_handler, before_start=None, after_start=None, before_stop=None, after_stop=None, debug=False, request_timeout=60, response_timeout=60, keep_alive_timeout=5, ssl=None, sock=None, request_max_size=None, request_buffer_queue_size=100, reuse_port=False, loop=None, protocol=HttpProtocol, backlog=100, register_sys_signals=True, run_multiple=False, run_async=False, connections=None, signal=Signal(), request_class=None, access_log=True, keep_alive=True, is_request_stream=False, router=None, websocket_max_size=None, websocket_max_queue=None, websocket_read_limit=2 ** 16, websocket_write_limit=2 ** 16, state=None, graceful_shutdown_timeout=15.0, asyncio_server_kwargs=None)",
        "snippet": "def serve(\n    host,\n    port,\n    app,\n    request_handler,\n    error_handler,\n    before_start=None,\n    after_start=None,\n    before_stop=None,\n    after_stop=None,\n    debug=False,\n    request_timeout=60,\n    response_timeout=60,\n    keep_alive_timeout=5,\n    ssl=None,\n    sock=None,\n    request_max_size=None,\n    request_buffer_queue_size=100,\n    reuse_port=False,\n    loop=None,\n    protocol=HttpProtocol,\n    backlog=100,\n    register_sys_signals=True,\n    run_multiple=False,\n    run_async=False,\n    connections=None,\n    signal=Signal(),\n    request_class=None,\n    access_log=True,\n    keep_alive=True,\n    is_request_stream=False,\n    router=None,\n    websocket_max_size=None,\n    websocket_max_queue=None,\n    websocket_read_limit=2 ** 16,\n    websocket_write_limit=2 ** 16,\n    state=None,\n    graceful_shutdown_timeout=15.0,\n    asyncio_server_kwargs=None,\n):\n    \"\"\"Start asynchronous HTTP Server on an individual process.\n\n    :param host: Address to host on\n    :param port: Port to host on\n    :param request_handler: Sanic request handler with middleware\n    :param error_handler: Sanic error handler with middleware\n    :param before_start: function to be executed before the server starts\n                         listening. Takes arguments `app` instance and `loop`\n    :param after_start: function to be executed after the server starts\n                        listening. Takes  arguments `app` instance and `loop`\n    :param before_stop: function to be executed when a stop signal is\n                        received before it is respected. Takes arguments\n                        `app` instance and `loop`\n    :param after_stop: function to be executed when a stop signal is\n                       received after it is respected. Takes arguments\n                       `app` instance and `loop`\n    :param debug: enables debug output (slows server)\n    :param request_timeout: time in seconds\n    :param response_timeout: time in seconds\n    :param keep_alive_timeout: time in seconds\n    :param ssl: SSLContext\n    :param sock: Socket for the server to accept connections from\n    :param request_max_size: size in bytes, `None` for no limit\n    :param reuse_port: `True` for multiple workers\n    :param loop: asyncio compatible event loop\n    :param protocol: subclass of asyncio protocol class\n    :param run_async: bool: Do not create a new event loop for the server,\n                      and return an AsyncServer object rather than running it\n    :param request_class: Request class to use\n    :param access_log: disable/enable access log\n    :param websocket_max_size: enforces the maximum size for\n                               incoming messages in bytes.\n    :param websocket_max_queue: sets the maximum length of the queue\n                                that holds incoming messages.\n    :param websocket_read_limit: sets the high-water limit of the buffer for\n                                 incoming bytes, the low-water limit is half\n                                 the high-water limit.\n    :param websocket_write_limit: sets the high-water limit of the buffer for\n                                  outgoing bytes, the low-water limit is a\n                                  quarter of the high-water limit.\n    :param is_request_stream: disable/enable Request.stream\n    :param request_buffer_queue_size: streaming request buffer queue size\n    :param router: Router object\n    :param graceful_shutdown_timeout: How long take to Force close non-idle\n                                      connection\n    :param asyncio_server_kwargs: key-value args for asyncio/uvloop\n                                  create_server method\n    :return: Nothing\n    \"\"\"\n    if not run_async:\n        # create new event_loop after fork\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n\n    if debug:\n        loop.set_debug(debug)\n\n    app.asgi = False\n\n    connections = connections if connections is not None else set()\n    server = partial(\n        protocol,\n        loop=loop,\n        connections=connections,\n        signal=signal,\n        app=app,\n        request_handler=request_handler,\n        error_handler=error_handler,\n        request_timeout=request_timeout,\n        response_timeout=response_timeout,\n        keep_alive_timeout=keep_alive_timeout,\n        request_max_size=request_max_size,\n        request_class=request_class,\n        access_log=access_log,\n        keep_alive=keep_alive,\n        is_request_stream=is_request_stream,\n        router=router,\n        websocket_max_size=websocket_max_size,\n        websocket_max_queue=websocket_max_queue,\n        websocket_read_limit=websocket_read_limit,\n        websocket_write_limit=websocket_write_limit,\n        state=state,\n        debug=debug,\n    )\n    asyncio_server_kwargs = (\n        asyncio_server_kwargs if asyncio_server_kwargs else {}\n    )\n    server_coroutine = loop.create_server(\n        server,\n        host,\n        port,\n        ssl=ssl,\n        reuse_port=reuse_port,\n        sock=sock,\n        backlog=backlog,\n        **asyncio_server_kwargs\n    )\n\n    if run_async:\n        return AsyncioServer(\n            loop,\n            server_coroutine,\n            connections,\n            after_start,\n            before_stop,\n            after_stop,\n        )\n\n    trigger_events(before_start, loop)\n\n    try:\n        http_server = loop.run_until_complete(server_coroutine)\n    except BaseException:\n        logger.exception(\"Unable to start server\")\n        return\n\n    trigger_events(after_start, loop)\n\n    # Ignore SIGINT when run_multiple\n    if run_multiple:\n        signal_func(SIGINT, SIG_IGN)\n\n    # Register signals for graceful termination\n    if register_sys_signals:\n        _singals = (SIGTERM,) if run_multiple else (SIGINT, SIGTERM)\n        for _signal in _singals:\n            try:\n                loop.add_signal_handler(_signal, loop.stop)\n            except NotImplementedError:\n                logger.warning(\n                    \"Sanic tried to use loop.add_signal_handler \"\n                    \"but it is not implemented on this platform.\"\n                )\n    pid = os.getpid()\n    try:\n        logger.info(\"Starting worker [%s]\", pid)\n        loop.run_forever()\n    finally:\n        logger.info(\"Stopping worker [%s]\", pid)\n\n        # Run the on_stop function if provided\n        trigger_events(before_stop, loop)\n\n        # Wait for event loop to finish and all connections to drain\n        http_server.close()\n        loop.run_until_complete(http_server.wait_closed())\n\n        # Complete all tasks on the loop\n        signal.stopped = True\n        for connection in connections:\n            connection.close_if_idle()\n\n        # Gracefully shutdown timeout.\n        # We should provide graceful_shutdown_timeout,\n        # instead of letting connection hangs forever.\n        # Let's roughly calcucate time.\n        start_shutdown = 0\n        while connections and (start_shutdown < graceful_shutdown_timeout):\n            loop.run_until_complete(asyncio.sleep(0.1))\n            start_shutdown = start_shutdown + 0.1\n\n        # Force close non-idle connection after waiting for\n        # graceful_shutdown_timeout\n        coros = []\n        for conn in connections:\n            if hasattr(conn, \"websocket\") and conn.websocket:\n                coros.append(conn.websocket.close_connection())\n            else:\n                conn.close()\n\n        _shutdown = asyncio.gather(*coros, loop=loop)\n        loop.run_until_complete(_shutdown)\n\n        trigger_events(after_stop, loop)\n\n        loop.close()",
        "begin_line": 709,
        "end_line": 924,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002331002331002331,
            "pseudo_dstar_susp": 0.003194888178913738,
            "pseudo_tarantula_susp": 0.002364066193853428,
            "pseudo_op2_susp": 0.003194888178913738,
            "pseudo_barinel_susp": 0.002364066193853428
        }
    },
    {
        "name": "sanic.server.serve_multiple#927",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server",
        "signature": "sanic.server.serve_multiple(server_settings, workers)",
        "snippet": "def serve_multiple(server_settings, workers):\n    \"\"\"Start multiple server processes simultaneously.  Stop on interrupt\n    and terminate signals, and drain connections when complete.\n\n    :param server_settings: kw arguments to be passed to the serve function\n    :param workers: number of workers to launch\n    :param stop_event: if provided, is used as a stop signal\n    :return:\n    \"\"\"\n    server_settings[\"reuse_port\"] = True\n    server_settings[\"run_multiple\"] = True\n\n    # Handling when custom socket is not provided.\n    if server_settings.get(\"sock\") is None:\n        sock = socket()\n        sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)\n        sock.bind((server_settings[\"host\"], server_settings[\"port\"]))\n        sock.set_inheritable(True)\n        server_settings[\"sock\"] = sock\n        server_settings[\"host\"] = None\n        server_settings[\"port\"] = None\n\n    processes = []\n\n    def sig_handler(signal, frame):\n        logger.info(\"Received signal %s. Shutting down.\", Signals(signal).name)\n        for process in processes:\n            os.kill(process.pid, SIGTERM)\n\n    signal_func(SIGINT, lambda s, f: sig_handler(s, f))\n    signal_func(SIGTERM, lambda s, f: sig_handler(s, f))\n\n    for _ in range(workers):\n        process = Process(target=serve, kwargs=server_settings)\n        process.daemon = True\n        process.start()\n        processes.append(process)\n\n    for process in processes:\n        process.join()\n\n    # the above processes will block this until they're stopped\n    for process in processes:\n        process.terminate()\n    server_settings.get(\"sock\").close()",
        "begin_line": 927,
        "end_line": 971,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.server.sig_handler#951",
        "src_path": "sanic/server.py",
        "class_name": "sanic.server",
        "signature": "sanic.server.sig_handler(signal, frame)",
        "snippet": "    def sig_handler(signal, frame):\n        logger.info(\"Received signal %s. Shutting down.\", Signals(signal).name)\n        for process in processes:\n            os.kill(process.pid, SIGTERM)",
        "begin_line": 951,
        "end_line": 954,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.static.register#19",
        "src_path": "sanic/static.py",
        "class_name": "sanic.static",
        "signature": "sanic.static.register(app, uri, file_or_directory, pattern, use_modified_since, use_content_range, stream_large_files, name='static', host=None, strict_slashes=None, content_type=None)",
        "snippet": "def register(\n    app,\n    uri,\n    file_or_directory,\n    pattern,\n    use_modified_since,\n    use_content_range,\n    stream_large_files,\n    name=\"static\",\n    host=None,\n    strict_slashes=None,\n    content_type=None,\n):\n    # TODO: Though sanic is not a file server, I feel like we should at least\n    #       make a good effort here.  Modified-since is nice, but we could\n    #       also look into etags, expires, and caching\n    \"\"\"\n    Register a static directory handler with Sanic by adding a route to the\n    router and registering a handler.\n\n    :param app: Sanic\n    :param file_or_directory: File or directory path to serve from\n    :param uri: URL to serve from\n    :param pattern: regular expression used to match files in the URL\n    :param use_modified_since: If true, send file modified time, and return\n                               not modified if the browser's matches the\n                               server's\n    :param use_content_range: If true, process header for range requests\n                              and sends the file part that is requested\n    :param stream_large_files: If true, use the file_stream() handler rather\n                              than the file() handler to send the file\n                              If this is an integer, this represents the\n                              threshold size to switch to file_stream()\n    :param name: user defined name used for url_for\n    :param content_type: user defined content type for header\n    \"\"\"\n    # If we're not trying to match a file directly,\n    # serve from the folder\n    if not path.isfile(file_or_directory):\n        uri += \"<file_uri:\" + pattern + \">\"\n\n    async def _handler(request, file_uri=None):\n        # Using this to determine if the URL is trying to break out of the path\n        # served.  os.path.realpath seems to be very slow\n        if file_uri and \"../\" in file_uri:\n            raise InvalidUsage(\"Invalid URL\")\n        # Merge served directory and requested file if provided\n        # Strip all / that in the beginning of the URL to help prevent python\n        # from herping a derp and treating the uri as an absolute path\n        root_path = file_path = file_or_directory\n        if file_uri:\n            file_path = path.join(\n                file_or_directory, sub(\"^[/]*\", \"\", file_uri)\n            )\n\n        # URL decode the path sent by the browser otherwise we won't be able to\n        # match filenames which got encoded (filenames with spaces etc)\n        file_path = path.abspath(unquote(file_path))\n        if not file_path.startswith(path.abspath(unquote(root_path))):\n            raise FileNotFound(\n                \"File not found\", path=file_or_directory, relative_url=file_uri\n            )\n        try:\n            headers = {}\n            # Check if the client has been sent this file before\n            # and it has not been modified since\n            stats = None\n            if use_modified_since:\n                stats = await stat(file_path)\n                modified_since = strftime(\n                    \"%a, %d %b %Y %H:%M:%S GMT\", gmtime(stats.st_mtime)\n                )\n                if request.headers.get(\"If-Modified-Since\") == modified_since:\n                    return HTTPResponse(status=304)\n                headers[\"Last-Modified\"] = modified_since\n            _range = None\n            if use_content_range:\n                _range = None\n                if not stats:\n                    stats = await stat(file_path)\n                headers[\"Accept-Ranges\"] = \"bytes\"\n                headers[\"Content-Length\"] = str(stats.st_size)\n                if request.method != \"HEAD\":\n                    try:\n                        _range = ContentRangeHandler(request, stats)\n                    except HeaderNotFound:\n                        pass\n                    else:\n                        del headers[\"Content-Length\"]\n                        for key, value in _range.headers.items():\n                            headers[key] = value\n            headers[\"Content-Type\"] = (\n                content_type or guess_type(file_path)[0] or \"text/plain\"\n            )\n            if request.method == \"HEAD\":\n                return HTTPResponse(headers=headers)\n            else:\n                if stream_large_files:\n                    if type(stream_large_files) == int:\n                        threshold = stream_large_files\n                    else:\n                        threshold = 1024 * 1024\n\n                    if not stats:\n                        stats = await stat(file_path)\n                    if stats.st_size >= threshold:\n                        return await file_stream(\n                            file_path, headers=headers, _range=_range\n                        )\n                return await file(file_path, headers=headers, _range=_range)\n        except ContentRangeError:\n            raise\n        except Exception:\n            raise FileNotFound(\n                \"File not found\", path=file_or_directory, relative_url=file_uri\n            )\n\n    # special prefix for static files\n    if not name.startswith(\"_static_\"):\n        name = \"_static_{}\".format(name)\n\n    app.route(\n        uri,\n        methods=[\"GET\", \"HEAD\"],\n        name=name,\n        host=host,\n        strict_slashes=strict_slashes,\n    )(_handler)",
        "begin_line": 19,
        "end_line": 146,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00041911148365465214,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.static._handler#60",
        "src_path": "sanic/static.py",
        "class_name": "sanic.static",
        "signature": "sanic.static._handler(request, file_uri=None)",
        "snippet": "    async def _handler(request, file_uri=None):\n        # Using this to determine if the URL is trying to break out of the path\n        # served.  os.path.realpath seems to be very slow\n        if file_uri and \"../\" in file_uri:\n            raise InvalidUsage(\"Invalid URL\")\n        # Merge served directory and requested file if provided\n        # Strip all / that in the beginning of the URL to help prevent python\n        # from herping a derp and treating the uri as an absolute path\n        root_path = file_path = file_or_directory\n        if file_uri:\n            file_path = path.join(\n                file_or_directory, sub(\"^[/]*\", \"\", file_uri)\n            )\n\n        # URL decode the path sent by the browser otherwise we won't be able to\n        # match filenames which got encoded (filenames with spaces etc)\n        file_path = path.abspath(unquote(file_path))\n        if not file_path.startswith(path.abspath(unquote(root_path))):\n            raise FileNotFound(\n                \"File not found\", path=file_or_directory, relative_url=file_uri\n            )\n        try:\n            headers = {}\n            # Check if the client has been sent this file before\n            # and it has not been modified since\n            stats = None\n            if use_modified_since:\n                stats = await stat(file_path)\n                modified_since = strftime(\n                    \"%a, %d %b %Y %H:%M:%S GMT\", gmtime(stats.st_mtime)\n                )\n                if request.headers.get(\"If-Modified-Since\") == modified_since:\n                    return HTTPResponse(status=304)\n                headers[\"Last-Modified\"] = modified_since\n            _range = None\n            if use_content_range:\n                _range = None\n                if not stats:\n                    stats = await stat(file_path)\n                headers[\"Accept-Ranges\"] = \"bytes\"\n                headers[\"Content-Length\"] = str(stats.st_size)\n                if request.method != \"HEAD\":\n                    try:\n                        _range = ContentRangeHandler(request, stats)\n                    except HeaderNotFound:\n                        pass\n                    else:\n                        del headers[\"Content-Length\"]\n                        for key, value in _range.headers.items():\n                            headers[key] = value\n            headers[\"Content-Type\"] = (\n                content_type or guess_type(file_path)[0] or \"text/plain\"\n            )\n            if request.method == \"HEAD\":\n                return HTTPResponse(headers=headers)\n            else:\n                if stream_large_files:\n                    if type(stream_large_files) == int:\n                        threshold = stream_large_files\n                    else:\n                        threshold = 1024 * 1024\n\n                    if not stats:\n                        stats = await stat(file_path)\n                    if stats.st_size >= threshold:\n                        return await file_stream(\n                            file_path, headers=headers, _range=_range\n                        )\n                return await file(file_path, headers=headers, _range=_range)\n        except ContentRangeError:\n            raise\n        except Exception:\n            raise FileNotFound(\n                \"File not found\", path=file_or_directory, relative_url=file_uri\n            )",
        "begin_line": 60,
        "end_line": 134,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.testing.SanicTestClient.__init__#25",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicTestClient",
        "signature": "sanic.testing.SanicTestClient.__init__(self, app, port=PORT)",
        "snippet": "    def __init__(self, app, port=PORT):\n        \"\"\"Use port=None to bind to a random port\"\"\"\n        self.app = app\n        self.port = port",
        "begin_line": 25,
        "end_line": 28,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024096385542168677,
            "pseudo_dstar_susp": 0.0033444816053511705,
            "pseudo_tarantula_susp": 0.0024449877750611247,
            "pseudo_op2_susp": 0.0033444816053511705,
            "pseudo_barinel_susp": 0.0024449877750611247
        }
    },
    {
        "name": "sanic.testing.SanicTestClient.get_new_session#30",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicTestClient",
        "signature": "sanic.testing.SanicTestClient.get_new_session(self)",
        "snippet": "    def get_new_session(self):\n        return requests.Session()",
        "begin_line": 30,
        "end_line": 31,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004807692307692308,
            "pseudo_dstar_susp": 0.010869565217391304,
            "pseudo_tarantula_susp": 0.005025125628140704,
            "pseudo_op2_susp": 0.010869565217391304,
            "pseudo_barinel_susp": 0.005025125628140704
        }
    },
    {
        "name": "sanic.testing.SanicTestClient._local_request#33",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicTestClient",
        "signature": "sanic.testing.SanicTestClient._local_request(self, method, url, *args, **kwargs)",
        "snippet": "    async def _local_request(self, method, url, *args, **kwargs):\n        logger.info(url)\n        raw_cookies = kwargs.pop(\"raw_cookies\", None)\n\n        if method == \"websocket\":\n            async with websockets.connect(url, *args, **kwargs) as websocket:\n                websocket.opened = websocket.open\n                return websocket\n        else:\n            async with self.get_new_session() as session:\n\n                try:\n                    response = await getattr(session, method.lower())(\n                        url, verify=False, *args, **kwargs\n                    )\n                except NameError:\n                    raise Exception(response.status_code)\n\n                try:\n                    response.json = response.json()\n                except (JSONDecodeError, UnicodeDecodeError):\n                    response.json = None\n\n                response.body = await response.read()\n                response.status = response.status_code\n                response.content_type = response.headers.get(\"content-type\")\n\n                if raw_cookies:\n                    response.raw_cookies = {}\n                    for cookie in response.cookies:\n                        response.raw_cookies[cookie.name] = cookie\n\n                return response",
        "begin_line": 33,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005235602094240838,
            "pseudo_dstar_susp": 0.013333333333333334,
            "pseudo_tarantula_susp": 0.005494505494505495,
            "pseudo_op2_susp": 0.013333333333333334,
            "pseudo_barinel_susp": 0.005494505494505495
        }
    },
    {
        "name": "sanic.testing.SanicTestClient._sanic_endpoint_test#67",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicTestClient",
        "signature": "sanic.testing.SanicTestClient._sanic_endpoint_test(self, method='get', uri='/', gather_request=True, debug=False, server_kwargs={'auto_reload': False}, *request_args, **request_kwargs)",
        "snippet": "    def _sanic_endpoint_test(\n        self,\n        method=\"get\",\n        uri=\"/\",\n        gather_request=True,\n        debug=False,\n        server_kwargs={\"auto_reload\": False},\n        *request_args,\n        **request_kwargs,\n    ):\n        results = [None, None]\n        exceptions = []\n\n        if gather_request:\n\n            def _collect_request(request):\n                if results[0] is None:\n                    results[0] = request\n\n            self.app.request_middleware.appendleft(_collect_request)\n\n        @self.app.exception(MethodNotSupported)\n        async def error_handler(request, exception):\n            if request.method in [\"HEAD\", \"PATCH\", \"PUT\", \"DELETE\"]:\n                return text(\n                    \"\", exception.status_code, headers=exception.headers\n                )\n            else:\n                return self.app.error_handler.default(request, exception)\n\n        if self.port:\n            server_kwargs = dict(host=HOST, port=self.port, **server_kwargs)\n            host, port = HOST, self.port\n        else:\n            sock = socket()\n            sock.bind((HOST, 0))\n            server_kwargs = dict(sock=sock, **server_kwargs)\n            host, port = sock.getsockname()\n\n        if uri.startswith(\n            (\"http:\", \"https:\", \"ftp:\", \"ftps://\", \"//\", \"ws:\", \"wss:\")\n        ):\n            url = uri\n        else:\n            uri = uri if uri.startswith(\"/\") else \"/{uri}\".format(uri=uri)\n            scheme = \"ws\" if method == \"websocket\" else \"http\"\n            url = \"{scheme}://{host}:{port}{uri}\".format(\n                scheme=scheme, host=host, port=port, uri=uri\n            )\n\n        @self.app.listener(\"after_server_start\")\n        async def _collect_response(sanic, loop):\n            try:\n                response = await self._local_request(\n                    method, url, *request_args, **request_kwargs\n                )\n                results[-1] = response\n            except Exception as e:\n                logger.exception(\"Exception\")\n                exceptions.append(e)\n            self.app.stop()\n\n        self.app.run(debug=debug, **server_kwargs)\n        self.app.listeners[\"after_server_start\"].pop()\n\n        if exceptions:\n            raise ValueError(\"Exception during request: {}\".format(exceptions))\n\n        if gather_request:\n            try:\n                request, response = results\n                return request, response\n            except BaseException:  # noqa\n                raise ValueError(\n                    \"Request and response object expected, got ({})\".format(\n                        results\n                    )\n                )\n        else:\n            try:\n                return results[-1]\n            except BaseException:  # noqa\n                raise ValueError(\n                    \"Request object expected, got ({})\".format(results)\n                )",
        "begin_line": 67,
        "end_line": 151,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008264462809917356,
            "pseudo_dstar_susp": 0.5,
            "pseudo_tarantula_susp": 0.004784688995215311,
            "pseudo_op2_susp": 0.5,
            "pseudo_barinel_susp": 0.004784688995215311
        }
    },
    {
        "name": "sanic.testing.SanicTestClient._collect_request#82",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicTestClient",
        "signature": "sanic.testing.SanicTestClient._collect_request(request)",
        "snippet": "            def _collect_request(request):\n                if results[0] is None:\n                    results[0] = request",
        "begin_line": 82,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008333333333333333,
            "pseudo_dstar_susp": 1.0,
            "pseudo_tarantula_susp": 0.004273504273504274,
            "pseudo_op2_susp": 1.0,
            "pseudo_barinel_susp": 0.004273504273504274
        }
    },
    {
        "name": "sanic.testing.SanicTestClient.error_handler#89",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicTestClient",
        "signature": "sanic.testing.SanicTestClient.error_handler(request, exception)",
        "snippet": "        async def error_handler(request, exception):\n            if request.method in [\"HEAD\", \"PATCH\", \"PUT\", \"DELETE\"]:\n                return text(\n                    \"\", exception.status_code, headers=exception.headers\n                )\n            else:\n                return self.app.error_handler.default(request, exception)",
        "begin_line": 89,
        "end_line": 95,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0030120481927710845,
            "pseudo_dstar_susp": 0.004629629629629629,
            "pseudo_tarantula_susp": 0.003076923076923077,
            "pseudo_op2_susp": 0.004629629629629629,
            "pseudo_barinel_susp": 0.003076923076923077
        }
    },
    {
        "name": "sanic.testing.SanicTestClient._collect_response#118",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicTestClient",
        "signature": "sanic.testing.SanicTestClient._collect_response(sanic, loop)",
        "snippet": "        async def _collect_response(sanic, loop):\n            try:\n                response = await self._local_request(\n                    method, url, *request_args, **request_kwargs\n                )\n                results[-1] = response\n            except Exception as e:\n                logger.exception(\"Exception\")\n                exceptions.append(e)\n            self.app.stop()",
        "begin_line": 118,
        "end_line": 127,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0038022813688212928,
            "pseudo_dstar_susp": 0.006802721088435374,
            "pseudo_tarantula_susp": 0.00392156862745098,
            "pseudo_op2_susp": 0.006802721088435374,
            "pseudo_barinel_susp": 0.00392156862745098
        }
    },
    {
        "name": "sanic.testing.SanicTestClient.get#153",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicTestClient",
        "signature": "sanic.testing.SanicTestClient.get(self, *args, **kwargs)",
        "snippet": "    def get(self, *args, **kwargs):\n        return self._sanic_endpoint_test(\"get\", *args, **kwargs)",
        "begin_line": 153,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001272264631043257,
            "pseudo_dstar_susp": 0.001272264631043257,
            "pseudo_tarantula_susp": 0.001272264631043257,
            "pseudo_op2_susp": 0.001272264631043257,
            "pseudo_barinel_susp": 0.001272264631043257
        }
    },
    {
        "name": "sanic.testing.SanicTestClient.post#156",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicTestClient",
        "signature": "sanic.testing.SanicTestClient.post(self, *args, **kwargs)",
        "snippet": "    def post(self, *args, **kwargs):\n        return self._sanic_endpoint_test(\"post\", *args, **kwargs)",
        "begin_line": 156,
        "end_line": 157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008130081300813009,
            "pseudo_dstar_susp": 0.001321003963011889,
            "pseudo_tarantula_susp": 0.008403361344537815,
            "pseudo_op2_susp": 0.001321003963011889,
            "pseudo_barinel_susp": 0.008403361344537815
        }
    },
    {
        "name": "sanic.testing.SanicTestClient.put#159",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicTestClient",
        "signature": "sanic.testing.SanicTestClient.put(self, *args, **kwargs)",
        "snippet": "    def put(self, *args, **kwargs):\n        return self._sanic_endpoint_test(\"put\", *args, **kwargs)",
        "begin_line": 159,
        "end_line": 160,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004432624113475177,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.testing.SanicTestClient.delete#162",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicTestClient",
        "signature": "sanic.testing.SanicTestClient.delete(self, *args, **kwargs)",
        "snippet": "    def delete(self, *args, **kwargs):\n        return self._sanic_endpoint_test(\"delete\", *args, **kwargs)",
        "begin_line": 162,
        "end_line": 163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004432624113475177,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.testing.SanicTestClient.patch#165",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicTestClient",
        "signature": "sanic.testing.SanicTestClient.patch(self, *args, **kwargs)",
        "snippet": "    def patch(self, *args, **kwargs):\n        return self._sanic_endpoint_test(\"patch\", *args, **kwargs)",
        "begin_line": 165,
        "end_line": 166,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00045433893684688776,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.testing.SanicTestClient.options#168",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicTestClient",
        "signature": "sanic.testing.SanicTestClient.options(self, *args, **kwargs)",
        "snippet": "    def options(self, *args, **kwargs):\n        return self._sanic_endpoint_test(\"options\", *args, **kwargs)",
        "begin_line": 168,
        "end_line": 169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004997501249375312,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.testing.SanicTestClient.head#171",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicTestClient",
        "signature": "sanic.testing.SanicTestClient.head(self, *args, **kwargs)",
        "snippet": "    def head(self, *args, **kwargs):\n        return self._sanic_endpoint_test(\"head\", *args, **kwargs)",
        "begin_line": 171,
        "end_line": 172,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004338394793926247,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.testing.SanicTestClient.websocket#174",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicTestClient",
        "signature": "sanic.testing.SanicTestClient.websocket(self, *args, **kwargs)",
        "snippet": "    def websocket(self, *args, **kwargs):\n        return self._sanic_endpoint_test(\"websocket\", *args, **kwargs)",
        "begin_line": 174,
        "end_line": 175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004997501249375312,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.testing.SanicASGIAdapter.send#179",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicASGIAdapter",
        "signature": "sanic.testing.SanicASGIAdapter.send(self, request: requests.PreparedRequest, gather_return: bool=False, *args: typing.Any, **kwargs: typing.Any)",
        "snippet": "    async def send(  # type: ignore\n        self,\n        request: requests.PreparedRequest,\n        gather_return: bool = False,\n        *args: typing.Any,\n        **kwargs: typing.Any,\n    ) -> requests.Response:\n        \"\"\"This method is taken MOSTLY verbatim from requests-asyn. The\n        difference is the capturing of a response on the ASGI call and then\n        returning it on the response object. This is implemented to achieve:\n\n        request, response = await app.asgi_client.get(\"/\")\n\n        You can see the original code here:\n        https://github.com/encode/requests-async/blob/614f40f77f19e6c6da8a212ae799107b0384dbf9/requests_async/asgi.py#L51\"\"\"  # noqa\n        scheme, netloc, path, query, fragment = urlsplit(\n            request.url\n        )  # type: ignore\n\n        default_port = {\"http\": 80, \"ws\": 80, \"https\": 443, \"wss\": 443}[scheme]\n\n        if \":\" in netloc:\n            host, port_string = netloc.split(\":\", 1)\n            port = int(port_string)\n        else:\n            host = netloc\n            port = default_port\n\n        # Include the 'host' header.\n        if \"host\" in request.headers:\n            headers = []  # type: typing.List[typing.Tuple[bytes, bytes]]\n        elif port == default_port:\n            headers = [(b\"host\", host.encode())]\n        else:\n            headers = [(b\"host\", (f\"{host}:{port}\").encode())]\n\n        # Include other request headers.\n        headers += [\n            (key.lower().encode(), value.encode())\n            for key, value in request.headers.items()\n        ]\n\n        no_response = False\n        if scheme in {\"ws\", \"wss\"}:\n            subprotocol = request.headers.get(\"sec-websocket-protocol\", None)\n            if subprotocol is None:\n                subprotocols = []  # type: typing.Sequence[str]\n            else:\n                subprotocols = [\n                    value.strip() for value in subprotocol.split(\",\")\n                ]\n\n            scope = {\n                \"type\": \"websocket\",\n                \"path\": unquote(path),\n                \"root_path\": \"\",\n                \"scheme\": scheme,\n                \"query_string\": query.encode(),\n                \"headers\": headers,\n                \"client\": [\"testclient\", 50000],\n                \"server\": [host, port],\n                \"subprotocols\": subprotocols,\n            }\n            no_response = True\n\n        else:\n            scope = {\n                \"type\": \"http\",\n                \"http_version\": \"1.1\",\n                \"method\": request.method,\n                \"path\": unquote(path),\n                \"root_path\": \"\",\n                \"scheme\": scheme,\n                \"query_string\": query.encode(),\n                \"headers\": headers,\n                \"client\": [\"testclient\", 50000],\n                \"server\": [host, port],\n                \"extensions\": {\"http.response.template\": {}},\n            }\n\n        async def receive():\n            nonlocal request_complete, response_complete\n\n            if request_complete:\n                while not response_complete:\n                    await asyncio.sleep(0.0001)\n                return {\"type\": \"http.disconnect\"}\n\n            body = request.body\n            if isinstance(body, str):\n                body_bytes = body.encode(\"utf-8\")  # type: bytes\n            elif body is None:\n                body_bytes = b\"\"\n            elif isinstance(body, types.GeneratorType):\n                try:\n                    chunk = body.send(None)\n                    if isinstance(chunk, str):\n                        chunk = chunk.encode(\"utf-8\")\n                    return {\n                        \"type\": \"http.request\",\n                        \"body\": chunk,\n                        \"more_body\": True,\n                    }\n                except StopIteration:\n                    request_complete = True\n                    return {\"type\": \"http.request\", \"body\": b\"\"}\n            else:\n                body_bytes = body\n\n            request_complete = True\n            return {\"type\": \"http.request\", \"body\": body_bytes}\n\n        request_complete = False\n        response_started = False\n        response_complete = False\n        raw_kwargs = {\"content\": b\"\"}  # type: typing.Dict[str, typing.Any]\n        template = None\n        context = None\n        return_value = None\n\n        async def send(message) -> None:\n            nonlocal raw_kwargs, response_started, response_complete, template, context  # noqa\n\n            if message[\"type\"] == \"http.response.start\":\n                assert (\n                    not response_started\n                ), 'Received multiple \"http.response.start\" messages.'\n                raw_kwargs[\"status_code\"] = message[\"status\"]\n                raw_kwargs[\"headers\"] = message[\"headers\"]\n                response_started = True\n            elif message[\"type\"] == \"http.response.body\":\n                assert response_started, (\n                    'Received \"http.response.body\" '\n                    'without \"http.response.start\".'\n                )\n                assert (\n                    not response_complete\n                ), 'Received \"http.response.body\" after response completed.'\n                body = message.get(\"body\", b\"\")\n                more_body = message.get(\"more_body\", False)\n                if request.method != \"HEAD\":\n                    raw_kwargs[\"content\"] += body\n                if not more_body:\n                    response_complete = True\n            elif message[\"type\"] == \"http.response.template\":\n                template = message[\"template\"]\n                context = message[\"context\"]\n\n        try:\n            return_value = await self.app(scope, receive, send)\n        except BaseException as exc:\n            if not self.suppress_exceptions:\n                raise exc from None\n\n        if no_response:\n            response_started = True\n            raw_kwargs = {\"status_code\": 204, \"headers\": []}\n\n        if not self.suppress_exceptions:\n            assert response_started, \"TestClient did not receive any response.\"\n        elif not response_started:\n            raw_kwargs = {\"status_code\": 500, \"headers\": []}\n\n        raw = httpcore.Response(**raw_kwargs)\n        response = self.build_response(request, raw)\n        if template is not None:\n            response.template = template\n            response.context = context\n\n        if gather_return:\n            response.return_value = return_value\n        return response",
        "begin_line": 179,
        "end_line": 350,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.testing.SanicASGIAdapter.receive#259",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicASGIAdapter",
        "signature": "sanic.testing.SanicASGIAdapter.receive()",
        "snippet": "        async def receive():\n            nonlocal request_complete, response_complete\n\n            if request_complete:\n                while not response_complete:\n                    await asyncio.sleep(0.0001)\n                return {\"type\": \"http.disconnect\"}\n\n            body = request.body\n            if isinstance(body, str):\n                body_bytes = body.encode(\"utf-8\")  # type: bytes\n            elif body is None:\n                body_bytes = b\"\"\n            elif isinstance(body, types.GeneratorType):\n                try:\n                    chunk = body.send(None)\n                    if isinstance(chunk, str):\n                        chunk = chunk.encode(\"utf-8\")\n                    return {\n                        \"type\": \"http.request\",\n                        \"body\": chunk,\n                        \"more_body\": True,\n                    }\n                except StopIteration:\n                    request_complete = True\n                    return {\"type\": \"http.request\", \"body\": b\"\"}\n            else:\n                body_bytes = body\n\n            request_complete = True\n            return {\"type\": \"http.request\", \"body\": body_bytes}",
        "begin_line": 259,
        "end_line": 289,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.testing.SanicASGIAdapter.send#299",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicASGIAdapter",
        "signature": "sanic.testing.SanicASGIAdapter.send(message)",
        "snippet": "        async def send(message) -> None:\n            nonlocal raw_kwargs, response_started, response_complete, template, context  # noqa\n\n            if message[\"type\"] == \"http.response.start\":\n                assert (\n                    not response_started\n                ), 'Received multiple \"http.response.start\" messages.'\n                raw_kwargs[\"status_code\"] = message[\"status\"]\n                raw_kwargs[\"headers\"] = message[\"headers\"]\n                response_started = True\n            elif message[\"type\"] == \"http.response.body\":\n                assert response_started, (\n                    'Received \"http.response.body\" '\n                    'without \"http.response.start\".'\n                )\n                assert (\n                    not response_complete\n                ), 'Received \"http.response.body\" after response completed.'\n                body = message.get(\"body\", b\"\")\n                more_body = message.get(\"more_body\", False)\n                if request.method != \"HEAD\":\n                    raw_kwargs[\"content\"] += body\n                if not more_body:\n                    response_complete = True\n            elif message[\"type\"] == \"http.response.template\":\n                template = message[\"template\"]\n                context = message[\"context\"]",
        "begin_line": 299,
        "end_line": 325,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.testing.TestASGIApp.__call__#354",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.TestASGIApp",
        "signature": "sanic.testing.TestASGIApp.__call__(self)",
        "snippet": "    async def __call__(self):\n        await super().__call__()\n        return self.request",
        "begin_line": 354,
        "end_line": 356,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00037383177570093456,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.testing.app_call_with_return#359",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing",
        "signature": "sanic.testing.app_call_with_return(self, scope, receive, send)",
        "snippet": "async def app_call_with_return(self, scope, receive, send):\n    asgi_app = await TestASGIApp.create(self, scope, receive, send)\n    return await asgi_app()",
        "begin_line": 359,
        "end_line": 361,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00036832412523020257,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.testing.SanicASGITestClient.__init__#365",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicASGITestClient",
        "signature": "sanic.testing.SanicASGITestClient.__init__(self, app, base_url: str='http://{}'.format(ASGI_HOST), suppress_exceptions: bool=False)",
        "snippet": "    def __init__(\n        self,\n        app,\n        base_url: str = \"http://{}\".format(ASGI_HOST),\n        suppress_exceptions: bool = False,\n    ) -> None:\n        app.__class__.__call__ = app_call_with_return\n        app.asgi = True\n        super().__init__(app)\n\n        adapter = SanicASGIAdapter(\n            app, suppress_exceptions=suppress_exceptions\n        )\n        self.mount(\"http://\", adapter)\n        self.mount(\"https://\", adapter)\n        self.mount(\"ws://\", adapter)\n        self.mount(\"wss://\", adapter)\n        self.headers.update({\"user-agent\": \"testclient\"})\n        self.app = app\n        self.base_url = base_url",
        "begin_line": 365,
        "end_line": 384,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00036310820624546115,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.testing.SanicASGITestClient.request#386",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicASGITestClient",
        "signature": "sanic.testing.SanicASGITestClient.request(self, method, url, gather_request=True, *args, **kwargs)",
        "snippet": "    async def request(self, method, url, gather_request=True, *args, **kwargs):\n\n        self.gather_request = gather_request\n        response = await super().request(method, url, *args, **kwargs)\n        response.status = response.status_code\n        response.body = response.content\n        response.content_type = response.headers.get(\"content-type\")\n\n        if hasattr(response, \"return_value\"):\n            request = response.return_value\n            del response.return_value\n            return request, response\n\n        return response",
        "begin_line": 386,
        "end_line": 399,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00037383177570093456,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.testing.SanicASGITestClient.merge_environment_settings#401",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicASGITestClient",
        "signature": "sanic.testing.SanicASGITestClient.merge_environment_settings(self, *args, **kwargs)",
        "snippet": "    def merge_environment_settings(self, *args, **kwargs):\n        settings = super().merge_environment_settings(*args, **kwargs)\n        settings.update({\"gather_return\": self.gather_request})\n        return settings",
        "begin_line": 401,
        "end_line": 404,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00036832412523020257,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.testing.SanicASGITestClient.websocket#406",
        "src_path": "sanic/testing.py",
        "class_name": "sanic.testing.SanicASGITestClient",
        "signature": "sanic.testing.SanicASGITestClient.websocket(self, uri, subprotocols=None, *args, **kwargs)",
        "snippet": "    async def websocket(self, uri, subprotocols=None, *args, **kwargs):\n        if uri.startswith((\"ws:\", \"wss:\")):\n            url = uri\n        else:\n            uri = uri if uri.startswith(\"/\") else \"/{uri}\".format(uri=uri)\n            url = \"ws://testserver{uri}\".format(uri=uri)\n\n            headers = kwargs.get(\"headers\", {})\n            headers.setdefault(\"connection\", \"upgrade\")\n            headers.setdefault(\"sec-websocket-key\", \"testserver==\")\n            headers.setdefault(\"sec-websocket-version\", \"13\")\n            if subprotocols is not None:\n                headers.setdefault(\n                    \"sec-websocket-protocol\", \", \".join(subprotocols)\n                )\n            kwargs[\"headers\"] = headers\n\n            return await self.request(\"websocket\", url, **kwargs)",
        "begin_line": 406,
        "end_line": 423,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0007358351729212656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.response.BaseHTTPResponse._encode_body#24",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response.BaseHTTPResponse",
        "signature": "sanic.response.BaseHTTPResponse._encode_body(self, data)",
        "snippet": "    def _encode_body(self, data):\n        try:\n            # Try to encode it regularly\n            return data.encode()\n        except AttributeError:\n            # Convert it to a str if you can't\n            return str(data).encode()",
        "begin_line": 24,
        "end_line": 30,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006211180124223602,
            "pseudo_dstar_susp": 0.022222222222222223,
            "pseudo_tarantula_susp": 0.006578947368421052,
            "pseudo_op2_susp": 0.022222222222222223,
            "pseudo_barinel_susp": 0.006578947368421052
        }
    },
    {
        "name": "sanic.response.BaseHTTPResponse._parse_headers#32",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response.BaseHTTPResponse",
        "signature": "sanic.response.BaseHTTPResponse._parse_headers(self)",
        "snippet": "    def _parse_headers(self):\n        headers = b\"\"\n        for name, value in self.headers.items():\n            try:\n                headers += b\"%b: %b\\r\\n\" % (\n                    name.encode(),\n                    value.encode(\"utf-8\"),\n                )\n            except AttributeError:\n                headers += b\"%b: %b\\r\\n\" % (\n                    str(name).encode(),\n                    str(value).encode(\"utf-8\"),\n                )\n\n        return headers",
        "begin_line": 32,
        "end_line": 46,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006369426751592357,
            "pseudo_dstar_susp": 0.024390243902439025,
            "pseudo_tarantula_susp": 0.006756756756756757,
            "pseudo_op2_susp": 0.024390243902439025,
            "pseudo_barinel_susp": 0.006756756756756757
        }
    },
    {
        "name": "sanic.response.BaseHTTPResponse.cookies#49",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response.BaseHTTPResponse",
        "signature": "sanic.response.BaseHTTPResponse.cookies(self)",
        "snippet": "    def cookies(self):\n        if self._cookies is None:\n            self._cookies = CookieJar(self.headers)\n        return self._cookies",
        "begin_line": 49,
        "end_line": 52,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.response.StreamingHTTPResponse.__init__#66",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response.StreamingHTTPResponse",
        "signature": "sanic.response.StreamingHTTPResponse.__init__(self, streaming_fn, status=200, headers=None, content_type='text/plain', chunked=True)",
        "snippet": "    def __init__(\n        self,\n        streaming_fn,\n        status=200,\n        headers=None,\n        content_type=\"text/plain\",\n        chunked=True,\n    ):\n        self.content_type = content_type\n        self.streaming_fn = streaming_fn\n        self.status = status\n        self.headers = Header(headers or {})\n        self.chunked = chunked\n        self._cookies = None",
        "begin_line": 66,
        "end_line": 79,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0003920031360250882,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.response.StreamingHTTPResponse.write#81",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response.StreamingHTTPResponse",
        "signature": "sanic.response.StreamingHTTPResponse.write(self, data)",
        "snippet": "    async def write(self, data):\n        \"\"\"Writes a chunk of data to the streaming response.\n\n        :param data: bytes-ish data to be written.\n        \"\"\"\n        if type(data) != bytes:\n            data = self._encode_body(data)\n\n        if self.chunked:\n            await self.protocol.push_data(b\"%x\\r\\n%b\\r\\n\" % (len(data), data))\n        else:\n            await self.protocol.push_data(data)\n        await self.protocol.drain()",
        "begin_line": 81,
        "end_line": 93,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0006317119393556538,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.response.StreamingHTTPResponse.stream#95",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response.StreamingHTTPResponse",
        "signature": "sanic.response.StreamingHTTPResponse.stream(self, version='1.1', keep_alive=False, keep_alive_timeout=None)",
        "snippet": "    async def stream(\n        self, version=\"1.1\", keep_alive=False, keep_alive_timeout=None\n    ):\n        \"\"\"Streams headers, runs the `streaming_fn` callback that writes\n        content to the response body, then finalizes the response body.\n        \"\"\"\n        if version != \"1.1\":\n            self.chunked = False\n        headers = self.get_headers(\n            version,\n            keep_alive=keep_alive,\n            keep_alive_timeout=keep_alive_timeout,\n        )\n        await self.protocol.push_data(headers)\n        await self.protocol.drain()\n        await self.streaming_fn(self)\n        if self.chunked:\n            await self.protocol.push_data(b\"0\\r\\n\\r\\n\")",
        "begin_line": 95,
        "end_line": 112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.response.StreamingHTTPResponse.get_headers#116",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response.StreamingHTTPResponse",
        "signature": "sanic.response.StreamingHTTPResponse.get_headers(self, version='1.1', keep_alive=False, keep_alive_timeout=None)",
        "snippet": "    def get_headers(\n        self, version=\"1.1\", keep_alive=False, keep_alive_timeout=None\n    ):\n        # This is all returned in a kind-of funky way\n        # We tried to make this as fast as possible in pure python\n        timeout_header = b\"\"\n        if keep_alive and keep_alive_timeout is not None:\n            timeout_header = b\"Keep-Alive: %d\\r\\n\" % keep_alive_timeout\n\n        if self.chunked and version == \"1.1\":\n            self.headers[\"Transfer-Encoding\"] = \"chunked\"\n            self.headers.pop(\"Content-Length\", None)\n        self.headers[\"Content-Type\"] = self.headers.get(\n            \"Content-Type\", self.content_type\n        )\n\n        headers = self._parse_headers()\n\n        if self.status == 200:\n            status = b\"OK\"\n        else:\n            status = STATUS_CODES.get(self.status)\n\n        return (b\"HTTP/%b %d %b\\r\\n\" b\"%b\" b\"%b\\r\\n\") % (\n            version.encode(),\n            self.status,\n            status,\n            timeout_header,\n            headers,\n        )",
        "begin_line": 116,
        "end_line": 145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00048449612403100775,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.response.HTTPResponse.__init__#151",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response.HTTPResponse",
        "signature": "sanic.response.HTTPResponse.__init__(self, body=None, status=200, headers=None, content_type='text/plain', body_bytes=b'')",
        "snippet": "    def __init__(\n        self,\n        body=None,\n        status=200,\n        headers=None,\n        content_type=\"text/plain\",\n        body_bytes=b\"\",\n    ):\n        self.content_type = content_type\n\n        if body is not None:\n            self.body = self._encode_body(body)\n        else:\n            self.body = body_bytes\n\n        self.status = status\n        self.headers = Header(headers or {})\n        self._cookies = None",
        "begin_line": 151,
        "end_line": 168,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0064516129032258064,
            "pseudo_dstar_susp": 0.02564102564102564,
            "pseudo_tarantula_susp": 0.00684931506849315,
            "pseudo_op2_susp": 0.02564102564102564,
            "pseudo_barinel_susp": 0.00684931506849315
        }
    },
    {
        "name": "sanic.response.HTTPResponse.output#170",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response.HTTPResponse",
        "signature": "sanic.response.HTTPResponse.output(self, version='1.1', keep_alive=False, keep_alive_timeout=None)",
        "snippet": "    def output(self, version=\"1.1\", keep_alive=False, keep_alive_timeout=None):\n        # This is all returned in a kind-of funky way\n        # We tried to make this as fast as possible in pure python\n        timeout_header = b\"\"\n        if keep_alive and keep_alive_timeout is not None:\n            timeout_header = b\"Keep-Alive: %d\\r\\n\" % keep_alive_timeout\n\n        body = b\"\"\n        if has_message_body(self.status):\n            body = self.body\n            self.headers[\"Content-Length\"] = self.headers.get(\n                \"Content-Length\", len(self.body)\n            )\n\n        self.headers[\"Content-Type\"] = self.headers.get(\n            \"Content-Type\", self.content_type\n        )\n\n        if self.status in (304, 412):\n            self.headers = remove_entity_headers(self.headers)\n\n        headers = self._parse_headers()\n\n        if self.status == 200:\n            status = b\"OK\"\n        else:\n            status = STATUS_CODES.get(self.status, b\"UNKNOWN RESPONSE\")\n\n        return (\n            b\"HTTP/%b %d %b\\r\\n\" b\"Connection: %b\\r\\n\" b\"%b\" b\"%b\\r\\n\" b\"%b\"\n        ) % (\n            version.encode(),\n            self.status,\n            status,\n            b\"keep-alive\" if keep_alive else b\"close\",\n            timeout_header,\n            headers,\n            body,\n        )",
        "begin_line": 170,
        "end_line": 208,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008403361344537815,
            "pseudo_dstar_susp": 0.02702702702702703,
            "pseudo_tarantula_susp": 0.008264462809917356,
            "pseudo_op2_susp": 0.02702702702702703,
            "pseudo_barinel_susp": 0.008264462809917356
        }
    },
    {
        "name": "sanic.response.HTTPResponse.cookies#211",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response.HTTPResponse",
        "signature": "sanic.response.HTTPResponse.cookies(self)",
        "snippet": "    def cookies(self):\n        if self._cookies is None:\n            self._cookies = CookieJar(self.headers)\n        return self._cookies",
        "begin_line": 211,
        "end_line": 214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00035236081747709656,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.response.json#217",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response",
        "signature": "sanic.response.json(body, status=200, headers=None, content_type='application/json', dumps=json_dumps, **kwargs)",
        "snippet": "def json(\n    body,\n    status=200,\n    headers=None,\n    content_type=\"application/json\",\n    dumps=json_dumps,\n    **kwargs\n):\n    \"\"\"\n    Returns response object with body in json format.\n\n    :param body: Response data to be serialized.\n    :param status: Response code.\n    :param headers: Custom Headers.\n    :param kwargs: Remaining arguments that are passed to the json encoder.\n    \"\"\"\n    return HTTPResponse(\n        dumps(body, **kwargs),\n        headers=headers,\n        status=status,\n        content_type=content_type,\n    )",
        "begin_line": 217,
        "end_line": 238,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0004149377593360996,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.response.text#241",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response",
        "signature": "sanic.response.text(body, status=200, headers=None, content_type='text/plain; charset=utf-8')",
        "snippet": "def text(\n    body, status=200, headers=None, content_type=\"text/plain; charset=utf-8\"\n):\n    \"\"\"\n    Returns response object with body in text format.\n\n    :param body: Response data to be encoded.\n    :param status: Response code.\n    :param headers: Custom Headers.\n    :param content_type: the content type (string) of the response\n    \"\"\"\n    return HTTPResponse(\n        body, status=status, headers=headers, content_type=content_type\n    )",
        "begin_line": 241,
        "end_line": 254,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0012755102040816326,
            "pseudo_dstar_susp": 0.0012755102040816326,
            "pseudo_tarantula_susp": 0.0012755102040816326,
            "pseudo_op2_susp": 0.0012755102040816326,
            "pseudo_barinel_susp": 0.0012755102040816326
        }
    },
    {
        "name": "sanic.response.raw#257",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response",
        "signature": "sanic.response.raw(body, status=200, headers=None, content_type='application/octet-stream')",
        "snippet": "def raw(\n    body, status=200, headers=None, content_type=\"application/octet-stream\"\n):\n    \"\"\"\n    Returns response object without encoding the body.\n\n    :param body: Response data.\n    :param status: Response code.\n    :param headers: Custom Headers.\n    :param content_type: the content type (string) of the response.\n    \"\"\"\n    return HTTPResponse(\n        body_bytes=body,\n        status=status,\n        headers=headers,\n        content_type=content_type,\n    )",
        "begin_line": 257,
        "end_line": 273,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.000998003992015968,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.response.html#276",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response",
        "signature": "sanic.response.html(body, status=200, headers=None)",
        "snippet": "def html(body, status=200, headers=None):\n    \"\"\"\n    Returns response object with body in html format.\n\n    :param body: Response data to be encoded.\n    :param status: Response code.\n    :param headers: Custom Headers.\n    \"\"\"\n    return HTTPResponse(\n        body,\n        status=status,\n        headers=headers,\n        content_type=\"text/html; charset=utf-8\",\n    )",
        "begin_line": 276,
        "end_line": 289,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.043478260869565216,
            "pseudo_dstar_susp": 0.0014534883720930232,
            "pseudo_tarantula_susp": 0.043478260869565216,
            "pseudo_op2_susp": 0.0014534883720930232,
            "pseudo_barinel_susp": 0.043478260869565216
        }
    },
    {
        "name": "sanic.response.file#292",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response",
        "signature": "sanic.response.file(location, status=200, mime_type=None, headers=None, filename=None, _range=None)",
        "snippet": "async def file(\n    location,\n    status=200,\n    mime_type=None,\n    headers=None,\n    filename=None,\n    _range=None,\n):\n    \"\"\"Return a response object with file data.\n\n    :param location: Location of file on system.\n    :param mime_type: Specific mime_type.\n    :param headers: Custom Headers.\n    :param filename: Override filename.\n    :param _range:\n    \"\"\"\n    headers = headers or {}\n    if filename:\n        headers.setdefault(\n            \"Content-Disposition\", 'attachment; filename=\"{}\"'.format(filename)\n        )\n    filename = filename or path.split(location)[-1]\n\n    async with open_async(location, mode=\"rb\") as _file:\n        if _range:\n            await _file.seek(_range.start)\n            out_stream = await _file.read(_range.size)\n            headers[\"Content-Range\"] = \"bytes %s-%s/%s\" % (\n                _range.start,\n                _range.end,\n                _range.total,\n            )\n            status = 206\n        else:\n            out_stream = await _file.read()\n\n    mime_type = mime_type or guess_type(filename)[0] or \"text/plain\"\n    return HTTPResponse(\n        status=status,\n        headers=headers,\n        content_type=mime_type,\n        body_bytes=out_stream,\n    )",
        "begin_line": 292,
        "end_line": 334,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0006317119393556538,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.response.file_stream#337",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response",
        "signature": "sanic.response.file_stream(location, status=200, chunk_size=4096, mime_type=None, headers=None, filename=None, chunked=True, _range=None)",
        "snippet": "async def file_stream(\n    location,\n    status=200,\n    chunk_size=4096,\n    mime_type=None,\n    headers=None,\n    filename=None,\n    chunked=True,\n    _range=None,\n):\n    \"\"\"Return a streaming response object with file data.\n\n    :param location: Location of file on system.\n    :param chunk_size: The size of each chunk in the stream (in bytes)\n    :param mime_type: Specific mime_type.\n    :param headers: Custom Headers.\n    :param filename: Override filename.\n    :param chunked: Enable or disable chunked transfer-encoding\n    :param _range:\n    \"\"\"\n    headers = headers or {}\n    if filename:\n        headers.setdefault(\n            \"Content-Disposition\", 'attachment; filename=\"{}\"'.format(filename)\n        )\n    filename = filename or path.split(location)[-1]\n\n    _file = await open_async(location, mode=\"rb\")\n\n    async def _streaming_fn(response):\n        nonlocal _file, chunk_size\n        try:\n            if _range:\n                chunk_size = min((_range.size, chunk_size))\n                await _file.seek(_range.start)\n                to_send = _range.size\n                while to_send > 0:\n                    content = await _file.read(chunk_size)\n                    if len(content) < 1:\n                        break\n                    to_send -= len(content)\n                    await response.write(content)\n            else:\n                while True:\n                    content = await _file.read(chunk_size)\n                    if len(content) < 1:\n                        break\n                    await response.write(content)\n        finally:\n            await _file.close()\n        return  # Returning from this fn closes the stream\n\n    mime_type = mime_type or guess_type(filename)[0] or \"text/plain\"\n    if _range:\n        headers[\"Content-Range\"] = \"bytes %s-%s/%s\" % (\n            _range.start,\n            _range.end,\n            _range.total,\n        )\n        status = 206\n    return StreamingHTTPResponse(\n        streaming_fn=_streaming_fn,\n        status=status,\n        headers=headers,\n        content_type=mime_type,\n        chunked=chunked,\n    )",
        "begin_line": 337,
        "end_line": 403,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0006317119393556538,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.response._streaming_fn#366",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response",
        "signature": "sanic.response._streaming_fn(response)",
        "snippet": "    async def _streaming_fn(response):\n        nonlocal _file, chunk_size\n        try:\n            if _range:\n                chunk_size = min((_range.size, chunk_size))\n                await _file.seek(_range.start)\n                to_send = _range.size\n                while to_send > 0:\n                    content = await _file.read(chunk_size)\n                    if len(content) < 1:\n                        break\n                    to_send -= len(content)\n                    await response.write(content)\n            else:\n                while True:\n                    content = await _file.read(chunk_size)\n                    if len(content) < 1:\n                        break\n                    await response.write(content)\n        finally:\n            await _file.close()\n        return  # Returning from this fn closes the stream",
        "begin_line": 366,
        "end_line": 387,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005899705014749262,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.response.stream#406",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response",
        "signature": "sanic.response.stream(streaming_fn, status=200, headers=None, content_type='text/plain; charset=utf-8', chunked=True)",
        "snippet": "def stream(\n    streaming_fn,\n    status=200,\n    headers=None,\n    content_type=\"text/plain; charset=utf-8\",\n    chunked=True,\n):\n    \"\"\"Accepts an coroutine `streaming_fn` which can be used to\n    write chunks to a streaming response. Returns a `StreamingHTTPResponse`.\n\n    Example usage::\n\n        @app.route(\"/\")\n        async def index(request):\n            async def streaming_fn(response):\n                await response.write('foo')\n                await response.write('bar')\n\n            return stream(streaming_fn, content_type='text/plain')\n\n    :param streaming_fn: A coroutine accepts a response and\n        writes content to that response.\n    :param mime_type: Specific mime_type.\n    :param headers: Custom Headers.\n    :param chunked: Enable or disable chunked transfer-encoding\n    \"\"\"\n    return StreamingHTTPResponse(\n        streaming_fn,\n        headers=headers,\n        content_type=content_type,\n        status=status,\n        chunked=chunked,\n    )",
        "begin_line": 406,
        "end_line": 438,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.0005393743257820927,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    },
    {
        "name": "sanic.response.redirect#441",
        "src_path": "sanic/response.py",
        "class_name": "sanic.response",
        "signature": "sanic.response.redirect(to, headers=None, status=302, content_type='text/html; charset=utf-8')",
        "snippet": "def redirect(\n    to, headers=None, status=302, content_type=\"text/html; charset=utf-8\"\n):\n    \"\"\"Abort execution and cause a 302 redirect (by default).\n\n    :param to: path or fully qualified URL to redirect to\n    :param headers: optional dict of headers to include in the new request\n    :param status: status code (int) of the new request, defaults to 302\n    :param content_type: the content type (string) of the response\n    :returns: the redirecting Response\n    \"\"\"\n    headers = headers or {}\n\n    # URL Quote the URL before redirecting\n    safe_to = quote_plus(to, safe=\":/%#?&=@[]!$&'()*+,;\")\n\n    # According to RFC 7231, a relative URI is now permitted.\n    headers[\"Location\"] = safe_to\n\n    return HTTPResponse(\n        status=status, headers=headers, content_type=content_type\n    )",
        "begin_line": 441,
        "end_line": 462,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005246589716684155,
            "pseudo_dstar_susp": 0.0005246589716684155,
            "pseudo_tarantula_susp": 0.0005246589716684155,
            "pseudo_op2_susp": 0.00048449612403100775,
            "pseudo_barinel_susp": 0.0005246589716684155
        }
    }
]