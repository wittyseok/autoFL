[
    {
        "name": "tests.test_black.dump_to_stderr#47",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black",
        "signature": "tests.test_black.dump_to_stderr(*output: str)",
        "snippet": "def dump_to_stderr(*output: str) -> str:\n    return \"\\n\" + \"\\n\".join(output) + \"\\n\"",
        "begin_line": 47,
        "end_line": 48,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.read_data#51",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black",
        "signature": "tests.test_black.read_data(name: str, data: bool=True)",
        "snippet": "def read_data(name: str, data: bool = True) -> Tuple[str, str]:\n    \"\"\"read_data('test_name') -> 'input', 'output'\"\"\"\n    if not name.endswith((\".py\", \".pyi\", \".out\", \".diff\")):\n        name += \".py\"\n    _input: List[str] = []\n    _output: List[str] = []\n    base_dir = THIS_DIR / \"data\" if data else THIS_DIR\n    with open(base_dir / name, \"r\", encoding=\"utf8\") as test:\n        lines = test.readlines()\n    result = _input\n    for line in lines:\n        line = line.replace(EMPTY_LINE, \"\")\n        if line.rstrip() == \"# output\":\n            result = _output\n            continue\n\n        result.append(line)\n    if _input and not _output:\n        # If there's no output marker, treat the entire file as already pre-formatted.\n        _output = _input[:]\n    return \"\".join(_input).strip() + \"\\n\", \"\".join(_output).strip() + \"\\n\"",
        "begin_line": 51,
        "end_line": 71,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.cache_dir#75",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black",
        "signature": "tests.test_black.cache_dir(exists: bool=True)",
        "snippet": "def cache_dir(exists: bool = True) -> Iterator[Path]:\n    with TemporaryDirectory() as workspace:\n        cache_dir = Path(workspace)\n        if not exists:\n            cache_dir = cache_dir / \"new\"\n        with patch(\"black.CACHE_DIR\", cache_dir):\n            yield cache_dir",
        "begin_line": 75,
        "end_line": 81,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.event_loop#85",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black",
        "signature": "tests.test_black.event_loop(close: bool)",
        "snippet": "def event_loop(close: bool) -> Iterator[None]:\n    policy = asyncio.get_event_loop_policy()\n    loop = policy.new_event_loop()\n    asyncio.set_event_loop(loop)\n    try:\n        yield\n\n    finally:\n        if close:\n            loop.close()",
        "begin_line": 85,
        "end_line": 94,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.skip_if_exception#98",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black",
        "signature": "tests.test_black.skip_if_exception(e: str)",
        "snippet": "def skip_if_exception(e: str) -> Iterator[None]:\n    try:\n        yield\n    except Exception as exc:\n        if exc.__class__.__name__ == e:\n            unittest.skip(f\"Encountered expected exception {exc}, skipping\")\n        else:\n            raise",
        "begin_line": 98,
        "end_line": 105,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackRunner.__init__#113",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackRunner",
        "signature": "tests.test_black.BlackRunner.__init__(self)",
        "snippet": "    def __init__(self) -> None:\n        self.stderrbuf = BytesIO()\n        self.stdoutbuf = BytesIO()\n        self.stdout_bytes = b\"\"\n        self.stderr_bytes = b\"\"\n        super().__init__()",
        "begin_line": 113,
        "end_line": 118,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackRunner.isolation#121",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackRunner",
        "signature": "tests.test_black.BlackRunner.isolation(self, *args: Any, **kwargs: Any)",
        "snippet": "    def isolation(self, *args: Any, **kwargs: Any) -> Generator[BinaryIO, None, None]:\n        with super().isolation(*args, **kwargs) as output:\n            try:\n                hold_stderr = sys.stderr\n                sys.stderr = TextIOWrapper(self.stderrbuf, encoding=self.charset)\n                yield output\n            finally:\n                self.stdout_bytes = sys.stdout.buffer.getvalue()  # type: ignore\n                self.stderr_bytes = sys.stderr.buffer.getvalue()  # type: ignore\n                sys.stderr = hold_stderr",
        "begin_line": 121,
        "end_line": 130,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.assertFormatEqual#136",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.assertFormatEqual(self, expected: str, actual: str)",
        "snippet": "    def assertFormatEqual(self, expected: str, actual: str) -> None:\n        if actual != expected and not os.environ.get(\"SKIP_AST_PRINT\"):\n            bdv: black.DebugVisitor[Any]\n            black.out(\"Expected tree:\", fg=\"green\")\n            try:\n                exp_node = black.lib2to3_parse(expected)\n                bdv = black.DebugVisitor()\n                list(bdv.visit(exp_node))\n            except Exception as ve:\n                black.err(str(ve))\n            black.out(\"Actual tree:\", fg=\"red\")\n            try:\n                exp_node = black.lib2to3_parse(actual)\n                bdv = black.DebugVisitor()\n                list(bdv.visit(exp_node))\n            except Exception as ve:\n                black.err(str(ve))\n        self.assertEqual(expected, actual)",
        "begin_line": 136,
        "end_line": 153,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.invokeBlack#155",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.invokeBlack(self, args: List[str], exit_code: int=0, ignore_config: bool=True)",
        "snippet": "    def invokeBlack(\n        self, args: List[str], exit_code: int = 0, ignore_config: bool = True\n    ) -> None:\n        runner = BlackRunner()\n        if ignore_config:\n            args = [\"--config\", str(THIS_DIR / \"empty.toml\"), *args]\n        result = runner.invoke(black.main, args)\n        self.assertEqual(result.exit_code, exit_code, msg=runner.stderr_bytes.decode())",
        "begin_line": 155,
        "end_line": 162,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.checkSourceFile#165",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.checkSourceFile(self, name: str)",
        "snippet": "    def checkSourceFile(self, name: str) -> None:\n        path = THIS_DIR.parent / name\n        source, expected = read_data(str(path), data=False)\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())\n        self.assertFalse(ff(path))",
        "begin_line": 165,
        "end_line": 172,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_empty#175",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_empty(self)",
        "snippet": "    def test_empty(self) -> None:\n        source = expected = \"\"\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 175,
        "end_line": 180,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_empty_ff#182",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_empty_ff(self)",
        "snippet": "    def test_empty_ff(self) -> None:\n        expected = \"\"\n        tmp_file = Path(black.dump_to_file())\n        try:\n            self.assertFalse(ff(tmp_file, write_back=black.WriteBack.YES))\n            with open(tmp_file, encoding=\"utf8\") as f:\n                actual = f.read()\n        finally:\n            os.unlink(tmp_file)\n        self.assertFormatEqual(expected, actual)",
        "begin_line": 182,
        "end_line": 191,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_self#193",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_self(self)",
        "snippet": "    def test_self(self) -> None:\n        self.checkSourceFile(\"tests/test_black.py\")",
        "begin_line": 193,
        "end_line": 194,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_black#196",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_black(self)",
        "snippet": "    def test_black(self) -> None:\n        self.checkSourceFile(\"black.py\")",
        "begin_line": 196,
        "end_line": 197,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_pygram#199",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_pygram(self)",
        "snippet": "    def test_pygram(self) -> None:\n        self.checkSourceFile(\"blib2to3/pygram.py\")",
        "begin_line": 199,
        "end_line": 200,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_pytree#202",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_pytree(self)",
        "snippet": "    def test_pytree(self) -> None:\n        self.checkSourceFile(\"blib2to3/pytree.py\")",
        "begin_line": 202,
        "end_line": 203,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_conv#205",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_conv(self)",
        "snippet": "    def test_conv(self) -> None:\n        self.checkSourceFile(\"blib2to3/pgen2/conv.py\")",
        "begin_line": 205,
        "end_line": 206,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_driver#208",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_driver(self)",
        "snippet": "    def test_driver(self) -> None:\n        self.checkSourceFile(\"blib2to3/pgen2/driver.py\")",
        "begin_line": 208,
        "end_line": 209,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_grammar#211",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_grammar(self)",
        "snippet": "    def test_grammar(self) -> None:\n        self.checkSourceFile(\"blib2to3/pgen2/grammar.py\")",
        "begin_line": 211,
        "end_line": 212,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_literals#214",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_literals(self)",
        "snippet": "    def test_literals(self) -> None:\n        self.checkSourceFile(\"blib2to3/pgen2/literals.py\")",
        "begin_line": 214,
        "end_line": 215,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_parse#217",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_parse(self)",
        "snippet": "    def test_parse(self) -> None:\n        self.checkSourceFile(\"blib2to3/pgen2/parse.py\")",
        "begin_line": 217,
        "end_line": 218,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_pgen#220",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_pgen(self)",
        "snippet": "    def test_pgen(self) -> None:\n        self.checkSourceFile(\"blib2to3/pgen2/pgen.py\")",
        "begin_line": 220,
        "end_line": 221,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_tokenize#223",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_tokenize(self)",
        "snippet": "    def test_tokenize(self) -> None:\n        self.checkSourceFile(\"blib2to3/pgen2/tokenize.py\")",
        "begin_line": 223,
        "end_line": 224,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_token#226",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_token(self)",
        "snippet": "    def test_token(self) -> None:\n        self.checkSourceFile(\"blib2to3/pgen2/token.py\")",
        "begin_line": 226,
        "end_line": 227,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_setup#229",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_setup(self)",
        "snippet": "    def test_setup(self) -> None:\n        self.checkSourceFile(\"setup.py\")",
        "begin_line": 229,
        "end_line": 230,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_piping#232",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_piping(self)",
        "snippet": "    def test_piping(self) -> None:\n        source, expected = read_data(\"../black\", data=False)\n        result = BlackRunner().invoke(\n            black.main,\n            [\"-\", \"--fast\", f\"--line-length={black.DEFAULT_LINE_LENGTH}\"],\n            input=BytesIO(source.encode(\"utf8\")),\n        )\n        self.assertEqual(result.exit_code, 0)\n        self.assertFormatEqual(expected, result.output)\n        black.assert_equivalent(source, result.output)\n        black.assert_stable(source, result.output, black.FileMode())",
        "begin_line": 232,
        "end_line": 242,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_piping_diff#244",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_piping_diff(self)",
        "snippet": "    def test_piping_diff(self) -> None:\n        diff_header = re.compile(\n            rf\"(STDIN|STDOUT)\\t\\d\\d\\d\\d-\\d\\d-\\d\\d \\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\d\\d\\d\\d \"\n            rf\"\\+\\d\\d\\d\\d\"\n        )\n        source, _ = read_data(\"expression.py\")\n        expected, _ = read_data(\"expression.diff\")\n        config = THIS_DIR / \"data\" / \"empty_pyproject.toml\"\n        args = [\n            \"-\",\n            \"--fast\",\n            f\"--line-length={black.DEFAULT_LINE_LENGTH}\",\n            \"--diff\",\n            f\"--config={config}\",\n        ]\n        result = BlackRunner().invoke(\n            black.main, args, input=BytesIO(source.encode(\"utf8\"))\n        )\n        self.assertEqual(result.exit_code, 0)\n        actual = diff_header.sub(DETERMINISTIC_HEADER, result.output)\n        actual = actual.rstrip() + \"\\n\"  # the diff output has a trailing space\n        self.assertEqual(expected, actual)",
        "begin_line": 244,
        "end_line": 265,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_piping_diff_with_color#267",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_piping_diff_with_color(self)",
        "snippet": "    def test_piping_diff_with_color(self) -> None:\n        source, _ = read_data(\"expression.py\")\n        config = THIS_DIR / \"data\" / \"empty_pyproject.toml\"\n        args = [\n            \"-\",\n            \"--fast\",\n            f\"--line-length={black.DEFAULT_LINE_LENGTH}\",\n            \"--diff\",\n            \"--color\",\n            f\"--config={config}\",\n        ]\n        result = BlackRunner().invoke(\n            black.main, args, input=BytesIO(source.encode(\"utf8\"))\n        )\n        actual = result.output\n        # Again, the contents are checked in a different test, so only look for colors.\n        self.assertIn(\"\\033[1;37m\", actual)\n        self.assertIn(\"\\033[36m\", actual)\n        self.assertIn(\"\\033[32m\", actual)\n        self.assertIn(\"\\033[31m\", actual)\n        self.assertIn(\"\\033[0m\", actual)",
        "begin_line": 267,
        "end_line": 287,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_function#290",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_function(self)",
        "snippet": "    def test_function(self) -> None:\n        source, expected = read_data(\"function\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 290,
        "end_line": 295,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_function2#298",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_function2(self)",
        "snippet": "    def test_function2(self) -> None:\n        source, expected = read_data(\"function2\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 298,
        "end_line": 303,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_function_trailing_comma#306",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_function_trailing_comma(self)",
        "snippet": "    def test_function_trailing_comma(self) -> None:\n        source, expected = read_data(\"function_trailing_comma\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 306,
        "end_line": 311,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_expression#314",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_expression(self)",
        "snippet": "    def test_expression(self) -> None:\n        source, expected = read_data(\"expression\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 314,
        "end_line": 319,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_pep_572#322",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_pep_572(self)",
        "snippet": "    def test_pep_572(self) -> None:\n        source, expected = read_data(\"pep_572\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_stable(source, actual, black.FileMode())\n        if sys.version_info >= (3, 8):\n            black.assert_equivalent(source, actual)",
        "begin_line": 322,
        "end_line": 328,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_pep_572_version_detection#330",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_pep_572_version_detection(self)",
        "snippet": "    def test_pep_572_version_detection(self) -> None:\n        source, _ = read_data(\"pep_572\")\n        root = black.lib2to3_parse(source)\n        features = black.get_features_used(root)\n        self.assertIn(black.Feature.ASSIGNMENT_EXPRESSIONS, features)\n        versions = black.detect_target_versions(root)\n        self.assertIn(black.TargetVersion.PY38, versions)",
        "begin_line": 330,
        "end_line": 336,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_expression_ff#338",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_expression_ff(self)",
        "snippet": "    def test_expression_ff(self) -> None:\n        source, expected = read_data(\"expression\")\n        tmp_file = Path(black.dump_to_file(source))\n        try:\n            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.YES))\n            with open(tmp_file, encoding=\"utf8\") as f:\n                actual = f.read()\n        finally:\n            os.unlink(tmp_file)\n        self.assertFormatEqual(expected, actual)\n        with patch(\"black.dump_to_file\", dump_to_stderr):\n            black.assert_equivalent(source, actual)\n            black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 338,
        "end_line": 350,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_expression_diff#352",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_expression_diff(self)",
        "snippet": "    def test_expression_diff(self) -> None:\n        source, _ = read_data(\"expression.py\")\n        expected, _ = read_data(\"expression.diff\")\n        tmp_file = Path(black.dump_to_file(source))\n        diff_header = re.compile(\n            rf\"{re.escape(str(tmp_file))}\\t\\d\\d\\d\\d-\\d\\d-\\d\\d \"\n            r\"\\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\d\\d\\d\\d \\+\\d\\d\\d\\d\"\n        )\n        try:\n            result = BlackRunner().invoke(black.main, [\"--diff\", str(tmp_file)])\n            self.assertEqual(result.exit_code, 0)\n        finally:\n            os.unlink(tmp_file)\n        actual = result.output\n        actual = diff_header.sub(DETERMINISTIC_HEADER, actual)\n        actual = actual.rstrip() + \"\\n\"  # the diff output has a trailing space\n        if expected != actual:\n            dump = black.dump_to_file(actual)\n            msg = (\n                \"Expected diff isn't equal to the actual. If you made changes to\"\n                \" expression.py and this is an anticipated difference, overwrite\"\n                f\" tests/data/expression.diff with {dump}\"\n            )\n            self.assertEqual(expected, actual, msg)",
        "begin_line": 352,
        "end_line": 375,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_expression_diff_with_color#377",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_expression_diff_with_color(self)",
        "snippet": "    def test_expression_diff_with_color(self) -> None:\n        source, _ = read_data(\"expression.py\")\n        expected, _ = read_data(\"expression.diff\")\n        tmp_file = Path(black.dump_to_file(source))\n        try:\n            result = BlackRunner().invoke(\n                black.main, [\"--diff\", \"--color\", str(tmp_file)]\n            )\n        finally:\n            os.unlink(tmp_file)\n        actual = result.output\n        # We check the contents of the diff in `test_expression_diff`. All\n        # we need to check here is that color codes exist in the result.\n        self.assertIn(\"\\033[1;37m\", actual)\n        self.assertIn(\"\\033[36m\", actual)\n        self.assertIn(\"\\033[32m\", actual)\n        self.assertIn(\"\\033[31m\", actual)\n        self.assertIn(\"\\033[0m\", actual)",
        "begin_line": 377,
        "end_line": 394,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_fstring#397",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_fstring(self)",
        "snippet": "    def test_fstring(self) -> None:\n        source, expected = read_data(\"fstring\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 397,
        "end_line": 402,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_pep_570#405",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_pep_570(self)",
        "snippet": "    def test_pep_570(self) -> None:\n        source, expected = read_data(\"pep_570\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_stable(source, actual, black.FileMode())\n        if sys.version_info >= (3, 8):\n            black.assert_equivalent(source, actual)",
        "begin_line": 405,
        "end_line": 411,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_detect_pos_only_arguments#413",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_detect_pos_only_arguments(self)",
        "snippet": "    def test_detect_pos_only_arguments(self) -> None:\n        source, _ = read_data(\"pep_570\")\n        root = black.lib2to3_parse(source)\n        features = black.get_features_used(root)\n        self.assertIn(black.Feature.POS_ONLY_ARGUMENTS, features)\n        versions = black.detect_target_versions(root)\n        self.assertIn(black.TargetVersion.PY38, versions)",
        "begin_line": 413,
        "end_line": 419,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_string_quotes#422",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_string_quotes(self)",
        "snippet": "    def test_string_quotes(self) -> None:\n        source, expected = read_data(\"string_quotes\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())\n        mode = black.FileMode(string_normalization=False)\n        not_normalized = fs(source, mode=mode)\n        self.assertFormatEqual(source.replace(\"\\\\\\n\", \"\"), not_normalized)\n        black.assert_equivalent(source, not_normalized)\n        black.assert_stable(source, not_normalized, mode=mode)",
        "begin_line": 422,
        "end_line": 432,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_docstring#435",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_docstring(self)",
        "snippet": "    def test_docstring(self) -> None:\n        source, expected = read_data(\"docstring\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 435,
        "end_line": 440,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_long_strings#442",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_long_strings(self)",
        "snippet": "    def test_long_strings(self) -> None:\n        \"\"\"Tests for splitting long strings.\"\"\"\n        source, expected = read_data(\"long_strings\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 442,
        "end_line": 448,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_long_strings__edge_case#451",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_long_strings__edge_case(self)",
        "snippet": "    def test_long_strings__edge_case(self) -> None:\n        \"\"\"Edge-case tests for splitting long strings.\"\"\"\n        source, expected = read_data(\"long_strings__edge_case\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 451,
        "end_line": 457,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_long_strings__regression#460",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_long_strings__regression(self)",
        "snippet": "    def test_long_strings__regression(self) -> None:\n        \"\"\"Regression tests for splitting long strings.\"\"\"\n        source, expected = read_data(\"long_strings__regression\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 460,
        "end_line": 466,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_slices#469",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_slices(self)",
        "snippet": "    def test_slices(self) -> None:\n        source, expected = read_data(\"slices\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 469,
        "end_line": 474,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_comments#477",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_comments(self)",
        "snippet": "    def test_comments(self) -> None:\n        source, expected = read_data(\"comments\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 477,
        "end_line": 482,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_comments2#485",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_comments2(self)",
        "snippet": "    def test_comments2(self) -> None:\n        source, expected = read_data(\"comments2\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 485,
        "end_line": 490,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_comments3#493",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_comments3(self)",
        "snippet": "    def test_comments3(self) -> None:\n        source, expected = read_data(\"comments3\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 493,
        "end_line": 498,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_comments4#501",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_comments4(self)",
        "snippet": "    def test_comments4(self) -> None:\n        source, expected = read_data(\"comments4\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 501,
        "end_line": 506,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_comments5#509",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_comments5(self)",
        "snippet": "    def test_comments5(self) -> None:\n        source, expected = read_data(\"comments5\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 509,
        "end_line": 514,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_comments6#517",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_comments6(self)",
        "snippet": "    def test_comments6(self) -> None:\n        source, expected = read_data(\"comments6\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 517,
        "end_line": 522,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_comments7#525",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_comments7(self)",
        "snippet": "    def test_comments7(self) -> None:\n        source, expected = read_data(\"comments7\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 525,
        "end_line": 530,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_comment_after_escaped_newline#533",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_comment_after_escaped_newline(self)",
        "snippet": "    def test_comment_after_escaped_newline(self) -> None:\n        source, expected = read_data(\"comment_after_escaped_newline\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 533,
        "end_line": 538,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_cantfit#541",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_cantfit(self)",
        "snippet": "    def test_cantfit(self) -> None:\n        source, expected = read_data(\"cantfit\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 541,
        "end_line": 546,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_import_spacing#549",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_import_spacing(self)",
        "snippet": "    def test_import_spacing(self) -> None:\n        source, expected = read_data(\"import_spacing\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 549,
        "end_line": 554,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_composition#557",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_composition(self)",
        "snippet": "    def test_composition(self) -> None:\n        source, expected = read_data(\"composition\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 557,
        "end_line": 562,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_empty_lines#565",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_empty_lines(self)",
        "snippet": "    def test_empty_lines(self) -> None:\n        source, expected = read_data(\"empty_lines\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 565,
        "end_line": 570,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_remove_parens#573",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_remove_parens(self)",
        "snippet": "    def test_remove_parens(self) -> None:\n        source, expected = read_data(\"remove_parens\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 573,
        "end_line": 578,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_string_prefixes#581",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_string_prefixes(self)",
        "snippet": "    def test_string_prefixes(self) -> None:\n        source, expected = read_data(\"string_prefixes\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 581,
        "end_line": 586,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_numeric_literals#589",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_numeric_literals(self)",
        "snippet": "    def test_numeric_literals(self) -> None:\n        source, expected = read_data(\"numeric_literals\")\n        mode = black.FileMode(target_versions=black.PY36_VERSIONS)\n        actual = fs(source, mode=mode)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, mode)",
        "begin_line": 589,
        "end_line": 595,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_numeric_literals_ignoring_underscores#598",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_numeric_literals_ignoring_underscores(self)",
        "snippet": "    def test_numeric_literals_ignoring_underscores(self) -> None:\n        source, expected = read_data(\"numeric_literals_skip_underscores\")\n        mode = black.FileMode(target_versions=black.PY36_VERSIONS)\n        actual = fs(source, mode=mode)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, mode)",
        "begin_line": 598,
        "end_line": 604,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_numeric_literals_py2#607",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_numeric_literals_py2(self)",
        "snippet": "    def test_numeric_literals_py2(self) -> None:\n        source, expected = read_data(\"numeric_literals_py2\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 607,
        "end_line": 611,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_python2#614",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_python2(self)",
        "snippet": "    def test_python2(self) -> None:\n        source, expected = read_data(\"python2\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 614,
        "end_line": 619,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_python2_print_function#622",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_python2_print_function(self)",
        "snippet": "    def test_python2_print_function(self) -> None:\n        source, expected = read_data(\"python2_print_function\")\n        mode = black.FileMode(target_versions={TargetVersion.PY27})\n        actual = fs(source, mode=mode)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, mode)",
        "begin_line": 622,
        "end_line": 628,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_python2_unicode_literals#631",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_python2_unicode_literals(self)",
        "snippet": "    def test_python2_unicode_literals(self) -> None:\n        source, expected = read_data(\"python2_unicode_literals\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 631,
        "end_line": 636,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_stub#639",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_stub(self)",
        "snippet": "    def test_stub(self) -> None:\n        mode = black.FileMode(is_pyi=True)\n        source, expected = read_data(\"stub.pyi\")\n        actual = fs(source, mode=mode)\n        self.assertFormatEqual(expected, actual)\n        black.assert_stable(source, actual, mode)",
        "begin_line": 639,
        "end_line": 644,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_async_as_identifier#647",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_async_as_identifier(self)",
        "snippet": "    def test_async_as_identifier(self) -> None:\n        source_path = (THIS_DIR / \"data\" / \"async_as_identifier.py\").resolve()\n        source, expected = read_data(\"async_as_identifier\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        major, minor = sys.version_info[:2]\n        if major < 3 or (major <= 3 and minor < 7):\n            black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())\n        # ensure black can parse this when the target is 3.6\n        self.invokeBlack([str(source_path), \"--target-version\", \"py36\"])\n        # but not on 3.7, because async/await is no longer an identifier\n        self.invokeBlack([str(source_path), \"--target-version\", \"py37\"], exit_code=123)",
        "begin_line": 647,
        "end_line": 659,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_python37#662",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_python37(self)",
        "snippet": "    def test_python37(self) -> None:\n        source_path = (THIS_DIR / \"data\" / \"python37.py\").resolve()\n        source, expected = read_data(\"python37\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        major, minor = sys.version_info[:2]\n        if major > 3 or (major == 3 and minor >= 7):\n            black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())\n        # ensure black can parse this when the target is 3.7\n        self.invokeBlack([str(source_path), \"--target-version\", \"py37\"])\n        # but not on 3.6, because we use async as a reserved keyword\n        self.invokeBlack([str(source_path), \"--target-version\", \"py36\"], exit_code=123)",
        "begin_line": 662,
        "end_line": 674,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_python38#677",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_python38(self)",
        "snippet": "    def test_python38(self) -> None:\n        source, expected = read_data(\"python38\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        major, minor = sys.version_info[:2]\n        if major > 3 or (major == 3 and minor >= 8):\n            black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 677,
        "end_line": 684,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_fmtonoff#687",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_fmtonoff(self)",
        "snippet": "    def test_fmtonoff(self) -> None:\n        source, expected = read_data(\"fmtonoff\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 687,
        "end_line": 692,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_fmtonoff2#695",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_fmtonoff2(self)",
        "snippet": "    def test_fmtonoff2(self) -> None:\n        source, expected = read_data(\"fmtonoff2\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 695,
        "end_line": 700,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_fmtonoff3#703",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_fmtonoff3(self)",
        "snippet": "    def test_fmtonoff3(self) -> None:\n        source, expected = read_data(\"fmtonoff3\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 703,
        "end_line": 708,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_fmtonoff4#711",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_fmtonoff4(self)",
        "snippet": "    def test_fmtonoff4(self) -> None:\n        source, expected = read_data(\"fmtonoff4\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 711,
        "end_line": 716,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_remove_empty_parentheses_after_class#719",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_remove_empty_parentheses_after_class(self)",
        "snippet": "    def test_remove_empty_parentheses_after_class(self) -> None:\n        source, expected = read_data(\"class_blank_parentheses\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 719,
        "end_line": 724,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_new_line_between_class_and_code#727",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_new_line_between_class_and_code(self)",
        "snippet": "    def test_new_line_between_class_and_code(self) -> None:\n        source, expected = read_data(\"class_methods_new_line\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 727,
        "end_line": 732,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_bracket_match#735",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_bracket_match(self)",
        "snippet": "    def test_bracket_match(self) -> None:\n        source, expected = read_data(\"bracketmatch\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 735,
        "end_line": 740,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_tuple_assign#743",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_tuple_assign(self)",
        "snippet": "    def test_tuple_assign(self) -> None:\n        source, expected = read_data(\"tupleassign\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 743,
        "end_line": 748,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_beginning_backslash#751",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_beginning_backslash(self)",
        "snippet": "    def test_beginning_backslash(self) -> None:\n        source, expected = read_data(\"beginning_backslash\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 751,
        "end_line": 756,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_tab_comment_indentation#758",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_tab_comment_indentation(self)",
        "snippet": "    def test_tab_comment_indentation(self) -> None:\n        contents_tab = \"if 1:\\n\\tif 2:\\n\\t\\tpass\\n\\t# comment\\n\\tpass\\n\"\n        contents_spc = \"if 1:\\n    if 2:\\n        pass\\n    # comment\\n    pass\\n\"\n        self.assertFormatEqual(contents_spc, fs(contents_spc))\n        self.assertFormatEqual(contents_spc, fs(contents_tab))\n\n        contents_tab = \"if 1:\\n\\tif 2:\\n\\t\\tpass\\n\\t\\t# comment\\n\\tpass\\n\"\n        contents_spc = \"if 1:\\n    if 2:\\n        pass\\n        # comment\\n    pass\\n\"\n        self.assertFormatEqual(contents_spc, fs(contents_spc))\n        self.assertFormatEqual(contents_spc, fs(contents_tab))\n\n        # mixed tabs and spaces (valid Python 2 code)\n        contents_tab = \"if 1:\\n        if 2:\\n\\t\\tpass\\n\\t# comment\\n        pass\\n\"\n        contents_spc = \"if 1:\\n    if 2:\\n        pass\\n    # comment\\n    pass\\n\"\n        self.assertFormatEqual(contents_spc, fs(contents_spc))\n        self.assertFormatEqual(contents_spc, fs(contents_tab))\n\n        contents_tab = \"if 1:\\n        if 2:\\n\\t\\tpass\\n\\t\\t# comment\\n        pass\\n\"\n        contents_spc = \"if 1:\\n    if 2:\\n        pass\\n        # comment\\n    pass\\n\"\n        self.assertFormatEqual(contents_spc, fs(contents_spc))\n        self.assertFormatEqual(contents_spc, fs(contents_tab))",
        "begin_line": 758,
        "end_line": 778,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_report_verbose#780",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_report_verbose(self)",
        "snippet": "    def test_report_verbose(self) -> None:\n        report = black.Report(verbose=True)\n        out_lines = []\n        err_lines = []\n\n        def out(msg: str, **kwargs: Any) -> None:\n            out_lines.append(msg)\n\n        def err(msg: str, **kwargs: Any) -> None:\n            err_lines.append(msg)\n\n        with patch(\"black.out\", out), patch(\"black.err\", err):\n            report.done(Path(\"f1\"), black.Changed.NO)\n            self.assertEqual(len(out_lines), 1)\n            self.assertEqual(len(err_lines), 0)\n            self.assertEqual(out_lines[-1], \"f1 already well formatted, good job.\")\n            self.assertEqual(unstyle(str(report)), \"1 file left unchanged.\")\n            self.assertEqual(report.return_code, 0)\n            report.done(Path(\"f2\"), black.Changed.YES)\n            self.assertEqual(len(out_lines), 2)\n            self.assertEqual(len(err_lines), 0)\n            self.assertEqual(out_lines[-1], \"reformatted f2\")\n            self.assertEqual(\n                unstyle(str(report)), \"1 file reformatted, 1 file left unchanged.\"\n            )\n            report.done(Path(\"f3\"), black.Changed.CACHED)\n            self.assertEqual(len(out_lines), 3)\n            self.assertEqual(len(err_lines), 0)\n            self.assertEqual(\n                out_lines[-1], \"f3 wasn't modified on disk since last run.\"\n            )\n            self.assertEqual(\n                unstyle(str(report)), \"1 file reformatted, 2 files left unchanged.\"\n            )\n            self.assertEqual(report.return_code, 0)\n            report.check = True\n            self.assertEqual(report.return_code, 1)\n            report.check = False\n            report.failed(Path(\"e1\"), \"boom\")\n            self.assertEqual(len(out_lines), 3)\n            self.assertEqual(len(err_lines), 1)\n            self.assertEqual(err_lines[-1], \"error: cannot format e1: boom\")\n            self.assertEqual(\n                unstyle(str(report)),\n                \"1 file reformatted, 2 files left unchanged, 1 file failed to\"\n                \" reformat.\",\n            )\n            self.assertEqual(report.return_code, 123)\n            report.done(Path(\"f3\"), black.Changed.YES)\n            self.assertEqual(len(out_lines), 4)\n            self.assertEqual(len(err_lines), 1)\n            self.assertEqual(out_lines[-1], \"reformatted f3\")\n            self.assertEqual(\n                unstyle(str(report)),\n                \"2 files reformatted, 2 files left unchanged, 1 file failed to\"\n                \" reformat.\",\n            )\n            self.assertEqual(report.return_code, 123)\n            report.failed(Path(\"e2\"), \"boom\")\n            self.assertEqual(len(out_lines), 4)\n            self.assertEqual(len(err_lines), 2)\n            self.assertEqual(err_lines[-1], \"error: cannot format e2: boom\")\n            self.assertEqual(\n                unstyle(str(report)),\n                \"2 files reformatted, 2 files left unchanged, 2 files failed to\"\n                \" reformat.\",\n            )\n            self.assertEqual(report.return_code, 123)\n            report.path_ignored(Path(\"wat\"), \"no match\")\n            self.assertEqual(len(out_lines), 5)\n            self.assertEqual(len(err_lines), 2)\n            self.assertEqual(out_lines[-1], \"wat ignored: no match\")\n            self.assertEqual(\n                unstyle(str(report)),\n                \"2 files reformatted, 2 files left unchanged, 2 files failed to\"\n                \" reformat.\",\n            )\n            self.assertEqual(report.return_code, 123)\n            report.done(Path(\"f4\"), black.Changed.NO)\n            self.assertEqual(len(out_lines), 6)\n            self.assertEqual(len(err_lines), 2)\n            self.assertEqual(out_lines[-1], \"f4 already well formatted, good job.\")\n            self.assertEqual(\n                unstyle(str(report)),\n                \"2 files reformatted, 3 files left unchanged, 2 files failed to\"\n                \" reformat.\",\n            )\n            self.assertEqual(report.return_code, 123)\n            report.check = True\n            self.assertEqual(\n                unstyle(str(report)),\n                \"2 files would be reformatted, 3 files would be left unchanged, 2 files\"\n                \" would fail to reformat.\",\n            )\n            report.check = False\n            report.diff = True\n            self.assertEqual(\n                unstyle(str(report)),\n                \"2 files would be reformatted, 3 files would be left unchanged, 2 files\"\n                \" would fail to reformat.\",\n            )",
        "begin_line": 780,
        "end_line": 880,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.out#785",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.out(msg: str, **kwargs: Any)",
        "snippet": "        def out(msg: str, **kwargs: Any) -> None:\n            out_lines.append(msg)",
        "begin_line": 785,
        "end_line": 786,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.err#788",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.err(msg: str, **kwargs: Any)",
        "snippet": "        def err(msg: str, **kwargs: Any) -> None:\n            err_lines.append(msg)",
        "begin_line": 788,
        "end_line": 789,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_report_quiet#882",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_report_quiet(self)",
        "snippet": "    def test_report_quiet(self) -> None:\n        report = black.Report(quiet=True)\n        out_lines = []\n        err_lines = []\n\n        def out(msg: str, **kwargs: Any) -> None:\n            out_lines.append(msg)\n\n        def err(msg: str, **kwargs: Any) -> None:\n            err_lines.append(msg)\n\n        with patch(\"black.out\", out), patch(\"black.err\", err):\n            report.done(Path(\"f1\"), black.Changed.NO)\n            self.assertEqual(len(out_lines), 0)\n            self.assertEqual(len(err_lines), 0)\n            self.assertEqual(unstyle(str(report)), \"1 file left unchanged.\")\n            self.assertEqual(report.return_code, 0)\n            report.done(Path(\"f2\"), black.Changed.YES)\n            self.assertEqual(len(out_lines), 0)\n            self.assertEqual(len(err_lines), 0)\n            self.assertEqual(\n                unstyle(str(report)), \"1 file reformatted, 1 file left unchanged.\"\n            )\n            report.done(Path(\"f3\"), black.Changed.CACHED)\n            self.assertEqual(len(out_lines), 0)\n            self.assertEqual(len(err_lines), 0)\n            self.assertEqual(\n                unstyle(str(report)), \"1 file reformatted, 2 files left unchanged.\"\n            )\n            self.assertEqual(report.return_code, 0)\n            report.check = True\n            self.assertEqual(report.return_code, 1)\n            report.check = False\n            report.failed(Path(\"e1\"), \"boom\")\n            self.assertEqual(len(out_lines), 0)\n            self.assertEqual(len(err_lines), 1)\n            self.assertEqual(err_lines[-1], \"error: cannot format e1: boom\")\n            self.assertEqual(\n                unstyle(str(report)),\n                \"1 file reformatted, 2 files left unchanged, 1 file failed to\"\n                \" reformat.\",\n            )\n            self.assertEqual(report.return_code, 123)\n            report.done(Path(\"f3\"), black.Changed.YES)\n            self.assertEqual(len(out_lines), 0)\n            self.assertEqual(len(err_lines), 1)\n            self.assertEqual(\n                unstyle(str(report)),\n                \"2 files reformatted, 2 files left unchanged, 1 file failed to\"\n                \" reformat.\",\n            )\n            self.assertEqual(report.return_code, 123)\n            report.failed(Path(\"e2\"), \"boom\")\n            self.assertEqual(len(out_lines), 0)\n            self.assertEqual(len(err_lines), 2)\n            self.assertEqual(err_lines[-1], \"error: cannot format e2: boom\")\n            self.assertEqual(\n                unstyle(str(report)),\n                \"2 files reformatted, 2 files left unchanged, 2 files failed to\"\n                \" reformat.\",\n            )\n            self.assertEqual(report.return_code, 123)\n            report.path_ignored(Path(\"wat\"), \"no match\")\n            self.assertEqual(len(out_lines), 0)\n            self.assertEqual(len(err_lines), 2)\n            self.assertEqual(\n                unstyle(str(report)),\n                \"2 files reformatted, 2 files left unchanged, 2 files failed to\"\n                \" reformat.\",\n            )\n            self.assertEqual(report.return_code, 123)\n            report.done(Path(\"f4\"), black.Changed.NO)\n            self.assertEqual(len(out_lines), 0)\n            self.assertEqual(len(err_lines), 2)\n            self.assertEqual(\n                unstyle(str(report)),\n                \"2 files reformatted, 3 files left unchanged, 2 files failed to\"\n                \" reformat.\",\n            )\n            self.assertEqual(report.return_code, 123)\n            report.check = True\n            self.assertEqual(\n                unstyle(str(report)),\n                \"2 files would be reformatted, 3 files would be left unchanged, 2 files\"\n                \" would fail to reformat.\",\n            )\n            report.check = False\n            report.diff = True\n            self.assertEqual(\n                unstyle(str(report)),\n                \"2 files would be reformatted, 3 files would be left unchanged, 2 files\"\n                \" would fail to reformat.\",\n            )",
        "begin_line": 882,
        "end_line": 974,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.out#887",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.out(msg: str, **kwargs: Any)",
        "snippet": "        def out(msg: str, **kwargs: Any) -> None:\n            out_lines.append(msg)",
        "begin_line": 887,
        "end_line": 888,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.err#890",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.err(msg: str, **kwargs: Any)",
        "snippet": "        def err(msg: str, **kwargs: Any) -> None:\n            err_lines.append(msg)",
        "begin_line": 890,
        "end_line": 891,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_report_normal#976",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_report_normal(self)",
        "snippet": "    def test_report_normal(self) -> None:\n        report = black.Report()\n        out_lines = []\n        err_lines = []\n\n        def out(msg: str, **kwargs: Any) -> None:\n            out_lines.append(msg)\n\n        def err(msg: str, **kwargs: Any) -> None:\n            err_lines.append(msg)\n\n        with patch(\"black.out\", out), patch(\"black.err\", err):\n            report.done(Path(\"f1\"), black.Changed.NO)\n            self.assertEqual(len(out_lines), 0)\n            self.assertEqual(len(err_lines), 0)\n            self.assertEqual(unstyle(str(report)), \"1 file left unchanged.\")\n            self.assertEqual(report.return_code, 0)\n            report.done(Path(\"f2\"), black.Changed.YES)\n            self.assertEqual(len(out_lines), 1)\n            self.assertEqual(len(err_lines), 0)\n            self.assertEqual(out_lines[-1], \"reformatted f2\")\n            self.assertEqual(\n                unstyle(str(report)), \"1 file reformatted, 1 file left unchanged.\"\n            )\n            report.done(Path(\"f3\"), black.Changed.CACHED)\n            self.assertEqual(len(out_lines), 1)\n            self.assertEqual(len(err_lines), 0)\n            self.assertEqual(out_lines[-1], \"reformatted f2\")\n            self.assertEqual(\n                unstyle(str(report)), \"1 file reformatted, 2 files left unchanged.\"\n            )\n            self.assertEqual(report.return_code, 0)\n            report.check = True\n            self.assertEqual(report.return_code, 1)\n            report.check = False\n            report.failed(Path(\"e1\"), \"boom\")\n            self.assertEqual(len(out_lines), 1)\n            self.assertEqual(len(err_lines), 1)\n            self.assertEqual(err_lines[-1], \"error: cannot format e1: boom\")\n            self.assertEqual(\n                unstyle(str(report)),\n                \"1 file reformatted, 2 files left unchanged, 1 file failed to\"\n                \" reformat.\",\n            )\n            self.assertEqual(report.return_code, 123)\n            report.done(Path(\"f3\"), black.Changed.YES)\n            self.assertEqual(len(out_lines), 2)\n            self.assertEqual(len(err_lines), 1)\n            self.assertEqual(out_lines[-1], \"reformatted f3\")\n            self.assertEqual(\n                unstyle(str(report)),\n                \"2 files reformatted, 2 files left unchanged, 1 file failed to\"\n                \" reformat.\",\n            )\n            self.assertEqual(report.return_code, 123)\n            report.failed(Path(\"e2\"), \"boom\")\n            self.assertEqual(len(out_lines), 2)\n            self.assertEqual(len(err_lines), 2)\n            self.assertEqual(err_lines[-1], \"error: cannot format e2: boom\")\n            self.assertEqual(\n                unstyle(str(report)),\n                \"2 files reformatted, 2 files left unchanged, 2 files failed to\"\n                \" reformat.\",\n            )\n            self.assertEqual(report.return_code, 123)\n            report.path_ignored(Path(\"wat\"), \"no match\")\n            self.assertEqual(len(out_lines), 2)\n            self.assertEqual(len(err_lines), 2)\n            self.assertEqual(\n                unstyle(str(report)),\n                \"2 files reformatted, 2 files left unchanged, 2 files failed to\"\n                \" reformat.\",\n            )\n            self.assertEqual(report.return_code, 123)\n            report.done(Path(\"f4\"), black.Changed.NO)\n            self.assertEqual(len(out_lines), 2)\n            self.assertEqual(len(err_lines), 2)\n            self.assertEqual(\n                unstyle(str(report)),\n                \"2 files reformatted, 3 files left unchanged, 2 files failed to\"\n                \" reformat.\",\n            )\n            self.assertEqual(report.return_code, 123)\n            report.check = True\n            self.assertEqual(\n                unstyle(str(report)),\n                \"2 files would be reformatted, 3 files would be left unchanged, 2 files\"\n                \" would fail to reformat.\",\n            )\n            report.check = False\n            report.diff = True\n            self.assertEqual(\n                unstyle(str(report)),\n                \"2 files would be reformatted, 3 files would be left unchanged, 2 files\"\n                \" would fail to reformat.\",\n            )",
        "begin_line": 976,
        "end_line": 1071,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.out#981",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.out(msg: str, **kwargs: Any)",
        "snippet": "        def out(msg: str, **kwargs: Any) -> None:\n            out_lines.append(msg)",
        "begin_line": 981,
        "end_line": 982,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.err#984",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.err(msg: str, **kwargs: Any)",
        "snippet": "        def err(msg: str, **kwargs: Any) -> None:\n            err_lines.append(msg)",
        "begin_line": 984,
        "end_line": 985,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_lib2to3_parse#1073",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_lib2to3_parse(self)",
        "snippet": "    def test_lib2to3_parse(self) -> None:\n        with self.assertRaises(black.InvalidInput):\n            black.lib2to3_parse(\"invalid syntax\")\n\n        straddling = \"x + y\"\n        black.lib2to3_parse(straddling)\n        black.lib2to3_parse(straddling, {TargetVersion.PY27})\n        black.lib2to3_parse(straddling, {TargetVersion.PY36})\n        black.lib2to3_parse(straddling, {TargetVersion.PY27, TargetVersion.PY36})\n\n        py2_only = \"print x\"\n        black.lib2to3_parse(py2_only)\n        black.lib2to3_parse(py2_only, {TargetVersion.PY27})\n        with self.assertRaises(black.InvalidInput):\n            black.lib2to3_parse(py2_only, {TargetVersion.PY36})\n        with self.assertRaises(black.InvalidInput):\n            black.lib2to3_parse(py2_only, {TargetVersion.PY27, TargetVersion.PY36})\n\n        py3_only = \"exec(x, end=y)\"\n        black.lib2to3_parse(py3_only)\n        with self.assertRaises(black.InvalidInput):\n            black.lib2to3_parse(py3_only, {TargetVersion.PY27})\n        black.lib2to3_parse(py3_only, {TargetVersion.PY36})\n        black.lib2to3_parse(py3_only, {TargetVersion.PY27, TargetVersion.PY36})",
        "begin_line": 1073,
        "end_line": 1096,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_get_features_used#1098",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_get_features_used(self)",
        "snippet": "    def test_get_features_used(self) -> None:\n        node = black.lib2to3_parse(\"def f(*, arg): ...\\n\")\n        self.assertEqual(black.get_features_used(node), set())\n        node = black.lib2to3_parse(\"def f(*, arg,): ...\\n\")\n        self.assertEqual(black.get_features_used(node), {Feature.TRAILING_COMMA_IN_DEF})\n        node = black.lib2to3_parse(\"f(*arg,)\\n\")\n        self.assertEqual(\n            black.get_features_used(node), {Feature.TRAILING_COMMA_IN_CALL}\n        )\n        node = black.lib2to3_parse(\"def f(*, arg): f'string'\\n\")\n        self.assertEqual(black.get_features_used(node), {Feature.F_STRINGS})\n        node = black.lib2to3_parse(\"123_456\\n\")\n        self.assertEqual(black.get_features_used(node), {Feature.NUMERIC_UNDERSCORES})\n        node = black.lib2to3_parse(\"123456\\n\")\n        self.assertEqual(black.get_features_used(node), set())\n        source, expected = read_data(\"function\")\n        node = black.lib2to3_parse(source)\n        expected_features = {\n            Feature.TRAILING_COMMA_IN_CALL,\n            Feature.TRAILING_COMMA_IN_DEF,\n            Feature.F_STRINGS,\n        }\n        self.assertEqual(black.get_features_used(node), expected_features)\n        node = black.lib2to3_parse(expected)\n        self.assertEqual(black.get_features_used(node), expected_features)\n        source, expected = read_data(\"expression\")\n        node = black.lib2to3_parse(source)\n        self.assertEqual(black.get_features_used(node), set())\n        node = black.lib2to3_parse(expected)\n        self.assertEqual(black.get_features_used(node), set())",
        "begin_line": 1098,
        "end_line": 1127,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_get_future_imports#1129",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_get_future_imports(self)",
        "snippet": "    def test_get_future_imports(self) -> None:\n        node = black.lib2to3_parse(\"\\n\")\n        self.assertEqual(set(), black.get_future_imports(node))\n        node = black.lib2to3_parse(\"from __future__ import black\\n\")\n        self.assertEqual({\"black\"}, black.get_future_imports(node))\n        node = black.lib2to3_parse(\"from __future__ import multiple, imports\\n\")\n        self.assertEqual({\"multiple\", \"imports\"}, black.get_future_imports(node))\n        node = black.lib2to3_parse(\"from __future__ import (parenthesized, imports)\\n\")\n        self.assertEqual({\"parenthesized\", \"imports\"}, black.get_future_imports(node))\n        node = black.lib2to3_parse(\n            \"from __future__ import multiple\\nfrom __future__ import imports\\n\"\n        )\n        self.assertEqual({\"multiple\", \"imports\"}, black.get_future_imports(node))\n        node = black.lib2to3_parse(\"# comment\\nfrom __future__ import black\\n\")\n        self.assertEqual({\"black\"}, black.get_future_imports(node))\n        node = black.lib2to3_parse('\"\"\"docstring\"\"\"\\nfrom __future__ import black\\n')\n        self.assertEqual({\"black\"}, black.get_future_imports(node))\n        node = black.lib2to3_parse(\"some(other, code)\\nfrom __future__ import black\\n\")\n        self.assertEqual(set(), black.get_future_imports(node))\n        node = black.lib2to3_parse(\"from some.module import black\\n\")\n        self.assertEqual(set(), black.get_future_imports(node))\n        node = black.lib2to3_parse(\n            \"from __future__ import unicode_literals as _unicode_literals\"\n        )\n        self.assertEqual({\"unicode_literals\"}, black.get_future_imports(node))\n        node = black.lib2to3_parse(\n            \"from __future__ import unicode_literals as _lol, print\"\n        )\n        self.assertEqual({\"unicode_literals\", \"print\"}, black.get_future_imports(node))",
        "begin_line": 1129,
        "end_line": 1157,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_debug_visitor#1159",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_debug_visitor(self)",
        "snippet": "    def test_debug_visitor(self) -> None:\n        source, _ = read_data(\"debug_visitor.py\")\n        expected, _ = read_data(\"debug_visitor.out\")\n        out_lines = []\n        err_lines = []\n\n        def out(msg: str, **kwargs: Any) -> None:\n            out_lines.append(msg)\n\n        def err(msg: str, **kwargs: Any) -> None:\n            err_lines.append(msg)\n\n        with patch(\"black.out\", out), patch(\"black.err\", err):\n            black.DebugVisitor.show(source)\n        actual = \"\\n\".join(out_lines) + \"\\n\"\n        log_name = \"\"\n        if expected != actual:\n            log_name = black.dump_to_file(*out_lines)\n        self.assertEqual(\n            expected,\n            actual,\n            f\"AST print out is different. Actual version dumped to {log_name}\",\n        )",
        "begin_line": 1159,
        "end_line": 1181,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.out#1165",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.out(msg: str, **kwargs: Any)",
        "snippet": "        def out(msg: str, **kwargs: Any) -> None:\n            out_lines.append(msg)",
        "begin_line": 1165,
        "end_line": 1166,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.err#1168",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.err(msg: str, **kwargs: Any)",
        "snippet": "        def err(msg: str, **kwargs: Any) -> None:\n            err_lines.append(msg)",
        "begin_line": 1168,
        "end_line": 1169,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_format_file_contents#1183",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_format_file_contents(self)",
        "snippet": "    def test_format_file_contents(self) -> None:\n        empty = \"\"\n        mode = black.FileMode()\n        with self.assertRaises(black.NothingChanged):\n            black.format_file_contents(empty, mode=mode, fast=False)\n        just_nl = \"\\n\"\n        with self.assertRaises(black.NothingChanged):\n            black.format_file_contents(just_nl, mode=mode, fast=False)\n        same = \"j = [1, 2, 3]\\n\"\n        with self.assertRaises(black.NothingChanged):\n            black.format_file_contents(same, mode=mode, fast=False)\n        different = \"j = [1,2,3]\"\n        expected = same\n        actual = black.format_file_contents(different, mode=mode, fast=False)\n        self.assertEqual(expected, actual)\n        invalid = \"return if you can\"\n        with self.assertRaises(black.InvalidInput) as e:\n            black.format_file_contents(invalid, mode=mode, fast=False)\n        self.assertEqual(str(e.exception), \"Cannot parse: 1:7: return if you can\")",
        "begin_line": 1183,
        "end_line": 1201,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_endmarker#1203",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_endmarker(self)",
        "snippet": "    def test_endmarker(self) -> None:\n        n = black.lib2to3_parse(\"\\n\")\n        self.assertEqual(n.type, black.syms.file_input)\n        self.assertEqual(len(n.children), 1)\n        self.assertEqual(n.children[0].type, black.token.ENDMARKER)",
        "begin_line": 1203,
        "end_line": 1207,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_assertFormatEqual#1210",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_assertFormatEqual(self)",
        "snippet": "    def test_assertFormatEqual(self) -> None:\n        out_lines = []\n        err_lines = []\n\n        def out(msg: str, **kwargs: Any) -> None:\n            out_lines.append(msg)\n\n        def err(msg: str, **kwargs: Any) -> None:\n            err_lines.append(msg)\n\n        with patch(\"black.out\", out), patch(\"black.err\", err):\n            with self.assertRaises(AssertionError):\n                self.assertFormatEqual(\"j = [1, 2, 3]\", \"j = [1, 2, 3,]\")\n\n        out_str = \"\".join(out_lines)\n        self.assertTrue(\"Expected tree:\" in out_str)\n        self.assertTrue(\"Actual tree:\" in out_str)\n        self.assertEqual(\"\".join(err_lines), \"\")",
        "begin_line": 1210,
        "end_line": 1227,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.out#1214",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.out(msg: str, **kwargs: Any)",
        "snippet": "        def out(msg: str, **kwargs: Any) -> None:\n            out_lines.append(msg)",
        "begin_line": 1214,
        "end_line": 1215,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.err#1217",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.err(msg: str, **kwargs: Any)",
        "snippet": "        def err(msg: str, **kwargs: Any) -> None:\n            err_lines.append(msg)",
        "begin_line": 1217,
        "end_line": 1218,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_cache_broken_file#1229",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_cache_broken_file(self)",
        "snippet": "    def test_cache_broken_file(self) -> None:\n        mode = black.FileMode()\n        with cache_dir() as workspace:\n            cache_file = black.get_cache_file(mode)\n            with cache_file.open(\"w\") as fobj:\n                fobj.write(\"this is not a pickle\")\n            self.assertEqual(black.read_cache(mode), {})\n            src = (workspace / \"test.py\").resolve()\n            with src.open(\"w\") as fobj:\n                fobj.write(\"print('hello')\")\n            self.invokeBlack([str(src)])\n            cache = black.read_cache(mode)\n            self.assertIn(src, cache)",
        "begin_line": 1229,
        "end_line": 1241,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_cache_single_file_already_cached#1243",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_cache_single_file_already_cached(self)",
        "snippet": "    def test_cache_single_file_already_cached(self) -> None:\n        mode = black.FileMode()\n        with cache_dir() as workspace:\n            src = (workspace / \"test.py\").resolve()\n            with src.open(\"w\") as fobj:\n                fobj.write(\"print('hello')\")\n            black.write_cache({}, [src], mode)\n            self.invokeBlack([str(src)])\n            with src.open(\"r\") as fobj:\n                self.assertEqual(fobj.read(), \"print('hello')\")",
        "begin_line": 1243,
        "end_line": 1252,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_cache_multiple_files#1255",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_cache_multiple_files(self)",
        "snippet": "    def test_cache_multiple_files(self) -> None:\n        mode = black.FileMode()\n        with cache_dir() as workspace, patch(\n            \"black.ProcessPoolExecutor\", new=ThreadPoolExecutor\n        ):\n            one = (workspace / \"one.py\").resolve()\n            with one.open(\"w\") as fobj:\n                fobj.write(\"print('hello')\")\n            two = (workspace / \"two.py\").resolve()\n            with two.open(\"w\") as fobj:\n                fobj.write(\"print('hello')\")\n            black.write_cache({}, [one], mode)\n            self.invokeBlack([str(workspace)])\n            with one.open(\"r\") as fobj:\n                self.assertEqual(fobj.read(), \"print('hello')\")\n            with two.open(\"r\") as fobj:\n                self.assertEqual(fobj.read(), 'print(\"hello\")\\n')\n            cache = black.read_cache(mode)\n            self.assertIn(one, cache)\n            self.assertIn(two, cache)",
        "begin_line": 1255,
        "end_line": 1274,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_works_in_mono_process_only_environment#1277",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_works_in_mono_process_only_environment(self, mock_executor)",
        "snippet": "    def test_works_in_mono_process_only_environment(self, mock_executor) -> None:\n        mock_executor.side_effect = OSError()\n        mode = black.FileMode()\n        with cache_dir() as workspace:\n            one = (workspace / \"one.py\").resolve()\n            with one.open(\"w\") as fobj:\n                fobj.write(\"print('hello')\")\n            two = (workspace / \"two.py\").resolve()\n            with two.open(\"w\") as fobj:\n                fobj.write(\"print('hello')\")\n            black.write_cache({}, [one], mode)\n            self.invokeBlack([str(workspace)])\n            with one.open(\"r\") as fobj:\n                self.assertEqual(fobj.read(), \"print('hello')\")\n            with two.open(\"r\") as fobj:\n                self.assertEqual(fobj.read(), 'print(\"hello\")\\n')\n            cache = black.read_cache(mode)\n            self.assertIn(one, cache)\n            self.assertIn(two, cache)",
        "begin_line": 1277,
        "end_line": 1295,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_no_cache_when_writeback_diff#1297",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_no_cache_when_writeback_diff(self)",
        "snippet": "    def test_no_cache_when_writeback_diff(self) -> None:\n        mode = black.FileMode()\n        with cache_dir() as workspace:\n            src = (workspace / \"test.py\").resolve()\n            with src.open(\"w\") as fobj:\n                fobj.write(\"print('hello')\")\n            self.invokeBlack([str(src), \"--diff\"])\n            cache_file = black.get_cache_file(mode)\n            self.assertFalse(cache_file.exists())",
        "begin_line": 1297,
        "end_line": 1305,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_no_cache_when_stdin#1307",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_no_cache_when_stdin(self)",
        "snippet": "    def test_no_cache_when_stdin(self) -> None:\n        mode = black.FileMode()\n        with cache_dir():\n            result = CliRunner().invoke(\n                black.main, [\"-\"], input=BytesIO(b\"print('hello')\")\n            )\n            self.assertEqual(result.exit_code, 0)\n            cache_file = black.get_cache_file(mode)\n            self.assertFalse(cache_file.exists())",
        "begin_line": 1307,
        "end_line": 1315,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_read_cache_no_cachefile#1317",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_read_cache_no_cachefile(self)",
        "snippet": "    def test_read_cache_no_cachefile(self) -> None:\n        mode = black.FileMode()\n        with cache_dir():\n            self.assertEqual(black.read_cache(mode), {})",
        "begin_line": 1317,
        "end_line": 1320,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_write_cache_read_cache#1322",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_write_cache_read_cache(self)",
        "snippet": "    def test_write_cache_read_cache(self) -> None:\n        mode = black.FileMode()\n        with cache_dir() as workspace:\n            src = (workspace / \"test.py\").resolve()\n            src.touch()\n            black.write_cache({}, [src], mode)\n            cache = black.read_cache(mode)\n            self.assertIn(src, cache)\n            self.assertEqual(cache[src], black.get_cache_info(src))",
        "begin_line": 1322,
        "end_line": 1330,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_filter_cached#1332",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_filter_cached(self)",
        "snippet": "    def test_filter_cached(self) -> None:\n        with TemporaryDirectory() as workspace:\n            path = Path(workspace)\n            uncached = (path / \"uncached\").resolve()\n            cached = (path / \"cached\").resolve()\n            cached_but_changed = (path / \"changed\").resolve()\n            uncached.touch()\n            cached.touch()\n            cached_but_changed.touch()\n            cache = {cached: black.get_cache_info(cached), cached_but_changed: (0.0, 0)}\n            todo, done = black.filter_cached(\n                cache, {uncached, cached, cached_but_changed}\n            )\n            self.assertEqual(todo, {uncached, cached_but_changed})\n            self.assertEqual(done, {cached})",
        "begin_line": 1332,
        "end_line": 1346,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_write_cache_creates_directory_if_needed#1348",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_write_cache_creates_directory_if_needed(self)",
        "snippet": "    def test_write_cache_creates_directory_if_needed(self) -> None:\n        mode = black.FileMode()\n        with cache_dir(exists=False) as workspace:\n            self.assertFalse(workspace.exists())\n            black.write_cache({}, [], mode)\n            self.assertTrue(workspace.exists())",
        "begin_line": 1348,
        "end_line": 1353,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_failed_formatting_does_not_get_cached#1356",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_failed_formatting_does_not_get_cached(self)",
        "snippet": "    def test_failed_formatting_does_not_get_cached(self) -> None:\n        mode = black.FileMode()\n        with cache_dir() as workspace, patch(\n            \"black.ProcessPoolExecutor\", new=ThreadPoolExecutor\n        ):\n            failing = (workspace / \"failing.py\").resolve()\n            with failing.open(\"w\") as fobj:\n                fobj.write(\"not actually python\")\n            clean = (workspace / \"clean.py\").resolve()\n            with clean.open(\"w\") as fobj:\n                fobj.write('print(\"hello\")\\n')\n            self.invokeBlack([str(workspace)], exit_code=123)\n            cache = black.read_cache(mode)\n            self.assertNotIn(failing, cache)\n            self.assertIn(clean, cache)",
        "begin_line": 1356,
        "end_line": 1370,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_write_cache_write_fail#1372",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_write_cache_write_fail(self)",
        "snippet": "    def test_write_cache_write_fail(self) -> None:\n        mode = black.FileMode()\n        with cache_dir(), patch.object(Path, \"open\") as mock:\n            mock.side_effect = OSError\n            black.write_cache({}, [], mode)",
        "begin_line": 1372,
        "end_line": 1376,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_check_diff_use_together#1379",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_check_diff_use_together(self)",
        "snippet": "    def test_check_diff_use_together(self) -> None:\n        with cache_dir():\n            # Files which will be reformatted.\n            src1 = (THIS_DIR / \"data\" / \"string_quotes.py\").resolve()\n            self.invokeBlack([str(src1), \"--diff\", \"--check\"], exit_code=1)\n            # Files which will not be reformatted.\n            src2 = (THIS_DIR / \"data\" / \"composition.py\").resolve()\n            self.invokeBlack([str(src2), \"--diff\", \"--check\"])\n            # Multi file command.\n            self.invokeBlack([str(src1), str(src2), \"--diff\", \"--check\"], exit_code=1)",
        "begin_line": 1379,
        "end_line": 1388,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_no_files#1390",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_no_files(self)",
        "snippet": "    def test_no_files(self) -> None:\n        with cache_dir():\n            # Without an argument, black exits with error code 0.\n            self.invokeBlack([])",
        "begin_line": 1390,
        "end_line": 1393,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_broken_symlink#1395",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_broken_symlink(self)",
        "snippet": "    def test_broken_symlink(self) -> None:\n        with cache_dir() as workspace:\n            symlink = workspace / \"broken_link.py\"\n            try:\n                symlink.symlink_to(\"nonexistent.py\")\n            except OSError as e:\n                self.skipTest(f\"Can't create symlinks: {e}\")\n            self.invokeBlack([str(workspace.resolve())])",
        "begin_line": 1395,
        "end_line": 1402,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_read_cache_line_lengths#1404",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_read_cache_line_lengths(self)",
        "snippet": "    def test_read_cache_line_lengths(self) -> None:\n        mode = black.FileMode()\n        short_mode = black.FileMode(line_length=1)\n        with cache_dir() as workspace:\n            path = (workspace / \"file.py\").resolve()\n            path.touch()\n            black.write_cache({}, [path], mode)\n            one = black.read_cache(mode)\n            self.assertIn(path, one)\n            two = black.read_cache(short_mode)\n            self.assertNotIn(path, two)",
        "begin_line": 1404,
        "end_line": 1414,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_tricky_unicode_symbols#1416",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_tricky_unicode_symbols(self)",
        "snippet": "    def test_tricky_unicode_symbols(self) -> None:\n        source, expected = read_data(\"tricky_unicode_symbols\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 1416,
        "end_line": 1421,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_single_file_force_pyi#1423",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_single_file_force_pyi(self)",
        "snippet": "    def test_single_file_force_pyi(self) -> None:\n        reg_mode = black.FileMode()\n        pyi_mode = black.FileMode(is_pyi=True)\n        contents, expected = read_data(\"force_pyi\")\n        with cache_dir() as workspace:\n            path = (workspace / \"file.py\").resolve()\n            with open(path, \"w\") as fh:\n                fh.write(contents)\n            self.invokeBlack([str(path), \"--pyi\"])\n            with open(path, \"r\") as fh:\n                actual = fh.read()\n            # verify cache with --pyi is separate\n            pyi_cache = black.read_cache(pyi_mode)\n            self.assertIn(path, pyi_cache)\n            normal_cache = black.read_cache(reg_mode)\n            self.assertNotIn(path, normal_cache)\n        self.assertEqual(actual, expected)",
        "begin_line": 1423,
        "end_line": 1439,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_multi_file_force_pyi#1442",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_multi_file_force_pyi(self)",
        "snippet": "    def test_multi_file_force_pyi(self) -> None:\n        reg_mode = black.FileMode()\n        pyi_mode = black.FileMode(is_pyi=True)\n        contents, expected = read_data(\"force_pyi\")\n        with cache_dir() as workspace:\n            paths = [\n                (workspace / \"file1.py\").resolve(),\n                (workspace / \"file2.py\").resolve(),\n            ]\n            for path in paths:\n                with open(path, \"w\") as fh:\n                    fh.write(contents)\n            self.invokeBlack([str(p) for p in paths] + [\"--pyi\"])\n            for path in paths:\n                with open(path, \"r\") as fh:\n                    actual = fh.read()\n                self.assertEqual(actual, expected)\n            # verify cache with --pyi is separate\n            pyi_cache = black.read_cache(pyi_mode)\n            normal_cache = black.read_cache(reg_mode)\n            for path in paths:\n                self.assertIn(path, pyi_cache)\n                self.assertNotIn(path, normal_cache)",
        "begin_line": 1442,
        "end_line": 1464,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_pipe_force_pyi#1466",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_pipe_force_pyi(self)",
        "snippet": "    def test_pipe_force_pyi(self) -> None:\n        source, expected = read_data(\"force_pyi\")\n        result = CliRunner().invoke(\n            black.main, [\"-\", \"-q\", \"--pyi\"], input=BytesIO(source.encode(\"utf8\"))\n        )\n        self.assertEqual(result.exit_code, 0)\n        actual = result.output\n        self.assertFormatEqual(actual, expected)",
        "begin_line": 1466,
        "end_line": 1473,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_single_file_force_py36#1475",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_single_file_force_py36(self)",
        "snippet": "    def test_single_file_force_py36(self) -> None:\n        reg_mode = black.FileMode()\n        py36_mode = black.FileMode(target_versions=black.PY36_VERSIONS)\n        source, expected = read_data(\"force_py36\")\n        with cache_dir() as workspace:\n            path = (workspace / \"file.py\").resolve()\n            with open(path, \"w\") as fh:\n                fh.write(source)\n            self.invokeBlack([str(path), *PY36_ARGS])\n            with open(path, \"r\") as fh:\n                actual = fh.read()\n            # verify cache with --target-version is separate\n            py36_cache = black.read_cache(py36_mode)\n            self.assertIn(path, py36_cache)\n            normal_cache = black.read_cache(reg_mode)\n            self.assertNotIn(path, normal_cache)\n        self.assertEqual(actual, expected)",
        "begin_line": 1475,
        "end_line": 1491,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_multi_file_force_py36#1494",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_multi_file_force_py36(self)",
        "snippet": "    def test_multi_file_force_py36(self) -> None:\n        reg_mode = black.FileMode()\n        py36_mode = black.FileMode(target_versions=black.PY36_VERSIONS)\n        source, expected = read_data(\"force_py36\")\n        with cache_dir() as workspace:\n            paths = [\n                (workspace / \"file1.py\").resolve(),\n                (workspace / \"file2.py\").resolve(),\n            ]\n            for path in paths:\n                with open(path, \"w\") as fh:\n                    fh.write(source)\n            self.invokeBlack([str(p) for p in paths] + PY36_ARGS)\n            for path in paths:\n                with open(path, \"r\") as fh:\n                    actual = fh.read()\n                self.assertEqual(actual, expected)\n            # verify cache with --target-version is separate\n            pyi_cache = black.read_cache(py36_mode)\n            normal_cache = black.read_cache(reg_mode)\n            for path in paths:\n                self.assertIn(path, pyi_cache)\n                self.assertNotIn(path, normal_cache)",
        "begin_line": 1494,
        "end_line": 1516,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_collections#1518",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_collections(self)",
        "snippet": "    def test_collections(self) -> None:\n        source, expected = read_data(\"collections\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())",
        "begin_line": 1518,
        "end_line": 1523,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_pipe_force_py36#1525",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_pipe_force_py36(self)",
        "snippet": "    def test_pipe_force_py36(self) -> None:\n        source, expected = read_data(\"force_py36\")\n        result = CliRunner().invoke(\n            black.main,\n            [\"-\", \"-q\", \"--target-version=py36\"],\n            input=BytesIO(source.encode(\"utf8\")),\n        )\n        self.assertEqual(result.exit_code, 0)\n        actual = result.output\n        self.assertFormatEqual(actual, expected)",
        "begin_line": 1525,
        "end_line": 1534,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_include_exclude#1536",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_include_exclude(self)",
        "snippet": "    def test_include_exclude(self) -> None:\n        path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n        include = re.compile(r\"\\.pyi?$\")\n        exclude = re.compile(r\"/exclude/|/\\.definitely_exclude/\")\n        report = black.Report()\n        gitignore = PathSpec.from_lines(\"gitwildmatch\", [])\n        sources: List[Path] = []\n        expected = [\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.pyi\"),\n        ]\n        this_abs = THIS_DIR.resolve()\n        sources.extend(\n            black.gen_python_files_in_dir(\n                path, this_abs, include, exclude, report, gitignore\n            )\n        )\n        self.assertEqual(sorted(expected), sorted(sources))",
        "begin_line": 1536,
        "end_line": 1553,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_gitignore_exclude#1555",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_gitignore_exclude(self)",
        "snippet": "    def test_gitignore_exclude(self) -> None:\n        path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n        include = re.compile(r\"\\.pyi?$\")\n        exclude = re.compile(r\"\")\n        report = black.Report()\n        gitignore = PathSpec.from_lines(\n            \"gitwildmatch\", [\"exclude/\", \".definitely_exclude\"]\n        )\n        sources: List[Path] = []\n        expected = [\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.pyi\"),\n        ]\n        this_abs = THIS_DIR.resolve()\n        sources.extend(\n            black.gen_python_files_in_dir(\n                path, this_abs, include, exclude, report, gitignore\n            )\n        )\n        self.assertEqual(sorted(expected), sorted(sources))",
        "begin_line": 1555,
        "end_line": 1574,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_empty_include#1576",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_empty_include(self)",
        "snippet": "    def test_empty_include(self) -> None:\n        path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n        report = black.Report()\n        gitignore = PathSpec.from_lines(\"gitwildmatch\", [])\n        empty = re.compile(r\"\")\n        sources: List[Path] = []\n        expected = [\n            Path(path / \"b/exclude/a.pie\"),\n            Path(path / \"b/exclude/a.py\"),\n            Path(path / \"b/exclude/a.pyi\"),\n            Path(path / \"b/dont_exclude/a.pie\"),\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.pyi\"),\n            Path(path / \"b/.definitely_exclude/a.pie\"),\n            Path(path / \"b/.definitely_exclude/a.py\"),\n            Path(path / \"b/.definitely_exclude/a.pyi\"),\n        ]\n        this_abs = THIS_DIR.resolve()\n        sources.extend(\n            black.gen_python_files_in_dir(\n                path,\n                this_abs,\n                empty,\n                re.compile(black.DEFAULT_EXCLUDES),\n                report,\n                gitignore,\n            )\n        )\n        self.assertEqual(sorted(expected), sorted(sources))",
        "begin_line": 1576,
        "end_line": 1604,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_empty_exclude#1606",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_empty_exclude(self)",
        "snippet": "    def test_empty_exclude(self) -> None:\n        path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n        report = black.Report()\n        gitignore = PathSpec.from_lines(\"gitwildmatch\", [])\n        empty = re.compile(r\"\")\n        sources: List[Path] = []\n        expected = [\n            Path(path / \"b/dont_exclude/a.py\"),\n            Path(path / \"b/dont_exclude/a.pyi\"),\n            Path(path / \"b/exclude/a.py\"),\n            Path(path / \"b/exclude/a.pyi\"),\n            Path(path / \"b/.definitely_exclude/a.py\"),\n            Path(path / \"b/.definitely_exclude/a.pyi\"),\n        ]\n        this_abs = THIS_DIR.resolve()\n        sources.extend(\n            black.gen_python_files_in_dir(\n                path,\n                this_abs,\n                re.compile(black.DEFAULT_INCLUDES),\n                empty,\n                report,\n                gitignore,\n            )\n        )\n        self.assertEqual(sorted(expected), sorted(sources))",
        "begin_line": 1606,
        "end_line": 1631,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_invalid_include_exclude#1633",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_invalid_include_exclude(self)",
        "snippet": "    def test_invalid_include_exclude(self) -> None:\n        for option in [\"--include\", \"--exclude\"]:\n            self.invokeBlack([\"-\", option, \"**()(!!*)\"], exit_code=2)",
        "begin_line": 1633,
        "end_line": 1635,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_preserves_line_endings#1637",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_preserves_line_endings(self)",
        "snippet": "    def test_preserves_line_endings(self) -> None:\n        with TemporaryDirectory() as workspace:\n            test_file = Path(workspace) / \"test.py\"\n            for nl in [\"\\n\", \"\\r\\n\"]:\n                contents = nl.join([\"def f(  ):\", \"    pass\"])\n                test_file.write_bytes(contents.encode())\n                ff(test_file, write_back=black.WriteBack.YES)\n                updated_contents: bytes = test_file.read_bytes()\n                self.assertIn(nl.encode(), updated_contents)\n                if nl == \"\\n\":\n                    self.assertNotIn(b\"\\r\\n\", updated_contents)",
        "begin_line": 1637,
        "end_line": 1647,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_preserves_line_endings_via_stdin#1649",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_preserves_line_endings_via_stdin(self)",
        "snippet": "    def test_preserves_line_endings_via_stdin(self) -> None:\n        for nl in [\"\\n\", \"\\r\\n\"]:\n            contents = nl.join([\"def f(  ):\", \"    pass\"])\n            runner = BlackRunner()\n            result = runner.invoke(\n                black.main, [\"-\", \"--fast\"], input=BytesIO(contents.encode(\"utf8\"))\n            )\n            self.assertEqual(result.exit_code, 0)\n            output = runner.stdout_bytes\n            self.assertIn(nl.encode(\"utf8\"), output)\n            if nl == \"\\n\":\n                self.assertNotIn(b\"\\r\\n\", output)",
        "begin_line": 1649,
        "end_line": 1660,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_assert_equivalent_different_asts#1662",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_assert_equivalent_different_asts(self)",
        "snippet": "    def test_assert_equivalent_different_asts(self) -> None:\n        with self.assertRaises(AssertionError):\n            black.assert_equivalent(\"{}\", \"None\")",
        "begin_line": 1662,
        "end_line": 1664,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_symlink_out_of_root_directory#1666",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_symlink_out_of_root_directory(self)",
        "snippet": "    def test_symlink_out_of_root_directory(self) -> None:\n        path = MagicMock()\n        root = THIS_DIR\n        child = MagicMock()\n        include = re.compile(black.DEFAULT_INCLUDES)\n        exclude = re.compile(black.DEFAULT_EXCLUDES)\n        report = black.Report()\n        gitignore = PathSpec.from_lines(\"gitwildmatch\", [])\n        # `child` should behave like a symlink which resolved path is clearly\n        # outside of the `root` directory.\n        path.iterdir.return_value = [child]\n        child.resolve.return_value = Path(\"/a/b/c\")\n        child.as_posix.return_value = \"/a/b/c\"\n        child.is_symlink.return_value = True\n        try:\n            list(\n                black.gen_python_files_in_dir(\n                    path, root, include, exclude, report, gitignore\n                )\n            )\n        except ValueError as ve:\n            self.fail(f\"`get_python_files_in_dir()` failed: {ve}\")\n        path.iterdir.assert_called_once()\n        child.resolve.assert_called_once()\n        child.is_symlink.assert_called_once()\n        # `child` should behave like a strange file which resolved path is clearly\n        # outside of the `root` directory.\n        child.is_symlink.return_value = False\n        with self.assertRaises(ValueError):\n            list(\n                black.gen_python_files_in_dir(\n                    path, root, include, exclude, report, gitignore\n                )\n            )\n        path.iterdir.assert_called()\n        self.assertEqual(path.iterdir.call_count, 2)\n        child.resolve.assert_called()\n        self.assertEqual(child.resolve.call_count, 2)\n        child.is_symlink.assert_called()\n        self.assertEqual(child.is_symlink.call_count, 2)",
        "begin_line": 1666,
        "end_line": 1705,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_shhh_click#1707",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_shhh_click(self)",
        "snippet": "    def test_shhh_click(self) -> None:\n        try:\n            from click import _unicodefun  # type: ignore\n        except ModuleNotFoundError:\n            self.skipTest(\"Incompatible Click version\")\n        if not hasattr(_unicodefun, \"_verify_python3_env\"):\n            self.skipTest(\"Incompatible Click version\")\n        # First, let's see if Click is crashing with a preferred ASCII charset.\n        with patch(\"locale.getpreferredencoding\") as gpe:\n            gpe.return_value = \"ASCII\"\n            with self.assertRaises(RuntimeError):\n                _unicodefun._verify_python3_env()\n        # Now, let's silence Click...\n        black.patch_click()\n        # ...and confirm it's silent.\n        with patch(\"locale.getpreferredencoding\") as gpe:\n            gpe.return_value = \"ASCII\"\n            try:\n                _unicodefun._verify_python3_env()\n            except RuntimeError as re:\n                self.fail(f\"`patch_click()` failed, exception still raised: {re}\")",
        "begin_line": 1707,
        "end_line": 1727,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_root_logger_not_used_directly#1729",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_root_logger_not_used_directly(self)",
        "snippet": "    def test_root_logger_not_used_directly(self) -> None:\n        def fail(*args: Any, **kwargs: Any) -> None:\n            self.fail(\"Record created with root logger\")\n\n        with patch.multiple(\n            logging.root,\n            debug=fail,\n            info=fail,\n            warning=fail,\n            error=fail,\n            critical=fail,\n            log=fail,\n        ):\n            ff(THIS_FILE)",
        "begin_line": 1729,
        "end_line": 1742,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.fail#1730",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.fail(*args: Any, **kwargs: Any)",
        "snippet": "        def fail(*args: Any, **kwargs: Any) -> None:\n            self.fail(\"Record created with root logger\")",
        "begin_line": 1730,
        "end_line": 1731,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_blackd_main#1745",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_blackd_main(self)",
        "snippet": "    def test_blackd_main(self) -> None:\n        with patch(\"blackd.web.run_app\"):\n            result = CliRunner().invoke(blackd.main, [])\n            if result.exception is not None:\n                raise result.exception\n            self.assertEqual(result.exit_code, 0)",
        "begin_line": 1745,
        "end_line": 1750,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackTestCase.test_invalid_config_return_code#1752",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackTestCase",
        "signature": "tests.test_black.BlackTestCase.test_invalid_config_return_code(self)",
        "snippet": "    def test_invalid_config_return_code(self) -> None:\n        tmp_file = Path(black.dump_to_file())\n        try:\n            tmp_config = Path(black.dump_to_file())\n            tmp_config.unlink()\n            args = [\"--config\", str(tmp_config), str(tmp_file)]\n            self.invokeBlack(args, exit_code=2, ignore_config=False)\n        finally:\n            tmp_file.unlink()",
        "begin_line": 1752,
        "end_line": 1760,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackDTestCase.get_application#1764",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackDTestCase",
        "signature": "tests.test_black.BlackDTestCase.get_application(self)",
        "snippet": "    async def get_application(self) -> web.Application:\n        return blackd.make_app()",
        "begin_line": 1764,
        "end_line": 1765,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackDTestCase.test_blackd_request_needs_formatting#1772",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackDTestCase",
        "signature": "tests.test_black.BlackDTestCase.test_blackd_request_needs_formatting(self)",
        "snippet": "    async def test_blackd_request_needs_formatting(self) -> None:\n        response = await self.client.post(\"/\", data=b\"print('hello world')\")\n        self.assertEqual(response.status, 200)\n        self.assertEqual(response.charset, \"utf8\")\n        self.assertEqual(await response.read(), b'print(\"hello world\")\\n')",
        "begin_line": 1772,
        "end_line": 1776,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackDTestCase.test_blackd_request_no_change#1781",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackDTestCase",
        "signature": "tests.test_black.BlackDTestCase.test_blackd_request_no_change(self)",
        "snippet": "    async def test_blackd_request_no_change(self) -> None:\n        response = await self.client.post(\"/\", data=b'print(\"hello world\")\\n')\n        self.assertEqual(response.status, 204)\n        self.assertEqual(await response.read(), b\"\")",
        "begin_line": 1781,
        "end_line": 1784,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackDTestCase.test_blackd_request_syntax_error#1789",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackDTestCase",
        "signature": "tests.test_black.BlackDTestCase.test_blackd_request_syntax_error(self)",
        "snippet": "    async def test_blackd_request_syntax_error(self) -> None:\n        response = await self.client.post(\"/\", data=b\"what even ( is\")\n        self.assertEqual(response.status, 400)\n        content = await response.text()\n        self.assertTrue(\n            content.startswith(\"Cannot parse\"),\n            msg=f\"Expected error to start with 'Cannot parse', got {repr(content)}\",\n        )",
        "begin_line": 1789,
        "end_line": 1796,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackDTestCase.test_blackd_unsupported_version#1801",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackDTestCase",
        "signature": "tests.test_black.BlackDTestCase.test_blackd_unsupported_version(self)",
        "snippet": "    async def test_blackd_unsupported_version(self) -> None:\n        response = await self.client.post(\n            \"/\", data=b\"what\", headers={blackd.PROTOCOL_VERSION_HEADER: \"2\"}\n        )\n        self.assertEqual(response.status, 501)",
        "begin_line": 1801,
        "end_line": 1805,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackDTestCase.test_blackd_supported_version#1810",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackDTestCase",
        "signature": "tests.test_black.BlackDTestCase.test_blackd_supported_version(self)",
        "snippet": "    async def test_blackd_supported_version(self) -> None:\n        response = await self.client.post(\n            \"/\", data=b\"what\", headers={blackd.PROTOCOL_VERSION_HEADER: \"1\"}\n        )\n        self.assertEqual(response.status, 200)",
        "begin_line": 1810,
        "end_line": 1814,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackDTestCase.test_blackd_invalid_python_variant#1819",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackDTestCase",
        "signature": "tests.test_black.BlackDTestCase.test_blackd_invalid_python_variant(self)",
        "snippet": "    async def test_blackd_invalid_python_variant(self) -> None:\n        async def check(header_value: str, expected_status: int = 400) -> None:\n            response = await self.client.post(\n                \"/\", data=b\"what\", headers={blackd.PYTHON_VARIANT_HEADER: header_value}\n            )\n            self.assertEqual(response.status, expected_status)\n\n        await check(\"lol\")\n        await check(\"ruby3.5\")\n        await check(\"pyi3.6\")\n        await check(\"py1.5\")\n        await check(\"2.8\")\n        await check(\"py2.8\")\n        await check(\"3.0\")\n        await check(\"pypy3.0\")\n        await check(\"jython3.4\")",
        "begin_line": 1819,
        "end_line": 1834,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackDTestCase.check#1820",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackDTestCase",
        "signature": "tests.test_black.BlackDTestCase.check(header_value: str, expected_status: int=400)",
        "snippet": "        async def check(header_value: str, expected_status: int = 400) -> None:\n            response = await self.client.post(\n                \"/\", data=b\"what\", headers={blackd.PYTHON_VARIANT_HEADER: header_value}\n            )\n            self.assertEqual(response.status, expected_status)",
        "begin_line": 1820,
        "end_line": 1824,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackDTestCase.test_blackd_pyi#1839",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackDTestCase",
        "signature": "tests.test_black.BlackDTestCase.test_blackd_pyi(self)",
        "snippet": "    async def test_blackd_pyi(self) -> None:\n        source, expected = read_data(\"stub.pyi\")\n        response = await self.client.post(\n            \"/\", data=source, headers={blackd.PYTHON_VARIANT_HEADER: \"pyi\"}\n        )\n        self.assertEqual(response.status, 200)\n        self.assertEqual(await response.text(), expected)",
        "begin_line": 1839,
        "end_line": 1845,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackDTestCase.test_blackd_diff#1850",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackDTestCase",
        "signature": "tests.test_black.BlackDTestCase.test_blackd_diff(self)",
        "snippet": "    async def test_blackd_diff(self) -> None:\n        diff_header = re.compile(\n            rf\"(In|Out)\\t\\d\\d\\d\\d-\\d\\d-\\d\\d \\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\d\\d\\d\\d \\+\\d\\d\\d\\d\"\n        )\n\n        source, _ = read_data(\"blackd_diff.py\")\n        expected, _ = read_data(\"blackd_diff.diff\")\n\n        response = await self.client.post(\n            \"/\", data=source, headers={blackd.DIFF_HEADER: \"true\"}\n        )\n        self.assertEqual(response.status, 200)\n\n        actual = await response.text()\n        actual = diff_header.sub(DETERMINISTIC_HEADER, actual)\n        self.assertEqual(actual, expected)",
        "begin_line": 1850,
        "end_line": 1865,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackDTestCase.test_blackd_python_variant#1870",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackDTestCase",
        "signature": "tests.test_black.BlackDTestCase.test_blackd_python_variant(self)",
        "snippet": "    async def test_blackd_python_variant(self) -> None:\n        code = (\n            \"def f(\\n\"\n            \"    and_has_a_bunch_of,\\n\"\n            \"    very_long_arguments_too,\\n\"\n            \"    and_lots_of_them_as_well_lol,\\n\"\n            \"    **and_very_long_keyword_arguments\\n\"\n            \"):\\n\"\n            \"    pass\\n\"\n        )\n\n        async def check(header_value: str, expected_status: int) -> None:\n            response = await self.client.post(\n                \"/\", data=code, headers={blackd.PYTHON_VARIANT_HEADER: header_value}\n            )\n            self.assertEqual(\n                response.status, expected_status, msg=await response.text()\n            )\n\n        await check(\"3.6\", 200)\n        await check(\"py3.6\", 200)\n        await check(\"3.6,3.7\", 200)\n        await check(\"3.6,py3.7\", 200)\n        await check(\"py36,py37\", 200)\n        await check(\"36\", 200)\n        await check(\"3.6.4\", 200)\n\n        await check(\"2\", 204)\n        await check(\"2.7\", 204)\n        await check(\"py2.7\", 204)\n        await check(\"3.4\", 204)\n        await check(\"py3.4\", 204)\n        await check(\"py34,py36\", 204)\n        await check(\"34\", 204)",
        "begin_line": 1870,
        "end_line": 1903,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackDTestCase.check#1881",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackDTestCase",
        "signature": "tests.test_black.BlackDTestCase.check(header_value: str, expected_status: int)",
        "snippet": "        async def check(header_value: str, expected_status: int) -> None:\n            response = await self.client.post(\n                \"/\", data=code, headers={blackd.PYTHON_VARIANT_HEADER: header_value}\n            )\n            self.assertEqual(\n                response.status, expected_status, msg=await response.text()\n            )",
        "begin_line": 1881,
        "end_line": 1887,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackDTestCase.test_blackd_line_length#1908",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackDTestCase",
        "signature": "tests.test_black.BlackDTestCase.test_blackd_line_length(self)",
        "snippet": "    async def test_blackd_line_length(self) -> None:\n        response = await self.client.post(\n            \"/\", data=b'print(\"hello\")\\n', headers={blackd.LINE_LENGTH_HEADER: \"7\"}\n        )\n        self.assertEqual(response.status, 200)",
        "begin_line": 1908,
        "end_line": 1912,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackDTestCase.test_blackd_invalid_line_length#1917",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackDTestCase",
        "signature": "tests.test_black.BlackDTestCase.test_blackd_invalid_line_length(self)",
        "snippet": "    async def test_blackd_invalid_line_length(self) -> None:\n        response = await self.client.post(\n            \"/\", data=b'print(\"hello\")\\n', headers={blackd.LINE_LENGTH_HEADER: \"NaN\"}\n        )\n        self.assertEqual(response.status, 400)",
        "begin_line": 1917,
        "end_line": 1921,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_black.BlackDTestCase.test_blackd_response_black_version_header#1926",
        "src_path": "tests/test_black.py",
        "class_name": "tests.test_black.BlackDTestCase",
        "signature": "tests.test_black.BlackDTestCase.test_blackd_response_black_version_header(self)",
        "snippet": "    async def test_blackd_response_black_version_header(self) -> None:\n        response = await self.client.post(\"/\")\n        self.assertIsNotNone(response.headers.get(blackd.BLACK_VERSION_HEADER))",
        "begin_line": 1926,
        "end_line": 1928,
        "comment": "",
        "is_bug": false
    }
]