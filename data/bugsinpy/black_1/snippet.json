[
    {
        "name": "blib2to3.pgen2.driver.Driver.__init__#48",
        "src_path": "blib2to3/pgen2/driver.py",
        "class_name": "blib2to3.pgen2.driver.Driver",
        "signature": "blib2to3.pgen2.driver.Driver.__init__(self, grammar: Grammar, convert: Optional[_Convert]=None, logger: Optional[Logger]=None)",
        "snippet": "    def __init__(\n        self,\n        grammar: Grammar,\n        convert: Optional[_Convert] = None,\n        logger: Optional[Logger] = None,\n    ) -> None:\n        self.grammar = grammar\n        if logger is None:\n            logger = logging.getLogger(__name__)\n        self.logger = logger\n        self.convert = convert",
        "begin_line": 48,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00030175015087507544,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pgen2.driver.Driver.parse_tokens#60",
        "src_path": "blib2to3/pgen2/driver.py",
        "class_name": "blib2to3.pgen2.driver.Driver",
        "signature": "blib2to3.pgen2.driver.Driver.parse_tokens(self, tokens: Iterable[Any], debug: bool=False)",
        "snippet": "    def parse_tokens(self, tokens: Iterable[Any], debug: bool = False) -> NL:\n        \"\"\"Parse a series of tokens and return the syntax tree.\"\"\"\n        # XXX Move the prefix computation into a wrapper around tokenize.\n        p = parse.Parser(self.grammar, self.convert)\n        p.setup()\n        lineno = 1\n        column = 0\n        indent_columns = []\n        type = value = start = end = line_text = None\n        prefix = \"\"\n        for quintuple in tokens:\n            type, value, start, end, line_text = quintuple\n            if start != (lineno, column):\n                assert (lineno, column) <= start, ((lineno, column), start)\n                s_lineno, s_column = start\n                if lineno < s_lineno:\n                    prefix += \"\\n\" * (s_lineno - lineno)\n                    lineno = s_lineno\n                    column = 0\n                if column < s_column:\n                    prefix += line_text[column:s_column]\n                    column = s_column\n            if type in (tokenize.COMMENT, tokenize.NL):\n                prefix += value\n                lineno, column = end\n                if value.endswith(\"\\n\"):\n                    lineno += 1\n                    column = 0\n                continue\n            if type == token.OP:\n                type = grammar.opmap[value]\n            if debug:\n                self.logger.debug(\n                    \"%s %r (prefix=%r)\", token.tok_name[type], value, prefix\n                )\n            if type == token.INDENT:\n                indent_columns.append(len(value))\n                _prefix = prefix + value\n                prefix = \"\"\n                value = \"\"\n            elif type == token.DEDENT:\n                _indent_col = indent_columns.pop()\n                prefix, _prefix = self._partially_consume_prefix(prefix, _indent_col)\n            if p.addtoken(type, value, (prefix, start)):\n                if debug:\n                    self.logger.debug(\"Stop.\")\n                break\n            prefix = \"\"\n            if type in {token.INDENT, token.DEDENT}:\n                prefix = _prefix\n            lineno, column = end\n            if value.endswith(\"\\n\"):\n                lineno += 1\n                column = 0\n        else:\n            # We never broke out -- EOF is too soon (how can this happen???)\n            assert start is not None\n            raise parse.ParseError(\"incomplete input\", type, value, (prefix, start))\n        assert p.rootnode is not None\n        return p.rootnode",
        "begin_line": 60,
        "end_line": 119,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00038255547054322876,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pgen2.driver.Driver.parse_string#137",
        "src_path": "blib2to3/pgen2/driver.py",
        "class_name": "blib2to3.pgen2.driver.Driver",
        "signature": "blib2to3.pgen2.driver.Driver.parse_string(self, text: Text, debug: bool=False)",
        "snippet": "    def parse_string(self, text: Text, debug: bool = False) -> NL:\n        \"\"\"Parse a string and return the syntax tree.\"\"\"\n        tokens = tokenize.generate_tokens(\n            io.StringIO(text).readline, grammar=self.grammar\n        )\n        return self.parse_tokens(tokens, debug)",
        "begin_line": 137,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00030175015087507544,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pgen2.driver.Driver._partially_consume_prefix#144",
        "src_path": "blib2to3/pgen2/driver.py",
        "class_name": "blib2to3.pgen2.driver.Driver",
        "signature": "blib2to3.pgen2.driver.Driver._partially_consume_prefix(self, prefix: Text, column: int)",
        "snippet": "    def _partially_consume_prefix(self, prefix: Text, column: int) -> Tuple[Text, Text]:\n        lines: List[str] = []\n        current_line = \"\"\n        current_column = 0\n        wait_for_nl = False\n        for char in prefix:\n            current_line += char\n            if wait_for_nl:\n                if char == \"\\n\":\n                    if current_line.strip() and current_column < column:\n                        res = \"\".join(lines)\n                        return res, prefix[len(res) :]\n\n                    lines.append(current_line)\n                    current_line = \"\"\n                    current_column = 0\n                    wait_for_nl = False\n            elif char in \" \\t\":\n                current_column += 1\n            elif char == \"\\n\":\n                # unexpected empty line\n                current_column = 0\n            else:\n                # indent is finished\n                wait_for_nl = True\n        return \"\".join(lines), current_line",
        "begin_line": 144,
        "end_line": 169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0011001100110011,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blackd.main#50",
        "src_path": "blackd.py",
        "class_name": "blackd",
        "signature": "blackd.main(bind_host: str, bind_port: int)",
        "snippet": "def main(bind_host: str, bind_port: int) -> None:\n    logging.basicConfig(level=logging.INFO)\n    app = make_app()\n    ver = black.__version__\n    black.out(f\"blackd version {ver} listening on {bind_host} port {bind_port}\")\n    web.run_app(app, host=bind_host, port=bind_port, handle_signals=True, print=None)",
        "begin_line": 50,
        "end_line": 55,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blackd.make_app#58",
        "src_path": "blackd.py",
        "class_name": "blackd",
        "signature": "blackd.make_app()",
        "snippet": "def make_app() -> web.Application:\n    app = web.Application()\n    executor = ProcessPoolExecutor()\n\n    cors = aiohttp_cors.setup(app)\n    resource = cors.add(app.router.add_resource(\"/\"))\n    cors.add(\n        resource.add_route(\"POST\", partial(handle, executor=executor)),\n        {\n            \"*\": aiohttp_cors.ResourceOptions(\n                allow_headers=(*BLACK_HEADERS, \"Content-Type\"), expose_headers=\"*\"\n            )\n        },\n    )\n\n    return app",
        "begin_line": 58,
        "end_line": 73,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0007547169811320754,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blackd.handle#76",
        "src_path": "blackd.py",
        "class_name": "blackd",
        "signature": "blackd.handle(request: web.Request, executor: Executor)",
        "snippet": "async def handle(request: web.Request, executor: Executor) -> web.Response:\n    headers = {BLACK_VERSION_HEADER: __version__}\n    try:\n        if request.headers.get(PROTOCOL_VERSION_HEADER, \"1\") != \"1\":\n            return web.Response(\n                status=501, text=\"This server only supports protocol version 1\"\n            )\n        try:\n            line_length = int(\n                request.headers.get(LINE_LENGTH_HEADER, black.DEFAULT_LINE_LENGTH)\n            )\n        except ValueError:\n            return web.Response(status=400, text=\"Invalid line length header value\")\n\n        if PYTHON_VARIANT_HEADER in request.headers:\n            value = request.headers[PYTHON_VARIANT_HEADER]\n            try:\n                pyi, versions = parse_python_variant_header(value)\n            except InvalidVariantHeader as e:\n                return web.Response(\n                    status=400,\n                    text=f\"Invalid value for {PYTHON_VARIANT_HEADER}: {e.args[0]}\",\n                )\n        else:\n            pyi = False\n            versions = set()\n\n        skip_string_normalization = bool(\n            request.headers.get(SKIP_STRING_NORMALIZATION_HEADER, False)\n        )\n        fast = False\n        if request.headers.get(FAST_OR_SAFE_HEADER, \"safe\") == \"fast\":\n            fast = True\n        mode = black.FileMode(\n            target_versions=versions,\n            is_pyi=pyi,\n            line_length=line_length,\n            string_normalization=not skip_string_normalization,\n        )\n        req_bytes = await request.content.read()\n        charset = request.charset if request.charset is not None else \"utf8\"\n        req_str = req_bytes.decode(charset)\n        then = datetime.utcnow()\n\n        loop = asyncio.get_event_loop()\n        formatted_str = await loop.run_in_executor(\n            executor, partial(black.format_file_contents, req_str, fast=fast, mode=mode)\n        )\n\n        # Only output the diff in the HTTP response\n        only_diff = bool(request.headers.get(DIFF_HEADER, False))\n        if only_diff:\n            now = datetime.utcnow()\n            src_name = f\"In\\t{then} +0000\"\n            dst_name = f\"Out\\t{now} +0000\"\n            loop = asyncio.get_event_loop()\n            formatted_str = await loop.run_in_executor(\n                executor,\n                partial(black.diff, req_str, formatted_str, src_name, dst_name),\n            )\n\n        return web.Response(\n            content_type=request.content_type,\n            charset=charset,\n            headers=headers,\n            text=formatted_str,\n        )\n    except black.NothingChanged:\n        return web.Response(status=204, headers=headers)\n    except black.InvalidInput as e:\n        return web.Response(status=400, headers=headers, text=str(e))\n    except Exception as e:\n        logging.exception(\"Exception during handling a request\")\n        return web.Response(status=500, headers=headers, text=str(e))",
        "begin_line": 76,
        "end_line": 149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blackd.parse_python_variant_header#152",
        "src_path": "blackd.py",
        "class_name": "blackd",
        "signature": "blackd.parse_python_variant_header(value: str)",
        "snippet": "def parse_python_variant_header(value: str) -> Tuple[bool, Set[black.TargetVersion]]:\n    if value == \"pyi\":\n        return True, set()\n    else:\n        versions = set()\n        for version in value.split(\",\"):\n            if version.startswith(\"py\"):\n                version = version[len(\"py\") :]\n            if \".\" in version:\n                major_str, *rest = version.split(\".\")\n            else:\n                major_str = version[0]\n                rest = [version[1:]] if len(version) > 1 else []\n            try:\n                major = int(major_str)\n                if major not in (2, 3):\n                    raise InvalidVariantHeader(\"major version must be 2 or 3\")\n                if len(rest) > 0:\n                    minor = int(rest[0])\n                    if major == 2 and minor != 7:\n                        raise InvalidVariantHeader(\n                            \"minor version must be 7 for Python 2\"\n                        )\n                else:\n                    # Default to lowest supported minor version.\n                    minor = 7 if major == 2 else 3\n                version_str = f\"PY{major}{minor}\"\n                if major == 3 and not hasattr(black.TargetVersion, version_str):\n                    raise InvalidVariantHeader(f\"3.{minor} is not supported\")\n                versions.add(black.TargetVersion[version_str])\n            except (KeyError, ValueError):\n                raise InvalidVariantHeader(\"expected e.g. '3.7', 'py3.5'\")\n        return False, versions",
        "begin_line": 152,
        "end_line": 184,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pgen2.tokenize.generate_tokens#402",
        "src_path": "blib2to3/pgen2/tokenize.py",
        "class_name": "blib2to3.pgen2.tokenize",
        "signature": "blib2to3.pgen2.tokenize.generate_tokens(readline: Callable[[], Text], grammar: Optional[Grammar]=None)",
        "snippet": "def generate_tokens(\n    readline: Callable[[], Text], grammar: Optional[Grammar] = None\n) -> Iterator[GoodTokenInfo]:\n    \"\"\"\n    The generate_tokens() generator requires one argument, readline, which\n    must be a callable object which provides the same interface as the\n    readline() method of built-in file objects. Each call to the function\n    should return one line of input as a string.  Alternately, readline\n    can be a callable function terminating with StopIteration:\n        readline = open(myfile).next    # Example of alternate readline\n\n    The generator produces 5-tuples with these members: the token type; the\n    token string; a 2-tuple (srow, scol) of ints specifying the row and\n    column where the token begins in the source; a 2-tuple (erow, ecol) of\n    ints specifying the row and column where the token ends in the source;\n    and the line on which the token was found. The line passed is the\n    logical line; continuation lines are included.\n    \"\"\"\n    lnum = parenlev = continued = 0\n    numchars = \"0123456789\"\n    contstr, needcont = \"\", 0\n    contline: Optional[str] = None\n    indents = [0]\n\n    # If we know we're parsing 3.7+, we can unconditionally parse `async` and\n    # `await` as keywords.\n    async_keywords = False if grammar is None else grammar.async_keywords\n    # 'stashed' and 'async_*' are used for async/await parsing\n    stashed = None\n    async_def = False\n    async_def_indent = 0\n    async_def_nl = False\n\n    strstart: Tuple[int, int]\n    endprog: Pattern[str]\n\n    while 1:  # loop over lines in stream\n        try:\n            line = readline()\n        except StopIteration:\n            line = \"\"\n        lnum = lnum + 1\n        pos, max = 0, len(line)\n\n        if contstr:  # continued string\n            assert contline is not None\n            if not line:\n                raise TokenError(\"EOF in multi-line string\", strstart)\n            endmatch = endprog.match(line)\n            if endmatch:\n                pos = end = endmatch.end(0)\n                yield (\n                    STRING,\n                    contstr + line[:end],\n                    strstart,\n                    (lnum, end),\n                    contline + line,\n                )\n                contstr, needcont = \"\", 0\n                contline = None\n            elif needcont and line[-2:] != \"\\\\\\n\" and line[-3:] != \"\\\\\\r\\n\":\n                yield (\n                    ERRORTOKEN,\n                    contstr + line,\n                    strstart,\n                    (lnum, len(line)),\n                    contline,\n                )\n                contstr = \"\"\n                contline = None\n                continue\n            else:\n                contstr = contstr + line\n                contline = contline + line\n                continue\n\n        elif parenlev == 0 and not continued:  # new statement\n            if not line:\n                break\n            column = 0\n            while pos < max:  # measure leading whitespace\n                if line[pos] == \" \":\n                    column = column + 1\n                elif line[pos] == \"\\t\":\n                    column = (column // tabsize + 1) * tabsize\n                elif line[pos] == \"\\f\":\n                    column = 0\n                else:\n                    break\n                pos = pos + 1\n            if pos == max:\n                break\n\n            if stashed:\n                yield stashed\n                stashed = None\n\n            if line[pos] in \"\\r\\n\":  # skip blank lines\n                yield (NL, line[pos:], (lnum, pos), (lnum, len(line)), line)\n                continue\n\n            if line[pos] == \"#\":  # skip comments\n                comment_token = line[pos:].rstrip(\"\\r\\n\")\n                nl_pos = pos + len(comment_token)\n                yield (\n                    COMMENT,\n                    comment_token,\n                    (lnum, pos),\n                    (lnum, pos + len(comment_token)),\n                    line,\n                )\n                yield (NL, line[nl_pos:], (lnum, nl_pos), (lnum, len(line)), line)\n                continue\n\n            if column > indents[-1]:  # count indents\n                indents.append(column)\n                yield (INDENT, line[:pos], (lnum, 0), (lnum, pos), line)\n\n            while column < indents[-1]:  # count dedents\n                if column not in indents:\n                    raise IndentationError(\n                        \"unindent does not match any outer indentation level\",\n                        (\"<tokenize>\", lnum, pos, line),\n                    )\n                indents = indents[:-1]\n\n                if async_def and async_def_indent >= indents[-1]:\n                    async_def = False\n                    async_def_nl = False\n                    async_def_indent = 0\n\n                yield (DEDENT, \"\", (lnum, pos), (lnum, pos), line)\n\n            if async_def and async_def_nl and async_def_indent >= indents[-1]:\n                async_def = False\n                async_def_nl = False\n                async_def_indent = 0\n\n        else:  # continued statement\n            if not line:\n                raise TokenError(\"EOF in multi-line statement\", (lnum, 0))\n            continued = 0\n\n        while pos < max:\n            pseudomatch = pseudoprog.match(line, pos)\n            if pseudomatch:  # scan for tokens\n                start, end = pseudomatch.span(1)\n                spos, epos, pos = (lnum, start), (lnum, end), end\n                token, initial = line[start:end], line[start]\n\n                if initial in numchars or (\n                    initial == \".\" and token != \".\"\n                ):  # ordinary number\n                    yield (NUMBER, token, spos, epos, line)\n                elif initial in \"\\r\\n\":\n                    newline = NEWLINE\n                    if parenlev > 0:\n                        newline = NL\n                    elif async_def:\n                        async_def_nl = True\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield (newline, token, spos, epos, line)\n\n                elif initial == \"#\":\n                    assert not token.endswith(\"\\n\")\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield (COMMENT, token, spos, epos, line)\n                elif token in triple_quoted:\n                    endprog = endprogs[token]\n                    endmatch = endprog.match(line, pos)\n                    if endmatch:  # all on one line\n                        pos = endmatch.end(0)\n                        token = line[start:pos]\n                        if stashed:\n                            yield stashed\n                            stashed = None\n                        yield (STRING, token, spos, (lnum, pos), line)\n                    else:\n                        strstart = (lnum, start)  # multiple lines\n                        contstr = line[start:]\n                        contline = line\n                        break\n                elif (\n                    initial in single_quoted\n                    or token[:2] in single_quoted\n                    or token[:3] in single_quoted\n                ):\n                    if token[-1] == \"\\n\":  # continued string\n                        strstart = (lnum, start)\n                        endprog = (\n                            endprogs[initial]\n                            or endprogs[token[1]]\n                            or endprogs[token[2]]\n                        )\n                        contstr, needcont = line[start:], 1\n                        contline = line\n                        break\n                    else:  # ordinary string\n                        if stashed:\n                            yield stashed\n                            stashed = None\n                        yield (STRING, token, spos, epos, line)\n                elif initial.isidentifier():  # ordinary name\n                    if token in (\"async\", \"await\"):\n                        if async_keywords or async_def:\n                            yield (\n                                ASYNC if token == \"async\" else AWAIT,\n                                token,\n                                spos,\n                                epos,\n                                line,\n                            )\n                            continue\n\n                    tok = (NAME, token, spos, epos, line)\n                    if token == \"async\" and not stashed:\n                        stashed = tok\n                        continue\n\n                    if token in (\"def\", \"for\"):\n                        if stashed and stashed[0] == NAME and stashed[1] == \"async\":\n\n                            if token == \"def\":\n                                async_def = True\n                                async_def_indent = indents[-1]\n\n                            yield (\n                                ASYNC,\n                                stashed[1],\n                                stashed[2],\n                                stashed[3],\n                                stashed[4],\n                            )\n                            stashed = None\n\n                    if stashed:\n                        yield stashed\n                        stashed = None\n\n                    yield tok\n                elif initial == \"\\\\\":  # continued stmt\n                    # This yield is new; needed for better idempotency:\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield (NL, token, spos, (lnum, pos), line)\n                    continued = 1\n                else:\n                    if initial in \"([{\":\n                        parenlev = parenlev + 1\n                    elif initial in \")]}\":\n                        parenlev = parenlev - 1\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield (OP, token, spos, epos, line)\n            else:\n                yield (ERRORTOKEN, line[pos], (lnum, pos), (lnum, pos + 1), line)\n                pos = pos + 1\n\n    if stashed:\n        yield stashed\n        stashed = None\n\n    for indent in indents[1:]:  # pop remaining indent levels\n        yield (DEDENT, \"\", (lnum, 0), (lnum, 0), \"\")\n    yield (ENDMARKER, \"\", (lnum, 0), (lnum, 0), \"\")",
        "begin_line": 402,
        "end_line": 672,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Ok.__init__#119",
        "src_path": "black.py",
        "class_name": "black.Ok",
        "signature": "black.Ok.__init__(self, value: T)",
        "snippet": "    def __init__(self, value: T) -> None:\n        self._value = value",
        "begin_line": 119,
        "end_line": 120,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0004930966469428008,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Ok.ok#122",
        "src_path": "black.py",
        "class_name": "black.Ok",
        "signature": "black.Ok.ok(self)",
        "snippet": "    def ok(self) -> T:\n        return self._value",
        "begin_line": 122,
        "end_line": 123,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0004930966469428008,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Err.__init__#127",
        "src_path": "black.py",
        "class_name": "black.Err",
        "signature": "black.Err.__init__(self, e: E)",
        "snippet": "    def __init__(self, e: E) -> None:\n        self._e = e",
        "begin_line": 127,
        "end_line": 128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00039184952978056425,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Err.err#130",
        "src_path": "black.py",
        "class_name": "black.Err",
        "signature": "black.Err.err(self)",
        "snippet": "    def err(self) -> E:\n        return self._e",
        "begin_line": 130,
        "end_line": 131,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00039184952978056425,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.WriteBack.from_configuration#150",
        "src_path": "black.py",
        "class_name": "black.WriteBack",
        "signature": "black.WriteBack.from_configuration(cls, *, check: bool, diff: bool, color: bool=False)",
        "snippet": "    def from_configuration(\n        cls, *, check: bool, diff: bool, color: bool = False\n    ) -> \"WriteBack\":\n        if check and not diff:\n            return cls.CHECK\n\n        if diff and color:\n            return cls.COLOR_DIFF\n\n        return cls.DIFF if diff else cls.YES",
        "begin_line": 150,
        "end_line": 159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.014492753623188406,
            "pseudo_dstar_susp": 0.014492753623188406,
            "pseudo_tarantula_susp": 0.014925373134328358,
            "pseudo_op2_susp": 0.014492753623188406,
            "pseudo_barinel_susp": 0.014925373134328358
        }
    },
    {
        "name": "black.TargetVersion.is_python2#177",
        "src_path": "black.py",
        "class_name": "black.TargetVersion",
        "signature": "black.TargetVersion.is_python2(self)",
        "snippet": "    def is_python2(self) -> bool:\n        return self is TargetVersion.PY27",
        "begin_line": 177,
        "end_line": 178,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0008438818565400844,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Mode.get_cache_key#244",
        "src_path": "black.py",
        "class_name": "black.Mode",
        "signature": "black.Mode.get_cache_key(self)",
        "snippet": "    def get_cache_key(self) -> str:\n        if self.target_versions:\n            version_str = \",\".join(\n                str(version.value)\n                for version in sorted(self.target_versions, key=lambda v: v.value)\n            )\n        else:\n            version_str = \"-\"\n        parts = [\n            version_str,\n            str(self.line_length),\n            str(int(self.string_normalization)),\n            str(int(self.is_pyi)),\n        ]\n        return \".\".join(parts)",
        "begin_line": 244,
        "end_line": 258,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.02127659574468085,
            "pseudo_dstar_susp": 0.02127659574468085,
            "pseudo_tarantula_susp": 0.022222222222222223,
            "pseudo_op2_susp": 0.02127659574468085,
            "pseudo_barinel_susp": 0.022222222222222223
        }
    },
    {
        "name": "black.supports_feature#265",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.supports_feature(target_versions: Set[TargetVersion], feature: Feature)",
        "snippet": "def supports_feature(target_versions: Set[TargetVersion], feature: Feature) -> bool:\n    return all(feature in VERSION_TO_FEATURES[version] for version in target_versions)",
        "begin_line": 265,
        "end_line": 266,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0003176620076238882,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.find_pyproject_toml#269",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.find_pyproject_toml(path_search_start: str)",
        "snippet": "def find_pyproject_toml(path_search_start: str) -> Optional[str]:\n    \"\"\"Find the absolute filepath to a pyproject.toml if it exists\"\"\"\n    path_project_root = find_project_root(path_search_start)\n    path_pyproject_toml = path_project_root / \"pyproject.toml\"\n    return str(path_pyproject_toml) if path_pyproject_toml.is_file() else None",
        "begin_line": 269,
        "end_line": 273,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0011001100110011,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.parse_pyproject_toml#276",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.parse_pyproject_toml(path_config: str)",
        "snippet": "def parse_pyproject_toml(path_config: str) -> Dict[str, Any]:\n    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black\n\n    If parsing fails, will raise a toml.TomlDecodeError\n    \"\"\"\n    pyproject_toml = toml.load(path_config)\n    config = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n    return {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}",
        "begin_line": 276,
        "end_line": 283,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.034482758620689655,
            "pseudo_dstar_susp": 0.25,
            "pseudo_tarantula_susp": 0.014925373134328358,
            "pseudo_op2_susp": 0.25,
            "pseudo_barinel_susp": 0.014925373134328358
        }
    },
    {
        "name": "black.read_pyproject_toml#286",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.read_pyproject_toml(ctx: click.Context, param: click.Parameter, value: Optional[str])",
        "snippet": "def read_pyproject_toml(\n    ctx: click.Context, param: click.Parameter, value: Optional[str]\n) -> Optional[str]:\n    \"\"\"Inject Black configuration from \"pyproject.toml\" into defaults in `ctx`.\n\n    Returns the path to a successfully found and read configuration file, None\n    otherwise.\n    \"\"\"\n    if not value:\n        value = find_pyproject_toml(ctx.params.get(\"src\", ()))\n        if value is None:\n            return None\n\n    try:\n        config = parse_pyproject_toml(value)\n    except (toml.TomlDecodeError, OSError) as e:\n        raise click.FileError(\n            filename=value, hint=f\"Error reading configuration file: {e}\"\n        )\n\n    if not config:\n        return None\n\n    target_version = config.get(\"target_version\")\n    if target_version is not None and not isinstance(target_version, list):\n        raise click.BadOptionUsage(\n            \"target-version\", f\"Config key target-version must be a list\"\n        )\n\n    default_map: Dict[str, Any] = {}\n    if ctx.default_map:\n        default_map.update(ctx.default_map)\n    default_map.update(config)\n\n    ctx.default_map = default_map\n    return value",
        "begin_line": 286,
        "end_line": 321,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0196078431372549,
            "pseudo_dstar_susp": 0.0196078431372549,
            "pseudo_tarantula_susp": 0.02040816326530612,
            "pseudo_op2_susp": 0.0196078431372549,
            "pseudo_barinel_susp": 0.02040816326530612
        }
    },
    {
        "name": "black.target_version_option_callback#324",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.target_version_option_callback(c: click.Context, p: Union[click.Option, click.Parameter], v: Tuple[str, ...])",
        "snippet": "def target_version_option_callback(\n    c: click.Context, p: Union[click.Option, click.Parameter], v: Tuple[str, ...]\n) -> List[TargetVersion]:\n    \"\"\"Compute the target versions from a --target-version flag.\n\n    This is its own function because mypy couldn't infer the type correctly\n    when it was a lambda, causing mypyc trouble.\n    \"\"\"\n    return [TargetVersion[val.upper()] for val in v]",
        "begin_line": 324,
        "end_line": 332,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03333333333333333,
            "pseudo_dstar_susp": 0.2,
            "pseudo_tarantula_susp": 0.010869565217391304,
            "pseudo_op2_susp": 0.2,
            "pseudo_barinel_susp": 0.010869565217391304
        }
    },
    {
        "name": "black.main#469",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.main(ctx: click.Context, code: Optional[str], line_length: int, target_version: List[TargetVersion], check: bool, diff: bool, color: bool, fast: bool, pyi: bool, py36: bool, skip_string_normalization: bool, quiet: bool, verbose: bool, include: str, exclude: str, src: Tuple[str, ...], config: Optional[str])",
        "snippet": "def main(\n    ctx: click.Context,\n    code: Optional[str],\n    line_length: int,\n    target_version: List[TargetVersion],\n    check: bool,\n    diff: bool,\n    color: bool,\n    fast: bool,\n    pyi: bool,\n    py36: bool,\n    skip_string_normalization: bool,\n    quiet: bool,\n    verbose: bool,\n    include: str,\n    exclude: str,\n    src: Tuple[str, ...],\n    config: Optional[str],\n) -> None:\n    \"\"\"The uncompromising code formatter.\"\"\"\n    write_back = WriteBack.from_configuration(check=check, diff=diff, color=color)\n    if target_version:\n        if py36:\n            err(\"Cannot use both --target-version and --py36\")\n            ctx.exit(2)\n        else:\n            versions = set(target_version)\n    elif py36:\n        err(\n            \"--py36 is deprecated and will be removed in a future version. Use\"\n            \" --target-version py36 instead.\"\n        )\n        versions = PY36_VERSIONS\n    else:\n        # We'll autodetect later.\n        versions = set()\n    mode = Mode(\n        target_versions=versions,\n        line_length=line_length,\n        is_pyi=pyi,\n        string_normalization=not skip_string_normalization,\n    )\n    if config and verbose:\n        out(f\"Using configuration from {config}.\", bold=False, fg=\"blue\")\n    if code is not None:\n        print(format_str(code, mode=mode))\n        ctx.exit(0)\n    try:\n        include_regex = re_compile_maybe_verbose(include)\n    except re.error:\n        err(f\"Invalid regular expression for include given: {include!r}\")\n        ctx.exit(2)\n    try:\n        exclude_regex = re_compile_maybe_verbose(exclude)\n    except re.error:\n        err(f\"Invalid regular expression for exclude given: {exclude!r}\")\n        ctx.exit(2)\n    report = Report(check=check, diff=diff, quiet=quiet, verbose=verbose)\n    root = find_project_root(src)\n    sources: Set[Path] = set()\n    path_empty(src, quiet, verbose, ctx)\n    for s in src:\n        p = Path(s)\n        if p.is_dir():\n            sources.update(\n                gen_python_files_in_dir(\n                    p, root, include_regex, exclude_regex, report, get_gitignore(root)\n                )\n            )\n        elif p.is_file() or s == \"-\":\n            # if a file was explicitly given, we don't care about its extension\n            sources.add(p)\n        else:\n            err(f\"invalid path: {s}\")\n    if len(sources) == 0:\n        if verbose or not quiet:\n            out(\"No Python files are present to be formatted. Nothing to do \ud83d\ude34\")\n        ctx.exit(0)\n\n    if len(sources) == 1:\n        reformat_one(\n            src=sources.pop(),\n            fast=fast,\n            write_back=write_back,\n            mode=mode,\n            report=report,\n        )\n    else:\n        reformat_many(\n            sources=sources, fast=fast, write_back=write_back, mode=mode, report=report\n        )\n\n    if verbose or not quiet:\n        out(\"Oh no! \ud83d\udca5 \ud83d\udc94 \ud83d\udca5\" if report.return_code else \"All done! \u2728 \ud83c\udf70 \u2728\")\n        click.secho(str(report), err=True)\n    ctx.exit(report.return_code)",
        "begin_line": 469,
        "end_line": 564,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.3333333333333333,
            "pseudo_dstar_susp": 0.14285714285714285,
            "pseudo_tarantula_susp": 0.3333333333333333,
            "pseudo_op2_susp": 0.14285714285714285,
            "pseudo_barinel_susp": 0.3333333333333333
        }
    },
    {
        "name": "black.path_empty#567",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.path_empty(src: Tuple[str, ...], quiet: bool, verbose: bool, ctx: click.Context)",
        "snippet": "def path_empty(\n    src: Tuple[str, ...], quiet: bool, verbose: bool, ctx: click.Context\n) -> None:\n    \"\"\"\n    Exit if there is no `src` provided for formatting\n    \"\"\"\n    if not src:\n        if verbose or not quiet:\n            out(\"No Path provided. Nothing to do \ud83d\ude34\")\n            ctx.exit(0)",
        "begin_line": 567,
        "end_line": 576,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012987012987012988,
            "pseudo_dstar_susp": 0.012987012987012988,
            "pseudo_tarantula_susp": 0.013157894736842105,
            "pseudo_op2_susp": 0.012987012987012988,
            "pseudo_barinel_susp": 0.013157894736842105
        }
    },
    {
        "name": "black.reformat_one#579",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.reformat_one(src: Path, fast: bool, write_back: WriteBack, mode: Mode, report: 'Report')",
        "snippet": "def reformat_one(\n    src: Path, fast: bool, write_back: WriteBack, mode: Mode, report: \"Report\"\n) -> None:\n    \"\"\"Reformat a single file under `src` without spawning child processes.\n\n    `fast`, `write_back`, and `mode` options are passed to\n    :func:`format_file_in_place` or :func:`format_stdin_to_stdout`.\n    \"\"\"\n    try:\n        changed = Changed.NO\n        if not src.is_file() and str(src) == \"-\":\n            if format_stdin_to_stdout(fast=fast, write_back=write_back, mode=mode):\n                changed = Changed.YES\n        else:\n            cache: Cache = {}\n            if write_back != WriteBack.DIFF:\n                cache = read_cache(mode)\n                res_src = src.resolve()\n                if res_src in cache and cache[res_src] == get_cache_info(res_src):\n                    changed = Changed.CACHED\n            if changed is not Changed.CACHED and format_file_in_place(\n                src, fast=fast, write_back=write_back, mode=mode\n            ):\n                changed = Changed.YES\n            if (write_back is WriteBack.YES and changed is not Changed.CACHED) or (\n                write_back is WriteBack.CHECK and changed is Changed.NO\n            ):\n                write_cache(cache, [src], mode)\n        report.done(src, changed)\n    except Exception as exc:\n        report.failed(src, str(exc))",
        "begin_line": 579,
        "end_line": 609,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.reformat_many#612",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.reformat_many(sources: Set[Path], fast: bool, write_back: WriteBack, mode: Mode, report: 'Report')",
        "snippet": "def reformat_many(\n    sources: Set[Path], fast: bool, write_back: WriteBack, mode: Mode, report: \"Report\"\n) -> None:\n    \"\"\"Reformat multiple files using a ProcessPoolExecutor.\"\"\"\n    loop = asyncio.get_event_loop()\n    worker_count = os.cpu_count()\n    if sys.platform == \"win32\":\n        # Work around https://bugs.python.org/issue26903\n        worker_count = min(worker_count, 61)\n    executor = ProcessPoolExecutor(max_workers=worker_count)\n    try:\n        loop.run_until_complete(\n            schedule_formatting(\n                sources=sources,\n                fast=fast,\n                write_back=write_back,\n                mode=mode,\n                report=report,\n                loop=loop,\n                executor=executor,\n            )\n        )\n    finally:\n        shutdown(loop)\n        executor.shutdown()",
        "begin_line": 612,
        "end_line": 636,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.1111111111111111,
            "pseudo_dstar_susp": 0.07692307692307693,
            "pseudo_tarantula_susp": 0.1111111111111111,
            "pseudo_op2_susp": 0.07692307692307693,
            "pseudo_barinel_susp": 0.1111111111111111
        }
    },
    {
        "name": "black.schedule_formatting#639",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.schedule_formatting(sources: Set[Path], fast: bool, write_back: WriteBack, mode: Mode, report: 'Report', loop: asyncio.AbstractEventLoop, executor: Executor)",
        "snippet": "async def schedule_formatting(\n    sources: Set[Path],\n    fast: bool,\n    write_back: WriteBack,\n    mode: Mode,\n    report: \"Report\",\n    loop: asyncio.AbstractEventLoop,\n    executor: Executor,\n) -> None:\n    \"\"\"Run formatting of `sources` in parallel using the provided `executor`.\n\n    (Use ProcessPoolExecutors for actual parallelism.)\n\n    `write_back`, `fast`, and `mode` options are passed to\n    :func:`format_file_in_place`.\n    \"\"\"\n    cache: Cache = {}\n    if write_back != WriteBack.DIFF:\n        cache = read_cache(mode)\n        sources, cached = filter_cached(cache, sources)\n        for src in sorted(cached):\n            report.done(src, Changed.CACHED)\n    if not sources:\n        return\n\n    cancelled = []\n    sources_to_cache = []\n    lock = None\n    if write_back == WriteBack.DIFF:\n        # For diff output, we need locks to ensure we don't interleave output\n        # from different processes.\n        manager = Manager()\n        lock = manager.Lock()\n    tasks = {\n        asyncio.ensure_future(\n            loop.run_in_executor(\n                executor, format_file_in_place, src, fast, mode, write_back, lock\n            )\n        ): src\n        for src in sorted(sources)\n    }\n    pending: Iterable[\"asyncio.Future[bool]\"] = tasks.keys()\n    try:\n        loop.add_signal_handler(signal.SIGINT, cancel, pending)\n        loop.add_signal_handler(signal.SIGTERM, cancel, pending)\n    except NotImplementedError:\n        # There are no good alternatives for these on Windows.\n        pass\n    while pending:\n        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)\n        for task in done:\n            src = tasks.pop(task)\n            if task.cancelled():\n                cancelled.append(task)\n            elif task.exception():\n                report.failed(src, str(task.exception()))\n            else:\n                changed = Changed.YES if task.result() else Changed.NO\n                # If the file was written back or was successfully checked as\n                # well-formatted, store this information in the cache.\n                if write_back is WriteBack.YES or (\n                    write_back is WriteBack.CHECK and changed is Changed.NO\n                ):\n                    sources_to_cache.append(src)\n                report.done(src, changed)\n    if cancelled:\n        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)\n    if sources_to_cache:\n        write_cache(cache, sources_to_cache, mode)",
        "begin_line": 639,
        "end_line": 707,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.format_file_in_place#710",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.format_file_in_place(src: Path, fast: bool, mode: Mode, write_back: WriteBack=WriteBack.NO, lock: Any=None)",
        "snippet": "def format_file_in_place(\n    src: Path,\n    fast: bool,\n    mode: Mode,\n    write_back: WriteBack = WriteBack.NO,\n    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy\n) -> bool:\n    \"\"\"Format file under `src` path. Return True if changed.\n\n    If `write_back` is DIFF, write a diff to stdout. If it is YES, write reformatted\n    code to the file.\n    `mode` and `fast` options are passed to :func:`format_file_contents`.\n    \"\"\"\n    if src.suffix == \".pyi\":\n        mode = replace(mode, is_pyi=True)\n\n    then = datetime.utcfromtimestamp(src.stat().st_mtime)\n    with open(src, \"rb\") as buf:\n        src_contents, encoding, newline = decode_bytes(buf.read())\n    try:\n        dst_contents = format_file_contents(src_contents, fast=fast, mode=mode)\n    except NothingChanged:\n        return False\n\n    if write_back == WriteBack.YES:\n        with open(src, \"w\", encoding=encoding, newline=newline) as f:\n            f.write(dst_contents)\n    elif write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        now = datetime.utcnow()\n        src_name = f\"{src}\\t{then} +0000\"\n        dst_name = f\"{src}\\t{now} +0000\"\n        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)\n\n        if write_back == write_back.COLOR_DIFF:\n            diff_contents = color_diff(diff_contents)\n\n        with lock or nullcontext():\n            f = io.TextIOWrapper(\n                sys.stdout.buffer,\n                encoding=encoding,\n                newline=newline,\n                write_through=True,\n            )\n            f = wrap_stream_for_windows(f)\n            f.write(diff_contents)\n            f.detach()\n\n    return True",
        "begin_line": 710,
        "end_line": 757,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.color_diff#760",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.color_diff(contents: str)",
        "snippet": "def color_diff(contents: str) -> str:\n    \"\"\"Inject the ANSI color codes to the diff.\"\"\"\n    lines = contents.split(\"\\n\")\n    for i, line in enumerate(lines):\n        if line.startswith(\"+++\") or line.startswith(\"---\"):\n            line = \"\\033[1;37m\" + line + \"\\033[0m\"  # bold white, reset\n        if line.startswith(\"@@\"):\n            line = \"\\033[36m\" + line + \"\\033[0m\"  # cyan, reset\n        if line.startswith(\"+\"):\n            line = \"\\033[32m\" + line + \"\\033[0m\"  # green, reset\n        elif line.startswith(\"-\"):\n            line = \"\\033[31m\" + line + \"\\033[0m\"  # red, reset\n        lines[i] = line\n    return \"\\n\".join(lines)",
        "begin_line": 760,
        "end_line": 773,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.wrap_stream_for_windows#776",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.wrap_stream_for_windows(f: io.TextIOWrapper)",
        "snippet": "def wrap_stream_for_windows(\n    f: io.TextIOWrapper,\n) -> Union[io.TextIOWrapper, \"colorama.AnsiToWin32.AnsiToWin32\"]:\n    \"\"\"\n    Wrap the stream in colorama's wrap_stream so colors are shown on Windows.\n\n    If `colorama` is not found, then no change is made. If `colorama` does\n    exist, then it handles the logic to determine whether or not to change\n    things.\n    \"\"\"\n    try:\n        from colorama import initialise\n\n        # We set `strip=False` so that we can don't have to modify\n        # test_express_diff_with_color.\n        f = initialise.wrap_stream(\n            f, convert=None, strip=False, autoreset=False, wrap=True\n        )\n\n        # wrap_stream returns a `colorama.AnsiToWin32.AnsiToWin32` object\n        # which does not have a `detach()` method. So we fake one.\n        f.detach = lambda *args, **kwargs: None  # type: ignore\n    except ImportError:\n        pass\n\n    return f",
        "begin_line": 776,
        "end_line": 801,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0013698630136986301,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.format_stdin_to_stdout#804",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.format_stdin_to_stdout(fast: bool, *, write_back: WriteBack=WriteBack.NO, mode: Mode)",
        "snippet": "def format_stdin_to_stdout(\n    fast: bool, *, write_back: WriteBack = WriteBack.NO, mode: Mode\n) -> bool:\n    \"\"\"Format file on stdin. Return True if changed.\n\n    If `write_back` is YES, write reformatted code back to stdout. If it is DIFF,\n    write a diff to stdout. The `mode` argument is passed to\n    :func:`format_file_contents`.\n    \"\"\"\n    then = datetime.utcnow()\n    src, encoding, newline = decode_bytes(sys.stdin.buffer.read())\n    dst = src\n    try:\n        dst = format_file_contents(src, fast=fast, mode=mode)\n        return True\n\n    except NothingChanged:\n        return False\n\n    finally:\n        f = io.TextIOWrapper(\n            sys.stdout.buffer, encoding=encoding, newline=newline, write_through=True\n        )\n        if write_back == WriteBack.YES:\n            f.write(dst)\n        elif write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n            now = datetime.utcnow()\n            src_name = f\"STDIN\\t{then} +0000\"\n            dst_name = f\"STDOUT\\t{now} +0000\"\n            d = diff(src, dst, src_name, dst_name)\n            if write_back == WriteBack.COLOR_DIFF:\n                d = color_diff(d)\n                f = wrap_stream_for_windows(f)\n            f.write(d)\n        f.detach()",
        "begin_line": 804,
        "end_line": 838,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.format_file_contents#841",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.format_file_contents(src_contents: str, *, fast: bool, mode: Mode)",
        "snippet": "def format_file_contents(src_contents: str, *, fast: bool, mode: Mode) -> FileContent:\n    \"\"\"Reformat contents a file and return new contents.\n\n    If `fast` is False, additionally confirm that the reformatted code is\n    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.\n    `mode` is passed to :func:`format_str`.\n    \"\"\"\n    if src_contents.strip() == \"\":\n        raise NothingChanged\n\n    dst_contents = format_str(src_contents, mode=mode)\n    if src_contents == dst_contents:\n        raise NothingChanged\n\n    if not fast:\n        assert_equivalent(src_contents, dst_contents)\n        assert_stable(src_contents, dst_contents, mode=mode)\n    return dst_contents",
        "begin_line": 841,
        "end_line": 858,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.format_str#861",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.format_str(src_contents: str, *, mode: Mode)",
        "snippet": "def format_str(src_contents: str, *, mode: Mode) -> FileContent:\n    \"\"\"Reformat a string and return new contents.\n\n    `mode` determines formatting options, such as how many characters per line are\n    allowed.  Example:\n\n    >>> import black\n    >>> print(black.format_str(\"def f(arg:str='')->None:...\", mode=Mode()))\n    def f(arg: str = \"\") -> None:\n        ...\n\n    A more complex example:\n    >>> print(\n    ...   black.format_str(\n    ...     \"def f(arg:str='')->None: hey\",\n    ...     mode=black.Mode(\n    ...       target_versions={black.TargetVersion.PY36},\n    ...       line_length=10,\n    ...       string_normalization=False,\n    ...       is_pyi=False,\n    ...     ),\n    ...   ),\n    ... )\n    def f(\n        arg: str = '',\n    ) -> None:\n        hey\n\n    \"\"\"\n    src_node = lib2to3_parse(src_contents.lstrip(), mode.target_versions)\n    dst_contents = []\n    future_imports = get_future_imports(src_node)\n    if mode.target_versions:\n        versions = mode.target_versions\n    else:\n        versions = detect_target_versions(src_node)\n    normalize_fmt_off(src_node)\n    lines = LineGenerator(\n        remove_u_prefix=\"unicode_literals\" in future_imports\n        or supports_feature(versions, Feature.UNICODE_LITERALS),\n        is_pyi=mode.is_pyi,\n        normalize_strings=mode.string_normalization,\n    )\n    elt = EmptyLineTracker(is_pyi=mode.is_pyi)\n    empty_line = Line()\n    after = 0\n    split_line_features = {\n        feature\n        for feature in {Feature.TRAILING_COMMA_IN_CALL, Feature.TRAILING_COMMA_IN_DEF}\n        if supports_feature(versions, feature)\n    }\n    for current_line in lines.visit(src_node):\n        dst_contents.append(str(empty_line) * after)\n        before, after = elt.maybe_empty_lines(current_line)\n        dst_contents.append(str(empty_line) * before)\n        for line in transform_line(\n            current_line,\n            line_length=mode.line_length,\n            normalize_strings=mode.string_normalization,\n            features=split_line_features,\n        ):\n            dst_contents.append(str(line))\n    return \"\".join(dst_contents)",
        "begin_line": 861,
        "end_line": 923,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0009930486593843098,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.decode_bytes#926",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.decode_bytes(src: bytes)",
        "snippet": "def decode_bytes(src: bytes) -> Tuple[FileContent, Encoding, NewLine]:\n    \"\"\"Return a tuple of (decoded_contents, encoding, newline).\n\n    `newline` is either CRLF or LF but `decoded_contents` is decoded with\n    universal newlines (i.e. only contains LF).\n    \"\"\"\n    srcbuf = io.BytesIO(src)\n    encoding, lines = tokenize.detect_encoding(srcbuf.readline)\n    if not lines:\n        return \"\", encoding, \"\\n\"\n\n    newline = \"\\r\\n\" if b\"\\r\\n\" == lines[0][-2:] else \"\\n\"\n    srcbuf.seek(0)\n    with io.TextIOWrapper(srcbuf, encoding) as tiow:\n        return tiow.read(), encoding, newline",
        "begin_line": 926,
        "end_line": 940,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.get_grammars#943",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.get_grammars(target_versions: Set[TargetVersion])",
        "snippet": "def get_grammars(target_versions: Set[TargetVersion]) -> List[Grammar]:\n    if not target_versions:\n        # No target_version specified, so try all grammars.\n        return [\n            # Python 3.7+\n            pygram.python_grammar_no_print_statement_no_exec_statement_async_keywords,\n            # Python 3.0-3.6\n            pygram.python_grammar_no_print_statement_no_exec_statement,\n            # Python 2.7 with future print_function import\n            pygram.python_grammar_no_print_statement,\n            # Python 2.7\n            pygram.python_grammar,\n        ]\n\n    if all(version.is_python2() for version in target_versions):\n        # Python 2-only code, so try Python 2 grammars.\n        return [\n            # Python 2.7 with future print_function import\n            pygram.python_grammar_no_print_statement,\n            # Python 2.7\n            pygram.python_grammar,\n        ]\n\n    # Python 3-compatible code, so only try Python 3 grammar.\n    grammars = []\n    # If we have to parse both, try to parse async as a keyword first\n    if not supports_feature(target_versions, Feature.ASYNC_IDENTIFIERS):\n        # Python 3.7+\n        grammars.append(\n            pygram.python_grammar_no_print_statement_no_exec_statement_async_keywords\n        )\n    if not supports_feature(target_versions, Feature.ASYNC_KEYWORDS):\n        # Python 3.0-3.6\n        grammars.append(pygram.python_grammar_no_print_statement_no_exec_statement)\n    # At least one of the above branches must have been taken, because every Python\n    # version has exactly one of the two 'ASYNC_*' flags\n    return grammars",
        "begin_line": 943,
        "end_line": 979,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.lib2to3_parse#982",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.lib2to3_parse(src_txt: str, target_versions: Iterable[TargetVersion]=())",
        "snippet": "def lib2to3_parse(src_txt: str, target_versions: Iterable[TargetVersion] = ()) -> Node:\n    \"\"\"Given a string with source, return the lib2to3 Node.\"\"\"\n    if src_txt[-1:] != \"\\n\":\n        src_txt += \"\\n\"\n\n    for grammar in get_grammars(set(target_versions)):\n        drv = driver.Driver(grammar, pytree.convert)\n        try:\n            result = drv.parse_string(src_txt, True)\n            break\n\n        except ParseError as pe:\n            lineno, column = pe.context[1]\n            lines = src_txt.splitlines()\n            try:\n                faulty_line = lines[lineno - 1]\n            except IndexError:\n                faulty_line = \"<line number missing in source>\"\n            exc = InvalidInput(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\n    else:\n        raise exc from None\n\n    if isinstance(result, Leaf):\n        result = Node(syms.file_input, [result])\n    return result",
        "begin_line": 982,
        "end_line": 1006,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.002109704641350211,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Visitor.visit#1018",
        "src_path": "black.py",
        "class_name": "black.Visitor",
        "signature": "black.Visitor.visit(self, node: LN)",
        "snippet": "    def visit(self, node: LN) -> Iterator[T]:\n        \"\"\"Main method to visit `node` and its children.\n\n        It tries to find a `visit_*()` method for the given `node.type`, like\n        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.\n        If no dedicated `visit_*()` method is found, chooses `visit_default()`\n        instead.\n\n        Then yields objects of type `T` from the selected visitor.\n        \"\"\"\n        if node.type < 256:\n            name = token.tok_name[node.type]\n        else:\n            name = str(type_repr(node.type))\n        # We explicitly branch on whether a visitor exists (instead of\n        # using self.visit_default as the default arg to getattr) in order\n        # to save needing to create a bound method object and so mypyc can\n        # generate a native call to visit_default.\n        visitf = getattr(self, f\"visit_{name}\", None)\n        if visitf:\n            yield from visitf(node)\n        else:\n            yield from self.visit_default(node)",
        "begin_line": 1018,
        "end_line": 1040,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00032331070158422246,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Visitor.visit_default#1042",
        "src_path": "black.py",
        "class_name": "black.Visitor",
        "signature": "black.Visitor.visit_default(self, node: LN)",
        "snippet": "    def visit_default(self, node: LN) -> Iterator[T]:\n        \"\"\"Default `visit_*()` implementation. Recurses to children of `node`.\"\"\"\n        if isinstance(node, Node):\n            for child in node.children:\n                yield from self.visit(child)",
        "begin_line": 1042,
        "end_line": 1046,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00032331070158422246,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.DebugVisitor.visit_default#1053",
        "src_path": "black.py",
        "class_name": "black.DebugVisitor",
        "signature": "black.DebugVisitor.visit_default(self, node: LN)",
        "snippet": "    def visit_default(self, node: LN) -> Iterator[T]:\n        indent = \" \" * (2 * self.tree_depth)\n        if isinstance(node, Node):\n            _type = type_repr(node.type)\n            out(f\"{indent}{_type}\", fg=\"yellow\")\n            self.tree_depth += 1\n            for child in node.children:\n                yield from self.visit(child)\n\n            self.tree_depth -= 1\n            out(f\"{indent}/{_type}\", fg=\"yellow\", bold=False)\n        else:\n            _type = token.tok_name.get(node.type, str(node.type))\n            out(f\"{indent}{_type}\", fg=\"blue\", nl=False)\n            if node.prefix:\n                # We don't have to handle prefixes for `Node` objects since\n                # that delegates to the first child anyway.\n                out(f\" {node.prefix!r}\", fg=\"green\", bold=False, nl=False)\n            out(f\" {node.value!r}\", fg=\"blue\", bold=False)",
        "begin_line": 1053,
        "end_line": 1071,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.DebugVisitor.show#1074",
        "src_path": "black.py",
        "class_name": "black.DebugVisitor",
        "signature": "black.DebugVisitor.show(cls, code: Union[str, Leaf, Node])",
        "snippet": "    def show(cls, code: Union[str, Leaf, Node]) -> None:\n        \"\"\"Pretty-print the lib2to3 AST of a given string of `code`.\n\n        Convenience method for debugging.\n        \"\"\"\n        v: DebugVisitor[None] = DebugVisitor()\n        if isinstance(code, str):\n            code = lib2to3_parse(code)\n        list(v.visit(code))",
        "begin_line": 1074,
        "end_line": 1082,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.BracketTracker.mark#1208",
        "src_path": "black.py",
        "class_name": "black.BracketTracker",
        "signature": "black.BracketTracker.mark(self, leaf: Leaf)",
        "snippet": "    def mark(self, leaf: Leaf) -> None:\n        \"\"\"Mark `leaf` with bracket-related metadata. Keep track of delimiters.\n\n        All leaves receive an int `bracket_depth` field that stores how deep\n        within brackets a given leaf is. 0 means there are no enclosing brackets\n        that started on this line.\n\n        If a leaf is itself a closing bracket, it receives an `opening_bracket`\n        field that it forms a pair with. This is a one-directional link to\n        avoid reference cycles.\n\n        If a leaf is a delimiter (a token on which Black can split the line if\n        needed) and it's on depth 0, its `id()` is stored in the tracker's\n        `delimiters` field.\n        \"\"\"\n        if leaf.type == token.COMMENT:\n            return\n\n        self.maybe_decrement_after_for_loop_variable(leaf)\n        self.maybe_decrement_after_lambda_arguments(leaf)\n        if leaf.type in CLOSING_BRACKETS:\n            self.depth -= 1\n            opening_bracket = self.bracket_match.pop((self.depth, leaf.type))\n            leaf.opening_bracket = opening_bracket\n        leaf.bracket_depth = self.depth\n        if self.depth == 0:\n            delim = is_split_before_delimiter(leaf, self.previous)\n            if delim and self.previous is not None:\n                self.delimiters[id(self.previous)] = delim\n            else:\n                delim = is_split_after_delimiter(leaf, self.previous)\n                if delim:\n                    self.delimiters[id(leaf)] = delim\n        if leaf.type in OPENING_BRACKETS:\n            self.bracket_match[self.depth, BRACKET[leaf.type]] = leaf\n            self.depth += 1\n        self.previous = leaf\n        self.maybe_increment_lambda_arguments(leaf)\n        self.maybe_increment_for_loop_variable(leaf)",
        "begin_line": 1208,
        "end_line": 1246,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0004930966469428008,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.BracketTracker.any_open_brackets#1248",
        "src_path": "black.py",
        "class_name": "black.BracketTracker",
        "signature": "black.BracketTracker.any_open_brackets(self)",
        "snippet": "    def any_open_brackets(self) -> bool:\n        \"\"\"Return True if there is an yet unmatched open bracket on the line.\"\"\"\n        return bool(self.bracket_match)",
        "begin_line": 1248,
        "end_line": 1250,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00032331070158422246,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.BracketTracker.max_delimiter_priority#1252",
        "src_path": "black.py",
        "class_name": "black.BracketTracker",
        "signature": "black.BracketTracker.max_delimiter_priority(self, exclude: Iterable[LeafID]=())",
        "snippet": "    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> Priority:\n        \"\"\"Return the highest priority of a delimiter found on the line.\n\n        Values are consistent with what `is_split_*_delimiter()` return.\n        Raises ValueError on no delimiters.\n        \"\"\"\n        return max(v for k, v in self.delimiters.items() if k not in exclude)",
        "begin_line": 1252,
        "end_line": 1258,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00044802867383512545,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.BracketTracker.delimiter_count_with_priority#1260",
        "src_path": "black.py",
        "class_name": "black.BracketTracker",
        "signature": "black.BracketTracker.delimiter_count_with_priority(self, priority: Priority=0)",
        "snippet": "    def delimiter_count_with_priority(self, priority: Priority = 0) -> int:\n        \"\"\"Return the number of delimiters with the given `priority`.\n\n        If no `priority` is passed, defaults to max priority on the line.\n        \"\"\"\n        if not self.delimiters:\n            return 0\n\n        priority = priority or self.max_delimiter_priority()\n        return sum(1 for p in self.delimiters.values() if p == priority)",
        "begin_line": 1260,
        "end_line": 1269,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0005399568034557236,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.BracketTracker.maybe_increment_for_loop_variable#1271",
        "src_path": "black.py",
        "class_name": "black.BracketTracker",
        "signature": "black.BracketTracker.maybe_increment_for_loop_variable(self, leaf: Leaf)",
        "snippet": "    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:\n        \"\"\"In a for loop, or comprehension, the variables are often unpacks.\n\n        To avoid splitting on the comma in this situation, increase the depth of\n        tokens between `for` and `in`.\n        \"\"\"\n        if leaf.type == token.NAME and leaf.value == \"for\":\n            self.depth += 1\n            self._for_loop_depths.append(self.depth)\n            return True\n\n        return False",
        "begin_line": 1271,
        "end_line": 1282,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0005065856129685917,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.BracketTracker.maybe_decrement_after_for_loop_variable#1284",
        "src_path": "black.py",
        "class_name": "black.BracketTracker",
        "signature": "black.BracketTracker.maybe_decrement_after_for_loop_variable(self, leaf: Leaf)",
        "snippet": "    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:\n        \"\"\"See `maybe_increment_for_loop_variable` above for explanation.\"\"\"\n        if (\n            self._for_loop_depths\n            and self._for_loop_depths[-1] == self.depth\n            and leaf.type == token.NAME\n            and leaf.value == \"in\"\n        ):\n            self.depth -= 1\n            self._for_loop_depths.pop()\n            return True\n\n        return False",
        "begin_line": 1284,
        "end_line": 1296,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0005065856129685917,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.BracketTracker.maybe_increment_lambda_arguments#1298",
        "src_path": "black.py",
        "class_name": "black.BracketTracker",
        "signature": "black.BracketTracker.maybe_increment_lambda_arguments(self, leaf: Leaf)",
        "snippet": "    def maybe_increment_lambda_arguments(self, leaf: Leaf) -> bool:\n        \"\"\"In a lambda expression, there might be more than one argument.\n\n        To avoid splitting on the comma in this situation, increase the depth of\n        tokens between `lambda` and `:`.\n        \"\"\"\n        if leaf.type == token.NAME and leaf.value == \"lambda\":\n            self.depth += 1\n            self._lambda_argument_depths.append(self.depth)\n            return True\n\n        return False",
        "begin_line": 1298,
        "end_line": 1309,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0006373486297004461,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.BracketTracker.maybe_decrement_after_lambda_arguments#1311",
        "src_path": "black.py",
        "class_name": "black.BracketTracker",
        "signature": "black.BracketTracker.maybe_decrement_after_lambda_arguments(self, leaf: Leaf)",
        "snippet": "    def maybe_decrement_after_lambda_arguments(self, leaf: Leaf) -> bool:\n        \"\"\"See `maybe_increment_lambda_arguments` above for explanation.\"\"\"\n        if (\n            self._lambda_argument_depths\n            and self._lambda_argument_depths[-1] == self.depth\n            and leaf.type == token.COLON\n        ):\n            self.depth -= 1\n            self._lambda_argument_depths.pop()\n            return True\n\n        return False",
        "begin_line": 1311,
        "end_line": 1322,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0006373486297004461,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.BracketTracker.get_open_lsqb#1324",
        "src_path": "black.py",
        "class_name": "black.BracketTracker",
        "signature": "black.BracketTracker.get_open_lsqb(self)",
        "snippet": "    def get_open_lsqb(self) -> Optional[Leaf]:\n        \"\"\"Return the most recent opening square bracket (if any).\"\"\"\n        return self.bracket_match.get((self.depth - 1, token.RSQB))",
        "begin_line": 1324,
        "end_line": 1326,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0003549875754348598,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.append#1341",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.append(self, leaf: Leaf, preformatted: bool=False)",
        "snippet": "    def append(self, leaf: Leaf, preformatted: bool = False) -> None:\n        \"\"\"Add a new `leaf` to the end of the line.\n\n        Unless `preformatted` is True, the `leaf` will receive a new consistent\n        whitespace prefix and metadata applied by :class:`BracketTracker`.\n        Trailing commas are maybe removed, unpacked for loop variables are\n        demoted from being delimiters.\n\n        Inline comments are put aside.\n        \"\"\"\n        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())\n        if not has_value:\n            return\n\n        if token.COLON == leaf.type and self.is_class_paren_empty:\n            del self.leaves[-2:]\n        if self.leaves and not preformatted:\n            # Note: at this point leaf.prefix should be empty except for\n            # imports, for which we only preserve newlines.\n            leaf.prefix += whitespace(\n                leaf, complex_subscript=self.is_complex_subscript(leaf)\n            )\n        if self.inside_brackets or not preformatted:\n            self.bracket_tracker.mark(leaf)\n            self.maybe_remove_trailing_comma(leaf)\n        if not self.append_comment(leaf):\n            self.leaves.append(leaf)",
        "begin_line": 1341,
        "end_line": 1367,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.append_safe#1369",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.append_safe(self, leaf: Leaf, preformatted: bool=False)",
        "snippet": "    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:\n        \"\"\"Like :func:`append()` but disallow invalid standalone comment structure.\n\n        Raises ValueError when any `leaf` is appended after a standalone comment\n        or when a standalone comment is not the first leaf on the line.\n        \"\"\"\n        if self.bracket_tracker.depth == 0:\n            if self.is_comment:\n                raise ValueError(\"cannot append to standalone comments\")\n\n            if self.leaves and leaf.type == STANDALONE_COMMENT:\n                raise ValueError(\n                    \"cannot append standalone comments to a populated line\"\n                )\n\n        self.append(leaf, preformatted=preformatted)",
        "begin_line": 1369,
        "end_line": 1384,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0011001100110011,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.is_comment#1387",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.is_comment(self)",
        "snippet": "    def is_comment(self) -> bool:\n        \"\"\"Is this line a standalone comment?\"\"\"\n        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT",
        "begin_line": 1387,
        "end_line": 1389,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00033955857385398983,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.is_decorator#1392",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.is_decorator(self)",
        "snippet": "    def is_decorator(self) -> bool:\n        \"\"\"Is this line a decorator?\"\"\"\n        return bool(self) and self.leaves[0].type == token.AT",
        "begin_line": 1392,
        "end_line": 1394,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00033955857385398983,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.is_import#1397",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.is_import(self)",
        "snippet": "    def is_import(self) -> bool:\n        \"\"\"Is this an import line?\"\"\"\n        return bool(self) and is_import(self.leaves[0])",
        "begin_line": 1397,
        "end_line": 1399,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0003748125937031484,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.is_class#1402",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.is_class(self)",
        "snippet": "    def is_class(self) -> bool:\n        \"\"\"Is this line a class definition?\"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.NAME\n            and self.leaves[0].value == \"class\"\n        )",
        "begin_line": 1402,
        "end_line": 1408,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00035971223021582735,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.is_stub_class#1411",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.is_stub_class(self)",
        "snippet": "    def is_stub_class(self) -> bool:\n        \"\"\"Is this line a class definition with a body consisting only of \"...\"?\"\"\"\n        return self.is_class and self.leaves[-3:] == [\n            Leaf(token.DOT, \".\") for _ in range(3)\n        ]",
        "begin_line": 1411,
        "end_line": 1415,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.is_collection_with_optional_trailing_comma#1418",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.is_collection_with_optional_trailing_comma(self)",
        "snippet": "    def is_collection_with_optional_trailing_comma(self) -> bool:\n        \"\"\"Is this line a collection literal with a trailing comma that's optional?\n\n        Note that the trailing comma in a 1-tuple is not optional.\n        \"\"\"\n        if not self.leaves or len(self.leaves) < 4:\n            return False\n\n        # Look for and address a trailing colon.\n        if self.leaves[-1].type == token.COLON:\n            closer = self.leaves[-2]\n            close_index = -2\n        else:\n            closer = self.leaves[-1]\n            close_index = -1\n        if closer.type not in CLOSING_BRACKETS or self.inside_brackets:\n            return False\n\n        if closer.type == token.RPAR:\n            # Tuples require an extra check, because if there's only\n            # one element in the tuple removing the comma unmakes the\n            # tuple.\n            #\n            # We also check for parens before looking for the trailing\n            # comma because in some cases (eg assigning a dict\n            # literal) the literal gets wrapped in temporary parens\n            # during parsing. This case is covered by the\n            # collections.py test data.\n            opener = closer.opening_bracket\n            for _open_index, leaf in enumerate(self.leaves):\n                if leaf is opener:\n                    break\n\n            else:\n                # Couldn't find the matching opening paren, play it safe.\n                return False\n\n            commas = 0\n            comma_depth = self.leaves[close_index - 1].bracket_depth\n            for leaf in self.leaves[_open_index + 1 : close_index]:\n                if leaf.bracket_depth == comma_depth and leaf.type == token.COMMA:\n                    commas += 1\n            if commas > 1:\n                # We haven't looked yet for the trailing comma because\n                # we might also have caught noop parens.\n                return self.leaves[close_index - 1].type == token.COMMA\n\n            elif commas == 1:\n                return False  # it's either a one-tuple or didn't have a trailing comma\n\n            if self.leaves[close_index - 1].type in CLOSING_BRACKETS:\n                close_index -= 1\n                closer = self.leaves[close_index]\n                if closer.type == token.RPAR:\n                    # TODO: this is a gut feeling. Will we ever see this?\n                    return False\n\n        if self.leaves[close_index - 1].type != token.COMMA:\n            return False\n\n        return True",
        "begin_line": 1418,
        "end_line": 1478,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0009930486593843098,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.is_def#1481",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.is_def(self)",
        "snippet": "    def is_def(self) -> bool:\n        \"\"\"Is this a function definition? (Also returns True for async defs.)\"\"\"\n        try:\n            first_leaf = self.leaves[0]\n        except IndexError:\n            return False\n\n        try:\n            second_leaf: Optional[Leaf] = self.leaves[1]\n        except IndexError:\n            second_leaf = None\n        return (first_leaf.type == token.NAME and first_leaf.value == \"def\") or (\n            first_leaf.type == token.ASYNC\n            and second_leaf is not None\n            and second_leaf.type == token.NAME\n            and second_leaf.value == \"def\"\n        )",
        "begin_line": 1481,
        "end_line": 1497,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0006373486297004461,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.is_class_paren_empty#1500",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.is_class_paren_empty(self)",
        "snippet": "    def is_class_paren_empty(self) -> bool:\n        \"\"\"Is this a class with no base classes but using parentheses?\n\n        Those are unnecessary and should be removed.\n        \"\"\"\n        return (\n            bool(self)\n            and len(self.leaves) == 4\n            and self.is_class\n            and self.leaves[2].type == token.LPAR\n            and self.leaves[2].value == \"(\"\n            and self.leaves[3].type == token.RPAR\n            and self.leaves[3].value == \")\"\n        )",
        "begin_line": 1500,
        "end_line": 1513,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.is_triple_quoted_string#1516",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.is_triple_quoted_string(self)",
        "snippet": "    def is_triple_quoted_string(self) -> bool:\n        \"\"\"Is the line a triple quoted string?\"\"\"\n        return (\n            bool(self)\n            and self.leaves[0].type == token.STRING\n            and self.leaves[0].value.startswith(('\"\"\"', \"'''\"))\n        )",
        "begin_line": 1516,
        "end_line": 1522,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0009140767824497258,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.contains_standalone_comments#1524",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.contains_standalone_comments(self, depth_limit: int=sys.maxsize)",
        "snippet": "    def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:\n        \"\"\"If so, needs to be split before emitting.\"\"\"\n        for leaf in self.leaves:\n            if leaf.type == STANDALONE_COMMENT and leaf.bracket_depth <= depth_limit:\n                return True\n\n        return False",
        "begin_line": 1524,
        "end_line": 1530,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0010309278350515464,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.contains_uncollapsable_type_comments#1532",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.contains_uncollapsable_type_comments(self)",
        "snippet": "    def contains_uncollapsable_type_comments(self) -> bool:\n        ignored_ids = set()\n        try:\n            last_leaf = self.leaves[-1]\n            ignored_ids.add(id(last_leaf))\n            if last_leaf.type == token.COMMA or (\n                last_leaf.type == token.RPAR and not last_leaf.value\n            ):\n                # When trailing commas or optional parens are inserted by Black for\n                # consistency, comments after the previous last element are not moved\n                # (they don't have to, rendering will still be correct).  So we ignore\n                # trailing commas and invisible.\n                last_leaf = self.leaves[-2]\n                ignored_ids.add(id(last_leaf))\n        except IndexError:\n            return False\n\n        # A type comment is uncollapsable if it is attached to a leaf\n        # that isn't at the end of the line (since that could cause it\n        # to get associated to a different argument) or if there are\n        # comments before it (since that could cause it to get hidden\n        # behind a comment.\n        comment_seen = False\n        for leaf_id, comments in self.comments.items():\n            for comment in comments:\n                if is_type_comment(comment):\n                    if comment_seen or (\n                        not is_type_comment(comment, \" ignore\")\n                        and leaf_id not in ignored_ids\n                    ):\n                        return True\n\n                comment_seen = True\n\n        return False",
        "begin_line": 1532,
        "end_line": 1566,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.contains_unsplittable_type_ignore#1568",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.contains_unsplittable_type_ignore(self)",
        "snippet": "    def contains_unsplittable_type_ignore(self) -> bool:\n        if not self.leaves:\n            return False\n\n        # If a 'type: ignore' is attached to the end of a line, we\n        # can't split the line, because we can't know which of the\n        # subexpressions the ignore was meant to apply to.\n        #\n        # We only want this to apply to actual physical lines from the\n        # original source, though: we don't want the presence of a\n        # 'type: ignore' at the end of a multiline expression to\n        # justify pushing it all onto one line. Thus we\n        # (unfortunately) need to check the actual source lines and\n        # only report an unsplittable 'type: ignore' if this line was\n        # one line in the original code.\n\n        # Grab the first and last line numbers, skipping generated leaves\n        first_line = next((l.lineno for l in self.leaves if l.lineno != 0), 0)\n        last_line = next((l.lineno for l in reversed(self.leaves) if l.lineno != 0), 0)\n\n        if first_line == last_line:\n            # We look at the last two leaves since a comma or an\n            # invisible paren could have been added at the end of the\n            # line.\n            for node in self.leaves[-2:]:\n                for comment in self.comments.get(id(node), []):\n                    if is_type_comment(comment, \" ignore\"):\n                        return True\n\n        return False",
        "begin_line": 1568,
        "end_line": 1597,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0009532888465204957,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.contains_multiline_strings#1599",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.contains_multiline_strings(self)",
        "snippet": "    def contains_multiline_strings(self) -> bool:\n        return any(is_multiline_string(leaf) for leaf in self.leaves)",
        "begin_line": 1599,
        "end_line": 1600,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0011001100110011,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.maybe_remove_trailing_comma#1602",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.maybe_remove_trailing_comma(self, closing: Leaf)",
        "snippet": "    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:\n        \"\"\"Remove trailing comma if there is one and it's safe.\"\"\"\n        if not (self.leaves and self.leaves[-1].type == token.COMMA):\n            return False\n\n        # We remove trailing commas only in the case of importing a\n        # single name from a module.\n        if not (\n            self.leaves\n            and self.is_import\n            and len(self.leaves) > 4\n            and self.leaves[-1].type == token.COMMA\n            and closing.type in CLOSING_BRACKETS\n            and self.leaves[-4].type == token.NAME\n            and (\n                # regular `from foo import bar,`\n                self.leaves[-4].value == \"import\"\n                # `from foo import (bar as baz,)\n                or (\n                    len(self.leaves) > 6\n                    and self.leaves[-6].value == \"import\"\n                    and self.leaves[-3].value == \"as\"\n                )\n                # `from foo import bar as baz,`\n                or (\n                    len(self.leaves) > 5\n                    and self.leaves[-5].value == \"import\"\n                    and self.leaves[-3].value == \"as\"\n                )\n            )\n            and closing.type == token.RPAR\n        ):\n            return False\n\n        self.remove_trailing_comma()\n        return True",
        "begin_line": 1602,
        "end_line": 1637,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0016891891891891893,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.append_comment#1639",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.append_comment(self, comment: Leaf)",
        "snippet": "    def append_comment(self, comment: Leaf) -> bool:\n        \"\"\"Add an inline or standalone comment to the line.\"\"\"\n        if (\n            comment.type == STANDALONE_COMMENT\n            and self.bracket_tracker.any_open_brackets()\n        ):\n            comment.prefix = \"\"\n            return False\n\n        if comment.type != token.COMMENT:\n            return False\n\n        if not self.leaves:\n            comment.type = STANDALONE_COMMENT\n            comment.prefix = \"\"\n            return False\n\n        last_leaf = self.leaves[-1]\n        if (\n            last_leaf.type == token.RPAR\n            and not last_leaf.value\n            and last_leaf.parent\n            and len(list(last_leaf.parent.leaves())) <= 3\n            and not is_type_comment(comment)\n        ):\n            # Comments on an optional parens wrapping a single leaf should belong to\n            # the wrapped node except if it's a type comment. Pinning the comment like\n            # this avoids unstable formatting caused by comment migration.\n            if len(self.leaves) < 2:\n                comment.type = STANDALONE_COMMENT\n                comment.prefix = \"\"\n                return False\n\n            last_leaf = self.leaves[-2]\n        self.comments.setdefault(id(last_leaf), []).append(comment)\n        return True",
        "begin_line": 1639,
        "end_line": 1674,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0009930486593843098,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.comments_after#1676",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.comments_after(self, leaf: Leaf)",
        "snippet": "    def comments_after(self, leaf: Leaf) -> List[Leaf]:\n        \"\"\"Generate comments that should appear directly after `leaf`.\"\"\"\n        return self.comments.get(id(leaf), [])",
        "begin_line": 1676,
        "end_line": 1678,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00042826552462526765,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.remove_trailing_comma#1680",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.remove_trailing_comma(self)",
        "snippet": "    def remove_trailing_comma(self) -> None:\n        \"\"\"Remove the trailing comma and moves the comments attached to it.\"\"\"\n        trailing_comma = self.leaves.pop()\n        trailing_comma_comments = self.comments.pop(id(trailing_comma), [])\n        self.comments.setdefault(id(self.leaves[-1]), []).extend(\n            trailing_comma_comments\n        )",
        "begin_line": 1680,
        "end_line": 1686,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0016891891891891893,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.is_complex_subscript#1688",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.is_complex_subscript(self, leaf: Leaf)",
        "snippet": "    def is_complex_subscript(self, leaf: Leaf) -> bool:\n        \"\"\"Return True iff `leaf` is part of a slice with non-trivial exprs.\"\"\"\n        open_lsqb = self.bracket_tracker.get_open_lsqb()\n        if open_lsqb is None:\n            return False\n\n        subscript_start = open_lsqb.next_sibling\n\n        if isinstance(subscript_start, Node):\n            if subscript_start.type == syms.listmaker:\n                return False\n\n            if subscript_start.type == syms.subscriptlist:\n                subscript_start = child_towards(subscript_start, leaf)\n        return subscript_start is not None and any(\n            n.type in TEST_DESCENDANTS for n in subscript_start.pre_order()\n        )",
        "begin_line": 1688,
        "end_line": 1704,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0005737234652897303,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.clone#1706",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.clone(self)",
        "snippet": "    def clone(self) -> \"Line\":\n        return Line(\n            depth=self.depth,\n            inside_brackets=self.inside_brackets,\n            should_explode=self.should_explode,\n        )",
        "begin_line": 1706,
        "end_line": 1711,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0006373486297004461,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.__str__#1713",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.__str__(self)",
        "snippet": "    def __str__(self) -> str:\n        \"\"\"Render the line.\"\"\"\n        if not self:\n            return \"\\n\"\n\n        indent = \"    \" * self.depth\n        leaves = iter(self.leaves)\n        first = next(leaves)\n        res = f\"{first.prefix}{indent}{first.value}\"\n        for leaf in leaves:\n            res += str(leaf)\n        for comment in itertools.chain.from_iterable(self.comments.values()):\n            res += str(comment)\n\n        return res + \"\\n\"",
        "begin_line": 1713,
        "end_line": 1727,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0005211047420531526,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Line.__bool__#1729",
        "src_path": "black.py",
        "class_name": "black.Line",
        "signature": "black.Line.__bool__(self)",
        "snippet": "    def __bool__(self) -> bool:\n        \"\"\"Return True if the line has leaves or comments.\"\"\"\n        return bool(self.leaves or self.comments)",
        "begin_line": 1729,
        "end_line": 1731,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00032331070158422246,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.EmptyLineTracker.maybe_empty_lines#1749",
        "src_path": "black.py",
        "class_name": "black.EmptyLineTracker",
        "signature": "black.EmptyLineTracker.maybe_empty_lines(self, current_line: Line)",
        "snippet": "    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n        \"\"\"Return the number of extra empty lines before and after the `current_line`.\n\n        This is for separating `def`, `async def` and `class` with extra empty\n        lines (two on module-level).\n        \"\"\"\n        before, after = self._maybe_empty_lines(current_line)\n        before = (\n            # Black should not insert empty lines at the beginning\n            # of the file\n            0\n            if self.previous_line is None\n            else before - self.previous_after\n        )\n        self.previous_after = after\n        self.previous_line = current_line\n        return before, after",
        "begin_line": 1749,
        "end_line": 1765,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00036589828027808267,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.EmptyLineTracker._maybe_empty_lines#1767",
        "src_path": "black.py",
        "class_name": "black.EmptyLineTracker",
        "signature": "black.EmptyLineTracker._maybe_empty_lines(self, current_line: Line)",
        "snippet": "    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n        max_allowed = 1\n        if current_line.depth == 0:\n            max_allowed = 1 if self.is_pyi else 2\n        if current_line.leaves:\n            # Consume the first leaf's extra newlines.\n            first_leaf = current_line.leaves[0]\n            before = first_leaf.prefix.count(\"\\n\")\n            before = min(before, max_allowed)\n            first_leaf.prefix = \"\"\n        else:\n            before = 0\n        depth = current_line.depth\n        while self.previous_defs and self.previous_defs[-1] >= depth:\n            self.previous_defs.pop()\n            if self.is_pyi:\n                before = 0 if depth else 1\n            else:\n                before = 1 if depth else 2\n        if current_line.is_decorator or current_line.is_def or current_line.is_class:\n            return self._maybe_empty_lines_for_class_or_def(current_line, before)\n\n        if (\n            self.previous_line\n            and self.previous_line.is_import\n            and not current_line.is_import\n            and depth == self.previous_line.depth\n        ):\n            return (before or 1), 0\n\n        if (\n            self.previous_line\n            and self.previous_line.is_class\n            and current_line.is_triple_quoted_string\n        ):\n            return before, 1\n\n        return before, 0",
        "begin_line": 1767,
        "end_line": 1804,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.002109704641350211,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.EmptyLineTracker._maybe_empty_lines_for_class_or_def#1806",
        "src_path": "black.py",
        "class_name": "black.EmptyLineTracker",
        "signature": "black.EmptyLineTracker._maybe_empty_lines_for_class_or_def(self, current_line: Line, before: int)",
        "snippet": "    def _maybe_empty_lines_for_class_or_def(\n        self, current_line: Line, before: int\n    ) -> Tuple[int, int]:\n        if not current_line.is_decorator:\n            self.previous_defs.append(current_line.depth)\n        if self.previous_line is None:\n            # Don't insert empty lines before the first line in the file.\n            return 0, 0\n\n        if self.previous_line.is_decorator:\n            return 0, 0\n\n        if self.previous_line.depth < current_line.depth and (\n            self.previous_line.is_class or self.previous_line.is_def\n        ):\n            return 0, 0\n\n        if (\n            self.previous_line.is_comment\n            and self.previous_line.depth == current_line.depth\n            and before == 0\n        ):\n            return 0, 0\n\n        if self.is_pyi:\n            if self.previous_line.depth > current_line.depth:\n                newlines = 1\n            elif current_line.is_class or self.previous_line.is_class:\n                if current_line.is_stub_class and self.previous_line.is_stub_class:\n                    # No blank line between classes with an empty body\n                    newlines = 0\n                else:\n                    newlines = 1\n            elif current_line.is_def and not self.previous_line.is_def:\n                # Blank line between a block of functions and a block of non-functions\n                newlines = 1\n            else:\n                newlines = 0\n        else:\n            newlines = 2\n        if current_line.depth and newlines:\n            newlines -= 1\n        return newlines, 0",
        "begin_line": 1806,
        "end_line": 1848,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.LineGenerator.line#1864",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.line(self, indent: int=0)",
        "snippet": "    def line(self, indent: int = 0) -> Iterator[Line]:\n        \"\"\"Generate a line.\n\n        If the line is empty, only emit if it makes sense.\n        If the line is too long, split it first and then generate.\n\n        If any lines were generated, set up a new current_line.\n        \"\"\"\n        if not self.current_line:\n            self.current_line.depth += indent\n            return  # Line is empty, don't emit. Creating a new one unnecessary.\n\n        complete_line = self.current_line\n        self.current_line = Line(depth=complete_line.depth + indent)\n        yield complete_line",
        "begin_line": 1864,
        "end_line": 1878,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00033955857385398983,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.LineGenerator.visit_default#1880",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_default(self, node: LN)",
        "snippet": "    def visit_default(self, node: LN) -> Iterator[Line]:\n        \"\"\"Default `visit_*()` implementation. Recurses to children of `node`.\"\"\"\n        if isinstance(node, Leaf):\n            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()\n            for comment in generate_comments(node):\n                if any_open_brackets:\n                    # any comment within brackets is subject to splitting\n                    self.current_line.append(comment)\n                elif comment.type == token.COMMENT:\n                    # regular trailing comment\n                    self.current_line.append(comment)\n                    yield from self.line()\n\n                else:\n                    # regular standalone comment\n                    yield from self.line()\n\n                    self.current_line.append(comment)\n                    yield from self.line()\n\n            normalize_prefix(node, inside_brackets=any_open_brackets)\n            if self.normalize_strings and node.type == token.STRING:\n                normalize_string_prefix(node, remove_u_prefix=self.remove_u_prefix)\n                normalize_string_quotes(node)\n            if node.type == token.NUMBER:\n                normalize_numeric_literal(node)\n            if node.type not in WHITESPACE:\n                self.current_line.append(node)\n        yield from super().visit_default(node)",
        "begin_line": 1880,
        "end_line": 1908,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0005737234652897303,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.LineGenerator.visit_INDENT#1910",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_INDENT(self, node: Leaf)",
        "snippet": "    def visit_INDENT(self, node: Leaf) -> Iterator[Line]:\n        \"\"\"Increase indentation level, maybe yield a line.\"\"\"\n        # In blib2to3 INDENT never holds comments.\n        yield from self.line(+1)\n        yield from self.visit_default(node)",
        "begin_line": 1910,
        "end_line": 1914,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0003990422984836393,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.LineGenerator.visit_DEDENT#1916",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_DEDENT(self, node: Leaf)",
        "snippet": "    def visit_DEDENT(self, node: Leaf) -> Iterator[Line]:\n        \"\"\"Decrease indentation level, maybe yield a line.\"\"\"\n        # The current line might still wait for trailing comments.  At DEDENT time\n        # there won't be any (they would be prefixes on the preceding NEWLINE).\n        # Emit the line then.\n        yield from self.line()\n\n        # While DEDENT has no value, its prefix may contain standalone comments\n        # that belong to the current indentation level.  Get 'em.\n        yield from self.visit_default(node)\n\n        # Finally, emit the dedent.\n        yield from self.line(-1)",
        "begin_line": 1916,
        "end_line": 1928,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0003990422984836393,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.LineGenerator.visit_stmt#1930",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_stmt(self, node: Node, keywords: Set[str], parens: Set[str])",
        "snippet": "    def visit_stmt(\n        self, node: Node, keywords: Set[str], parens: Set[str]\n    ) -> Iterator[Line]:\n        \"\"\"Visit a statement.\n\n        This implementation is shared for `if`, `while`, `for`, `try`, `except`,\n        `def`, `with`, `class`, `assert` and assignments.\n\n        The relevant Python language `keywords` for a given statement will be\n        NAME leaves within it. This methods puts those on a separate line.\n\n        `parens` holds a set of string leaf values immediately after which\n        invisible parens should be put.\n        \"\"\"\n        normalize_invisible_parens(node, parens_after=parens)\n        for child in node.children:\n            if child.type == token.NAME and child.value in keywords:  # type: ignore\n                yield from self.line()\n\n            yield from self.visit(child)",
        "begin_line": 1930,
        "end_line": 1949,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00038580246913580245,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.LineGenerator.visit_suite#1951",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_suite(self, node: Node)",
        "snippet": "    def visit_suite(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit a suite.\"\"\"\n        if self.is_pyi and is_stub_suite(node):\n            yield from self.visit(node.children[2])\n        else:\n            yield from self.visit_default(node)",
        "begin_line": 1951,
        "end_line": 1956,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.LineGenerator.visit_simple_stmt#1958",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_simple_stmt(self, node: Node)",
        "snippet": "    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit a statement without nested statements.\"\"\"\n        is_suite_like = node.parent and node.parent.type in STATEMENT\n        if is_suite_like:\n            if self.is_pyi and is_stub_body(node):\n                yield from self.visit_default(node)\n            else:\n                yield from self.line(+1)\n                yield from self.visit_default(node)\n                yield from self.line(-1)\n\n        else:\n            if not self.is_pyi or not node.parent or not is_stub_suite(node.parent):\n                yield from self.line()\n            yield from self.visit_default(node)",
        "begin_line": 1958,
        "end_line": 1972,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.002109704641350211,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.LineGenerator.visit_async_stmt#1974",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_async_stmt(self, node: Node)",
        "snippet": "    def visit_async_stmt(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit `async def`, `async for`, `async with`.\"\"\"\n        yield from self.line()\n\n        children = iter(node.children)\n        for child in children:\n            yield from self.visit(child)\n\n            if child.type == token.ASYNC:\n                break\n\n        internal_stmt = next(children)\n        for child in internal_stmt.children:\n            yield from self.visit(child)",
        "begin_line": 1974,
        "end_line": 1987,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0006373486297004461,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.LineGenerator.visit_decorators#1989",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_decorators(self, node: Node)",
        "snippet": "    def visit_decorators(self, node: Node) -> Iterator[Line]:\n        \"\"\"Visit decorators.\"\"\"\n        for child in node.children:\n            yield from self.line()\n            yield from self.visit(child)",
        "begin_line": 1989,
        "end_line": 1993,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0009140767824497258,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.LineGenerator.visit_SEMI#1995",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_SEMI(self, leaf: Leaf)",
        "snippet": "    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Remove a semicolon and put the other statement on a separate line.\"\"\"\n        yield from self.line()",
        "begin_line": 1995,
        "end_line": 1997,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.LineGenerator.visit_ENDMARKER#1999",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_ENDMARKER(self, leaf: Leaf)",
        "snippet": "    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:\n        \"\"\"End of file. Process outstanding comments and end with a newline.\"\"\"\n        yield from self.visit_default(leaf)\n        yield from self.line()",
        "begin_line": 1999,
        "end_line": 2002,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00032331070158422246,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.LineGenerator.visit_STANDALONE_COMMENT#2004",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_STANDALONE_COMMENT(self, leaf: Leaf)",
        "snippet": "    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:\n        if not self.current_line.bracket_tracker.any_open_brackets():\n            yield from self.line()\n        yield from self.visit_default(leaf)",
        "begin_line": 2004,
        "end_line": 2007,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0016891891891891893,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.LineGenerator.visit_factor#2009",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_factor(self, node: Node)",
        "snippet": "    def visit_factor(self, node: Node) -> Iterator[Line]:\n        \"\"\"Force parentheses between a unary op and a binary power:\n\n        -2 ** 8 -> -(2 ** 8)\n        \"\"\"\n        _operator, operand = node.children\n        if (\n            operand.type == syms.power\n            and len(operand.children) == 3\n            and operand.children[1].type == token.DOUBLESTAR\n        ):\n            lpar = Leaf(token.LPAR, \"(\")\n            rpar = Leaf(token.RPAR, \")\")\n            index = operand.remove() or 0\n            node.insert_child(index, Node(syms.atom, [lpar, operand, rpar]))\n        yield from self.visit_default(node)",
        "begin_line": 2009,
        "end_line": 2024,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.001215066828675577,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.LineGenerator.visit_STRING#2026",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.visit_STRING(self, leaf: Leaf)",
        "snippet": "    def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n        # Check if it's a docstring\n        if prev_siblings_are(\n            leaf.parent, [None, token.NEWLINE, token.INDENT, syms.simple_stmt]\n        ) and is_multiline_string(leaf):\n            prefix = \"    \" * self.current_line.depth\n            docstring = fix_docstring(leaf.value[3:-3], prefix)\n            leaf.value = leaf.value[0:3] + docstring + leaf.value[-3:]\n            normalize_string_quotes(leaf)\n\n        yield from self.visit_default(leaf)",
        "begin_line": 2026,
        "end_line": 2036,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.000697350069735007,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.LineGenerator.__post_init__#2038",
        "src_path": "black.py",
        "class_name": "black.LineGenerator",
        "signature": "black.LineGenerator.__post_init__(self)",
        "snippet": "    def __post_init__(self) -> None:\n        \"\"\"You are in a twisty little maze of passages.\"\"\"\n        v = self.visit_stmt\n        \u00d8: Set[str] = set()\n        self.visit_assert_stmt = partial(v, keywords={\"assert\"}, parens={\"assert\", \",\"})\n        self.visit_if_stmt = partial(\n            v, keywords={\"if\", \"else\", \"elif\"}, parens={\"if\", \"elif\"}\n        )\n        self.visit_while_stmt = partial(v, keywords={\"while\", \"else\"}, parens={\"while\"})\n        self.visit_for_stmt = partial(v, keywords={\"for\", \"else\"}, parens={\"for\", \"in\"})\n        self.visit_try_stmt = partial(\n            v, keywords={\"try\", \"except\", \"else\", \"finally\"}, parens=\u00d8\n        )\n        self.visit_except_clause = partial(v, keywords={\"except\"}, parens=\u00d8)\n        self.visit_with_stmt = partial(v, keywords={\"with\"}, parens=\u00d8)\n        self.visit_funcdef = partial(v, keywords={\"def\"}, parens=\u00d8)\n        self.visit_classdef = partial(v, keywords={\"class\"}, parens=\u00d8)\n        self.visit_expr_stmt = partial(v, keywords=\u00d8, parens=ASSIGNMENTS)\n        self.visit_return_stmt = partial(v, keywords={\"return\"}, parens={\"return\"})\n        self.visit_import_from = partial(v, keywords=\u00d8, parens={\"import\"})\n        self.visit_del_stmt = partial(v, keywords=\u00d8, parens={\"del\"})\n        self.visit_async_funcdef = self.visit_async_stmt\n        self.visit_decorated = self.visit_decorators",
        "begin_line": 2038,
        "end_line": 2060,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00032331070158422246,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.whitespace#2071",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.whitespace(leaf: Leaf, *, complex_subscript: bool)",
        "snippet": "def whitespace(leaf: Leaf, *, complex_subscript: bool) -> str:  # noqa: C901\n    \"\"\"Return whitespace prefix if needed for the given `leaf`.\n\n    `complex_subscript` signals whether the given leaf is part of a subscription\n    which has non-trivial arguments, like arithmetic expressions or function calls.\n    \"\"\"\n    NO = \"\"\n    SPACE = \" \"\n    DOUBLESPACE = \"  \"\n    t = leaf.type\n    p = leaf.parent\n    v = leaf.value\n    if t in ALWAYS_NO_SPACE:\n        return NO\n\n    if t == token.COMMENT:\n        return DOUBLESPACE\n\n    assert p is not None, f\"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}\"\n    if t == token.COLON and p.type not in {\n        syms.subscript,\n        syms.subscriptlist,\n        syms.sliceop,\n    }:\n        return NO\n\n    prev = leaf.prev_sibling\n    if not prev:\n        prevp = preceding_leaf(p)\n        if not prevp or prevp.type in OPENING_BRACKETS:\n            return NO\n\n        if t == token.COLON:\n            if prevp.type == token.COLON:\n                return NO\n\n            elif prevp.type != token.COMMA and not complex_subscript:\n                return NO\n\n            return SPACE\n\n        if prevp.type == token.EQUAL:\n            if prevp.parent:\n                if prevp.parent.type in {\n                    syms.arglist,\n                    syms.argument,\n                    syms.parameters,\n                    syms.varargslist,\n                }:\n                    return NO\n\n                elif prevp.parent.type == syms.typedargslist:\n                    # A bit hacky: if the equal sign has whitespace, it means we\n                    # previously found it's a typed argument.  So, we're using\n                    # that, too.\n                    return prevp.prefix\n\n        elif prevp.type in VARARGS_SPECIALS:\n            if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS):\n                return NO\n\n        elif prevp.type == token.COLON:\n            if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}:\n                return SPACE if complex_subscript else NO\n\n        elif (\n            prevp.parent\n            and prevp.parent.type == syms.factor\n            and prevp.type in MATH_OPERATORS\n        ):\n            return NO\n\n        elif (\n            prevp.type == token.RIGHTSHIFT\n            and prevp.parent\n            and prevp.parent.type == syms.shift_expr\n            and prevp.prev_sibling\n            and prevp.prev_sibling.type == token.NAME\n            and prevp.prev_sibling.value == \"print\"  # type: ignore\n        ):\n            # Python 2 print chevron\n            return NO\n\n    elif prev.type in OPENING_BRACKETS:\n        return NO\n\n    if p.type in {syms.parameters, syms.arglist}:\n        # untyped function signatures or calls\n        if not prev or prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.varargslist:\n        # lambdas\n        if prev and prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.typedargslist:\n        # typed function signatures\n        if not prev:\n            return NO\n\n        if t == token.EQUAL:\n            if prev.type != syms.tname:\n                return NO\n\n        elif prev.type == token.EQUAL:\n            # A bit hacky: if the equal sign has whitespace, it means we\n            # previously found it's a typed argument.  So, we're using that, too.\n            return prev.prefix\n\n        elif prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.tname:\n        # type names\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type != token.COMMA:\n                return NO\n\n    elif p.type == syms.trailer:\n        # attributes and calls\n        if t == token.LPAR or t == token.RPAR:\n            return NO\n\n        if not prev:\n            if t == token.DOT:\n                prevp = preceding_leaf(p)\n                if not prevp or prevp.type != token.NUMBER:\n                    return NO\n\n            elif t == token.LSQB:\n                return NO\n\n        elif prev.type != token.COMMA:\n            return NO\n\n    elif p.type == syms.argument:\n        # single argument\n        if t == token.EQUAL:\n            return NO\n\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type == token.LPAR:\n                return NO\n\n        elif prev.type in {token.EQUAL} | VARARGS_SPECIALS:\n            return NO\n\n    elif p.type == syms.decorator:\n        # decorators\n        return NO\n\n    elif p.type == syms.dotted_name:\n        if prev:\n            return NO\n\n        prevp = preceding_leaf(p)\n        if not prevp or prevp.type == token.AT or prevp.type == token.DOT:\n            return NO\n\n    elif p.type == syms.classdef:\n        if t == token.LPAR:\n            return NO\n\n        if prev and prev.type == token.LPAR:\n            return NO\n\n    elif p.type in {syms.subscript, syms.sliceop}:\n        # indexing\n        if not prev:\n            assert p.parent is not None, \"subscripts are always parented\"\n            if p.parent.type == syms.subscriptlist:\n                return SPACE\n\n            return NO\n\n        elif not complex_subscript:\n            return NO\n\n    elif p.type == syms.atom:\n        if prev and t == token.DOT:\n            # dots, but not the first one.\n            return NO\n\n    elif p.type == syms.dictsetmaker:\n        # dict unpacking\n        if prev and prev.type == token.DOUBLESTAR:\n            return NO\n\n    elif p.type in {syms.factor, syms.star_expr}:\n        # unary ops\n        if not prev:\n            prevp = preceding_leaf(p)\n            if not prevp or prevp.type in OPENING_BRACKETS:\n                return NO\n\n            prevp_parent = prevp.parent\n            assert prevp_parent is not None\n            if prevp.type == token.COLON and prevp_parent.type in {\n                syms.subscript,\n                syms.sliceop,\n            }:\n                return NO\n\n            elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument:\n                return NO\n\n        elif t in {token.NAME, token.NUMBER, token.STRING}:\n            return NO\n\n    elif p.type == syms.import_from:\n        if t == token.DOT:\n            if prev and prev.type == token.DOT:\n                return NO\n\n        elif t == token.NAME:\n            if v == \"import\":\n                return SPACE\n\n            if prev and prev.type == token.DOT:\n                return NO\n\n    elif p.type == syms.sliceop:\n        return NO\n\n    return SPACE",
        "begin_line": 2071,
        "end_line": 2298,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.preceding_leaf#2301",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.preceding_leaf(node: Optional[LN])",
        "snippet": "def preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:\n    \"\"\"Return the first leaf that precedes `node`, if any.\"\"\"\n    while node:\n        res = node.prev_sibling\n        if res:\n            if isinstance(res, Leaf):\n                return res\n\n            try:\n                return list(res.leaves())[-1]\n\n            except IndexError:\n                return None\n\n        node = node.parent\n    return None",
        "begin_line": 2301,
        "end_line": 2316,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.prev_siblings_are#2319",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.prev_siblings_are(node: Optional[LN], tokens: List[Optional[NodeType]])",
        "snippet": "def prev_siblings_are(node: Optional[LN], tokens: List[Optional[NodeType]]) -> bool:\n    \"\"\"Return if the `node` and its previous siblings match types against the provided\n    list of tokens; the provided `node`has its type matched against the last element in\n    the list.  `None` can be used as the first element to declare that the start of the\n    list is anchored at the start of its parent's children.\"\"\"\n    if not tokens:\n        return True\n    if tokens[-1] is None:\n        return node is None\n    if not node:\n        return False\n    if node.type != tokens[-1]:\n        return False\n    return prev_siblings_are(node.prev_sibling, tokens[:-1])",
        "begin_line": 2319,
        "end_line": 2332,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0006688963210702341,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.child_towards#2335",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.child_towards(ancestor: Node, descendant: LN)",
        "snippet": "def child_towards(ancestor: Node, descendant: LN) -> Optional[LN]:\n    \"\"\"Return the child of `ancestor` that contains `descendant`.\"\"\"\n    node: Optional[LN] = descendant\n    while node and node.parent != ancestor:\n        node = node.parent\n    return node",
        "begin_line": 2335,
        "end_line": 2340,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0005737234652897303,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.container_of#2343",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.container_of(leaf: Leaf)",
        "snippet": "def container_of(leaf: Leaf) -> LN:\n    \"\"\"Return `leaf` or one of its ancestors that is the topmost container of it.\n\n    By \"container\" we mean a node where `leaf` is the very first child.\n    \"\"\"\n    same_prefix = leaf.prefix\n    container: LN = leaf\n    while container:\n        parent = container.parent\n        if parent is None:\n            break\n\n        if parent.children[0].prefix != same_prefix:\n            break\n\n        if parent.type == syms.file_input:\n            break\n\n        if parent.prev_sibling is not None and parent.prev_sibling.type in BRACKETS:\n            break\n\n        container = parent\n    return container",
        "begin_line": 2343,
        "end_line": 2365,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_split_after_delimiter#2368",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_split_after_delimiter(leaf: Leaf, previous: Optional[Leaf]=None)",
        "snippet": "def is_split_after_delimiter(leaf: Leaf, previous: Optional[Leaf] = None) -> Priority:\n    \"\"\"Return the priority of the `leaf` delimiter, given a line break after it.\n\n    The delimiter priorities returned here are from those delimiters that would\n    cause a line break after themselves.\n\n    Higher numbers are higher priority.\n    \"\"\"\n    if leaf.type == token.COMMA:\n        return COMMA_PRIORITY\n\n    return 0",
        "begin_line": 2368,
        "end_line": 2379,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00043196544276457883,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_split_before_delimiter#2382",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_split_before_delimiter(leaf: Leaf, previous: Optional[Leaf]=None)",
        "snippet": "def is_split_before_delimiter(leaf: Leaf, previous: Optional[Leaf] = None) -> Priority:\n    \"\"\"Return the priority of the `leaf` delimiter, given a line break before it.\n\n    The delimiter priorities returned here are from those delimiters that would\n    cause a line break before themselves.\n\n    Higher numbers are higher priority.\n    \"\"\"\n    if is_vararg(leaf, within=VARARGS_PARENTS | UNPACKING_PARENTS):\n        # * and ** might also be MATH_OPERATORS but in this case they are not.\n        # Don't treat them as a delimiter.\n        return 0\n\n    if (\n        leaf.type == token.DOT\n        and leaf.parent\n        and leaf.parent.type not in {syms.import_from, syms.dotted_name}\n        and (previous is None or previous.type in CLOSING_BRACKETS)\n    ):\n        return DOT_PRIORITY\n\n    if (\n        leaf.type in MATH_OPERATORS\n        and leaf.parent\n        and leaf.parent.type not in {syms.factor, syms.star_expr}\n    ):\n        return MATH_PRIORITIES[leaf.type]\n\n    if leaf.type in COMPARATORS:\n        return COMPARATOR_PRIORITY\n\n    if (\n        leaf.type == token.STRING\n        and previous is not None\n        and previous.type == token.STRING\n    ):\n        return STRING_PRIORITY\n\n    if leaf.type not in {token.NAME, token.ASYNC}:\n        return 0\n\n    if (\n        leaf.value == \"for\"\n        and leaf.parent\n        and leaf.parent.type in {syms.comp_for, syms.old_comp_for}\n        or leaf.type == token.ASYNC\n    ):\n        if (\n            not isinstance(leaf.prev_sibling, Leaf)\n            or leaf.prev_sibling.value != \"async\"\n        ):\n            return COMPREHENSION_PRIORITY\n\n    if (\n        leaf.value == \"if\"\n        and leaf.parent\n        and leaf.parent.type in {syms.comp_if, syms.old_comp_if}\n    ):\n        return COMPREHENSION_PRIORITY\n\n    if leaf.value in {\"if\", \"else\"} and leaf.parent and leaf.parent.type == syms.test:\n        return TERNARY_PRIORITY\n\n    if leaf.value == \"is\":\n        return COMPARATOR_PRIORITY\n\n    if (\n        leaf.value == \"in\"\n        and leaf.parent\n        and leaf.parent.type in {syms.comp_op, syms.comparison}\n        and not (\n            previous is not None\n            and previous.type == token.NAME\n            and previous.value == \"not\"\n        )\n    ):\n        return COMPARATOR_PRIORITY\n\n    if (\n        leaf.value == \"not\"\n        and leaf.parent\n        and leaf.parent.type == syms.comp_op\n        and not (\n            previous is not None\n            and previous.type == token.NAME\n            and previous.value == \"is\"\n        )\n    ):\n        return COMPARATOR_PRIORITY\n\n    if leaf.value in LOGIC_OPERATORS and leaf.parent:\n        return LOGIC_PRIORITY\n\n    return 0",
        "begin_line": 2382,
        "end_line": 2475,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.generate_comments#2482",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.generate_comments(leaf: LN)",
        "snippet": "def generate_comments(leaf: LN) -> Iterator[Leaf]:\n    \"\"\"Clean the prefix of the `leaf` and generate comments from it, if any.\n\n    Comments in lib2to3 are shoved into the whitespace prefix.  This happens\n    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation\n    move because it does away with modifying the grammar to include all the\n    possible places in which comments can be placed.\n\n    The sad consequence for us though is that comments don't \"belong\" anywhere.\n    This is why this function generates simple parentless Leaf objects for\n    comments.  We simply don't know what the correct parent should be.\n\n    No matter though, we can live without this.  We really only need to\n    differentiate between inline and standalone comments.  The latter don't\n    share the line with any code.\n\n    Inline comments are emitted as regular token.COMMENT leaves.  Standalone\n    are emitted with a fake STANDALONE_COMMENT token identifier.\n    \"\"\"\n    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):\n        yield Leaf(pc.type, pc.value, prefix=\"\\n\" * pc.newlines)",
        "begin_line": 2482,
        "end_line": 2502,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00040816326530612246,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.list_comments#2524",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.list_comments(prefix: str, *, is_endmarker: bool)",
        "snippet": "def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:\n    \"\"\"Return a list of :class:`ProtoComment` objects parsed from the given `prefix`.\"\"\"\n    result: List[ProtoComment] = []\n    if not prefix or \"#\" not in prefix:\n        return result\n\n    consumed = 0\n    nlines = 0\n    ignored_lines = 0\n    for index, line in enumerate(prefix.split(\"\\n\")):\n        consumed += len(line) + 1  # adding the length of the split '\\n'\n        line = line.lstrip()\n        if not line:\n            nlines += 1\n        if not line.startswith(\"#\"):\n            # Escaped newlines outside of a comment are not really newlines at\n            # all. We treat a single-line comment following an escaped newline\n            # as a simple trailing comment.\n            if line.endswith(\"\\\\\"):\n                ignored_lines += 1\n            continue\n\n        if index == ignored_lines and not is_endmarker:\n            comment_type = token.COMMENT  # simple trailing comment\n        else:\n            comment_type = STANDALONE_COMMENT\n        comment = make_comment(line)\n        result.append(\n            ProtoComment(\n                type=comment_type, value=comment, newlines=nlines, consumed=consumed\n            )\n        )\n        nlines = 0\n    return result",
        "begin_line": 2524,
        "end_line": 2557,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.make_comment#2560",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.make_comment(content: str)",
        "snippet": "def make_comment(content: str) -> str:\n    \"\"\"Return a consistently formatted comment from the given `content` string.\n\n    All comments (except for \"##\", \"#!\", \"#:\", '#'\", \"#%%\") should have a single\n    space between the hash sign and the content.\n\n    If `content` didn't start with a hash sign, one is provided.\n    \"\"\"\n    content = content.rstrip()\n    if not content:\n        return \"#\"\n\n    if content[0] == \"#\":\n        content = content[1:]\n    if content and content[0] not in \" !:#'%\":\n        content = \" \" + content\n    return \"#\" + content",
        "begin_line": 2560,
        "end_line": 2576,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.transform_line#2579",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.transform_line(line: Line, line_length: int, normalize_strings: bool, features: Collection[Feature]=())",
        "snippet": "def transform_line(\n    line: Line,\n    line_length: int,\n    normalize_strings: bool,\n    features: Collection[Feature] = (),\n) -> Iterator[Line]:\n    \"\"\"Transform a `line`, potentially splitting it into many lines.\n\n    They should fit in the allotted `line_length` but might not be able to.\n\n    `features` are syntactical features that may be used in the output.\n    \"\"\"\n    if line.is_comment:\n        yield line\n        return\n\n    line_str = line_to_string(line)\n\n    def init_st(ST: Type[StringTransformer]) -> StringTransformer:\n        \"\"\"Initialize StringTransformer\"\"\"\n        return ST(line_length, normalize_strings)\n\n    string_merge = init_st(StringMerger)\n    string_paren_strip = init_st(StringParenStripper)\n    string_split = init_st(StringSplitter)\n    string_paren_wrap = init_st(StringParenWrapper)\n\n    transformers: List[Transformer]\n    if (\n        not line.contains_uncollapsable_type_comments()\n        and not line.should_explode\n        and not line.is_collection_with_optional_trailing_comma\n        and (\n            is_line_short_enough(line, line_length=line_length, line_str=line_str)\n            or line.contains_unsplittable_type_ignore()\n        )\n        and not (line.contains_standalone_comments() and line.inside_brackets)\n    ):\n        # Only apply basic string preprocessing, since lines shouldn't be split here.\n        transformers = [string_merge, string_paren_strip]\n    elif line.is_def:\n        transformers = [left_hand_split]\n    else:\n\n        def rhs(line: Line, features: Collection[Feature]) -> Iterator[Line]:\n            for omit in generate_trailers_to_omit(line, line_length):\n                lines = list(right_hand_split(line, line_length, features, omit=omit))\n                if is_line_short_enough(lines[0], line_length=line_length):\n                    yield from lines\n                    return\n\n            # All splits failed, best effort split with no omits.\n            # This mostly happens to multiline strings that are by definition\n            # reported as not fitting a single line.\n            # line_length=1 here was historically a bug that somehow became a feature.\n            # See #762 and #781 for the full story.\n            yield from right_hand_split(line, line_length=1, features=features)\n\n        if line.inside_brackets:\n            transformers = [\n                string_merge,\n                string_paren_strip,\n                delimiter_split,\n                standalone_comment_split,\n                string_split,\n                string_paren_wrap,\n                rhs,\n            ]\n        else:\n            transformers = [\n                string_merge,\n                string_paren_strip,\n                string_split,\n                string_paren_wrap,\n                rhs,\n            ]\n\n    for transform in transformers:\n        # We are accumulating lines in `result` because we might want to abort\n        # mission and return the original line in the end, or attempt a different\n        # split altogether.\n        result: List[Line] = []\n        try:\n            for l in transform(line, features):\n                if str(l).strip(\"\\n\") == line_str:\n                    raise CannotTransform(\n                        \"Line transformer returned an unchanged result\"\n                    )\n\n                result.extend(\n                    transform_line(\n                        l,\n                        line_length=line_length,\n                        normalize_strings=normalize_strings,\n                        features=features,\n                    )\n                )\n        except CannotTransform:\n            continue\n        else:\n            yield from result\n            break\n\n    else:\n        yield line",
        "begin_line": 2579,
        "end_line": 2683,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.init_st#2597",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.init_st(ST: Type[StringTransformer])",
        "snippet": "    def init_st(ST: Type[StringTransformer]) -> StringTransformer:\n        \"\"\"Initialize StringTransformer\"\"\"\n        return ST(line_length, normalize_strings)",
        "begin_line": 2597,
        "end_line": 2599,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00033955857385398983,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.rhs#2623",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.rhs(line: Line, features: Collection[Feature])",
        "snippet": "        def rhs(line: Line, features: Collection[Feature]) -> Iterator[Line]:\n            for omit in generate_trailers_to_omit(line, line_length):\n                lines = list(right_hand_split(line, line_length, features, omit=omit))\n                if is_line_short_enough(lines[0], line_length=line_length):\n                    yield from lines\n                    return\n\n            # All splits failed, best effort split with no omits.\n            # This mostly happens to multiline strings that are by definition\n            # reported as not fitting a single line.\n            # line_length=1 here was historically a bug that somehow became a feature.\n            # See #762 and #781 for the full story.\n            yield from right_hand_split(line, line_length=1, features=features)",
        "begin_line": 2623,
        "end_line": 2635,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0008438818565400844,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringTransformer.__call__#2746",
        "src_path": "black.py",
        "class_name": "black.StringTransformer",
        "signature": "black.StringTransformer.__call__(self, line: Line, _features: Collection[Feature])",
        "snippet": "    def __call__(self, line: Line, _features: Collection[Feature]) -> Iterator[Line]:\n        \"\"\"\n        StringTransformer instances have a call signature that mirrors that of\n        the Transformer type.\n\n        Raises:\n            CannotTransform(...) if the concrete StringTransformer class is unable\n            to transform @line.\n        \"\"\"\n        # Optimization to avoid calling `self.do_match(...)` when the line does\n        # not contain any string.\n        if not any(leaf.type == token.STRING for leaf in line.leaves):\n            raise CannotTransform(\"There are no strings in this line.\")\n\n        match_result = self.do_match(line)\n\n        if isinstance(match_result, Err):\n            cant_transform = match_result.err()\n            raise CannotTransform(\n                f\"The string transformer {self.__class__.__name__} does not recognize\"\n                \" this line as one that it can transform.\"\n            ) from cant_transform\n\n        string_idx = match_result.ok()\n\n        for line_result in self.do_transform(line, string_idx):\n            if isinstance(line_result, Err):\n                cant_transform = line_result.err()\n                raise CannotTransform(\n                    \"StringTransformer failed while attempting to transform string.\"\n                ) from cant_transform\n            line = line_result.ok()\n            yield line",
        "begin_line": 2746,
        "end_line": 2778,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.001215066828675577,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.CustomSplitMapMixin._get_key#2818",
        "src_path": "black.py",
        "class_name": "black.CustomSplitMapMixin",
        "signature": "black.CustomSplitMapMixin._get_key(string: str)",
        "snippet": "    def _get_key(string: str) -> \"CustomSplitMapMixin._Key\":\n        \"\"\"\n        Returns:\n            A unique identifier that is used internally to map @string to a\n            group of custom splits.\n        \"\"\"\n        return (id(string), string)",
        "begin_line": 2818,
        "end_line": 2824,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0007547169811320754,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.CustomSplitMapMixin.add_custom_splits#2826",
        "src_path": "black.py",
        "class_name": "black.CustomSplitMapMixin",
        "signature": "black.CustomSplitMapMixin.add_custom_splits(self, string: str, custom_splits: Iterable[CustomSplit])",
        "snippet": "    def add_custom_splits(\n        self, string: str, custom_splits: Iterable[CustomSplit]\n    ) -> None:\n        \"\"\"Custom Split Map Setter Method\n\n        Side Effects:\n            Adds a mapping from @string to the custom splits @custom_splits.\n        \"\"\"\n        key = self._get_key(string)\n        self._CUSTOM_SPLIT_MAP[key] = tuple(custom_splits)",
        "begin_line": 2826,
        "end_line": 2835,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0008438818565400844,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.CustomSplitMapMixin.pop_custom_splits#2837",
        "src_path": "black.py",
        "class_name": "black.CustomSplitMapMixin",
        "signature": "black.CustomSplitMapMixin.pop_custom_splits(self, string: str)",
        "snippet": "    def pop_custom_splits(self, string: str) -> List[CustomSplit]:\n        \"\"\"Custom Split Map Getter Method\n\n        Returns:\n            * A list of the custom splits that are mapped to @string, if any\n            exist.\n                OR\n            * [], otherwise.\n\n        Side Effects:\n            Deletes the mapping between @string and its associated custom\n            splits (which are returned to the caller).\n        \"\"\"\n        key = self._get_key(string)\n\n        custom_splits = self._CUSTOM_SPLIT_MAP[key]\n        del self._CUSTOM_SPLIT_MAP[key]\n\n        return list(custom_splits)",
        "begin_line": 2837,
        "end_line": 2855,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0007547169811320754,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.CustomSplitMapMixin.has_custom_splits#2857",
        "src_path": "black.py",
        "class_name": "black.CustomSplitMapMixin",
        "signature": "black.CustomSplitMapMixin.has_custom_splits(self, string: str)",
        "snippet": "    def has_custom_splits(self, string: str) -> bool:\n        \"\"\"\n        Returns:\n            True iff @string is associated with a set of custom splits.\n        \"\"\"\n        key = self._get_key(string)\n        return key in self._CUSTOM_SPLIT_MAP",
        "begin_line": 2857,
        "end_line": 2863,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0013698630136986301,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringMerger.do_match#2889",
        "src_path": "black.py",
        "class_name": "black.StringMerger",
        "signature": "black.StringMerger.do_match(self, line: Line)",
        "snippet": "    def do_match(self, line: Line) -> TMatchResult:\n        LL = line.leaves\n\n        is_valid_index = is_valid_index_factory(LL)\n\n        for (i, leaf) in enumerate(LL):\n            if (\n                leaf.type == token.STRING\n                and is_valid_index(i + 1)\n                and LL[i + 1].type == token.STRING\n            ):\n                return Ok(i)\n\n            if leaf.type == token.STRING and \"\\\\\\n\" in leaf.value:\n                return Ok(i)\n\n        return TErr(\"This line has no strings that need merging.\")",
        "begin_line": 2889,
        "end_line": 2905,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0016891891891891893,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringMerger.do_transform#2907",
        "src_path": "black.py",
        "class_name": "black.StringMerger",
        "signature": "black.StringMerger.do_transform(self, line: Line, string_idx: int)",
        "snippet": "    def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:\n        new_line = line\n        rblc_result = self.__remove_backslash_line_continuation_chars(\n            new_line, string_idx\n        )\n        if isinstance(rblc_result, Ok):\n            new_line = rblc_result.ok()\n\n        msg_result = self.__merge_string_group(new_line, string_idx)\n        if isinstance(msg_result, Ok):\n            new_line = msg_result.ok()\n\n        if isinstance(rblc_result, Err) and isinstance(msg_result, Err):\n            msg_cant_transform = msg_result.err()\n            rblc_cant_transform = rblc_result.err()\n            cant_transform = CannotTransform(\n                \"StringMerger failed to merge any strings in this line.\"\n            )\n\n            # Chain the errors together using `__cause__`.\n            msg_cant_transform.__cause__ = rblc_cant_transform\n            cant_transform.__cause__ = msg_cant_transform\n\n            yield Err(cant_transform)\n        else:\n            yield Ok(new_line)",
        "begin_line": 2907,
        "end_line": 2932,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.002109704641350211,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringMerger.__remove_backslash_line_continuation_chars#2935",
        "src_path": "black.py",
        "class_name": "black.StringMerger",
        "signature": "black.StringMerger.__remove_backslash_line_continuation_chars(line: Line, string_idx: int)",
        "snippet": "    def __remove_backslash_line_continuation_chars(\n        line: Line, string_idx: int\n    ) -> TResult[Line]:\n        \"\"\"\n        Merge strings that were split across multiple lines using\n        line-continuation backslashes.\n\n        Returns:\n            Ok(new_line), if @line contains backslash line-continuation\n            characters.\n                OR\n            Err(CannotTransform), otherwise.\n        \"\"\"\n        LL = line.leaves\n\n        string_leaf = LL[string_idx]\n        if not (\n            string_leaf.type == token.STRING\n            and \"\\\\\\n\" in string_leaf.value\n            and not has_triple_quotes(string_leaf.value)\n        ):\n            return TErr(\n                f\"String leaf {string_leaf} does not contain any backslash line\"\n                \" continuation characters.\"\n            )\n\n        new_line = line.clone()\n        new_line.comments = line.comments\n        append_leaves(new_line, line, LL)\n\n        new_string_leaf = new_line.leaves[string_idx]\n        new_string_leaf.value = new_string_leaf.value.replace(\"\\\\\\n\", \"\")\n\n        return Ok(new_line)",
        "begin_line": 2935,
        "end_line": 2968,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.002109704641350211,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringMerger.__merge_string_group#2970",
        "src_path": "black.py",
        "class_name": "black.StringMerger",
        "signature": "black.StringMerger.__merge_string_group(self, line: Line, string_idx: int)",
        "snippet": "    def __merge_string_group(self, line: Line, string_idx: int) -> TResult[Line]:\n        \"\"\"\n        Merges string group (i.e. set of adjacent strings) where the first\n        string in the group is `line.leaves[string_idx]`.\n\n        Returns:\n            Ok(new_line), if ALL of the validation checks found in\n            __validate_msg(...) pass.\n                OR\n            Err(CannotTransform), otherwise.\n        \"\"\"\n        LL = line.leaves\n\n        is_valid_index = is_valid_index_factory(LL)\n\n        vresult = self.__validate_msg(line, string_idx)\n        if isinstance(vresult, Err):\n            return vresult\n\n        # If the string group is wrapped inside an Atom node, we must make sure\n        # to later replace that Atom with our new (merged) string leaf.\n        atom_node = LL[string_idx].parent\n\n        # We will place BREAK_MARK in between every two substrings that we\n        # merge. We will then later go through our final result and use the\n        # various instances of BREAK_MARK we find to add the right values to\n        # the custom split map.\n        BREAK_MARK = \"@@@@@ BLACK BREAKPOINT MARKER @@@@@\"\n\n        QUOTE = LL[string_idx].value[-1]\n\n        def make_naked(string: str, string_prefix: str) -> str:\n            \"\"\"Strip @string (i.e. make it a \"naked\" string)\n\n            Pre-conditions:\n                * assert_is_leaf_string(@string)\n\n            Returns:\n                A string that is identical to @string except that\n                @string_prefix has been stripped, the surrounding QUOTE\n                characters have been removed, and any remaining QUOTE\n                characters have been escaped.\n            \"\"\"\n            assert_is_leaf_string(string)\n\n            RE_EVEN_BACKSLASHES = r\"(?:(?<!\\\\)(?:\\\\\\\\)*)\"\n            naked_string = string[len(string_prefix) + 1 : -1]\n            naked_string = re.sub(\n                \"(\" + RE_EVEN_BACKSLASHES + \")\" + QUOTE, r\"\\1\\\\\" + QUOTE, naked_string\n            )\n            return naked_string\n\n        # Holds the CustomSplit objects that will later be added to the custom\n        # split map.\n        custom_splits = []\n\n        # Temporary storage for the 'has_prefix' part of the CustomSplit objects.\n        prefix_tracker = []\n\n        # Sets the 'prefix' variable. This is the prefix that the final merged\n        # string will have.\n        next_str_idx = string_idx\n        prefix = \"\"\n        while (\n            not prefix\n            and is_valid_index(next_str_idx)\n            and LL[next_str_idx].type == token.STRING\n        ):\n            prefix = get_string_prefix(LL[next_str_idx].value)\n            next_str_idx += 1\n\n        # The next loop merges the string group. The final string will be\n        # contained in 'S'.\n        #\n        # The following convenience variables are used:\n        #\n        #   S: string\n        #   NS: naked string\n        #   SS: next string\n        #   NSS: naked next string\n        S = \"\"\n        NS = \"\"\n        num_of_strings = 0\n        next_str_idx = string_idx\n        while is_valid_index(next_str_idx) and LL[next_str_idx].type == token.STRING:\n            num_of_strings += 1\n\n            SS = LL[next_str_idx].value\n            next_prefix = get_string_prefix(SS)\n\n            # If this is an f-string group but this substring is not prefixed\n            # with 'f'...\n            if \"f\" in prefix and \"f\" not in next_prefix:\n                # Then we must escape any braces contained in this substring.\n                SS = re.subf(r\"(\\{|\\})\", \"{1}{1}\", SS)\n\n            NSS = make_naked(SS, next_prefix)\n\n            has_prefix = bool(next_prefix)\n            prefix_tracker.append(has_prefix)\n\n            S = prefix + QUOTE + NS + NSS + BREAK_MARK + QUOTE\n            NS = make_naked(S, prefix)\n\n            next_str_idx += 1\n\n        S_leaf = Leaf(token.STRING, S)\n        if self.normalize_strings:\n            normalize_string_quotes(S_leaf)\n\n        # Fill the 'custom_splits' list with the appropriate CustomSplit objects.\n        temp_string = S_leaf.value[len(prefix) + 1 : -1]\n        for has_prefix in prefix_tracker:\n            mark_idx = temp_string.find(BREAK_MARK)\n            assert (\n                mark_idx >= 0\n            ), \"Logic error while filling the custom string breakpoint cache.\"\n\n            temp_string = temp_string[mark_idx + len(BREAK_MARK) :]\n            breakpoint_idx = mark_idx + (len(prefix) if has_prefix else 0) + 1\n            custom_splits.append(CustomSplit(has_prefix, breakpoint_idx))\n\n        string_leaf = Leaf(token.STRING, S_leaf.value.replace(BREAK_MARK, \"\"))\n\n        if atom_node is not None:\n            replace_child(atom_node, string_leaf)\n\n        # Build the final line ('new_line') that this method will later return.\n        new_line = line.clone()\n        for (i, leaf) in enumerate(LL):\n            if i == string_idx:\n                new_line.append(string_leaf)\n\n            if string_idx <= i < string_idx + num_of_strings:\n                for comment_leaf in line.comments_after(LL[i]):\n                    new_line.append(comment_leaf, preformatted=True)\n                continue\n\n            append_leaves(new_line, line, [leaf])\n\n        self.add_custom_splits(string_leaf.value, custom_splits)\n        return Ok(new_line)",
        "begin_line": 2970,
        "end_line": 3111,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringMerger.make_naked#3001",
        "src_path": "black.py",
        "class_name": "black.StringMerger",
        "signature": "black.StringMerger.make_naked(string: str, string_prefix: str)",
        "snippet": "        def make_naked(string: str, string_prefix: str) -> str:\n            \"\"\"Strip @string (i.e. make it a \"naked\" string)\n\n            Pre-conditions:\n                * assert_is_leaf_string(@string)\n\n            Returns:\n                A string that is identical to @string except that\n                @string_prefix has been stripped, the surrounding QUOTE\n                characters have been removed, and any remaining QUOTE\n                characters have been escaped.\n            \"\"\"\n            assert_is_leaf_string(string)\n\n            RE_EVEN_BACKSLASHES = r\"(?:(?<!\\\\)(?:\\\\\\\\)*)\"\n            naked_string = string[len(string_prefix) + 1 : -1]\n            naked_string = re.sub(\n                \"(\" + RE_EVEN_BACKSLASHES + \")\" + QUOTE, r\"\\1\\\\\" + QUOTE, naked_string\n            )\n            return naked_string",
        "begin_line": 3001,
        "end_line": 3020,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0008438818565400844,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringMerger.__validate_msg#3114",
        "src_path": "black.py",
        "class_name": "black.StringMerger",
        "signature": "black.StringMerger.__validate_msg(line: Line, string_idx: int)",
        "snippet": "    def __validate_msg(line: Line, string_idx: int) -> TResult[None]:\n        \"\"\"Validate (M)erge (S)tring (G)roup\n\n        Transform-time string validation logic for __merge_string_group(...).\n\n        Returns:\n            * Ok(None), if ALL validation checks (listed below) pass.\n                OR\n            * Err(CannotTransform), if any of the following are true:\n                - The target string is not in a string group (i.e. it has no\n                  adjacent strings).\n                - The string group has more than one inline comment.\n                - The string group has an inline comment that appears to be a pragma.\n                - The set of all string prefixes in the string group is of\n                  length greater than one and is not equal to {\"\", \"f\"}.\n                - The string group consists of raw strings.\n        \"\"\"\n        num_of_inline_string_comments = 0\n        set_of_prefixes = set()\n        num_of_strings = 0\n        for leaf in line.leaves[string_idx:]:\n            if leaf.type != token.STRING:\n                # If the string group is trailed by a comma, we count the\n                # comments trailing the comma to be one of the string group's\n                # comments.\n                if leaf.type == token.COMMA and id(leaf) in line.comments:\n                    num_of_inline_string_comments += 1\n                break\n\n            if has_triple_quotes(leaf.value):\n                return TErr(\"StringMerger does NOT merge multiline strings.\")\n\n            num_of_strings += 1\n            prefix = get_string_prefix(leaf.value)\n            if \"r\" in prefix:\n                return TErr(\"StringMerger does NOT merge raw strings.\")\n\n            set_of_prefixes.add(prefix)\n\n            if id(leaf) in line.comments:\n                num_of_inline_string_comments += 1\n                if contains_pragma_comment(line.comments[id(leaf)]):\n                    return TErr(\"Cannot merge strings which have pragma comments.\")\n\n        if num_of_strings < 2:\n            return TErr(\n                f\"Not enough strings to merge (num_of_strings={num_of_strings}).\"\n            )\n\n        if num_of_inline_string_comments > 1:\n            return TErr(\n                f\"Too many inline string comments ({num_of_inline_string_comments}).\"\n            )\n\n        if len(set_of_prefixes) > 1 and set_of_prefixes != {\"\", \"f\"}:\n            return TErr(f\"Too many different prefixes ({set_of_prefixes}).\")\n\n        return Ok(None)",
        "begin_line": 3114,
        "end_line": 3171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringParenStripper.do_match#3191",
        "src_path": "black.py",
        "class_name": "black.StringParenStripper",
        "signature": "black.StringParenStripper.do_match(self, line: Line)",
        "snippet": "    def do_match(self, line: Line) -> TMatchResult:\n        LL = line.leaves\n\n        is_valid_index = is_valid_index_factory(LL)\n\n        for (idx, leaf) in enumerate(LL):\n            # Should be a string...\n            if leaf.type != token.STRING:\n                continue\n\n            # Should be preceded by a non-empty LPAR...\n            if (\n                not is_valid_index(idx - 1)\n                or LL[idx - 1].type != token.LPAR\n                or is_empty_lpar(LL[idx - 1])\n            ):\n                continue\n\n            # That LPAR should NOT be preceded by a function name or a closing\n            # bracket (which could be a function which returns a function or a\n            # list/dictionary that contains a function)...\n            if is_valid_index(idx - 2) and (\n                LL[idx - 2].type == token.NAME or LL[idx - 2].type in CLOSING_BRACKETS\n            ):\n                continue\n\n            string_idx = idx\n\n            # Skip the string trailer, if one exists.\n            string_parser = StringParser()\n            next_idx = string_parser.parse(LL, string_idx)\n\n            # Should be followed by a non-empty RPAR...\n            if (\n                is_valid_index(next_idx)\n                and LL[next_idx].type == token.RPAR\n                and not is_empty_rpar(LL[next_idx])\n            ):\n                # That RPAR should NOT be followed by a '.' symbol.\n                if is_valid_index(next_idx + 1) and LL[next_idx + 1].type == token.DOT:\n                    continue\n\n                return Ok(string_idx)\n\n        return TErr(\"This line has no strings wrapped in parens.\")",
        "begin_line": 3191,
        "end_line": 3235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringParenStripper.do_transform#3237",
        "src_path": "black.py",
        "class_name": "black.StringParenStripper",
        "signature": "black.StringParenStripper.do_transform(self, line: Line, string_idx: int)",
        "snippet": "    def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:\n        LL = line.leaves\n\n        string_parser = StringParser()\n        rpar_idx = string_parser.parse(LL, string_idx)\n\n        for leaf in (LL[string_idx - 1], LL[rpar_idx]):\n            if line.comments_after(leaf):\n                yield TErr(\n                    \"Will not strip parentheses which have comments attached to them.\"\n                )\n\n        new_line = line.clone()\n        new_line.comments = line.comments.copy()\n\n        append_leaves(new_line, line, LL[: string_idx - 1])\n\n        string_leaf = Leaf(token.STRING, LL[string_idx].value)\n        LL[string_idx - 1].remove()\n        replace_child(LL[string_idx], string_leaf)\n        new_line.append(string_leaf)\n\n        append_leaves(\n            new_line, line, LL[string_idx + 1 : rpar_idx] + LL[rpar_idx + 1 :],\n        )\n\n        LL[rpar_idx].remove()\n\n        yield Ok(new_line)",
        "begin_line": 3237,
        "end_line": 3265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.BaseStringSplitter.do_match#3301",
        "src_path": "black.py",
        "class_name": "black.BaseStringSplitter",
        "signature": "black.BaseStringSplitter.do_match(self, line: Line)",
        "snippet": "    def do_match(self, line: Line) -> TMatchResult:\n        match_result = self.do_splitter_match(line)\n        if isinstance(match_result, Err):\n            return match_result\n\n        string_idx = match_result.ok()\n        vresult = self.__validate(line, string_idx)\n        if isinstance(vresult, Err):\n            return vresult\n\n        return match_result",
        "begin_line": 3301,
        "end_line": 3311,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0006688963210702341,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.BaseStringSplitter.__validate#3313",
        "src_path": "black.py",
        "class_name": "black.BaseStringSplitter",
        "signature": "black.BaseStringSplitter.__validate(self, line: Line, string_idx: int)",
        "snippet": "    def __validate(self, line: Line, string_idx: int) -> TResult[None]:\n        \"\"\"\n        Checks that @line meets all of the requirements listed in this classes'\n        docstring. Refer to `help(BaseStringSplitter)` for a detailed\n        description of those requirements.\n\n        Returns:\n            * Ok(None), if ALL of the requirements are met.\n                OR\n            * Err(CannotTransform), if ANY of the requirements are NOT met.\n        \"\"\"\n        LL = line.leaves\n\n        string_leaf = LL[string_idx]\n\n        max_string_length = self.__get_max_string_length(line, string_idx)\n        if len(string_leaf.value) <= max_string_length:\n            return TErr(\n                \"The string itself is not what is causing this line to be too long.\"\n            )\n\n        if not string_leaf.parent or [L.type for L in string_leaf.parent.children] == [\n            token.STRING,\n            token.NEWLINE,\n        ]:\n            return TErr(\n                f\"This string ({string_leaf.value}) appears to be pointless (i.e. has\"\n                \" no parent).\"\n            )\n\n        if id(line.leaves[string_idx]) in line.comments and contains_pragma_comment(\n            line.comments[id(line.leaves[string_idx])]\n        ):\n            return TErr(\n                \"Line appears to end with an inline pragma comment. Splitting the line\"\n                \" could modify the pragma's behavior.\"\n            )\n\n        if has_triple_quotes(string_leaf.value):\n            return TErr(\"We cannot split multiline strings.\")\n\n        return Ok(None)",
        "begin_line": 3313,
        "end_line": 3354,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.BaseStringSplitter.__get_max_string_length#3356",
        "src_path": "black.py",
        "class_name": "black.BaseStringSplitter",
        "signature": "black.BaseStringSplitter.__get_max_string_length(self, line: Line, string_idx: int)",
        "snippet": "    def __get_max_string_length(self, line: Line, string_idx: int) -> int:\n        \"\"\"\n        Calculates the max string length used when attempting to determine\n        whether or not the target string is responsible for causing the line to\n        go over the line length limit.\n\n        WARNING: This method is tightly coupled to both StringSplitter and\n        (especially) StringParenWrapper. There is probably a better way to\n        accomplish what is being done here.\n\n        Returns:\n            max_string_length: such that `line.leaves[string_idx].value >\n            max_string_length` implies that the target string IS responsible\n            for causing this line to exceed the line length limit.\n        \"\"\"\n        LL = line.leaves\n\n        is_valid_index = is_valid_index_factory(LL)\n\n        # We use the shorthand \"WMA4\" in comments to abbreviate \"We must\n        # account for\". When giving examples, we use STRING to mean some/any\n        # valid string.\n        #\n        # Finally, we use the following convenience variables:\n        #\n        #   P:  The leaf that is before the target string leaf.\n        #   N:  The leaf that is after the target string leaf.\n        #   NN: The leaf that is after N.\n\n        # WMA4 the whitespace at the beginning of the line.\n        offset = line.depth * 4\n\n        if is_valid_index(string_idx - 1):\n            p_idx = string_idx - 1\n            if (\n                LL[string_idx - 1].type == token.LPAR\n                and LL[string_idx - 1].value == \"\"\n                and string_idx >= 2\n            ):\n                # If the previous leaf is an empty LPAR placeholder, we should skip it.\n                p_idx -= 1\n\n            P = LL[p_idx]\n            if P.type == token.PLUS:\n                # WMA4 a space and a '+' character (e.g. `+ STRING`).\n                offset += 2\n\n            if P.type == token.COMMA:\n                # WMA4 a space, a comma, and a closing bracket [e.g. `), STRING`].\n                offset += 3\n\n            if P.type in [token.COLON, token.EQUAL, token.NAME]:\n                # This conditional branch is meant to handle dictionary keys,\n                # variable assignments, 'return STRING' statement lines, and\n                # 'else STRING' ternary expression lines.\n\n                # WMA4 a single space.\n                offset += 1\n\n                # WMA4 the lengths of any leaves that came before that space.\n                for leaf in LL[: p_idx + 1]:\n                    offset += len(str(leaf))\n\n        if is_valid_index(string_idx + 1):\n            N = LL[string_idx + 1]\n            if N.type == token.RPAR and N.value == \"\" and len(LL) > string_idx + 2:\n                # If the next leaf is an empty RPAR placeholder, we should skip it.\n                N = LL[string_idx + 2]\n\n            if N.type == token.COMMA:\n                # WMA4 a single comma at the end of the string (e.g `STRING,`).\n                offset += 1\n\n            if is_valid_index(string_idx + 2):\n                NN = LL[string_idx + 2]\n\n                if N.type == token.DOT and NN.type == token.NAME:\n                    # This conditional branch is meant to handle method calls invoked\n                    # off of a string literal up to and including the LPAR character.\n\n                    # WMA4 the '.' character.\n                    offset += 1\n\n                    if (\n                        is_valid_index(string_idx + 3)\n                        and LL[string_idx + 3].type == token.LPAR\n                    ):\n                        # WMA4 the left parenthesis character.\n                        offset += 1\n\n                    # WMA4 the length of the method's name.\n                    offset += len(NN.value)\n\n        has_comments = False\n        for comment_leaf in line.comments_after(LL[string_idx]):\n            if not has_comments:\n                has_comments = True\n                # WMA4 two spaces before the '#' character.\n                offset += 2\n\n            # WMA4 the length of the inline comment.\n            offset += len(comment_leaf.value)\n\n        max_string_length = self.line_length - offset\n        return max_string_length",
        "begin_line": 3356,
        "end_line": 3460,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.002109704641350211,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringSplitter.do_splitter_match#3512",
        "src_path": "black.py",
        "class_name": "black.StringSplitter",
        "signature": "black.StringSplitter.do_splitter_match(self, line: Line)",
        "snippet": "    def do_splitter_match(self, line: Line) -> TMatchResult:\n        LL = line.leaves\n\n        is_valid_index = is_valid_index_factory(LL)\n\n        idx = 0\n\n        # The first leaf MAY be a '+' symbol...\n        if is_valid_index(idx) and LL[idx].type == token.PLUS:\n            idx += 1\n\n        # The next/first leaf MAY be an empty LPAR...\n        if is_valid_index(idx) and is_empty_lpar(LL[idx]):\n            idx += 1\n\n        # The next/first leaf MUST be a string...\n        if not is_valid_index(idx) or LL[idx].type != token.STRING:\n            return TErr(\"Line does not start with a string.\")\n\n        string_idx = idx\n\n        # Skip the string trailer, if one exists.\n        string_parser = StringParser()\n        idx = string_parser.parse(LL, string_idx)\n\n        # That string MAY be followed by an empty RPAR...\n        if is_valid_index(idx) and is_empty_rpar(LL[idx]):\n            idx += 1\n\n        # That string / empty RPAR leaf MAY be followed by a comma...\n        if is_valid_index(idx) and LL[idx].type == token.COMMA:\n            idx += 1\n\n        # But no more leaves are allowed...\n        if is_valid_index(idx):\n            return TErr(\"This line does not end with a string.\")\n\n        return Ok(string_idx)",
        "begin_line": 3512,
        "end_line": 3549,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.002109704641350211,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringSplitter.do_transform#3551",
        "src_path": "black.py",
        "class_name": "black.StringSplitter",
        "signature": "black.StringSplitter.do_transform(self, line: Line, string_idx: int)",
        "snippet": "    def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:\n        LL = line.leaves\n\n        QUOTE = LL[string_idx].value[-1]\n\n        is_valid_index = is_valid_index_factory(LL)\n        insert_str_child = insert_str_child_factory(LL[string_idx])\n\n        prefix = get_string_prefix(LL[string_idx].value)\n\n        # We MAY choose to drop the 'f' prefix from substrings that don't\n        # contain any f-expressions, but ONLY if the original f-string\n        # containes at least one f-expression. Otherwise, we will alter the AST\n        # of the program.\n        drop_pointless_f_prefix = (\"f\" in prefix) and re.search(\n            self.RE_FEXPR, LL[string_idx].value, re.VERBOSE\n        )\n\n        first_string_line = True\n        starts_with_plus = LL[0].type == token.PLUS\n\n        def line_needs_plus() -> bool:\n            return first_string_line and starts_with_plus\n\n        def maybe_append_plus(new_line: Line) -> None:\n            \"\"\"\n            Side Effects:\n                If @line starts with a plus and this is the first line we are\n                constructing, this function appends a PLUS leaf to @new_line\n                and replaces the old PLUS leaf in the node structure. Otherwise\n                this function does nothing.\n            \"\"\"\n            if line_needs_plus():\n                plus_leaf = Leaf(token.PLUS, \"+\")\n                replace_child(LL[0], plus_leaf)\n                new_line.append(plus_leaf)\n\n        ends_with_comma = (\n            is_valid_index(string_idx + 1) and LL[string_idx + 1].type == token.COMMA\n        )\n\n        def max_last_string() -> int:\n            \"\"\"\n            Returns:\n                The max allowed length of the string value used for the last\n                line we will construct.\n            \"\"\"\n            result = self.line_length\n            result -= line.depth * 4\n            result -= 1 if ends_with_comma else 0\n            result -= 2 if line_needs_plus() else 0\n            return result\n\n        # --- Calculate Max Break Index (for string value)\n        # We start with the line length limit\n        max_break_idx = self.line_length\n        # The last index of a string of length N is N-1.\n        max_break_idx -= 1\n        # Leading whitespace is not present in the string value (e.g. Leaf.value).\n        max_break_idx -= line.depth * 4\n        if max_break_idx < 0:\n            yield TErr(\n                f\"Unable to split {LL[string_idx].value} at such high of a line depth:\"\n                f\" {line.depth}\"\n            )\n            return\n\n        # Check if StringMerger registered any custom splits.\n        custom_splits = self.pop_custom_splits(LL[string_idx].value)\n        # We use them ONLY if none of them would produce lines that exceed the\n        # line limit.\n        use_custom_breakpoints = bool(\n            custom_splits\n            and all(csplit.break_idx <= max_break_idx for csplit in custom_splits)\n        )\n\n        # Temporary storage for the remaining chunk of the string line that\n        # can't fit onto the line currently being constructed.\n        rest_value = LL[string_idx].value\n\n        def more_splits_should_be_made() -> bool:\n            \"\"\"\n            Returns:\n                True iff `rest_value` (the remaining string value from the last\n                split), should be split again.\n            \"\"\"\n            if use_custom_breakpoints:\n                return len(custom_splits) > 1\n            else:\n                return len(rest_value) > max_last_string()\n\n        string_line_results: List[Ok[Line]] = []\n        while more_splits_should_be_made():\n            if use_custom_breakpoints:\n                # Custom User Split (manual)\n                csplit = custom_splits.pop(0)\n                break_idx = csplit.break_idx\n            else:\n                # Algorithmic Split (automatic)\n                max_bidx = max_break_idx - 2 if line_needs_plus() else max_break_idx\n                maybe_break_idx = self.__get_break_idx(rest_value, max_bidx)\n                if maybe_break_idx is None:\n                    # If we are unable to algorthmically determine a good split\n                    # and this string has custom splits registered to it, we\n                    # fall back to using them--which means we have to start\n                    # over from the beginning.\n                    if custom_splits:\n                        rest_value = LL[string_idx].value\n                        string_line_results = []\n                        first_string_line = True\n                        use_custom_breakpoints = True\n                        continue\n\n                    # Otherwise, we stop splitting here.\n                    break\n\n                break_idx = maybe_break_idx\n\n            # --- Construct `next_value`\n            next_value = rest_value[:break_idx] + QUOTE\n            if (\n                # Are we allowed to try to drop a pointless 'f' prefix?\n                drop_pointless_f_prefix\n                # If we are, will we be successful?\n                and next_value != self.__normalize_f_string(next_value, prefix)\n            ):\n                # If the current custom split did NOT originally use a prefix,\n                # then `csplit.break_idx` will be off by one after removing\n                # the 'f' prefix.\n                break_idx = (\n                    break_idx + 1\n                    if use_custom_breakpoints and not csplit.has_prefix\n                    else break_idx\n                )\n                next_value = rest_value[:break_idx] + QUOTE\n                next_value = self.__normalize_f_string(next_value, prefix)\n\n            # --- Construct `next_leaf`\n            next_leaf = Leaf(token.STRING, next_value)\n            insert_str_child(next_leaf)\n            self.__maybe_normalize_string_quotes(next_leaf)\n\n            # --- Construct `next_line`\n            next_line = line.clone()\n            maybe_append_plus(next_line)\n            next_line.append(next_leaf)\n            string_line_results.append(Ok(next_line))\n\n            rest_value = prefix + QUOTE + rest_value[break_idx:]\n            first_string_line = False\n\n        yield from string_line_results\n\n        if drop_pointless_f_prefix:\n            rest_value = self.__normalize_f_string(rest_value, prefix)\n\n        rest_leaf = Leaf(token.STRING, rest_value)\n        insert_str_child(rest_leaf)\n\n        # NOTE: I could not find a test case that verifies that the following\n        # line is actually necessary, but it seems to be. Otherwise we risk\n        # not normalizing the last substring, right?\n        self.__maybe_normalize_string_quotes(rest_leaf)\n\n        last_line = line.clone()\n        maybe_append_plus(last_line)\n\n        # If there are any leaves to the right of the target string...\n        if is_valid_index(string_idx + 1):\n            # We use `temp_value` here to determine how long the last line\n            # would be if we were to append all the leaves to the right of the\n            # target string to the last string line.\n            temp_value = rest_value\n            for leaf in LL[string_idx + 1 :]:\n                temp_value += str(leaf)\n                if leaf.type == token.LPAR:\n                    break\n\n            # Try to fit them all on the same line with the last substring...\n            if (\n                len(temp_value) <= max_last_string()\n                or LL[string_idx + 1].type == token.COMMA\n            ):\n                last_line.append(rest_leaf)\n                append_leaves(last_line, line, LL[string_idx + 1 :])\n                yield Ok(last_line)\n            # Otherwise, place the last substring on one line and everything\n            # else on a line below that...\n            else:\n                last_line.append(rest_leaf)\n                yield Ok(last_line)\n\n                non_string_line = line.clone()\n                append_leaves(non_string_line, line, LL[string_idx + 1 :])\n                yield Ok(non_string_line)\n        # Else the target string was the last leaf...\n        else:\n            last_line.append(rest_leaf)\n            last_line.comments = line.comments.copy()\n            yield Ok(last_line)",
        "begin_line": 3551,
        "end_line": 3750,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringSplitter.line_needs_plus#3572",
        "src_path": "black.py",
        "class_name": "black.StringSplitter",
        "signature": "black.StringSplitter.line_needs_plus()",
        "snippet": "        def line_needs_plus() -> bool:\n            return first_string_line and starts_with_plus",
        "begin_line": 3572,
        "end_line": 3573,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0007547169811320754,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringSplitter.maybe_append_plus#3575",
        "src_path": "black.py",
        "class_name": "black.StringSplitter",
        "signature": "black.StringSplitter.maybe_append_plus(new_line: Line)",
        "snippet": "        def maybe_append_plus(new_line: Line) -> None:\n            \"\"\"\n            Side Effects:\n                If @line starts with a plus and this is the first line we are\n                constructing, this function appends a PLUS leaf to @new_line\n                and replaces the old PLUS leaf in the node structure. Otherwise\n                this function does nothing.\n            \"\"\"\n            if line_needs_plus():\n                plus_leaf = Leaf(token.PLUS, \"+\")\n                replace_child(LL[0], plus_leaf)\n                new_line.append(plus_leaf)",
        "begin_line": 3575,
        "end_line": 3586,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.002109704641350211,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringSplitter.max_last_string#3592",
        "src_path": "black.py",
        "class_name": "black.StringSplitter",
        "signature": "black.StringSplitter.max_last_string()",
        "snippet": "        def max_last_string() -> int:\n            \"\"\"\n            Returns:\n                The max allowed length of the string value used for the last\n                line we will construct.\n            \"\"\"\n            result = self.line_length\n            result -= line.depth * 4\n            result -= 1 if ends_with_comma else 0\n            result -= 2 if line_needs_plus() else 0\n            return result",
        "begin_line": 3592,
        "end_line": 3602,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0009532888465204957,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringSplitter.more_splits_should_be_made#3631",
        "src_path": "black.py",
        "class_name": "black.StringSplitter",
        "signature": "black.StringSplitter.more_splits_should_be_made()",
        "snippet": "        def more_splits_should_be_made() -> bool:\n            \"\"\"\n            Returns:\n                True iff `rest_value` (the remaining string value from the last\n                split), should be split again.\n            \"\"\"\n            if use_custom_breakpoints:\n                return len(custom_splits) > 1\n            else:\n                return len(rest_value) > max_last_string()",
        "begin_line": 3631,
        "end_line": 3640,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0013698630136986301,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringSplitter.__get_break_idx#3752",
        "src_path": "black.py",
        "class_name": "black.StringSplitter",
        "signature": "black.StringSplitter.__get_break_idx(self, string: str, max_break_idx: int)",
        "snippet": "    def __get_break_idx(self, string: str, max_break_idx: int) -> Optional[int]:\n        \"\"\"\n        This method contains the algorithm that StringSplitter uses to\n        determine which character to split each string at.\n\n        Args:\n            @string: The substring that we are attempting to split.\n            @max_break_idx: The ideal break index. We will return this value if it\n            meets all the necessary conditions. In the likely event that it\n            doesn't we will try to find the closest index BELOW @max_break_idx\n            that does. If that fails, we will expand our search by also\n            considering all valid indices ABOVE @max_break_idx.\n\n        Pre-Conditions:\n            * assert_is_leaf_string(@string)\n            * 0 <= @max_break_idx < len(@string)\n\n        Returns:\n            break_idx, if an index is able to be found that meets all of the\n            conditions listed in the 'Transformations' section of this classes'\n            docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        is_valid_index = is_valid_index_factory(string)\n\n        assert is_valid_index(max_break_idx)\n        assert_is_leaf_string(string)\n\n        _fexpr_slices: Optional[List[Tuple[Index, Index]]] = None\n\n        def fexpr_slices() -> Iterator[Tuple[Index, Index]]:\n            \"\"\"\n            Yields:\n                All ranges of @string which, if @string were to be split there,\n                would result in the splitting of an f-expression (which is NOT\n                allowed).\n            \"\"\"\n            nonlocal _fexpr_slices\n\n            if _fexpr_slices is None:\n                _fexpr_slices = []\n                for match in re.finditer(self.RE_FEXPR, string, re.VERBOSE):\n                    _fexpr_slices.append(match.span())\n\n            yield from _fexpr_slices\n\n        is_fstring = \"f\" in get_string_prefix(string)\n\n        def breaks_fstring_expression(i: Index) -> bool:\n            \"\"\"\n            Returns:\n                True iff returning @i would result in the splitting of an\n                f-expression (which is NOT allowed).\n            \"\"\"\n            if not is_fstring:\n                return False\n\n            for (start, end) in fexpr_slices():\n                if start <= i < end:\n                    return True\n\n            return False\n\n        def passes_all_checks(i: Index) -> bool:\n            \"\"\"\n            Returns:\n                True iff ALL of the conditions listed in the 'Transformations'\n                section of this classes' docstring would be be met by returning @i.\n            \"\"\"\n            is_space = string[i] == \" \"\n            is_big_enough = (\n                len(string[i:]) >= self.MIN_SUBSTR_SIZE\n                and len(string[:i]) >= self.MIN_SUBSTR_SIZE\n            )\n            return is_space and is_big_enough and not breaks_fstring_expression(i)\n\n        # First, we check all indices BELOW @max_break_idx.\n        break_idx = max_break_idx\n        while is_valid_index(break_idx - 1) and not passes_all_checks(break_idx):\n            break_idx -= 1\n\n        if not passes_all_checks(break_idx):\n            # If that fails, we check all indices ABOVE @max_break_idx.\n            #\n            # If we are able to find a valid index here, the next line is going\n            # to be longer than the specified line length, but it's probably\n            # better than doing nothing at all.\n            break_idx = max_break_idx + 1\n            while is_valid_index(break_idx + 1) and not passes_all_checks(break_idx):\n                break_idx += 1\n\n            if not is_valid_index(break_idx) or not passes_all_checks(break_idx):\n                return None\n\n        return break_idx",
        "begin_line": 3752,
        "end_line": 3847,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringSplitter.fexpr_slices#3783",
        "src_path": "black.py",
        "class_name": "black.StringSplitter",
        "signature": "black.StringSplitter.fexpr_slices()",
        "snippet": "        def fexpr_slices() -> Iterator[Tuple[Index, Index]]:\n            \"\"\"\n            Yields:\n                All ranges of @string which, if @string were to be split there,\n                would result in the splitting of an f-expression (which is NOT\n                allowed).\n            \"\"\"\n            nonlocal _fexpr_slices\n\n            if _fexpr_slices is None:\n                _fexpr_slices = []\n                for match in re.finditer(self.RE_FEXPR, string, re.VERBOSE):\n                    _fexpr_slices.append(match.span())\n\n            yield from _fexpr_slices",
        "begin_line": 3783,
        "end_line": 3797,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringSplitter.breaks_fstring_expression#3801",
        "src_path": "black.py",
        "class_name": "black.StringSplitter",
        "signature": "black.StringSplitter.breaks_fstring_expression(i: Index)",
        "snippet": "        def breaks_fstring_expression(i: Index) -> bool:\n            \"\"\"\n            Returns:\n                True iff returning @i would result in the splitting of an\n                f-expression (which is NOT allowed).\n            \"\"\"\n            if not is_fstring:\n                return False\n\n            for (start, end) in fexpr_slices():\n                if start <= i < end:\n                    return True\n\n            return False",
        "begin_line": 3801,
        "end_line": 3814,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringSplitter.passes_all_checks#3816",
        "src_path": "black.py",
        "class_name": "black.StringSplitter",
        "signature": "black.StringSplitter.passes_all_checks(i: Index)",
        "snippet": "        def passes_all_checks(i: Index) -> bool:\n            \"\"\"\n            Returns:\n                True iff ALL of the conditions listed in the 'Transformations'\n                section of this classes' docstring would be be met by returning @i.\n            \"\"\"\n            is_space = string[i] == \" \"\n            is_big_enough = (\n                len(string[i:]) >= self.MIN_SUBSTR_SIZE\n                and len(string[:i]) >= self.MIN_SUBSTR_SIZE\n            )\n            return is_space and is_big_enough and not breaks_fstring_expression(i)",
        "begin_line": 3816,
        "end_line": 3827,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0013698630136986301,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringSplitter.__maybe_normalize_string_quotes#3849",
        "src_path": "black.py",
        "class_name": "black.StringSplitter",
        "signature": "black.StringSplitter.__maybe_normalize_string_quotes(self, leaf: Leaf)",
        "snippet": "    def __maybe_normalize_string_quotes(self, leaf: Leaf) -> None:\n        if self.normalize_strings:\n            normalize_string_quotes(leaf)",
        "begin_line": 3849,
        "end_line": 3851,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0007547169811320754,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringSplitter.__normalize_f_string#3853",
        "src_path": "black.py",
        "class_name": "black.StringSplitter",
        "signature": "black.StringSplitter.__normalize_f_string(self, string: str, prefix: str)",
        "snippet": "    def __normalize_f_string(self, string: str, prefix: str) -> str:\n        \"\"\"\n        Pre-Conditions:\n            * assert_is_leaf_string(@string)\n\n        Returns:\n            * If @string is an f-string that contains no f-expressions, we\n            return a string identical to @string except that the 'f' prefix\n            has been stripped and all double braces (i.e. '{{' or '}}') have\n            been normalized (i.e. turned into '{' or '}').\n                OR\n            * Otherwise, we return @string.\n        \"\"\"\n        assert_is_leaf_string(string)\n\n        if \"f\" in prefix and not re.search(self.RE_FEXPR, string, re.VERBOSE):\n            new_prefix = prefix.replace(\"f\", \"\")\n\n            temp = string[len(prefix) :]\n            temp = re.sub(r\"\\{\\{\", \"{\", temp)\n            temp = re.sub(r\"\\}\\}\", \"}\", temp)\n            new_string = temp\n\n            return f\"{new_prefix}{new_string}\"\n        else:\n            return string",
        "begin_line": 3853,
        "end_line": 3878,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.001215066828675577,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringParenWrapper.do_splitter_match#3930",
        "src_path": "black.py",
        "class_name": "black.StringParenWrapper",
        "signature": "black.StringParenWrapper.do_splitter_match(self, line: Line)",
        "snippet": "    def do_splitter_match(self, line: Line) -> TMatchResult:\n        LL = line.leaves\n\n        string_idx = None\n        string_idx = string_idx or self._return_match(LL)\n        string_idx = string_idx or self._else_match(LL)\n        string_idx = string_idx or self._assert_match(LL)\n        string_idx = string_idx or self._assign_match(LL)\n        string_idx = string_idx or self._dict_match(LL)\n\n        if string_idx is not None:\n            string_value = line.leaves[string_idx].value\n            # If the string has no spaces...\n            if \" \" not in string_value:\n                # And will still violate the line length limit when split...\n                max_string_length = self.line_length - ((line.depth + 1) * 4)\n                if len(string_value) > max_string_length:\n                    # And has no associated custom splits...\n                    if not self.has_custom_splits(string_value):\n                        # Then we should NOT put this string on its own line.\n                        return TErr(\n                            \"We do not wrap long strings in parentheses when the\"\n                            \" resultant line would still be over the specified line\"\n                            \" length and can't be split further by StringSplitter.\"\n                        )\n            return Ok(string_idx)\n\n        return TErr(\"This line does not contain any non-atomic strings.\")",
        "begin_line": 3930,
        "end_line": 3957,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0016891891891891893,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringParenWrapper._return_match#3960",
        "src_path": "black.py",
        "class_name": "black.StringParenWrapper",
        "signature": "black.StringParenWrapper._return_match(LL: List[Leaf])",
        "snippet": "    def _return_match(LL: List[Leaf]) -> Optional[int]:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the return/yield statement\n            requirements listed in the 'Requirements' section of this classes'\n            docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is apart of a return/yield statement and the first leaf\n        # contains either the \"return\" or \"yield\" keywords...\n        if parent_type(LL[0]) in [syms.return_stmt, syms.yield_expr] and LL[\n            0\n        ].value in [\"return\", \"yield\"]:\n            is_valid_index = is_valid_index_factory(LL)\n\n            idx = 2 if is_valid_index(1) and is_empty_par(LL[1]) else 1\n            # The next visible leaf MUST contain a string...\n            if is_valid_index(idx) and LL[idx].type == token.STRING:\n                return idx\n\n        return None",
        "begin_line": 3960,
        "end_line": 3982,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0010309278350515464,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringParenWrapper._else_match#3985",
        "src_path": "black.py",
        "class_name": "black.StringParenWrapper",
        "signature": "black.StringParenWrapper._else_match(LL: List[Leaf])",
        "snippet": "    def _else_match(LL: List[Leaf]) -> Optional[int]:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the ternary expression\n            requirements listed in the 'Requirements' section of this classes'\n            docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is apart of a ternary expression and the first leaf\n        # contains the \"else\" keyword...\n        if (\n            parent_type(LL[0]) == syms.test\n            and LL[0].type == token.NAME\n            and LL[0].value == \"else\"\n        ):\n            is_valid_index = is_valid_index_factory(LL)\n\n            idx = 2 if is_valid_index(1) and is_empty_par(LL[1]) else 1\n            # The next visible leaf MUST contain a string...\n            if is_valid_index(idx) and LL[idx].type == token.STRING:\n                return idx\n\n        return None",
        "begin_line": 3985,
        "end_line": 4009,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringParenWrapper._assert_match#4012",
        "src_path": "black.py",
        "class_name": "black.StringParenWrapper",
        "signature": "black.StringParenWrapper._assert_match(LL: List[Leaf])",
        "snippet": "    def _assert_match(LL: List[Leaf]) -> Optional[int]:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the assert statement\n            requirements listed in the 'Requirements' section of this classes'\n            docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is apart of an assert statement and the first leaf\n        # contains the \"assert\" keyword...\n        if parent_type(LL[0]) == syms.assert_stmt and LL[0].value == \"assert\":\n            is_valid_index = is_valid_index_factory(LL)\n\n            for (i, leaf) in enumerate(LL):\n                # We MUST find a comma...\n                if leaf.type == token.COMMA:\n                    idx = i + 2 if is_empty_par(LL[i + 1]) else i + 1\n\n                    # That comma MUST be followed by a string...\n                    if is_valid_index(idx) and LL[idx].type == token.STRING:\n                        string_idx = idx\n\n                        # Skip the string trailer, if one exists.\n                        string_parser = StringParser()\n                        idx = string_parser.parse(LL, string_idx)\n\n                        # But no more leaves are allowed...\n                        if not is_valid_index(idx):\n                            return string_idx\n\n        return None",
        "begin_line": 4012,
        "end_line": 4044,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0007547169811320754,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringParenWrapper._assign_match#4047",
        "src_path": "black.py",
        "class_name": "black.StringParenWrapper",
        "signature": "black.StringParenWrapper._assign_match(LL: List[Leaf])",
        "snippet": "    def _assign_match(LL: List[Leaf]) -> Optional[int]:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the assignment statement\n            requirements listed in the 'Requirements' section of this classes'\n            docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is apart of an expression statement or is a function\n        # argument AND the first leaf contains a variable name...\n        if (\n            parent_type(LL[0]) in [syms.expr_stmt, syms.argument, syms.power]\n            and LL[0].type == token.NAME\n        ):\n            is_valid_index = is_valid_index_factory(LL)\n\n            for (i, leaf) in enumerate(LL):\n                # We MUST find either an '=' or '+=' symbol...\n                if leaf.type in [token.EQUAL, token.PLUSEQUAL]:\n                    idx = i + 2 if is_empty_par(LL[i + 1]) else i + 1\n\n                    # That symbol MUST be followed by a string...\n                    if is_valid_index(idx) and LL[idx].type == token.STRING:\n                        string_idx = idx\n\n                        # Skip the string trailer, if one exists.\n                        string_parser = StringParser()\n                        idx = string_parser.parse(LL, string_idx)\n\n                        # The next leaf MAY be a comma iff this line is apart\n                        # of a function argument...\n                        if (\n                            parent_type(LL[0]) == syms.argument\n                            and is_valid_index(idx)\n                            and LL[idx].type == token.COMMA\n                        ):\n                            idx += 1\n\n                        # But no more leaves are allowed...\n                        if not is_valid_index(idx):\n                            return string_idx\n\n        return None",
        "begin_line": 4047,
        "end_line": 4091,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.002109704641350211,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringParenWrapper._dict_match#4094",
        "src_path": "black.py",
        "class_name": "black.StringParenWrapper",
        "signature": "black.StringParenWrapper._dict_match(LL: List[Leaf])",
        "snippet": "    def _dict_match(LL: List[Leaf]) -> Optional[int]:\n        \"\"\"\n        Returns:\n            string_idx such that @LL[string_idx] is equal to our target (i.e.\n            matched) string, if this line matches the dictionary key assignment\n            statement requirements listed in the 'Requirements' section of this\n            classes' docstring.\n                OR\n            None, otherwise.\n        \"\"\"\n        # If this line is apart of a dictionary key assignment...\n        if syms.dictsetmaker in [parent_type(LL[0]), parent_type(LL[0].parent)]:\n            is_valid_index = is_valid_index_factory(LL)\n\n            for (i, leaf) in enumerate(LL):\n                # We MUST find a colon...\n                if leaf.type == token.COLON:\n                    idx = i + 2 if is_empty_par(LL[i + 1]) else i + 1\n\n                    # That colon MUST be followed by a string...\n                    if is_valid_index(idx) and LL[idx].type == token.STRING:\n                        string_idx = idx\n\n                        # Skip the string trailer, if one exists.\n                        string_parser = StringParser()\n                        idx = string_parser.parse(LL, string_idx)\n\n                        # That string MAY be followed by a comma...\n                        if is_valid_index(idx) and LL[idx].type == token.COMMA:\n                            idx += 1\n\n                        # But no more leaves are allowed...\n                        if not is_valid_index(idx):\n                            return string_idx\n\n        return None",
        "begin_line": 4094,
        "end_line": 4129,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringParenWrapper.do_transform#4131",
        "src_path": "black.py",
        "class_name": "black.StringParenWrapper",
        "signature": "black.StringParenWrapper.do_transform(self, line: Line, string_idx: int)",
        "snippet": "    def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:\n        LL = line.leaves\n\n        is_valid_index = is_valid_index_factory(LL)\n        insert_str_child = insert_str_child_factory(LL[string_idx])\n\n        comma_idx = len(LL) - 1\n        ends_with_comma = False\n        if LL[comma_idx].type == token.COMMA:\n            ends_with_comma = True\n\n        leaves_to_steal_comments_from = [LL[string_idx]]\n        if ends_with_comma:\n            leaves_to_steal_comments_from.append(LL[comma_idx])\n\n        # --- First Line\n        first_line = line.clone()\n        left_leaves = LL[:string_idx]\n\n        # We have to remember to account for (possibly invisible) LPAR and RPAR\n        # leaves that already wrapped the target string. If these leaves do\n        # exist, we will replace them with our own LPAR and RPAR leaves.\n        old_parens_exist = False\n        if left_leaves and left_leaves[-1].type == token.LPAR:\n            old_parens_exist = True\n            leaves_to_steal_comments_from.append(left_leaves[-1])\n            left_leaves.pop()\n\n        append_leaves(first_line, line, left_leaves)\n\n        lpar_leaf = Leaf(token.LPAR, \"(\")\n        if old_parens_exist:\n            replace_child(LL[string_idx - 1], lpar_leaf)\n        else:\n            insert_str_child(lpar_leaf)\n        first_line.append(lpar_leaf)\n\n        # We throw inline comments that were originally to the right of the\n        # target string to the top line. They will now be shown to the right of\n        # the LPAR.\n        for leaf in leaves_to_steal_comments_from:\n            for comment_leaf in line.comments_after(leaf):\n                first_line.append(comment_leaf, preformatted=True)\n\n        yield Ok(first_line)\n\n        # --- Middle (String) Line\n        # We only need to yield one (possibly too long) string line, since the\n        # `StringSplitter` will break it down further if necessary.\n        string_value = LL[string_idx].value\n        string_line = Line(\n            depth=line.depth + 1,\n            inside_brackets=True,\n            should_explode=line.should_explode,\n        )\n        string_leaf = Leaf(token.STRING, string_value)\n        insert_str_child(string_leaf)\n        string_line.append(string_leaf)\n\n        old_rpar_leaf = None\n        if is_valid_index(string_idx + 1):\n            right_leaves = LL[string_idx + 1 :]\n            if ends_with_comma:\n                right_leaves.pop()\n\n            if old_parens_exist:\n                assert (\n                    right_leaves and right_leaves[-1].type == token.RPAR\n                ), \"Apparently, old parentheses do NOT exist?!\"\n                old_rpar_leaf = right_leaves.pop()\n\n            append_leaves(string_line, line, right_leaves)\n\n        yield Ok(string_line)\n\n        # --- Last Line\n        last_line = line.clone()\n        last_line.bracket_tracker = first_line.bracket_tracker\n\n        new_rpar_leaf = Leaf(token.RPAR, \")\")\n        if old_rpar_leaf is not None:\n            replace_child(old_rpar_leaf, new_rpar_leaf)\n        else:\n            insert_str_child(new_rpar_leaf)\n        last_line.append(new_rpar_leaf)\n\n        # If the target string ended with a comma, we place this comma to the\n        # right of the RPAR on the last line.\n        if ends_with_comma:\n            comma_leaf = Leaf(token.COMMA, \",\")\n            replace_child(LL[comma_idx], comma_leaf)\n            last_line.append(comma_leaf)\n\n        yield Ok(last_line)",
        "begin_line": 4131,
        "end_line": 4224,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0016891891891891893,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringParser.__init__#4295",
        "src_path": "black.py",
        "class_name": "black.StringParser",
        "signature": "black.StringParser.__init__(self)",
        "snippet": "    def __init__(self) -> None:\n        self._state = self.START\n        self._unmatched_lpars = 0",
        "begin_line": 4295,
        "end_line": 4297,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00048756704046806434,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringParser.parse#4299",
        "src_path": "black.py",
        "class_name": "black.StringParser",
        "signature": "black.StringParser.parse(self, leaves: List[Leaf], string_idx: int)",
        "snippet": "    def parse(self, leaves: List[Leaf], string_idx: int) -> int:\n        \"\"\"\n        Pre-conditions:\n            * @leaves[@string_idx].type == token.STRING\n\n        Returns:\n            The index directly after the last leaf which is apart of the string\n            trailer, if a \"trailer\" exists.\n                OR\n            @string_idx + 1, if no string \"trailer\" exists.\n        \"\"\"\n        assert leaves[string_idx].type == token.STRING\n\n        idx = string_idx + 1\n        while idx < len(leaves) and self._next_state(leaves[idx]):\n            idx += 1\n        return idx",
        "begin_line": 4299,
        "end_line": 4315,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0005851375073142189,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.StringParser._next_state#4317",
        "src_path": "black.py",
        "class_name": "black.StringParser",
        "signature": "black.StringParser._next_state(self, leaf: Leaf)",
        "snippet": "    def _next_state(self, leaf: Leaf) -> bool:\n        \"\"\"\n        Pre-conditions:\n            * On the first call to this function, @leaf MUST be the leaf that\n            was directly after the string leaf in question (e.g. if our target\n            string is `line.leaves[i]` then the first call to this method must\n            be `line.leaves[i + 1]`).\n            * On the next call to this function, the leaf paramater passed in\n            MUST be the leaf directly following @leaf.\n\n        Returns:\n            True iff @leaf is apart of the string's trailer.\n        \"\"\"\n        # We ignore empty LPAR or RPAR leaves.\n        if is_empty_par(leaf):\n            return True\n\n        next_token = leaf.type\n        if next_token == token.LPAR:\n            self._unmatched_lpars += 1\n\n        current_state = self._state\n\n        # The LPAR parser state is a special case. We will return True until we\n        # find the matching RPAR token.\n        if current_state == self.LPAR:\n            if next_token == token.RPAR:\n                self._unmatched_lpars -= 1\n                if self._unmatched_lpars == 0:\n                    self._state = self.RPAR\n        # Otherwise, we use a lookup table to determine the next state.\n        else:\n            # If the lookup table matches the current state to the next\n            # token, we use the lookup table.\n            if (current_state, next_token) in self._goto:\n                self._state = self._goto[current_state, next_token]\n            else:\n                # Otherwise, we check if a the current state was assigned a\n                # default.\n                if (current_state, self.DEFAULT_TOKEN) in self._goto:\n                    self._state = self._goto[current_state, self.DEFAULT_TOKEN]\n                # If no default has been assigned, then this parser has a logic\n                # error.\n                else:\n                    raise RuntimeError(f\"{self.__class__.__name__} LOGIC ERROR!\")\n\n            if self._state == self.DONE:\n                return False\n\n        return True",
        "begin_line": 4317,
        "end_line": 4366,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0011001100110011,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.TErr#4369",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.TErr(err_msg: str)",
        "snippet": "def TErr(err_msg: str) -> Err[CannotTransform]:\n    \"\"\"(T)ransform Err\n\n    Convenience function used when working with the TResult type.\n    \"\"\"\n    cant_transform = CannotTransform(err_msg)\n    return Err(cant_transform)",
        "begin_line": 4369,
        "end_line": 4375,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00039184952978056425,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.contains_pragma_comment#4378",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.contains_pragma_comment(comment_list: List[Leaf])",
        "snippet": "def contains_pragma_comment(comment_list: List[Leaf]) -> bool:\n    \"\"\"\n    Returns:\n        True iff one of the comments in @comment_list is a pragma used by one\n        of the more common static analysis tools for python (e.g. mypy, flake8,\n        pylint).\n    \"\"\"\n    for comment in comment_list:\n        if comment.value.startswith((\"# type:\", \"# noqa\", \"# pylint:\")):\n            return True\n\n    return False",
        "begin_line": 4378,
        "end_line": 4389,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.insert_str_child_factory#4392",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.insert_str_child_factory(string_leaf: Leaf)",
        "snippet": "def insert_str_child_factory(string_leaf: Leaf) -> Callable[[LN], None]:\n    \"\"\"\n    Factory for a convenience function that is used to orphan @string_leaf\n    and then insert multiple new leaves into the same part of the node\n    structure that @string_leaf had originally occupied.\n\n    Examples:\n        Let `string_leaf = Leaf(token.STRING, '\"foo\"')` and `N =\n        string_leaf.parent`. Assume the node `N` has the following\n        original structure:\n\n        Node(\n            expr_stmt, [\n                Leaf(NAME, 'x'),\n                Leaf(EQUAL, '='),\n                Leaf(STRING, '\"foo\"'),\n            ]\n        )\n\n        We then run the code snippet shown below.\n        ```\n        insert_str_child = insert_str_child_factory(string_leaf)\n\n        lpar = Leaf(token.LPAR, '(')\n        insert_str_child(lpar)\n\n        bar = Leaf(token.STRING, '\"bar\"')\n        insert_str_child(bar)\n\n        rpar = Leaf(token.RPAR, ')')\n        insert_str_child(rpar)\n        ```\n\n        After which point, it follows that `string_leaf.parent is None` and\n        the node `N` now has the following structure:\n\n        Node(\n            expr_stmt, [\n                Leaf(NAME, 'x'),\n                Leaf(EQUAL, '='),\n                Leaf(LPAR, '('),\n                Leaf(STRING, '\"bar\"'),\n                Leaf(RPAR, ')'),\n            ]\n        )\n    \"\"\"\n    string_parent = string_leaf.parent\n    string_child_idx = string_leaf.remove()\n\n    def insert_str_child(child: LN) -> None:\n        nonlocal string_child_idx\n\n        assert string_parent is not None\n        assert string_child_idx is not None\n\n        string_parent.insert_child(string_child_idx, child)\n        string_child_idx += 1\n\n    return insert_str_child",
        "begin_line": 4392,
        "end_line": 4450,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0006688963210702341,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.insert_str_child#4441",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.insert_str_child(child: LN)",
        "snippet": "    def insert_str_child(child: LN) -> None:\n        nonlocal string_child_idx\n\n        assert string_parent is not None\n        assert string_child_idx is not None\n\n        string_parent.insert_child(string_child_idx, child)\n        string_child_idx += 1",
        "begin_line": 4441,
        "end_line": 4448,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0006688963210702341,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.has_triple_quotes#4453",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.has_triple_quotes(string: str)",
        "snippet": "def has_triple_quotes(string: str) -> bool:\n    \"\"\"\n    Returns:\n        True iff @string starts with three quotation characters.\n    \"\"\"\n    raw_string = string.lstrip(STRING_PREFIX_CHARS)\n    return raw_string[:3] in {'\"\"\"', \"'''\"}",
        "begin_line": 4453,
        "end_line": 4459,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0004187604690117253,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.parent_type#4462",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.parent_type(node: Optional[LN])",
        "snippet": "def parent_type(node: Optional[LN]) -> Optional[NodeType]:\n    \"\"\"\n    Returns:\n        @node.parent.type, if @node is not None and has a parent.\n            OR\n        None, otherwise.\n    \"\"\"\n    if node is None or node.parent is None:\n        return None\n\n    return node.parent.type",
        "begin_line": 4462,
        "end_line": 4472,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_empty_par#4475",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_empty_par(leaf: Leaf)",
        "snippet": "def is_empty_par(leaf: Leaf) -> bool:\n    return is_empty_lpar(leaf) or is_empty_rpar(leaf)",
        "begin_line": 4475,
        "end_line": 4476,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0005162622612287042,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_empty_lpar#4479",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_empty_lpar(leaf: Leaf)",
        "snippet": "def is_empty_lpar(leaf: Leaf) -> bool:\n    return leaf.type == token.LPAR and leaf.value == \"\"",
        "begin_line": 4479,
        "end_line": 4480,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00042319085907744394,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_empty_rpar#4483",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_empty_rpar(leaf: Leaf)",
        "snippet": "def is_empty_rpar(leaf: Leaf) -> bool:\n    return leaf.type == token.RPAR and leaf.value == \"\"",
        "begin_line": 4483,
        "end_line": 4484,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0005302226935312832,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_valid_index_factory#4487",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_valid_index_factory(seq: Sequence[Any])",
        "snippet": "def is_valid_index_factory(seq: Sequence[Any]) -> Callable[[int], bool]:\n    \"\"\"\n    Examples:\n        ```\n        my_list = [1, 2, 3]\n\n        is_valid_index = is_valid_index_factory(my_list)\n\n        assert is_valid_index(0)\n        assert is_valid_index(2)\n\n        assert not is_valid_index(3)\n        assert not is_valid_index(-1)\n        ```\n    \"\"\"\n\n    def is_valid_index(idx: int) -> bool:\n        \"\"\"\n        Returns:\n            True iff @idx is positive AND seq[@idx] does NOT raise an\n            IndexError.\n        \"\"\"\n        return 0 <= idx < len(seq)\n\n    return is_valid_index",
        "begin_line": 4487,
        "end_line": 4511,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00039184952978056425,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_valid_index#4503",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_valid_index(idx: int)",
        "snippet": "    def is_valid_index(idx: int) -> bool:\n        \"\"\"\n        Returns:\n            True iff @idx is positive AND seq[@idx] does NOT raise an\n            IndexError.\n        \"\"\"\n        return 0 <= idx < len(seq)",
        "begin_line": 4503,
        "end_line": 4509,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00039184952978056425,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.line_to_string#4514",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.line_to_string(line: Line)",
        "snippet": "def line_to_string(line: Line) -> str:\n    \"\"\"Returns the string representation of @line.\n\n    WARNING: This is known to be computationally expensive.\n    \"\"\"\n    return str(line).strip(\"\\n\")",
        "begin_line": 4514,
        "end_line": 4519,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00033955857385398983,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.append_leaves#4522",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.append_leaves(new_line: Line, old_line: Line, leaves: List[Leaf])",
        "snippet": "def append_leaves(new_line: Line, old_line: Line, leaves: List[Leaf]) -> None:\n    \"\"\"\n    Append leaves (taken from @old_line) to @new_line, making sure to fix the\n    underlying Node structure where appropriate.\n\n    All of the leaves in @leaves are duplicated. The duplicates are then\n    appended to @new_line and used to replace their originals in the underlying\n    Node structure. Any comments attatched to the old leaves are reattached to\n    the new leaves.\n\n    Pre-conditions:\n        set(@leaves) is a subset of set(@old_line.leaves).\n    \"\"\"\n    for old_leaf in leaves:\n        assert old_leaf in old_line.leaves\n\n        new_leaf = Leaf(old_leaf.type, old_leaf.value)\n        replace_child(old_leaf, new_leaf)\n        new_line.append(new_leaf)\n\n        for comment_leaf in old_line.comments_after(old_leaf):\n            new_line.append(comment_leaf, preformatted=True)",
        "begin_line": 4522,
        "end_line": 4543,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.replace_child#4546",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.replace_child(old_child: LN, new_child: LN)",
        "snippet": "def replace_child(old_child: LN, new_child: LN) -> None:\n    \"\"\"\n    Side Effects:\n        * If @old_child.parent is set, replace @old_child with @new_child in\n        @old_child's underlying Node structure.\n            OR\n        * Otherwise, this function does nothing.\n    \"\"\"\n    parent = old_child.parent\n    if not parent:\n        return\n\n    child_idx = old_child.remove()\n    if child_idx is not None:\n        parent.insert_child(child_idx, new_child)",
        "begin_line": 4546,
        "end_line": 4560,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.002109704641350211,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.get_string_prefix#4563",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.get_string_prefix(string: str)",
        "snippet": "def get_string_prefix(string: str) -> str:\n    \"\"\"\n    Pre-conditions:\n        * assert_is_leaf_string(@string)\n\n    Returns:\n        @string's prefix (e.g. '', 'r', 'f', or 'rf').\n    \"\"\"\n    assert_is_leaf_string(string)\n\n    prefix = \"\"\n    prefix_idx = 0\n    while string[prefix_idx] in STRING_PREFIX_CHARS:\n        prefix += string[prefix_idx].lower()\n        prefix_idx += 1\n\n    return prefix",
        "begin_line": 4563,
        "end_line": 4579,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0011001100110011,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.assert_is_leaf_string#4582",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.assert_is_leaf_string(string: str)",
        "snippet": "def assert_is_leaf_string(string: str) -> None:\n    \"\"\"\n    Checks the pre-condition that @string has the format that you would expect\n    of `leaf.value` where `leaf` is some Leaf such that `leaf.type ==\n    token.STRING`. A more precise description of the pre-conditions that are\n    checked are listed below.\n\n    Pre-conditions:\n        * @string starts with either ', \", <prefix>', or <prefix>\" where\n        `set(<prefix>)` is some subset of `set(STRING_PREFIX_CHARS)`.\n        * @string ends with a quote character (' or \").\n\n    Raises:\n        AssertionError(...) if the pre-conditions listed above are not\n        satisfied.\n    \"\"\"\n    dquote_idx = string.find('\"')\n    squote_idx = string.find(\"'\")\n    if -1 in [dquote_idx, squote_idx]:\n        quote_idx = max(dquote_idx, squote_idx)\n    else:\n        quote_idx = min(squote_idx, dquote_idx)\n\n    assert (\n        0 <= quote_idx < len(string) - 1\n    ), f\"{string!r} is missing a starting quote character (' or \\\").\"\n    assert string[-1] in (\n        \"'\",\n        '\"',\n    ), f\"{string!r} is missing an ending quote character (' or \\\").\"\n    assert set(string[:quote_idx]).issubset(\n        set(STRING_PREFIX_CHARS)\n    ), f\"{set(string[:quote_idx])} is NOT a subset of {set(STRING_PREFIX_CHARS)}.\"",
        "begin_line": 4582,
        "end_line": 4614,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0008438818565400844,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.left_hand_split#4617",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.left_hand_split(line: Line, _features: Collection[Feature]=())",
        "snippet": "def left_hand_split(line: Line, _features: Collection[Feature] = ()) -> Iterator[Line]:\n    \"\"\"Split line into many lines, starting with the first matching bracket pair.\n\n    Note: this usually looks weird, only use this for function definitions.\n    Prefer RHS otherwise.  This is why this function is not symmetrical with\n    :func:`right_hand_split` which also handles optional parentheses.\n    \"\"\"\n    tail_leaves: List[Leaf] = []\n    body_leaves: List[Leaf] = []\n    head_leaves: List[Leaf] = []\n    current_leaves = head_leaves\n    matching_bracket: Optional[Leaf] = None\n    for leaf in line.leaves:\n        if (\n            current_leaves is body_leaves\n            and leaf.type in CLOSING_BRACKETS\n            and leaf.opening_bracket is matching_bracket\n        ):\n            current_leaves = tail_leaves if body_leaves else head_leaves\n        current_leaves.append(leaf)\n        if current_leaves is head_leaves:\n            if leaf.type in OPENING_BRACKETS:\n                matching_bracket = leaf\n                current_leaves = body_leaves\n    if not matching_bracket:\n        raise CannotSplit(\"No brackets found\")\n\n    head = bracket_split_build_line(head_leaves, line, matching_bracket)\n    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)\n    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)\n    bracket_split_succeeded_or_raise(head, body, tail)\n    for result in (head, body, tail):\n        if result:\n            yield result",
        "begin_line": 4617,
        "end_line": 4650,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0006373486297004461,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.right_hand_split#4653",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.right_hand_split(line: Line, line_length: int, features: Collection[Feature]=(), omit: Collection[LeafID]=())",
        "snippet": "def right_hand_split(\n    line: Line,\n    line_length: int,\n    features: Collection[Feature] = (),\n    omit: Collection[LeafID] = (),\n) -> Iterator[Line]:\n    \"\"\"Split line into many lines, starting with the last matching bracket pair.\n\n    If the split was by optional parentheses, attempt splitting without them, too.\n    `omit` is a collection of closing bracket IDs that shouldn't be considered for\n    this split.\n\n    Note: running this function modifies `bracket_depth` on the leaves of `line`.\n    \"\"\"\n    tail_leaves: List[Leaf] = []\n    body_leaves: List[Leaf] = []\n    head_leaves: List[Leaf] = []\n    current_leaves = tail_leaves\n    opening_bracket: Optional[Leaf] = None\n    closing_bracket: Optional[Leaf] = None\n    for leaf in reversed(line.leaves):\n        if current_leaves is body_leaves:\n            if leaf is opening_bracket:\n                current_leaves = head_leaves if body_leaves else tail_leaves\n        current_leaves.append(leaf)\n        if current_leaves is tail_leaves:\n            if leaf.type in CLOSING_BRACKETS and id(leaf) not in omit:\n                opening_bracket = leaf.opening_bracket\n                closing_bracket = leaf\n                current_leaves = body_leaves\n    if not (opening_bracket and closing_bracket and head_leaves):\n        # If there is no opening or closing_bracket that means the split failed and\n        # all content is in the tail.  Otherwise, if `head_leaves` are empty, it means\n        # the matching `opening_bracket` wasn't available on `line` anymore.\n        raise CannotSplit(\"No brackets found\")\n\n    tail_leaves.reverse()\n    body_leaves.reverse()\n    head_leaves.reverse()\n    head = bracket_split_build_line(head_leaves, line, opening_bracket)\n    body = bracket_split_build_line(body_leaves, line, opening_bracket, is_body=True)\n    tail = bracket_split_build_line(tail_leaves, line, opening_bracket)\n    bracket_split_succeeded_or_raise(head, body, tail)\n    if (\n        # the body shouldn't be exploded\n        not body.should_explode\n        # the opening bracket is an optional paren\n        and opening_bracket.type == token.LPAR\n        and not opening_bracket.value\n        # the closing bracket is an optional paren\n        and closing_bracket.type == token.RPAR\n        and not closing_bracket.value\n        # it's not an import (optional parens are the only thing we can split on\n        # in this case; attempting a split without them is a waste of time)\n        and not line.is_import\n        # there are no standalone comments in the body\n        and not body.contains_standalone_comments(0)\n        # and we can actually remove the parens\n        and can_omit_invisible_parens(body, line_length)\n    ):\n        omit = {id(closing_bracket), *omit}\n        try:\n            yield from right_hand_split(line, line_length, features=features, omit=omit)\n            return\n\n        except CannotSplit:\n            if not (\n                can_be_split(body)\n                or is_line_short_enough(body, line_length=line_length)\n            ):\n                raise CannotSplit(\n                    \"Splitting failed, body is still too long and can't be split.\"\n                )\n\n            elif head.contains_multiline_strings() or tail.contains_multiline_strings():\n                raise CannotSplit(\n                    \"The current optional pair of parentheses is bound to fail to\"\n                    \" satisfy the splitting algorithm because the head or the tail\"\n                    \" contains multiline strings which by definition never fit one\"\n                    \" line.\"\n                )\n\n    ensure_visible(opening_bracket)\n    ensure_visible(closing_bracket)\n    for result in (head, body, tail):\n        if result:\n            yield result",
        "begin_line": 4653,
        "end_line": 4739,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.bracket_split_succeeded_or_raise#4742",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line)",
        "snippet": "def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:\n    \"\"\"Raise :exc:`CannotSplit` if the last left- or right-hand split failed.\n\n    Do nothing otherwise.\n\n    A left- or right-hand split is based on a pair of brackets. Content before\n    (and including) the opening bracket is left on one line, content inside the\n    brackets is put on a separate line, and finally content starting with and\n    following the closing bracket is put on a separate line.\n\n    Those are called `head`, `body`, and `tail`, respectively. If the split\n    produced the same line (all content in `head`) or ended up with an empty `body`\n    and the `tail` is just the closing bracket, then it's considered failed.\n    \"\"\"\n    tail_len = len(str(tail).strip())\n    if not body:\n        if tail_len == 0:\n            raise CannotSplit(\"Splitting brackets produced the same line\")\n\n        elif tail_len < 3:\n            raise CannotSplit(\n                f\"Splitting brackets on an empty body to save {tail_len} characters is\"\n                \" not worth it\"\n            )",
        "begin_line": 4742,
        "end_line": 4765,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0004389815627743635,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.bracket_split_build_line#4768",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.bracket_split_build_line(leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool=False)",
        "snippet": "def bracket_split_build_line(\n    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False\n) -> Line:\n    \"\"\"Return a new line with given `leaves` and respective comments from `original`.\n\n    If `is_body` is True, the result line is one-indented inside brackets and as such\n    has its first leaf's prefix normalized and a trailing comma added when expected.\n    \"\"\"\n    result = Line(depth=original.depth)\n    if is_body:\n        result.inside_brackets = True\n        result.depth += 1\n        if leaves:\n            # Since body is a new indent level, remove spurious leading whitespace.\n            normalize_prefix(leaves[0], inside_brackets=True)\n            # Ensure a trailing comma for imports and standalone function arguments, but\n            # be careful not to add one after any comments or within type annotations.\n            no_commas = (\n                original.is_def\n                and opening_bracket.value == \"(\"\n                and not any(l.type == token.COMMA for l in leaves)\n            )\n\n            if original.is_import or no_commas:\n                for i in range(len(leaves) - 1, -1, -1):\n                    if leaves[i].type == STANDALONE_COMMENT:\n                        continue\n\n                    if leaves[i].type != token.COMMA:\n                        leaves.insert(i + 1, Leaf(token.COMMA, \",\"))\n                    break\n\n    # Populate the line\n    for leaf in leaves:\n        result.append(leaf, preformatted=True)\n        for comment_after in original.comments_after(leaf):\n            result.append(comment_after, preformatted=True)\n    if is_body:\n        result.should_explode = should_explode(result, opening_bracket)\n    return result",
        "begin_line": 4768,
        "end_line": 4807,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.dont_increase_indentation#4810",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.dont_increase_indentation(split_func: Transformer)",
        "snippet": "def dont_increase_indentation(split_func: Transformer) -> Transformer:\n    \"\"\"Normalize prefix of the first leaf in every line returned by `split_func`.\n\n    This is a decorator over relevant split functions.\n    \"\"\"\n\n    @wraps(split_func)\n    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:\n        for l in split_func(line, features):\n            normalize_prefix(l.leaves[0], inside_brackets=True)\n            yield l\n\n    return split_wrapper",
        "begin_line": 4810,
        "end_line": 4822,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00045871559633027525,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.split_wrapper#4817",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.split_wrapper(line: Line, features: Collection[Feature]=())",
        "snippet": "    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:\n        for l in split_func(line, features):\n            normalize_prefix(l.leaves[0], inside_brackets=True)\n            yield l",
        "begin_line": 4817,
        "end_line": 4820,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00045871559633027525,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.delimiter_split#4826",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.delimiter_split(line: Line, features: Collection[Feature]=())",
        "snippet": "def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:\n    \"\"\"Split according to delimiters of the highest priority.\n\n    If the appropriate Features are given, the split will add trailing commas\n    also in function signatures and calls that contain `*` and `**`.\n    \"\"\"\n    try:\n        last_leaf = line.leaves[-1]\n    except IndexError:\n        raise CannotSplit(\"Line empty\")\n\n    bt = line.bracket_tracker\n    try:\n        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})\n    except ValueError:\n        raise CannotSplit(\"No delimiters found\")\n\n    if delimiter_priority == DOT_PRIORITY:\n        if bt.delimiter_count_with_priority(delimiter_priority) == 1:\n            raise CannotSplit(\"Splitting a single attribute from its owner looks wrong\")\n\n    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n    lowest_depth = sys.maxsize\n    trailing_comma_safe = True\n\n    def append_to_line(leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Append `leaf` to current line or to new line if appending impossible.\"\"\"\n        nonlocal current_line\n        try:\n            current_line.append_safe(leaf, preformatted=True)\n        except ValueError:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n            current_line.append(leaf)\n\n    for leaf in line.leaves:\n        yield from append_to_line(leaf)\n\n        for comment_after in line.comments_after(leaf):\n            yield from append_to_line(comment_after)\n\n        lowest_depth = min(lowest_depth, leaf.bracket_depth)\n        if leaf.bracket_depth == lowest_depth:\n            if is_vararg(leaf, within={syms.typedargslist}):\n                trailing_comma_safe = (\n                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features\n                )\n            elif is_vararg(leaf, within={syms.arglist, syms.argument}):\n                trailing_comma_safe = (\n                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features\n                )\n\n        leaf_priority = bt.delimiters.get(id(leaf))\n        if leaf_priority == delimiter_priority:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n    if current_line:\n        if (\n            trailing_comma_safe\n            and delimiter_priority == COMMA_PRIORITY\n            and current_line.leaves[-1].type != token.COMMA\n            and current_line.leaves[-1].type != STANDALONE_COMMENT\n        ):\n            current_line.append(Leaf(token.COMMA, \",\"))\n        yield current_line",
        "begin_line": 4826,
        "end_line": 4892,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0013698630136986301,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.append_to_line#4851",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.append_to_line(leaf: Leaf)",
        "snippet": "    def append_to_line(leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Append `leaf` to current line or to new line if appending impossible.\"\"\"\n        nonlocal current_line\n        try:\n            current_line.append_safe(leaf, preformatted=True)\n        except ValueError:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n            current_line.append(leaf)",
        "begin_line": 4851,
        "end_line": 4860,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0016891891891891893,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.standalone_comment_split#4896",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.standalone_comment_split(line: Line, features: Collection[Feature]=())",
        "snippet": "def standalone_comment_split(\n    line: Line, features: Collection[Feature] = ()\n) -> Iterator[Line]:\n    \"\"\"Split standalone comments from the rest of the line.\"\"\"\n    if not line.contains_standalone_comments(0):\n        raise CannotSplit(\"Line does not have any standalone comments\")\n\n    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n\n    def append_to_line(leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Append `leaf` to current line or to new line if appending impossible.\"\"\"\n        nonlocal current_line\n        try:\n            current_line.append_safe(leaf, preformatted=True)\n        except ValueError:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n            current_line.append(leaf)\n\n    for leaf in line.leaves:\n        yield from append_to_line(leaf)\n\n        for comment_after in line.comments_after(leaf):\n            yield from append_to_line(comment_after)\n\n    if current_line:\n        yield current_line",
        "begin_line": 4896,
        "end_line": 4923,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.append_to_line#4905",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.append_to_line(leaf: Leaf)",
        "snippet": "    def append_to_line(leaf: Leaf) -> Iterator[Line]:\n        \"\"\"Append `leaf` to current line or to new line if appending impossible.\"\"\"\n        nonlocal current_line\n        try:\n            current_line.append_safe(leaf, preformatted=True)\n        except ValueError:\n            yield current_line\n\n            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)\n            current_line.append(leaf)",
        "begin_line": 4905,
        "end_line": 4914,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0016891891891891893,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_import#4926",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_import(leaf: Leaf)",
        "snippet": "def is_import(leaf: Leaf) -> bool:\n    \"\"\"Return True if the given leaf starts an import statement.\"\"\"\n    p = leaf.parent\n    t = leaf.type\n    v = leaf.value\n    return bool(\n        t == token.NAME\n        and (\n            (v == \"import\" and p and p.type == syms.import_name)\n            or (v == \"from\" and p and p.type == syms.import_from)\n        )\n    )",
        "begin_line": 4926,
        "end_line": 4937,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00037893141341417203,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_type_comment#4940",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_type_comment(leaf: Leaf, suffix: str='')",
        "snippet": "def is_type_comment(leaf: Leaf, suffix: str = \"\") -> bool:\n    \"\"\"Return True if the given leaf is a special comment.\n    Only returns true for type comments for now.\"\"\"\n    t = leaf.type\n    v = leaf.value\n    return t in {token.COMMENT, STANDALONE_COMMENT} and v.startswith(\"# type:\" + suffix)",
        "begin_line": 4940,
        "end_line": 4945,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0005211047420531526,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.normalize_prefix#4948",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.normalize_prefix(leaf: Leaf, *, inside_brackets: bool)",
        "snippet": "def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:\n    \"\"\"Leave existing extra newlines if not `inside_brackets`. Remove everything\n    else.\n\n    Note: don't use backslashes for formatting or you'll lose your voting rights.\n    \"\"\"\n    if not inside_brackets:\n        spl = leaf.prefix.split(\"#\")\n        if \"\\\\\" not in spl[0]:\n            nl_count = spl[-1].count(\"\\n\")\n            if len(spl) > 1:\n                nl_count -= 1\n            leaf.prefix = \"\\n\" * nl_count\n            return\n\n    leaf.prefix = \"\"",
        "begin_line": 4948,
        "end_line": 4963,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00041425020712510354,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.normalize_string_prefix#4966",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.normalize_string_prefix(leaf: Leaf, remove_u_prefix: bool=False)",
        "snippet": "def normalize_string_prefix(leaf: Leaf, remove_u_prefix: bool = False) -> None:\n    \"\"\"Make all string prefixes lowercase.\n\n    If remove_u_prefix is given, also removes any u prefix from the string.\n\n    Note: Mutates its argument.\n    \"\"\"\n    match = re.match(r\"^([\" + STRING_PREFIX_CHARS + r\"]*)(.*)$\", leaf.value, re.DOTALL)\n    assert match is not None, f\"failed to match string {leaf.value!r}\"\n    orig_prefix = match.group(1)\n    new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n    if remove_u_prefix:\n        new_prefix = new_prefix.replace(\"u\", \"\")\n    leaf.value = f\"{new_prefix}{match.group(2)}\"",
        "begin_line": 4966,
        "end_line": 4979,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0005810575246949448,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.normalize_string_quotes#4982",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.normalize_string_quotes(leaf: Leaf)",
        "snippet": "def normalize_string_quotes(leaf: Leaf) -> None:\n    \"\"\"Prefer double quotes but only if it doesn't cause more escaping.\n\n    Adds or removes backslashes as appropriate. Doesn't parse and fix\n    strings nested in f-strings (yet).\n\n    Note: Mutates its argument.\n    \"\"\"\n    value = leaf.value.lstrip(STRING_PREFIX_CHARS)\n    if value[:3] == '\"\"\"':\n        return\n\n    elif value[:3] == \"'''\":\n        orig_quote = \"'''\"\n        new_quote = '\"\"\"'\n    elif value[0] == '\"':\n        orig_quote = '\"'\n        new_quote = \"'\"\n    else:\n        orig_quote = \"'\"\n        new_quote = '\"'\n    first_quote_pos = leaf.value.find(orig_quote)\n    if first_quote_pos == -1:\n        return  # There's an internal error\n\n    prefix = leaf.value[:first_quote_pos]\n    unescaped_new_quote = re.compile(rf\"(([^\\\\]|^)(\\\\\\\\)*){new_quote}\")\n    escaped_new_quote = re.compile(rf\"([^\\\\]|^)\\\\((?:\\\\\\\\)*){new_quote}\")\n    escaped_orig_quote = re.compile(rf\"([^\\\\]|^)\\\\((?:\\\\\\\\)*){orig_quote}\")\n    body = leaf.value[first_quote_pos + len(orig_quote) : -len(orig_quote)]\n    if \"r\" in prefix.casefold():\n        if unescaped_new_quote.search(body):\n            # There's at least one unescaped new_quote in this raw string\n            # so converting is impossible\n            return\n\n        # Do not introduce or remove backslashes in raw strings\n        new_body = body\n    else:\n        # remove unnecessary escapes\n        new_body = sub_twice(escaped_new_quote, rf\"\\1\\2{new_quote}\", body)\n        if body != new_body:\n            # Consider the string without unnecessary escapes as the original\n            body = new_body\n            leaf.value = f\"{prefix}{orig_quote}{body}{orig_quote}\"\n        new_body = sub_twice(escaped_orig_quote, rf\"\\1\\2{orig_quote}\", new_body)\n        new_body = sub_twice(unescaped_new_quote, rf\"\\1\\\\{new_quote}\", new_body)\n    if \"f\" in prefix.casefold():\n        matches = re.findall(\n            r\"\"\"\n            (?:[^{]|^)\\{  # start of the string or a non-{ followed by a single {\n                ([^{].*?)  # contents of the brackets except if begins with {{\n            \\}(?:[^}]|$)  # A } followed by end of the string or a non-}\n            \"\"\",\n            new_body,\n            re.VERBOSE,\n        )\n        for m in matches:\n            if \"\\\\\" in str(m):\n                # Do not introduce backslashes in interpolated expressions\n                return\n\n    if new_quote == '\"\"\"' and new_body[-1:] == '\"':\n        # edge case:\n        new_body = new_body[:-1] + '\\\\\"'\n    orig_escape_count = body.count(\"\\\\\")\n    new_escape_count = new_body.count(\"\\\\\")\n    if new_escape_count > orig_escape_count:\n        return  # Do not introduce more escaping\n\n    if new_escape_count == orig_escape_count and orig_quote == '\"':\n        return  # Prefer double quotes\n\n    leaf.value = f\"{prefix}{new_quote}{new_body}{new_quote}\"",
        "begin_line": 4982,
        "end_line": 5055,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.normalize_numeric_literal#5058",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.normalize_numeric_literal(leaf: Leaf)",
        "snippet": "def normalize_numeric_literal(leaf: Leaf) -> None:\n    \"\"\"Normalizes numeric (float, int, and complex) literals.\n\n    All letters used in the representation are normalized to lowercase (except\n    in Python 2 long literals).\n    \"\"\"\n    text = leaf.value.lower()\n    if text.startswith((\"0o\", \"0b\")):\n        # Leave octal and binary literals alone.\n        pass\n    elif text.startswith(\"0x\"):\n        # Change hex literals to upper case.\n        before, after = text[:2], text[2:]\n        text = f\"{before}{after.upper()}\"\n    elif \"e\" in text:\n        before, after = text.split(\"e\")\n        sign = \"\"\n        if after.startswith(\"-\"):\n            after = after[1:]\n            sign = \"-\"\n        elif after.startswith(\"+\"):\n            after = after[1:]\n        before = format_float_or_int_string(before)\n        text = f\"{before}e{sign}{after}\"\n    elif text.endswith((\"j\", \"l\")):\n        number = text[:-1]\n        suffix = text[-1]\n        # Capitalize in \"2L\" because \"l\" looks too similar to \"1\".\n        if suffix == \"l\":\n            suffix = \"L\"\n        text = f\"{format_float_or_int_string(number)}{suffix}\"\n    else:\n        text = format_float_or_int_string(text)\n    leaf.value = text",
        "begin_line": 5058,
        "end_line": 5091,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.format_float_or_int_string#5094",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.format_float_or_int_string(text: str)",
        "snippet": "def format_float_or_int_string(text: str) -> str:\n    \"\"\"Formats a float string like \"1.0\".\"\"\"\n    if \".\" not in text:\n        return text\n\n    before, after = text.split(\".\")\n    return f\"{before or 0}.{after or 0}\"",
        "begin_line": 5094,
        "end_line": 5100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0005984440454817474,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.normalize_invisible_parens#5103",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.normalize_invisible_parens(node: Node, parens_after: Set[str])",
        "snippet": "def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:\n    \"\"\"Make existing optional parentheses invisible or create new ones.\n\n    `parens_after` is a set of string leaf values immediately after which parens\n    should be put.\n\n    Standardizes on visible parentheses for single-element tuples, and keeps\n    existing visible parentheses for other tuples and generator expressions.\n    \"\"\"\n    for pc in list_comments(node.prefix, is_endmarker=False):\n        if pc.value in FMT_OFF:\n            # This `node` has a prefix with `# fmt: off`, don't mess with parens.\n            return\n    check_lpar = False\n    for index, child in enumerate(list(node.children)):\n        # Fixes a bug where invisible parens are not properly stripped from\n        # assignment statements that contain type annotations.\n        if isinstance(child, Node) and child.type == syms.annassign:\n            normalize_invisible_parens(child, parens_after=parens_after)\n\n        # Add parentheses around long tuple unpacking in assignments.\n        if (\n            index == 0\n            and isinstance(child, Node)\n            and child.type == syms.testlist_star_expr\n        ):\n            check_lpar = True\n\n        if check_lpar:\n            if is_walrus_assignment(child):\n                continue\n\n            if child.type == syms.atom:\n                if maybe_make_parens_invisible_in_atom(child, parent=node):\n                    wrap_in_parentheses(node, child, visible=False)\n            elif is_one_tuple(child):\n                wrap_in_parentheses(node, child, visible=True)\n            elif node.type == syms.import_from:\n                # \"import from\" nodes store parentheses directly as part of\n                # the statement\n                if child.type == token.LPAR:\n                    # make parentheses invisible\n                    child.value = \"\"  # type: ignore\n                    node.children[-1].value = \"\"  # type: ignore\n                elif child.type != token.STAR:\n                    # insert invisible parentheses\n                    node.insert_child(index, Leaf(token.LPAR, \"\"))\n                    node.append_child(Leaf(token.RPAR, \"\"))\n                break\n\n            elif not (isinstance(child, Leaf) and is_multiline_string(child)):\n                wrap_in_parentheses(node, child, visible=False)\n\n        check_lpar = isinstance(child, Leaf) and child.value in parens_after",
        "begin_line": 5103,
        "end_line": 5156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.normalize_fmt_off#5159",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.normalize_fmt_off(node: Node)",
        "snippet": "def normalize_fmt_off(node: Node) -> None:\n    \"\"\"Convert content between `# fmt: off`/`# fmt: on` into standalone comments.\"\"\"\n    try_again = True\n    while try_again:\n        try_again = convert_one_fmt_off_pair(node)",
        "begin_line": 5159,
        "end_line": 5163,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00032331070158422246,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.convert_one_fmt_off_pair#5166",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.convert_one_fmt_off_pair(node: Node)",
        "snippet": "def convert_one_fmt_off_pair(node: Node) -> bool:\n    \"\"\"Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.\n\n    Returns True if a pair was converted.\n    \"\"\"\n    for leaf in node.leaves():\n        previous_consumed = 0\n        for comment in list_comments(leaf.prefix, is_endmarker=False):\n            if comment.value in FMT_OFF:\n                # We only want standalone comments. If there's no previous leaf or\n                # the previous leaf is indentation, it's a standalone comment in\n                # disguise.\n                if comment.type != STANDALONE_COMMENT:\n                    prev = preceding_leaf(leaf)\n                    if prev and prev.type not in WHITESPACE:\n                        continue\n\n                ignored_nodes = list(generate_ignored_nodes(leaf))\n                if not ignored_nodes:\n                    continue\n\n                first = ignored_nodes[0]  # Can be a container node with the `leaf`.\n                parent = first.parent\n                prefix = first.prefix\n                first.prefix = prefix[comment.consumed :]\n                hidden_value = (\n                    comment.value + \"\\n\" + \"\".join(str(n) for n in ignored_nodes)\n                )\n                if hidden_value.endswith(\"\\n\"):\n                    # That happens when one of the `ignored_nodes` ended with a NEWLINE\n                    # leaf (possibly followed by a DEDENT).\n                    hidden_value = hidden_value[:-1]\n                first_idx: Optional[int] = None\n                for ignored in ignored_nodes:\n                    index = ignored.remove()\n                    if first_idx is None:\n                        first_idx = index\n                assert parent is not None, \"INTERNAL ERROR: fmt: on/off handling (1)\"\n                assert first_idx is not None, \"INTERNAL ERROR: fmt: on/off handling (2)\"\n                parent.insert_child(\n                    first_idx,\n                    Leaf(\n                        STANDALONE_COMMENT,\n                        hidden_value,\n                        prefix=prefix[:previous_consumed] + \"\\n\" * comment.newlines,\n                    ),\n                )\n                return True\n\n            previous_consumed = comment.consumed\n\n    return False",
        "begin_line": 5166,
        "end_line": 5217,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.generate_ignored_nodes#5220",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.generate_ignored_nodes(leaf: Leaf)",
        "snippet": "def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:\n    \"\"\"Starting from the container of `leaf`, generate all leaves until `# fmt: on`.\n\n    Stops at the end of the block.\n    \"\"\"\n    container: Optional[LN] = container_of(leaf)\n    while container is not None and container.type != token.ENDMARKER:\n        if fmt_on(container):\n            return\n\n        # fix for fmt: on in children\n        if contains_fmt_on_at_column(container, leaf.column):\n            for child in container.children:\n                if contains_fmt_on_at_column(child, leaf.column):\n                    return\n                yield child\n        else:\n            yield container\n            container = container.next_sibling",
        "begin_line": 5220,
        "end_line": 5238,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.fmt_on#5241",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.fmt_on(container: LN)",
        "snippet": "def fmt_on(container: LN) -> bool:\n    is_fmt_on = False\n    for comment in list_comments(container.prefix, is_endmarker=False):\n        if comment.value in FMT_ON:\n            is_fmt_on = True\n        elif comment.value in FMT_OFF:\n            is_fmt_on = False\n    return is_fmt_on",
        "begin_line": 5241,
        "end_line": 5248,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.002109704641350211,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.contains_fmt_on_at_column#5251",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.contains_fmt_on_at_column(container: LN, column: int)",
        "snippet": "def contains_fmt_on_at_column(container: LN, column: int) -> bool:\n    for child in container.children:\n        if (\n            isinstance(child, Node)\n            and first_leaf_column(child) == column\n            or isinstance(child, Leaf)\n            and child.column == column\n        ):\n            if fmt_on(child):\n                return True\n\n    return False",
        "begin_line": 5251,
        "end_line": 5262,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.first_leaf_column#5265",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.first_leaf_column(node: Node)",
        "snippet": "def first_leaf_column(node: Node) -> Optional[int]:\n    for child in node.children:\n        if isinstance(child, Leaf):\n            return child.column\n    return None",
        "begin_line": 5265,
        "end_line": 5269,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.maybe_make_parens_invisible_in_atom#5272",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.maybe_make_parens_invisible_in_atom(node: LN, parent: LN)",
        "snippet": "def maybe_make_parens_invisible_in_atom(node: LN, parent: LN) -> bool:\n    \"\"\"If it's safe, make the parens in the atom `node` invisible, recursively.\n    Additionally, remove repeated, adjacent invisible parens from the atom `node`\n    as they are redundant.\n\n    Returns whether the node should itself be wrapped in invisible parentheses.\n\n    \"\"\"\n    if (\n        node.type != syms.atom\n        or is_empty_tuple(node)\n        or is_one_tuple(node)\n        or (is_yield(node) and parent.type != syms.expr_stmt)\n        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY\n    ):\n        return False\n\n    first = node.children[0]\n    last = node.children[-1]\n    if first.type == token.LPAR and last.type == token.RPAR:\n        middle = node.children[1]\n        # make parentheses invisible\n        first.value = \"\"  # type: ignore\n        last.value = \"\"  # type: ignore\n        maybe_make_parens_invisible_in_atom(middle, parent=parent)\n\n        if is_atom_with_invisible_parens(middle):\n            # Strip the invisible parens from `middle` by replacing\n            # it with the child in-between the invisible parens\n            middle.replace(middle.children[1])\n\n        return False\n\n    return True",
        "begin_line": 5272,
        "end_line": 5305,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0011001100110011,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_atom_with_invisible_parens#5308",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_atom_with_invisible_parens(node: LN)",
        "snippet": "def is_atom_with_invisible_parens(node: LN) -> bool:\n    \"\"\"Given a `LN`, determines whether it's an atom `node` with invisible\n    parens. Useful in dedupe-ing and normalizing parens.\n    \"\"\"\n    if isinstance(node, Leaf) or node.type != syms.atom:\n        return False\n\n    first, last = node.children[0], node.children[-1]\n    return (\n        isinstance(first, Leaf)\n        and first.type == token.LPAR\n        and first.value == \"\"\n        and isinstance(last, Leaf)\n        and last.type == token.RPAR\n        and last.value == \"\"\n    )",
        "begin_line": 5308,
        "end_line": 5323,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0011001100110011,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_empty_tuple#5326",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_empty_tuple(node: LN)",
        "snippet": "def is_empty_tuple(node: LN) -> bool:\n    \"\"\"Return True if `node` holds an empty tuple.\"\"\"\n    return (\n        node.type == syms.atom\n        and len(node.children) == 2\n        and node.children[0].type == token.LPAR\n        and node.children[1].type == token.RPAR\n    )",
        "begin_line": 5326,
        "end_line": 5333,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0011001100110011,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.unwrap_singleton_parenthesis#5336",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.unwrap_singleton_parenthesis(node: LN)",
        "snippet": "def unwrap_singleton_parenthesis(node: LN) -> Optional[LN]:\n    \"\"\"Returns `wrapped` if `node` is of the shape ( wrapped ).\n\n    Parenthesis can be optional. Returns None otherwise\"\"\"\n    if len(node.children) != 3:\n        return None\n\n    lpar, wrapped, rpar = node.children\n    if not (lpar.type == token.LPAR and rpar.type == token.RPAR):\n        return None\n\n    return wrapped",
        "begin_line": 5336,
        "end_line": 5347,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00048756704046806434,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.wrap_in_parentheses#5350",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.wrap_in_parentheses(parent: Node, child: LN, *, visible: bool=True)",
        "snippet": "def wrap_in_parentheses(parent: Node, child: LN, *, visible: bool = True) -> None:\n    \"\"\"Wrap `child` in parentheses.\n\n    This replaces `child` with an atom holding the parentheses and the old\n    child.  That requires moving the prefix.\n\n    If `visible` is False, the leaves will be valueless (and thus invisible).\n    \"\"\"\n    lpar = Leaf(token.LPAR, \"(\" if visible else \"\")\n    rpar = Leaf(token.RPAR, \")\" if visible else \"\")\n    prefix = child.prefix\n    child.prefix = \"\"\n    index = child.remove() or 0\n    new_child = Node(syms.atom, [lpar, child, rpar])\n    new_child.prefix = prefix\n    parent.insert_child(index, new_child)",
        "begin_line": 5350,
        "end_line": 5365,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00040816326530612246,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_one_tuple#5368",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_one_tuple(node: LN)",
        "snippet": "def is_one_tuple(node: LN) -> bool:\n    \"\"\"Return True if `node` holds a tuple with one element, with or without parens.\"\"\"\n    if node.type == syms.atom:\n        gexp = unwrap_singleton_parenthesis(node)\n        if gexp is None or gexp.type != syms.testlist_gexp:\n            return False\n\n        return len(gexp.children) == 2 and gexp.children[1].type == token.COMMA\n\n    return (\n        node.type in IMPLICIT_TUPLE\n        and len(node.children) == 2\n        and node.children[1].type == token.COMMA\n    )",
        "begin_line": 5368,
        "end_line": 5381,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0010309278350515464,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_walrus_assignment#5384",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_walrus_assignment(node: LN)",
        "snippet": "def is_walrus_assignment(node: LN) -> bool:\n    \"\"\"Return True iff `node` is of the shape ( test := test )\"\"\"\n    inner = unwrap_singleton_parenthesis(node)\n    return inner is not None and inner.type == syms.namedexpr_test",
        "begin_line": 5384,
        "end_line": 5387,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00039184952978056425,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_yield#5390",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_yield(node: LN)",
        "snippet": "def is_yield(node: LN) -> bool:\n    \"\"\"Return True if `node` holds a `yield` or `yield from` expression.\"\"\"\n    if node.type == syms.yield_expr:\n        return True\n\n    if node.type == token.NAME and node.value == \"yield\":  # type: ignore\n        return True\n\n    if node.type != syms.atom:\n        return False\n\n    if len(node.children) != 3:\n        return False\n\n    lpar, expr, rpar = node.children\n    if lpar.type == token.LPAR and rpar.type == token.RPAR:\n        return is_yield(expr)\n\n    return False",
        "begin_line": 5390,
        "end_line": 5408,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_vararg#5411",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_vararg(leaf: Leaf, within: Set[NodeType])",
        "snippet": "def is_vararg(leaf: Leaf, within: Set[NodeType]) -> bool:\n    \"\"\"Return True if `leaf` is a star or double star in a vararg or kwarg.\n\n    If `within` includes VARARGS_PARENTS, this applies to function signatures.\n    If `within` includes UNPACKING_PARENTS, it applies to right hand-side\n    extended iterable unpacking (PEP 3132) and additional unpacking\n    generalizations (PEP 448).\n    \"\"\"\n    if leaf.type not in VARARGS_SPECIALS or not leaf.parent:\n        return False\n\n    p = leaf.parent\n    if p.type == syms.star_expr:\n        # Star expressions are also used as assignment targets in extended\n        # iterable unpacking (PEP 3132).  See what its parent is instead.\n        if not p.parent:\n            return False\n\n        p = p.parent\n\n    return p.type in within",
        "begin_line": 5411,
        "end_line": 5431,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0011001100110011,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_multiline_string#5434",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_multiline_string(leaf: Leaf)",
        "snippet": "def is_multiline_string(leaf: Leaf) -> bool:\n    \"\"\"Return True if `leaf` is a multiline string that actually spans many lines.\"\"\"\n    return has_triple_quotes(leaf.value) and \"\\n\" in leaf.value",
        "begin_line": 5434,
        "end_line": 5436,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00042140750105351877,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_stub_suite#5439",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_stub_suite(node: Node)",
        "snippet": "def is_stub_suite(node: Node) -> bool:\n    \"\"\"Return True if `node` is a suite with a stub body.\"\"\"\n    if (\n        len(node.children) != 4\n        or node.children[0].type != token.NEWLINE\n        or node.children[1].type != token.INDENT\n        or node.children[3].type != token.DEDENT\n    ):\n        return False\n\n    return is_stub_body(node.children[2])",
        "begin_line": 5439,
        "end_line": 5449,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_stub_body#5452",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_stub_body(node: LN)",
        "snippet": "def is_stub_body(node: LN) -> bool:\n    \"\"\"Return True if `node` is a simple statement containing an ellipsis.\"\"\"\n    if not isinstance(node, Node) or node.type != syms.simple_stmt:\n        return False\n\n    if len(node.children) != 2:\n        return False\n\n    child = node.children[0]\n    return (\n        child.type == syms.atom\n        and len(child.children) == 3\n        and all(leaf == Leaf(token.DOT, \".\") for leaf in child.children)\n    )",
        "begin_line": 5452,
        "end_line": 5465,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.002109704641350211,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.max_delimiter_priority_in_atom#5468",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.max_delimiter_priority_in_atom(node: LN)",
        "snippet": "def max_delimiter_priority_in_atom(node: LN) -> Priority:\n    \"\"\"Return maximum delimiter priority inside `node`.\n\n    This is specific to atoms with contents contained in a pair of parentheses.\n    If `node` isn't an atom or there are no enclosing parentheses, returns 0.\n    \"\"\"\n    if node.type != syms.atom:\n        return 0\n\n    first = node.children[0]\n    last = node.children[-1]\n    if not (first.type == token.LPAR and last.type == token.RPAR):\n        return 0\n\n    bt = BracketTracker()\n    for c in node.children[1:-1]:\n        if isinstance(c, Leaf):\n            bt.mark(c)\n        else:\n            for leaf in c.leaves():\n                bt.mark(leaf)\n    try:\n        return bt.max_delimiter_priority()\n\n    except ValueError:\n        return 0",
        "begin_line": 5468,
        "end_line": 5493,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0006112469437652812,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.ensure_visible#5496",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.ensure_visible(leaf: Leaf)",
        "snippet": "def ensure_visible(leaf: Leaf) -> None:\n    \"\"\"Make sure parentheses are visible.\n\n    They could be invisible as part of some statements (see\n    :func:`normalize_invisible_parens` and :func:`visit_import_from`).\n    \"\"\"\n    if leaf.type == token.LPAR:\n        leaf.value = \"(\"\n    elif leaf.type == token.RPAR:\n        leaf.value = \")\"",
        "begin_line": 5496,
        "end_line": 5505,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00047938638542665386,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.should_explode#5508",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.should_explode(line: Line, opening_bracket: Leaf)",
        "snippet": "def should_explode(line: Line, opening_bracket: Leaf) -> bool:\n    \"\"\"Should `line` immediately be split with `delimiter_split()` after RHS?\"\"\"\n\n    if not (\n        opening_bracket.parent\n        and opening_bracket.parent.type in {syms.atom, syms.import_from}\n        and opening_bracket.value in \"[{(\"\n    ):\n        return False\n\n    try:\n        last_leaf = line.leaves[-1]\n        exclude = {id(last_leaf)} if last_leaf.type == token.COMMA else set()\n        max_priority = line.bracket_tracker.max_delimiter_priority(exclude=exclude)\n    except (IndexError, ValueError):\n        return False\n\n    return max_priority == COMMA_PRIORITY",
        "begin_line": 5508,
        "end_line": 5525,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0004995004995004995,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.get_features_used#5528",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.get_features_used(node: Node)",
        "snippet": "def get_features_used(node: Node) -> Set[Feature]:\n    \"\"\"Return a set of (relatively) new Python features used in this file.\n\n    Currently looking for:\n    - f-strings;\n    - underscores in numeric literals;\n    - trailing commas after * or ** in function signatures and calls;\n    - positional only arguments in function signatures and lambdas;\n    \"\"\"\n    features: Set[Feature] = set()\n    for n in node.pre_order():\n        if n.type == token.STRING:\n            value_head = n.value[:2]  # type: ignore\n            if value_head in {'f\"', 'F\"', \"f'\", \"F'\", \"rf\", \"fr\", \"RF\", \"FR\"}:\n                features.add(Feature.F_STRINGS)\n\n        elif n.type == token.NUMBER:\n            if \"_\" in n.value:  # type: ignore\n                features.add(Feature.NUMERIC_UNDERSCORES)\n\n        elif n.type == token.SLASH:\n            if n.parent and n.parent.type in {syms.typedargslist, syms.arglist}:\n                features.add(Feature.POS_ONLY_ARGUMENTS)\n\n        elif n.type == token.COLONEQUAL:\n            features.add(Feature.ASSIGNMENT_EXPRESSIONS)\n\n        elif (\n            n.type in {syms.typedargslist, syms.arglist}\n            and n.children\n            and n.children[-1].type == token.COMMA\n        ):\n            if n.type == syms.typedargslist:\n                feature = Feature.TRAILING_COMMA_IN_DEF\n            else:\n                feature = Feature.TRAILING_COMMA_IN_CALL\n\n            for ch in n.children:\n                if ch.type in STARS:\n                    features.add(feature)\n\n                if ch.type == syms.argument:\n                    for argch in ch.children:\n                        if argch.type in STARS:\n                            features.add(feature)\n\n    return features",
        "begin_line": 5528,
        "end_line": 5574,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.detect_target_versions#5577",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.detect_target_versions(node: Node)",
        "snippet": "def detect_target_versions(node: Node) -> Set[TargetVersion]:\n    \"\"\"Detect the version to target based on the nodes used.\"\"\"\n    features = get_features_used(node)\n    return {\n        version for version in TargetVersion if features <= VERSION_TO_FEATURES[version]\n    }",
        "begin_line": 5577,
        "end_line": 5582,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00036469730123997083,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.generate_trailers_to_omit#5585",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.generate_trailers_to_omit(line: Line, line_length: int)",
        "snippet": "def generate_trailers_to_omit(line: Line, line_length: int) -> Iterator[Set[LeafID]]:\n    \"\"\"Generate sets of closing bracket IDs that should be omitted in a RHS.\n\n    Brackets can be omitted if the entire trailer up to and including\n    a preceding closing bracket fits in one line.\n\n    Yielded sets are cumulative (contain results of previous yields, too).  First\n    set is empty.\n    \"\"\"\n\n    omit: Set[LeafID] = set()\n    yield omit\n\n    length = 4 * line.depth\n    opening_bracket: Optional[Leaf] = None\n    closing_bracket: Optional[Leaf] = None\n    inner_brackets: Set[LeafID] = set()\n    for index, leaf, leaf_length in enumerate_with_length(line, reversed=True):\n        length += leaf_length\n        if length > line_length:\n            break\n\n        has_inline_comment = leaf_length > len(leaf.value) + len(leaf.prefix)\n        if leaf.type == STANDALONE_COMMENT or has_inline_comment:\n            break\n\n        if opening_bracket:\n            if leaf is opening_bracket:\n                opening_bracket = None\n            elif leaf.type in CLOSING_BRACKETS:\n                inner_brackets.add(id(leaf))\n        elif leaf.type in CLOSING_BRACKETS:\n            if index > 0 and line.leaves[index - 1].type in OPENING_BRACKETS:\n                # Empty brackets would fail a split so treat them as \"inner\"\n                # brackets (e.g. only add them to the `omit` set if another\n                # pair of brackets was good enough.\n                inner_brackets.add(id(leaf))\n                continue\n\n            if closing_bracket:\n                omit.add(id(closing_bracket))\n                omit.update(inner_brackets)\n                inner_brackets.clear()\n                yield omit\n\n            if leaf.value:\n                opening_bracket = leaf.opening_bracket\n                closing_bracket = leaf",
        "begin_line": 5585,
        "end_line": 5632,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0013698630136986301,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.get_future_imports#5635",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.get_future_imports(node: Node)",
        "snippet": "def get_future_imports(node: Node) -> Set[str]:\n    \"\"\"Return a set of __future__ imports in the file.\"\"\"\n    imports: Set[str] = set()\n\n    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:\n        for child in children:\n            if isinstance(child, Leaf):\n                if child.type == token.NAME:\n                    yield child.value\n\n            elif child.type == syms.import_as_name:\n                orig_name = child.children[0]\n                assert isinstance(orig_name, Leaf), \"Invalid syntax parsing imports\"\n                assert orig_name.type == token.NAME, \"Invalid syntax parsing imports\"\n                yield orig_name.value\n\n            elif child.type == syms.import_as_names:\n                yield from get_imports_from_children(child.children)\n\n            else:\n                raise AssertionError(\"Invalid syntax parsing imports\")\n\n    for child in node.children:\n        if child.type != syms.simple_stmt:\n            break\n\n        first_child = child.children[0]\n        if isinstance(first_child, Leaf):\n            # Continue looking if we see a docstring; otherwise stop.\n            if (\n                len(child.children) == 2\n                and first_child.type == token.STRING\n                and child.children[1].type == token.NEWLINE\n            ):\n                continue\n\n            break\n\n        elif first_child.type == syms.import_from:\n            module_name = first_child.children[1]\n            if not isinstance(module_name, Leaf) or module_name.value != \"__future__\":\n                break\n\n            imports |= set(get_imports_from_children(first_child.children[3:]))\n        else:\n            break\n\n    return imports",
        "begin_line": 5635,
        "end_line": 5682,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.002109704641350211,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.get_imports_from_children#5639",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.get_imports_from_children(children: List[LN])",
        "snippet": "    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:\n        for child in children:\n            if isinstance(child, Leaf):\n                if child.type == token.NAME:\n                    yield child.value\n\n            elif child.type == syms.import_as_name:\n                orig_name = child.children[0]\n                assert isinstance(orig_name, Leaf), \"Invalid syntax parsing imports\"\n                assert orig_name.type == token.NAME, \"Invalid syntax parsing imports\"\n                yield orig_name.value\n\n            elif child.type == syms.import_as_names:\n                yield from get_imports_from_children(child.children)\n\n            else:\n                raise AssertionError(\"Invalid syntax parsing imports\")",
        "begin_line": 5639,
        "end_line": 5655,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.get_gitignore#5686",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.get_gitignore(root: Path)",
        "snippet": "def get_gitignore(root: Path) -> PathSpec:\n    \"\"\" Return a PathSpec matching gitignore content if present.\"\"\"\n    gitignore = root / \".gitignore\"\n    lines: List[str] = []\n    if gitignore.is_file():\n        with gitignore.open() as gf:\n            lines = gf.readlines()\n    return PathSpec.from_lines(\"gitwildmatch\", lines)",
        "begin_line": 5686,
        "end_line": 5693,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.gen_python_files_in_dir#5696",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.gen_python_files_in_dir(path: Path, root: Path, include: Pattern[str], exclude: Pattern[str], report: 'Report', gitignore: PathSpec)",
        "snippet": "def gen_python_files_in_dir(\n    path: Path,\n    root: Path,\n    include: Pattern[str],\n    exclude: Pattern[str],\n    report: \"Report\",\n    gitignore: PathSpec,\n) -> Iterator[Path]:\n    \"\"\"Generate all files under `path` whose paths are not excluded by the\n    `exclude` regex, but are included by the `include` regex.\n\n    Symbolic links pointing outside of the `root` directory are ignored.\n\n    `report` is where output about exclusions goes.\n    \"\"\"\n    assert root.is_absolute(), f\"INTERNAL ERROR: `root` must be absolute but is {root}\"\n    for child in path.iterdir():\n        # First ignore files matching .gitignore\n        if gitignore.match_file(child.as_posix()):\n            report.path_ignored(child, \"matches the .gitignore file content\")\n            continue\n\n        # Then ignore with `exclude` option.\n        try:\n            normalized_path = \"/\" + child.resolve().relative_to(root).as_posix()\n        except OSError as e:\n            report.path_ignored(child, f\"cannot be read because {e}\")\n            continue\n\n        except ValueError:\n            if child.is_symlink():\n                report.path_ignored(\n                    child, f\"is a symbolic link that points outside {root}\"\n                )\n                continue\n\n            raise\n\n        if child.is_dir():\n            normalized_path += \"/\"\n\n        exclude_match = exclude.search(normalized_path)\n        if exclude_match and exclude_match.group(0):\n            report.path_ignored(child, \"matches the --exclude regular expression\")\n            continue\n\n        if child.is_dir():\n            yield from gen_python_files_in_dir(\n                child, root, include, exclude, report, gitignore\n            )\n\n        elif child.is_file():\n            include_match = include.search(normalized_path)\n            if include_match:\n                yield child",
        "begin_line": 5696,
        "end_line": 5750,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.06666666666666667,
            "pseudo_dstar_susp": 0.05555555555555555,
            "pseudo_tarantula_susp": 0.07142857142857142,
            "pseudo_op2_susp": 0.05555555555555555,
            "pseudo_barinel_susp": 0.07142857142857142
        }
    },
    {
        "name": "black.find_project_root#5754",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.find_project_root(srcs: Iterable[str])",
        "snippet": "def find_project_root(srcs: Iterable[str]) -> Path:\n    \"\"\"Return a directory containing .git, .hg, or pyproject.toml.\n\n    That directory can be one of the directories passed in `srcs` or their\n    common parent.\n\n    If no directory in the tree contains a marker that would specify it's the\n    project root, the root of the file system is returned.\n    \"\"\"\n    if not srcs:\n        return Path(\"/\").resolve()\n\n    common_base = min(Path(src).resolve() for src in srcs)\n    if common_base.is_dir():\n        # Append a fake file so `parents` below returns `common_base_dir`, too.\n        common_base /= \"fake-file\"\n    for directory in common_base.parents:\n        if (directory / \".git\").exists():\n            return directory\n\n        if (directory / \".hg\").is_dir():\n            return directory\n\n        if (directory / \"pyproject.toml\").is_file():\n            return directory\n\n    return directory",
        "begin_line": 5754,
        "end_line": 5780,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.3333333333333333,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.3333333333333333,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.3333333333333333
        }
    },
    {
        "name": "black.Report.done#5795",
        "src_path": "black.py",
        "class_name": "black.Report",
        "signature": "black.Report.done(self, src: Path, changed: Changed)",
        "snippet": "    def done(self, src: Path, changed: Changed) -> None:\n        \"\"\"Increment the counter for successful reformatting. Write out a message.\"\"\"\n        if changed is Changed.YES:\n            reformatted = \"would reformat\" if self.check or self.diff else \"reformatted\"\n            if self.verbose or not self.quiet:\n                out(f\"{reformatted} {src}\")\n            self.change_count += 1\n        else:\n            if self.verbose:\n                if changed is Changed.NO:\n                    msg = f\"{src} already well formatted, good job.\"\n                else:\n                    msg = f\"{src} wasn't modified on disk since last run.\"\n                out(msg, bold=False)\n            self.same_count += 1",
        "begin_line": 5795,
        "end_line": 5809,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Report.failed#5811",
        "src_path": "black.py",
        "class_name": "black.Report",
        "signature": "black.Report.failed(self, src: Path, message: str)",
        "snippet": "    def failed(self, src: Path, message: str) -> None:\n        \"\"\"Increment the counter for failed reformatting. Write out a message.\"\"\"\n        err(f\"error: cannot format {src}: {message}\")\n        self.failure_count += 1",
        "begin_line": 5811,
        "end_line": 5814,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.001215066828675577,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Report.path_ignored#5816",
        "src_path": "black.py",
        "class_name": "black.Report",
        "signature": "black.Report.path_ignored(self, path: Path, message: str)",
        "snippet": "    def path_ignored(self, path: Path, message: str) -> None:\n        if self.verbose:\n            out(f\"{path} ignored: {message}\", bold=False)",
        "begin_line": 5816,
        "end_line": 5818,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Report.return_code#5821",
        "src_path": "black.py",
        "class_name": "black.Report",
        "signature": "black.Report.return_code(self)",
        "snippet": "    def return_code(self) -> int:\n        \"\"\"Return the exit code that the app should use.\n\n        This considers the current state of changed files and failures:\n        - if there were any failures, return 123;\n        - if any files were changed and --check is being used, return 1;\n        - otherwise return 0.\n        \"\"\"\n        # According to http://tldp.org/LDP/abs/html/exitcodes.html starting with\n        # 126 we have special return codes reserved by the shell.\n        if self.failure_count:\n            return 123\n\n        elif self.change_count and self.check:\n            return 1\n\n        return 0",
        "begin_line": 5821,
        "end_line": 5837,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0016891891891891893,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.Report.__str__#5839",
        "src_path": "black.py",
        "class_name": "black.Report",
        "signature": "black.Report.__str__(self)",
        "snippet": "    def __str__(self) -> str:\n        \"\"\"Render a color report of the current state.\n\n        Use `click.unstyle` to remove colors.\n        \"\"\"\n        if self.check or self.diff:\n            reformatted = \"would be reformatted\"\n            unchanged = \"would be left unchanged\"\n            failed = \"would fail to reformat\"\n        else:\n            reformatted = \"reformatted\"\n            unchanged = \"left unchanged\"\n            failed = \"failed to reformat\"\n        report = []\n        if self.change_count:\n            s = \"s\" if self.change_count > 1 else \"\"\n            report.append(\n                click.style(f\"{self.change_count} file{s} {reformatted}\", bold=True)\n            )\n        if self.same_count:\n            s = \"s\" if self.same_count > 1 else \"\"\n            report.append(f\"{self.same_count} file{s} {unchanged}\")\n        if self.failure_count:\n            s = \"s\" if self.failure_count > 1 else \"\"\n            report.append(\n                click.style(f\"{self.failure_count} file{s} {failed}\", fg=\"red\")\n            )\n        return \", \".join(report) + \".\"",
        "begin_line": 5839,
        "end_line": 5866,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.001215066828675577,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.parse_ast#5869",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.parse_ast(src: str)",
        "snippet": "def parse_ast(src: str) -> Union[ast.AST, ast3.AST, ast27.AST]:\n    filename = \"<unknown>\"\n    if sys.version_info >= (3, 8):\n        # TODO: support Python 4+ ;)\n        for minor_version in range(sys.version_info[1], 4, -1):\n            try:\n                return ast.parse(src, filename, feature_version=(3, minor_version))\n            except SyntaxError:\n                continue\n    else:\n        for feature_version in (7, 6):\n            try:\n                return ast3.parse(src, filename, feature_version=feature_version)\n            except SyntaxError:\n                continue\n\n    return ast27.parse(src)",
        "begin_line": 5869,
        "end_line": 5885,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black._fixup_ast_constants#5888",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black._fixup_ast_constants(node: Union[ast.AST, ast3.AST, ast27.AST])",
        "snippet": "def _fixup_ast_constants(\n    node: Union[ast.AST, ast3.AST, ast27.AST]\n) -> Union[ast.AST, ast3.AST, ast27.AST]:\n    \"\"\"Map ast nodes deprecated in 3.8 to Constant.\"\"\"\n    if isinstance(node, (ast.Str, ast3.Str, ast27.Str, ast.Bytes, ast3.Bytes)):\n        return ast.Constant(value=node.s)\n\n    if isinstance(node, (ast.Num, ast3.Num, ast27.Num)):\n        return ast.Constant(value=node.n)\n\n    if isinstance(node, (ast.NameConstant, ast3.NameConstant)):\n        return ast.Constant(value=node.value)\n\n    return node",
        "begin_line": 5888,
        "end_line": 5901,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0004995004995004995,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black._stringify_ast#5904",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black._stringify_ast(node: Union[ast.AST, ast3.AST, ast27.AST], depth: int=0)",
        "snippet": "def _stringify_ast(\n    node: Union[ast.AST, ast3.AST, ast27.AST], depth: int = 0\n) -> Iterator[str]:\n    \"\"\"Simple visitor generating strings to compare ASTs by content.\"\"\"\n\n    node = _fixup_ast_constants(node)\n\n    yield f\"{'  ' * depth}{node.__class__.__name__}(\"\n\n    for field in sorted(node._fields):  # noqa: F402\n        # TypeIgnore has only one field 'lineno' which breaks this comparison\n        type_ignore_classes = (ast3.TypeIgnore, ast27.TypeIgnore)\n        if sys.version_info >= (3, 8):\n            type_ignore_classes += (ast.TypeIgnore,)\n        if isinstance(node, type_ignore_classes):\n            break\n\n        try:\n            value = getattr(node, field)\n        except AttributeError:\n            continue\n\n        yield f\"{'  ' * (depth+1)}{field}=\"\n\n        if isinstance(value, list):\n            for item in value:\n                # Ignore nested tuples within del statements, because we may insert\n                # parentheses and they change the AST.\n                if (\n                    field == \"targets\"\n                    and isinstance(node, (ast.Delete, ast3.Delete, ast27.Delete))\n                    and isinstance(item, (ast.Tuple, ast3.Tuple, ast27.Tuple))\n                ):\n                    for item in item.elts:\n                        yield from _stringify_ast(item, depth + 2)\n\n                elif isinstance(item, (ast.AST, ast3.AST, ast27.AST)):\n                    yield from _stringify_ast(item, depth + 2)\n\n        elif isinstance(value, (ast.AST, ast3.AST, ast27.AST)):\n            yield from _stringify_ast(value, depth + 2)\n\n        else:\n            # Constant strings may be indented across newlines, if they are\n            # docstrings; fold spaces after newlines when comparing\n            if (\n                isinstance(node, ast.Constant)\n                and field == \"value\"\n                and isinstance(value, str)\n            ):\n                normalized = re.sub(r\"\\n[ \\t]+\", \"\\n \", value)\n            else:\n                normalized = value\n            yield f\"{'  ' * (depth+2)}{normalized!r},  # {value.__class__.__name__}\"\n\n    yield f\"{'  ' * depth})  # /{node.__class__.__name__}\"",
        "begin_line": 5904,
        "end_line": 5959,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.assert_equivalent#5962",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.assert_equivalent(src: str, dst: str)",
        "snippet": "def assert_equivalent(src: str, dst: str) -> None:\n    \"\"\"Raise AssertionError if `src` and `dst` aren't equivalent.\"\"\"\n    try:\n        src_ast = parse_ast(src)\n    except Exception as exc:\n        raise AssertionError(\n            \"cannot use --safe with this file; failed to parse source file.  AST\"\n            f\" error message: {exc}\"\n        )\n\n    try:\n        dst_ast = parse_ast(dst)\n    except Exception as exc:\n        log = dump_to_file(\"\".join(traceback.format_tb(exc.__traceback__)), dst)\n        raise AssertionError(\n            f\"INTERNAL ERROR: Black produced invalid code: {exc}. Please report a bug\"\n            \" on https://github.com/psf/black/issues.  This invalid output might be\"\n            f\" helpful: {log}\"\n        ) from None\n\n    src_ast_str = \"\\n\".join(_stringify_ast(src_ast))\n    dst_ast_str = \"\\n\".join(_stringify_ast(dst_ast))\n    if src_ast_str != dst_ast_str:\n        log = dump_to_file(diff(src_ast_str, dst_ast_str, \"src\", \"dst\"))\n        raise AssertionError(\n            \"INTERNAL ERROR: Black produced code that is not equivalent to the\"\n            \" source.  Please report a bug on https://github.com/psf/black/issues. \"\n            f\" This diff might be helpful: {log}\"\n        ) from None",
        "begin_line": 5962,
        "end_line": 5990,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.assert_stable#5993",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.assert_stable(src: str, dst: str, mode: Mode)",
        "snippet": "def assert_stable(src: str, dst: str, mode: Mode) -> None:\n    \"\"\"Raise AssertionError if `dst` reformats differently the second time.\"\"\"\n    newdst = format_str(dst, mode=mode)\n    if dst != newdst:\n        log = dump_to_file(\n            diff(src, dst, \"source\", \"first pass\"),\n            diff(dst, newdst, \"first pass\", \"second pass\"),\n        )\n        raise AssertionError(\n            \"INTERNAL ERROR: Black produced different code on the second pass of the\"\n            \" formatter.  Please report a bug on https://github.com/psf/black/issues.\"\n            f\"  This diff might be helpful: {log}\"\n        ) from None",
        "begin_line": 5993,
        "end_line": 6005,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00036536353671903543,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.dump_to_file#6009",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.dump_to_file(*output: str)",
        "snippet": "def dump_to_file(*output: str) -> str:\n    \"\"\"Dump `output` to a temporary file. Return path to the file.\"\"\"\n    with tempfile.NamedTemporaryFile(\n        mode=\"w\", prefix=\"blk_\", suffix=\".log\", delete=False, encoding=\"utf8\"\n    ) as f:\n        for lines in output:\n            f.write(lines)\n            if lines and lines[-1] != \"\\n\":\n                f.write(\"\\n\")\n    return f.name",
        "begin_line": 6009,
        "end_line": 6018,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0016891891891891893,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.nullcontext#6022",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.nullcontext()",
        "snippet": "def nullcontext() -> Iterator[None]:\n    \"\"\"Return an empty context manager.\n\n    To be used like `nullcontext` in Python 3.7.\n    \"\"\"\n    yield",
        "begin_line": 6022,
        "end_line": 6027,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0016891891891891893,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.diff#6030",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.diff(a: str, b: str, a_name: str, b_name: str)",
        "snippet": "def diff(a: str, b: str, a_name: str, b_name: str) -> str:\n    \"\"\"Return a unified diff string between strings `a` and `b`.\"\"\"\n    import difflib\n\n    a_lines = [line + \"\\n\" for line in a.splitlines()]\n    b_lines = [line + \"\\n\" for line in b.splitlines()]\n    return \"\".join(\n        difflib.unified_diff(a_lines, b_lines, fromfile=a_name, tofile=b_name, n=5)\n    )",
        "begin_line": 6030,
        "end_line": 6038,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0011001100110011,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.shutdown#6048",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.shutdown(loop: asyncio.AbstractEventLoop)",
        "snippet": "def shutdown(loop: asyncio.AbstractEventLoop) -> None:\n    \"\"\"Cancel all pending tasks on `loop`, wait for them, and close the loop.\"\"\"\n    try:\n        if sys.version_info[:2] >= (3, 7):\n            all_tasks = asyncio.all_tasks\n        else:\n            all_tasks = asyncio.Task.all_tasks\n        # This part is borrowed from asyncio/runners.py in Python 3.7b2.\n        to_cancel = [task for task in all_tasks(loop) if not task.done()]\n        if not to_cancel:\n            return\n\n        for task in to_cancel:\n            task.cancel()\n        loop.run_until_complete(\n            asyncio.gather(*to_cancel, loop=loop, return_exceptions=True)\n        )\n    finally:\n        # `concurrent.futures.Future` objects cannot be cancelled once they\n        # are already running. There might be some when the `shutdown()` happened.\n        # Silence their logger's spew about the event loop being closed.\n        cf_logger = logging.getLogger(\"concurrent.futures\")\n        cf_logger.setLevel(logging.CRITICAL)\n        loop.close()",
        "begin_line": 6048,
        "end_line": 6071,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0013698630136986301,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.sub_twice#6074",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.sub_twice(regex: Pattern[str], replacement: str, original: str)",
        "snippet": "def sub_twice(regex: Pattern[str], replacement: str, original: str) -> str:\n    \"\"\"Replace `regex` with `replacement` twice on `original`.\n\n    This is used by string normalization to perform replaces on\n    overlapping matches.\n    \"\"\"\n    return regex.sub(replacement, regex.sub(replacement, original))",
        "begin_line": 6074,
        "end_line": 6080,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00040816326530612246,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.re_compile_maybe_verbose#6083",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.re_compile_maybe_verbose(regex: str)",
        "snippet": "def re_compile_maybe_verbose(regex: str) -> Pattern[str]:\n    \"\"\"Compile a regular expression string in `regex`.\n\n    If it contains newlines, use verbose mode.\n    \"\"\"\n    if \"\\n\" in regex:\n        regex = \"(?x)\" + regex\n    compiled: Pattern[str] = re.compile(regex)\n    return compiled",
        "begin_line": 6083,
        "end_line": 6091,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010869565217391304,
            "pseudo_dstar_susp": 0.010869565217391304,
            "pseudo_tarantula_susp": 0.010869565217391304,
            "pseudo_op2_susp": 0.010869565217391304,
            "pseudo_barinel_susp": 0.010869565217391304
        }
    },
    {
        "name": "black.enumerate_reversed#6094",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.enumerate_reversed(sequence: Sequence[T])",
        "snippet": "def enumerate_reversed(sequence: Sequence[T]) -> Iterator[Tuple[Index, T]]:\n    \"\"\"Like `reversed(enumerate(sequence))` if that were possible.\"\"\"\n    index = len(sequence) - 1\n    for element in reversed(sequence):\n        yield (index, element)\n        index -= 1",
        "begin_line": 6094,
        "end_line": 6099,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.000697350069735007,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.enumerate_with_length#6102",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.enumerate_with_length(line: Line, reversed: bool=False)",
        "snippet": "def enumerate_with_length(\n    line: Line, reversed: bool = False\n) -> Iterator[Tuple[Index, Leaf, int]]:\n    \"\"\"Return an enumeration of leaves with their length.\n\n    Stops prematurely on multiline strings and standalone comments.\n    \"\"\"\n    op = cast(\n        Callable[[Sequence[Leaf]], Iterator[Tuple[Index, Leaf]]],\n        enumerate_reversed if reversed else enumerate,\n    )\n    for index, leaf in op(line.leaves):\n        length = len(leaf.prefix) + len(leaf.value)\n        if \"\\n\" in leaf.value:\n            return  # Multiline strings, we can't continue.\n\n        for comment in line.comments_after(leaf):\n            length += len(comment.value)\n\n        yield index, leaf, length",
        "begin_line": 6102,
        "end_line": 6121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.is_line_short_enough#6124",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.is_line_short_enough(line: Line, *, line_length: int, line_str: str='')",
        "snippet": "def is_line_short_enough(line: Line, *, line_length: int, line_str: str = \"\") -> bool:\n    \"\"\"Return True if `line` is no longer than `line_length`.\n\n    Uses the provided `line_str` rendering, if any, otherwise computes a new one.\n    \"\"\"\n    if not line_str:\n        line_str = line_to_string(line)\n    return (\n        len(line_str) <= line_length\n        and \"\\n\" not in line_str  # multiline strings\n        and not line.contains_standalone_comments()\n    )",
        "begin_line": 6124,
        "end_line": 6135,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0004666355576294914,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.can_be_split#6138",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.can_be_split(line: Line)",
        "snippet": "def can_be_split(line: Line) -> bool:\n    \"\"\"Return False if the line cannot be split *for sure*.\n\n    This is not an exhaustive search but a cheap heuristic that we can use to\n    avoid some unfortunate formattings (mostly around wrapping unsplittable code\n    in unnecessary parentheses).\n    \"\"\"\n    leaves = line.leaves\n    if len(leaves) < 2:\n        return False\n\n    if leaves[0].type == token.STRING and leaves[1].type == token.DOT:\n        call_count = 0\n        dot_count = 0\n        next = leaves[-1]\n        for leaf in leaves[-2::-1]:\n            if leaf.type in OPENING_BRACKETS:\n                if next.type not in CLOSING_BRACKETS:\n                    return False\n\n                call_count += 1\n            elif leaf.type == token.DOT:\n                dot_count += 1\n            elif leaf.type == token.NAME:\n                if not (next.type == token.DOT or next.type in OPENING_BRACKETS):\n                    return False\n\n            elif leaf.type not in CLOSING_BRACKETS:\n                return False\n\n            if dot_count > 1 and call_count > 1:\n                return False\n\n    return True",
        "begin_line": 6138,
        "end_line": 6171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.can_omit_invisible_parens#6174",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.can_omit_invisible_parens(line: Line, line_length: int)",
        "snippet": "def can_omit_invisible_parens(line: Line, line_length: int) -> bool:\n    \"\"\"Does `line` have a shape safe to reformat without optional parens around it?\n\n    Returns True for only a subset of potentially nice looking formattings but\n    the point is to not return false positives that end up producing lines that\n    are too long.\n    \"\"\"\n    bt = line.bracket_tracker\n    if not bt.delimiters:\n        # Without delimiters the optional parentheses are useless.\n        return True\n\n    max_priority = bt.max_delimiter_priority()\n    if bt.delimiter_count_with_priority(max_priority) > 1:\n        # With more than one delimiter of a kind the optional parentheses read better.\n        return False\n\n    if max_priority == DOT_PRIORITY:\n        # A single stranded method call doesn't require optional parentheses.\n        return True\n\n    assert len(line.leaves) >= 2, \"Stranded delimiter\"\n\n    first = line.leaves[0]\n    second = line.leaves[1]\n    penultimate = line.leaves[-2]\n    last = line.leaves[-1]\n\n    # With a single delimiter, omit if the expression starts or ends with\n    # a bracket.\n    if first.type in OPENING_BRACKETS and second.type not in CLOSING_BRACKETS:\n        remainder = False\n        length = 4 * line.depth\n        for _index, leaf, leaf_length in enumerate_with_length(line):\n            if leaf.type in CLOSING_BRACKETS and leaf.opening_bracket is first:\n                remainder = True\n            if remainder:\n                length += leaf_length\n                if length > line_length:\n                    break\n\n                if leaf.type in OPENING_BRACKETS:\n                    # There are brackets we can further split on.\n                    remainder = False\n\n        else:\n            # checked the entire string and line length wasn't exceeded\n            if len(line.leaves) == _index + 1:\n                return True\n\n        # Note: we are not returning False here because a line might have *both*\n        # a leading opening bracket and a trailing closing bracket.  If the\n        # opening bracket doesn't match our rule, maybe the closing will.\n\n    if (\n        last.type == token.RPAR\n        or last.type == token.RBRACE\n        or (\n            # don't use indexing for omitting optional parentheses;\n            # it looks weird\n            last.type == token.RSQB\n            and last.parent\n            and last.parent.type != syms.trailer\n        )\n    ):\n        if penultimate.type in OPENING_BRACKETS:\n            # Empty brackets don't help.\n            return False\n\n        if is_multiline_string(first):\n            # Additional wrapping of a multiline string in this situation is\n            # unnecessary.\n            return True\n\n        length = 4 * line.depth\n        seen_other_brackets = False\n        for _index, leaf, leaf_length in enumerate_with_length(line):\n            length += leaf_length\n            if leaf is last.opening_bracket:\n                if seen_other_brackets or length <= line_length:\n                    return True\n\n            elif leaf.type in OPENING_BRACKETS:\n                # There are brackets we can further split on.\n                seen_other_brackets = True\n\n    return False",
        "begin_line": 6174,
        "end_line": 6260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.get_cache_file#6263",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.get_cache_file(mode: Mode)",
        "snippet": "def get_cache_file(mode: Mode) -> Path:\n    return CACHE_DIR / f\"cache.{mode.get_cache_key()}.pickle\"",
        "begin_line": 6263,
        "end_line": 6264,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.017543859649122806,
            "pseudo_dstar_susp": 0.017543859649122806,
            "pseudo_tarantula_susp": 0.01818181818181818,
            "pseudo_op2_susp": 0.017543859649122806,
            "pseudo_barinel_susp": 0.01818181818181818
        }
    },
    {
        "name": "black.read_cache#6267",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.read_cache(mode: Mode)",
        "snippet": "def read_cache(mode: Mode) -> Cache:\n    \"\"\"Read the cache if it exists and is well formed.\n\n    If it is not well formed, the call to write_cache later should resolve the issue.\n    \"\"\"\n    cache_file = get_cache_file(mode)\n    if not cache_file.exists():\n        return {}\n\n    with cache_file.open(\"rb\") as fobj:\n        try:\n            cache: Cache = pickle.load(fobj)\n        except (pickle.UnpicklingError, ValueError):\n            return {}\n\n    return cache",
        "begin_line": 6267,
        "end_line": 6282,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.get_cache_info#6285",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.get_cache_info(path: Path)",
        "snippet": "def get_cache_info(path: Path) -> CacheInfo:\n    \"\"\"Return the information used to check if a file is already formatted or not.\"\"\"\n    stat = path.stat()\n    return stat.st_mtime, stat.st_size",
        "begin_line": 6285,
        "end_line": 6288,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.025,
            "pseudo_dstar_susp": 0.025,
            "pseudo_tarantula_susp": 0.02702702702702703,
            "pseudo_op2_susp": 0.025,
            "pseudo_barinel_susp": 0.02702702702702703
        }
    },
    {
        "name": "black.filter_cached#6291",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.filter_cached(cache: Cache, sources: Iterable[Path])",
        "snippet": "def filter_cached(cache: Cache, sources: Iterable[Path]) -> Tuple[Set[Path], Set[Path]]:\n    \"\"\"Split an iterable of paths in `sources` into two sets.\n\n    The first contains paths of files that modified on disk or are not in the\n    cache. The other contains paths to non-modified files.\n    \"\"\"\n    todo, done = set(), set()\n    for src in sources:\n        src = src.resolve()\n        if cache.get(src) != get_cache_info(src):\n            todo.add(src)\n        else:\n            done.add(src)\n    return todo, done",
        "begin_line": 6291,
        "end_line": 6304,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "black.write_cache#6307",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.write_cache(cache: Cache, sources: Iterable[Path], mode: Mode)",
        "snippet": "def write_cache(cache: Cache, sources: Iterable[Path], mode: Mode) -> None:\n    \"\"\"Update the cache file.\"\"\"\n    cache_file = get_cache_file(mode)\n    try:\n        CACHE_DIR.mkdir(parents=True, exist_ok=True)\n        new_cache = {**cache, **{src.resolve(): get_cache_info(src) for src in sources}}\n        with tempfile.NamedTemporaryFile(dir=str(cache_file.parent), delete=False) as f:\n            pickle.dump(new_cache, f, protocol=4)\n        os.replace(f.name, cache_file)\n    except OSError:\n        pass",
        "begin_line": 6307,
        "end_line": 6317,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.07692307692307693,
            "pseudo_dstar_susp": 0.5,
            "pseudo_tarantula_susp": 0.03225806451612903,
            "pseudo_op2_susp": 0.5,
            "pseudo_barinel_susp": 0.03225806451612903
        }
    },
    {
        "name": "black.patch_click#6320",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.patch_click()",
        "snippet": "def patch_click() -> None:\n    \"\"\"Make Click not crash.\n\n    On certain misconfigured environments, Python 3 selects the ASCII encoding as the\n    default which restricts paths that it can access during the lifetime of the\n    application.  Click refuses to work in this scenario by raising a RuntimeError.\n\n    In case of Black the likelihood that non-ASCII characters are going to be used in\n    file paths is minimal since it's Python source code.  Moreover, this crash was\n    spurious on Python 3.7 thanks to PEP 538 and PEP 540.\n    \"\"\"\n    try:\n        from click import core\n        from click import _unicodefun  # type: ignore\n    except ModuleNotFoundError:\n        return\n\n    for module in (core, _unicodefun):\n        if hasattr(module, \"_verify_python3_env\"):\n            module._verify_python3_env = lambda: None",
        "begin_line": 6320,
        "end_line": 6339,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 1.0,
            "pseudo_dstar_susp": 1.0,
            "pseudo_tarantula_susp": 0.3333333333333333,
            "pseudo_op2_susp": 1.0,
            "pseudo_barinel_susp": 0.3333333333333333
        }
    },
    {
        "name": "black.fix_docstring#6348",
        "src_path": "black.py",
        "class_name": "black",
        "signature": "black.fix_docstring(docstring: str, prefix: str)",
        "snippet": "def fix_docstring(docstring: str, prefix: str) -> str:\n    # https://www.python.org/dev/peps/pep-0257/#handling-docstring-indentation\n    if not docstring:\n        return \"\"\n    # Convert tabs to spaces (following the normal Python rules)\n    # and split into a list of lines:\n    lines = docstring.expandtabs().splitlines()\n    # Determine minimum indentation (first line doesn't count):\n    indent = sys.maxsize\n    for line in lines[1:]:\n        stripped = line.lstrip()\n        if stripped:\n            indent = min(indent, len(line) - len(stripped))\n    # Remove indentation (first line is special):\n    trimmed = [lines[0].strip()]\n    if indent < sys.maxsize:\n        last_line_idx = len(lines) - 2\n        for i, line in enumerate(lines[1:]):\n            stripped_line = line[indent:].rstrip()\n            if stripped_line or i == last_line_idx:\n                trimmed.append(prefix + stripped_line)\n            else:\n                trimmed.append(\"\")\n    # Return a single string:\n    return \"\\n\".join(trimmed)",
        "begin_line": 6348,
        "end_line": 6372,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.000697350069735007,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pgen2.parse.ParseError.__init__#45",
        "src_path": "blib2to3/pgen2/parse.py",
        "class_name": "blib2to3.pgen2.parse.ParseError",
        "signature": "blib2to3.pgen2.parse.ParseError.__init__(self, msg: Text, type: Optional[int], value: Optional[Text], context: Context)",
        "snippet": "    def __init__(\n        self, msg: Text, type: Optional[int], value: Optional[Text], context: Context\n    ) -> None:\n        Exception.__init__(\n            self, \"%s: type=%r, value=%r, context=%r\" % (msg, type, value, context)\n        )\n        self.msg = msg\n        self.type = type\n        self.value = value\n        self.context = context",
        "begin_line": 45,
        "end_line": 54,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.001215066828675577,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pgen2.parse.Parser.__init__#87",
        "src_path": "blib2to3/pgen2/parse.py",
        "class_name": "blib2to3.pgen2.parse.Parser",
        "signature": "blib2to3.pgen2.parse.Parser.__init__(self, grammar: Grammar, convert: Optional[Convert]=None)",
        "snippet": "    def __init__(self, grammar: Grammar, convert: Optional[Convert] = None) -> None:\n        \"\"\"Constructor.\n\n        The grammar argument is a grammar.Grammar instance; see the\n        grammar module for more information.\n\n        The parser is not ready yet for parsing; you must call the\n        setup() method to get it started.\n\n        The optional convert argument is a function mapping concrete\n        syntax tree nodes to abstract syntax tree nodes.  If not\n        given, no conversion is done and the syntax tree produced is\n        the concrete syntax tree.  If given, it must be a function of\n        two arguments, the first being the grammar (a grammar.Grammar\n        instance), and the second being the concrete syntax tree node\n        to be converted.  The syntax tree is converted from the bottom\n        up.\n\n        A concrete syntax tree node is a (type, value, context, nodes)\n        tuple, where type is the node type (a token or symbol number),\n        value is None for symbols and a string for tokens, context is\n        None or an opaque value used for error reporting (typically a\n        (lineno, offset) pair), and nodes is a list of children for\n        symbols, and None for tokens.\n\n        An abstract syntax tree node may be anything; this is entirely\n        up to the converter function.\n\n        \"\"\"\n        self.grammar = grammar\n        self.convert = convert or lam_sub",
        "begin_line": 87,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00030175015087507544,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pgen2.parse.Parser.setup#119",
        "src_path": "blib2to3/pgen2/parse.py",
        "class_name": "blib2to3.pgen2.parse.Parser",
        "signature": "blib2to3.pgen2.parse.Parser.setup(self, start: Optional[int]=None)",
        "snippet": "    def setup(self, start: Optional[int] = None) -> None:\n        \"\"\"Prepare for parsing.\n\n        This *must* be called before starting to parse.\n\n        The optional argument is an alternative start symbol; it\n        defaults to the grammar's start symbol.\n\n        You can use a Parser instance to parse any number of programs;\n        each time you call setup() the parser is reset to an initial\n        state determined by the (implicit or explicit) start symbol.\n\n        \"\"\"\n        if start is None:\n            start = self.grammar.start\n        # Each stack entry is a tuple: (dfa, state, node).\n        # A node is a tuple: (type, value, context, children),\n        # where children is a list of nodes or None, and context may be None.\n        newnode: RawNode = (start, None, None, [])\n        stackentry = (self.grammar.dfas[start], 0, newnode)\n        self.stack: List[Tuple[DFAS, int, RawNode]] = [stackentry]\n        self.rootnode: Optional[NL] = None\n        self.used_names: Set[str] = set()",
        "begin_line": 119,
        "end_line": 141,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00030175015087507544,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pgen2.parse.Parser.addtoken#143",
        "src_path": "blib2to3/pgen2/parse.py",
        "class_name": "blib2to3.pgen2.parse.Parser",
        "signature": "blib2to3.pgen2.parse.Parser.addtoken(self, type: int, value: Optional[Text], context: Context)",
        "snippet": "    def addtoken(self, type: int, value: Optional[Text], context: Context) -> bool:\n        \"\"\"Add a token; return True iff this is the end of the program.\"\"\"\n        # Map from token to label\n        ilabel = self.classify(type, value, context)\n        # Loop until the token is shifted; may raise exceptions\n        while True:\n            dfa, state, node = self.stack[-1]\n            states, first = dfa\n            arcs = states[state]\n            # Look for a state with this label\n            for i, newstate in arcs:\n                t, v = self.grammar.labels[i]\n                if ilabel == i:\n                    # Look it up in the list of labels\n                    assert t < 256\n                    # Shift a token; we're done with it\n                    self.shift(type, value, newstate, context)\n                    # Pop while we are in an accept-only state\n                    state = newstate\n                    while states[state] == [(0, state)]:\n                        self.pop()\n                        if not self.stack:\n                            # Done parsing!\n                            return True\n                        dfa, state, node = self.stack[-1]\n                        states, first = dfa\n                    # Done with this token\n                    return False\n                elif t >= 256:\n                    # See if it's a symbol and if we're in its first set\n                    itsdfa = self.grammar.dfas[t]\n                    itsstates, itsfirst = itsdfa\n                    if ilabel in itsfirst:\n                        # Push a symbol\n                        self.push(t, self.grammar.dfas[t], newstate, context)\n                        break  # To continue the outer while loop\n            else:\n                if (0, state) in arcs:\n                    # An accepting state, pop it and try something else\n                    self.pop()\n                    if not self.stack:\n                        # Done parsing, but another token is input\n                        raise ParseError(\"too much input\", type, value, context)\n                else:\n                    # No success finding a transition\n                    raise ParseError(\"bad input\", type, value, context)",
        "begin_line": 143,
        "end_line": 188,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.001215066828675577,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pgen2.parse.Parser.classify#190",
        "src_path": "blib2to3/pgen2/parse.py",
        "class_name": "blib2to3.pgen2.parse.Parser",
        "signature": "blib2to3.pgen2.parse.Parser.classify(self, type: int, value: Optional[Text], context: Context)",
        "snippet": "    def classify(self, type: int, value: Optional[Text], context: Context) -> int:\n        \"\"\"Turn a token into a label.  (Internal)\"\"\"\n        if type == token.NAME:\n            # Keep a listing of all used names\n            assert value is not None\n            self.used_names.add(value)\n            # Check for reserved words\n            ilabel = self.grammar.keywords.get(value)\n            if ilabel is not None:\n                return ilabel\n        ilabel = self.grammar.tokens.get(type)\n        if ilabel is None:\n            raise ParseError(\"bad token\", type, value, context)\n        return ilabel",
        "begin_line": 190,
        "end_line": 203,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00036886757654002215,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pgen2.parse.Parser.shift#205",
        "src_path": "blib2to3/pgen2/parse.py",
        "class_name": "blib2to3.pgen2.parse.Parser",
        "signature": "blib2to3.pgen2.parse.Parser.shift(self, type: int, value: Optional[Text], newstate: int, context: Context)",
        "snippet": "    def shift(\n        self, type: int, value: Optional[Text], newstate: int, context: Context\n    ) -> None:\n        \"\"\"Shift a token.  (Internal)\"\"\"\n        dfa, state, node = self.stack[-1]\n        assert value is not None\n        assert context is not None\n        rawnode: RawNode = (type, value, context, None)\n        newnode = self.convert(self.grammar, rawnode)\n        if newnode is not None:\n            assert node[-1] is not None\n            node[-1].append(newnode)\n        self.stack[-1] = (dfa, newstate, node)",
        "begin_line": 205,
        "end_line": 217,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00030175015087507544,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pgen2.parse.Parser.push#219",
        "src_path": "blib2to3/pgen2/parse.py",
        "class_name": "blib2to3.pgen2.parse.Parser",
        "signature": "blib2to3.pgen2.parse.Parser.push(self, type: int, newdfa: DFAS, newstate: int, context: Context)",
        "snippet": "    def push(self, type: int, newdfa: DFAS, newstate: int, context: Context) -> None:\n        \"\"\"Push a nonterminal.  (Internal)\"\"\"\n        dfa, state, node = self.stack[-1]\n        newnode: RawNode = (type, None, context, [])\n        self.stack[-1] = (dfa, newstate, node)\n        self.stack.append((newdfa, 0, newnode))",
        "begin_line": 219,
        "end_line": 224,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00031152647975077883,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pgen2.parse.Parser.pop#226",
        "src_path": "blib2to3/pgen2/parse.py",
        "class_name": "blib2to3.pgen2.parse.Parser",
        "signature": "blib2to3.pgen2.parse.Parser.pop(self)",
        "snippet": "    def pop(self) -> None:\n        \"\"\"Pop a nonterminal.  (Internal)\"\"\"\n        popdfa, popstate, popnode = self.stack.pop()\n        newnode = self.convert(self.grammar, popnode)\n        if newnode is not None:\n            if self.stack:\n                dfa, state, node = self.stack[-1]\n                assert node[-1] is not None\n                node[-1].append(newnode)\n            else:\n                self.rootnode = newnode\n                self.rootnode.used_names = self.used_names",
        "begin_line": 226,
        "end_line": 237,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00031152647975077883,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.type_repr#42",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree",
        "signature": "blib2to3.pytree.type_repr(type_num: int)",
        "snippet": "def type_repr(type_num: int) -> Union[Text, int]:\n    global _type_reprs\n    if not _type_reprs:\n        from .pygram import python_symbols\n\n        # printing tokens is possible but not as useful\n        # from .pgen2 import token // token.__dict__.items():\n        for name in dir(python_symbols):\n            val = getattr(python_symbols, name)\n            if type(val) == int:\n                _type_reprs[val] = name\n    return _type_reprs.setdefault(type_num, type_num)",
        "begin_line": 42,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Base.__new__#81",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Base",
        "signature": "blib2to3.pytree.Base.__new__(cls, *args, **kwds)",
        "snippet": "    def __new__(cls, *args, **kwds):\n        \"\"\"Constructor that prevents Base from being instantiated.\"\"\"\n        assert cls is not Base, \"Cannot instantiate Base\"\n        return object.__new__(cls)",
        "begin_line": 81,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00030175015087507544,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Base.__eq__#86",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Base",
        "signature": "blib2to3.pytree.Base.__eq__(self, other: Any)",
        "snippet": "    def __eq__(self, other: Any) -> bool:\n        \"\"\"\n        Compare two nodes for equality.\n\n        This calls the method _eq().\n        \"\"\"\n        if self.__class__ is not other.__class__:\n            return NotImplemented\n        return self._eq(other)",
        "begin_line": 86,
        "end_line": 94,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0005737234652897303,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Base.replace#137",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Base",
        "signature": "blib2to3.pytree.Base.replace(self, new: Union[NL, List[NL]])",
        "snippet": "    def replace(self, new: Union[NL, List[NL]]) -> None:\n        \"\"\"Replace this node with a new one in the parent.\"\"\"\n        assert self.parent is not None, str(self)\n        assert new is not None\n        if not isinstance(new, list):\n            new = [new]\n        l_children = []\n        found = False\n        for ch in self.parent.children:\n            if ch is self:\n                assert not found, (self.parent.children, self, new)\n                if new is not None:\n                    l_children.extend(new)\n                found = True\n            else:\n                l_children.append(ch)\n        assert found, (self.children, self, new)\n        self.parent.children = l_children\n        self.parent.changed()\n        self.parent.invalidate_sibling_maps()\n        for x in new:\n            x.parent = self.parent\n        self.parent = None",
        "begin_line": 137,
        "end_line": 159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0011001100110011,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Base.changed#170",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Base",
        "signature": "blib2to3.pytree.Base.changed(self)",
        "snippet": "    def changed(self) -> None:\n        if self.was_changed:\n            return\n        if self.parent:\n            self.parent.changed()\n        self.was_changed = True",
        "begin_line": 170,
        "end_line": 175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00033955857385398983,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Base.remove#177",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Base",
        "signature": "blib2to3.pytree.Base.remove(self)",
        "snippet": "    def remove(self) -> Optional[int]:\n        \"\"\"\n        Remove the node from the tree. Returns the position of the node in its\n        parent's children before it was removed.\n        \"\"\"\n        if self.parent:\n            for i, node in enumerate(self.parent.children):\n                if node is self:\n                    del self.parent.children[i]\n                    self.parent.changed()\n                    self.parent.invalidate_sibling_maps()\n                    self.parent = None\n                    return i\n        return None",
        "begin_line": 177,
        "end_line": 190,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0003990422984836393,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Base.next_sibling#193",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Base",
        "signature": "blib2to3.pytree.Base.next_sibling(self)",
        "snippet": "    def next_sibling(self) -> Optional[NL]:\n        \"\"\"\n        The node immediately following the invocant in their parent's children\n        list. If the invocant does not have a next sibling, it is None\n        \"\"\"\n        if self.parent is None:\n            return None\n\n        if self.parent.next_sibling_map is None:\n            self.parent.update_sibling_maps()\n        assert self.parent.next_sibling_map is not None\n        return self.parent.next_sibling_map[id(self)]",
        "begin_line": 193,
        "end_line": 204,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0006688963210702341,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Base.prev_sibling#207",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Base",
        "signature": "blib2to3.pytree.Base.prev_sibling(self)",
        "snippet": "    def prev_sibling(self) -> Optional[NL]:\n        \"\"\"\n        The node immediately preceding the invocant in their parent's children\n        list. If the invocant does not have a previous sibling, it is None.\n        \"\"\"\n        if self.parent is None:\n            return None\n\n        if self.parent.prev_sibling_map is None:\n            self.parent.update_sibling_maps()\n        assert self.parent.prev_sibling_map is not None\n        return self.parent.prev_sibling_map[id(self)]",
        "begin_line": 207,
        "end_line": 218,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0027548209366391185,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Base.leaves#220",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Base",
        "signature": "blib2to3.pytree.Base.leaves(self)",
        "snippet": "    def leaves(self) -> Iterator[\"Leaf\"]:\n        for child in self.children:\n            yield from child.leaves()",
        "begin_line": 220,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00032331070158422246,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Node.__init__#248",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Node",
        "signature": "blib2to3.pytree.Node.__init__(self, type: int, children: List[NL], context: Optional[Any]=None, prefix: Optional[Text]=None, fixers_applied: Optional[List[Any]]=None)",
        "snippet": "    def __init__(\n        self,\n        type: int,\n        children: List[NL],\n        context: Optional[Any] = None,\n        prefix: Optional[Text] = None,\n        fixers_applied: Optional[List[Any]] = None,\n    ) -> None:\n        \"\"\"\n        Initializer.\n\n        Takes a type constant (a symbol number >= 256), a sequence of\n        child nodes, and an optional context keyword argument.\n\n        As a side effect, the parent pointers of the children are updated.\n        \"\"\"\n        assert type >= 256, type\n        self.type = type\n        self.children = list(children)\n        for ch in self.children:\n            assert ch.parent is None, repr(ch)\n            ch.parent = self\n        self.invalidate_sibling_maps()\n        if prefix is not None:\n            self.prefix = prefix\n        if fixers_applied:\n            self.fixers_applied = fixers_applied[:]\n        else:\n            self.fixers_applied = None",
        "begin_line": 248,
        "end_line": 276,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00030175015087507544,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Node.__str__#287",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Node",
        "signature": "blib2to3.pytree.Node.__str__(self)",
        "snippet": "    def __str__(self) -> Text:\n        \"\"\"\n        Return a pretty string representation.\n\n        This reproduces the input source exactly.\n        \"\"\"\n        return \"\".join(map(str, self.children))",
        "begin_line": 287,
        "end_line": 293,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0016891891891891893,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Node._eq#295",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Node",
        "signature": "blib2to3.pytree.Node._eq(self, other)",
        "snippet": "    def _eq(self, other) -> bool:\n        \"\"\"Compare two nodes for equality.\"\"\"\n        return (self.type, self.children) == (other.type, other.children)",
        "begin_line": 295,
        "end_line": 297,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0005737234652897303,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Node.pre_order#314",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Node",
        "signature": "blib2to3.pytree.Node.pre_order(self)",
        "snippet": "    def pre_order(self) -> Iterator[NL]:\n        \"\"\"Return a pre-order iterator for the tree.\"\"\"\n        yield self\n        for child in self.children:\n            yield from child.pre_order()",
        "begin_line": 314,
        "end_line": 318,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0003624501631025734,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Node.prefix#321",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Node",
        "signature": "blib2to3.pytree.Node.prefix(self)",
        "snippet": "    def prefix(self) -> Text:\n        \"\"\"\n        The whitespace and comments preceding this node in the input.\n        \"\"\"\n        if not self.children:\n            return \"\"\n        return self.children[0].prefix",
        "begin_line": 321,
        "end_line": 327,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0003748125937031484,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Node.prefix#330",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Node",
        "signature": "blib2to3.pytree.Node.prefix(self, prefix)",
        "snippet": "    def prefix(self, prefix) -> None:\n        if self.children:\n            self.children[0].prefix = prefix",
        "begin_line": 330,
        "end_line": 332,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00040241448692152917,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Node.insert_child#345",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Node",
        "signature": "blib2to3.pytree.Node.insert_child(self, i: int, child: NL)",
        "snippet": "    def insert_child(self, i: int, child: NL) -> None:\n        \"\"\"\n        Equivalent to 'node.children.insert(i, child)'. This method also sets\n        the child's parent attribute appropriately.\n        \"\"\"\n        child.parent = self\n        self.children.insert(i, child)\n        self.changed()\n        self.invalidate_sibling_maps()",
        "begin_line": 345,
        "end_line": 353,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0003846153846153846,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Node.append_child#355",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Node",
        "signature": "blib2to3.pytree.Node.append_child(self, child: NL)",
        "snippet": "    def append_child(self, child: NL) -> None:\n        \"\"\"\n        Equivalent to 'node.children.append(child)'. This method also sets the\n        child's parent attribute appropriately.\n        \"\"\"\n        child.parent = self\n        self.children.append(child)\n        self.changed()\n        self.invalidate_sibling_maps()",
        "begin_line": 355,
        "end_line": 363,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0005659309564233164,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Node.invalidate_sibling_maps#365",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Node",
        "signature": "blib2to3.pytree.Node.invalidate_sibling_maps(self)",
        "snippet": "    def invalidate_sibling_maps(self) -> None:\n        self.prev_sibling_map: Optional[Dict[int, Optional[NL]]] = None\n        self.next_sibling_map: Optional[Dict[int, Optional[NL]]] = None",
        "begin_line": 365,
        "end_line": 367,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00030175015087507544,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Node.update_sibling_maps#369",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Node",
        "signature": "blib2to3.pytree.Node.update_sibling_maps(self)",
        "snippet": "    def update_sibling_maps(self) -> None:\n        _prev: Dict[int, Optional[NL]] = {}\n        _next: Dict[int, Optional[NL]] = {}\n        self.prev_sibling_map = _prev\n        self.next_sibling_map = _next\n        previous: Optional[NL] = None\n        for current in self.children:\n            _prev[id(current)] = previous\n            _next[id(previous)] = current\n            previous = current\n        _next[id(current)] = None",
        "begin_line": 369,
        "end_line": 379,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00033955857385398983,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Leaf.__init__#396",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Leaf",
        "signature": "blib2to3.pytree.Leaf.__init__(self, type: int, value: Text, context: Optional[Context]=None, prefix: Optional[Text]=None, fixers_applied: List[Any]=[])",
        "snippet": "    def __init__(\n        self,\n        type: int,\n        value: Text,\n        context: Optional[Context] = None,\n        prefix: Optional[Text] = None,\n        fixers_applied: List[Any] = [],\n    ) -> None:\n        \"\"\"\n        Initializer.\n\n        Takes a type constant (a token number < 256), a string value, and an\n        optional context keyword argument.\n        \"\"\"\n\n        assert 0 <= type < 256, type\n        if context is not None:\n            self._prefix, (self.lineno, self.column) = context\n        self.type = type\n        self.value = value\n        if prefix is not None:\n            self._prefix = prefix\n        self.fixers_applied: Optional[List[Any]] = fixers_applied[:]\n        self.children = []",
        "begin_line": 396,
        "end_line": 419,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00040816326530612246,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Leaf.__str__#432",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Leaf",
        "signature": "blib2to3.pytree.Leaf.__str__(self)",
        "snippet": "    def __str__(self) -> Text:\n        \"\"\"\n        Return a pretty string representation.\n\n        This reproduces the input source exactly.\n        \"\"\"\n        return self.prefix + str(self.value)",
        "begin_line": 432,
        "end_line": 438,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0003549875754348598,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Leaf._eq#440",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Leaf",
        "signature": "blib2to3.pytree.Leaf._eq(self, other)",
        "snippet": "    def _eq(self, other) -> bool:\n        \"\"\"Compare two nodes for equality.\"\"\"\n        return (self.type, self.value) == (other.type, other.value)",
        "begin_line": 440,
        "end_line": 442,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0005399568034557236,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Leaf.leaves#454",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Leaf",
        "signature": "blib2to3.pytree.Leaf.leaves(self)",
        "snippet": "    def leaves(self) -> Iterator[\"Leaf\"]:\n        yield self",
        "begin_line": 454,
        "end_line": 455,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00032331070158422246,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Leaf.pre_order#461",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Leaf",
        "signature": "blib2to3.pytree.Leaf.pre_order(self)",
        "snippet": "    def pre_order(self) -> Iterator[\"Leaf\"]:\n        \"\"\"Return a pre-order iterator for the tree.\"\"\"\n        yield self",
        "begin_line": 461,
        "end_line": 463,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0003624501631025734,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Leaf.prefix#466",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Leaf",
        "signature": "blib2to3.pytree.Leaf.prefix(self)",
        "snippet": "    def prefix(self) -> Text:\n        \"\"\"\n        The whitespace and comments preceding this token in the input.\n        \"\"\"\n        return self._prefix",
        "begin_line": 466,
        "end_line": 470,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.0003167564143173899,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.Leaf.prefix#473",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree.Leaf",
        "signature": "blib2to3.pytree.Leaf.prefix(self, prefix)",
        "snippet": "    def prefix(self, prefix) -> None:\n        self.changed()\n        self._prefix = prefix",
        "begin_line": 473,
        "end_line": 475,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00032331070158422246,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    },
    {
        "name": "blib2to3.pytree.convert#478",
        "src_path": "blib2to3/pytree.py",
        "class_name": "blib2to3.pytree",
        "signature": "blib2to3.pytree.convert(gr: Grammar, raw_node: RawNode)",
        "snippet": "def convert(gr: Grammar, raw_node: RawNode) -> NL:\n    \"\"\"\n    Convert raw node information to a Node or Leaf instance.\n\n    This is passed to the parser driver which calls it whenever a reduction of a\n    grammar rule produces a new complete node, so that the tree is build\n    strictly bottom-up.\n    \"\"\"\n    type, value, context, children = raw_node\n    if children or type in gr.number2symbol:\n        # If there's exactly one child, return that child instead of\n        # creating a new node.\n        assert children is not None\n        if len(children) == 1:\n            return children[0]\n        return Node(type, children, context=context)\n    else:\n        return Leaf(type, value or \"\", context=context)",
        "begin_line": 478,
        "end_line": 495,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005711022272986865,
            "pseudo_dstar_susp": 0.0005711022272986865,
            "pseudo_tarantula_susp": 0.0005711022272986865,
            "pseudo_op2_susp": 0.00031152647975077883,
            "pseudo_barinel_susp": 0.0005711022272986865
        }
    }
]