[
    {
        "name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_per_axis_per_level_getitem#14",
        "src_path": "pandas/tests/indexing/multiindex/test_slice.py",
        "class_name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers",
        "signature": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_per_axis_per_level_getitem(self)",
        "snippet": "    def test_per_axis_per_level_getitem(self):\n\n        # GH6134\n        # example test case\n        ix = MultiIndex.from_product(\n            [_mklbl(\"A\", 5), _mklbl(\"B\", 7), _mklbl(\"C\", 4), _mklbl(\"D\", 2)]\n        )\n        df = DataFrame(np.arange(len(ix.to_numpy())), index=ix)\n\n        result = df.loc[(slice(\"A1\", \"A3\"), slice(None), [\"C1\", \"C3\"]), :]\n        expected = df.loc[\n            [\n                tuple([a, b, c, d])\n                for a, b, c, d in df.index.values\n                if (a == \"A1\" or a == \"A2\" or a == \"A3\") and (c == \"C1\" or c == \"C3\")\n            ]\n        ]\n        tm.assert_frame_equal(result, expected)\n\n        expected = df.loc[\n            [\n                tuple([a, b, c, d])\n                for a, b, c, d in df.index.values\n                if (a == \"A1\" or a == \"A2\" or a == \"A3\")\n                and (c == \"C1\" or c == \"C2\" or c == \"C3\")\n            ]\n        ]\n        result = df.loc[(slice(\"A1\", \"A3\"), slice(None), slice(\"C1\", \"C3\")), :]\n        tm.assert_frame_equal(result, expected)\n\n        # test multi-index slicing with per axis and per index controls\n        index = MultiIndex.from_tuples(\n            [(\"A\", 1), (\"A\", 2), (\"A\", 3), (\"B\", 1)], names=[\"one\", \"two\"]\n        )\n        columns = MultiIndex.from_tuples(\n            [(\"a\", \"foo\"), (\"a\", \"bar\"), (\"b\", \"foo\"), (\"b\", \"bah\")],\n            names=[\"lvl0\", \"lvl1\"],\n        )\n\n        df = DataFrame(\n            np.arange(16, dtype=\"int64\").reshape(4, 4), index=index, columns=columns\n        )\n        df = df.sort_index(axis=0).sort_index(axis=1)\n\n        # identity\n        result = df.loc[(slice(None), slice(None)), :]\n        tm.assert_frame_equal(result, df)\n        result = df.loc[(slice(None), slice(None)), (slice(None), slice(None))]\n        tm.assert_frame_equal(result, df)\n        result = df.loc[:, (slice(None), slice(None))]\n        tm.assert_frame_equal(result, df)\n\n        # index\n        result = df.loc[(slice(None), [1]), :]\n        expected = df.iloc[[0, 3]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[(slice(None), 1), :]\n        expected = df.iloc[[0, 3]]\n        tm.assert_frame_equal(result, expected)\n\n        # columns\n        result = df.loc[:, (slice(None), [\"foo\"])]\n        expected = df.iloc[:, [1, 3]]\n        tm.assert_frame_equal(result, expected)\n\n        # both\n        result = df.loc[(slice(None), 1), (slice(None), [\"foo\"])]\n        expected = df.iloc[[0, 3], [1, 3]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[\"A\", \"a\"]\n        expected = DataFrame(\n            dict(bar=[1, 5, 9], foo=[0, 4, 8]),\n            index=Index([1, 2, 3], name=\"two\"),\n            columns=Index([\"bar\", \"foo\"], name=\"lvl1\"),\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[(slice(None), [1, 2]), :]\n        expected = df.iloc[[0, 1, 3]]\n        tm.assert_frame_equal(result, expected)\n\n        # multi-level series\n        s = Series(np.arange(len(ix.to_numpy())), index=ix)\n        result = s.loc[\"A1\":\"A3\", :, [\"C1\", \"C3\"]]\n        expected = s.loc[\n            [\n                tuple([a, b, c, d])\n                for a, b, c, d in s.index.values\n                if (a == \"A1\" or a == \"A2\" or a == \"A3\") and (c == \"C1\" or c == \"C3\")\n            ]\n        ]\n        tm.assert_series_equal(result, expected)\n\n        # boolean indexers\n        result = df.loc[(slice(None), df.loc[:, (\"a\", \"bar\")] > 5), :]\n        expected = df.iloc[[2, 3]]\n        tm.assert_frame_equal(result, expected)\n\n        msg = (\n            \"cannot index with a boolean indexer \"\n            \"that is not the same length as the index\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            df.loc[(slice(None), np.array([True, False])), :]\n\n        with pytest.raises(KeyError, match=r\"\\[1\\] not in index\"):\n            # slice(None) is on the index, [1] is on the columns, but 1 is\n            #  not in the columns, so we raise\n            #  This used to treat [1] as positional GH#16396\n            df.loc[slice(None), [1]]\n\n        result = df.loc[(slice(None), [1]), :]\n        expected = df.iloc[[0, 3]]\n        tm.assert_frame_equal(result, expected)\n\n        # not lexsorted\n        assert df.index.lexsort_depth == 2\n        df = df.sort_index(level=1, axis=0)\n        assert df.index.lexsort_depth == 0\n\n        msg = (\n            \"MultiIndex slicing requires the index to be \"\n            r\"lexsorted: slicing on levels \\[1\\], lexsort depth 0\"\n        )\n        with pytest.raises(UnsortedIndexError, match=msg):\n            df.loc[(slice(None), slice(\"bar\")), :]\n\n        # GH 16734: not sorted, but no real slicing\n        result = df.loc[(slice(None), df.loc[:, (\"a\", \"bar\")] > 5), :]\n        tm.assert_frame_equal(result, df.iloc[[1, 3], :])",
        "begin_line": 14,
        "end_line": 145,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_multiindex_slicers_non_unique#147",
        "src_path": "pandas/tests/indexing/multiindex/test_slice.py",
        "class_name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers",
        "signature": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_multiindex_slicers_non_unique(self)",
        "snippet": "    def test_multiindex_slicers_non_unique(self):\n\n        # GH 7106\n        # non-unique mi index support\n        df = (\n            DataFrame(\n                dict(\n                    A=[\"foo\", \"foo\", \"foo\", \"foo\"],\n                    B=[\"a\", \"a\", \"a\", \"a\"],\n                    C=[1, 2, 1, 3],\n                    D=[1, 2, 3, 4],\n                )\n            )\n            .set_index([\"A\", \"B\", \"C\"])\n            .sort_index()\n        )\n        assert not df.index.is_unique\n        expected = (\n            DataFrame(dict(A=[\"foo\", \"foo\"], B=[\"a\", \"a\"], C=[1, 1], D=[1, 3]))\n            .set_index([\"A\", \"B\", \"C\"])\n            .sort_index()\n        )\n        result = df.loc[(slice(None), slice(None), 1), :]\n        tm.assert_frame_equal(result, expected)\n\n        # this is equivalent of an xs expression\n        result = df.xs(1, level=2, drop_level=False)\n        tm.assert_frame_equal(result, expected)\n\n        df = (\n            DataFrame(\n                dict(\n                    A=[\"foo\", \"foo\", \"foo\", \"foo\"],\n                    B=[\"a\", \"a\", \"a\", \"a\"],\n                    C=[1, 2, 1, 2],\n                    D=[1, 2, 3, 4],\n                )\n            )\n            .set_index([\"A\", \"B\", \"C\"])\n            .sort_index()\n        )\n        assert not df.index.is_unique\n        expected = (\n            DataFrame(dict(A=[\"foo\", \"foo\"], B=[\"a\", \"a\"], C=[1, 1], D=[1, 3]))\n            .set_index([\"A\", \"B\", \"C\"])\n            .sort_index()\n        )\n        result = df.loc[(slice(None), slice(None), 1), :]\n        assert not result.index.is_unique\n        tm.assert_frame_equal(result, expected)\n\n        # GH12896\n        # numpy-implementation dependent bug\n        ints = [\n            1,\n            2,\n            3,\n            4,\n            5,\n            6,\n            7,\n            8,\n            9,\n            10,\n            11,\n            12,\n            12,\n            13,\n            14,\n            14,\n            16,\n            17,\n            18,\n            19,\n            200000,\n            200000,\n        ]\n        n = len(ints)\n        idx = MultiIndex.from_arrays([[\"a\"] * n, ints])\n        result = Series([1] * n, index=idx)\n        result = result.sort_index()\n        result = result.loc[(slice(None), slice(100000))]\n        expected = Series([1] * (n - 2), index=idx[:-2]).sort_index()\n        tm.assert_series_equal(result, expected)",
        "begin_line": 147,
        "end_line": 230,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_multiindex_slicers_datetimelike#232",
        "src_path": "pandas/tests/indexing/multiindex/test_slice.py",
        "class_name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers",
        "signature": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_multiindex_slicers_datetimelike(self)",
        "snippet": "    def test_multiindex_slicers_datetimelike(self):\n\n        # GH 7429\n        # buggy/inconsistent behavior when slicing with datetime-like\n        import datetime\n\n        dates = [\n            datetime.datetime(2012, 1, 1, 12, 12, 12) + datetime.timedelta(days=i)\n            for i in range(6)\n        ]\n        freq = [1, 2]\n        index = MultiIndex.from_product([dates, freq], names=[\"date\", \"frequency\"])\n\n        df = DataFrame(\n            np.arange(6 * 2 * 4, dtype=\"int64\").reshape(-1, 4),\n            index=index,\n            columns=list(\"ABCD\"),\n        )\n\n        # multi-axis slicing\n        idx = pd.IndexSlice\n        expected = df.iloc[[0, 2, 4], [0, 1]]\n        result = df.loc[\n            (\n                slice(\n                    Timestamp(\"2012-01-01 12:12:12\"), Timestamp(\"2012-01-03 12:12:12\")\n                ),\n                slice(1, 1),\n            ),\n            slice(\"A\", \"B\"),\n        ]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[\n            (\n                idx[\n                    Timestamp(\"2012-01-01 12:12:12\") : Timestamp(\"2012-01-03 12:12:12\")\n                ],\n                idx[1:1],\n            ),\n            slice(\"A\", \"B\"),\n        ]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[\n            (\n                slice(\n                    Timestamp(\"2012-01-01 12:12:12\"), Timestamp(\"2012-01-03 12:12:12\")\n                ),\n                1,\n            ),\n            slice(\"A\", \"B\"),\n        ]\n        tm.assert_frame_equal(result, expected)\n\n        # with strings\n        result = df.loc[\n            (slice(\"2012-01-01 12:12:12\", \"2012-01-03 12:12:12\"), slice(1, 1)),\n            slice(\"A\", \"B\"),\n        ]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[\n            (idx[\"2012-01-01 12:12:12\":\"2012-01-03 12:12:12\"], 1), idx[\"A\", \"B\"]\n        ]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 232,
        "end_line": 297,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_multiindex_slicers_edges#299",
        "src_path": "pandas/tests/indexing/multiindex/test_slice.py",
        "class_name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers",
        "signature": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_multiindex_slicers_edges(self)",
        "snippet": "    def test_multiindex_slicers_edges(self):\n        # GH 8132\n        # various edge cases\n        df = DataFrame(\n            {\n                \"A\": [\"A0\"] * 5 + [\"A1\"] * 5 + [\"A2\"] * 5,\n                \"B\": [\"B0\", \"B0\", \"B1\", \"B1\", \"B2\"] * 3,\n                \"DATE\": [\n                    \"2013-06-11\",\n                    \"2013-07-02\",\n                    \"2013-07-09\",\n                    \"2013-07-30\",\n                    \"2013-08-06\",\n                    \"2013-06-11\",\n                    \"2013-07-02\",\n                    \"2013-07-09\",\n                    \"2013-07-30\",\n                    \"2013-08-06\",\n                    \"2013-09-03\",\n                    \"2013-10-01\",\n                    \"2013-07-09\",\n                    \"2013-08-06\",\n                    \"2013-09-03\",\n                ],\n                \"VALUES\": [22, 35, 14, 9, 4, 40, 18, 4, 2, 5, 1, 2, 3, 4, 2],\n            }\n        )\n\n        df[\"DATE\"] = pd.to_datetime(df[\"DATE\"])\n        df1 = df.set_index([\"A\", \"B\", \"DATE\"])\n        df1 = df1.sort_index()\n\n        # A1 - Get all values under \"A0\" and \"A1\"\n        result = df1.loc[(slice(\"A1\")), :]\n        expected = df1.iloc[0:10]\n        tm.assert_frame_equal(result, expected)\n\n        # A2 - Get all values from the start to \"A2\"\n        result = df1.loc[(slice(\"A2\")), :]\n        expected = df1\n        tm.assert_frame_equal(result, expected)\n\n        # A3 - Get all values under \"B1\" or \"B2\"\n        result = df1.loc[(slice(None), slice(\"B1\", \"B2\")), :]\n        expected = df1.iloc[[2, 3, 4, 7, 8, 9, 12, 13, 14]]\n        tm.assert_frame_equal(result, expected)\n\n        # A4 - Get all values between 2013-07-02 and 2013-07-09\n        result = df1.loc[(slice(None), slice(None), slice(\"20130702\", \"20130709\")), :]\n        expected = df1.iloc[[1, 2, 6, 7, 12]]\n        tm.assert_frame_equal(result, expected)\n\n        # B1 - Get all values in B0 that are also under A0, A1 and A2\n        result = df1.loc[(slice(\"A2\"), slice(\"B0\")), :]\n        expected = df1.iloc[[0, 1, 5, 6, 10, 11]]\n        tm.assert_frame_equal(result, expected)\n\n        # B2 - Get all values in B0, B1 and B2 (similar to what #2 is doing for\n        # the As)\n        result = df1.loc[(slice(None), slice(\"B2\")), :]\n        expected = df1\n        tm.assert_frame_equal(result, expected)\n\n        # B3 - Get all values from B1 to B2 and up to 2013-08-06\n        result = df1.loc[(slice(None), slice(\"B1\", \"B2\"), slice(\"2013-08-06\")), :]\n        expected = df1.iloc[[2, 3, 4, 7, 8, 9, 12, 13]]\n        tm.assert_frame_equal(result, expected)\n\n        # B4 - Same as A4 but the start of the date slice is not a key.\n        #      shows indexing on a partial selection slice\n        result = df1.loc[(slice(None), slice(None), slice(\"20130701\", \"20130709\")), :]\n        expected = df1.iloc[[1, 2, 6, 7, 12]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 299,
        "end_line": 371,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_per_axis_per_level_doc_examples#373",
        "src_path": "pandas/tests/indexing/multiindex/test_slice.py",
        "class_name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers",
        "signature": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_per_axis_per_level_doc_examples(self)",
        "snippet": "    def test_per_axis_per_level_doc_examples(self):\n\n        # test index maker\n        idx = pd.IndexSlice\n\n        # from indexing.rst / advanced\n        index = MultiIndex.from_product(\n            [_mklbl(\"A\", 4), _mklbl(\"B\", 2), _mklbl(\"C\", 4), _mklbl(\"D\", 2)]\n        )\n        columns = MultiIndex.from_tuples(\n            [(\"a\", \"foo\"), (\"a\", \"bar\"), (\"b\", \"foo\"), (\"b\", \"bah\")],\n            names=[\"lvl0\", \"lvl1\"],\n        )\n        df = DataFrame(\n            np.arange(len(index) * len(columns), dtype=\"int64\").reshape(\n                (len(index), len(columns))\n            ),\n            index=index,\n            columns=columns,\n        )\n        result = df.loc[(slice(\"A1\", \"A3\"), slice(None), [\"C1\", \"C3\"]), :]\n        expected = df.loc[\n            [\n                tuple([a, b, c, d])\n                for a, b, c, d in df.index.values\n                if (a == \"A1\" or a == \"A2\" or a == \"A3\") and (c == \"C1\" or c == \"C3\")\n            ]\n        ]\n        tm.assert_frame_equal(result, expected)\n        result = df.loc[idx[\"A1\":\"A3\", :, [\"C1\", \"C3\"]], :]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[(slice(None), slice(None), [\"C1\", \"C3\"]), :]\n        expected = df.loc[\n            [\n                tuple([a, b, c, d])\n                for a, b, c, d in df.index.values\n                if (c == \"C1\" or c == \"C3\")\n            ]\n        ]\n        tm.assert_frame_equal(result, expected)\n        result = df.loc[idx[:, :, [\"C1\", \"C3\"]], :]\n        tm.assert_frame_equal(result, expected)\n\n        # not sorted\n        msg = (\n            \"MultiIndex slicing requires the index to be lexsorted: \"\n            r\"slicing on levels \\[1\\], lexsort depth 1\"\n        )\n        with pytest.raises(UnsortedIndexError, match=msg):\n            df.loc[\"A1\", (\"a\", slice(\"foo\"))]\n\n        # GH 16734: not sorted, but no real slicing\n        tm.assert_frame_equal(\n            df.loc[\"A1\", (slice(None), \"foo\")], df.loc[\"A1\"].iloc[:, [0, 2]]\n        )\n\n        df = df.sort_index(axis=1)\n\n        # slicing\n        df.loc[\"A1\", (slice(None), \"foo\")]\n        df.loc[(slice(None), slice(None), [\"C1\", \"C3\"]), (slice(None), \"foo\")]\n\n        # setitem\n        df.loc(axis=0)[:, :, [\"C1\", \"C3\"]] = -10",
        "begin_line": 373,
        "end_line": 437,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_loc_axis_arguments#439",
        "src_path": "pandas/tests/indexing/multiindex/test_slice.py",
        "class_name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers",
        "signature": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_loc_axis_arguments(self)",
        "snippet": "    def test_loc_axis_arguments(self):\n\n        index = MultiIndex.from_product(\n            [_mklbl(\"A\", 4), _mklbl(\"B\", 2), _mklbl(\"C\", 4), _mklbl(\"D\", 2)]\n        )\n        columns = MultiIndex.from_tuples(\n            [(\"a\", \"foo\"), (\"a\", \"bar\"), (\"b\", \"foo\"), (\"b\", \"bah\")],\n            names=[\"lvl0\", \"lvl1\"],\n        )\n        df = (\n            DataFrame(\n                np.arange(len(index) * len(columns), dtype=\"int64\").reshape(\n                    (len(index), len(columns))\n                ),\n                index=index,\n                columns=columns,\n            )\n            .sort_index()\n            .sort_index(axis=1)\n        )\n\n        # axis 0\n        result = df.loc(axis=0)[\"A1\":\"A3\", :, [\"C1\", \"C3\"]]\n        expected = df.loc[\n            [\n                tuple([a, b, c, d])\n                for a, b, c, d in df.index.values\n                if (a == \"A1\" or a == \"A2\" or a == \"A3\") and (c == \"C1\" or c == \"C3\")\n            ]\n        ]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc(axis=\"index\")[:, :, [\"C1\", \"C3\"]]\n        expected = df.loc[\n            [\n                tuple([a, b, c, d])\n                for a, b, c, d in df.index.values\n                if (c == \"C1\" or c == \"C3\")\n            ]\n        ]\n        tm.assert_frame_equal(result, expected)\n\n        # axis 1\n        result = df.loc(axis=1)[:, \"foo\"]\n        expected = df.loc[:, (slice(None), \"foo\")]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc(axis=\"columns\")[:, \"foo\"]\n        expected = df.loc[:, (slice(None), \"foo\")]\n        tm.assert_frame_equal(result, expected)\n\n        # invalid axis\n        for i in [-1, 2, \"foo\"]:\n            msg = f\"No axis named {i} for object type DataFrame\"\n            with pytest.raises(ValueError, match=msg):\n                df.loc(axis=i)[:, :, [\"C1\", \"C3\"]]",
        "begin_line": 439,
        "end_line": 494,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_loc_axis_single_level_multi_col_indexing_multiindex_col_df#496",
        "src_path": "pandas/tests/indexing/multiindex/test_slice.py",
        "class_name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers",
        "signature": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_loc_axis_single_level_multi_col_indexing_multiindex_col_df(self)",
        "snippet": "    def test_loc_axis_single_level_multi_col_indexing_multiindex_col_df(self):\n\n        # GH29519\n        df = pd.DataFrame(\n            np.arange(27).reshape(3, 9),\n            columns=pd.MultiIndex.from_product(\n                [[\"a1\", \"a2\", \"a3\"], [\"b1\", \"b2\", \"b3\"]]\n            ),\n        )\n        result = df.loc(axis=1)[\"a1\":\"a2\"]\n        expected = df.iloc[:, :-3]\n\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 496,
        "end_line": 508,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_loc_axis_single_level_single_col_indexing_multiindex_col_df#510",
        "src_path": "pandas/tests/indexing/multiindex/test_slice.py",
        "class_name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers",
        "signature": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_loc_axis_single_level_single_col_indexing_multiindex_col_df(self)",
        "snippet": "    def test_loc_axis_single_level_single_col_indexing_multiindex_col_df(self):\n\n        # GH29519\n        df = pd.DataFrame(\n            np.arange(27).reshape(3, 9),\n            columns=pd.MultiIndex.from_product(\n                [[\"a1\", \"a2\", \"a3\"], [\"b1\", \"b2\", \"b3\"]]\n            ),\n        )\n        result = df.loc(axis=1)[\"a1\"]\n        expected = df.iloc[:, :3]\n        expected.columns = [\"b1\", \"b2\", \"b3\"]\n\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 510,
        "end_line": 523,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_loc_ax_single_level_indexer_simple_df#525",
        "src_path": "pandas/tests/indexing/multiindex/test_slice.py",
        "class_name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers",
        "signature": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_loc_ax_single_level_indexer_simple_df(self)",
        "snippet": "    def test_loc_ax_single_level_indexer_simple_df(self):\n\n        # GH29519\n        # test single level indexing on single index column data frame\n        df = pd.DataFrame(np.arange(9).reshape(3, 3), columns=[\"a\", \"b\", \"c\"])\n        result = df.loc(axis=1)[\"a\"]\n        expected = pd.Series(np.array([0, 3, 6]), name=\"a\")\n        tm.assert_series_equal(result, expected)",
        "begin_line": 525,
        "end_line": 532,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_per_axis_per_level_setitem#534",
        "src_path": "pandas/tests/indexing/multiindex/test_slice.py",
        "class_name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers",
        "signature": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_per_axis_per_level_setitem(self)",
        "snippet": "    def test_per_axis_per_level_setitem(self):\n\n        # test index maker\n        idx = pd.IndexSlice\n\n        # test multi-index slicing with per axis and per index controls\n        index = MultiIndex.from_tuples(\n            [(\"A\", 1), (\"A\", 2), (\"A\", 3), (\"B\", 1)], names=[\"one\", \"two\"]\n        )\n        columns = MultiIndex.from_tuples(\n            [(\"a\", \"foo\"), (\"a\", \"bar\"), (\"b\", \"foo\"), (\"b\", \"bah\")],\n            names=[\"lvl0\", \"lvl1\"],\n        )\n\n        df_orig = DataFrame(\n            np.arange(16, dtype=\"int64\").reshape(4, 4), index=index, columns=columns\n        )\n        df_orig = df_orig.sort_index(axis=0).sort_index(axis=1)\n\n        # identity\n        df = df_orig.copy()\n        df.loc[(slice(None), slice(None)), :] = 100\n        expected = df_orig.copy()\n        expected.iloc[:, :] = 100\n        tm.assert_frame_equal(df, expected)\n\n        df = df_orig.copy()\n        df.loc(axis=0)[:, :] = 100\n        expected = df_orig.copy()\n        expected.iloc[:, :] = 100\n        tm.assert_frame_equal(df, expected)\n\n        df = df_orig.copy()\n        df.loc[(slice(None), slice(None)), (slice(None), slice(None))] = 100\n        expected = df_orig.copy()\n        expected.iloc[:, :] = 100\n        tm.assert_frame_equal(df, expected)\n\n        df = df_orig.copy()\n        df.loc[:, (slice(None), slice(None))] = 100\n        expected = df_orig.copy()\n        expected.iloc[:, :] = 100\n        tm.assert_frame_equal(df, expected)\n\n        # index\n        df = df_orig.copy()\n        df.loc[(slice(None), [1]), :] = 100\n        expected = df_orig.copy()\n        expected.iloc[[0, 3]] = 100\n        tm.assert_frame_equal(df, expected)\n\n        df = df_orig.copy()\n        df.loc[(slice(None), 1), :] = 100\n        expected = df_orig.copy()\n        expected.iloc[[0, 3]] = 100\n        tm.assert_frame_equal(df, expected)\n\n        df = df_orig.copy()\n        df.loc(axis=0)[:, 1] = 100\n        expected = df_orig.copy()\n        expected.iloc[[0, 3]] = 100\n        tm.assert_frame_equal(df, expected)\n\n        # columns\n        df = df_orig.copy()\n        df.loc[:, (slice(None), [\"foo\"])] = 100\n        expected = df_orig.copy()\n        expected.iloc[:, [1, 3]] = 100\n        tm.assert_frame_equal(df, expected)\n\n        # both\n        df = df_orig.copy()\n        df.loc[(slice(None), 1), (slice(None), [\"foo\"])] = 100\n        expected = df_orig.copy()\n        expected.iloc[[0, 3], [1, 3]] = 100\n        tm.assert_frame_equal(df, expected)\n\n        df = df_orig.copy()\n        df.loc[idx[:, 1], idx[:, [\"foo\"]]] = 100\n        expected = df_orig.copy()\n        expected.iloc[[0, 3], [1, 3]] = 100\n        tm.assert_frame_equal(df, expected)\n\n        df = df_orig.copy()\n        df.loc[\"A\", \"a\"] = 100\n        expected = df_orig.copy()\n        expected.iloc[0:3, 0:2] = 100\n        tm.assert_frame_equal(df, expected)\n\n        # setting with a list-like\n        df = df_orig.copy()\n        df.loc[(slice(None), 1), (slice(None), [\"foo\"])] = np.array(\n            [[100, 100], [100, 100]], dtype=\"int64\"\n        )\n        expected = df_orig.copy()\n        expected.iloc[[0, 3], [1, 3]] = 100\n        tm.assert_frame_equal(df, expected)\n\n        # not enough values\n        df = df_orig.copy()\n\n        msg = \"setting an array element with a sequence.\"\n        with pytest.raises(ValueError, match=msg):\n            df.loc[(slice(None), 1), (slice(None), [\"foo\"])] = np.array(\n                [[100], [100, 100]], dtype=\"int64\"\n            )\n\n        msg = \"Must have equal len keys and value when setting with an iterable\"\n        with pytest.raises(ValueError, match=msg):\n            df.loc[(slice(None), 1), (slice(None), [\"foo\"])] = np.array(\n                [100, 100, 100, 100], dtype=\"int64\"\n            )\n\n        # with an alignable rhs\n        df = df_orig.copy()\n        df.loc[(slice(None), 1), (slice(None), [\"foo\"])] = (\n            df.loc[(slice(None), 1), (slice(None), [\"foo\"])] * 5\n        )\n        expected = df_orig.copy()\n        expected.iloc[[0, 3], [1, 3]] = expected.iloc[[0, 3], [1, 3]] * 5\n        tm.assert_frame_equal(df, expected)\n\n        df = df_orig.copy()\n        df.loc[(slice(None), 1), (slice(None), [\"foo\"])] *= df.loc[\n            (slice(None), 1), (slice(None), [\"foo\"])\n        ]\n        expected = df_orig.copy()\n        expected.iloc[[0, 3], [1, 3]] *= expected.iloc[[0, 3], [1, 3]]\n        tm.assert_frame_equal(df, expected)\n\n        rhs = df_orig.loc[(slice(None), 1), (slice(None), [\"foo\"])].copy()\n        rhs.loc[:, (\"c\", \"bah\")] = 10\n        df = df_orig.copy()\n        df.loc[(slice(None), 1), (slice(None), [\"foo\"])] *= rhs\n        expected = df_orig.copy()\n        expected.iloc[[0, 3], [1, 3]] *= expected.iloc[[0, 3], [1, 3]]\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 534,
        "end_line": 670,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_multiindex_label_slicing_with_negative_step#672",
        "src_path": "pandas/tests/indexing/multiindex/test_slice.py",
        "class_name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers",
        "signature": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_multiindex_label_slicing_with_negative_step(self)",
        "snippet": "    def test_multiindex_label_slicing_with_negative_step(self):\n        s = Series(\n            np.arange(20), MultiIndex.from_product([list(\"abcde\"), np.arange(4)])\n        )\n        SLC = pd.IndexSlice\n\n        def assert_slices_equivalent(l_slc, i_slc):\n            tm.assert_series_equal(s.loc[l_slc], s.iloc[i_slc])\n            tm.assert_series_equal(s[l_slc], s.iloc[i_slc])\n\n        assert_slices_equivalent(SLC[::-1], SLC[::-1])\n\n        assert_slices_equivalent(SLC[\"d\"::-1], SLC[15::-1])\n        assert_slices_equivalent(SLC[(\"d\",)::-1], SLC[15::-1])\n\n        assert_slices_equivalent(SLC[:\"d\":-1], SLC[:11:-1])\n        assert_slices_equivalent(SLC[:(\"d\",):-1], SLC[:11:-1])\n\n        assert_slices_equivalent(SLC[\"d\":\"b\":-1], SLC[15:3:-1])\n        assert_slices_equivalent(SLC[(\"d\",):\"b\":-1], SLC[15:3:-1])\n        assert_slices_equivalent(SLC[\"d\":(\"b\",):-1], SLC[15:3:-1])\n        assert_slices_equivalent(SLC[(\"d\",):(\"b\",):-1], SLC[15:3:-1])\n        assert_slices_equivalent(SLC[\"b\":\"d\":-1], SLC[:0])\n\n        assert_slices_equivalent(SLC[(\"c\", 2)::-1], SLC[10::-1])\n        assert_slices_equivalent(SLC[:(\"c\", 2):-1], SLC[:9:-1])\n        assert_slices_equivalent(SLC[(\"e\", 0):(\"c\", 2):-1], SLC[16:9:-1])",
        "begin_line": 672,
        "end_line": 698,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.assert_slices_equivalent#678",
        "src_path": "pandas/tests/indexing/multiindex/test_slice.py",
        "class_name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers",
        "signature": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.assert_slices_equivalent(l_slc, i_slc)",
        "snippet": "        def assert_slices_equivalent(l_slc, i_slc):\n            tm.assert_series_equal(s.loc[l_slc], s.iloc[i_slc])\n            tm.assert_series_equal(s[l_slc], s.iloc[i_slc])",
        "begin_line": 678,
        "end_line": 680,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_multiindex_slice_first_level#700",
        "src_path": "pandas/tests/indexing/multiindex/test_slice.py",
        "class_name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers",
        "signature": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_multiindex_slice_first_level(self)",
        "snippet": "    def test_multiindex_slice_first_level(self):\n        # GH 12697\n        freq = [\"a\", \"b\", \"c\", \"d\"]\n        idx = MultiIndex.from_product([freq, np.arange(500)])\n        df = DataFrame(list(range(2000)), index=idx, columns=[\"Test\"])\n        df_slice = df.loc[pd.IndexSlice[:, 30:70], :]\n        result = df_slice.loc[\"a\"]\n        expected = DataFrame(list(range(30, 71)), columns=[\"Test\"], index=range(30, 71))\n        tm.assert_frame_equal(result, expected)\n        result = df_slice.loc[\"d\"]\n        expected = DataFrame(\n            list(range(1530, 1571)), columns=[\"Test\"], index=range(30, 71)\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 700,
        "end_line": 713,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_int_series_slicing#715",
        "src_path": "pandas/tests/indexing/multiindex/test_slice.py",
        "class_name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers",
        "signature": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_int_series_slicing(self, multiindex_year_month_day_dataframe_random_data)",
        "snippet": "    def test_int_series_slicing(self, multiindex_year_month_day_dataframe_random_data):\n        ymd = multiindex_year_month_day_dataframe_random_data\n        s = ymd[\"A\"]\n        result = s[5:]\n        expected = s.reindex(s.index[5:])\n        tm.assert_series_equal(result, expected)\n\n        exp = ymd[\"A\"].copy()\n        s[5:] = 0\n        exp.values[5:] = 0\n        tm.assert_numpy_array_equal(s.values, exp.values)\n\n        result = ymd[5:]\n        expected = ymd.reindex(s.index[5:])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 715,
        "end_line": 729,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_non_reducing_slice_on_multiindex#731",
        "src_path": "pandas/tests/indexing/multiindex/test_slice.py",
        "class_name": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers",
        "signature": "pandas.tests.indexing.multiindex.test_slice.TestMultiIndexSlicers.test_non_reducing_slice_on_multiindex(self)",
        "snippet": "    def test_non_reducing_slice_on_multiindex(self):\n        # GH 19861\n        dic = {\n            (\"a\", \"d\"): [1, 4],\n            (\"a\", \"c\"): [2, 3],\n            (\"b\", \"c\"): [3, 2],\n            (\"b\", \"d\"): [4, 1],\n        }\n        df = pd.DataFrame(dic, index=[0, 1])\n        idx = pd.IndexSlice\n        slice_ = idx[:, idx[\"b\", \"d\"]]\n        tslice_ = _non_reducing_slice(slice_)\n\n        result = df.loc[tslice_]\n        expected = pd.DataFrame({(\"b\", \"d\"): [4, 1]})\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 731,
        "end_line": 746,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.conftest.string_series#7",
        "src_path": "pandas/tests/series/conftest.py",
        "class_name": "pandas.tests.series.conftest",
        "signature": "pandas.tests.series.conftest.string_series()",
        "snippet": "def string_series():\n    \"\"\"\n    Fixture for Series of floats with Index of unique strings\n    \"\"\"\n    s = tm.makeStringSeries()\n    s.name = \"series\"\n    return s",
        "begin_line": 7,
        "end_line": 13,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.conftest.object_series#17",
        "src_path": "pandas/tests/series/conftest.py",
        "class_name": "pandas.tests.series.conftest",
        "signature": "pandas.tests.series.conftest.object_series()",
        "snippet": "def object_series():\n    \"\"\"\n    Fixture for Series of dtype object with Index of unique strings\n    \"\"\"\n    s = tm.makeObjectSeries()\n    s.name = \"objects\"\n    return s",
        "begin_line": 17,
        "end_line": 23,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.single_level_multiindex#11",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.single_level_multiindex()",
        "snippet": "def single_level_multiindex():\n    \"\"\"single level MultiIndex\"\"\"\n    return MultiIndex(\n        levels=[[\"foo\", \"bar\", \"baz\", \"qux\"]], codes=[[0, 1, 2, 3]], names=[\"first\"]\n    )",
        "begin_line": 11,
        "end_line": 15,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.frame_random_data_integer_multi_index#19",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.frame_random_data_integer_multi_index()",
        "snippet": "def frame_random_data_integer_multi_index():\n    levels = [[0, 1], [0, 1, 2]]\n    codes = [[0, 0, 0, 1, 1, 1], [0, 1, 2, 0, 1, 2]]\n    index = MultiIndex(levels=levels, codes=codes)\n    return DataFrame(np.random.randn(6, 2), index=index)",
        "begin_line": 19,
        "end_line": 23,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_getitem_series#27",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_getitem_series(self)",
        "snippet": "    def test_loc_getitem_series(self):\n        # GH14730\n        # passing a series as a key with a MultiIndex\n        index = MultiIndex.from_product([[1, 2, 3], [\"A\", \"B\", \"C\"]])\n        x = Series(index=index, data=range(9), dtype=np.float64)\n        y = Series([1, 3])\n        expected = Series(\n            data=[0, 1, 2, 6, 7, 8],\n            index=MultiIndex.from_product([[1, 3], [\"A\", \"B\", \"C\"]]),\n            dtype=np.float64,\n        )\n        result = x.loc[y]\n        tm.assert_series_equal(result, expected)\n\n        result = x.loc[[1, 3]]\n        tm.assert_series_equal(result, expected)\n\n        # GH15424\n        y1 = Series([1, 3], index=[1, 2])\n        result = x.loc[y1]\n        tm.assert_series_equal(result, expected)\n\n        empty = Series(data=[], dtype=np.float64)\n        expected = Series(\n            [],\n            index=MultiIndex(levels=index.levels, codes=[[], []], dtype=np.float64),\n            dtype=np.float64,\n        )\n        result = x.loc[empty]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 27,
        "end_line": 56,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_getitem_array#58",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_getitem_array(self)",
        "snippet": "    def test_loc_getitem_array(self):\n        # GH15434\n        # passing an array as a key with a MultiIndex\n        index = MultiIndex.from_product([[1, 2, 3], [\"A\", \"B\", \"C\"]])\n        x = Series(index=index, data=range(9), dtype=np.float64)\n        y = np.array([1, 3])\n        expected = Series(\n            data=[0, 1, 2, 6, 7, 8],\n            index=MultiIndex.from_product([[1, 3], [\"A\", \"B\", \"C\"]]),\n            dtype=np.float64,\n        )\n        result = x.loc[y]\n        tm.assert_series_equal(result, expected)\n\n        # empty array:\n        empty = np.array([])\n        expected = Series(\n            [],\n            index=MultiIndex(levels=index.levels, codes=[[], []], dtype=np.float64),\n            dtype=\"float64\",\n        )\n        result = x.loc[empty]\n        tm.assert_series_equal(result, expected)\n\n        # 0-dim array (scalar):\n        scalar = np.int64(1)\n        expected = Series(data=[0, 1, 2], index=[\"A\", \"B\", \"C\"], dtype=np.float64)\n        result = x.loc[scalar]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 58,
        "end_line": 86,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_multiindex_labels#88",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_multiindex_labels(self)",
        "snippet": "    def test_loc_multiindex_labels(self):\n        df = DataFrame(\n            np.random.randn(3, 3),\n            columns=[[\"i\", \"i\", \"j\"], [\"A\", \"A\", \"B\"]],\n            index=[[\"i\", \"i\", \"j\"], [\"X\", \"X\", \"Y\"]],\n        )\n\n        # the first 2 rows\n        expected = df.iloc[[0, 1]].droplevel(0)\n        result = df.loc[\"i\"]\n        tm.assert_frame_equal(result, expected)\n\n        # 2nd (last) column\n        expected = df.iloc[:, [2]].droplevel(0, axis=1)\n        result = df.loc[:, \"j\"]\n        tm.assert_frame_equal(result, expected)\n\n        # bottom right corner\n        expected = df.iloc[[2], [2]].droplevel(0).droplevel(0, axis=1)\n        result = df.loc[\"j\"].loc[:, \"j\"]\n        tm.assert_frame_equal(result, expected)\n\n        # with a tuple\n        expected = df.iloc[[0, 1]]\n        result = df.loc[(\"i\", \"X\")]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 88,
        "end_line": 113,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_multiindex_ints#115",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_multiindex_ints(self)",
        "snippet": "    def test_loc_multiindex_ints(self):\n        df = DataFrame(\n            np.random.randn(3, 3),\n            columns=[[2, 2, 4], [6, 8, 10]],\n            index=[[4, 4, 8], [8, 10, 12]],\n        )\n        expected = df.iloc[[0, 1]].droplevel(0)\n        result = df.loc[4]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 115,
        "end_line": 123,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_multiindex_missing_label_raises#125",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_multiindex_missing_label_raises(self)",
        "snippet": "    def test_loc_multiindex_missing_label_raises(self):\n        df = DataFrame(\n            np.random.randn(3, 3),\n            columns=[[2, 2, 4], [6, 8, 10]],\n            index=[[4, 4, 8], [8, 10, 12]],\n        )\n\n        with pytest.raises(KeyError, match=r\"^2$\"):\n            df.loc[2]",
        "begin_line": 125,
        "end_line": 133,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_multiindex_list_missing_label#136",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_multiindex_list_missing_label(self, key, pos)",
        "snippet": "    def test_loc_multiindex_list_missing_label(self, key, pos):\n        # GH 27148 - lists with missing labels _do_ raise\n        df = DataFrame(\n            np.random.randn(3, 3),\n            columns=[[2, 2, 4], [6, 8, 10]],\n            index=[[4, 4, 8], [8, 10, 12]],\n        )\n\n        with pytest.raises(KeyError, match=\"not in index\"):\n            df.loc[key]",
        "begin_line": 136,
        "end_line": 145,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_multiindex_too_many_dims_raises#147",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_multiindex_too_many_dims_raises(self)",
        "snippet": "    def test_loc_multiindex_too_many_dims_raises(self):\n        # GH 14885\n        s = Series(\n            range(8),\n            index=MultiIndex.from_product([[\"a\", \"b\"], [\"c\", \"d\"], [\"e\", \"f\"]]),\n        )\n\n        with pytest.raises(KeyError, match=r\"^\\('a', 'b'\\)$\"):\n            s.loc[\"a\", \"b\"]\n        with pytest.raises(KeyError, match=r\"^\\('a', 'd', 'g'\\)$\"):\n            s.loc[\"a\", \"d\", \"g\"]\n        with pytest.raises(IndexingError, match=\"Too many indexers\"):\n            s.loc[\"a\", \"d\", \"g\", \"j\"]",
        "begin_line": 147,
        "end_line": 159,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_multiindex_indexer_none#161",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_multiindex_indexer_none(self)",
        "snippet": "    def test_loc_multiindex_indexer_none(self):\n\n        # GH6788\n        # multi-index indexer is None (meaning take all)\n        attributes = [\"Attribute\" + str(i) for i in range(1)]\n        attribute_values = [\"Value\" + str(i) for i in range(5)]\n\n        index = MultiIndex.from_product([attributes, attribute_values])\n        df = 0.1 * np.random.randn(10, 1 * 5) + 0.5\n        df = DataFrame(df, columns=index)\n        result = df[attributes]\n        tm.assert_frame_equal(result, df)\n\n        # GH 7349\n        # loc with a multi-index seems to be doing fallback\n        df = DataFrame(\n            np.arange(12).reshape(-1, 1),\n            index=MultiIndex.from_product([[1, 2, 3, 4], [1, 2, 3]]),\n        )\n\n        expected = df.loc[([1, 2],), :]\n        result = df.loc[[1, 2]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 161,
        "end_line": 183,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_multiindex_incomplete#185",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_multiindex_incomplete(self)",
        "snippet": "    def test_loc_multiindex_incomplete(self):\n\n        # GH 7399\n        # incomplete indexers\n        s = Series(\n            np.arange(15, dtype=\"int64\"),\n            MultiIndex.from_product([range(5), [\"a\", \"b\", \"c\"]]),\n        )\n        expected = s.loc[:, \"a\":\"c\"]\n\n        result = s.loc[0:4, \"a\":\"c\"]\n        tm.assert_series_equal(result, expected)\n        tm.assert_series_equal(result, expected)\n\n        result = s.loc[:4, \"a\":\"c\"]\n        tm.assert_series_equal(result, expected)\n        tm.assert_series_equal(result, expected)\n\n        result = s.loc[0:, \"a\":\"c\"]\n        tm.assert_series_equal(result, expected)\n        tm.assert_series_equal(result, expected)\n\n        # GH 7400\n        # multiindexer gettitem with list of indexers skips wrong element\n        s = Series(\n            np.arange(15, dtype=\"int64\"),\n            MultiIndex.from_product([range(5), [\"a\", \"b\", \"c\"]]),\n        )\n        expected = s.iloc[[6, 7, 8, 12, 13, 14]]\n        result = s.loc[2:4:2, \"a\":\"c\"]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 185,
        "end_line": 215,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_get_loc_single_level#217",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_get_loc_single_level(self, single_level_multiindex)",
        "snippet": "    def test_get_loc_single_level(self, single_level_multiindex):\n        single_level = single_level_multiindex\n        s = Series(np.random.randn(len(single_level)), index=single_level)\n        for k in single_level.values:\n            s[k]",
        "begin_line": 217,
        "end_line": 221,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_getitem_int_slice#223",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_getitem_int_slice(self)",
        "snippet": "    def test_loc_getitem_int_slice(self):\n        # GH 3053\n        # loc should treat integer slices like label slices\n\n        index = MultiIndex.from_product([[6, 7, 8], [\"a\", \"b\"]])\n        df = DataFrame(np.random.randn(6, 6), index, index)\n        result = df.loc[6:8, :]\n        expected = df\n        tm.assert_frame_equal(result, expected)\n\n        index = MultiIndex.from_product([[10, 20, 30], [\"a\", \"b\"]])\n        df = DataFrame(np.random.randn(6, 6), index, index)\n        result = df.loc[20:30, :]\n        expected = df.iloc[2:]\n        tm.assert_frame_equal(result, expected)\n\n        # doc examples\n        result = df.loc[10, :]\n        expected = df.iloc[0:2]\n        expected.index = [\"a\", \"b\"]\n        tm.assert_frame_equal(result, expected)\n\n        result = df.loc[:, 10]\n        expected = df[10]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 223,
        "end_line": 247,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_getitem_nested_indexer#255",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.test_loc_getitem_nested_indexer(self, indexer_type_1, indexer_type_2)",
        "snippet": "    def test_loc_getitem_nested_indexer(self, indexer_type_1, indexer_type_2):\n        # GH #19686\n        # .loc should work with nested indexers which can be\n        # any list-like objects (see `pandas.api.types.is_list_like`) or slices\n\n        def convert_nested_indexer(indexer_type, keys):\n            if indexer_type == np.ndarray:\n                return np.array(keys)\n            if indexer_type == slice:\n                return slice(*keys)\n            return indexer_type(keys)\n\n        a = [10, 20, 30]\n        b = [1, 2, 3]\n        index = MultiIndex.from_product([a, b])\n        df = DataFrame(\n            np.arange(len(index), dtype=\"int64\"), index=index, columns=[\"Data\"]\n        )\n\n        keys = ([10, 20], [2, 3])\n        types = (indexer_type_1, indexer_type_2)\n\n        # check indexers with all the combinations of nested objects\n        # of all the valid types\n        indexer = tuple(\n            convert_nested_indexer(indexer_type, k)\n            for indexer_type, k in zip(types, keys)\n        )\n\n        result = df.loc[indexer, \"Data\"]\n        expected = Series(\n            [1, 2, 4, 5], name=\"Data\", index=MultiIndex.from_product(keys)\n        )\n\n        tm.assert_series_equal(result, expected)",
        "begin_line": 255,
        "end_line": 289,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.convert_nested_indexer#260",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.TestMultiIndexLoc.convert_nested_indexer(indexer_type, keys)",
        "snippet": "        def convert_nested_indexer(indexer_type, keys):\n            if indexer_type == np.ndarray:\n                return np.array(keys)\n            if indexer_type == slice:\n                return slice(*keys)\n            return indexer_type(keys)",
        "begin_line": 260,
        "end_line": 265,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.test_loc_getitem_duplicates_multiindex_missing_indexers#304",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.test_loc_getitem_duplicates_multiindex_missing_indexers(indexer, pos)",
        "snippet": "def test_loc_getitem_duplicates_multiindex_missing_indexers(indexer, pos):\n    # GH 7866\n    # multi-index slicing with missing indexers\n    idx = MultiIndex.from_product(\n        [[\"A\", \"B\", \"C\"], [\"foo\", \"bar\", \"baz\"]], names=[\"one\", \"two\"]\n    )\n    s = Series(np.arange(9, dtype=\"int64\"), index=idx).sort_index()\n    expected = s.iloc[pos]\n\n    if expected.size == 0 and indexer != []:\n        with pytest.raises(KeyError, match=str(indexer)):\n            s.loc[indexer]\n    else:\n        result = s.loc[indexer]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 304,
        "end_line": 318,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.test_series_loc_getitem_fancy#321",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.test_series_loc_getitem_fancy(multiindex_year_month_day_dataframe_random_data)",
        "snippet": "def test_series_loc_getitem_fancy(multiindex_year_month_day_dataframe_random_data):\n    s = multiindex_year_month_day_dataframe_random_data[\"A\"]\n    expected = s.reindex(s.index[49:51])\n    result = s.loc[[(2000, 3, 10), (2000, 3, 13)]]\n    tm.assert_series_equal(result, expected)",
        "begin_line": 321,
        "end_line": 325,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.test_loc_getitem_duplicates_multiindex_empty_indexer#329",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.test_loc_getitem_duplicates_multiindex_empty_indexer(columns_indexer)",
        "snippet": "def test_loc_getitem_duplicates_multiindex_empty_indexer(columns_indexer):\n    # GH 8737\n    # empty indexer\n    multi_index = MultiIndex.from_product(([\"foo\", \"bar\", \"baz\"], [\"alpha\", \"beta\"]))\n    df = DataFrame(np.random.randn(5, 6), index=range(5), columns=multi_index)\n    df = df.sort_index(level=0, axis=1)\n\n    expected = DataFrame(index=range(5), columns=multi_index.reindex([])[0])\n    result = df.loc[:, columns_indexer]\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 329,
        "end_line": 338,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.test_loc_getitem_duplicates_multiindex_non_scalar_type_object#341",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.test_loc_getitem_duplicates_multiindex_non_scalar_type_object()",
        "snippet": "def test_loc_getitem_duplicates_multiindex_non_scalar_type_object():\n    # regression from < 0.14.0\n    # GH 7914\n    df = DataFrame(\n        [[np.mean, np.median], [\"mean\", \"median\"]],\n        columns=MultiIndex.from_tuples([(\"functs\", \"mean\"), (\"functs\", \"median\")]),\n        index=[\"function\", \"name\"],\n    )\n    result = df.loc[\"function\", (\"functs\", \"mean\")]\n    expected = np.mean\n    assert result == expected",
        "begin_line": 341,
        "end_line": 351,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.test_loc_getitem_tuple_plus_slice#354",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.test_loc_getitem_tuple_plus_slice()",
        "snippet": "def test_loc_getitem_tuple_plus_slice():\n    # GH 671\n    df = DataFrame(\n        {\n            \"a\": np.arange(10),\n            \"b\": np.arange(10),\n            \"c\": np.random.randn(10),\n            \"d\": np.random.randn(10),\n        }\n    ).set_index([\"a\", \"b\"])\n    expected = df.loc[0, 0]\n    result = df.loc[(0, 0), :]\n    tm.assert_series_equal(result, expected)",
        "begin_line": 354,
        "end_line": 366,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.test_loc_getitem_int#369",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.test_loc_getitem_int(frame_random_data_integer_multi_index)",
        "snippet": "def test_loc_getitem_int(frame_random_data_integer_multi_index):\n    df = frame_random_data_integer_multi_index\n    result = df.loc[1]\n    expected = df[-3:]\n    expected.index = expected.index.droplevel(0)\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 369,
        "end_line": 374,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.test_loc_getitem_int_raises_exception#377",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.test_loc_getitem_int_raises_exception(frame_random_data_integer_multi_index)",
        "snippet": "def test_loc_getitem_int_raises_exception(frame_random_data_integer_multi_index):\n    df = frame_random_data_integer_multi_index\n    with pytest.raises(KeyError, match=r\"^3$\"):\n        df.loc[3]",
        "begin_line": 377,
        "end_line": 380,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.test_loc_getitem_lowerdim_corner#383",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.test_loc_getitem_lowerdim_corner(multiindex_dataframe_random_data)",
        "snippet": "def test_loc_getitem_lowerdim_corner(multiindex_dataframe_random_data):\n    df = multiindex_dataframe_random_data\n\n    # test setup - check key not in dataframe\n    with pytest.raises(KeyError, match=r\"^\\('bar', 'three'\\)$\"):\n        df.loc[(\"bar\", \"three\"), \"B\"]\n\n    # in theory should be inserting in a sorted space????\n    df.loc[(\"bar\", \"three\"), \"B\"] = 0\n    expected = 0\n    result = df.sort_index().loc[(\"bar\", \"three\"), \"B\"]\n    assert result == expected",
        "begin_line": 383,
        "end_line": 394,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.test_loc_setitem_single_column_slice#397",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.test_loc_setitem_single_column_slice()",
        "snippet": "def test_loc_setitem_single_column_slice():\n    # case from https://github.com/pandas-dev/pandas/issues/27841\n    df = DataFrame(\n        \"string\",\n        index=list(\"abcd\"),\n        columns=MultiIndex.from_product([[\"Main\"], (\"another\", \"one\")]),\n    )\n    df[\"labels\"] = \"a\"\n    df.loc[:, \"labels\"] = df.index\n    tm.assert_numpy_array_equal(np.asarray(df[\"labels\"]), np.asarray(df.index))\n\n    # test with non-object block\n    df = DataFrame(\n        np.nan,\n        index=range(4),\n        columns=MultiIndex.from_tuples([(\"A\", \"1\"), (\"A\", \"2\"), (\"B\", \"1\")]),\n    )\n    expected = df.copy()\n    df.loc[:, \"B\"] = np.arange(4)\n    expected.iloc[:, 2] = np.arange(4)\n    tm.assert_frame_equal(df, expected)",
        "begin_line": 397,
        "end_line": 417,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.test_loc_nan_multiindex#420",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.test_loc_nan_multiindex()",
        "snippet": "def test_loc_nan_multiindex():\n    # GH 5286\n    tups = [\n        (\"Good Things\", \"C\", np.nan),\n        (\"Good Things\", \"R\", np.nan),\n        (\"Bad Things\", \"C\", np.nan),\n        (\"Bad Things\", \"T\", np.nan),\n        (\"Okay Things\", \"N\", \"B\"),\n        (\"Okay Things\", \"N\", \"D\"),\n        (\"Okay Things\", \"B\", np.nan),\n        (\"Okay Things\", \"D\", np.nan),\n    ]\n    df = DataFrame(\n        np.ones((8, 4)),\n        columns=Index([\"d1\", \"d2\", \"d3\", \"d4\"]),\n        index=MultiIndex.from_tuples(tups, names=[\"u1\", \"u2\", \"u3\"]),\n    )\n    result = df.loc[\"Good Things\"].loc[\"C\"]\n    expected = DataFrame(\n        np.ones((1, 4)),\n        index=Index([np.nan], dtype=\"object\", name=\"u3\"),\n        columns=Index([\"d1\", \"d2\", \"d3\", \"d4\"], dtype=\"object\"),\n    )\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 420,
        "end_line": 443,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.test_loc_period_string_indexing#446",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.test_loc_period_string_indexing()",
        "snippet": "def test_loc_period_string_indexing():\n    # GH 9892\n    a = pd.period_range(\"2013Q1\", \"2013Q4\", freq=\"Q\")\n    i = (1111, 2222, 3333)\n    idx = pd.MultiIndex.from_product((a, i), names=(\"Periode\", \"CVR\"))\n    df = pd.DataFrame(\n        index=idx,\n        columns=(\n            \"OMS\",\n            \"OMK\",\n            \"RES\",\n            \"DRIFT_IND\",\n            \"OEVRIG_IND\",\n            \"FIN_IND\",\n            \"VARE_UD\",\n            \"LOEN_UD\",\n            \"FIN_UD\",\n        ),\n    )\n    result = df.loc[(\"2013Q1\", 1111), \"OMS\"]\n    expected = pd.Series(\n        [np.nan],\n        dtype=object,\n        name=\"OMS\",\n        index=pd.MultiIndex.from_tuples(\n            [(pd.Period(\"2013Q1\"), 1111)], names=[\"Periode\", \"CVR\"]\n        ),\n    )\n    tm.assert_series_equal(result, expected)",
        "begin_line": 446,
        "end_line": 474,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.test_loc.test_loc_datetime_mask_slicing#477",
        "src_path": "pandas/tests/indexing/multiindex/test_loc.py",
        "class_name": "pandas.tests.indexing.multiindex.test_loc",
        "signature": "pandas.tests.indexing.multiindex.test_loc.test_loc_datetime_mask_slicing()",
        "snippet": "def test_loc_datetime_mask_slicing():\n    # GH 16699\n    dt_idx = pd.to_datetime([\"2017-05-04\", \"2017-05-05\"])\n    m_idx = pd.MultiIndex.from_product([dt_idx, dt_idx], names=[\"Idx1\", \"Idx2\"])\n    df = pd.DataFrame(\n        data=[[1, 2], [3, 4], [5, 6], [7, 6]], index=m_idx, columns=[\"C1\", \"C2\"]\n    )\n    result = df.loc[(dt_idx[0], (df.index.get_level_values(1) > \"2017-05-04\")), \"C1\"]\n    expected = pd.Series(\n        [3],\n        name=\"C1\",\n        index=MultiIndex.from_tuples(\n            [(pd.Timestamp(\"2017-05-04\"), pd.Timestamp(\"2017-05-05\"))],\n            names=[\"Idx1\", \"Idx2\"],\n        ),\n    )\n    tm.assert_series_equal(result, expected)",
        "begin_line": 477,
        "end_line": 493,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemScalars.test_getitem_regression#19",
        "src_path": "pandas/tests/series/indexing/test_getitem.py",
        "class_name": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemScalars",
        "signature": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemScalars.test_getitem_regression(self)",
        "snippet": "    def test_getitem_regression(self):\n        ser = Series(range(5), index=list(range(5)))\n        result = ser[list(range(5))]\n        tm.assert_series_equal(result, ser)",
        "begin_line": 19,
        "end_line": 22,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemScalars.test_getitem_pydatetime_tz#28",
        "src_path": "pandas/tests/series/indexing/test_getitem.py",
        "class_name": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemScalars",
        "signature": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemScalars.test_getitem_pydatetime_tz(self, tzstr)",
        "snippet": "    def test_getitem_pydatetime_tz(self, tzstr):\n        tz = timezones.maybe_get_tz(tzstr)\n\n        index = date_range(\n            start=\"2012-12-24 16:00\", end=\"2012-12-24 18:00\", freq=\"H\", tz=tzstr\n        )\n        ts = Series(index=index, data=index.hour)\n        time_pandas = Timestamp(\"2012-12-24 17:00\", tz=tzstr)\n\n        dt = datetime(2012, 12, 24, 17, 0)\n        time_datetime = conversion.localize_pydatetime(dt, tz)\n        assert ts[time_pandas] == ts[time_datetime]",
        "begin_line": 28,
        "end_line": 39,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemScalars.test_string_index_alias_tz_aware#42",
        "src_path": "pandas/tests/series/indexing/test_getitem.py",
        "class_name": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemScalars",
        "signature": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemScalars.test_string_index_alias_tz_aware(self, tz)",
        "snippet": "    def test_string_index_alias_tz_aware(self, tz):\n        rng = date_range(\"1/1/2000\", periods=10, tz=tz)\n        ser = Series(np.random.randn(len(rng)), index=rng)\n\n        result = ser[\"1/3/2000\"]\n        tm.assert_almost_equal(result, ser[2])",
        "begin_line": 42,
        "end_line": 47,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemSlices.test_getitem_slice_2d#51",
        "src_path": "pandas/tests/series/indexing/test_getitem.py",
        "class_name": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemSlices",
        "signature": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemSlices.test_getitem_slice_2d(self, datetime_series)",
        "snippet": "    def test_getitem_slice_2d(self, datetime_series):\n        # GH#30588 multi-dimensional indexing deprecated\n\n        # This is currently failing because the test was relying on\n        # the DeprecationWarning coming through Index.__getitem__.\n        # We want to implement a warning specifically for Series.__getitem__\n        # at which point this will become a Deprecation/FutureWarning\n        with tm.assert_produces_warning(None):\n            # GH#30867 Don't want to support this long-term, but\n            # for now ensure that the warning from Index\n            # doesn't comes through via Series.__getitem__.\n            result = datetime_series[:, np.newaxis]\n        expected = datetime_series.values[:, np.newaxis]\n        tm.assert_almost_equal(result, expected)",
        "begin_line": 51,
        "end_line": 64,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemSlices.test_getitem_median_slice_bug#68",
        "src_path": "pandas/tests/series/indexing/test_getitem.py",
        "class_name": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemSlices",
        "signature": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemSlices.test_getitem_median_slice_bug(self)",
        "snippet": "    def test_getitem_median_slice_bug(self):\n        index = date_range(\"20090415\", \"20090519\", freq=\"2B\")\n        s = Series(np.random.randn(13), index=index)\n\n        indexer = [slice(6, 7, None)]\n        with tm.assert_produces_warning(FutureWarning):\n            # GH#31299\n            result = s[indexer]\n        expected = s[indexer[0]]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 68,
        "end_line": 77,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike.test_getitem_no_matches#82",
        "src_path": "pandas/tests/series/indexing/test_getitem.py",
        "class_name": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike",
        "signature": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike.test_getitem_no_matches(self, box)",
        "snippet": "    def test_getitem_no_matches(self, box):\n        # GH#33462 we expect the same behavior for list/ndarray/Index/Series\n        ser = Series([\"A\", \"B\"])\n\n        key = Series([\"C\"], dtype=object)\n        key = box(key)\n\n        msg = r\"None of \\[Index\\(\\['C'\\], dtype='object'\\)\\] are in the \\[index\\]\"\n        with pytest.raises(KeyError, match=msg):\n            ser[key]",
        "begin_line": 82,
        "end_line": 91,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike.test_getitem_intlist_intindex_periodvalues#93",
        "src_path": "pandas/tests/series/indexing/test_getitem.py",
        "class_name": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike",
        "signature": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike.test_getitem_intlist_intindex_periodvalues(self)",
        "snippet": "    def test_getitem_intlist_intindex_periodvalues(self):\n        ser = Series(period_range(\"2000-01-01\", periods=10, freq=\"D\"))\n\n        result = ser[[2, 4]]\n        exp = pd.Series(\n            [pd.Period(\"2000-01-03\", freq=\"D\"), pd.Period(\"2000-01-05\", freq=\"D\")],\n            index=[2, 4],\n            dtype=\"Period[D]\",\n        )\n        tm.assert_series_equal(result, exp)\n        assert result.dtype == \"Period[D]\"",
        "begin_line": 93,
        "end_line": 103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike.test_getitem_intlist_intervalindex_non_int#106",
        "src_path": "pandas/tests/series/indexing/test_getitem.py",
        "class_name": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike",
        "signature": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike.test_getitem_intlist_intervalindex_non_int(self, box)",
        "snippet": "    def test_getitem_intlist_intervalindex_non_int(self, box):\n        # GH#33404 fall back to positional since ints are unambiguous\n        dti = date_range(\"2000-01-03\", periods=3)\n        ii = pd.IntervalIndex.from_breaks(dti)\n        ser = Series(range(len(ii)), index=ii)\n\n        expected = ser.iloc[:1]\n        key = box([0])\n        result = ser[key]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 106,
        "end_line": 115,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike.test_getitem_intlist_multiindex_numeric_level#119",
        "src_path": "pandas/tests/series/indexing/test_getitem.py",
        "class_name": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike",
        "signature": "pandas.tests.series.indexing.test_getitem.TestSeriesGetitemListLike.test_getitem_intlist_multiindex_numeric_level(self, dtype, box)",
        "snippet": "    def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):\n        # GH#33404 do _not_ fall back to positional since ints are ambiguous\n        idx = pd.Index(range(4)).astype(dtype)\n        dti = date_range(\"2000-01-03\", periods=3)\n        mi = pd.MultiIndex.from_product([idx, dti])\n        ser = Series(range(len(mi))[::-1], index=mi)\n\n        key = box([5])\n        with pytest.raises(KeyError, match=\"5\"):\n            ser[key]",
        "begin_line": 119,
        "end_line": 128,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.indexing.test_getitem.test_getitem_generator#131",
        "src_path": "pandas/tests/series/indexing/test_getitem.py",
        "class_name": "pandas.tests.series.indexing.test_getitem",
        "signature": "pandas.tests.series.indexing.test_getitem.test_getitem_generator(string_series)",
        "snippet": "def test_getitem_generator(string_series):\n    gen = (x > 0 for x in string_series)\n    result = string_series[gen]\n    result2 = string_series[iter(string_series > 0)]\n    expected = string_series[string_series > 0]\n    tm.assert_series_equal(result, expected)\n    tm.assert_series_equal(result2, expected)",
        "begin_line": 131,
        "end_line": 137,
        "comment": "",
        "is_bug": false
    }
]