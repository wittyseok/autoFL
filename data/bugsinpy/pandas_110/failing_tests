coverage run -m pytest pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories
============================= test session starts ==============================
platform linux -- Python 3.8.3, pytest-5.4.3, py-1.8.1, pluggy-0.13.1
rootdir: /home/user/BugsInPy/temp/projects/pandas, inifile: setup.cfg
plugins: hypothesis-5.16.0
collected 93 items

pandas/tests/indexing/test_categorical.py FFFFFFFFFFFFFFFFF...FFFFFFFF.. [ 32%]
.FFFFFFFFFFFFFFFFF...FFFFFFFF...FFFFFFFFFFFFFFFFF...FFFFFFFF...          [100%]

=================================== FAILURES ===================================
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values0] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3c6eca0>
idx_values = [1, 2, 3], ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values1] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3c3db80>
idx_values = [-1, -2, -3], ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([-1, -2, -3], categories=[-3, -2, -1], ordered=True, dtype='category')
form = 'slice', key = -1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [-1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values2] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b36574c0>
idx_values = [1.5, 2.5, 3.5], ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4859: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=True, dtype='category')
form = 'slice', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'float'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values3] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b391c040>
idx_values = [-1.5, -2.5, -3.5], ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4859: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([-1.5, -2.5, -3.5], categories=[-3.5, -2.5, -1.5], ordered=True, dtype='category')
form = 'slice', key = -1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [-1.5] of <class 'float'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values4] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b39a4760>
idx_values = array([1, 2, 3], dtype=uint8), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint8'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values5] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3a2ba60>
idx_values = array([1, 2, 3], dtype=uint16), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint16'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values6] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b39a3670>
idx_values = array([1, 2, 3], dtype=uint32), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint32'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values7] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3543730>
idx_values = array([1, 2, 3], dtype=uint64), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint64'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values8] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b39a3c10>
idx_values = array([1, 2, 3]), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int64'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values9] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b379d310>
idx_values = array([1, 2, 3], dtype=int8), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values10] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3543d60>
idx_values = array([1, 2, 3], dtype=int16), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values11] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3b66190>
idx_values = array([1, 2, 3], dtype=int32), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values12] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b37c68b0>
idx_values = array([1, 2, 3]), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values13] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b35cfd60>
idx_values = array([1.5, 2.5, 3.5]), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4859: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=True, dtype='category')
form = 'slice', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'numpy.float64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values14] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b36da4f0>
idx_values = array([1.5, 2.5, 3.5], dtype=float32), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4859: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=True, dtype='category')
form = 'slice', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'numpy.float32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values15] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b35cfbe0>
idx_values = array([1.5, 2.5, 3.5]), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4859: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=True, dtype='category')
form = 'slice', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'numpy.float64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values16] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b35e3430>
idx_values = array([1, 'b', 3.5], dtype=object), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 'b', 3.5], categories=[1, 3.5, 'b'], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values20] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3b3dc10>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt8
ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values21] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b38f9be0>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt16
ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values22] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3be7460>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt32
ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values23] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3574d30>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt64
ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values24] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3894250>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int8
ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values25] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3574250>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int16
ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values26] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b35b7bb0>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int32
ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values27] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3b66310>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int64
ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values0] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b38cde50>
idx_values = [1, 2, 3], ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values1] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b38be940>
idx_values = [-1, -2, -3], ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([-1, -2, -3], categories=[-3, -2, -1], ordered=False, dtype='category')
form = 'slice', key = -1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [-1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values2] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3ae6340>
idx_values = [1.5, 2.5, 3.5], ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4859: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=False, dtype='category')
form = 'slice', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'float'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values3] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3b66160>
idx_values = [-1.5, -2.5, -3.5], ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4859: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([-1.5, -2.5, -3.5], categories=[-3.5, -2.5, -1.5], ordered=False, dtype='category')
form = 'slice', key = -1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [-1.5] of <class 'float'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values4] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3a23610>
idx_values = array([1, 2, 3], dtype=uint8), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values5] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b34e22b0>
idx_values = array([1, 2, 3], dtype=uint16), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values6] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b34e2580>
idx_values = array([1, 2, 3], dtype=uint32), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values7] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b349d1f0>
idx_values = array([1, 2, 3], dtype=uint64), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values8] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b37b8610>
idx_values = array([1, 2, 3]), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values9] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b38881f0>
idx_values = array([1, 2, 3], dtype=int8), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values10] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b38f29d0>
idx_values = array([1, 2, 3], dtype=int16), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values11] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b33d59d0>
idx_values = array([1, 2, 3], dtype=int32), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values12] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b339d1c0>
idx_values = array([1, 2, 3]), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values13] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b33edfa0>
idx_values = array([1.5, 2.5, 3.5]), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4859: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=False, dtype='category')
form = 'slice', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'numpy.float64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values14] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3272970>
idx_values = array([1.5, 2.5, 3.5], dtype=float32), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4859: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=False, dtype='category')
form = 'slice', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'numpy.float32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values15] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b38f21c0>
idx_values = array([1.5, 2.5, 3.5]), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4859: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=False, dtype='category')
form = 'slice', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'numpy.float64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values16] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b37aa430>
idx_values = array([1, 'b', 3.5], dtype=object), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 'b', 3.5], categories=[1, 3.5, 'b'], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values20] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b362a310>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt8
ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values21] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b33327c0>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt16
ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values22] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3501df0>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt32
ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values23] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b348f460>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt64
ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values24] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3501a00>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int8
ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values25] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b387a370>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int16
ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values26] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b337d700>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int32
ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values27] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b35dbc10>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int64
ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int64'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values0] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b33cc7f0>
idx_values = [1, 2, 3], ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values1] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b35db8b0>
idx_values = [-1, -2, -3], ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([-1, -2, -3], categories=[-3, -2, -1], ordered=False, dtype='category')
form = 'slice', key = -1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [-1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values2] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3ab8a90>
idx_values = [1.5, 2.5, 3.5], ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4859: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=False, dtype='category')
form = 'slice', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'float'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values3] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b36f6730>
idx_values = [-1.5, -2.5, -3.5], ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4859: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([-1.5, -2.5, -3.5], categories=[-3.5, -2.5, -1.5], ordered=False, dtype='category')
form = 'slice', key = -1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [-1.5] of <class 'float'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values4] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b38d1f40>
idx_values = array([1, 2, 3], dtype=uint8), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint8'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values5] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b36f6f70>
idx_values = array([1, 2, 3], dtype=uint16), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint16'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values6] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b337d400>
idx_values = array([1, 2, 3], dtype=uint32), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint32'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values7] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3827ac0>
idx_values = array([1, 2, 3], dtype=uint64), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint64'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values8] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b32b8550>
idx_values = array([1, 2, 3]), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int64'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values9] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3c3d100>
idx_values = array([1, 2, 3], dtype=int8), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values10] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b37217c0>
idx_values = array([1, 2, 3], dtype=int16), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values11] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3814310>
idx_values = array([1, 2, 3], dtype=int32), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values12] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3814af0>
idx_values = array([1, 2, 3]), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values13] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b32316d0>
idx_values = array([1.5, 2.5, 3.5]), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4859: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=False, dtype='category')
form = 'slice', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'numpy.float64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values14] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3814670>
idx_values = array([1.5, 2.5, 3.5], dtype=float32), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4859: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=False, dtype='category')
form = 'slice', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'numpy.float32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values15] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3239490>
idx_values = array([1.5, 2.5, 3.5]), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4859: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=False, dtype='category')
form = 'slice', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'numpy.float64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values16] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3231730>
idx_values = array([1, 'b', 3.5], dtype=object), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 'b', 3.5], categories=[1, 3.5, 'b'], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values20] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b3347610>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt8
ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values21] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b33191c0>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt16
ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values22] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b37a5dc0>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt32
ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values23] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b38a7220>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt64
ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values24] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b37a5280>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int8
ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values25] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b360bf40>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int16
ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values26] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b32651f0>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int32
ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values27] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7f69b387a400>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int64
ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
        sl = slice(idx_values[0], idx_values[1])
    
        # scalar selection
        result = df.loc[idx_values[0]]
        expected = Series(["foo"], index=["A"], name=idx_values[0])
        tm.assert_series_equal(result, expected)
    
        # list selection
        result = df.loc[idx_values[:2]]
        expected = DataFrame(["foo", "bar"], index=cat_idx[:2], columns=["A"])
        tm.assert_frame_equal(result, expected)
    
        # slice selection
>       result = df.loc[sl]

pandas/tests/indexing/test_categorical.py:801: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int64'>

pandas/core/indexes/base.py:3132: TypeError
=========================== short test summary info ============================
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values0]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values1]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values2]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values3]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values4]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values5]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values6]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values7]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values8]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values9]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values10]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values11]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values12]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values13]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values14]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values15]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values16]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values20]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values21]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values22]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values23]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values24]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values25]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values26]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values27]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values0]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values1]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values2]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values3]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values4]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values5]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values6]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values7]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values8]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values9]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values10]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values11]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values12]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values13]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values14]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values15]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values16]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values20]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values21]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values22]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values23]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values24]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values25]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values26]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values27]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values0]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values1]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values2]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values3]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values4]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values5]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values6]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values7]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values8]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values9]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values10]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values11]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values12]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values13]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values14]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values15]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values16]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values20]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values21]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values22]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values23]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values24]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values25]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values26]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values27]
======================== 75 failed, 18 passed in 45.34s ========================

coverage run -m pytest pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_slice
============================= test session starts ==============================
platform linux -- Python 3.8.3, pytest-5.4.3, py-1.8.1, pluggy-0.13.1
rootdir: /home/user/BugsInPy/temp/projects/pandas, inifile: setup.cfg
plugins: hypothesis-5.16.0
collected 1 item

pandas/tests/indexing/test_categorical.py F                              [100%]

=================================== FAILURES ===================================
_____________________ TestCategoricalIndex.test_loc_slice ______________________

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fe2457edd00>

    def test_loc_slice(self):
        # GH9748
        with pytest.raises(KeyError, match="1"):
>           self.df.loc[1:5]

pandas/tests/indexing/test_categorical.py:659: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1301: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1681: in _getitem_axis
    return self._get_slice_axis(key, axis=axis)
pandas/core/indexing.py:1329: in _get_slice_axis
    indexer = labels.slice_indexer(
pandas/core/indexes/base.py:4787: in slice_indexer
    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
pandas/core/indexes/base.py:5000: in slice_locs
    start_slice = self.get_slice_bound(start, "left", kind)
pandas/core/indexes/base.py:4912: in get_slice_bound
    label = self._maybe_cast_slice_bound(label, side, kind)
pandas/core/indexes/base.py:4864: in _maybe_cast_slice_bound
    self._invalid_indexer("slice", label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex(['a', 'a', 'b', 'b', 'c', 'a'], categories=['c', 'a', 'b'], ordered=False, name='B', dtype='category')
form = 'slice', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do slice indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
=========================== short test summary info ============================
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_slice
============================== 1 failed in 0.84s ===============================
