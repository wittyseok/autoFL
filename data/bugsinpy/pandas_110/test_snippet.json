[
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.setup_method#24",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n\n        self.df = DataFrame(\n            {\n                \"A\": np.arange(6, dtype=\"int64\"),\n                \"B\": Series(list(\"aabbca\")).astype(CDT(list(\"cab\"))),\n            }\n        ).set_index(\"B\")\n        self.df2 = DataFrame(\n            {\n                \"A\": np.arange(6, dtype=\"int64\"),\n                \"B\": Series(list(\"aabbca\")).astype(CDT(list(\"cabe\"))),\n            }\n        ).set_index(\"B\")\n        self.df3 = DataFrame(\n            {\n                \"A\": np.arange(6, dtype=\"int64\"),\n                \"B\": (Series([1, 1, 2, 1, 3, 2]).astype(CDT([3, 2, 1], ordered=True))),\n            }\n        ).set_index(\"B\")\n        self.df4 = DataFrame(\n            {\n                \"A\": np.arange(6, dtype=\"int64\"),\n                \"B\": (Series([1, 1, 2, 1, 3, 2]).astype(CDT([3, 2, 1], ordered=False))),\n            }\n        ).set_index(\"B\")",
        "begin_line": 24,
        "end_line": 49,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_scalar#51",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_scalar(self)",
        "snippet": "    def test_loc_scalar(self):\n        result = self.df.loc[\"a\"]\n        expected = DataFrame(\n            {\"A\": [0, 1, 5], \"B\": (Series(list(\"aaa\")).astype(CDT(list(\"cab\"))))}\n        ).set_index(\"B\")\n        tm.assert_frame_equal(result, expected)\n\n        df = self.df.copy()\n        df.loc[\"a\"] = 20\n        expected = DataFrame(\n            {\n                \"A\": [20, 20, 2, 3, 4, 20],\n                \"B\": (Series(list(\"aabbca\")).astype(CDT(list(\"cab\")))),\n            }\n        ).set_index(\"B\")\n        tm.assert_frame_equal(df, expected)\n\n        # value not in the categories\n        with pytest.raises(KeyError, match=r\"^'d'$\"):\n            df.loc[\"d\"]\n\n        msg = \"cannot append a non-category item to a CategoricalIndex\"\n        with pytest.raises(TypeError, match=msg):\n            df.loc[\"d\"] = 10\n\n        msg = (\n            \"cannot insert an item into a CategoricalIndex that is not\"\n            \" already an existing category\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            df.loc[\"d\", \"A\"] = 10\n        with pytest.raises(TypeError, match=msg):\n            df.loc[\"d\", \"C\"] = 10\n\n        msg = (\n            r\"cannot do label indexing on <class 'pandas\\.core\\.indexes\\.category\"\n            r\"\\.CategoricalIndex'> with these indexers \\[1\\] of <class 'int'>\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            df.loc[1]",
        "begin_line": 51,
        "end_line": 90,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_getitem_scalar#92",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_getitem_scalar(self)",
        "snippet": "    def test_getitem_scalar(self):\n\n        cats = Categorical([Timestamp(\"12-31-1999\"), Timestamp(\"12-31-2000\")])\n\n        s = Series([1, 2], index=cats)\n\n        expected = s.iloc[0]\n        result = s[cats[0]]\n        assert result == expected",
        "begin_line": 92,
        "end_line": 100,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing_directly#102",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing_directly(self)",
        "snippet": "    def test_slicing_directly(self):\n        cat = Categorical([\"a\", \"b\", \"c\", \"d\", \"a\", \"b\", \"c\"])\n        sliced = cat[3]\n        assert sliced == \"d\"\n        sliced = cat[3:5]\n        expected = Categorical([\"d\", \"a\"], categories=[\"a\", \"b\", \"c\", \"d\"])\n        tm.assert_numpy_array_equal(sliced._codes, expected._codes)\n        tm.assert_index_equal(sliced.categories, expected.categories)",
        "begin_line": 102,
        "end_line": 109,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing#111",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing(self)",
        "snippet": "    def test_slicing(self):\n        cat = Series(Categorical([1, 2, 3, 4]))\n        reversed = cat[::-1]\n        exp = np.array([4, 3, 2, 1], dtype=np.int64)\n        tm.assert_numpy_array_equal(reversed.__array__(), exp)\n\n        df = DataFrame({\"value\": (np.arange(100) + 1).astype(\"int64\")})\n        df[\"D\"] = pd.cut(df.value, bins=[0, 25, 50, 75, 100])\n\n        expected = Series([11, Interval(0, 25)], index=[\"value\", \"D\"], name=10)\n        result = df.iloc[10]\n        tm.assert_series_equal(result, expected)\n\n        expected = DataFrame(\n            {\"value\": np.arange(11, 21).astype(\"int64\")},\n            index=np.arange(10, 20).astype(\"int64\"),\n        )\n        expected[\"D\"] = pd.cut(expected.value, bins=[0, 25, 50, 75, 100])\n        result = df.iloc[10:20]\n        tm.assert_frame_equal(result, expected)\n\n        expected = Series([9, Interval(0, 25)], index=[\"value\", \"D\"], name=8)\n        result = df.loc[8]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 111,
        "end_line": 134,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing_and_getting_ops#136",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing_and_getting_ops(self)",
        "snippet": "    def test_slicing_and_getting_ops(self):\n\n        # systematically test the slicing operations:\n        #  for all slicing ops:\n        #   - returning a dataframe\n        #   - returning a column\n        #   - returning a row\n        #   - returning a single value\n\n        cats = Categorical(\n            [\"a\", \"c\", \"b\", \"c\", \"c\", \"c\", \"c\"], categories=[\"a\", \"b\", \"c\"]\n        )\n        idx = Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        values = [1, 2, 3, 4, 5, 6, 7]\n        df = DataFrame({\"cats\": cats, \"values\": values}, index=idx)\n\n        # the expected values\n        cats2 = Categorical([\"b\", \"c\"], categories=[\"a\", \"b\", \"c\"])\n        idx2 = Index([\"j\", \"k\"])\n        values2 = [3, 4]\n\n        # 2:4,: | \"j\":\"k\",:\n        exp_df = DataFrame({\"cats\": cats2, \"values\": values2}, index=idx2)\n\n        # :,\"cats\" | :,0\n        exp_col = Series(cats, index=idx, name=\"cats\")\n\n        # \"j\",: | 2,:\n        exp_row = Series([\"b\", 3], index=[\"cats\", \"values\"], dtype=\"object\", name=\"j\")\n\n        # \"j\",\"cats | 2,0\n        exp_val = \"b\"\n\n        # iloc\n        # frame\n        res_df = df.iloc[2:4, :]\n        tm.assert_frame_equal(res_df, exp_df)\n        assert is_categorical_dtype(res_df[\"cats\"])\n\n        # row\n        res_row = df.iloc[2, :]\n        tm.assert_series_equal(res_row, exp_row)\n        assert isinstance(res_row[\"cats\"], str)\n\n        # col\n        res_col = df.iloc[:, 0]\n        tm.assert_series_equal(res_col, exp_col)\n        assert is_categorical_dtype(res_col)\n\n        # single value\n        res_val = df.iloc[2, 0]\n        assert res_val == exp_val\n\n        # loc\n        # frame\n        res_df = df.loc[\"j\":\"k\", :]\n        tm.assert_frame_equal(res_df, exp_df)\n        assert is_categorical_dtype(res_df[\"cats\"])\n\n        # row\n        res_row = df.loc[\"j\", :]\n        tm.assert_series_equal(res_row, exp_row)\n        assert isinstance(res_row[\"cats\"], str)\n\n        # col\n        res_col = df.loc[:, \"cats\"]\n        tm.assert_series_equal(res_col, exp_col)\n        assert is_categorical_dtype(res_col)\n\n        # single value\n        res_val = df.loc[\"j\", \"cats\"]\n        assert res_val == exp_val\n\n        # ix\n        # frame\n        # res_df = df.loc[\"j\":\"k\",[0,1]] # doesn't work?\n        res_df = df.loc[\"j\":\"k\", :]\n        tm.assert_frame_equal(res_df, exp_df)\n        assert is_categorical_dtype(res_df[\"cats\"])\n\n        # row\n        res_row = df.loc[\"j\", :]\n        tm.assert_series_equal(res_row, exp_row)\n        assert isinstance(res_row[\"cats\"], str)\n\n        # col\n        res_col = df.loc[:, \"cats\"]\n        tm.assert_series_equal(res_col, exp_col)\n        assert is_categorical_dtype(res_col)\n\n        # single value\n        res_val = df.loc[\"j\", df.columns[0]]\n        assert res_val == exp_val\n\n        # iat\n        res_val = df.iat[2, 0]\n        assert res_val == exp_val\n\n        # at\n        res_val = df.at[\"j\", \"cats\"]\n        assert res_val == exp_val\n\n        # fancy indexing\n        exp_fancy = df.iloc[[2]]\n\n        res_fancy = df[df[\"cats\"] == \"b\"]\n        tm.assert_frame_equal(res_fancy, exp_fancy)\n        res_fancy = df[df[\"values\"] == 3]\n        tm.assert_frame_equal(res_fancy, exp_fancy)\n\n        # get_value\n        res_val = df.at[\"j\", \"cats\"]\n        assert res_val == exp_val\n\n        # i : int, slice, or sequence of integers\n        res_row = df.iloc[2]\n        tm.assert_series_equal(res_row, exp_row)\n        assert isinstance(res_row[\"cats\"], str)\n\n        res_df = df.iloc[slice(2, 4)]\n        tm.assert_frame_equal(res_df, exp_df)\n        assert is_categorical_dtype(res_df[\"cats\"])\n\n        res_df = df.iloc[[2, 3]]\n        tm.assert_frame_equal(res_df, exp_df)\n        assert is_categorical_dtype(res_df[\"cats\"])\n\n        res_col = df.iloc[:, 0]\n        tm.assert_series_equal(res_col, exp_col)\n        assert is_categorical_dtype(res_col)\n\n        res_df = df.iloc[:, slice(0, 2)]\n        tm.assert_frame_equal(res_df, df)\n        assert is_categorical_dtype(res_df[\"cats\"])\n\n        res_df = df.iloc[:, [0, 1]]\n        tm.assert_frame_equal(res_df, df)\n        assert is_categorical_dtype(res_df[\"cats\"])",
        "begin_line": 136,
        "end_line": 273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing_doc_examples#275",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing_doc_examples(self)",
        "snippet": "    def test_slicing_doc_examples(self):\n\n        # GH 7918\n        cats = Categorical(\n            [\"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"], categories=[\"a\", \"b\", \"c\"]\n        )\n        idx = Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        values = [1, 2, 2, 2, 3, 4, 5]\n        df = DataFrame({\"cats\": cats, \"values\": values}, index=idx)\n\n        result = df.iloc[2:4, :]\n        expected = DataFrame(\n            {\n                \"cats\": Categorical([\"b\", \"b\"], categories=[\"a\", \"b\", \"c\"]),\n                \"values\": [2, 2],\n            },\n            index=[\"j\", \"k\"],\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[2:4, :].dtypes\n        expected = Series([\"category\", \"int64\"], [\"cats\", \"values\"])\n        tm.assert_series_equal(result, expected)\n\n        result = df.loc[\"h\":\"j\", \"cats\"]\n        expected = Series(\n            Categorical([\"a\", \"b\", \"b\"], categories=[\"a\", \"b\", \"c\"]),\n            index=[\"h\", \"i\", \"j\"],\n            name=\"cats\",\n        )\n        tm.assert_series_equal(result, expected)\n\n        result = df.loc[\"h\":\"j\", df.columns[0:1]]\n        expected = DataFrame(\n            {\"cats\": Categorical([\"a\", \"b\", \"b\"], categories=[\"a\", \"b\", \"c\"])},\n            index=[\"h\", \"i\", \"j\"],\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 275,
        "end_line": 312,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_getitem_category_type#314",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_getitem_category_type(self)",
        "snippet": "    def test_getitem_category_type(self):\n        # GH 14580\n        # test iloc() on Series with Categorical data\n\n        s = Series([1, 2, 3]).astype(\"category\")\n\n        # get slice\n        result = s.iloc[0:2]\n        expected = Series([1, 2]).astype(CategoricalDtype([1, 2, 3]))\n        tm.assert_series_equal(result, expected)\n\n        # get list of indexes\n        result = s.iloc[[0, 1]]\n        expected = Series([1, 2]).astype(CategoricalDtype([1, 2, 3]))\n        tm.assert_series_equal(result, expected)\n\n        # get boolean array\n        result = s.iloc[[True, False, False]]\n        expected = Series([1]).astype(CategoricalDtype([1, 2, 3]))\n        tm.assert_series_equal(result, expected)",
        "begin_line": 314,
        "end_line": 333,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_listlike#335",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_listlike(self)",
        "snippet": "    def test_loc_listlike(self):\n\n        # list of labels\n        result = self.df.loc[[\"c\", \"a\"]]\n        expected = self.df.iloc[[4, 0, 1, 5]]\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = self.df2.loc[[\"a\", \"b\", \"e\"]]\n        exp_index = CategoricalIndex(list(\"aaabbe\"), categories=list(\"cabe\"), name=\"B\")\n        expected = DataFrame({\"A\": [0, 1, 5, 2, 3, np.nan]}, index=exp_index)\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        # element in the categories but not in the values\n        with pytest.raises(KeyError, match=r\"^'e'$\"):\n            self.df2.loc[\"e\"]\n\n        # assign is ok\n        df = self.df2.copy()\n        df.loc[\"e\"] = 20\n        result = df.loc[[\"a\", \"b\", \"e\"]]\n        exp_index = CategoricalIndex(list(\"aaabbe\"), categories=list(\"cabe\"), name=\"B\")\n        expected = DataFrame({\"A\": [0, 1, 5, 2, 3, 20]}, index=exp_index)\n        tm.assert_frame_equal(result, expected)\n\n        df = self.df2.copy()\n        result = df.loc[[\"a\", \"b\", \"e\"]]\n        exp_index = CategoricalIndex(list(\"aaabbe\"), categories=list(\"cabe\"), name=\"B\")\n        expected = DataFrame({\"A\": [0, 1, 5, 2, 3, np.nan]}, index=exp_index)\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        # not all labels in the categories\n        with pytest.raises(\n            KeyError,\n            match=\"'a list-indexer must only include values that are in the\"\n            \" categories'\",\n        ):\n            self.df2.loc[[\"a\", \"d\"]]",
        "begin_line": 335,
        "end_line": 371,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_listlike_dtypes#373",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_listlike_dtypes(self)",
        "snippet": "    def test_loc_listlike_dtypes(self):\n        # GH 11586\n\n        # unique categories and codes\n        index = CategoricalIndex([\"a\", \"b\", \"c\"])\n        df = DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]}, index=index)\n\n        # unique slice\n        res = df.loc[[\"a\", \"b\"]]\n        exp_index = CategoricalIndex([\"a\", \"b\"], categories=index.categories)\n        exp = DataFrame({\"A\": [1, 2], \"B\": [4, 5]}, index=exp_index)\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        # duplicated slice\n        res = df.loc[[\"a\", \"a\", \"b\"]]\n\n        exp_index = CategoricalIndex([\"a\", \"a\", \"b\"], categories=index.categories)\n        exp = DataFrame({\"A\": [1, 1, 2], \"B\": [4, 4, 5]}, index=exp_index)\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        msg = \"a list-indexer must only include values that are in the categories\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[\"a\", \"x\"]]\n\n        # duplicated categories and codes\n        index = CategoricalIndex([\"a\", \"b\", \"a\"])\n        df = DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]}, index=index)\n\n        # unique slice\n        res = df.loc[[\"a\", \"b\"]]\n        exp = DataFrame(\n            {\"A\": [1, 3, 2], \"B\": [4, 6, 5]}, index=CategoricalIndex([\"a\", \"a\", \"b\"])\n        )\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        # duplicated slice\n        res = df.loc[[\"a\", \"a\", \"b\"]]\n        exp = DataFrame(\n            {\"A\": [1, 3, 1, 3, 2], \"B\": [4, 6, 4, 6, 5]},\n            index=CategoricalIndex([\"a\", \"a\", \"a\", \"a\", \"b\"]),\n        )\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        msg = \"a list-indexer must only include values that are in the categories\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[\"a\", \"x\"]]\n\n        # contains unused category\n        index = CategoricalIndex([\"a\", \"b\", \"a\", \"c\"], categories=list(\"abcde\"))\n        df = DataFrame({\"A\": [1, 2, 3, 4], \"B\": [5, 6, 7, 8]}, index=index)\n\n        res = df.loc[[\"a\", \"b\"]]\n        exp = DataFrame(\n            {\"A\": [1, 3, 2], \"B\": [5, 7, 6]},\n            index=CategoricalIndex([\"a\", \"a\", \"b\"], categories=list(\"abcde\")),\n        )\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        res = df.loc[[\"a\", \"e\"]]\n        exp = DataFrame(\n            {\"A\": [1, 3, np.nan], \"B\": [5, 7, np.nan]},\n            index=CategoricalIndex([\"a\", \"a\", \"e\"], categories=list(\"abcde\")),\n        )\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        # duplicated slice\n        res = df.loc[[\"a\", \"a\", \"b\"]]\n        exp = DataFrame(\n            {\"A\": [1, 3, 1, 3, 2], \"B\": [5, 7, 5, 7, 6]},\n            index=CategoricalIndex([\"a\", \"a\", \"a\", \"a\", \"b\"], categories=list(\"abcde\")),\n        )\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        msg = \"a list-indexer must only include values that are in the categories\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[\"a\", \"x\"]]",
        "begin_line": 373,
        "end_line": 448,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_get_indexer_array#450",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_get_indexer_array(self)",
        "snippet": "    def test_get_indexer_array(self):\n        arr = np.array(\n            [Timestamp(\"1999-12-31 00:00:00\"), Timestamp(\"2000-12-31 00:00:00\")],\n            dtype=object,\n        )\n        cats = [Timestamp(\"1999-12-31 00:00:00\"), Timestamp(\"2000-12-31 00:00:00\")]\n        ci = CategoricalIndex(cats, categories=cats, ordered=False, dtype=\"category\")\n        result = ci.get_indexer(arr)\n        expected = np.array([0, 1], dtype=\"intp\")\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 450,
        "end_line": 459,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_get_indexer_same_categories_same_order#461",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_get_indexer_same_categories_same_order(self)",
        "snippet": "    def test_get_indexer_same_categories_same_order(self):\n        ci = CategoricalIndex([\"a\", \"b\"], categories=[\"a\", \"b\"])\n\n        result = ci.get_indexer(CategoricalIndex([\"b\", \"b\"], categories=[\"a\", \"b\"]))\n        expected = np.array([1, 1], dtype=\"intp\")\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 461,
        "end_line": 466,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_get_indexer_same_categories_different_order#468",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_get_indexer_same_categories_different_order(self)",
        "snippet": "    def test_get_indexer_same_categories_different_order(self):\n        # https://github.com/pandas-dev/pandas/issues/19551\n        ci = CategoricalIndex([\"a\", \"b\"], categories=[\"a\", \"b\"])\n\n        result = ci.get_indexer(CategoricalIndex([\"b\", \"b\"], categories=[\"b\", \"a\"]))\n        expected = np.array([1, 1], dtype=\"intp\")\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 468,
        "end_line": 474,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_getitem_with_listlike#476",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_getitem_with_listlike(self)",
        "snippet": "    def test_getitem_with_listlike(self):\n        # GH 16115\n        cats = Categorical([Timestamp(\"12-31-1999\"), Timestamp(\"12-31-2000\")])\n\n        expected = DataFrame(\n            [[1, 0], [0, 1]], dtype=\"uint8\", index=[0, 1], columns=cats\n        )\n        dummies = pd.get_dummies(cats)\n        result = dummies[list(dummies.columns)]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 476,
        "end_line": 485,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_setitem_listlike#487",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_setitem_listlike(self)",
        "snippet": "    def test_setitem_listlike(self):\n\n        # GH 9469\n        # properly coerce the input indexers\n        np.random.seed(1)\n        c = Categorical(\n            np.random.randint(0, 5, size=150000).astype(np.int8)\n        ).add_categories([-1000])\n        indexer = np.array([100000]).astype(np.int64)\n        c[indexer] = -1000\n\n        # we are asserting the code result here\n        # which maps to the -1000 category\n        result = c.codes[np.array([100000]).astype(np.int64)]\n        tm.assert_numpy_array_equal(result, np.array([5], dtype=\"int8\"))",
        "begin_line": 487,
        "end_line": 501,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_ix_categorical_index#503",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_ix_categorical_index(self)",
        "snippet": "    def test_ix_categorical_index(self):\n        # GH 12531\n        df = DataFrame(np.random.randn(3, 3), index=list(\"ABC\"), columns=list(\"XYZ\"))\n        cdf = df.copy()\n        cdf.index = CategoricalIndex(df.index)\n        cdf.columns = CategoricalIndex(df.columns)\n\n        expect = Series(df.loc[\"A\", :], index=cdf.columns, name=\"A\")\n        tm.assert_series_equal(cdf.loc[\"A\", :], expect)\n\n        expect = Series(df.loc[:, \"X\"], index=cdf.index, name=\"X\")\n        tm.assert_series_equal(cdf.loc[:, \"X\"], expect)\n\n        exp_index = CategoricalIndex(list(\"AB\"), categories=[\"A\", \"B\", \"C\"])\n        expect = DataFrame(df.loc[[\"A\", \"B\"], :], columns=cdf.columns, index=exp_index)\n        tm.assert_frame_equal(cdf.loc[[\"A\", \"B\"], :], expect)\n\n        exp_columns = CategoricalIndex(list(\"XY\"), categories=[\"X\", \"Y\", \"Z\"])\n        expect = DataFrame(df.loc[:, [\"X\", \"Y\"]], index=cdf.index, columns=exp_columns)\n        tm.assert_frame_equal(cdf.loc[:, [\"X\", \"Y\"]], expect)\n\n        # non-unique\n        df = DataFrame(np.random.randn(3, 3), index=list(\"ABA\"), columns=list(\"XYX\"))\n        cdf = df.copy()\n        cdf.index = CategoricalIndex(df.index)\n        cdf.columns = CategoricalIndex(df.columns)\n\n        exp_index = CategoricalIndex(list(\"AA\"), categories=[\"A\", \"B\"])\n        expect = DataFrame(df.loc[\"A\", :], columns=cdf.columns, index=exp_index)\n        tm.assert_frame_equal(cdf.loc[\"A\", :], expect)\n\n        exp_columns = CategoricalIndex(list(\"XX\"), categories=[\"X\", \"Y\"])\n        expect = DataFrame(df.loc[:, \"X\"], index=cdf.index, columns=exp_columns)\n        tm.assert_frame_equal(cdf.loc[:, \"X\"], expect)\n\n        expect = DataFrame(\n            df.loc[[\"A\", \"B\"], :],\n            columns=cdf.columns,\n            index=CategoricalIndex(list(\"AAB\")),\n        )\n        tm.assert_frame_equal(cdf.loc[[\"A\", \"B\"], :], expect)\n\n        expect = DataFrame(\n            df.loc[:, [\"X\", \"Y\"]],\n            index=cdf.index,\n            columns=CategoricalIndex(list(\"XXY\")),\n        )\n        tm.assert_frame_equal(cdf.loc[:, [\"X\", \"Y\"]], expect)",
        "begin_line": 503,
        "end_line": 550,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_read_only_source#552",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_read_only_source(self)",
        "snippet": "    def test_read_only_source(self):\n        # GH 10043\n        rw_array = np.eye(10)\n        rw_df = DataFrame(rw_array)\n\n        ro_array = np.eye(10)\n        ro_array.setflags(write=False)\n        ro_df = DataFrame(ro_array)\n\n        tm.assert_frame_equal(rw_df.iloc[[1, 2, 3]], ro_df.iloc[[1, 2, 3]])\n        tm.assert_frame_equal(rw_df.iloc[[1]], ro_df.iloc[[1]])\n        tm.assert_series_equal(rw_df.iloc[1], ro_df.iloc[1])\n        tm.assert_frame_equal(rw_df.iloc[1:3], ro_df.iloc[1:3])\n\n        tm.assert_frame_equal(rw_df.loc[[1, 2, 3]], ro_df.loc[[1, 2, 3]])\n        tm.assert_frame_equal(rw_df.loc[[1]], ro_df.loc[[1]])\n        tm.assert_series_equal(rw_df.loc[1], ro_df.loc[1])\n        tm.assert_frame_equal(rw_df.loc[1:3], ro_df.loc[1:3])",
        "begin_line": 552,
        "end_line": 569,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_reindexing#571",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_reindexing(self)",
        "snippet": "    def test_reindexing(self):\n        df = DataFrame(\n            {\n                \"A\": np.arange(3, dtype=\"int64\"),\n                \"B\": Series(list(\"abc\")).astype(CDT(list(\"cabe\"))),\n            }\n        ).set_index(\"B\")\n\n        # reindexing\n        # convert to a regular index\n        result = df.reindex([\"a\", \"b\", \"e\"])\n        expected = DataFrame({\"A\": [0, 1, np.nan], \"B\": Series(list(\"abe\"))}).set_index(\n            \"B\"\n        )\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex([\"a\", \"b\"])\n        expected = DataFrame({\"A\": [0, 1], \"B\": Series(list(\"ab\"))}).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex([\"e\"])\n        expected = DataFrame({\"A\": [np.nan], \"B\": Series([\"e\"])}).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex([\"d\"])\n        expected = DataFrame({\"A\": [np.nan], \"B\": Series([\"d\"])}).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        # since we are actually reindexing with a Categorical\n        # then return a Categorical\n        cats = list(\"cabe\")\n\n        result = df.reindex(Categorical([\"a\", \"e\"], categories=cats))\n        expected = DataFrame(\n            {\"A\": [0, np.nan], \"B\": Series(list(\"ae\")).astype(CDT(cats))}\n        ).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex(Categorical([\"a\"], categories=cats))\n        expected = DataFrame(\n            {\"A\": [0], \"B\": Series(list(\"a\")).astype(CDT(cats))}\n        ).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex([\"a\", \"b\", \"e\"])\n        expected = DataFrame({\"A\": [0, 1, np.nan], \"B\": Series(list(\"abe\"))}).set_index(\n            \"B\"\n        )\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex([\"a\", \"b\"])\n        expected = DataFrame({\"A\": [0, 1], \"B\": Series(list(\"ab\"))}).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex([\"e\"])\n        expected = DataFrame({\"A\": [np.nan], \"B\": Series([\"e\"])}).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        # give back the type of categorical that we received\n        result = df.reindex(Categorical([\"a\", \"e\"], categories=cats, ordered=True))\n        expected = DataFrame(\n            {\"A\": [0, np.nan], \"B\": Series(list(\"ae\")).astype(CDT(cats, ordered=True))}\n        ).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex(Categorical([\"a\", \"d\"], categories=[\"a\", \"d\"]))\n        expected = DataFrame(\n            {\"A\": [0, np.nan], \"B\": Series(list(\"ad\")).astype(CDT([\"a\", \"d\"]))}\n        ).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        # passed duplicate indexers are not allowed\n        msg = \"cannot reindex from a duplicate axis\"\n        with pytest.raises(ValueError, match=msg):\n            self.df2.reindex([\"a\", \"b\"])\n\n        # args NotImplemented ATM\n        msg = r\"argument {} is not implemented for CategoricalIndex\\.reindex\"\n        with pytest.raises(NotImplementedError, match=msg.format(\"method\")):\n            df.reindex([\"a\"], method=\"ffill\")\n        with pytest.raises(NotImplementedError, match=msg.format(\"level\")):\n            df.reindex([\"a\"], level=1)\n        with pytest.raises(NotImplementedError, match=msg.format(\"limit\")):\n            df.reindex([\"a\"], limit=2)",
        "begin_line": 571,
        "end_line": 654,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_slice#656",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_slice(self)",
        "snippet": "    def test_loc_slice(self):\n        # GH9748\n        with pytest.raises(KeyError, match=\"1\"):\n            self.df.loc[1:5]\n\n        result = self.df.loc[\"b\":\"c\"]\n        expected = self.df.iloc[[2, 3, 4]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 656,
        "end_line": 663,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_and_at_with_categorical_index#665",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_and_at_with_categorical_index(self)",
        "snippet": "    def test_loc_and_at_with_categorical_index(self):\n        # GH 20629\n        s = Series([1, 2, 3], index=pd.CategoricalIndex([\"A\", \"B\", \"C\"]))\n        assert s.loc[\"A\"] == 1\n        assert s.at[\"A\"] == 1\n        df = DataFrame(\n            [[1, 2], [3, 4], [5, 6]], index=pd.CategoricalIndex([\"A\", \"B\", \"C\"])\n        )\n        assert df.loc[\"B\", 1] == 4\n        assert df.at[\"B\", 1] == 4",
        "begin_line": 665,
        "end_line": 674,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_boolean_selection#676",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_boolean_selection(self)",
        "snippet": "    def test_boolean_selection(self):\n\n        df3 = self.df3\n        df4 = self.df4\n\n        result = df3[df3.index == \"a\"]\n        expected = df3.iloc[[]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df4[df4.index == \"a\"]\n        expected = df4.iloc[[]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df3[df3.index == 1]\n        expected = df3.iloc[[0, 1, 3]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df4[df4.index == 1]\n        expected = df4.iloc[[0, 1, 3]]\n        tm.assert_frame_equal(result, expected)\n\n        # since we have an ordered categorical\n\n        # CategoricalIndex([1, 1, 2, 1, 3, 2],\n        #         categories=[3, 2, 1],\n        #         ordered=True,\n        #         name='B')\n        result = df3[df3.index < 2]\n        expected = df3.iloc[[4]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df3[df3.index > 1]\n        expected = df3.iloc[[]]\n        tm.assert_frame_equal(result, expected)\n\n        # unordered\n        # cannot be compared\n\n        # CategoricalIndex([1, 1, 2, 1, 3, 2],\n        #         categories=[3, 2, 1],\n        #         ordered=False,\n        #         name='B')\n        msg = \"Unordered Categoricals can only compare equality or not\"\n        with pytest.raises(TypeError, match=msg):\n            df4[df4.index < 2]\n        with pytest.raises(TypeError, match=msg):\n            df4[df4.index > 1]",
        "begin_line": 676,
        "end_line": 722,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_indexing_with_category#724",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_indexing_with_category(self)",
        "snippet": "    def test_indexing_with_category(self):\n\n        # https://github.com/pandas-dev/pandas/issues/12564\n        # consistent result if comparing as Dataframe\n\n        cat = DataFrame({\"A\": [\"foo\", \"bar\", \"baz\"]})\n        exp = DataFrame({\"A\": [True, False, False]})\n\n        res = cat[[\"A\"]] == \"foo\"\n        tm.assert_frame_equal(res, exp)\n\n        cat[\"A\"] = cat[\"A\"].astype(\"category\")\n\n        res = cat[[\"A\"]] == \"foo\"\n        tm.assert_frame_equal(res, exp)",
        "begin_line": 724,
        "end_line": 738,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_map_with_dict_or_series#740",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_map_with_dict_or_series(self)",
        "snippet": "    def test_map_with_dict_or_series(self):\n        orig_values = [\"a\", \"B\", 1, \"a\"]\n        new_values = [\"one\", 2, 3.0, \"one\"]\n        cur_index = pd.CategoricalIndex(orig_values, name=\"XXX\")\n        expected = pd.CategoricalIndex(\n            new_values, name=\"XXX\", categories=[3.0, 2, \"one\"]\n        )\n\n        mapper = pd.Series(new_values[:-1], index=orig_values[:-1])\n        output = cur_index.map(mapper)\n        # Order of categories in output can be different\n        tm.assert_index_equal(expected, output)\n\n        mapper = {o: n for o, n in zip(orig_values[:-1], new_values[:-1])}\n        output = cur_index.map(mapper)\n        # Order of categories in output can be different\n        tm.assert_index_equal(expected, output)",
        "begin_line": 740,
        "end_line": 756,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_with_non_string_categories#784",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_with_non_string_categories(self, idx_values, ordered_fixture)",
        "snippet": "    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):\n        # GH-17569\n        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)\n        df = DataFrame({\"A\": [\"foo\", \"bar\", \"baz\"]}, index=cat_idx)\n        sl = slice(idx_values[0], idx_values[1])\n\n        # scalar selection\n        result = df.loc[idx_values[0]]\n        expected = Series([\"foo\"], index=[\"A\"], name=idx_values[0])\n        tm.assert_series_equal(result, expected)\n\n        # list selection\n        result = df.loc[idx_values[:2]]\n        expected = DataFrame([\"foo\", \"bar\"], index=cat_idx[:2], columns=[\"A\"])\n        tm.assert_frame_equal(result, expected)\n\n        # slice selection\n        result = df.loc[sl]\n        expected = DataFrame([\"foo\", \"bar\"], index=cat_idx[:2], columns=[\"A\"])\n        tm.assert_frame_equal(result, expected)\n\n        # scalar assignment\n        result = df.copy()\n        result.loc[idx_values[0]] = \"qux\"\n        expected = DataFrame({\"A\": [\"qux\", \"bar\", \"baz\"]}, index=cat_idx)\n        tm.assert_frame_equal(result, expected)\n\n        # list assignment\n        result = df.copy()\n        result.loc[idx_values[:2], \"A\"] = [\"qux\", \"qux2\"]\n        expected = DataFrame({\"A\": [\"qux\", \"qux2\", \"baz\"]}, index=cat_idx)\n        tm.assert_frame_equal(result, expected)\n\n        # slice assignment\n        result = df.copy()\n        result.loc[sl, \"A\"] = [\"qux\", \"qux2\"]\n        expected = DataFrame({\"A\": [\"qux\", \"qux2\", \"baz\"]}, index=cat_idx)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 784,
        "end_line": 821,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.conftest.multiindex_dataframe_random_data#9",
        "src_path": "pandas/tests/indexing/multiindex/conftest.py",
        "class_name": "pandas.tests.indexing.multiindex.conftest",
        "signature": "pandas.tests.indexing.multiindex.conftest.multiindex_dataframe_random_data()",
        "snippet": "def multiindex_dataframe_random_data():\n    \"\"\"DataFrame with 2 level MultiIndex with random data\"\"\"\n    index = MultiIndex(\n        levels=[[\"foo\", \"bar\", \"baz\", \"qux\"], [\"one\", \"two\", \"three\"]],\n        codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],\n        names=[\"first\", \"second\"],\n    )\n    return DataFrame(\n        np.random.randn(10, 3), index=index, columns=Index([\"A\", \"B\", \"C\"], name=\"exp\")\n    )",
        "begin_line": 9,
        "end_line": 18,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.conftest.multiindex_year_month_day_dataframe_random_data#22",
        "src_path": "pandas/tests/indexing/multiindex/conftest.py",
        "class_name": "pandas.tests.indexing.multiindex.conftest",
        "signature": "pandas.tests.indexing.multiindex.conftest.multiindex_year_month_day_dataframe_random_data()",
        "snippet": "def multiindex_year_month_day_dataframe_random_data():\n    \"\"\"DataFrame with 3 level MultiIndex (year, month, day) covering\n    first 100 business days from 2000-01-01 with random data\"\"\"\n    tdf = tm.makeTimeDataFrame(100)\n    ymd = tdf.groupby([lambda x: x.year, lambda x: x.month, lambda x: x.day]).sum()\n    # use Int64Index, to make sure things work\n    ymd.index.set_levels([lev.astype(\"i8\") for lev in ymd.index.levels], inplace=True)\n    ymd.index.set_names([\"year\", \"month\", \"day\"], inplace=True)\n    return ymd",
        "begin_line": 22,
        "end_line": 30,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.conftest.numeric_indexing_engine_type_and_dtype#22",
        "src_path": "pandas/tests/indexing/conftest.py",
        "class_name": "pandas.tests.indexing.conftest",
        "signature": "pandas.tests.indexing.conftest.numeric_indexing_engine_type_and_dtype(request)",
        "snippet": "def numeric_indexing_engine_type_and_dtype(request):\n    return request.param",
        "begin_line": 22,
        "end_line": 23,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common._mklbl#13",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common",
        "signature": "pandas.tests.indexing.common._mklbl(prefix, n)",
        "snippet": "def _mklbl(prefix, n):\n    return [\"{prefix}{i}\".format(prefix=prefix, i=i) for i in range(n)]",
        "begin_line": 13,
        "end_line": 14,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common._axify#17",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common",
        "signature": "pandas.tests.indexing.common._axify(obj, key, axis)",
        "snippet": "def _axify(obj, key, axis):\n    # create a tuple accessor\n    axes = [slice(None)] * obj.ndim\n    axes[axis] = key\n    return tuple(axes)",
        "begin_line": 17,
        "end_line": 21,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.setup_method#40",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n\n        self.series_ints = Series(np.random.rand(4), index=np.arange(0, 8, 2))\n        self.frame_ints = DataFrame(\n            np.random.randn(4, 4), index=np.arange(0, 8, 2), columns=np.arange(0, 12, 3)\n        )\n\n        self.series_uints = Series(\n            np.random.rand(4), index=UInt64Index(np.arange(0, 8, 2))\n        )\n        self.frame_uints = DataFrame(\n            np.random.randn(4, 4),\n            index=UInt64Index(range(0, 8, 2)),\n            columns=UInt64Index(range(0, 12, 3)),\n        )\n\n        self.series_floats = Series(\n            np.random.rand(4), index=Float64Index(range(0, 8, 2))\n        )\n        self.frame_floats = DataFrame(\n            np.random.randn(4, 4),\n            index=Float64Index(range(0, 8, 2)),\n            columns=Float64Index(range(0, 12, 3)),\n        )\n\n        m_idces = [\n            MultiIndex.from_product([[1, 2], [3, 4]]),\n            MultiIndex.from_product([[5, 6], [7, 8]]),\n            MultiIndex.from_product([[9, 10], [11, 12]]),\n        ]\n\n        self.series_multi = Series(np.random.rand(4), index=m_idces[0])\n        self.frame_multi = DataFrame(\n            np.random.randn(4, 4), index=m_idces[0], columns=m_idces[1]\n        )\n\n        self.series_labels = Series(np.random.randn(4), index=list(\"abcd\"))\n        self.frame_labels = DataFrame(\n            np.random.randn(4, 4), index=list(\"abcd\"), columns=list(\"ABCD\")\n        )\n\n        self.series_mixed = Series(np.random.randn(4), index=[2, 4, \"null\", 8])\n        self.frame_mixed = DataFrame(np.random.randn(4, 4), index=[2, 4, \"null\", 8])\n\n        self.series_ts = Series(\n            np.random.randn(4), index=date_range(\"20130101\", periods=4)\n        )\n        self.frame_ts = DataFrame(\n            np.random.randn(4, 4), index=date_range(\"20130101\", periods=4)\n        )\n\n        dates_rev = date_range(\"20130101\", periods=4).sort_values(ascending=False)\n        self.series_ts_rev = Series(np.random.randn(4), index=dates_rev)\n        self.frame_ts_rev = DataFrame(np.random.randn(4, 4), index=dates_rev)\n\n        self.frame_empty = DataFrame()\n        self.series_empty = Series(dtype=object)\n\n        # form agglomerates\n        for kind in self._kinds:\n            d = dict()\n            for typ in self._typs:\n                d[typ] = getattr(self, \"{kind}_{typ}\".format(kind=kind, typ=typ))\n\n            setattr(self, kind, d)",
        "begin_line": 40,
        "end_line": 104,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.generate_indices#106",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.generate_indices(self, f, values=False)",
        "snippet": "    def generate_indices(self, f, values=False):\n        \"\"\" generate the indices\n        if values is True , use the axis values\n        is False, use the range\n        \"\"\"\n\n        axes = f.axes\n        if values:\n            axes = (list(range(len(ax))) for ax in axes)\n\n        return itertools.product(*axes)",
        "begin_line": 106,
        "end_line": 116,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.get_result#118",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.get_result(self, obj, method, key, axis)",
        "snippet": "    def get_result(self, obj, method, key, axis):\n        \"\"\" return the result for this obj with this key and this axis \"\"\"\n\n        if isinstance(key, dict):\n            key = key[axis]\n\n        # use an artificial conversion to map the key as integers to the labels\n        # so ix can work for comparisons\n        if method == \"indexer\":\n            method = \"ix\"\n            key = obj._get_axis(axis)[key]\n\n        # in case we actually want 0 index slicing\n        with catch_warnings(record=True):\n            try:\n                xp = getattr(obj, method).__getitem__(_axify(obj, key, axis))\n            except AttributeError:\n                xp = getattr(obj, method).__getitem__(key)\n\n        return xp",
        "begin_line": 118,
        "end_line": 137,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.get_value#139",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.get_value(self, name, f, i, values=False)",
        "snippet": "    def get_value(self, name, f, i, values=False):\n        \"\"\" return the value for the location i \"\"\"\n\n        # check against values\n        if values:\n            return f.values[i]\n\n        elif name == \"iat\":\n            return f.iloc[i]\n        else:\n            assert name == \"at\"\n            return f.loc[i]",
        "begin_line": 139,
        "end_line": 150,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.check_values#152",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.check_values(self, f, func, values=False)",
        "snippet": "    def check_values(self, f, func, values=False):\n\n        if f is None:\n            return\n        axes = f.axes\n        indicies = itertools.product(*axes)\n\n        for i in indicies:\n            result = getattr(f, func)[i]\n\n            # check against values\n            if values:\n                expected = f.values[i]\n            else:\n                expected = f\n                for a in reversed(i):\n                    expected = expected.__getitem__(a)\n\n            tm.assert_almost_equal(result, expected)",
        "begin_line": 152,
        "end_line": 170,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.check_result#172",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.check_result(self, method1, key1, method2, key2, typs=None, axes=None, fails=None)",
        "snippet": "    def check_result(\n        self, method1, key1, method2, key2, typs=None, axes=None, fails=None,\n    ):\n        def _eq(axis, obj, key1, key2):\n            \"\"\" compare equal for these 2 keys \"\"\"\n            if axis > obj.ndim - 1:\n                return\n\n            try:\n                rs = getattr(obj, method1).__getitem__(_axify(obj, key1, axis))\n\n                try:\n                    xp = self.get_result(obj=obj, method=method2, key=key2, axis=axis)\n                except (KeyError, IndexError):\n                    # TODO: why is this allowed?\n                    return\n\n                if is_scalar(rs) and is_scalar(xp):\n                    assert rs == xp\n                else:\n                    tm.assert_equal(rs, xp)\n\n            except (IndexError, TypeError, KeyError) as detail:\n\n                # if we are in fails, the ok, otherwise raise it\n                if fails is not None:\n                    if isinstance(detail, fails):\n                        result = f\"ok ({type(detail).__name__})\"\n                        return\n\n                result = type(detail).__name__\n                raise AssertionError(result, detail)\n\n        if typs is None:\n            typs = self._typs\n\n        if axes is None:\n            axes = [0, 1]\n        elif not isinstance(axes, (tuple, list)):\n            assert isinstance(axes, int)\n            axes = [axes]\n\n        # check\n        for kind in self._kinds:\n\n            d = getattr(self, kind)\n            for ax in axes:\n                for typ in typs:\n                    if typ not in self._typs:\n                        continue\n\n                    obj = d[typ]\n                    _eq(axis=ax, obj=obj, key1=key1, key2=key2)",
        "begin_line": 172,
        "end_line": 224,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base._eq#175",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base._eq(axis, obj, key1, key2)",
        "snippet": "        def _eq(axis, obj, key1, key2):\n            \"\"\" compare equal for these 2 keys \"\"\"\n            if axis > obj.ndim - 1:\n                return\n\n            try:\n                rs = getattr(obj, method1).__getitem__(_axify(obj, key1, axis))\n\n                try:\n                    xp = self.get_result(obj=obj, method=method2, key=key2, axis=axis)\n                except (KeyError, IndexError):\n                    # TODO: why is this allowed?\n                    return\n\n                if is_scalar(rs) and is_scalar(xp):\n                    assert rs == xp\n                else:\n                    tm.assert_equal(rs, xp)\n\n            except (IndexError, TypeError, KeyError) as detail:\n\n                # if we are in fails, the ok, otherwise raise it\n                if fails is not None:\n                    if isinstance(detail, fails):\n                        result = f\"ok ({type(detail).__name__})\"\n                        return\n\n                result = type(detail).__name__\n                raise AssertionError(result, detail)",
        "begin_line": 175,
        "end_line": 203,
        "comment": "",
        "is_bug": false
    }
]