[
    {
        "name": "lib.ansible.plugins.test.files.TestModule.tests#29",
        "src_path": "lib/ansible/plugins/test/files.py",
        "class_name": "lib.ansible.plugins.test.files.TestModule",
        "signature": "lib.ansible.plugins.test.files.TestModule.tests(self)",
        "snippet": "    def tests(self):\n        return {\n            # file testing\n            'is_dir': isdir,\n            'directory': isdir,\n            'is_file': isfile,\n            'file': isfile,\n            'is_link': islink,\n            'link': islink,\n            'exists': exists,\n            'link_exists': lexists,\n\n            # path testing\n            'is_abs': isabs,\n            'abs': isabs,\n            'is_same_file': samefile,\n            'same_file': samefile,\n            'is_mount': ismount,\n            'mount': ismount,\n        }",
        "begin_line": 29,
        "end_line": 48,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.vault_helper.TextVaultSecret.__init__#29",
        "src_path": "test/units/mock/vault_helper.py",
        "class_name": "test.units.mock.vault_helper.TextVaultSecret",
        "signature": "test.units.mock.vault_helper.TextVaultSecret.__init__(self, text, encoding=None, errors=None, _bytes=None)",
        "snippet": "    def __init__(self, text, encoding=None, errors=None, _bytes=None):\n        super(TextVaultSecret, self).__init__()\n        self.text = text\n        self.encoding = encoding or 'utf-8'\n        self._bytes = _bytes\n        self.errors = errors or 'strict'",
        "begin_line": 29,
        "end_line": 34,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.vault_helper.TextVaultSecret.bytes#37",
        "src_path": "test/units/mock/vault_helper.py",
        "class_name": "test.units.mock.vault_helper.TextVaultSecret",
        "signature": "test.units.mock.vault_helper.TextVaultSecret.bytes(self)",
        "snippet": "    def bytes(self):\n        '''The text encoded with encoding, unless we specifically set _bytes.'''\n        return self._bytes or to_bytes(self.text, encoding=self.encoding, errors=self.errors)",
        "begin_line": 37,
        "end_line": 39,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader.__init__#31",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader.__init__(self, file_mapping=None)",
        "snippet": "    def __init__(self, file_mapping=None):\n        file_mapping = {} if file_mapping is None else file_mapping\n        assert type(file_mapping) == dict\n\n        super(DictDataLoader, self).__init__()\n\n        self._file_mapping = file_mapping\n        self._build_known_directories()\n        self._vault_secrets = None",
        "begin_line": 31,
        "end_line": 39,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader.load_from_file#41",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader.load_from_file(self, path, cache=True, unsafe=False)",
        "snippet": "    def load_from_file(self, path, cache=True, unsafe=False):\n        path = to_text(path)\n        if path in self._file_mapping:\n            return self.load(self._file_mapping[path], path)\n        return None",
        "begin_line": 41,
        "end_line": 45,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader._get_file_contents#49",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader._get_file_contents(self, path)",
        "snippet": "    def _get_file_contents(self, path):\n        path = to_text(path)\n        if path in self._file_mapping:\n            return (to_bytes(self._file_mapping[path]), False)\n        else:\n            raise AnsibleParserError(\"file not found: %s\" % path)",
        "begin_line": 49,
        "end_line": 54,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader.path_exists#56",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader.path_exists(self, path)",
        "snippet": "    def path_exists(self, path):\n        path = to_text(path)\n        return path in self._file_mapping or path in self._known_directories",
        "begin_line": 56,
        "end_line": 58,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader.is_file#60",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader.is_file(self, path)",
        "snippet": "    def is_file(self, path):\n        path = to_text(path)\n        return path in self._file_mapping",
        "begin_line": 60,
        "end_line": 62,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader.is_directory#64",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader.is_directory(self, path)",
        "snippet": "    def is_directory(self, path):\n        path = to_text(path)\n        return path in self._known_directories",
        "begin_line": 64,
        "end_line": 66,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader.list_directory#68",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader.list_directory(self, path)",
        "snippet": "    def list_directory(self, path):\n        ret = []\n        path = to_text(path)\n        for x in (list(self._file_mapping.keys()) + self._known_directories):\n            if x.startswith(path):\n                if os.path.dirname(x) == path:\n                    ret.append(os.path.basename(x))\n        return ret",
        "begin_line": 68,
        "end_line": 75,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader.is_executable#77",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader.is_executable(self, path)",
        "snippet": "    def is_executable(self, path):\n        # FIXME: figure out a way to make paths return true for this\n        return False",
        "begin_line": 77,
        "end_line": 79,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader._add_known_directory#81",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader._add_known_directory(self, directory)",
        "snippet": "    def _add_known_directory(self, directory):\n        if directory not in self._known_directories:\n            self._known_directories.append(directory)",
        "begin_line": 81,
        "end_line": 83,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader._build_known_directories#85",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader._build_known_directories(self)",
        "snippet": "    def _build_known_directories(self):\n        self._known_directories = []\n        for path in self._file_mapping:\n            dirname = os.path.dirname(path)\n            while dirname not in ('/', ''):\n                self._add_known_directory(dirname)\n                dirname = os.path.dirname(dirname)",
        "begin_line": 85,
        "end_line": 91,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader.get_basedir#112",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader.get_basedir(self)",
        "snippet": "    def get_basedir(self):\n        return os.getcwd()",
        "begin_line": 112,
        "end_line": 113,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.loader.DictDataLoader.set_vault_secrets#115",
        "src_path": "test/units/mock/loader.py",
        "class_name": "test.units.mock.loader.DictDataLoader",
        "signature": "test.units.mock.loader.DictDataLoader.set_vault_secrets(self, vault_secrets)",
        "snippet": "    def set_vault_secrets(self, vault_secrets):\n        self._vault_secrets = vault_secrets",
        "begin_line": 115,
        "end_line": 116,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.mathstuff.issubset#24",
        "src_path": "lib/ansible/plugins/test/mathstuff.py",
        "class_name": "lib.ansible.plugins.test.mathstuff",
        "signature": "lib.ansible.plugins.test.mathstuff.issubset(a, b)",
        "snippet": "def issubset(a, b):\n    return set(a) <= set(b)",
        "begin_line": 24,
        "end_line": 25,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.mathstuff.issuperset#28",
        "src_path": "lib/ansible/plugins/test/mathstuff.py",
        "class_name": "lib.ansible.plugins.test.mathstuff",
        "signature": "lib.ansible.plugins.test.mathstuff.issuperset(a, b)",
        "snippet": "def issuperset(a, b):\n    return set(a) >= set(b)",
        "begin_line": 28,
        "end_line": 29,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.mathstuff.isnotanumber#32",
        "src_path": "lib/ansible/plugins/test/mathstuff.py",
        "class_name": "lib.ansible.plugins.test.mathstuff",
        "signature": "lib.ansible.plugins.test.mathstuff.isnotanumber(x)",
        "snippet": "def isnotanumber(x):\n    try:\n        return math.isnan(x)\n    except TypeError:\n        return False",
        "begin_line": 32,
        "end_line": 36,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.mathstuff.contains#39",
        "src_path": "lib/ansible/plugins/test/mathstuff.py",
        "class_name": "lib.ansible.plugins.test.mathstuff",
        "signature": "lib.ansible.plugins.test.mathstuff.contains(seq, value)",
        "snippet": "def contains(seq, value):\n    '''Opposite of the ``in`` test, allowing use as a test in filters like ``selectattr``\n\n    .. versionadded:: 2.8\n    '''\n    return value in seq",
        "begin_line": 39,
        "end_line": 44,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.mathstuff.TestModule.tests#50",
        "src_path": "lib/ansible/plugins/test/mathstuff.py",
        "class_name": "lib.ansible.plugins.test.mathstuff.TestModule",
        "signature": "lib.ansible.plugins.test.mathstuff.TestModule.tests(self)",
        "snippet": "    def tests(self):\n        return {\n            # set theory\n            'issubset': issubset,\n            'subset': issubset,\n            'issuperset': issuperset,\n            'superset': issuperset,\n            'contains': contains,\n\n            # numbers\n            'isnan': isnotanumber,\n            'nan': isnotanumber,\n        }",
        "begin_line": 50,
        "end_line": 62,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.failed#35",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.failed(result)",
        "snippet": "def failed(result):\n    ''' Test if task result yields failed '''\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'failed' test expects a dictionary\")\n    return result.get('failed', False)",
        "begin_line": 35,
        "end_line": 39,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.success#42",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.success(result)",
        "snippet": "def success(result):\n    ''' Test if task result yields success '''\n    return not failed(result)",
        "begin_line": 42,
        "end_line": 44,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.unreachable#47",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.unreachable(result)",
        "snippet": "def unreachable(result):\n    ''' Test if task result yields unreachable '''\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'unreachable' test expects a dictionary\")\n    return result.get('unreachable', False)",
        "begin_line": 47,
        "end_line": 51,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.reachable#54",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.reachable(result)",
        "snippet": "def reachable(result):\n    ''' Test if task result yields reachable '''\n    return not unreachable(result)",
        "begin_line": 54,
        "end_line": 56,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.changed#59",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.changed(result)",
        "snippet": "def changed(result):\n    ''' Test if task result yields changed '''\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'changed' test expects a dictionary\")\n    if 'changed' not in result:\n        changed = False\n        if (\n            'results' in result and   # some modules return a 'results' key\n            isinstance(result['results'], MutableSequence) and\n            isinstance(result['results'][0], MutableMapping)\n        ):\n            for res in result['results']:\n                if res.get('changed', False):\n                    changed = True\n                    break\n    else:\n        changed = result.get('changed', False)\n    return changed",
        "begin_line": 59,
        "end_line": 76,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.skipped#79",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.skipped(result)",
        "snippet": "def skipped(result):\n    ''' Test if task result yields skipped '''\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'skipped' test expects a dictionary\")\n    return result.get('skipped', False)",
        "begin_line": 79,
        "end_line": 83,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.started#86",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.started(result)",
        "snippet": "def started(result):\n    ''' Test if async task has started '''\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'started' test expects a dictionary\")\n    if 'started' in result:\n        # For async tasks, return status\n        # NOTE: The value of started is 0 or 1, not False or True :-/\n        return result.get('started', 0) == 1\n    else:\n        # For non-async tasks, warn user, but return as if started\n        display.warning(\"The 'started' test expects an async task, but a non-async task was tested\")\n        return True",
        "begin_line": 86,
        "end_line": 97,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.finished#100",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.finished(result)",
        "snippet": "def finished(result):\n    ''' Test if async task has finished '''\n    if not isinstance(result, MutableMapping):\n        raise errors.AnsibleFilterError(\"The 'finished' test expects a dictionary\")\n    if 'finished' in result:\n        # For async tasks, return status\n        # NOTE: The value of finished is 0 or 1, not False or True :-/\n        return result.get('finished', 0) == 1\n    else:\n        # For non-async tasks, warn user, but return as if finished\n        display.warning(\"The 'finished' test expects an async task, but a non-async task was tested\")\n        return True",
        "begin_line": 100,
        "end_line": 111,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.regex#114",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.regex(value='', pattern='', ignorecase=False, multiline=False, match_type='search')",
        "snippet": "def regex(value='', pattern='', ignorecase=False, multiline=False, match_type='search'):\n    ''' Expose `re` as a boolean filter using the `search` method by default.\n        This is likely only useful for `search` and `match` which already\n        have their own filters.\n    '''\n    # In addition to ensuring the correct type, to_text here will ensure\n    # _fail_with_undefined_error happens if the value is Undefined\n    value = to_text(value, errors='surrogate_or_strict')\n    flags = 0\n    if ignorecase:\n        flags |= re.I\n    if multiline:\n        flags |= re.M\n    _re = re.compile(pattern, flags=flags)\n    return bool(getattr(_re, match_type, 'search')(value))",
        "begin_line": 114,
        "end_line": 128,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.match#131",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.match(value, pattern='', ignorecase=False, multiline=False)",
        "snippet": "def match(value, pattern='', ignorecase=False, multiline=False):\n    ''' Perform a `re.match` returning a boolean '''\n    return regex(value, pattern, ignorecase, multiline, 'match')",
        "begin_line": 131,
        "end_line": 133,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.search#136",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.search(value, pattern='', ignorecase=False, multiline=False)",
        "snippet": "def search(value, pattern='', ignorecase=False, multiline=False):\n    ''' Perform a `re.search` returning a boolean '''\n    return regex(value, pattern, ignorecase, multiline, 'search')",
        "begin_line": 136,
        "end_line": 138,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.version_compare#141",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.version_compare(value, version, operator='eq', strict=False)",
        "snippet": "def version_compare(value, version, operator='eq', strict=False):\n    ''' Perform a version comparison on a value '''\n    op_map = {\n        '==': 'eq', '=': 'eq', 'eq': 'eq',\n        '<': 'lt', 'lt': 'lt',\n        '<=': 'le', 'le': 'le',\n        '>': 'gt', 'gt': 'gt',\n        '>=': 'ge', 'ge': 'ge',\n        '!=': 'ne', '<>': 'ne', 'ne': 'ne'\n    }\n\n    if strict:\n        Version = StrictVersion\n    else:\n        Version = LooseVersion\n\n    if operator in op_map:\n        operator = op_map[operator]\n    else:\n        raise errors.AnsibleFilterError('Invalid operator type')\n\n    try:\n        method = getattr(py_operator, operator)\n        return method(Version(str(value)), Version(str(version)))\n    except Exception as e:\n        raise errors.AnsibleFilterError('Version comparison: %s' % e)",
        "begin_line": 141,
        "end_line": 166,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.truthy#169",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.truthy(value, convert_bool=False)",
        "snippet": "def truthy(value, convert_bool=False):\n    \"\"\"Evaluate as value for truthiness using python ``bool``\n\n    Optionally, attempt to do a conversion to bool from boolean like values\n    such as ``\"false\"``, ``\"true\"``, ``\"yes\"``, ``\"no\"``, ``\"on\"``, ``\"off\"``, etc.\n\n    .. versionadded:: 2.10\n    \"\"\"\n    if convert_bool:\n        try:\n            value = boolean(value)\n        except TypeError:\n            pass\n\n    return bool(value)",
        "begin_line": 169,
        "end_line": 183,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.falsy#186",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core",
        "signature": "lib.ansible.plugins.test.core.falsy(value, convert_bool=False)",
        "snippet": "def falsy(value, convert_bool=False):\n    \"\"\"Evaluate as value for falsiness using python ``bool``\n\n    Optionally, attempt to do a conversion to bool from boolean like values\n    such as ``\"false\"``, ``\"true\"``, ``\"yes\"``, ``\"no\"``, ``\"on\"``, ``\"off\"``, etc.\n\n    .. versionadded:: 2.10\n    \"\"\"\n    return not truthy(value, convert_bool=convert_bool)",
        "begin_line": 186,
        "end_line": 194,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.ansible.plugins.test.core.TestModule.tests#200",
        "src_path": "lib/ansible/plugins/test/core.py",
        "class_name": "lib.ansible.plugins.test.core.TestModule",
        "signature": "lib.ansible.plugins.test.core.TestModule.tests(self)",
        "snippet": "    def tests(self):\n        return {\n            # failure testing\n            'failed': failed,\n            'failure': failed,\n            'succeeded': success,\n            'success': success,\n            'successful': success,\n            'reachable': reachable,\n            'unreachable': unreachable,\n\n            # changed testing\n            'changed': changed,\n            'change': changed,\n\n            # skip testing\n            'skipped': skipped,\n            'skip': skipped,\n\n            # async testing\n            'finished': finished,\n            'started': started,\n\n            # regex\n            'match': match,\n            'search': search,\n            'regex': regex,\n\n            # version comparison\n            'version_compare': version_compare,\n            'version': version_compare,\n\n            # lists\n            'any': any,\n            'all': all,\n\n            # truthiness\n            'truthy': truthy,\n            'falsy': falsy,\n        }",
        "begin_line": 200,
        "end_line": 239,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.yaml_helper.YamlTestUtils._dump_stream#17",
        "src_path": "test/units/mock/yaml_helper.py",
        "class_name": "test.units.mock.yaml_helper.YamlTestUtils",
        "signature": "test.units.mock.yaml_helper.YamlTestUtils._dump_stream(self, obj, stream, dumper=None)",
        "snippet": "    def _dump_stream(self, obj, stream, dumper=None):\n        \"\"\"Dump to a py2-unicode or py3-string stream.\"\"\"\n        if PY3:\n            return yaml.dump(obj, stream, Dumper=dumper)\n        else:\n            return yaml.dump(obj, stream, Dumper=dumper, encoding=None)",
        "begin_line": 17,
        "end_line": 22,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.yaml_helper.YamlTestUtils._dump_string#24",
        "src_path": "test/units/mock/yaml_helper.py",
        "class_name": "test.units.mock.yaml_helper.YamlTestUtils",
        "signature": "test.units.mock.yaml_helper.YamlTestUtils._dump_string(self, obj, dumper=None)",
        "snippet": "    def _dump_string(self, obj, dumper=None):\n        \"\"\"Dump to a py2-unicode or py3-string\"\"\"\n        if PY3:\n            return yaml.dump(obj, Dumper=dumper)\n        else:\n            return yaml.dump(obj, Dumper=dumper, encoding=None)",
        "begin_line": 24,
        "end_line": 29,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.yaml_helper.YamlTestUtils._dump_load_cycle#31",
        "src_path": "test/units/mock/yaml_helper.py",
        "class_name": "test.units.mock.yaml_helper.YamlTestUtils",
        "signature": "test.units.mock.yaml_helper.YamlTestUtils._dump_load_cycle(self, obj)",
        "snippet": "    def _dump_load_cycle(self, obj):\n        # Each pass though a dump or load revs the 'generation'\n        # obj to yaml string\n        string_from_object_dump = self._dump_string(obj, dumper=AnsibleDumper)\n\n        # wrap a stream/file like StringIO around that yaml\n        stream_from_object_dump = io.StringIO(string_from_object_dump)\n        loader = self._loader(stream_from_object_dump)\n        # load the yaml stream to create a new instance of the object (gen 2)\n        obj_2 = loader.get_data()\n\n        # dump the gen 2 objects directory to strings\n        string_from_object_dump_2 = self._dump_string(obj_2,\n                                                      dumper=AnsibleDumper)\n\n        # The gen 1 and gen 2 yaml strings\n        self.assertEqual(string_from_object_dump, string_from_object_dump_2)\n        # the gen 1 (orig) and gen 2 py object\n        self.assertEqual(obj, obj_2)\n\n        # again! gen 3... load strings into py objects\n        stream_3 = io.StringIO(string_from_object_dump_2)\n        loader_3 = self._loader(stream_3)\n        obj_3 = loader_3.get_data()\n\n        string_from_object_dump_3 = self._dump_string(obj_3, dumper=AnsibleDumper)\n\n        self.assertEqual(obj, obj_3)\n        # should be transitive, but...\n        self.assertEqual(obj_2, obj_3)\n        self.assertEqual(string_from_object_dump, string_from_object_dump_3)",
        "begin_line": 31,
        "end_line": 61,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.modules.utils.set_module_args#9",
        "src_path": "test/units/modules/utils.py",
        "class_name": "test.units.modules.utils",
        "signature": "test.units.modules.utils.set_module_args(args)",
        "snippet": "def set_module_args(args):\n    if '_ansible_remote_tmp' not in args:\n        args['_ansible_remote_tmp'] = '/tmp'\n    if '_ansible_keep_remote_files' not in args:\n        args['_ansible_keep_remote_files'] = False\n\n    args = json.dumps({'ANSIBLE_MODULE_ARGS': args})\n    basic._ANSIBLE_ARGS = to_bytes(args)",
        "begin_line": 9,
        "end_line": 16,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.modules.utils.exit_json#27",
        "src_path": "test/units/modules/utils.py",
        "class_name": "test.units.modules.utils",
        "signature": "test.units.modules.utils.exit_json(*args, **kwargs)",
        "snippet": "def exit_json(*args, **kwargs):\n    if 'changed' not in kwargs:\n        kwargs['changed'] = False\n    raise AnsibleExitJson(kwargs)",
        "begin_line": 27,
        "end_line": 30,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.modules.utils.fail_json#33",
        "src_path": "test/units/modules/utils.py",
        "class_name": "test.units.modules.utils",
        "signature": "test.units.modules.utils.fail_json(*args, **kwargs)",
        "snippet": "def fail_json(*args, **kwargs):\n    kwargs['failed'] = True\n    raise AnsibleFailJson(kwargs)",
        "begin_line": 33,
        "end_line": 35,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.modules.utils.ModuleTestCase.setUp#40",
        "src_path": "test/units/modules/utils.py",
        "class_name": "test.units.modules.utils.ModuleTestCase",
        "signature": "test.units.modules.utils.ModuleTestCase.setUp(self)",
        "snippet": "    def setUp(self):\n        self.mock_module = patch.multiple(basic.AnsibleModule, exit_json=exit_json, fail_json=fail_json)\n        self.mock_module.start()\n        self.mock_sleep = patch('time.sleep')\n        self.mock_sleep.start()\n        set_module_args({})\n        self.addCleanup(self.mock_module.stop)\n        self.addCleanup(self.mock_sleep.stop)",
        "begin_line": 40,
        "end_line": 47,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.facts.base.BaseFactsTest._mock_module#40",
        "src_path": "test/units/module_utils/facts/base.py",
        "class_name": "test.units.module_utils.facts.base.BaseFactsTest",
        "signature": "test.units.module_utils.facts.base.BaseFactsTest._mock_module(self)",
        "snippet": "    def _mock_module(self):\n        mock_module = Mock()\n        mock_module.params = {'gather_subset': self.gather_subset,\n                              'gather_timeout': 5,\n                              'filter': '*'}\n        mock_module.get_bin_path = Mock(return_value=None)\n        return mock_module",
        "begin_line": 40,
        "end_line": 46,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.facts.base.BaseFactsTest.test_collect#50",
        "src_path": "test/units/module_utils/facts/base.py",
        "class_name": "test.units.module_utils.facts.base.BaseFactsTest",
        "signature": "test.units.module_utils.facts.base.BaseFactsTest.test_collect(self, mock_gfc, mock_ps)",
        "snippet": "    def test_collect(self, mock_gfc, mock_ps):\n        module = self._mock_module()\n        fact_collector = self.collector_class()\n        facts_dict = fact_collector.collect(module=module, collected_facts=self.collected_facts)\n        self.assertIsInstance(facts_dict, dict)\n        return facts_dict",
        "begin_line": 50,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.module_utils.facts.base.BaseFactsTest.test_collect_with_namespace#59",
        "src_path": "test/units/module_utils/facts/base.py",
        "class_name": "test.units.module_utils.facts.base.BaseFactsTest",
        "signature": "test.units.module_utils.facts.base.BaseFactsTest.test_collect_with_namespace(self, mock_gfc, mock_ps)",
        "snippet": "    def test_collect_with_namespace(self, mock_gfc, mock_ps):\n        module = self._mock_module()\n        fact_collector = self.collector_class()\n        facts_dict = fact_collector.collect_with_namespace(module=module,\n                                                           collected_facts=self.collected_facts)\n        self.assertIsInstance(facts_dict, dict)\n        return facts_dict",
        "begin_line": 59,
        "end_line": 65,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.plugins.loader_fixtures.import_fixture.test.__init__#7",
        "src_path": "test/units/plugins/loader_fixtures/import_fixture.py",
        "class_name": "test.units.plugins.loader_fixtures.import_fixture.test",
        "signature": "test.units.plugins.loader_fixtures.import_fixture.test.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        pass",
        "begin_line": 7,
        "end_line": 8,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.reset_cli_args#32",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.reset_cli_args()",
        "snippet": "def reset_cli_args():\n    co.GlobalCLIArgs._Singleton__instance = None\n    yield\n    co.GlobalCLIArgs._Singleton__instance = None",
        "begin_line": 32,
        "end_line": 35,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.collection_input#39",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.collection_input(tmp_path_factory)",
        "snippet": "def collection_input(tmp_path_factory):\n    ''' Creates a collection skeleton directory for build tests '''\n    test_dir = to_text(tmp_path_factory.mktemp('test-\u00c5\u00d1\u015a\u00cc\u03b2\u0141\u00c8 Collections Input'))\n    namespace = 'ansible_namespace'\n    collection = 'collection'\n    skeleton = os.path.join(os.path.dirname(os.path.split(__file__)[0]), 'cli', 'test_data', 'collection_skeleton')\n\n    galaxy_args = ['ansible-galaxy', 'collection', 'init', '%s.%s' % (namespace, collection),\n                   '-c', '--init-path', test_dir, '--collection-skeleton', skeleton]\n    GalaxyCLI(args=galaxy_args).run()\n    collection_dir = os.path.join(test_dir, namespace, collection)\n    output_dir = to_text(tmp_path_factory.mktemp('test-\u00c5\u00d1\u015a\u00cc\u03b2\u0141\u00c8 Collections Output'))\n\n    return collection_dir, output_dir",
        "begin_line": 39,
        "end_line": 52,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.collection_artifact#56",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.collection_artifact(monkeypatch, tmp_path_factory)",
        "snippet": "def collection_artifact(monkeypatch, tmp_path_factory):\n    ''' Creates a temp collection artifact and mocked open_url instance for publishing tests '''\n    mock_open = MagicMock()\n    monkeypatch.setattr(collection, 'open_url', mock_open)\n\n    mock_uuid = MagicMock()\n    mock_uuid.return_value.hex = 'uuid'\n    monkeypatch.setattr(uuid, 'uuid4', mock_uuid)\n\n    tmp_path = tmp_path_factory.mktemp('test-\u00c5\u00d1\u015a\u00cc\u03b2\u0141\u00c8 Collections')\n    input_file = to_text(tmp_path / 'collection.tar.gz')\n\n    with tarfile.open(input_file, 'w:gz') as tfile:\n        b_io = BytesIO(b\"\\x00\\x01\\x02\\x03\")\n        tar_info = tarfile.TarInfo('test')\n        tar_info.size = 4\n        tar_info.mode = 0o0644\n        tfile.addfile(tarinfo=tar_info, fileobj=b_io)\n\n    return input_file, mock_open",
        "begin_line": 56,
        "end_line": 75,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.galaxy_yml#79",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.galaxy_yml(request, tmp_path_factory)",
        "snippet": "def galaxy_yml(request, tmp_path_factory):\n    b_test_dir = to_bytes(tmp_path_factory.mktemp('test-\u00c5\u00d1\u015a\u00cc\u03b2\u0141\u00c8 Collections'))\n    b_galaxy_yml = os.path.join(b_test_dir, b'galaxy.yml')\n    with open(b_galaxy_yml, 'wb') as galaxy_obj:\n        galaxy_obj.write(to_bytes(request.param))\n\n    yield b_galaxy_yml",
        "begin_line": 79,
        "end_line": 85,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.tmp_tarfile#89",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.tmp_tarfile(tmp_path_factory, manifest_info)",
        "snippet": "def tmp_tarfile(tmp_path_factory, manifest_info):\n    ''' Creates a temporary tar file for _extract_tar_file tests '''\n    filename = u'\u00c5\u00d1\u015a\u00cc\u03b2\u0141\u00c8'\n    temp_dir = to_bytes(tmp_path_factory.mktemp('test-%s Collections' % to_native(filename)))\n    tar_file = os.path.join(temp_dir, to_bytes('%s.tar.gz' % filename))\n    data = os.urandom(8)\n\n    with tarfile.open(tar_file, 'w:gz') as tfile:\n        b_io = BytesIO(data)\n        tar_info = tarfile.TarInfo(filename)\n        tar_info.size = len(data)\n        tar_info.mode = 0o0644\n        tfile.addfile(tarinfo=tar_info, fileobj=b_io)\n\n        b_data = to_bytes(json.dumps(manifest_info, indent=True), errors='surrogate_or_strict')\n        b_io = BytesIO(b_data)\n        tar_info = tarfile.TarInfo('MANIFEST.json')\n        tar_info.size = len(b_data)\n        tar_info.mode = 0o0644\n        tfile.addfile(tarinfo=tar_info, fileobj=b_io)\n\n    sha256_hash = sha256()\n    sha256_hash.update(data)\n\n    with tarfile.open(tar_file, 'r') as tfile:\n        yield temp_dir, tfile, filename, sha256_hash.hexdigest()",
        "begin_line": 89,
        "end_line": 114,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.galaxy_server#118",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.galaxy_server()",
        "snippet": "def galaxy_server():\n    context.CLIARGS._store = {'ignore_certs': False}\n    galaxy_api = api.GalaxyAPI(None, 'test_server', 'https://galaxy.ansible.com',\n                               token=token.GalaxyToken(token='key'))\n    return galaxy_api",
        "begin_line": 118,
        "end_line": 122,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.manifest_template#126",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.manifest_template()",
        "snippet": "def manifest_template():\n    def get_manifest_info(namespace='ansible_namespace', name='collection', version='0.1.0'):\n        return {\n            \"collection_info\": {\n                \"namespace\": namespace,\n                \"name\": name,\n                \"version\": version,\n                \"authors\": [\n                    \"shertel\"\n                ],\n                \"readme\": \"README.md\",\n                \"tags\": [\n                    \"test\",\n                    \"collection\"\n                ],\n                \"description\": \"Test\",\n                \"license\": [\n                    \"MIT\"\n                ],\n                \"license_file\": None,\n                \"dependencies\": {},\n                \"repository\": \"https://github.com/{0}/{1}\".format(namespace, name),\n                \"documentation\": None,\n                \"homepage\": None,\n                \"issues\": None\n            },\n            \"file_manifest_file\": {\n                \"name\": \"FILES.json\",\n                \"ftype\": \"file\",\n                \"chksum_type\": \"sha256\",\n                \"chksum_sha256\": \"files_manifest_checksum\",\n                \"format\": 1\n            },\n            \"format\": 1\n        }\n\n    return get_manifest_info",
        "begin_line": 126,
        "end_line": 162,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.get_manifest_info#127",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.get_manifest_info(namespace='ansible_namespace', name='collection', version='0.1.0')",
        "snippet": "    def get_manifest_info(namespace='ansible_namespace', name='collection', version='0.1.0'):\n        return {\n            \"collection_info\": {\n                \"namespace\": namespace,\n                \"name\": name,\n                \"version\": version,\n                \"authors\": [\n                    \"shertel\"\n                ],\n                \"readme\": \"README.md\",\n                \"tags\": [\n                    \"test\",\n                    \"collection\"\n                ],\n                \"description\": \"Test\",\n                \"license\": [\n                    \"MIT\"\n                ],\n                \"license_file\": None,\n                \"dependencies\": {},\n                \"repository\": \"https://github.com/{0}/{1}\".format(namespace, name),\n                \"documentation\": None,\n                \"homepage\": None,\n                \"issues\": None\n            },\n            \"file_manifest_file\": {\n                \"name\": \"FILES.json\",\n                \"ftype\": \"file\",\n                \"chksum_type\": \"sha256\",\n                \"chksum_sha256\": \"files_manifest_checksum\",\n                \"format\": 1\n            },\n            \"format\": 1\n        }",
        "begin_line": 127,
        "end_line": 160,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.manifest_info#166",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.manifest_info(manifest_template)",
        "snippet": "def manifest_info(manifest_template):\n    return manifest_template()",
        "begin_line": 166,
        "end_line": 167,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.files_manifest_info#171",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.files_manifest_info()",
        "snippet": "def files_manifest_info():\n    return {\n        \"files\": [\n            {\n                \"name\": \".\",\n                \"ftype\": \"dir\",\n                \"chksum_type\": None,\n                \"chksum_sha256\": None,\n                \"format\": 1\n            },\n            {\n                \"name\": \"README.md\",\n                \"ftype\": \"file\",\n                \"chksum_type\": \"sha256\",\n                \"chksum_sha256\": \"individual_file_checksum\",\n                \"format\": 1\n            }\n        ],\n        \"format\": 1}",
        "begin_line": 171,
        "end_line": 189,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.manifest#193",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.manifest(manifest_info)",
        "snippet": "def manifest(manifest_info):\n    b_data = to_bytes(json.dumps(manifest_info))\n\n    with patch.object(builtins, 'open', mock_open(read_data=b_data)) as m:\n        with open('MANIFEST.json', mode='rb') as fake_file:\n            yield fake_file, sha256(b_data).hexdigest()",
        "begin_line": 193,
        "end_line": 198,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.mock_collection#202",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.mock_collection(galaxy_server)",
        "snippet": "def mock_collection(galaxy_server):\n    def create_mock_collection(namespace='ansible_namespace', name='collection', version='0.1.0', local=True, local_installed=True):\n        b_path = None\n        force = False\n\n        if local:\n            mock_collection = collection.CollectionRequirement(namespace, name, b_path, galaxy_server, [version], version, force, skip=local_installed)\n        else:\n            download_url = 'https://galaxy.ansible.com/download/{0}-{1}-{2}.tar.gz'.format(namespace, name, version)\n            digest = '19415a6a6df831df61cffde4a09d1d89ac8d8ca5c0586e85bea0b106d6dff29a'\n            dependencies = {}\n            metadata = api.CollectionVersionMetadata(namespace, name, version, download_url, digest, dependencies)\n            mock_collection = collection.CollectionRequirement(namespace, name, b_path, galaxy_server, [version], version, force, metadata=metadata)\n\n        return mock_collection\n    return create_mock_collection",
        "begin_line": 202,
        "end_line": 217,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.create_mock_collection#203",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.create_mock_collection(namespace='ansible_namespace', name='collection', version='0.1.0', local=True, local_installed=True)",
        "snippet": "    def create_mock_collection(namespace='ansible_namespace', name='collection', version='0.1.0', local=True, local_installed=True):\n        b_path = None\n        force = False\n\n        if local:\n            mock_collection = collection.CollectionRequirement(namespace, name, b_path, galaxy_server, [version], version, force, skip=local_installed)\n        else:\n            download_url = 'https://galaxy.ansible.com/download/{0}-{1}-{2}.tar.gz'.format(namespace, name, version)\n            digest = '19415a6a6df831df61cffde4a09d1d89ac8d8ca5c0586e85bea0b106d6dff29a'\n            dependencies = {}\n            metadata = api.CollectionVersionMetadata(namespace, name, version, download_url, digest, dependencies)\n            mock_collection = collection.CollectionRequirement(namespace, name, b_path, galaxy_server, [version], version, force, metadata=metadata)\n\n        return mock_collection",
        "begin_line": 203,
        "end_line": 216,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_build_collection_no_galaxy_yaml#220",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_build_collection_no_galaxy_yaml()",
        "snippet": "def test_build_collection_no_galaxy_yaml():\n    fake_path = u'/fake/\u00c5\u00d1\u015a\u00cc\u03b2\u0141\u00c8/path'\n    expected = to_native(\"The collection galaxy.yml path '%s/galaxy.yml' does not exist.\" % fake_path)\n\n    with pytest.raises(AnsibleError, match=expected):\n        collection.build_collection(fake_path, 'output', False)",
        "begin_line": 220,
        "end_line": 225,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_build_existing_output_file#228",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_build_existing_output_file(collection_input)",
        "snippet": "def test_build_existing_output_file(collection_input):\n    input_dir, output_dir = collection_input\n\n    existing_output_dir = os.path.join(output_dir, 'ansible_namespace-collection-0.1.0.tar.gz')\n    os.makedirs(existing_output_dir)\n\n    expected = \"The output collection artifact '%s' already exists, but is a directory - aborting\" \\\n               % to_native(existing_output_dir)\n    with pytest.raises(AnsibleError, match=expected):\n        collection.build_collection(input_dir, output_dir, False)",
        "begin_line": 228,
        "end_line": 237,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_build_existing_output_without_force#240",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_build_existing_output_without_force(collection_input)",
        "snippet": "def test_build_existing_output_without_force(collection_input):\n    input_dir, output_dir = collection_input\n\n    existing_output = os.path.join(output_dir, 'ansible_namespace-collection-0.1.0.tar.gz')\n    with open(existing_output, 'w+') as out_file:\n        out_file.write(\"random garbage\")\n        out_file.flush()\n\n    expected = \"The file '%s' already exists. You can use --force to re-create the collection artifact.\" \\\n               % to_native(existing_output)\n    with pytest.raises(AnsibleError, match=expected):\n        collection.build_collection(input_dir, output_dir, False)",
        "begin_line": 240,
        "end_line": 251,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_build_existing_output_with_force#254",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_build_existing_output_with_force(collection_input)",
        "snippet": "def test_build_existing_output_with_force(collection_input):\n    input_dir, output_dir = collection_input\n\n    existing_output = os.path.join(output_dir, 'ansible_namespace-collection-0.1.0.tar.gz')\n    with open(existing_output, 'w+') as out_file:\n        out_file.write(\"random garbage\")\n        out_file.flush()\n\n    collection.build_collection(input_dir, output_dir, True)\n\n    # Verify the file was replaced with an actual tar file\n    assert tarfile.is_tarfile(existing_output)",
        "begin_line": 254,
        "end_line": 265,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_invalid_yaml_galaxy_file#269",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_invalid_yaml_galaxy_file(galaxy_yml)",
        "snippet": "def test_invalid_yaml_galaxy_file(galaxy_yml):\n    expected = to_native(b\"Failed to parse the galaxy.yml at '%s' with the following error:\" % galaxy_yml)\n\n    with pytest.raises(AnsibleError, match=expected):\n        collection._get_galaxy_yml(galaxy_yml)",
        "begin_line": 269,
        "end_line": 273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_missing_required_galaxy_key#277",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_missing_required_galaxy_key(galaxy_yml)",
        "snippet": "def test_missing_required_galaxy_key(galaxy_yml):\n    expected = \"The collection galaxy.yml at '%s' is missing the following mandatory keys: authors, name, \" \\\n               \"readme, version\" % to_native(galaxy_yml)\n\n    with pytest.raises(AnsibleError, match=expected):\n        collection._get_galaxy_yml(galaxy_yml)",
        "begin_line": 277,
        "end_line": 282,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_warning_extra_keys#292",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_warning_extra_keys(galaxy_yml, monkeypatch)",
        "snippet": "def test_warning_extra_keys(galaxy_yml, monkeypatch):\n    display_mock = MagicMock()\n    monkeypatch.setattr(Display, 'warning', display_mock)\n\n    collection._get_galaxy_yml(galaxy_yml)\n\n    assert display_mock.call_count == 1\n    assert display_mock.call_args[0][0] == \"Found unknown keys in collection galaxy.yml at '%s': invalid\"\\\n        % to_text(galaxy_yml)",
        "begin_line": 292,
        "end_line": 300,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_defaults_galaxy_yml#309",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_defaults_galaxy_yml(galaxy_yml)",
        "snippet": "def test_defaults_galaxy_yml(galaxy_yml):\n    actual = collection._get_galaxy_yml(galaxy_yml)\n\n    assert actual['namespace'] == 'namespace'\n    assert actual['name'] == 'collection'\n    assert actual['authors'] == ['Jordan']\n    assert actual['version'] == '0.1.0'\n    assert actual['readme'] == 'README.md'\n    assert actual['description'] is None\n    assert actual['repository'] is None\n    assert actual['documentation'] is None\n    assert actual['homepage'] is None\n    assert actual['issues'] is None\n    assert actual['tags'] == []\n    assert actual['dependencies'] == {}\n    assert actual['license_ids'] == []",
        "begin_line": 309,
        "end_line": 324,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_galaxy_yml_list_value#341",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_galaxy_yml_list_value(galaxy_yml)",
        "snippet": "def test_galaxy_yml_list_value(galaxy_yml):\n    actual = collection._get_galaxy_yml(galaxy_yml)\n    assert actual['license_ids'] == ['MIT']",
        "begin_line": 341,
        "end_line": 343,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_build_ignore_files_and_folders#346",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_build_ignore_files_and_folders(collection_input, monkeypatch)",
        "snippet": "def test_build_ignore_files_and_folders(collection_input, monkeypatch):\n    input_dir = collection_input[0]\n\n    mock_display = MagicMock()\n    monkeypatch.setattr(Display, 'vvv', mock_display)\n\n    git_folder = os.path.join(input_dir, '.git')\n    retry_file = os.path.join(input_dir, 'ansible.retry')\n\n    tests_folder = os.path.join(input_dir, 'tests', 'output')\n    tests_output_file = os.path.join(tests_folder, 'result.txt')\n\n    os.makedirs(git_folder)\n    os.makedirs(tests_folder)\n\n    with open(retry_file, 'w+') as ignore_file:\n        ignore_file.write('random')\n        ignore_file.flush()\n\n    with open(tests_output_file, 'w+') as tests_file:\n        tests_file.write('random')\n        tests_file.flush()\n\n    actual = collection._build_files_manifest(to_bytes(input_dir), 'namespace', 'collection', [])\n\n    assert actual['format'] == 1\n    for manifest_entry in actual['files']:\n        assert manifest_entry['name'] not in ['.git', 'ansible.retry', 'galaxy.yml', 'tests/output', 'tests/output/result.txt']\n\n    expected_msgs = [\n        \"Skipping '%s/galaxy.yml' for collection build\" % to_text(input_dir),\n        \"Skipping '%s' for collection build\" % to_text(retry_file),\n        \"Skipping '%s' for collection build\" % to_text(git_folder),\n        \"Skipping '%s' for collection build\" % to_text(tests_folder),\n    ]\n    assert mock_display.call_count == 4\n    assert mock_display.mock_calls[0][1][0] in expected_msgs\n    assert mock_display.mock_calls[1][1][0] in expected_msgs\n    assert mock_display.mock_calls[2][1][0] in expected_msgs\n    assert mock_display.mock_calls[3][1][0] in expected_msgs",
        "begin_line": 346,
        "end_line": 385,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_build_ignore_older_release_in_root#388",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_build_ignore_older_release_in_root(collection_input, monkeypatch)",
        "snippet": "def test_build_ignore_older_release_in_root(collection_input, monkeypatch):\n    input_dir = collection_input[0]\n\n    mock_display = MagicMock()\n    monkeypatch.setattr(Display, 'vvv', mock_display)\n\n    # This is expected to be ignored because it is in the root collection dir.\n    release_file = os.path.join(input_dir, 'namespace-collection-0.0.0.tar.gz')\n\n    # This is not expected to be ignored because it is not in the root collection dir.\n    fake_release_file = os.path.join(input_dir, 'plugins', 'namespace-collection-0.0.0.tar.gz')\n\n    for filename in [release_file, fake_release_file]:\n        with open(filename, 'w+') as file_obj:\n            file_obj.write('random')\n            file_obj.flush()\n\n    actual = collection._build_files_manifest(to_bytes(input_dir), 'namespace', 'collection', [])\n    assert actual['format'] == 1\n\n    plugin_release_found = False\n    for manifest_entry in actual['files']:\n        assert manifest_entry['name'] != 'namespace-collection-0.0.0.tar.gz'\n        if manifest_entry['name'] == 'plugins/namespace-collection-0.0.0.tar.gz':\n            plugin_release_found = True\n\n    assert plugin_release_found\n\n    expected_msgs = [\n        \"Skipping '%s/galaxy.yml' for collection build\" % to_text(input_dir),\n        \"Skipping '%s' for collection build\" % to_text(release_file)\n    ]\n    assert mock_display.call_count == 2\n    assert mock_display.mock_calls[0][1][0] in expected_msgs\n    assert mock_display.mock_calls[1][1][0] in expected_msgs",
        "begin_line": 388,
        "end_line": 422,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_build_ignore_patterns#425",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_build_ignore_patterns(collection_input, monkeypatch)",
        "snippet": "def test_build_ignore_patterns(collection_input, monkeypatch):\n    input_dir = collection_input[0]\n\n    mock_display = MagicMock()\n    monkeypatch.setattr(Display, 'vvv', mock_display)\n\n    actual = collection._build_files_manifest(to_bytes(input_dir), 'namespace', 'collection',\n                                              ['*.md', 'plugins/action', 'playbooks/*.j2'])\n    assert actual['format'] == 1\n\n    expected_missing = [\n        'README.md',\n        'docs/My Collection.md',\n        'plugins/action',\n        'playbooks/templates/test.conf.j2',\n        'playbooks/templates/subfolder/test.conf.j2',\n    ]\n\n    # Files or dirs that are close to a match but are not, make sure they are present\n    expected_present = [\n        'docs',\n        'roles/common/templates/test.conf.j2',\n        'roles/common/templates/subfolder/test.conf.j2',\n    ]\n\n    actual_files = [e['name'] for e in actual['files']]\n    for m in expected_missing:\n        assert m not in actual_files\n\n    for p in expected_present:\n        assert p in actual_files\n\n    expected_msgs = [\n        \"Skipping '%s/galaxy.yml' for collection build\" % to_text(input_dir),\n        \"Skipping '%s/README.md' for collection build\" % to_text(input_dir),\n        \"Skipping '%s/docs/My Collection.md' for collection build\" % to_text(input_dir),\n        \"Skipping '%s/plugins/action' for collection build\" % to_text(input_dir),\n        \"Skipping '%s/playbooks/templates/test.conf.j2' for collection build\" % to_text(input_dir),\n        \"Skipping '%s/playbooks/templates/subfolder/test.conf.j2' for collection build\" % to_text(input_dir),\n    ]\n    assert mock_display.call_count == len(expected_msgs)\n    assert mock_display.mock_calls[0][1][0] in expected_msgs\n    assert mock_display.mock_calls[1][1][0] in expected_msgs\n    assert mock_display.mock_calls[2][1][0] in expected_msgs\n    assert mock_display.mock_calls[3][1][0] in expected_msgs\n    assert mock_display.mock_calls[4][1][0] in expected_msgs\n    assert mock_display.mock_calls[5][1][0] in expected_msgs",
        "begin_line": 425,
        "end_line": 471,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_build_ignore_symlink_target_outside_collection#474",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_build_ignore_symlink_target_outside_collection(collection_input, monkeypatch)",
        "snippet": "def test_build_ignore_symlink_target_outside_collection(collection_input, monkeypatch):\n    input_dir, outside_dir = collection_input\n\n    mock_display = MagicMock()\n    monkeypatch.setattr(Display, 'warning', mock_display)\n\n    link_path = os.path.join(input_dir, 'plugins', 'connection')\n    os.symlink(outside_dir, link_path)\n\n    actual = collection._build_files_manifest(to_bytes(input_dir), 'namespace', 'collection', [])\n    for manifest_entry in actual['files']:\n        assert manifest_entry['name'] != 'plugins/connection'\n\n    assert mock_display.call_count == 1\n    assert mock_display.mock_calls[0][1][0] == \"Skipping '%s' as it is a symbolic link to a directory outside \" \\\n                                               \"the collection\" % to_text(link_path)",
        "begin_line": 474,
        "end_line": 489,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_build_copy_symlink_target_inside_collection#492",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_build_copy_symlink_target_inside_collection(collection_input)",
        "snippet": "def test_build_copy_symlink_target_inside_collection(collection_input):\n    input_dir = collection_input[0]\n\n    os.makedirs(os.path.join(input_dir, 'playbooks', 'roles'))\n    roles_link = os.path.join(input_dir, 'playbooks', 'roles', 'linked')\n\n    roles_target = os.path.join(input_dir, 'roles', 'linked')\n    roles_target_tasks = os.path.join(roles_target, 'tasks')\n    os.makedirs(roles_target_tasks)\n    with open(os.path.join(roles_target_tasks, 'main.yml'), 'w+') as tasks_main:\n        tasks_main.write(\"---\\n- hosts: localhost\\n  tasks:\\n  - ping:\")\n        tasks_main.flush()\n\n    os.symlink(roles_target, roles_link)\n\n    actual = collection._build_files_manifest(to_bytes(input_dir), 'namespace', 'collection', [])\n\n    linked_entries = [e for e in actual['files'] if e['name'].startswith('playbooks/roles/linked')]\n    assert len(linked_entries) == 3\n    assert linked_entries[0]['name'] == 'playbooks/roles/linked'\n    assert linked_entries[0]['ftype'] == 'dir'\n    assert linked_entries[1]['name'] == 'playbooks/roles/linked/tasks'\n    assert linked_entries[1]['ftype'] == 'dir'\n    assert linked_entries[2]['name'] == 'playbooks/roles/linked/tasks/main.yml'\n    assert linked_entries[2]['ftype'] == 'file'\n    assert linked_entries[2]['chksum_sha256'] == '9c97a1633c51796999284c62236b8d5462903664640079b80c37bf50080fcbc3'",
        "begin_line": 492,
        "end_line": 517,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_build_with_symlink_inside_collection#520",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_build_with_symlink_inside_collection(collection_input)",
        "snippet": "def test_build_with_symlink_inside_collection(collection_input):\n    input_dir, output_dir = collection_input\n\n    os.makedirs(os.path.join(input_dir, 'playbooks', 'roles'))\n    roles_link = os.path.join(input_dir, 'playbooks', 'roles', 'linked')\n    file_link = os.path.join(input_dir, 'docs', 'README.md')\n\n    roles_target = os.path.join(input_dir, 'roles', 'linked')\n    roles_target_tasks = os.path.join(roles_target, 'tasks')\n    os.makedirs(roles_target_tasks)\n    with open(os.path.join(roles_target_tasks, 'main.yml'), 'w+') as tasks_main:\n        tasks_main.write(\"---\\n- hosts: localhost\\n  tasks:\\n  - ping:\")\n        tasks_main.flush()\n\n    os.symlink(roles_target, roles_link)\n    os.symlink(os.path.join(input_dir, 'README.md'), file_link)\n\n    collection.build_collection(input_dir, output_dir, False)\n\n    output_artifact = os.path.join(output_dir, 'ansible_namespace-collection-0.1.0.tar.gz')\n    assert tarfile.is_tarfile(output_artifact)\n\n    with tarfile.open(output_artifact, mode='r') as actual:\n        members = actual.getmembers()\n\n        linked_members = [m for m in members if m.path.startswith('playbooks/roles/linked/tasks')]\n        assert len(linked_members) == 2\n        assert linked_members[0].name == 'playbooks/roles/linked/tasks'\n        assert linked_members[0].isdir()\n\n        assert linked_members[1].name == 'playbooks/roles/linked/tasks/main.yml'\n        assert linked_members[1].isreg()\n\n        linked_task = actual.extractfile(linked_members[1].name)\n        actual_task = secure_hash_s(linked_task.read())\n        linked_task.close()\n\n        assert actual_task == 'f4dcc52576b6c2cd8ac2832c52493881c4e54226'\n\n        linked_file = [m for m in members if m.path == 'docs/README.md']\n        assert len(linked_file) == 1\n        assert linked_file[0].isreg()\n\n        linked_file_obj = actual.extractfile(linked_file[0].name)\n        actual_file = secure_hash_s(linked_file_obj.read())\n        linked_file_obj.close()\n\n        assert actual_file == '63444bfc766154e1bc7557ef6280de20d03fcd81'",
        "begin_line": 520,
        "end_line": 567,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_publish_no_wait#570",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_publish_no_wait(galaxy_server, collection_artifact, monkeypatch)",
        "snippet": "def test_publish_no_wait(galaxy_server, collection_artifact, monkeypatch):\n    mock_display = MagicMock()\n    monkeypatch.setattr(Display, 'display', mock_display)\n\n    artifact_path, mock_open = collection_artifact\n    fake_import_uri = 'https://galaxy.server.com/api/v2/import/1234'\n\n    mock_publish = MagicMock()\n    mock_publish.return_value = fake_import_uri\n    monkeypatch.setattr(galaxy_server, 'publish_collection', mock_publish)\n\n    collection.publish_collection(artifact_path, galaxy_server, False, 0)\n\n    assert mock_publish.call_count == 1\n    assert mock_publish.mock_calls[0][1][0] == artifact_path\n\n    assert mock_display.call_count == 1\n    assert mock_display.mock_calls[0][1][0] == \\\n        \"Collection has been pushed to the Galaxy server %s %s, not waiting until import has completed due to \" \\\n        \"--no-wait being set. Import task results can be found at %s\" % (galaxy_server.name, galaxy_server.api_server,\n                                                                         fake_import_uri)",
        "begin_line": 570,
        "end_line": 590,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_publish_with_wait#593",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_publish_with_wait(galaxy_server, collection_artifact, monkeypatch)",
        "snippet": "def test_publish_with_wait(galaxy_server, collection_artifact, monkeypatch):\n    mock_display = MagicMock()\n    monkeypatch.setattr(Display, 'display', mock_display)\n\n    artifact_path, mock_open = collection_artifact\n    fake_import_uri = 'https://galaxy.server.com/api/v2/import/1234'\n\n    mock_publish = MagicMock()\n    mock_publish.return_value = fake_import_uri\n    monkeypatch.setattr(galaxy_server, 'publish_collection', mock_publish)\n\n    mock_wait = MagicMock()\n    monkeypatch.setattr(galaxy_server, 'wait_import_task', mock_wait)\n\n    collection.publish_collection(artifact_path, galaxy_server, True, 0)\n\n    assert mock_publish.call_count == 1\n    assert mock_publish.mock_calls[0][1][0] == artifact_path\n\n    assert mock_wait.call_count == 1\n    assert mock_wait.mock_calls[0][1][0] == '1234'\n\n    assert mock_display.mock_calls[0][1][0] == \"Collection has been published to the Galaxy server test_server %s\" \\\n        % galaxy_server.api_server",
        "begin_line": 593,
        "end_line": 616,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_find_existing_collections#619",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_find_existing_collections(tmp_path_factory, monkeypatch)",
        "snippet": "def test_find_existing_collections(tmp_path_factory, monkeypatch):\n    test_dir = to_text(tmp_path_factory.mktemp('test-\u00c5\u00d1\u015a\u00cc\u03b2\u0141\u00c8 Collections'))\n    collection1 = os.path.join(test_dir, 'namespace1', 'collection1')\n    collection2 = os.path.join(test_dir, 'namespace2', 'collection2')\n    fake_collection1 = os.path.join(test_dir, 'namespace3', 'collection3')\n    fake_collection2 = os.path.join(test_dir, 'namespace4')\n    os.makedirs(collection1)\n    os.makedirs(collection2)\n    os.makedirs(os.path.split(fake_collection1)[0])\n\n    open(fake_collection1, 'wb+').close()\n    open(fake_collection2, 'wb+').close()\n\n    collection1_manifest = json.dumps({\n        'collection_info': {\n            'namespace': 'namespace1',\n            'name': 'collection1',\n            'version': '1.2.3',\n            'authors': ['Jordan Borean'],\n            'readme': 'README.md',\n            'dependencies': {},\n        },\n        'format': 1,\n    })\n    with open(os.path.join(collection1, 'MANIFEST.json'), 'wb') as manifest_obj:\n        manifest_obj.write(to_bytes(collection1_manifest))\n\n    mock_warning = MagicMock()\n    monkeypatch.setattr(Display, 'warning', mock_warning)\n\n    actual = collection.find_existing_collections(test_dir)\n\n    assert len(actual) == 2\n    for actual_collection in actual:\n        assert actual_collection.skip is True\n\n        if str(actual_collection) == 'namespace1.collection1':\n            assert actual_collection.namespace == 'namespace1'\n            assert actual_collection.name == 'collection1'\n            assert actual_collection.b_path == to_bytes(collection1)\n            assert actual_collection.api is None\n            assert actual_collection.versions == set(['1.2.3'])\n            assert actual_collection.latest_version == '1.2.3'\n            assert actual_collection.dependencies == {}\n        else:\n            assert actual_collection.namespace == 'namespace2'\n            assert actual_collection.name == 'collection2'\n            assert actual_collection.b_path == to_bytes(collection2)\n            assert actual_collection.api is None\n            assert actual_collection.versions == set(['*'])\n            assert actual_collection.latest_version == '*'\n            assert actual_collection.dependencies == {}\n\n    assert mock_warning.call_count == 1\n    assert mock_warning.mock_calls[0][1][0] == \"Collection at '%s' does not have a MANIFEST.json file, cannot \" \\\n                                               \"detect version.\" % to_text(collection2)",
        "begin_line": 619,
        "end_line": 674,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_download_file#677",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_download_file(tmp_path_factory, monkeypatch)",
        "snippet": "def test_download_file(tmp_path_factory, monkeypatch):\n    temp_dir = to_bytes(tmp_path_factory.mktemp('test-\u00c5\u00d1\u015a\u00cc\u03b2\u0141\u00c8 Collections'))\n\n    data = b\"\\x00\\x01\\x02\\x03\"\n    sha256_hash = sha256()\n    sha256_hash.update(data)\n\n    mock_open = MagicMock()\n    mock_open.return_value = BytesIO(data)\n    monkeypatch.setattr(collection, 'open_url', mock_open)\n\n    expected = os.path.join(temp_dir, b'file')\n    actual = collection._download_file('http://google.com/file', temp_dir, sha256_hash.hexdigest(), True)\n\n    assert actual.startswith(expected)\n    assert os.path.isfile(actual)\n    with open(actual, 'rb') as file_obj:\n        assert file_obj.read() == data\n\n    assert mock_open.call_count == 1\n    assert mock_open.mock_calls[0][1][0] == 'http://google.com/file'",
        "begin_line": 677,
        "end_line": 697,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_download_file_hash_mismatch#700",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_download_file_hash_mismatch(tmp_path_factory, monkeypatch)",
        "snippet": "def test_download_file_hash_mismatch(tmp_path_factory, monkeypatch):\n    temp_dir = to_bytes(tmp_path_factory.mktemp('test-\u00c5\u00d1\u015a\u00cc\u03b2\u0141\u00c8 Collections'))\n\n    data = b\"\\x00\\x01\\x02\\x03\"\n\n    mock_open = MagicMock()\n    mock_open.return_value = BytesIO(data)\n    monkeypatch.setattr(collection, 'open_url', mock_open)\n\n    expected = \"Mismatch artifact hash with downloaded file\"\n    with pytest.raises(AnsibleError, match=expected):\n        collection._download_file('http://google.com/file', temp_dir, 'bad', True)",
        "begin_line": 700,
        "end_line": 711,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_extract_tar_file_invalid_hash#714",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_extract_tar_file_invalid_hash(tmp_tarfile)",
        "snippet": "def test_extract_tar_file_invalid_hash(tmp_tarfile):\n    temp_dir, tfile, filename, dummy = tmp_tarfile\n\n    expected = \"Checksum mismatch for '%s' inside collection at '%s'\" % (to_native(filename), to_native(tfile.name))\n    with pytest.raises(AnsibleError, match=expected):\n        collection._extract_tar_file(tfile, filename, temp_dir, temp_dir, \"fakehash\")",
        "begin_line": 714,
        "end_line": 719,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_extract_tar_file_missing_member#722",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_extract_tar_file_missing_member(tmp_tarfile)",
        "snippet": "def test_extract_tar_file_missing_member(tmp_tarfile):\n    temp_dir, tfile, dummy, dummy = tmp_tarfile\n\n    expected = \"Collection tar at '%s' does not contain the expected file 'missing'.\" % to_native(tfile.name)\n    with pytest.raises(AnsibleError, match=expected):\n        collection._extract_tar_file(tfile, 'missing', temp_dir, temp_dir)",
        "begin_line": 722,
        "end_line": 727,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_extract_tar_file_missing_parent_dir#730",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_extract_tar_file_missing_parent_dir(tmp_tarfile)",
        "snippet": "def test_extract_tar_file_missing_parent_dir(tmp_tarfile):\n    temp_dir, tfile, filename, checksum = tmp_tarfile\n    output_dir = os.path.join(temp_dir, b'output')\n    output_file = os.path.join(output_dir, to_bytes(filename))\n\n    collection._extract_tar_file(tfile, filename, output_dir, temp_dir, checksum)\n    os.path.isfile(output_file)",
        "begin_line": 730,
        "end_line": 736,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_extract_tar_file_outside_dir#739",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_extract_tar_file_outside_dir(tmp_path_factory)",
        "snippet": "def test_extract_tar_file_outside_dir(tmp_path_factory):\n    filename = u'\u00c5\u00d1\u015a\u00cc\u03b2\u0141\u00c8'\n    temp_dir = to_bytes(tmp_path_factory.mktemp('test-%s Collections' % to_native(filename)))\n    tar_file = os.path.join(temp_dir, to_bytes('%s.tar.gz' % filename))\n    data = os.urandom(8)\n\n    tar_filename = '../%s.sh' % filename\n    with tarfile.open(tar_file, 'w:gz') as tfile:\n        b_io = BytesIO(data)\n        tar_info = tarfile.TarInfo(tar_filename)\n        tar_info.size = len(data)\n        tar_info.mode = 0o0644\n        tfile.addfile(tarinfo=tar_info, fileobj=b_io)\n\n    expected = re.escape(\"Cannot extract tar entry '%s' as it will be placed outside the collection directory\"\n                         % to_native(tar_filename))\n    with tarfile.open(tar_file, 'r') as tfile:\n        with pytest.raises(AnsibleError, match=expected):\n            collection._extract_tar_file(tfile, tar_filename, os.path.join(temp_dir, to_bytes(filename)), temp_dir)",
        "begin_line": 739,
        "end_line": 757,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_require_one_of_collections_requirements_with_both#760",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_require_one_of_collections_requirements_with_both()",
        "snippet": "def test_require_one_of_collections_requirements_with_both():\n    cli = GalaxyCLI(args=['ansible-galaxy', 'collection', 'verify', 'namespace.collection', '-r', 'requirements.yml'])\n\n    with pytest.raises(AnsibleError) as req_err:\n        cli._require_one_of_collections_requirements(('namespace.collection',), 'requirements.yml')\n\n    with pytest.raises(AnsibleError) as cli_err:\n        cli.run()\n\n    assert req_err.value.message == cli_err.value.message == 'The positional collection_name arg and --requirements-file are mutually exclusive.'",
        "begin_line": 760,
        "end_line": 769,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_require_one_of_collections_requirements_with_neither#772",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_require_one_of_collections_requirements_with_neither()",
        "snippet": "def test_require_one_of_collections_requirements_with_neither():\n    cli = GalaxyCLI(args=['ansible-galaxy', 'collection', 'verify'])\n\n    with pytest.raises(AnsibleError) as req_err:\n        cli._require_one_of_collections_requirements((), '')\n\n    with pytest.raises(AnsibleError) as cli_err:\n        cli.run()\n\n    assert req_err.value.message == cli_err.value.message == 'You must specify a collection name or a requirements file.'",
        "begin_line": 772,
        "end_line": 781,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_require_one_of_collections_requirements_with_collections#784",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_require_one_of_collections_requirements_with_collections()",
        "snippet": "def test_require_one_of_collections_requirements_with_collections():\n    cli = GalaxyCLI(args=['ansible-galaxy', 'collection', 'verify', 'namespace1.collection1', 'namespace2.collection1:1.0.0'])\n    collections = ('namespace1.collection1', 'namespace2.collection1:1.0.0',)\n\n    requirements = cli._require_one_of_collections_requirements(collections, '')\n\n    assert requirements == [('namespace1.collection1', '*', None), ('namespace2.collection1', '1.0.0', None)]",
        "begin_line": 784,
        "end_line": 790,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_require_one_of_collections_requirements_with_requirements#794",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_require_one_of_collections_requirements_with_requirements(mock_parse_requirements_file, galaxy_server)",
        "snippet": "def test_require_one_of_collections_requirements_with_requirements(mock_parse_requirements_file, galaxy_server):\n    cli = GalaxyCLI(args=['ansible-galaxy', 'collection', 'verify', '-r', 'requirements.yml', 'namespace.collection'])\n    mock_parse_requirements_file.return_value = {'collections': [('namespace.collection', '1.0.5', galaxy_server)]}\n    requirements = cli._require_one_of_collections_requirements((), 'requirements.yml')\n\n    assert mock_parse_requirements_file.call_count == 1\n    assert requirements == [('namespace.collection', '1.0.5', galaxy_server)]",
        "begin_line": 794,
        "end_line": 800,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_call_GalaxyCLI#804",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_call_GalaxyCLI(execute_verify)",
        "snippet": "def test_call_GalaxyCLI(execute_verify):\n    galaxy_args = ['ansible-galaxy', 'collection', 'verify', 'namespace.collection']\n\n    GalaxyCLI(args=galaxy_args).run()\n\n    assert execute_verify.call_count == 1",
        "begin_line": 804,
        "end_line": 809,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_call_GalaxyCLI_with_implicit_role#813",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_call_GalaxyCLI_with_implicit_role(execute_verify)",
        "snippet": "def test_call_GalaxyCLI_with_implicit_role(execute_verify):\n    galaxy_args = ['ansible-galaxy', 'verify', 'namespace.implicit_role']\n\n    with pytest.raises(SystemExit):\n        GalaxyCLI(args=galaxy_args).run()\n\n    assert not execute_verify.called",
        "begin_line": 813,
        "end_line": 819,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_call_GalaxyCLI_with_role#823",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_call_GalaxyCLI_with_role(execute_verify)",
        "snippet": "def test_call_GalaxyCLI_with_role(execute_verify):\n    galaxy_args = ['ansible-galaxy', 'role', 'verify', 'namespace.role']\n\n    with pytest.raises(SystemExit):\n        GalaxyCLI(args=galaxy_args).run()\n\n    assert not execute_verify.called",
        "begin_line": 823,
        "end_line": 829,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_execute_verify_with_defaults#833",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_execute_verify_with_defaults(mock_verify_collections)",
        "snippet": "def test_execute_verify_with_defaults(mock_verify_collections):\n    galaxy_args = ['ansible-galaxy', 'collection', 'verify', 'namespace.collection:1.0.4']\n    GalaxyCLI(args=galaxy_args).run()\n\n    assert mock_verify_collections.call_count == 1\n\n    requirements, search_paths, galaxy_apis, validate, ignore_errors = mock_verify_collections.call_args[0]\n\n    assert requirements == [('namespace.collection', '1.0.4', None)]\n    for install_path in search_paths:\n        assert install_path.endswith('ansible_collections')\n    assert galaxy_apis[0].api_server == 'https://galaxy.ansible.com'\n    assert validate is True\n    assert ignore_errors is False",
        "begin_line": 833,
        "end_line": 846,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_execute_verify#850",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_execute_verify(mock_verify_collections)",
        "snippet": "def test_execute_verify(mock_verify_collections):\n    GalaxyCLI(args=[\n        'ansible-galaxy', 'collection', 'verify', 'namespace.collection:1.0.4', '--ignore-certs',\n        '-p', '~/.ansible', '--ignore-errors', '--server', 'http://galaxy-dev.com',\n    ]).run()\n\n    assert mock_verify_collections.call_count == 1\n\n    requirements, search_paths, galaxy_apis, validate, ignore_errors = mock_verify_collections.call_args[0]\n\n    assert requirements == [('namespace.collection', '1.0.4', None)]\n    for install_path in search_paths:\n        assert install_path.endswith('ansible_collections')\n    assert galaxy_apis[0].api_server == 'http://galaxy-dev.com'\n    assert validate is False\n    assert ignore_errors is True",
        "begin_line": 850,
        "end_line": 865,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_file_hash_deleted_file#868",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_file_hash_deleted_file(manifest_info)",
        "snippet": "def test_verify_file_hash_deleted_file(manifest_info):\n    data = to_bytes(json.dumps(manifest_info))\n    digest = sha256(data).hexdigest()\n\n    namespace = manifest_info['collection_info']['namespace']\n    name = manifest_info['collection_info']['name']\n    version = manifest_info['collection_info']['version']\n    server = 'http://galaxy.ansible.com'\n\n    error_queue = []\n\n    with patch.object(builtins, 'open', mock_open(read_data=data)) as m:\n        with patch.object(collection.os.path, 'isfile', MagicMock(return_value=False)) as mock_isfile:\n            collection_req = collection.CollectionRequirement(namespace, name, './', server, [version], version, False)\n            collection_req._verify_file_hash(b'path/', 'file', digest, error_queue)\n\n            assert mock_isfile.called_once\n\n    assert len(error_queue) == 1\n    assert error_queue[0].installed is None\n    assert error_queue[0].expected == digest",
        "begin_line": 868,
        "end_line": 888,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_file_hash_matching_hash#891",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_file_hash_matching_hash(manifest_info)",
        "snippet": "def test_verify_file_hash_matching_hash(manifest_info):\n\n    data = to_bytes(json.dumps(manifest_info))\n    digest = sha256(data).hexdigest()\n\n    namespace = manifest_info['collection_info']['namespace']\n    name = manifest_info['collection_info']['name']\n    version = manifest_info['collection_info']['version']\n    server = 'http://galaxy.ansible.com'\n\n    error_queue = []\n\n    with patch.object(builtins, 'open', mock_open(read_data=data)) as m:\n        with patch.object(collection.os.path, 'isfile', MagicMock(return_value=True)) as mock_isfile:\n            collection_req = collection.CollectionRequirement(namespace, name, './', server, [version], version, False)\n            collection_req._verify_file_hash(b'path/', 'file', digest, error_queue)\n\n            assert mock_isfile.called_once\n\n    assert error_queue == []",
        "begin_line": 891,
        "end_line": 910,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_file_hash_mismatching_hash#913",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_file_hash_mismatching_hash(manifest_info)",
        "snippet": "def test_verify_file_hash_mismatching_hash(manifest_info):\n\n    data = to_bytes(json.dumps(manifest_info))\n    digest = sha256(data).hexdigest()\n    different_digest = 'not_{0}'.format(digest)\n\n    namespace = manifest_info['collection_info']['namespace']\n    name = manifest_info['collection_info']['name']\n    version = manifest_info['collection_info']['version']\n    server = 'http://galaxy.ansible.com'\n\n    error_queue = []\n\n    with patch.object(builtins, 'open', mock_open(read_data=data)) as m:\n        with patch.object(collection.os.path, 'isfile', MagicMock(return_value=True)) as mock_isfile:\n            collection_req = collection.CollectionRequirement(namespace, name, './', server, [version], version, False)\n            collection_req._verify_file_hash(b'path/', 'file', different_digest, error_queue)\n\n            assert mock_isfile.called_once\n\n    assert len(error_queue) == 1\n    assert error_queue[0].installed == digest\n    assert error_queue[0].expected == different_digest",
        "begin_line": 913,
        "end_line": 935,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_consume_file#938",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_consume_file(manifest)",
        "snippet": "def test_consume_file(manifest):\n\n    manifest_file, checksum = manifest\n    assert checksum == collection._consume_file(manifest_file)",
        "begin_line": 938,
        "end_line": 941,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_consume_file_and_write_contents#944",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_consume_file_and_write_contents(manifest, manifest_info)",
        "snippet": "def test_consume_file_and_write_contents(manifest, manifest_info):\n\n    manifest_file, checksum = manifest\n\n    write_to = BytesIO()\n    actual_hash = collection._consume_file(manifest_file, write_to)\n\n    write_to.seek(0)\n    assert to_bytes(json.dumps(manifest_info)) == write_to.read()\n    assert actual_hash == checksum",
        "begin_line": 944,
        "end_line": 953,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_get_tar_file_member#956",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_get_tar_file_member(tmp_tarfile)",
        "snippet": "def test_get_tar_file_member(tmp_tarfile):\n\n    temp_dir, tfile, filename, checksum = tmp_tarfile\n\n    with collection._get_tar_file_member(tfile, filename) as tar_file_obj:\n        assert isinstance(tar_file_obj, tarfile.ExFileObject)",
        "begin_line": 956,
        "end_line": 961,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_get_nonexistent_tar_file_member#964",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_get_nonexistent_tar_file_member(tmp_tarfile)",
        "snippet": "def test_get_nonexistent_tar_file_member(tmp_tarfile):\n    temp_dir, tfile, filename, checksum = tmp_tarfile\n\n    file_does_not_exist = filename + 'nonexistent'\n\n    with pytest.raises(AnsibleError) as err:\n        collection._get_tar_file_member(tfile, file_does_not_exist)\n\n    assert to_text(err.value.message) == \"Collection tar at '%s' does not contain the expected file '%s'.\" % (to_text(tfile.name), file_does_not_exist)",
        "begin_line": 964,
        "end_line": 972,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_get_tar_file_hash#975",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_get_tar_file_hash(tmp_tarfile)",
        "snippet": "def test_get_tar_file_hash(tmp_tarfile):\n    temp_dir, tfile, filename, checksum = tmp_tarfile\n\n    assert checksum == collection._get_tar_file_hash(tfile.name, filename)",
        "begin_line": 975,
        "end_line": 978,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_get_json_from_tar_file#981",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_get_json_from_tar_file(tmp_tarfile)",
        "snippet": "def test_get_json_from_tar_file(tmp_tarfile):\n    temp_dir, tfile, filename, checksum = tmp_tarfile\n\n    assert 'MANIFEST.json' in tfile.getnames()\n\n    data = collection._get_json_from_tar_file(tfile.name, 'MANIFEST.json')\n\n    assert isinstance(data, dict)",
        "begin_line": 981,
        "end_line": 988,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_collection_not_installed#991",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_collection_not_installed(mock_collection)",
        "snippet": "def test_verify_collection_not_installed(mock_collection):\n\n    local_collection = mock_collection(local_installed=False)\n    remote_collection = mock_collection(local=False)\n\n    with patch.object(collection.display, 'display') as mocked_display:\n        local_collection.verify(remote_collection, './', './')\n\n        assert mocked_display.called\n        assert mocked_display.call_args[0][0] == \"'%s.%s' has not been installed, nothing to verify\" % (local_collection.namespace, local_collection.name)",
        "begin_line": 991,
        "end_line": 1000,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_successful_debug_info#1003",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_successful_debug_info(monkeypatch, mock_collection)",
        "snippet": "def test_verify_successful_debug_info(monkeypatch, mock_collection):\n    local_collection = mock_collection()\n    remote_collection = mock_collection(local=False)\n\n    monkeypatch.setattr(collection, '_get_tar_file_hash', MagicMock())\n    monkeypatch.setattr(collection.CollectionRequirement, '_verify_file_hash', MagicMock())\n    monkeypatch.setattr(collection, '_get_json_from_tar_file', MagicMock())\n\n    with patch.object(collection.display, 'vvv') as mock_display:\n        local_collection.verify(remote_collection, './', './')\n\n        namespace = local_collection.namespace\n        name = local_collection.name\n        version = local_collection.latest_version\n\n        assert mock_display.call_count == 4\n        assert mock_display.call_args_list[0][0][0] == \"Verifying '%s.%s:%s'.\" % (namespace, name, version)\n        assert mock_display.call_args_list[1][0][0] == \"Installed collection found at './%s/%s'\" % (namespace, name)\n        located = \"Remote collection found at 'https://galaxy.ansible.com/download/%s-%s-%s.tar.gz'\" % (namespace, name, version)\n        assert mock_display.call_args_list[2][0][0] == located\n        verified = \"Successfully verified that checksums for '%s.%s:%s' match the remote collection\" % (namespace, name, version)\n        assert mock_display.call_args_list[3][0][0] == verified",
        "begin_line": 1003,
        "end_line": 1024,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_different_versions#1027",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_different_versions(mock_collection)",
        "snippet": "def test_verify_different_versions(mock_collection):\n\n    local_collection = mock_collection(version='0.1.0')\n    remote_collection = mock_collection(local=False, version='3.0.0')\n\n    with patch.object(collection.display, 'display') as mock_display:\n        local_collection.verify(remote_collection, './', './')\n\n        namespace = local_collection.namespace\n        name = local_collection.name\n        installed_version = local_collection.latest_version\n        compared_version = remote_collection.latest_version\n\n        msg = \"%s.%s has the version '%s' but is being compared to '%s'\" % (namespace, name, installed_version, compared_version)\n\n        assert mock_display.call_count == 1\n        assert mock_display.call_args[0][0] == msg",
        "begin_line": 1027,
        "end_line": 1043,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_modified_manifest#1047",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_modified_manifest(monkeypatch, mock_collection, manifest_info)",
        "snippet": "def test_verify_modified_manifest(monkeypatch, mock_collection, manifest_info):\n    local_collection = mock_collection()\n    remote_collection = mock_collection(local=False)\n\n    monkeypatch.setattr(collection, '_get_tar_file_hash', MagicMock(side_effect=['manifest_checksum']))\n    monkeypatch.setattr(collection, '_consume_file', MagicMock(side_effect=['manifest_checksum_modified', 'files_manifest_checksum']))\n    monkeypatch.setattr(collection, '_get_json_from_tar_file', MagicMock(side_effect=[manifest_info, {'files': []}]))\n    monkeypatch.setattr(collection.os.path, 'isfile', MagicMock(return_value=True))\n\n    with patch.object(collection.display, 'display') as mock_display:\n        with patch.object(collection.display, 'vvv') as mock_debug:\n            local_collection.verify(remote_collection, './', './')\n\n            namespace = local_collection.namespace\n            name = local_collection.name\n\n            assert mock_display.call_count == 3\n            assert mock_display.call_args_list[0][0][0] == 'Collection %s.%s contains modified content in the following files:' % (namespace, name)\n            assert mock_display.call_args_list[1][0][0] == '%s.%s' % (namespace, name)\n            assert mock_display.call_args_list[2][0][0] == '    MANIFEST.json'\n\n            # The -vvv output should show details (the checksums do not match)\n            assert mock_debug.call_count == 5\n            assert mock_debug.call_args_list[-1][0][0] == '    Expected: manifest_checksum\\n    Found: manifest_checksum_modified'",
        "begin_line": 1047,
        "end_line": 1070,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_modified_files_manifest#1074",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_modified_files_manifest(monkeypatch, mock_collection, manifest_info)",
        "snippet": "def test_verify_modified_files_manifest(monkeypatch, mock_collection, manifest_info):\n    local_collection = mock_collection()\n    remote_collection = mock_collection(local=False)\n\n    monkeypatch.setattr(collection, '_get_tar_file_hash', MagicMock(side_effect=['manifest_checksum']))\n    monkeypatch.setattr(collection, '_consume_file', MagicMock(side_effect=['manifest_checksum', 'files_manifest_checksum_modified']))\n    monkeypatch.setattr(collection, '_get_json_from_tar_file', MagicMock(side_effect=[manifest_info, {'files': []}]))\n    monkeypatch.setattr(collection.os.path, 'isfile', MagicMock(return_value=True))\n\n    with patch.object(collection.display, 'display') as mock_display:\n        with patch.object(collection.display, 'vvv') as mock_debug:\n            local_collection.verify(remote_collection, './', './')\n\n            namespace = local_collection.namespace\n            name = local_collection.name\n\n            assert mock_display.call_count == 3\n            assert mock_display.call_args_list[0][0][0] == 'Collection %s.%s contains modified content in the following files:' % (namespace, name)\n            assert mock_display.call_args_list[1][0][0] == '%s.%s' % (namespace, name)\n            assert mock_display.call_args_list[2][0][0] == '    FILES.json'\n\n            # The -vvv output should show details (the checksums do not match)\n            assert mock_debug.call_count == 5\n            assert mock_debug.call_args_list[-1][0][0] == '    Expected: files_manifest_checksum\\n    Found: files_manifest_checksum_modified'",
        "begin_line": 1074,
        "end_line": 1097,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_modified_files#1101",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_modified_files(monkeypatch, mock_collection, manifest_info, files_manifest_info)",
        "snippet": "def test_verify_modified_files(monkeypatch, mock_collection, manifest_info, files_manifest_info):\n\n    local_collection = mock_collection()\n    remote_collection = mock_collection(local=False)\n\n    monkeypatch.setattr(collection, '_get_tar_file_hash', MagicMock(side_effect=['manifest_checksum']))\n    fakehashes = ['manifest_checksum', 'files_manifest_checksum', 'individual_file_checksum_modified']\n    monkeypatch.setattr(collection, '_consume_file', MagicMock(side_effect=fakehashes))\n    monkeypatch.setattr(collection, '_get_json_from_tar_file', MagicMock(side_effect=[manifest_info, files_manifest_info]))\n    monkeypatch.setattr(collection.os.path, 'isfile', MagicMock(return_value=True))\n\n    with patch.object(collection.display, 'display') as mock_display:\n        with patch.object(collection.display, 'vvv') as mock_debug:\n            local_collection.verify(remote_collection, './', './')\n\n            namespace = local_collection.namespace\n            name = local_collection.name\n\n            assert mock_display.call_count == 3\n            assert mock_display.call_args_list[0][0][0] == 'Collection %s.%s contains modified content in the following files:' % (namespace, name)\n            assert mock_display.call_args_list[1][0][0] == '%s.%s' % (namespace, name)\n            assert mock_display.call_args_list[2][0][0] == '    README.md'\n\n            # The -vvv output should show details (the checksums do not match)\n            assert mock_debug.call_count == 5\n            assert mock_debug.call_args_list[-1][0][0] == '    Expected: individual_file_checksum\\n    Found: individual_file_checksum_modified'",
        "begin_line": 1101,
        "end_line": 1126,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_identical#1130",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_identical(monkeypatch, mock_collection, manifest_info, files_manifest_info)",
        "snippet": "def test_verify_identical(monkeypatch, mock_collection, manifest_info, files_manifest_info):\n\n    local_collection = mock_collection()\n    remote_collection = mock_collection(local=False)\n\n    monkeypatch.setattr(collection, '_get_tar_file_hash', MagicMock(side_effect=['manifest_checksum']))\n    monkeypatch.setattr(collection, '_consume_file', MagicMock(side_effect=['manifest_checksum', 'files_manifest_checksum', 'individual_file_checksum']))\n    monkeypatch.setattr(collection, '_get_json_from_tar_file', MagicMock(side_effect=[manifest_info, files_manifest_info]))\n    monkeypatch.setattr(collection.os.path, 'isfile', MagicMock(return_value=True))\n\n    with patch.object(collection.display, 'display') as mock_display:\n        with patch.object(collection.display, 'vvv') as mock_debug:\n            local_collection.verify(remote_collection, './', './')\n\n            # Successful verification is quiet\n            assert mock_display.call_count == 0\n\n            # The -vvv output should show the checksums not matching\n            namespace = local_collection.namespace\n            name = local_collection.name\n            version = local_collection.latest_version\n            success_msg = \"Successfully verified that checksums for '%s.%s:%s' match the remote collection\" % (namespace, name, version)\n\n            assert mock_debug.call_count == 4\n            assert mock_debug.call_args_list[-1][0][0] == success_msg",
        "begin_line": 1130,
        "end_line": 1154,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_collections_no_version#1158",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_collections_no_version(mock_isdir, mock_collection, monkeypatch)",
        "snippet": "def test_verify_collections_no_version(mock_isdir, mock_collection, monkeypatch):\n    namespace = 'ansible_namespace'\n    name = 'collection'\n    version = '*'  # Occurs if MANIFEST.json does not exist\n\n    local_collection = mock_collection(namespace=namespace, name=name, version=version)\n    monkeypatch.setattr(collection.CollectionRequirement, 'from_path', MagicMock(return_value=local_collection))\n\n    collections = [('%s.%s' % (namespace, name), version, None)]\n\n    with pytest.raises(AnsibleError) as err:\n        collection.verify_collections(collections, './', local_collection.api, False, False)\n\n    err_msg = 'Collection %s.%s does not appear to have a MANIFEST.json. ' % (namespace, name)\n    err_msg += 'A MANIFEST.json is expected if the collection has been built and installed via ansible-galaxy.'\n    assert err.value.message == err_msg",
        "begin_line": 1158,
        "end_line": 1173,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_collections_not_installed#1177",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_collections_not_installed(mock_verify, mock_collection, monkeypatch)",
        "snippet": "def test_verify_collections_not_installed(mock_verify, mock_collection, monkeypatch):\n    namespace = 'ansible_namespace'\n    name = 'collection'\n    version = '1.0.0'\n\n    local_collection = mock_collection(local_installed=False)\n\n    found_remote = MagicMock(return_value=mock_collection(local=False))\n    monkeypatch.setattr(collection.CollectionRequirement, 'from_name', found_remote)\n\n    collections = [('%s.%s' % (namespace, name), version, None)]\n    search_path = './'\n    validate_certs = False\n    ignore_errors = False\n    apis = [local_collection.api]\n\n    with patch.object(collection, '_download_file') as mock_download_file:\n        with pytest.raises(AnsibleError) as err:\n            collection.verify_collections(collections, search_path, apis, validate_certs, ignore_errors)\n\n    assert err.value.message == \"Collection %s.%s is not installed in any of the collection paths.\" % (namespace, name)",
        "begin_line": 1177,
        "end_line": 1197,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_collections_not_installed_ignore_errors#1201",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_collections_not_installed_ignore_errors(mock_verify, mock_collection, monkeypatch)",
        "snippet": "def test_verify_collections_not_installed_ignore_errors(mock_verify, mock_collection, monkeypatch):\n    namespace = 'ansible_namespace'\n    name = 'collection'\n    version = '1.0.0'\n\n    local_collection = mock_collection(local_installed=False)\n\n    found_remote = MagicMock(return_value=mock_collection(local=False))\n    monkeypatch.setattr(collection.CollectionRequirement, 'from_name', found_remote)\n\n    collections = [('%s.%s' % (namespace, name), version, None)]\n    search_path = './'\n    validate_certs = False\n    ignore_errors = True\n    apis = [local_collection.api]\n\n    with patch.object(collection, '_download_file') as mock_download_file:\n        with patch.object(Display, 'warning') as mock_warning:\n            collection.verify_collections(collections, search_path, apis, validate_certs, ignore_errors)\n\n            skip_message = \"Failed to verify collection %s.%s but skipping due to --ignore-errors being set.\" % (namespace, name)\n            original_err = \"Error: Collection %s.%s is not installed in any of the collection paths.\" % (namespace, name)\n\n            assert mock_warning.called\n            assert mock_warning.call_args[0][0] == skip_message + \" \" + original_err",
        "begin_line": 1201,
        "end_line": 1225,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_collections_no_remote#1230",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_collections_no_remote(mock_verify, mock_isdir, mock_collection, monkeypatch)",
        "snippet": "def test_verify_collections_no_remote(mock_verify, mock_isdir, mock_collection, monkeypatch):\n    namespace = 'ansible_namespace'\n    name = 'collection'\n    version = '1.0.0'\n\n    monkeypatch.setattr(os.path, 'isfile', MagicMock(side_effect=[False, True]))\n    monkeypatch.setattr(collection.CollectionRequirement, 'from_path', MagicMock(return_value=mock_collection()))\n\n    collections = [('%s.%s' % (namespace, name), version, None)]\n    search_path = './'\n    validate_certs = False\n    ignore_errors = False\n    apis = []\n\n    with pytest.raises(AnsibleError) as err:\n        collection.verify_collections(collections, search_path, apis, validate_certs, ignore_errors)\n\n    assert err.value.message == \"Failed to find remote collection %s.%s:%s on any of the galaxy servers\" % (namespace, name, version)",
        "begin_line": 1230,
        "end_line": 1247,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_collections_no_remote_ignore_errors#1252",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_collections_no_remote_ignore_errors(mock_verify, mock_isdir, mock_collection, monkeypatch)",
        "snippet": "def test_verify_collections_no_remote_ignore_errors(mock_verify, mock_isdir, mock_collection, monkeypatch):\n    namespace = 'ansible_namespace'\n    name = 'collection'\n    version = '1.0.0'\n\n    monkeypatch.setattr(os.path, 'isfile', MagicMock(side_effect=[False, True]))\n    monkeypatch.setattr(collection.CollectionRequirement, 'from_path', MagicMock(return_value=mock_collection()))\n\n    collections = [('%s.%s' % (namespace, name), version, None)]\n    search_path = './'\n    validate_certs = False\n    ignore_errors = True\n    apis = []\n\n    with patch.object(Display, 'warning') as mock_warning:\n        collection.verify_collections(collections, search_path, apis, validate_certs, ignore_errors)\n\n        skip_message = \"Failed to verify collection %s.%s but skipping due to --ignore-errors being set.\" % (namespace, name)\n        original_err = \"Error: Failed to find remote collection %s.%s:%s on any of the galaxy servers\" % (namespace, name, version)\n\n        assert mock_warning.called\n        assert mock_warning.call_args[0][0] == skip_message + \" \" + original_err",
        "begin_line": 1252,
        "end_line": 1273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_collections_tarfile#1276",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_collections_tarfile(monkeypatch)",
        "snippet": "def test_verify_collections_tarfile(monkeypatch):\n\n    monkeypatch.setattr(os.path, 'isfile', MagicMock(return_value=True))\n\n    invalid_format = 'ansible_namespace-collection-0.1.0.tar.gz'\n    collections = [(invalid_format, '*', None)]\n\n    with pytest.raises(AnsibleError) as err:\n        collection.verify_collections(collections, './', [], False, False)\n\n    msg = \"'%s' is not a valid collection name. The format namespace.name is expected.\" % invalid_format\n    assert err.value.message == msg",
        "begin_line": 1276,
        "end_line": 1287,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_collections_path#1290",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_collections_path(monkeypatch)",
        "snippet": "def test_verify_collections_path(monkeypatch):\n\n    monkeypatch.setattr(os.path, 'isfile', MagicMock(return_value=False))\n\n    invalid_format = 'collections/collection_namespace/collection_name'\n    collections = [(invalid_format, '*', None)]\n\n    with pytest.raises(AnsibleError) as err:\n        collection.verify_collections(collections, './', [], False, False)\n\n    msg = \"'%s' is not a valid collection name. The format namespace.name is expected.\" % invalid_format\n    assert err.value.message == msg",
        "begin_line": 1290,
        "end_line": 1301,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_collections_url#1304",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_collections_url(monkeypatch)",
        "snippet": "def test_verify_collections_url(monkeypatch):\n\n    monkeypatch.setattr(os.path, 'isfile', MagicMock(return_value=False))\n\n    invalid_format = 'https://galaxy.ansible.com/download/ansible_namespace-collection-0.1.0.tar.gz'\n    collections = [(invalid_format, '*', None)]\n\n    with pytest.raises(AnsibleError) as err:\n        collection.verify_collections(collections, './', [], False, False)\n\n    msg = \"'%s' is not a valid collection name. The format namespace.name is expected.\" % invalid_format\n    assert err.value.message == msg",
        "begin_line": 1304,
        "end_line": 1315,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.galaxy.test_collection.test_verify_collections_name#1320",
        "src_path": "test/units/galaxy/test_collection.py",
        "class_name": "test.units.galaxy.test_collection",
        "signature": "test.units.galaxy.test_collection.test_verify_collections_name(mock_verify, mock_isdir, mock_collection, monkeypatch)",
        "snippet": "def test_verify_collections_name(mock_verify, mock_isdir, mock_collection, monkeypatch):\n    local_collection = mock_collection()\n    monkeypatch.setattr(collection.CollectionRequirement, 'from_path', MagicMock(return_value=local_collection))\n\n    monkeypatch.setattr(os.path, 'isfile', MagicMock(side_effect=[False, True, False]))\n\n    located_remote_from_name = MagicMock(return_value=mock_collection(local=False))\n    monkeypatch.setattr(collection.CollectionRequirement, 'from_name', located_remote_from_name)\n\n    with patch.object(collection, '_download_file') as mock_download_file:\n\n        collections = [('%s.%s' % (local_collection.namespace, local_collection.name), '%s' % local_collection.latest_version, None)]\n        search_path = './'\n        validate_certs = False\n        ignore_errors = False\n        apis = [local_collection.api]\n\n        collection.verify_collections(collections, search_path, apis, validate_certs, ignore_errors)\n\n        assert mock_download_file.call_count == 1\n        assert located_remote_from_name.call_count == 1",
        "begin_line": 1320,
        "end_line": 1340,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.procenv.swap_stdin_and_argv#34",
        "src_path": "test/units/mock/procenv.py",
        "class_name": "test.units.mock.procenv",
        "signature": "test.units.mock.procenv.swap_stdin_and_argv(stdin_data='', argv_data=tuple())",
        "snippet": "def swap_stdin_and_argv(stdin_data='', argv_data=tuple()):\n    \"\"\"\n    context manager that temporarily masks the test runner's values for stdin and argv\n    \"\"\"\n    real_stdin = sys.stdin\n    real_argv = sys.argv\n\n    if PY3:\n        fake_stream = StringIO(stdin_data)\n        fake_stream.buffer = BytesIO(to_bytes(stdin_data))\n    else:\n        fake_stream = BytesIO(to_bytes(stdin_data))\n\n    try:\n        sys.stdin = fake_stream\n        sys.argv = argv_data\n\n        yield\n    finally:\n        sys.stdin = real_stdin\n        sys.argv = real_argv",
        "begin_line": 34,
        "end_line": 54,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.procenv.ModuleTestCase.setUp#78",
        "src_path": "test/units/mock/procenv.py",
        "class_name": "test.units.mock.procenv.ModuleTestCase",
        "signature": "test.units.mock.procenv.ModuleTestCase.setUp(self, module_args=None)",
        "snippet": "    def setUp(self, module_args=None):\n        if module_args is None:\n            module_args = {'_ansible_remote_tmp': '/tmp', '_ansible_keep_remote_files': False}\n\n        args = json.dumps(dict(ANSIBLE_MODULE_ARGS=module_args))\n\n        # unittest doesn't have a clean place to use a context manager, so we have to enter/exit manually\n        self.stdin_swap = swap_stdin_and_argv(stdin_data=args)\n        self.stdin_swap.__enter__()",
        "begin_line": 78,
        "end_line": 86,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "test.units.mock.procenv.ModuleTestCase.tearDown#88",
        "src_path": "test/units/mock/procenv.py",
        "class_name": "test.units.mock.procenv.ModuleTestCase",
        "signature": "test.units.mock.procenv.ModuleTestCase.tearDown(self)",
        "snippet": "    def tearDown(self):\n        # unittest doesn't have a clean place to use a context manager, so we have to enter/exit manually\n        self.stdin_swap.__exit__(None, None, None)",
        "begin_line": 88,
        "end_line": 90,
        "comment": "",
        "is_bug": false
    }
]