[
    {
        "name": "pandas.tests.indexes.conftest.sort#5",
        "src_path": "pandas/tests/indexes/conftest.py",
        "class_name": "pandas.tests.indexes.conftest",
        "signature": "pandas.tests.indexes.conftest.sort(request)",
        "snippet": "def sort(request):\n    \"\"\"\n    Valid values for the 'sort' parameter used in the Index\n    setops methods (intersection, union, etc.)\n\n    Caution:\n        Don't confuse this one with the \"sort\" fixture used\n        for DataFrame.append or concat. That one has\n        parameters [True, False].\n\n        We can't combine them as sort=True is not permitted\n        in in the Index setops methods.\n    \"\"\"\n    return request.param",
        "begin_line": 5,
        "end_line": 18,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.conftest.freq_sample#22",
        "src_path": "pandas/tests/indexes/conftest.py",
        "class_name": "pandas.tests.indexes.conftest",
        "signature": "pandas.tests.indexes.conftest.freq_sample(request)",
        "snippet": "def freq_sample(request):\n    \"\"\"\n    Valid values for 'freq' parameter used to create date_range and\n    timedelta_range..\n    \"\"\"\n    return request.param",
        "begin_line": 22,
        "end_line": 27,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.FixedOffset.__init__#31",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.FixedOffset",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.FixedOffset.__init__(self, offset, name)",
        "snippet": "    def __init__(self, offset, name):\n        self.__offset = timedelta(minutes=offset)\n        self.__name = name",
        "begin_line": 31,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.FixedOffset.utcoffset#35",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.FixedOffset",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.FixedOffset.utcoffset(self, dt)",
        "snippet": "    def utcoffset(self, dt):\n        return self.__offset",
        "begin_line": 35,
        "end_line": 36,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.FixedOffset.tzname#38",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.FixedOffset",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.FixedOffset.tzname(self, dt)",
        "snippet": "    def tzname(self, dt):\n        return self.__name",
        "begin_line": 38,
        "end_line": 39,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.FixedOffset.dst#41",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.FixedOffset",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.FixedOffset.dst(self, dt)",
        "snippet": "    def dst(self, dt):\n        return timedelta(0)",
        "begin_line": 41,
        "end_line": 42,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_tz_convert_nat#52",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_tz_convert_nat(self)",
        "snippet": "    def test_tz_convert_nat(self):\n        # GH#5546\n        dates = [pd.NaT]\n        idx = DatetimeIndex(dates)\n        idx = idx.tz_localize(\"US/Pacific\")\n        tm.assert_index_equal(idx, DatetimeIndex(dates, tz=\"US/Pacific\"))\n        idx = idx.tz_convert(\"US/Eastern\")\n        tm.assert_index_equal(idx, DatetimeIndex(dates, tz=\"US/Eastern\"))\n        idx = idx.tz_convert(\"UTC\")\n        tm.assert_index_equal(idx, DatetimeIndex(dates, tz=\"UTC\"))\n\n        dates = [\"2010-12-01 00:00\", \"2010-12-02 00:00\", pd.NaT]\n        idx = DatetimeIndex(dates)\n        idx = idx.tz_localize(\"US/Pacific\")\n        tm.assert_index_equal(idx, DatetimeIndex(dates, tz=\"US/Pacific\"))\n        idx = idx.tz_convert(\"US/Eastern\")\n        expected = [\"2010-12-01 03:00\", \"2010-12-02 03:00\", pd.NaT]\n        tm.assert_index_equal(idx, DatetimeIndex(expected, tz=\"US/Eastern\"))\n\n        idx = idx + pd.offsets.Hour(5)\n        expected = [\"2010-12-01 08:00\", \"2010-12-02 08:00\", pd.NaT]\n        tm.assert_index_equal(idx, DatetimeIndex(expected, tz=\"US/Eastern\"))\n        idx = idx.tz_convert(\"US/Pacific\")\n        expected = [\"2010-12-01 05:00\", \"2010-12-02 05:00\", pd.NaT]\n        tm.assert_index_equal(idx, DatetimeIndex(expected, tz=\"US/Pacific\"))\n\n        idx = idx + np.timedelta64(3, \"h\")\n        expected = [\"2010-12-01 08:00\", \"2010-12-02 08:00\", pd.NaT]\n        tm.assert_index_equal(idx, DatetimeIndex(expected, tz=\"US/Pacific\"))\n\n        idx = idx.tz_convert(\"US/Eastern\")\n        expected = [\"2010-12-01 11:00\", \"2010-12-02 11:00\", pd.NaT]\n        tm.assert_index_equal(idx, DatetimeIndex(expected, tz=\"US/Eastern\"))",
        "begin_line": 52,
        "end_line": 84,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_convert_compat_timestamp#87",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_convert_compat_timestamp(self, prefix)",
        "snippet": "    def test_dti_tz_convert_compat_timestamp(self, prefix):\n        strdates = [\"1/1/2012\", \"3/1/2012\", \"4/1/2012\"]\n        idx = DatetimeIndex(strdates, tz=prefix + \"US/Eastern\")\n\n        conv = idx[0].tz_convert(prefix + \"US/Pacific\")\n        expected = idx.tz_convert(prefix + \"US/Pacific\")[0]\n\n        assert conv == expected",
        "begin_line": 87,
        "end_line": 94,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_convert_hour_overflow_dst#96",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_convert_hour_overflow_dst(self)",
        "snippet": "    def test_dti_tz_convert_hour_overflow_dst(self):\n        # Regression test for:\n        # https://github.com/pandas-dev/pandas/issues/13306\n\n        # sorted case US/Eastern -> UTC\n        ts = [\"2008-05-12 09:50:00\", \"2008-12-12 09:50:35\", \"2009-05-12 09:50:32\"]\n        tt = DatetimeIndex(ts).tz_localize(\"US/Eastern\")\n        ut = tt.tz_convert(\"UTC\")\n        expected = Index([13, 14, 13])\n        tm.assert_index_equal(ut.hour, expected)\n\n        # sorted case UTC -> US/Eastern\n        ts = [\"2008-05-12 13:50:00\", \"2008-12-12 14:50:35\", \"2009-05-12 13:50:32\"]\n        tt = DatetimeIndex(ts).tz_localize(\"UTC\")\n        ut = tt.tz_convert(\"US/Eastern\")\n        expected = Index([9, 9, 9])\n        tm.assert_index_equal(ut.hour, expected)\n\n        # unsorted case US/Eastern -> UTC\n        ts = [\"2008-05-12 09:50:00\", \"2008-12-12 09:50:35\", \"2008-05-12 09:50:32\"]\n        tt = DatetimeIndex(ts).tz_localize(\"US/Eastern\")\n        ut = tt.tz_convert(\"UTC\")\n        expected = Index([13, 14, 13])\n        tm.assert_index_equal(ut.hour, expected)\n\n        # unsorted case UTC -> US/Eastern\n        ts = [\"2008-05-12 13:50:00\", \"2008-12-12 14:50:35\", \"2008-05-12 13:50:32\"]\n        tt = DatetimeIndex(ts).tz_localize(\"UTC\")\n        ut = tt.tz_convert(\"US/Eastern\")\n        expected = Index([9, 9, 9])\n        tm.assert_index_equal(ut.hour, expected)",
        "begin_line": 96,
        "end_line": 126,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_convert_hour_overflow_dst_timestamps#129",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_convert_hour_overflow_dst_timestamps(self, tz)",
        "snippet": "    def test_dti_tz_convert_hour_overflow_dst_timestamps(self, tz):\n        # Regression test for GH#13306\n\n        # sorted case US/Eastern -> UTC\n        ts = [\n            Timestamp(\"2008-05-12 09:50:00\", tz=tz),\n            Timestamp(\"2008-12-12 09:50:35\", tz=tz),\n            Timestamp(\"2009-05-12 09:50:32\", tz=tz),\n        ]\n        tt = DatetimeIndex(ts)\n        ut = tt.tz_convert(\"UTC\")\n        expected = Index([13, 14, 13])\n        tm.assert_index_equal(ut.hour, expected)\n\n        # sorted case UTC -> US/Eastern\n        ts = [\n            Timestamp(\"2008-05-12 13:50:00\", tz=\"UTC\"),\n            Timestamp(\"2008-12-12 14:50:35\", tz=\"UTC\"),\n            Timestamp(\"2009-05-12 13:50:32\", tz=\"UTC\"),\n        ]\n        tt = DatetimeIndex(ts)\n        ut = tt.tz_convert(\"US/Eastern\")\n        expected = Index([9, 9, 9])\n        tm.assert_index_equal(ut.hour, expected)\n\n        # unsorted case US/Eastern -> UTC\n        ts = [\n            Timestamp(\"2008-05-12 09:50:00\", tz=tz),\n            Timestamp(\"2008-12-12 09:50:35\", tz=tz),\n            Timestamp(\"2008-05-12 09:50:32\", tz=tz),\n        ]\n        tt = DatetimeIndex(ts)\n        ut = tt.tz_convert(\"UTC\")\n        expected = Index([13, 14, 13])\n        tm.assert_index_equal(ut.hour, expected)\n\n        # unsorted case UTC -> US/Eastern\n        ts = [\n            Timestamp(\"2008-05-12 13:50:00\", tz=\"UTC\"),\n            Timestamp(\"2008-12-12 14:50:35\", tz=\"UTC\"),\n            Timestamp(\"2008-05-12 13:50:32\", tz=\"UTC\"),\n        ]\n        tt = DatetimeIndex(ts)\n        ut = tt.tz_convert(\"US/Eastern\")\n        expected = Index([9, 9, 9])\n        tm.assert_index_equal(ut.hour, expected)",
        "begin_line": 129,
        "end_line": 174,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_convert_trans_pos_plus_1__bug#177",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_convert_trans_pos_plus_1__bug(self, freq, n)",
        "snippet": "    def test_dti_tz_convert_trans_pos_plus_1__bug(self, freq, n):\n        # Regression test for tslib.tz_convert(vals, tz1, tz2).\n        # See https://github.com/pandas-dev/pandas/issues/4496 for details.\n        idx = date_range(datetime(2011, 3, 26, 23), datetime(2011, 3, 27, 1), freq=freq)\n        idx = idx.tz_localize(\"UTC\")\n        idx = idx.tz_convert(\"Europe/Moscow\")\n\n        expected = np.repeat(np.array([3, 4, 5]), np.array([n, n, 1]))\n        tm.assert_index_equal(idx.hour, Index(expected))",
        "begin_line": 177,
        "end_line": 185,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_convert_dst#187",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_convert_dst(self)",
        "snippet": "    def test_dti_tz_convert_dst(self):\n        for freq, n in [(\"H\", 1), (\"T\", 60), (\"S\", 3600)]:\n            # Start DST\n            idx = date_range(\n                \"2014-03-08 23:00\", \"2014-03-09 09:00\", freq=freq, tz=\"UTC\"\n            )\n            idx = idx.tz_convert(\"US/Eastern\")\n            expected = np.repeat(\n                np.array([18, 19, 20, 21, 22, 23, 0, 1, 3, 4, 5]),\n                np.array([n, n, n, n, n, n, n, n, n, n, 1]),\n            )\n            tm.assert_index_equal(idx.hour, Index(expected))\n\n            idx = date_range(\n                \"2014-03-08 18:00\", \"2014-03-09 05:00\", freq=freq, tz=\"US/Eastern\"\n            )\n            idx = idx.tz_convert(\"UTC\")\n            expected = np.repeat(\n                np.array([23, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]),\n                np.array([n, n, n, n, n, n, n, n, n, n, 1]),\n            )\n            tm.assert_index_equal(idx.hour, Index(expected))\n\n            # End DST\n            idx = date_range(\n                \"2014-11-01 23:00\", \"2014-11-02 09:00\", freq=freq, tz=\"UTC\"\n            )\n            idx = idx.tz_convert(\"US/Eastern\")\n            expected = np.repeat(\n                np.array([19, 20, 21, 22, 23, 0, 1, 1, 2, 3, 4]),\n                np.array([n, n, n, n, n, n, n, n, n, n, 1]),\n            )\n            tm.assert_index_equal(idx.hour, Index(expected))\n\n            idx = date_range(\n                \"2014-11-01 18:00\", \"2014-11-02 05:00\", freq=freq, tz=\"US/Eastern\"\n            )\n            idx = idx.tz_convert(\"UTC\")\n            expected = np.repeat(\n                np.array([22, 23, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),\n                np.array([n, n, n, n, n, n, n, n, n, n, n, n, 1]),\n            )\n            tm.assert_index_equal(idx.hour, Index(expected))\n\n        # daily\n        # Start DST\n        idx = date_range(\"2014-03-08 00:00\", \"2014-03-09 00:00\", freq=\"D\", tz=\"UTC\")\n        idx = idx.tz_convert(\"US/Eastern\")\n        tm.assert_index_equal(idx.hour, Index([19, 19]))\n\n        idx = date_range(\n            \"2014-03-08 00:00\", \"2014-03-09 00:00\", freq=\"D\", tz=\"US/Eastern\"\n        )\n        idx = idx.tz_convert(\"UTC\")\n        tm.assert_index_equal(idx.hour, Index([5, 5]))\n\n        # End DST\n        idx = date_range(\"2014-11-01 00:00\", \"2014-11-02 00:00\", freq=\"D\", tz=\"UTC\")\n        idx = idx.tz_convert(\"US/Eastern\")\n        tm.assert_index_equal(idx.hour, Index([20, 20]))\n\n        idx = date_range(\n            \"2014-11-01 00:00\", \"2014-11-02 000:00\", freq=\"D\", tz=\"US/Eastern\"\n        )\n        idx = idx.tz_convert(\"UTC\")\n        tm.assert_index_equal(idx.hour, Index([4, 4]))",
        "begin_line": 187,
        "end_line": 252,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_tz_convert_roundtrip#254",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_tz_convert_roundtrip(self, tz_aware_fixture)",
        "snippet": "    def test_tz_convert_roundtrip(self, tz_aware_fixture):\n        tz = tz_aware_fixture\n        idx1 = date_range(start=\"2014-01-01\", end=\"2014-12-31\", freq=\"M\", tz=\"UTC\")\n        exp1 = date_range(start=\"2014-01-01\", end=\"2014-12-31\", freq=\"M\")\n\n        idx2 = date_range(start=\"2014-01-01\", end=\"2014-12-31\", freq=\"D\", tz=\"UTC\")\n        exp2 = date_range(start=\"2014-01-01\", end=\"2014-12-31\", freq=\"D\")\n\n        idx3 = date_range(start=\"2014-01-01\", end=\"2014-03-01\", freq=\"H\", tz=\"UTC\")\n        exp3 = date_range(start=\"2014-01-01\", end=\"2014-03-01\", freq=\"H\")\n\n        idx4 = date_range(start=\"2014-08-01\", end=\"2014-10-31\", freq=\"T\", tz=\"UTC\")\n        exp4 = date_range(start=\"2014-08-01\", end=\"2014-10-31\", freq=\"T\")\n\n        for idx, expected in [(idx1, exp1), (idx2, exp2), (idx3, exp3), (idx4, exp4)]:\n            converted = idx.tz_convert(tz)\n            reset = converted.tz_convert(None)\n            tm.assert_index_equal(reset, expected)\n            assert reset.tzinfo is None\n            expected = converted.tz_convert(\"UTC\").tz_localize(None)\n            tm.assert_index_equal(reset, expected)",
        "begin_line": 254,
        "end_line": 274,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_convert_tzlocal#276",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_convert_tzlocal(self)",
        "snippet": "    def test_dti_tz_convert_tzlocal(self):\n        # GH#13583\n        # tz_convert doesn't affect to internal\n        dti = date_range(start=\"2001-01-01\", end=\"2001-03-01\", tz=\"UTC\")\n        dti2 = dti.tz_convert(dateutil.tz.tzlocal())\n        tm.assert_numpy_array_equal(dti2.asi8, dti.asi8)\n\n        dti = date_range(start=\"2001-01-01\", end=\"2001-03-01\", tz=dateutil.tz.tzlocal())\n        dti2 = dti.tz_convert(None)\n        tm.assert_numpy_array_equal(dti2.asi8, dti.asi8)",
        "begin_line": 276,
        "end_line": 285,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_convert_utc_to_local_no_modify#296",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_convert_utc_to_local_no_modify(self, tz)",
        "snippet": "    def test_dti_tz_convert_utc_to_local_no_modify(self, tz):\n        rng = date_range(\"3/11/2012\", \"3/12/2012\", freq=\"H\", tz=\"utc\")\n        rng_eastern = rng.tz_convert(tz)\n\n        # Values are unmodified\n        tm.assert_numpy_array_equal(rng.asi8, rng_eastern.asi8)\n\n        assert timezones.tz_compare(rng_eastern.tz, timezones.maybe_get_tz(tz))",
        "begin_line": 296,
        "end_line": 303,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_tz_convert_unsorted#306",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_tz_convert_unsorted(self, tzstr)",
        "snippet": "    def test_tz_convert_unsorted(self, tzstr):\n        dr = date_range(\"2012-03-09\", freq=\"H\", periods=100, tz=\"utc\")\n        dr = dr.tz_convert(tzstr)\n\n        result = dr[::-1].hour\n        exp = dr.hour[::-1]\n        tm.assert_almost_equal(result, exp)",
        "begin_line": 306,
        "end_line": 312,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_nonexistent_raise_coerce#317",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_nonexistent_raise_coerce(self)",
        "snippet": "    def test_dti_tz_localize_nonexistent_raise_coerce(self):\n        # GH#13057\n        times = [\"2015-03-08 01:00\", \"2015-03-08 02:00\", \"2015-03-08 03:00\"]\n        index = DatetimeIndex(times)\n        tz = \"US/Eastern\"\n        with pytest.raises(pytz.NonExistentTimeError, match=\"|\".join(times)):\n            index.tz_localize(tz=tz)\n\n        with pytest.raises(pytz.NonExistentTimeError, match=\"|\".join(times)):\n            index.tz_localize(tz=tz, nonexistent=\"raise\")\n\n        result = index.tz_localize(tz=tz, nonexistent=\"NaT\")\n        test_times = [\"2015-03-08 01:00-05:00\", \"NaT\", \"2015-03-08 03:00-04:00\"]\n        dti = to_datetime(test_times, utc=True)\n        expected = dti.tz_convert(\"US/Eastern\")\n        tm.assert_index_equal(result, expected)",
        "begin_line": 317,
        "end_line": 332,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_ambiguous_infer#335",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_ambiguous_infer(self, tz)",
        "snippet": "    def test_dti_tz_localize_ambiguous_infer(self, tz):\n        # November 6, 2011, fall back, repeat 2 AM hour\n        # With no repeated hours, we cannot infer the transition\n        dr = date_range(datetime(2011, 11, 6, 0), periods=5, freq=pd.offsets.Hour())\n        with pytest.raises(pytz.AmbiguousTimeError, match=\"Cannot infer dst time\"):\n            dr.tz_localize(tz)\n\n        # With repeated hours, we can infer the transition\n        dr = date_range(\n            datetime(2011, 11, 6, 0), periods=5, freq=pd.offsets.Hour(), tz=tz\n        )\n        times = [\n            \"11/06/2011 00:00\",\n            \"11/06/2011 01:00\",\n            \"11/06/2011 01:00\",\n            \"11/06/2011 02:00\",\n            \"11/06/2011 03:00\",\n        ]\n        di = DatetimeIndex(times)\n        localized = di.tz_localize(tz, ambiguous=\"infer\")\n        tm.assert_index_equal(dr, localized)\n        tm.assert_index_equal(dr, DatetimeIndex(times, tz=tz, ambiguous=\"infer\"))\n\n        # When there is no dst transition, nothing special happens\n        dr = date_range(datetime(2011, 6, 1, 0), periods=10, freq=pd.offsets.Hour())\n        localized = dr.tz_localize(tz)\n        localized_infer = dr.tz_localize(tz, ambiguous=\"infer\")\n        tm.assert_index_equal(localized, localized_infer)",
        "begin_line": 335,
        "end_line": 362,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_ambiguous_times#365",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_ambiguous_times(self, tz)",
        "snippet": "    def test_dti_tz_localize_ambiguous_times(self, tz):\n        # March 13, 2011, spring forward, skip from 2 AM to 3 AM\n        dr = date_range(datetime(2011, 3, 13, 1, 30), periods=3, freq=pd.offsets.Hour())\n        with pytest.raises(pytz.NonExistentTimeError, match=\"2011-03-13 02:30:00\"):\n            dr.tz_localize(tz)\n\n        # after dst transition, it works\n        dr = date_range(\n            datetime(2011, 3, 13, 3, 30), periods=3, freq=pd.offsets.Hour(), tz=tz\n        )\n\n        # November 6, 2011, fall back, repeat 2 AM hour\n        dr = date_range(datetime(2011, 11, 6, 1, 30), periods=3, freq=pd.offsets.Hour())\n        with pytest.raises(pytz.AmbiguousTimeError, match=\"Cannot infer dst time\"):\n            dr.tz_localize(tz)\n\n        # UTC is OK\n        dr = date_range(\n            datetime(2011, 3, 13), periods=48, freq=pd.offsets.Minute(30), tz=pytz.utc\n        )",
        "begin_line": 365,
        "end_line": 384,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_pass_dates_to_utc#387",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_pass_dates_to_utc(self, tzstr)",
        "snippet": "    def test_dti_tz_localize_pass_dates_to_utc(self, tzstr):\n        strdates = [\"1/1/2012\", \"3/1/2012\", \"4/1/2012\"]\n\n        idx = DatetimeIndex(strdates)\n        conv = idx.tz_localize(tzstr)\n\n        fromdates = DatetimeIndex(strdates, tz=tzstr)\n\n        assert conv.tz == fromdates.tz\n        tm.assert_numpy_array_equal(conv.values, fromdates.values)",
        "begin_line": 387,
        "end_line": 396,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize#399",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize(self, prefix)",
        "snippet": "    def test_dti_tz_localize(self, prefix):\n        tzstr = prefix + \"US/Eastern\"\n        dti = pd.date_range(start=\"1/1/2005\", end=\"1/1/2005 0:00:30.256\", freq=\"L\")\n        dti2 = dti.tz_localize(tzstr)\n\n        dti_utc = pd.date_range(\n            start=\"1/1/2005 05:00\", end=\"1/1/2005 5:00:30.256\", freq=\"L\", tz=\"utc\"\n        )\n\n        tm.assert_numpy_array_equal(dti2.values, dti_utc.values)\n\n        dti3 = dti2.tz_convert(prefix + \"US/Pacific\")\n        tm.assert_numpy_array_equal(dti3.values, dti_utc.values)\n\n        dti = pd.date_range(start=\"11/6/2011 1:59\", end=\"11/6/2011 2:00\", freq=\"L\")\n        with pytest.raises(pytz.AmbiguousTimeError, match=\"Cannot infer dst time\"):\n            dti.tz_localize(tzstr)\n\n        dti = pd.date_range(start=\"3/13/2011 1:59\", end=\"3/13/2011 2:00\", freq=\"L\")\n        with pytest.raises(pytz.NonExistentTimeError, match=\"2011-03-13 02:00:00\"):\n            dti.tz_localize(tzstr)",
        "begin_line": 399,
        "end_line": 419,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_utc_conversion#430",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_utc_conversion(self, tz)",
        "snippet": "    def test_dti_tz_localize_utc_conversion(self, tz):\n        # Localizing to time zone should:\n        #  1) check for DST ambiguities\n        #  2) convert to UTC\n\n        rng = date_range(\"3/10/2012\", \"3/11/2012\", freq=\"30T\")\n\n        converted = rng.tz_localize(tz)\n        expected_naive = rng + pd.offsets.Hour(5)\n        tm.assert_numpy_array_equal(converted.asi8, expected_naive.asi8)\n\n        # DST ambiguity, this should fail\n        rng = date_range(\"3/11/2012\", \"3/12/2012\", freq=\"30T\")\n        # Is this really how it should fail??\n        with pytest.raises(pytz.NonExistentTimeError, match=\"2012-03-11 02:00:00\"):\n            rng.tz_localize(tz)",
        "begin_line": 430,
        "end_line": 445,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_roundtrip#447",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_roundtrip(self, tz_aware_fixture)",
        "snippet": "    def test_dti_tz_localize_roundtrip(self, tz_aware_fixture):\n        # note: this tz tests that a tz-naive index can be localized\n        # and de-localized successfully, when there are no DST transitions\n        # in the range.\n        idx = date_range(start=\"2014-06-01\", end=\"2014-08-30\", freq=\"15T\")\n        tz = tz_aware_fixture\n        localized = idx.tz_localize(tz)\n        # cant localize a tz-aware object\n        with pytest.raises(\n            TypeError, match=\"Already tz-aware, use tz_convert to convert\"\n        ):\n            localized.tz_localize(tz)\n        reset = localized.tz_localize(None)\n        assert reset.tzinfo is None\n        tm.assert_index_equal(reset, idx)",
        "begin_line": 447,
        "end_line": 461,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_naive#463",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_naive(self)",
        "snippet": "    def test_dti_tz_localize_naive(self):\n        rng = date_range(\"1/1/2011\", periods=100, freq=\"H\")\n\n        conv = rng.tz_localize(\"US/Pacific\")\n        exp = date_range(\"1/1/2011\", periods=100, freq=\"H\", tz=\"US/Pacific\")\n\n        tm.assert_index_equal(conv, exp)",
        "begin_line": 463,
        "end_line": 469,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_tzlocal#471",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_tzlocal(self)",
        "snippet": "    def test_dti_tz_localize_tzlocal(self):\n        # GH#13583\n        offset = dateutil.tz.tzlocal().utcoffset(datetime(2011, 1, 1))\n        offset = int(offset.total_seconds() * 1000000000)\n\n        dti = date_range(start=\"2001-01-01\", end=\"2001-03-01\")\n        dti2 = dti.tz_localize(dateutil.tz.tzlocal())\n        tm.assert_numpy_array_equal(dti2.asi8 + offset, dti.asi8)\n\n        dti = date_range(start=\"2001-01-01\", end=\"2001-03-01\", tz=dateutil.tz.tzlocal())\n        dti2 = dti.tz_localize(None)\n        tm.assert_numpy_array_equal(dti2.asi8 - offset, dti.asi8)",
        "begin_line": 471,
        "end_line": 482,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_ambiguous_nat#485",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_ambiguous_nat(self, tz)",
        "snippet": "    def test_dti_tz_localize_ambiguous_nat(self, tz):\n        times = [\n            \"11/06/2011 00:00\",\n            \"11/06/2011 01:00\",\n            \"11/06/2011 01:00\",\n            \"11/06/2011 02:00\",\n            \"11/06/2011 03:00\",\n        ]\n        di = DatetimeIndex(times)\n        localized = di.tz_localize(tz, ambiguous=\"NaT\")\n\n        times = [\n            \"11/06/2011 00:00\",\n            np.NaN,\n            np.NaN,\n            \"11/06/2011 02:00\",\n            \"11/06/2011 03:00\",\n        ]\n        di_test = DatetimeIndex(times, tz=\"US/Eastern\")\n\n        # left dtype is datetime64[ns, US/Eastern]\n        # right is datetime64[ns, tzfile('/usr/share/zoneinfo/US/Eastern')]\n        tm.assert_numpy_array_equal(di_test.values, localized.values)",
        "begin_line": 485,
        "end_line": 507,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_ambiguous_flags#510",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_ambiguous_flags(self, tz)",
        "snippet": "    def test_dti_tz_localize_ambiguous_flags(self, tz):\n        # November 6, 2011, fall back, repeat 2 AM hour\n\n        # Pass in flags to determine right dst transition\n        dr = date_range(\n            datetime(2011, 11, 6, 0), periods=5, freq=pd.offsets.Hour(), tz=tz\n        )\n        times = [\n            \"11/06/2011 00:00\",\n            \"11/06/2011 01:00\",\n            \"11/06/2011 01:00\",\n            \"11/06/2011 02:00\",\n            \"11/06/2011 03:00\",\n        ]\n\n        # Test tz_localize\n        di = DatetimeIndex(times)\n        is_dst = [1, 1, 0, 0, 0]\n        localized = di.tz_localize(tz, ambiguous=is_dst)\n        tm.assert_index_equal(dr, localized)\n        tm.assert_index_equal(dr, DatetimeIndex(times, tz=tz, ambiguous=is_dst))\n\n        localized = di.tz_localize(tz, ambiguous=np.array(is_dst))\n        tm.assert_index_equal(dr, localized)\n\n        localized = di.tz_localize(tz, ambiguous=np.array(is_dst).astype(\"bool\"))\n        tm.assert_index_equal(dr, localized)\n\n        # Test constructor\n        localized = DatetimeIndex(times, tz=tz, ambiguous=is_dst)\n        tm.assert_index_equal(dr, localized)\n\n        # Test duplicate times where inferring the dst fails\n        times += times\n        di = DatetimeIndex(times)\n\n        # When the sizes are incompatible, make sure error is raised\n        msg = \"Length of ambiguous bool-array must be the same size as vals\"\n        with pytest.raises(Exception, match=msg):\n            di.tz_localize(tz, ambiguous=is_dst)\n\n        # When sizes are compatible and there are repeats ('infer' won't work)\n        is_dst = np.hstack((is_dst, is_dst))\n        localized = di.tz_localize(tz, ambiguous=is_dst)\n        dr = dr.append(dr)\n        tm.assert_index_equal(dr, localized)\n\n        # When there is no dst transition, nothing special happens\n        dr = date_range(datetime(2011, 6, 1, 0), periods=10, freq=pd.offsets.Hour())\n        is_dst = np.array([1] * 10)\n        localized = dr.tz_localize(tz)\n        localized_is_dst = dr.tz_localize(tz, ambiguous=is_dst)\n        tm.assert_index_equal(localized, localized_is_dst)",
        "begin_line": 510,
        "end_line": 562,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_construction_ambiguous_endpoint#566",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_construction_ambiguous_endpoint(self, tz)",
        "snippet": "    def test_dti_construction_ambiguous_endpoint(self, tz):\n        # construction with an ambiguous end-point\n        # GH#11626\n\n        with pytest.raises(pytz.AmbiguousTimeError, match=\"Cannot infer dst time\"):\n            date_range(\n                \"2013-10-26 23:00\", \"2013-10-27 01:00\", tz=\"Europe/London\", freq=\"H\"\n            )\n\n        times = date_range(\n            \"2013-10-26 23:00\", \"2013-10-27 01:00\", freq=\"H\", tz=tz, ambiguous=\"infer\"\n        )\n        assert times[0] == Timestamp(\"2013-10-26 23:00\", tz=tz, freq=\"H\")\n        assert times[-1] == Timestamp(\"2013-10-27 01:00:00+0000\", tz=tz, freq=\"H\")",
        "begin_line": 566,
        "end_line": 579,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_construction_nonexistent_endpoint#591",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_construction_nonexistent_endpoint(self, tz, option, expected)",
        "snippet": "    def test_dti_construction_nonexistent_endpoint(self, tz, option, expected):\n        # construction with an nonexistent end-point\n\n        with pytest.raises(pytz.NonExistentTimeError, match=\"2019-03-10 02:00:00\"):\n            date_range(\n                \"2019-03-10 00:00\", \"2019-03-10 02:00\", tz=\"US/Pacific\", freq=\"H\"\n            )\n\n        times = date_range(\n            \"2019-03-10 00:00\", \"2019-03-10 02:00\", freq=\"H\", tz=tz, nonexistent=option\n        )\n        assert times[-1] == Timestamp(expected, tz=tz, freq=\"H\")",
        "begin_line": 591,
        "end_line": 602,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_bdate_range#604",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_bdate_range(self)",
        "snippet": "    def test_dti_tz_localize_bdate_range(self):\n        dr = pd.bdate_range(\"1/1/2009\", \"1/1/2010\")\n        dr_utc = pd.bdate_range(\"1/1/2009\", \"1/1/2010\", tz=pytz.utc)\n        localized = dr.tz_localize(pytz.utc)\n        tm.assert_index_equal(dr_utc, localized)",
        "begin_line": 604,
        "end_line": 608,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_nonexistent#614",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_nonexistent(self, tz, method, exp)",
        "snippet": "    def test_dti_tz_localize_nonexistent(self, tz, method, exp):\n        # GH 8917\n        n = 60\n        dti = date_range(start=\"2015-03-29 02:00:00\", periods=n, freq=\"min\")\n        if method == \"raise\":\n            with pytest.raises(pytz.NonExistentTimeError, match=\"2015-03-29 02:00:00\"):\n                dti.tz_localize(tz, nonexistent=method)\n        elif exp == \"invalid\":\n            msg = (\n                \"The nonexistent argument must be one of \"\n                \"'raise', 'NaT', 'shift_forward', 'shift_backward' \"\n                \"or a timedelta object\"\n            )\n            with pytest.raises(ValueError, match=msg):\n                dti.tz_localize(tz, nonexistent=method)\n        else:\n            result = dti.tz_localize(tz, nonexistent=method)\n            expected = DatetimeIndex([exp] * n, tz=tz)\n            tm.assert_index_equal(result, expected)",
        "begin_line": 614,
        "end_line": 632,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_nonexistent_shift#678",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_nonexistent_shift(self, start_ts, tz, end_ts, shift, tz_type)",
        "snippet": "    def test_dti_tz_localize_nonexistent_shift(\n        self, start_ts, tz, end_ts, shift, tz_type\n    ):\n        # GH 8917\n        tz = tz_type + tz\n        if isinstance(shift, str):\n            shift = \"shift_\" + shift\n        dti = DatetimeIndex([Timestamp(start_ts)])\n        result = dti.tz_localize(tz, nonexistent=shift)\n        expected = DatetimeIndex([Timestamp(end_ts)]).tz_localize(tz)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 678,
        "end_line": 688,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_nonexistent_shift_invalid#692",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_localize_nonexistent_shift_invalid(self, offset, tz_type)",
        "snippet": "    def test_dti_tz_localize_nonexistent_shift_invalid(self, offset, tz_type):\n        # GH 8917\n        tz = tz_type + \"Europe/Warsaw\"\n        dti = DatetimeIndex([Timestamp(\"2015-03-29 02:20:00\")])\n        msg = \"The provided timedelta will relocalize on a nonexistent time\"\n        with pytest.raises(ValueError, match=msg):\n            dti.tz_localize(tz, nonexistent=timedelta(seconds=offset))",
        "begin_line": 692,
        "end_line": 698,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_normalize_tz#703",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_normalize_tz(self)",
        "snippet": "    def test_normalize_tz(self):\n        rng = date_range(\"1/1/2000 9:30\", periods=10, freq=\"D\", tz=\"US/Eastern\")\n\n        result = rng.normalize()\n        expected = date_range(\"1/1/2000\", periods=10, freq=\"D\", tz=\"US/Eastern\")\n        tm.assert_index_equal(result, expected)\n\n        assert result.is_normalized\n        assert not rng.is_normalized\n\n        rng = date_range(\"1/1/2000 9:30\", periods=10, freq=\"D\", tz=\"UTC\")\n\n        result = rng.normalize()\n        expected = date_range(\"1/1/2000\", periods=10, freq=\"D\", tz=\"UTC\")\n        tm.assert_index_equal(result, expected)\n\n        assert result.is_normalized\n        assert not rng.is_normalized\n\n        rng = date_range(\"1/1/2000 9:30\", periods=10, freq=\"D\", tz=tzlocal())\n        result = rng.normalize()\n        expected = date_range(\"1/1/2000\", periods=10, freq=\"D\", tz=tzlocal())\n        tm.assert_index_equal(result, expected)\n\n        assert result.is_normalized\n        assert not rng.is_normalized",
        "begin_line": 703,
        "end_line": 728,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_normalize_tz_local#742",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_normalize_tz_local(self, timezone)",
        "snippet": "    def test_normalize_tz_local(self, timezone):\n        # GH#13459\n        with tm.set_timezone(timezone):\n            rng = date_range(\"1/1/2000 9:30\", periods=10, freq=\"D\", tz=tzlocal())\n\n            result = rng.normalize()\n            expected = date_range(\"1/1/2000\", periods=10, freq=\"D\", tz=tzlocal())\n            tm.assert_index_equal(result, expected)\n\n            assert result.is_normalized\n            assert not rng.is_normalized",
        "begin_line": 742,
        "end_line": 752,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_constructor_static_tzinfo#758",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_constructor_static_tzinfo(self, prefix)",
        "snippet": "    def test_dti_constructor_static_tzinfo(self, prefix):\n        # it works!\n        index = DatetimeIndex([datetime(2012, 1, 1)], tz=prefix + \"EST\")\n        index.hour\n        index[0]",
        "begin_line": 758,
        "end_line": 762,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_constructor_with_fixed_tz#764",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_constructor_with_fixed_tz(self)",
        "snippet": "    def test_dti_constructor_with_fixed_tz(self):\n        off = FixedOffset(420, \"+07:00\")\n        start = datetime(2012, 3, 11, 5, 0, 0, tzinfo=off)\n        end = datetime(2012, 6, 11, 5, 0, 0, tzinfo=off)\n        rng = date_range(start=start, end=end)\n        assert off == rng.tz\n\n        rng2 = date_range(start, periods=len(rng), tz=off)\n        tm.assert_index_equal(rng, rng2)\n\n        rng3 = date_range(\"3/11/2012 05:00:00+07:00\", \"6/11/2012 05:00:00+07:00\")\n        assert (rng.values == rng3.values).all()",
        "begin_line": 764,
        "end_line": 775,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_convert_datetime_list#778",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_convert_datetime_list(self, tzstr)",
        "snippet": "    def test_dti_convert_datetime_list(self, tzstr):\n        dr = date_range(\"2012-06-02\", periods=10, tz=tzstr, name=\"foo\")\n        dr2 = DatetimeIndex(list(dr), name=\"foo\")\n        tm.assert_index_equal(dr, dr2)\n        assert dr.tz == dr2.tz\n        assert dr2.name == \"foo\"",
        "begin_line": 778,
        "end_line": 783,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_construction_univalent#785",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_construction_univalent(self)",
        "snippet": "    def test_dti_construction_univalent(self):\n        rng = date_range(\"03/12/2012 00:00\", periods=10, freq=\"W-FRI\", tz=\"US/Eastern\")\n        rng2 = DatetimeIndex(data=rng, tz=\"US/Eastern\")\n        tm.assert_index_equal(rng, rng2)",
        "begin_line": 785,
        "end_line": 788,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_from_tzaware_datetime#791",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_from_tzaware_datetime(self, tz)",
        "snippet": "    def test_dti_from_tzaware_datetime(self, tz):\n        d = [datetime(2012, 8, 19, tzinfo=tz)]\n\n        index = DatetimeIndex(d)\n        assert timezones.tz_compare(index.tz, tz)",
        "begin_line": 791,
        "end_line": 795,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_constructors#798",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_constructors(self, tzstr)",
        "snippet": "    def test_dti_tz_constructors(self, tzstr):\n        \"\"\" Test different DatetimeIndex constructions with timezone\n        Follow-up of GH#4229\n        \"\"\"\n        arr = [\"11/10/2005 08:00:00\", \"11/10/2005 09:00:00\"]\n\n        idx1 = to_datetime(arr).tz_localize(tzstr)\n        idx2 = pd.date_range(start=\"2005-11-10 08:00:00\", freq=\"H\", periods=2, tz=tzstr)\n        idx3 = DatetimeIndex(arr, tz=tzstr)\n        idx4 = DatetimeIndex(np.array(arr), tz=tzstr)\n\n        for other in [idx2, idx3, idx4]:\n            tm.assert_index_equal(idx1, other)",
        "begin_line": 798,
        "end_line": 810,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_date_accessor#819",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_date_accessor(self, dtype)",
        "snippet": "    def test_date_accessor(self, dtype):\n        # Regression test for GH#21230\n        expected = np.array([date(2018, 6, 4), pd.NaT])\n\n        index = DatetimeIndex([\"2018-06-04 10:00:00\", pd.NaT], dtype=dtype)\n        result = index.date\n\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 819,
        "end_line": 826,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_time_accessor#832",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_time_accessor(self, dtype)",
        "snippet": "    def test_time_accessor(self, dtype):\n        # Regression test for GH#21267\n        expected = np.array([time(10, 20, 30), pd.NaT])\n\n        index = DatetimeIndex([\"2018-06-04 10:20:30\", pd.NaT], dtype=dtype)\n        result = index.time\n\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 832,
        "end_line": 839,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_timetz_accessor#841",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_timetz_accessor(self, tz_naive_fixture)",
        "snippet": "    def test_timetz_accessor(self, tz_naive_fixture):\n        # GH21358\n        tz = timezones.maybe_get_tz(tz_naive_fixture)\n\n        expected = np.array([time(10, 20, 30, tzinfo=tz), pd.NaT])\n\n        index = DatetimeIndex([\"2018-06-04 10:20:30\", pd.NaT], tz=tz)\n        result = index.timetz\n\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 841,
        "end_line": 850,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_drop_dont_lose_tz#852",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_drop_dont_lose_tz(self)",
        "snippet": "    def test_dti_drop_dont_lose_tz(self):\n        # GH#2621\n        ind = date_range(\"2012-12-01\", periods=10, tz=\"utc\")\n        ind = ind.drop(ind[-1])\n\n        assert ind.tz is not None",
        "begin_line": 852,
        "end_line": 857,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_conversion_freq#859",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_conversion_freq(self, tz_naive_fixture)",
        "snippet": "    def test_dti_tz_conversion_freq(self, tz_naive_fixture):\n        # GH25241\n        t3 = DatetimeIndex([\"2019-01-01 10:00\"], freq=\"H\")\n        assert t3.tz_localize(tz=tz_naive_fixture).freq == t3.freq\n        t4 = DatetimeIndex([\"2019-01-02 12:00\"], tz=\"UTC\", freq=\"T\")\n        assert t4.tz_convert(tz=\"UTC\").freq == t4.freq",
        "begin_line": 859,
        "end_line": 864,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_drop_dst_boundary#866",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_drop_dst_boundary(self)",
        "snippet": "    def test_drop_dst_boundary(self):\n        # see gh-18031\n        tz = \"Europe/Brussels\"\n        freq = \"15min\"\n\n        start = pd.Timestamp(\"201710290100\", tz=tz)\n        end = pd.Timestamp(\"201710290300\", tz=tz)\n        index = pd.date_range(start=start, end=end, freq=freq)\n\n        expected = DatetimeIndex(\n            [\n                \"201710290115\",\n                \"201710290130\",\n                \"201710290145\",\n                \"201710290200\",\n                \"201710290215\",\n                \"201710290230\",\n                \"201710290245\",\n                \"201710290200\",\n                \"201710290215\",\n                \"201710290230\",\n                \"201710290245\",\n                \"201710290300\",\n            ],\n            tz=tz,\n            freq=freq,\n            ambiguous=[\n                True,\n                True,\n                True,\n                True,\n                True,\n                True,\n                True,\n                False,\n                False,\n                False,\n                False,\n                False,\n            ],\n        )\n        result = index.drop(index[0])\n        tm.assert_index_equal(result, expected)",
        "begin_line": 866,
        "end_line": 908,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_date_range_localize#910",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_date_range_localize(self)",
        "snippet": "    def test_date_range_localize(self):\n        rng = date_range(\"3/11/2012 03:00\", periods=15, freq=\"H\", tz=\"US/Eastern\")\n        rng2 = DatetimeIndex([\"3/11/2012 03:00\", \"3/11/2012 04:00\"], tz=\"US/Eastern\")\n        rng3 = date_range(\"3/11/2012 03:00\", periods=15, freq=\"H\")\n        rng3 = rng3.tz_localize(\"US/Eastern\")\n\n        tm.assert_index_equal(rng, rng3)\n\n        # DST transition time\n        val = rng[0]\n        exp = Timestamp(\"3/11/2012 03:00\", tz=\"US/Eastern\")\n\n        assert val.hour == 3\n        assert exp.hour == 3\n        assert val == exp  # same UTC value\n        tm.assert_index_equal(rng[:2], rng2)\n\n        # Right before the DST transition\n        rng = date_range(\"3/11/2012 00:00\", periods=2, freq=\"H\", tz=\"US/Eastern\")\n        rng2 = DatetimeIndex([\"3/11/2012 00:00\", \"3/11/2012 01:00\"], tz=\"US/Eastern\")\n        tm.assert_index_equal(rng, rng2)\n        exp = Timestamp(\"3/11/2012 00:00\", tz=\"US/Eastern\")\n        assert exp.hour == 0\n        assert rng[0] == exp\n        exp = Timestamp(\"3/11/2012 01:00\", tz=\"US/Eastern\")\n        assert exp.hour == 1\n        assert rng[1] == exp\n\n        rng = date_range(\"3/11/2012 00:00\", periods=10, freq=\"H\", tz=\"US/Eastern\")\n        assert rng[2].hour == 3",
        "begin_line": 910,
        "end_line": 939,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_timestamp_equality_different_timezones#941",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_timestamp_equality_different_timezones(self)",
        "snippet": "    def test_timestamp_equality_different_timezones(self):\n        utc_range = date_range(\"1/1/2000\", periods=20, tz=\"UTC\")\n        eastern_range = utc_range.tz_convert(\"US/Eastern\")\n        berlin_range = utc_range.tz_convert(\"Europe/Berlin\")\n\n        for a, b, c in zip(utc_range, eastern_range, berlin_range):\n            assert a == b\n            assert b == c\n            assert a == c\n\n        assert (utc_range == eastern_range).all()\n        assert (utc_range == berlin_range).all()\n        assert (berlin_range == eastern_range).all()",
        "begin_line": 941,
        "end_line": 953,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_intersection#955",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_intersection(self)",
        "snippet": "    def test_dti_intersection(self):\n        rng = date_range(\"1/1/2011\", periods=100, freq=\"H\", tz=\"utc\")\n\n        left = rng[10:90][::-1]\n        right = rng[20:80][::-1]\n\n        assert left.tz == rng.tz\n        result = left.intersection(right)\n        assert result.tz == left.tz",
        "begin_line": 955,
        "end_line": 963,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_equals_with_tz#965",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_equals_with_tz(self)",
        "snippet": "    def test_dti_equals_with_tz(self):\n        left = date_range(\"1/1/2011\", periods=100, freq=\"H\", tz=\"utc\")\n        right = date_range(\"1/1/2011\", periods=100, freq=\"H\", tz=\"US/Eastern\")\n\n        assert not left.equals(right)",
        "begin_line": 965,
        "end_line": 969,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_nat#972",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_tz_nat(self, tzstr)",
        "snippet": "    def test_dti_tz_nat(self, tzstr):\n        idx = DatetimeIndex([Timestamp(\"2013-1-1\", tz=tzstr), pd.NaT])\n\n        assert isna(idx[1])\n        assert idx[0].tzinfo is not None",
        "begin_line": 972,
        "end_line": 976,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_astype_asobject_tzinfos#979",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_astype_asobject_tzinfos(self, tzstr)",
        "snippet": "    def test_dti_astype_asobject_tzinfos(self, tzstr):\n        # GH#1345\n\n        # dates around a dst transition\n        rng = date_range(\"2/13/2010\", \"5/6/2010\", tz=tzstr)\n\n        objs = rng.astype(object)\n        for i, x in enumerate(objs):\n            exval = rng[i]\n            assert x == exval\n            assert x.tzinfo == exval.tzinfo\n\n        objs = rng.astype(object)\n        for i, x in enumerate(objs):\n            exval = rng[i]\n            assert x == exval\n            assert x.tzinfo == exval.tzinfo",
        "begin_line": 979,
        "end_line": 995,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_with_timezone_repr#998",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_with_timezone_repr(self, tzstr)",
        "snippet": "    def test_dti_with_timezone_repr(self, tzstr):\n        rng = date_range(\"4/13/2010\", \"5/6/2010\")\n\n        rng_eastern = rng.tz_localize(tzstr)\n\n        rng_repr = repr(rng_eastern)\n        assert \"2010-04-13 00:00:00\" in rng_repr",
        "begin_line": 998,
        "end_line": 1004,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_take_dont_lose_meta#1007",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_take_dont_lose_meta(self, tzstr)",
        "snippet": "    def test_dti_take_dont_lose_meta(self, tzstr):\n        rng = date_range(\"1/1/2000\", periods=20, tz=tzstr)\n\n        result = rng.take(range(5))\n        assert result.tz == rng.tz\n        assert result.freq == rng.freq",
        "begin_line": 1007,
        "end_line": 1012,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_utc_box_timestamp_and_localize#1015",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_utc_box_timestamp_and_localize(self, tzstr)",
        "snippet": "    def test_utc_box_timestamp_and_localize(self, tzstr):\n        tz = timezones.maybe_get_tz(tzstr)\n\n        rng = date_range(\"3/11/2012\", \"3/12/2012\", freq=\"H\", tz=\"utc\")\n        rng_eastern = rng.tz_convert(tzstr)\n\n        expected = rng[-1].astimezone(tz)\n\n        stamp = rng_eastern[-1]\n        assert stamp == expected\n        assert stamp.tzinfo == expected.tzinfo\n\n        # right tzinfo\n        rng = date_range(\"3/13/2012\", \"3/14/2012\", freq=\"H\", tz=\"utc\")\n        rng_eastern = rng.tz_convert(tzstr)\n        # test not valid for dateutil timezones.\n        # assert 'EDT' in repr(rng_eastern[0].tzinfo)\n        assert \"EDT\" in repr(rng_eastern[0].tzinfo) or \"tzfile\" in repr(\n            rng_eastern[0].tzinfo\n        )",
        "begin_line": 1015,
        "end_line": 1034,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_to_pydatetime#1036",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_to_pydatetime(self)",
        "snippet": "    def test_dti_to_pydatetime(self):\n        dt = dateutil.parser.parse(\"2012-06-13T01:39:00Z\")\n        dt = dt.replace(tzinfo=tzlocal())\n\n        arr = np.array([dt], dtype=object)\n\n        result = to_datetime(arr, utc=True)\n        assert result.tz is pytz.utc\n\n        rng = date_range(\"2012-11-03 03:00\", \"2012-11-05 03:00\", tz=tzlocal())\n        arr = rng.to_pydatetime()\n        result = to_datetime(arr, utc=True)\n        assert result.tz is pytz.utc",
        "begin_line": 1036,
        "end_line": 1048,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_to_pydatetime_fizedtz#1050",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_to_pydatetime_fizedtz(self)",
        "snippet": "    def test_dti_to_pydatetime_fizedtz(self):\n        dates = np.array(\n            [\n                datetime(2000, 1, 1, tzinfo=fixed_off),\n                datetime(2000, 1, 2, tzinfo=fixed_off),\n                datetime(2000, 1, 3, tzinfo=fixed_off),\n            ]\n        )\n        dti = DatetimeIndex(dates)\n\n        result = dti.to_pydatetime()\n        tm.assert_numpy_array_equal(dates, result)\n\n        result = dti._mpl_repr()\n        tm.assert_numpy_array_equal(dates, result)",
        "begin_line": 1050,
        "end_line": 1064,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_with_tz#1067",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_with_tz(self, tz)",
        "snippet": "    def test_with_tz(self, tz):\n        # just want it to work\n        start = datetime(2011, 3, 12, tzinfo=pytz.utc)\n        dr = bdate_range(start, periods=50, freq=pd.offsets.Hour())\n        assert dr.tz is pytz.utc\n\n        # DateRange with naive datetimes\n        dr = bdate_range(\"1/1/2005\", \"1/1/2009\", tz=pytz.utc)\n        dr = bdate_range(\"1/1/2005\", \"1/1/2009\", tz=tz)\n\n        # normalized\n        central = dr.tz_convert(tz)\n        assert central.tz is tz\n        naive = central[0].to_pydatetime().replace(tzinfo=None)\n        comp = conversion.localize_pydatetime(naive, tz).tzinfo\n        assert central[0].tz is comp\n\n        # compare vs a localized tz\n        naive = dr[0].to_pydatetime().replace(tzinfo=None)\n        comp = conversion.localize_pydatetime(naive, tz).tzinfo\n        assert central[0].tz is comp\n\n        # datetimes with tzinfo set\n        dr = bdate_range(\n            datetime(2005, 1, 1, tzinfo=pytz.utc), datetime(2009, 1, 1, tzinfo=pytz.utc)\n        )\n        msg = \"Start and end cannot both be tz-aware with different timezones\"\n        with pytest.raises(Exception, match=msg):\n            bdate_range(datetime(2005, 1, 1, tzinfo=pytz.utc), \"1/1/2009\", tz=tz)",
        "begin_line": 1067,
        "end_line": 1095,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_field_access_localize#1098",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_field_access_localize(self, prefix)",
        "snippet": "    def test_field_access_localize(self, prefix):\n        strdates = [\"1/1/2012\", \"3/1/2012\", \"4/1/2012\"]\n        rng = DatetimeIndex(strdates, tz=prefix + \"US/Eastern\")\n        assert (rng.hour == 0).all()\n\n        # a more unusual time zone, #1946\n        dr = date_range(\n            \"2011-10-02 00:00\", freq=\"h\", periods=10, tz=prefix + \"America/Atikokan\"\n        )\n\n        expected = Index(np.arange(10, dtype=np.int64))\n        tm.assert_index_equal(dr.hour, expected)",
        "begin_line": 1098,
        "end_line": 1109,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_convert_tz_aware_datetime_datetime#1112",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_convert_tz_aware_datetime_datetime(self, tz)",
        "snippet": "    def test_dti_convert_tz_aware_datetime_datetime(self, tz):\n        # GH#1581\n        dates = [datetime(2000, 1, 1), datetime(2000, 1, 2), datetime(2000, 1, 3)]\n\n        dates_aware = [conversion.localize_pydatetime(x, tz) for x in dates]\n        result = DatetimeIndex(dates_aware)\n        assert timezones.tz_compare(result.tz, tz)\n\n        converted = to_datetime(dates_aware, utc=True)\n        ex_vals = np.array([Timestamp(x).value for x in dates_aware])\n        tm.assert_numpy_array_equal(converted.asi8, ex_vals)\n        assert converted.tz is pytz.utc",
        "begin_line": 1112,
        "end_line": 1123,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_union_aware#1125",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_union_aware(self)",
        "snippet": "    def test_dti_union_aware(self):\n        # non-overlapping\n        rng = date_range(\"2012-11-15 00:00:00\", periods=6, freq=\"H\", tz=\"US/Central\")\n\n        rng2 = date_range(\"2012-11-15 12:00:00\", periods=6, freq=\"H\", tz=\"US/Eastern\")\n\n        result = rng.union(rng2)\n        expected = rng.astype(\"O\").union(rng2.astype(\"O\"))\n        tm.assert_index_equal(result, expected)\n        assert result[0].tz.zone == \"US/Central\"\n        assert result[-1].tz.zone == \"US/Eastern\"",
        "begin_line": 1125,
        "end_line": 1135,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_union_mixed#1137",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_dti_union_mixed(self)",
        "snippet": "    def test_dti_union_mixed(self):\n        # GH 21671\n        rng = DatetimeIndex([pd.Timestamp(\"2011-01-01\"), pd.NaT])\n        rng2 = pd.DatetimeIndex([\"2012-01-01\", \"2012-01-02\"], tz=\"Asia/Tokyo\")\n        result = rng.union(rng2)\n        expected = Index(\n            [\n                pd.Timestamp(\"2011-01-01\"),\n                pd.NaT,\n                pd.Timestamp(\"2012-01-01\", tz=\"Asia/Tokyo\"),\n                pd.Timestamp(\"2012-01-02\", tz=\"Asia/Tokyo\"),\n            ],\n            dtype=object,\n        )\n        tm.assert_index_equal(result, expected)",
        "begin_line": 1137,
        "end_line": 1151,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_iteration_preserves_nanoseconds#1157",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.TestDatetimeIndexTimezones.test_iteration_preserves_nanoseconds(self, tz)",
        "snippet": "    def test_iteration_preserves_nanoseconds(self, tz):\n        # GH 19603\n        index = DatetimeIndex(\n            [\"2018-02-08 15:00:00.168456358\", \"2018-02-08 15:00:00.168456359\"], tz=tz\n        )\n        for i, ts in enumerate(index):\n            assert ts == index[i]",
        "begin_line": 1157,
        "end_line": 1163,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimes.test_timezones.test_tz_localize_invalidates_freq#1166",
        "src_path": "pandas/tests/indexes/datetimes/test_timezones.py",
        "class_name": "pandas.tests.indexes.datetimes.test_timezones",
        "signature": "pandas.tests.indexes.datetimes.test_timezones.test_tz_localize_invalidates_freq()",
        "snippet": "def test_tz_localize_invalidates_freq():\n    # we only preserve freq in unambiguous cases\n\n    # if localized to US/Eastern, this crosses a DST transition\n    dti = date_range(\"2014-03-08 23:00\", \"2014-03-09 09:00\", freq=\"H\")\n    assert dti.freq == \"H\"\n\n    result = dti.tz_localize(None)  # no-op\n    assert result.freq == \"H\"\n\n    result = dti.tz_localize(\"UTC\")  # unambiguous freq preservation\n    assert result.freq == \"H\"\n\n    result = dti.tz_localize(\"US/Eastern\", nonexistent=\"shift_forward\")\n    assert result.freq is None\n    assert result.inferred_freq is None  # i.e. we are not _too_ strict here\n\n    # Case where we _can_ keep freq because we're length==1\n    dti2 = dti[:1]\n    result = dti2.tz_localize(\"US/Eastern\")\n    assert result.freq == \"H\"",
        "begin_line": 1166,
        "end_line": 1186,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_pickle_compat_construction#41",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_pickle_compat_construction(self)",
        "snippet": "    def test_pickle_compat_construction(self):\n        # need an object to create with\n        msg = (\n            r\"Index\\(\\.\\.\\.\\) must be called with a collection of some \"\n            r\"kind, None was passed|\"\n            r\"__new__\\(\\) missing 1 required positional argument: 'data'|\"\n            r\"__new__\\(\\) takes at least 2 arguments \\(1 given\\)\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            self._holder()",
        "begin_line": 41,
        "end_line": 50,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_frame#53",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_frame(self, name)",
        "snippet": "    def test_to_frame(self, name):\n        # see GH-15230, GH-22580\n        idx = self.create_index()\n\n        if name:\n            idx_name = name\n        else:\n            idx_name = idx.name or 0\n\n        df = idx.to_frame(name=idx_name)\n\n        assert df.index is idx\n        assert len(df.columns) == 1\n        assert df.columns[0] == idx_name\n        assert df[idx_name].values is not idx.values\n\n        df = idx.to_frame(index=False, name=idx_name)\n        assert df.index is not idx",
        "begin_line": 53,
        "end_line": 70,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_shift#72",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_shift(self)",
        "snippet": "    def test_shift(self):\n\n        # GH8083 test the base class for shift\n        idx = self.create_index()\n        msg = f\"Not supported for type {type(idx).__name__}\"\n        with pytest.raises(NotImplementedError, match=msg):\n            idx.shift(1)\n        with pytest.raises(NotImplementedError, match=msg):\n            idx.shift(1, 2)",
        "begin_line": 72,
        "end_line": 80,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_constructor_name_unhashable#82",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_constructor_name_unhashable(self)",
        "snippet": "    def test_constructor_name_unhashable(self):\n        # GH#29069 check that name is hashable\n        # See also same-named test in tests.series.test_constructors\n        idx = self.create_index()\n        with pytest.raises(TypeError, match=\"Index.name must be a hashable type\"):\n            type(idx)(idx, name=[])",
        "begin_line": 82,
        "end_line": 87,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_create_index_existing_name#89",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_create_index_existing_name(self)",
        "snippet": "    def test_create_index_existing_name(self):\n\n        # GH11193, when an existing index is passed, and a new name is not\n        # specified, the new index should inherit the previous object name\n        expected = self.create_index()\n        if not isinstance(expected, MultiIndex):\n            expected.name = \"foo\"\n            result = pd.Index(expected)\n            tm.assert_index_equal(result, expected)\n\n            result = pd.Index(expected, name=\"bar\")\n            expected.name = \"bar\"\n            tm.assert_index_equal(result, expected)\n        else:\n            expected.names = [\"foo\", \"bar\"]\n            result = pd.Index(expected)\n            tm.assert_index_equal(\n                result,\n                Index(\n                    Index(\n                        [\n                            (\"foo\", \"one\"),\n                            (\"foo\", \"two\"),\n                            (\"bar\", \"one\"),\n                            (\"baz\", \"two\"),\n                            (\"qux\", \"one\"),\n                            (\"qux\", \"two\"),\n                        ],\n                        dtype=\"object\",\n                    ),\n                    names=[\"foo\", \"bar\"],\n                ),\n            )\n\n            result = pd.Index(expected, names=[\"A\", \"B\"])\n            tm.assert_index_equal(\n                result,\n                Index(\n                    Index(\n                        [\n                            (\"foo\", \"one\"),\n                            (\"foo\", \"two\"),\n                            (\"bar\", \"one\"),\n                            (\"baz\", \"two\"),\n                            (\"qux\", \"one\"),\n                            (\"qux\", \"two\"),\n                        ],\n                        dtype=\"object\",\n                    ),\n                    names=[\"A\", \"B\"],\n                ),\n            )",
        "begin_line": 89,
        "end_line": 140,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numeric_compat#142",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numeric_compat(self)",
        "snippet": "    def test_numeric_compat(self):\n\n        idx = self.create_index()\n        # Check that this doesn't cover MultiIndex case, if/when it does,\n        #  we can remove multi.test_compat.test_numeric_compat\n        assert not isinstance(idx, MultiIndex)\n\n        with pytest.raises(TypeError, match=\"cannot perform __mul__\"):\n            idx * 1\n        with pytest.raises(TypeError, match=\"cannot perform __rmul__\"):\n            1 * idx\n\n        div_err = \"cannot perform __truediv__\"\n        with pytest.raises(TypeError, match=div_err):\n            idx / 1\n\n        div_err = div_err.replace(\" __\", \" __r\")\n        with pytest.raises(TypeError, match=div_err):\n            1 / idx\n        with pytest.raises(TypeError, match=\"cannot perform __floordiv__\"):\n            idx // 1\n        with pytest.raises(TypeError, match=\"cannot perform __rfloordiv__\"):\n            1 // idx",
        "begin_line": 142,
        "end_line": 164,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_logical_compat#166",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_logical_compat(self)",
        "snippet": "    def test_logical_compat(self):\n        idx = self.create_index()\n        with pytest.raises(TypeError, match=\"cannot perform all\"):\n            idx.all()\n        with pytest.raises(TypeError, match=\"cannot perform any\"):\n            idx.any()",
        "begin_line": 166,
        "end_line": 171,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_reindex_base#173",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_reindex_base(self)",
        "snippet": "    def test_reindex_base(self):\n        idx = self.create_index()\n        expected = np.arange(idx.size, dtype=np.intp)\n\n        actual = idx.get_indexer(idx)\n        tm.assert_numpy_array_equal(expected, actual)\n\n        with pytest.raises(ValueError, match=\"Invalid fill method\"):\n            idx.get_indexer(idx, method=\"invalid\")",
        "begin_line": 173,
        "end_line": 181,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_get_indexer_consistency#183",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_get_indexer_consistency(self, indices)",
        "snippet": "    def test_get_indexer_consistency(self, indices):\n        # See GH 16819\n        if isinstance(indices, IntervalIndex):\n            return\n\n        if indices.is_unique or isinstance(indices, CategoricalIndex):\n            indexer = indices.get_indexer(indices[0:2])\n            assert isinstance(indexer, np.ndarray)\n            assert indexer.dtype == np.intp\n        else:\n            e = \"Reindexing only valid with uniquely valued Index objects\"\n            with pytest.raises(InvalidIndexError, match=e):\n                indices.get_indexer(indices[0:2])\n\n        indexer, _ = indices.get_indexer_non_unique(indices[0:2])\n        assert isinstance(indexer, np.ndarray)\n        assert indexer.dtype == np.intp",
        "begin_line": 183,
        "end_line": 199,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_ndarray_compat_properties#201",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_ndarray_compat_properties(self)",
        "snippet": "    def test_ndarray_compat_properties(self):\n        idx = self.create_index()\n        assert idx.T.equals(idx)\n        assert idx.transpose().equals(idx)\n\n        values = idx.values\n        for prop in self._compat_props:\n            assert getattr(idx, prop) == getattr(values, prop)\n\n        # test for validity\n        idx.nbytes\n        idx.values.nbytes",
        "begin_line": 201,
        "end_line": 212,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repr_roundtrip#214",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repr_roundtrip(self)",
        "snippet": "    def test_repr_roundtrip(self):\n\n        idx = self.create_index()\n        tm.assert_index_equal(eval(repr(idx)), idx)",
        "begin_line": 214,
        "end_line": 217,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repr_max_seq_item_setting#219",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repr_max_seq_item_setting(self)",
        "snippet": "    def test_repr_max_seq_item_setting(self):\n        # GH10182\n        idx = self.create_index()\n        idx = idx.repeat(50)\n        with pd.option_context(\"display.max_seq_items\", None):\n            repr(idx)\n            assert \"...\" not in str(idx)",
        "begin_line": 219,
        "end_line": 225,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_copy_name#227",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_copy_name(self, indices)",
        "snippet": "    def test_copy_name(self, indices):\n        # gh-12309: Check that the \"name\" argument\n        # passed at initialization is honored.\n        if isinstance(indices, MultiIndex):\n            return\n\n        first = type(indices)(indices, copy=True, name=\"mario\")\n        second = type(first)(first, copy=False)\n\n        # Even though \"copy=False\", we want a new object.\n        assert first is not second\n\n        # Not using tm.assert_index_equal() since names differ.\n        assert indices.equals(first)\n\n        assert first.name == \"mario\"\n        assert second.name == \"mario\"\n\n        s1 = Series(2, index=first)\n        s2 = Series(3, index=second[:-1])\n\n        if not isinstance(indices, CategoricalIndex):\n            # See gh-13365\n            s3 = s1 * s2\n            assert s3.index.name == \"mario\"",
        "begin_line": 227,
        "end_line": 251,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_ensure_copied_data#253",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_ensure_copied_data(self, indices)",
        "snippet": "    def test_ensure_copied_data(self, indices):\n        # Check the \"copy\" argument of each Index.__new__ is honoured\n        # GH12309\n        init_kwargs = {}\n        if isinstance(indices, PeriodIndex):\n            # Needs \"freq\" specification:\n            init_kwargs[\"freq\"] = indices.freq\n        elif isinstance(indices, (RangeIndex, MultiIndex, CategoricalIndex)):\n            # RangeIndex cannot be initialized from data\n            # MultiIndex and CategoricalIndex are tested separately\n            return\n\n        index_type = type(indices)\n        result = index_type(indices.values, copy=True, **init_kwargs)\n        if is_datetime64tz_dtype(indices.dtype):\n            result = result.tz_localize(\"UTC\").tz_convert(indices.tz)\n\n        tm.assert_index_equal(indices, result)\n\n        if isinstance(indices, PeriodIndex):\n            # .values an object array of Period, thus copied\n            result = index_type(ordinal=indices.asi8, copy=False, **init_kwargs)\n            tm.assert_numpy_array_equal(indices.asi8, result.asi8, check_same=\"same\")\n        elif isinstance(indices, IntervalIndex):\n            # checked in test_interval.py\n            pass\n        else:\n            result = index_type(indices.values, copy=False, **init_kwargs)\n            tm.assert_numpy_array_equal(\n                indices.values, result.values, check_same=\"same\"\n            )",
        "begin_line": 253,
        "end_line": 283,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_memory_usage#285",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_memory_usage(self, indices)",
        "snippet": "    def test_memory_usage(self, indices):\n        indices._engine.clear_mapping()\n        result = indices.memory_usage()\n        if indices.empty:\n            # we report 0 for no-length\n            assert result == 0\n            return\n\n        # non-zero length\n        indices.get_loc(indices[0])\n        result2 = indices.memory_usage()\n        result3 = indices.memory_usage(deep=True)\n\n        # RangeIndex, IntervalIndex\n        # don't have engines\n        if not isinstance(indices, (RangeIndex, IntervalIndex)):\n            assert result2 > result\n\n        if indices.inferred_type == \"object\":\n            assert result3 > result2",
        "begin_line": 285,
        "end_line": 304,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_argsort#306",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_argsort(self, request, indices)",
        "snippet": "    def test_argsort(self, request, indices):\n        # separately tested\n        if isinstance(indices, CategoricalIndex):\n            return\n\n        result = indices.argsort()\n        expected = np.array(indices).argsort()\n        tm.assert_numpy_array_equal(result, expected, check_dtype=False)",
        "begin_line": 306,
        "end_line": 313,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numpy_argsort#315",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numpy_argsort(self, indices)",
        "snippet": "    def test_numpy_argsort(self, indices):\n        result = np.argsort(indices)\n        expected = indices.argsort()\n        tm.assert_numpy_array_equal(result, expected)\n\n        # these are the only two types that perform\n        # pandas compatibility input validation - the\n        # rest already perform separate (or no) such\n        # validation via their 'values' attribute as\n        # defined in pandas.core.indexes/base.py - they\n        # cannot be changed at the moment due to\n        # backwards compatibility concerns\n        if isinstance(type(indices), (CategoricalIndex, RangeIndex)):\n            msg = \"the 'axis' parameter is not supported\"\n            with pytest.raises(ValueError, match=msg):\n                np.argsort(indices, axis=1)\n\n            msg = \"the 'kind' parameter is not supported\"\n            with pytest.raises(ValueError, match=msg):\n                np.argsort(indices, kind=\"mergesort\")\n\n            msg = \"the 'order' parameter is not supported\"\n            with pytest.raises(ValueError, match=msg):\n                np.argsort(indices, order=(\"a\", \"b\"))",
        "begin_line": 315,
        "end_line": 338,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_take#340",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_take(self, indices)",
        "snippet": "    def test_take(self, indices):\n        indexer = [4, 3, 0, 2]\n        if len(indices) < 5:\n            # not enough elements; ignore\n            return\n\n        result = indices.take(indexer)\n        expected = indices[indexer]\n        assert result.equals(expected)\n\n        if not isinstance(indices, (DatetimeIndex, PeriodIndex, TimedeltaIndex)):\n            # GH 10791\n            with pytest.raises(AttributeError):\n                indices.freq",
        "begin_line": 340,
        "end_line": 353,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_take_invalid_kwargs#355",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_take_invalid_kwargs(self)",
        "snippet": "    def test_take_invalid_kwargs(self):\n        idx = self.create_index()\n        indices = [1, 2]\n\n        msg = r\"take\\(\\) got an unexpected keyword argument 'foo'\"\n        with pytest.raises(TypeError, match=msg):\n            idx.take(indices, foo=2)\n\n        msg = \"the 'out' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            idx.take(indices, out=indices)\n\n        msg = \"the 'mode' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            idx.take(indices, mode=\"clip\")",
        "begin_line": 355,
        "end_line": 369,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repeat#371",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repeat(self)",
        "snippet": "    def test_repeat(self):\n        rep = 2\n        i = self.create_index()\n        expected = pd.Index(i.values.repeat(rep), name=i.name)\n        tm.assert_index_equal(i.repeat(rep), expected)\n\n        i = self.create_index()\n        rep = np.arange(len(i))\n        expected = pd.Index(i.values.repeat(rep), name=i.name)\n        tm.assert_index_equal(i.repeat(rep), expected)",
        "begin_line": 371,
        "end_line": 380,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numpy_repeat#382",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numpy_repeat(self)",
        "snippet": "    def test_numpy_repeat(self):\n        rep = 2\n        i = self.create_index()\n        expected = i.repeat(rep)\n        tm.assert_index_equal(np.repeat(i, rep), expected)\n\n        msg = \"the 'axis' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            np.repeat(i, rep, axis=0)",
        "begin_line": 382,
        "end_line": 390,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_where#393",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_where(self, klass)",
        "snippet": "    def test_where(self, klass):\n        i = self.create_index()\n\n        cond = [True] * len(i)\n        result = i.where(klass(cond))\n        expected = i\n        tm.assert_index_equal(result, expected)\n\n        cond = [False] + [True] * len(i[1:])\n        expected = pd.Index([i._na_value] + i[1:].tolist(), dtype=i.dtype)\n        result = i.where(klass(cond))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 393,
        "end_line": 404,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_set_ops_error_cases#410",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_set_ops_error_cases(self, case, method, indices)",
        "snippet": "    def test_set_ops_error_cases(self, case, method, indices):\n        # non-iterable input\n        msg = \"Input must be Index or array-like\"\n        with pytest.raises(TypeError, match=msg):\n            getattr(indices, method)(case)",
        "begin_line": 410,
        "end_line": 414,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_intersection_base#416",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_intersection_base(self, indices)",
        "snippet": "    def test_intersection_base(self, indices):\n        if isinstance(indices, CategoricalIndex):\n            return\n\n        first = indices[:5]\n        second = indices[:3]\n        intersect = first.intersection(second)\n        assert tm.equalContents(intersect, second)\n\n        if is_datetime64tz_dtype(indices.dtype):\n            # The second.values below will drop tz, so the rest of this test\n            #  is not applicable.\n            return\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            result = first.intersection(case)\n            assert tm.equalContents(result, second)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.intersection([1, 2, 3])",
        "begin_line": 416,
        "end_line": 439,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_union_base#441",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_union_base(self, indices)",
        "snippet": "    def test_union_base(self, indices):\n        first = indices[3:]\n        second = indices[:5]\n        everything = indices\n        union = first.union(second)\n        assert tm.equalContents(union, everything)\n\n        if is_datetime64tz_dtype(indices.dtype):\n            # The second.values below will drop tz, so the rest of this test\n            #  is not applicable.\n            return\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            if not isinstance(indices, CategoricalIndex):\n                result = first.union(case)\n                assert tm.equalContents(result, everything)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.union([1, 2, 3])",
        "begin_line": 441,
        "end_line": 463,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_difference_base#465",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_difference_base(self, sort, indices)",
        "snippet": "    def test_difference_base(self, sort, indices):\n        first = indices[2:]\n        second = indices[:4]\n        if isinstance(indices, CategoricalIndex) or indices.is_boolean():\n            answer = []\n        else:\n            answer = indices[4:]\n        result = first.difference(second, sort)\n        assert tm.equalContents(result, answer)\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            if isinstance(indices, (DatetimeIndex, TimedeltaIndex)):\n                assert type(result) == type(answer)\n                tm.assert_numpy_array_equal(\n                    result.sort_values().asi8, answer.sort_values().asi8\n                )\n            else:\n                result = first.difference(case, sort)\n                assert tm.equalContents(result, answer)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.difference([1, 2, 3], sort)",
        "begin_line": 465,
        "end_line": 490,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_symmetric_difference#492",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_symmetric_difference(self, indices)",
        "snippet": "    def test_symmetric_difference(self, indices):\n        if isinstance(indices, CategoricalIndex):\n            return\n\n        first = indices[1:]\n        second = indices[:-1]\n        answer = indices[[0, -1]]\n        result = first.symmetric_difference(second)\n        assert tm.equalContents(result, answer)\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            result = first.symmetric_difference(case)\n            assert tm.equalContents(result, answer)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.symmetric_difference([1, 2, 3])",
        "begin_line": 492,
        "end_line": 511,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_insert_base#513",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_insert_base(self, indices)",
        "snippet": "    def test_insert_base(self, indices):\n        result = indices[1:4]\n\n        if not len(indices):\n            return\n\n        # test 0th element\n        assert indices[0:4].equals(result.insert(0, indices[0]))",
        "begin_line": 513,
        "end_line": 520,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_delete_base#522",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_delete_base(self, indices)",
        "snippet": "    def test_delete_base(self, indices):\n        if not len(indices):\n            return\n\n        if isinstance(indices, RangeIndex):\n            # tested in class\n            return\n\n        expected = indices[1:]\n        result = indices.delete(0)\n        assert result.equals(expected)\n        assert result.name == expected.name\n\n        expected = indices[:-1]\n        result = indices.delete(-1)\n        assert result.equals(expected)\n        assert result.name == expected.name\n\n        with pytest.raises((IndexError, ValueError)):\n            # either depending on numpy version\n            indices.delete(len(indices))",
        "begin_line": 522,
        "end_line": 542,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_equals#544",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_equals(self, indices)",
        "snippet": "    def test_equals(self, indices):\n        if isinstance(indices, IntervalIndex):\n            # IntervalIndex tested separately\n            return\n\n        assert indices.equals(indices)\n        assert indices.equals(indices.copy())\n        assert indices.equals(indices.astype(object))\n\n        assert not indices.equals(list(indices))\n        assert not indices.equals(np.array(indices))\n\n        # Cannot pass in non-int64 dtype to RangeIndex\n        if not isinstance(indices, (RangeIndex, CategoricalIndex)):\n            # TODO: CategoricalIndex can be re-allowed following GH#32167\n            same_values = Index(indices, dtype=object)\n            assert indices.equals(same_values)\n            assert same_values.equals(indices)\n\n        if indices.nlevels == 1:\n            # do not test MultiIndex\n            assert not indices.equals(Series(indices))",
        "begin_line": 544,
        "end_line": 565,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_equals_op#567",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_equals_op(self)",
        "snippet": "    def test_equals_op(self):\n        # GH9947, GH10637\n        index_a = self.create_index()\n        if isinstance(index_a, PeriodIndex):\n            pytest.skip(\"Skip check for PeriodIndex\")\n\n        n = len(index_a)\n        index_b = index_a[0:-1]\n        index_c = index_a[0:-1].append(index_a[-2:-1])\n        index_d = index_a[0:1]\n\n        msg = \"Lengths must match|could not be broadcast\"\n        with pytest.raises(ValueError, match=msg):\n            index_a == index_b\n        expected1 = np.array([True] * n)\n        expected2 = np.array([True] * (n - 1) + [False])\n        tm.assert_numpy_array_equal(index_a == index_a, expected1)\n        tm.assert_numpy_array_equal(index_a == index_c, expected2)\n\n        # test comparisons with numpy arrays\n        array_a = np.array(index_a)\n        array_b = np.array(index_a[0:-1])\n        array_c = np.array(index_a[0:-1].append(index_a[-2:-1]))\n        array_d = np.array(index_a[0:1])\n        with pytest.raises(ValueError, match=msg):\n            index_a == array_b\n        tm.assert_numpy_array_equal(index_a == array_a, expected1)\n        tm.assert_numpy_array_equal(index_a == array_c, expected2)\n\n        # test comparisons with Series\n        series_a = Series(array_a)\n        series_b = Series(array_b)\n        series_c = Series(array_c)\n        series_d = Series(array_d)\n        with pytest.raises(ValueError, match=msg):\n            index_a == series_b\n\n        tm.assert_numpy_array_equal(index_a == series_a, expected1)\n        tm.assert_numpy_array_equal(index_a == series_c, expected2)\n\n        # cases where length is 1 for one of them\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == index_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == series_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == array_d\n        msg = \"Can only compare identically-labeled Series objects\"\n        with pytest.raises(ValueError, match=msg):\n            series_a == series_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            series_a == array_d\n\n        # comparing with a scalar should broadcast; note that we are excluding\n        # MultiIndex because in this case each item in the index is a tuple of\n        # length 2, and therefore is considered an array of length 2 in the\n        # comparison instead of a scalar\n        if not isinstance(index_a, MultiIndex):\n            expected3 = np.array([False] * (len(index_a) - 2) + [True, False])\n            # assuming the 2nd to last item is unique in the data\n            item = index_a[-2]\n            tm.assert_numpy_array_equal(index_a == item, expected3)\n            tm.assert_series_equal(series_a == item, Series(expected3))",
        "begin_line": 567,
        "end_line": 629,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_hasnans_isnans#631",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_hasnans_isnans(self, indices)",
        "snippet": "    def test_hasnans_isnans(self, indices):\n        # GH 11343, added tests for hasnans / isnans\n        if isinstance(indices, MultiIndex):\n            return\n\n        # cases in indices doesn't include NaN\n        idx = indices.copy(deep=True)\n        expected = np.array([False] * len(idx), dtype=bool)\n        tm.assert_numpy_array_equal(idx._isnan, expected)\n        assert idx.hasnans is False\n\n        idx = indices.copy(deep=True)\n        values = np.asarray(idx.values)\n\n        if len(indices) == 0:\n            return\n        elif isinstance(indices, DatetimeIndexOpsMixin):\n            values[1] = iNaT\n        elif isinstance(indices, (Int64Index, UInt64Index)):\n            return\n        else:\n            values[1] = np.nan\n\n        if isinstance(indices, PeriodIndex):\n            idx = type(indices)(values, freq=indices.freq)\n        else:\n            idx = type(indices)(values)\n\n            expected = np.array([False] * len(idx), dtype=bool)\n            expected[1] = True\n            tm.assert_numpy_array_equal(idx._isnan, expected)\n            assert idx.hasnans is True",
        "begin_line": 631,
        "end_line": 662,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_fillna#664",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_fillna(self, indices)",
        "snippet": "    def test_fillna(self, indices):\n        # GH 11343\n        if len(indices) == 0:\n            pass\n        elif isinstance(indices, MultiIndex):\n            idx = indices.copy(deep=True)\n            msg = \"isna is not defined for MultiIndex\"\n            with pytest.raises(NotImplementedError, match=msg):\n                idx.fillna(idx[0])\n        else:\n            idx = indices.copy(deep=True)\n            result = idx.fillna(idx[0])\n            tm.assert_index_equal(result, idx)\n            assert result is not idx\n\n            msg = \"'value' must be a scalar, passed: \"\n            with pytest.raises(TypeError, match=msg):\n                idx.fillna([idx[0]])\n\n            idx = indices.copy(deep=True)\n            values = np.asarray(idx.values)\n\n            if isinstance(indices, DatetimeIndexOpsMixin):\n                values[1] = iNaT\n            elif isinstance(indices, (Int64Index, UInt64Index)):\n                return\n            else:\n                values[1] = np.nan\n\n            if isinstance(indices, PeriodIndex):\n                idx = type(indices)(values, freq=indices.freq)\n            else:\n                idx = type(indices)(values)\n\n            expected = np.array([False] * len(idx), dtype=bool)\n            expected[1] = True\n            tm.assert_numpy_array_equal(idx._isnan, expected)\n            assert idx.hasnans is True",
        "begin_line": 664,
        "end_line": 701,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_nulls#703",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_nulls(self, indices)",
        "snippet": "    def test_nulls(self, indices):\n        # this is really a smoke test for the methods\n        # as these are adequately tested for function elsewhere\n        if len(indices) == 0:\n            tm.assert_numpy_array_equal(indices.isna(), np.array([], dtype=bool))\n        elif isinstance(indices, MultiIndex):\n            idx = indices.copy()\n            msg = \"isna is not defined for MultiIndex\"\n            with pytest.raises(NotImplementedError, match=msg):\n                idx.isna()\n        elif not indices.hasnans:\n            tm.assert_numpy_array_equal(\n                indices.isna(), np.zeros(len(indices), dtype=bool)\n            )\n            tm.assert_numpy_array_equal(\n                indices.notna(), np.ones(len(indices), dtype=bool)\n            )\n        else:\n            result = isna(indices)\n            tm.assert_numpy_array_equal(indices.isna(), result)\n            tm.assert_numpy_array_equal(indices.notna(), ~result)",
        "begin_line": 703,
        "end_line": 723,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_empty#725",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_empty(self)",
        "snippet": "    def test_empty(self):\n        # GH 15270\n        index = self.create_index()\n        assert not index.empty\n        assert index[:0].empty",
        "begin_line": 725,
        "end_line": 729,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_join_self_unique#731",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_join_self_unique(self, join_type)",
        "snippet": "    def test_join_self_unique(self, join_type):\n        index = self.create_index()\n        if index.is_unique:\n            joined = index.join(index, how=join_type)\n            assert (index == joined).all()",
        "begin_line": 731,
        "end_line": 735,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_map#737",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_map(self)",
        "snippet": "    def test_map(self):\n        # callable\n        index = self.create_index()\n\n        # we don't infer UInt64\n        if isinstance(index, pd.UInt64Index):\n            expected = index.astype(\"int64\")\n        else:\n            expected = index\n\n        result = index.map(lambda x: x)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 737,
        "end_line": 748,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_map_dictlike#757",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_map_dictlike(self, mapper)",
        "snippet": "    def test_map_dictlike(self, mapper):\n\n        index = self.create_index()\n        if isinstance(index, (pd.CategoricalIndex, pd.IntervalIndex)):\n            pytest.skip(f\"skipping tests for {type(index)}\")\n\n        identity = mapper(index.values, index)\n\n        # we don't infer to UInt64 for a dict\n        if isinstance(index, pd.UInt64Index) and isinstance(identity, dict):\n            expected = index.astype(\"int64\")\n        else:\n            expected = index\n\n        result = index.map(identity)\n        tm.assert_index_equal(result, expected)\n\n        # empty mappable\n        expected = pd.Index([np.nan] * len(index))\n        result = index.map(mapper(expected, index))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 757,
        "end_line": 777,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_map_str#779",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_map_str(self)",
        "snippet": "    def test_map_str(self):\n        # GH 31202\n        index = self.create_index()\n        result = index.map(str)\n        expected = Index([str(x) for x in index], dtype=object)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 779,
        "end_line": 784,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_putmask_with_wrong_mask#786",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_putmask_with_wrong_mask(self)",
        "snippet": "    def test_putmask_with_wrong_mask(self):\n        # GH18368\n        index = self.create_index()\n\n        with pytest.raises(ValueError):\n            index.putmask(np.ones(len(index) + 1, np.bool), 1)\n\n        with pytest.raises(ValueError):\n            index.putmask(np.ones(len(index) - 1, np.bool), 1)\n\n        with pytest.raises(ValueError):\n            index.putmask(\"foo\", 1)",
        "begin_line": 786,
        "end_line": 797,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_astype_category#802",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_astype_category(self, copy, name, ordered)",
        "snippet": "    def test_astype_category(self, copy, name, ordered):\n        # GH 18630\n        index = self.create_index()\n        if name:\n            index = index.rename(name)\n\n        # standard categories\n        dtype = CategoricalDtype(ordered=ordered)\n        result = index.astype(dtype, copy=copy)\n        expected = CategoricalIndex(index.values, name=name, ordered=ordered)\n        tm.assert_index_equal(result, expected)\n\n        # non-standard categories\n        dtype = CategoricalDtype(index.unique().tolist()[:-1], ordered)\n        result = index.astype(dtype, copy=copy)\n        expected = CategoricalIndex(index.values, name=name, dtype=dtype)\n        tm.assert_index_equal(result, expected)\n\n        if ordered is False:\n            # dtype='category' defaults to ordered=False, so only test once\n            result = index.astype(\"category\", copy=copy)\n            expected = CategoricalIndex(index.values, name=name)\n            tm.assert_index_equal(result, expected)",
        "begin_line": 802,
        "end_line": 824,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_is_unique#826",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_is_unique(self)",
        "snippet": "    def test_is_unique(self):\n        # initialize a unique index\n        index = self.create_index().drop_duplicates()\n        assert index.is_unique is True\n\n        # empty index should be unique\n        index_empty = index[:0]\n        assert index_empty.is_unique is True\n\n        # test basic dupes\n        index_dup = index.insert(0, index[0])\n        assert index_dup.is_unique is False\n\n        # single NA should be unique\n        index_na = index.insert(0, np.nan)\n        assert index_na.is_unique is True\n\n        # multiple NA should not be unique\n        index_na_dup = index_na.insert(0, np.nan)\n        assert index_na_dup.is_unique is False",
        "begin_line": 826,
        "end_line": 845,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_engine_reference_cycle#847",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_engine_reference_cycle(self)",
        "snippet": "    def test_engine_reference_cycle(self):\n        # GH27585\n        index = self.create_index()\n        nrefs_pre = len(gc.get_referrers(index))\n        index._engine\n        assert len(gc.get_referrers(index)) == nrefs_pre",
        "begin_line": 847,
        "end_line": 852,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_getitem_2d_deprecated#854",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_getitem_2d_deprecated(self)",
        "snippet": "    def test_getitem_2d_deprecated(self):\n        # GH#30588\n        idx = self.create_index()\n        with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n            res = idx[:, None]\n\n        assert isinstance(res, np.ndarray), type(res)",
        "begin_line": 854,
        "end_line": 860,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_contains_requires_hashable_raises#862",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_contains_requires_hashable_raises(self)",
        "snippet": "    def test_contains_requires_hashable_raises(self):\n        idx = self.create_index()\n        with pytest.raises(TypeError, match=\"unhashable type\"):\n            [] in idx\n\n        with pytest.raises(TypeError):\n            {} in idx._engine",
        "begin_line": 862,
        "end_line": 868,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_copy_copies_cache#870",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_copy_copies_cache(self)",
        "snippet": "    def test_copy_copies_cache(self):\n        # GH32898\n        idx = self.create_index()\n        idx.get_loc(idx[0])  # populates the _cache.\n        copy = idx.copy()\n\n        # check that the copied cache is a copy of the original\n        assert idx._cache == copy._cache\n        assert idx._cache is not copy._cache\n        # cache values should reference the same object\n        for key, val in idx._cache.items():\n            assert copy._cache[key] is val, key",
        "begin_line": 870,
        "end_line": 881,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_shallow_copy_copies_cache#883",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_shallow_copy_copies_cache(self)",
        "snippet": "    def test_shallow_copy_copies_cache(self):\n        # GH32669\n        idx = self.create_index()\n        idx.get_loc(idx[0])  # populates the _cache.\n        shallow_copy = idx._shallow_copy()\n\n        # check that the shallow_copied cache is a copy of the original\n        assert idx._cache == shallow_copy._cache\n        assert idx._cache is not shallow_copy._cache\n        # cache values should reference the same object\n        for key, val in idx._cache.items():\n            assert shallow_copy._cache[key] is val, key",
        "begin_line": 883,
        "end_line": 894,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.idx#9",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.idx()",
        "snippet": "def idx():\n    # a MultiIndex used to test the general functionality of the\n    # general functionality of this object\n    major_axis = Index([\"foo\", \"bar\", \"baz\", \"qux\"])\n    minor_axis = Index([\"one\", \"two\"])\n\n    major_codes = np.array([0, 0, 1, 2, 3, 3])\n    minor_codes = np.array([0, 1, 0, 1, 0, 1])\n    index_names = [\"first\", \"second\"]\n    mi = MultiIndex(\n        levels=[major_axis, minor_axis],\n        codes=[major_codes, minor_codes],\n        names=index_names,\n        verify_integrity=False,\n    )\n    return mi",
        "begin_line": 9,
        "end_line": 24,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.idx_dup#28",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.idx_dup()",
        "snippet": "def idx_dup():\n    # compare tests/indexes/multi/conftest.py\n    major_axis = Index([\"foo\", \"bar\", \"baz\", \"qux\"])\n    minor_axis = Index([\"one\", \"two\"])\n\n    major_codes = np.array([0, 0, 1, 0, 1, 1])\n    minor_codes = np.array([0, 1, 0, 1, 0, 1])\n    index_names = [\"first\", \"second\"]\n    mi = MultiIndex(\n        levels=[major_axis, minor_axis],\n        codes=[major_codes, minor_codes],\n        names=index_names,\n        verify_integrity=False,\n    )\n    return mi",
        "begin_line": 28,
        "end_line": 42,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.index_names#46",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.index_names()",
        "snippet": "def index_names():\n    # names that match those in the idx fixture for testing equality of\n    # names assigned to the idx\n    return [\"first\", \"second\"]",
        "begin_line": 46,
        "end_line": 49,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.compat_props#53",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.compat_props()",
        "snippet": "def compat_props():\n    # a MultiIndex must have these properties associated with it\n    return [\"shape\", \"ndim\", \"size\"]",
        "begin_line": 53,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.narrow_multi_index#59",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.narrow_multi_index()",
        "snippet": "def narrow_multi_index():\n    \"\"\"\n    Return a MultiIndex that is narrower than the display (<80 characters).\n    \"\"\"\n    n = 1000\n    ci = pd.CategoricalIndex(list(\"a\" * n) + ([\"abc\"] * n))\n    dti = pd.date_range(\"2000-01-01\", freq=\"s\", periods=n * 2)\n    return pd.MultiIndex.from_arrays([ci, ci.codes + 9, dti], names=[\"a\", \"b\", \"dti\"])",
        "begin_line": 59,
        "end_line": 66,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.wide_multi_index#70",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.wide_multi_index()",
        "snippet": "def wide_multi_index():\n    \"\"\"\n    Return a MultiIndex that is wider than the display (>80 characters).\n    \"\"\"\n    n = 1000\n    ci = pd.CategoricalIndex(list(\"a\" * n) + ([\"abc\"] * n))\n    dti = pd.date_range(\"2000-01-01\", freq=\"s\", periods=n * 2)\n    levels = [ci, ci.codes + 9, dti, dti, dti]\n    names = [\"a\", \"b\", \"dti_1\", \"dti_2\", \"dti_3\"]\n    return pd.MultiIndex.from_arrays(levels, names=names)",
        "begin_line": 70,
        "end_line": 79,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_argmax_axis_invalid#12",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_argmax_axis_invalid(self)",
        "snippet": "    def test_argmax_axis_invalid(self):\n        # GH#23081\n        rng = self.create_index()\n        with pytest.raises(ValueError):\n            rng.argmax(axis=1)\n        with pytest.raises(ValueError):\n            rng.argmin(axis=2)\n        with pytest.raises(ValueError):\n            rng.min(axis=-2)\n        with pytest.raises(ValueError):\n            rng.max(axis=-3)",
        "begin_line": 12,
        "end_line": 22,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_can_hold_identifiers#24",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_can_hold_identifiers(self)",
        "snippet": "    def test_can_hold_identifiers(self):\n        idx = self.create_index()\n        key = idx[0]\n        assert idx._can_hold_identifiers_and_holds_name(key) is False",
        "begin_line": 24,
        "end_line": 27,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_shift_identity#29",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_shift_identity(self)",
        "snippet": "    def test_shift_identity(self):\n\n        idx = self.create_index()\n        tm.assert_index_equal(idx, idx.shift(0))",
        "begin_line": 29,
        "end_line": 32,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_str#34",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_str(self)",
        "snippet": "    def test_str(self):\n\n        # test the string repr\n        idx = self.create_index()\n        idx.name = \"foo\"\n        assert not (f\"length={len(idx)}\" in str(idx))\n        assert \"'foo'\" in str(idx)\n        assert type(idx).__name__ in str(idx)\n\n        if hasattr(idx, \"tz\"):\n            if idx.tz is not None:\n                assert idx.tz in str(idx)\n        if hasattr(idx, \"freq\"):\n            assert f\"freq='{idx.freqstr}'\" in str(idx)",
        "begin_line": 34,
        "end_line": 47,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_view#49",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_view(self)",
        "snippet": "    def test_view(self):\n        i = self.create_index()\n\n        i_view = i.view(\"i8\")\n        result = self._holder(i)\n        tm.assert_index_equal(result, i)\n\n        i_view = i.view(self._holder)\n        result = self._holder(i)\n        tm.assert_index_equal(result, i_view)",
        "begin_line": 49,
        "end_line": 58,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_callable#60",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_callable(self)",
        "snippet": "    def test_map_callable(self):\n        index = self.create_index()\n        expected = index + index.freq\n        result = index.map(lambda x: x + x.freq)\n        tm.assert_index_equal(result, expected)\n\n        # map to NaT\n        result = index.map(lambda x: pd.NaT if x == index[0] else x)\n        expected = pd.Index([pd.NaT] + index[1:].tolist())\n        tm.assert_index_equal(result, expected)",
        "begin_line": 60,
        "end_line": 69,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_dictlike#78",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_dictlike(self, mapper)",
        "snippet": "    def test_map_dictlike(self, mapper):\n        index = self.create_index()\n        expected = index + index.freq\n\n        # don't compare the freqs\n        if isinstance(expected, pd.DatetimeIndex):\n            expected._data.freq = None\n\n        result = index.map(mapper(expected, index))\n        tm.assert_index_equal(result, expected)\n\n        expected = pd.Index([pd.NaT] + index[1:].tolist())\n        result = index.map(mapper(expected, index))\n        tm.assert_index_equal(result, expected)\n\n        # empty map; these map to np.nan because we cannot know\n        # to re-infer things\n        expected = pd.Index([np.nan] * len(index))\n        result = index.map(mapper([], []))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 78,
        "end_line": 97,
        "comment": "",
        "is_bug": false
    }
]