[
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.setup_method#24",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n\n        self.df = DataFrame(\n            {\n                \"A\": np.arange(6, dtype=\"int64\"),\n                \"B\": Series(list(\"aabbca\")).astype(CDT(list(\"cab\"))),\n            }\n        ).set_index(\"B\")\n        self.df2 = DataFrame(\n            {\n                \"A\": np.arange(6, dtype=\"int64\"),\n                \"B\": Series(list(\"aabbca\")).astype(CDT(list(\"cabe\"))),\n            }\n        ).set_index(\"B\")\n        self.df3 = DataFrame(\n            {\n                \"A\": np.arange(6, dtype=\"int64\"),\n                \"B\": (Series([1, 1, 2, 1, 3, 2]).astype(CDT([3, 2, 1], ordered=True))),\n            }\n        ).set_index(\"B\")\n        self.df4 = DataFrame(\n            {\n                \"A\": np.arange(6, dtype=\"int64\"),\n                \"B\": (Series([1, 1, 2, 1, 3, 2]).astype(CDT([3, 2, 1], ordered=False))),\n            }\n        ).set_index(\"B\")",
        "begin_line": 24,
        "end_line": 49,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_scalar#51",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_scalar(self)",
        "snippet": "    def test_loc_scalar(self):\n        result = self.df.loc[\"a\"]\n        expected = DataFrame(\n            {\"A\": [0, 1, 5], \"B\": (Series(list(\"aaa\")).astype(CDT(list(\"cab\"))))}\n        ).set_index(\"B\")\n        tm.assert_frame_equal(result, expected)\n\n        df = self.df.copy()\n        df.loc[\"a\"] = 20\n        expected = DataFrame(\n            {\n                \"A\": [20, 20, 2, 3, 4, 20],\n                \"B\": (Series(list(\"aabbca\")).astype(CDT(list(\"cab\")))),\n            }\n        ).set_index(\"B\")\n        tm.assert_frame_equal(df, expected)\n\n        # value not in the categories\n        with pytest.raises(KeyError, match=r\"^'d'$\"):\n            df.loc[\"d\"]\n\n        msg = \"cannot append a non-category item to a CategoricalIndex\"\n        with pytest.raises(TypeError, match=msg):\n            df.loc[\"d\"] = 10\n\n        msg = (\n            \"cannot insert an item into a CategoricalIndex that is not\"\n            \" already an existing category\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            df.loc[\"d\", \"A\"] = 10\n        with pytest.raises(TypeError, match=msg):\n            df.loc[\"d\", \"C\"] = 10\n\n        msg = (\n            r\"cannot do label indexing on <class 'pandas\\.core\\.indexes\\.category\"\n            r\"\\.CategoricalIndex'> with these indexers \\[1\\] of <class 'int'>\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            df.loc[1]",
        "begin_line": 51,
        "end_line": 90,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_getitem_scalar#92",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_getitem_scalar(self)",
        "snippet": "    def test_getitem_scalar(self):\n\n        cats = Categorical([Timestamp(\"12-31-1999\"), Timestamp(\"12-31-2000\")])\n\n        s = Series([1, 2], index=cats)\n\n        expected = s.iloc[0]\n        result = s[cats[0]]\n        assert result == expected",
        "begin_line": 92,
        "end_line": 100,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing_directly#102",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing_directly(self)",
        "snippet": "    def test_slicing_directly(self):\n        cat = Categorical([\"a\", \"b\", \"c\", \"d\", \"a\", \"b\", \"c\"])\n        sliced = cat[3]\n        assert sliced == \"d\"\n        sliced = cat[3:5]\n        expected = Categorical([\"d\", \"a\"], categories=[\"a\", \"b\", \"c\", \"d\"])\n        tm.assert_numpy_array_equal(sliced._codes, expected._codes)\n        tm.assert_index_equal(sliced.categories, expected.categories)",
        "begin_line": 102,
        "end_line": 109,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing#111",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing(self)",
        "snippet": "    def test_slicing(self):\n        cat = Series(Categorical([1, 2, 3, 4]))\n        reversed = cat[::-1]\n        exp = np.array([4, 3, 2, 1], dtype=np.int64)\n        tm.assert_numpy_array_equal(reversed.__array__(), exp)\n\n        df = DataFrame({\"value\": (np.arange(100) + 1).astype(\"int64\")})\n        df[\"D\"] = pd.cut(df.value, bins=[0, 25, 50, 75, 100])\n\n        expected = Series([11, Interval(0, 25)], index=[\"value\", \"D\"], name=10)\n        result = df.iloc[10]\n        tm.assert_series_equal(result, expected)\n\n        expected = DataFrame(\n            {\"value\": np.arange(11, 21).astype(\"int64\")},\n            index=np.arange(10, 20).astype(\"int64\"),\n        )\n        expected[\"D\"] = pd.cut(expected.value, bins=[0, 25, 50, 75, 100])\n        result = df.iloc[10:20]\n        tm.assert_frame_equal(result, expected)\n\n        expected = Series([9, Interval(0, 25)], index=[\"value\", \"D\"], name=8)\n        result = df.loc[8]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 111,
        "end_line": 134,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing_and_getting_ops#136",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing_and_getting_ops(self)",
        "snippet": "    def test_slicing_and_getting_ops(self):\n\n        # systematically test the slicing operations:\n        #  for all slicing ops:\n        #   - returning a dataframe\n        #   - returning a column\n        #   - returning a row\n        #   - returning a single value\n\n        cats = Categorical(\n            [\"a\", \"c\", \"b\", \"c\", \"c\", \"c\", \"c\"], categories=[\"a\", \"b\", \"c\"]\n        )\n        idx = Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        values = [1, 2, 3, 4, 5, 6, 7]\n        df = DataFrame({\"cats\": cats, \"values\": values}, index=idx)\n\n        # the expected values\n        cats2 = Categorical([\"b\", \"c\"], categories=[\"a\", \"b\", \"c\"])\n        idx2 = Index([\"j\", \"k\"])\n        values2 = [3, 4]\n\n        # 2:4,: | \"j\":\"k\",:\n        exp_df = DataFrame({\"cats\": cats2, \"values\": values2}, index=idx2)\n\n        # :,\"cats\" | :,0\n        exp_col = Series(cats, index=idx, name=\"cats\")\n\n        # \"j\",: | 2,:\n        exp_row = Series([\"b\", 3], index=[\"cats\", \"values\"], dtype=\"object\", name=\"j\")\n\n        # \"j\",\"cats | 2,0\n        exp_val = \"b\"\n\n        # iloc\n        # frame\n        res_df = df.iloc[2:4, :]\n        tm.assert_frame_equal(res_df, exp_df)\n        assert is_categorical_dtype(res_df[\"cats\"])\n\n        # row\n        res_row = df.iloc[2, :]\n        tm.assert_series_equal(res_row, exp_row)\n        assert isinstance(res_row[\"cats\"], str)\n\n        # col\n        res_col = df.iloc[:, 0]\n        tm.assert_series_equal(res_col, exp_col)\n        assert is_categorical_dtype(res_col)\n\n        # single value\n        res_val = df.iloc[2, 0]\n        assert res_val == exp_val\n\n        # loc\n        # frame\n        res_df = df.loc[\"j\":\"k\", :]\n        tm.assert_frame_equal(res_df, exp_df)\n        assert is_categorical_dtype(res_df[\"cats\"])\n\n        # row\n        res_row = df.loc[\"j\", :]\n        tm.assert_series_equal(res_row, exp_row)\n        assert isinstance(res_row[\"cats\"], str)\n\n        # col\n        res_col = df.loc[:, \"cats\"]\n        tm.assert_series_equal(res_col, exp_col)\n        assert is_categorical_dtype(res_col)\n\n        # single value\n        res_val = df.loc[\"j\", \"cats\"]\n        assert res_val == exp_val\n\n        # ix\n        # frame\n        # res_df = df.loc[\"j\":\"k\",[0,1]] # doesn't work?\n        res_df = df.loc[\"j\":\"k\", :]\n        tm.assert_frame_equal(res_df, exp_df)\n        assert is_categorical_dtype(res_df[\"cats\"])\n\n        # row\n        res_row = df.loc[\"j\", :]\n        tm.assert_series_equal(res_row, exp_row)\n        assert isinstance(res_row[\"cats\"], str)\n\n        # col\n        res_col = df.loc[:, \"cats\"]\n        tm.assert_series_equal(res_col, exp_col)\n        assert is_categorical_dtype(res_col)\n\n        # single value\n        res_val = df.loc[\"j\", df.columns[0]]\n        assert res_val == exp_val\n\n        # iat\n        res_val = df.iat[2, 0]\n        assert res_val == exp_val\n\n        # at\n        res_val = df.at[\"j\", \"cats\"]\n        assert res_val == exp_val\n\n        # fancy indexing\n        exp_fancy = df.iloc[[2]]\n\n        res_fancy = df[df[\"cats\"] == \"b\"]\n        tm.assert_frame_equal(res_fancy, exp_fancy)\n        res_fancy = df[df[\"values\"] == 3]\n        tm.assert_frame_equal(res_fancy, exp_fancy)\n\n        # get_value\n        res_val = df.at[\"j\", \"cats\"]\n        assert res_val == exp_val\n\n        # i : int, slice, or sequence of integers\n        res_row = df.iloc[2]\n        tm.assert_series_equal(res_row, exp_row)\n        assert isinstance(res_row[\"cats\"], str)\n\n        res_df = df.iloc[slice(2, 4)]\n        tm.assert_frame_equal(res_df, exp_df)\n        assert is_categorical_dtype(res_df[\"cats\"])\n\n        res_df = df.iloc[[2, 3]]\n        tm.assert_frame_equal(res_df, exp_df)\n        assert is_categorical_dtype(res_df[\"cats\"])\n\n        res_col = df.iloc[:, 0]\n        tm.assert_series_equal(res_col, exp_col)\n        assert is_categorical_dtype(res_col)\n\n        res_df = df.iloc[:, slice(0, 2)]\n        tm.assert_frame_equal(res_df, df)\n        assert is_categorical_dtype(res_df[\"cats\"])\n\n        res_df = df.iloc[:, [0, 1]]\n        tm.assert_frame_equal(res_df, df)\n        assert is_categorical_dtype(res_df[\"cats\"])",
        "begin_line": 136,
        "end_line": 273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing_doc_examples#275",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_slicing_doc_examples(self)",
        "snippet": "    def test_slicing_doc_examples(self):\n\n        # GH 7918\n        cats = Categorical(\n            [\"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"], categories=[\"a\", \"b\", \"c\"]\n        )\n        idx = Index([\"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n        values = [1, 2, 2, 2, 3, 4, 5]\n        df = DataFrame({\"cats\": cats, \"values\": values}, index=idx)\n\n        result = df.iloc[2:4, :]\n        expected = DataFrame(\n            {\n                \"cats\": Categorical([\"b\", \"b\"], categories=[\"a\", \"b\", \"c\"]),\n                \"values\": [2, 2],\n            },\n            index=[\"j\", \"k\"],\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.iloc[2:4, :].dtypes\n        expected = Series([\"category\", \"int64\"], [\"cats\", \"values\"])\n        tm.assert_series_equal(result, expected)\n\n        result = df.loc[\"h\":\"j\", \"cats\"]\n        expected = Series(\n            Categorical([\"a\", \"b\", \"b\"], categories=[\"a\", \"b\", \"c\"]),\n            index=[\"h\", \"i\", \"j\"],\n            name=\"cats\",\n        )\n        tm.assert_series_equal(result, expected)\n\n        result = df.loc[\"h\":\"j\", df.columns[0:1]]\n        expected = DataFrame(\n            {\"cats\": Categorical([\"a\", \"b\", \"b\"], categories=[\"a\", \"b\", \"c\"])},\n            index=[\"h\", \"i\", \"j\"],\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 275,
        "end_line": 312,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_getitem_category_type#314",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_getitem_category_type(self)",
        "snippet": "    def test_getitem_category_type(self):\n        # GH 14580\n        # test iloc() on Series with Categorical data\n\n        s = Series([1, 2, 3]).astype(\"category\")\n\n        # get slice\n        result = s.iloc[0:2]\n        expected = Series([1, 2]).astype(CategoricalDtype([1, 2, 3]))\n        tm.assert_series_equal(result, expected)\n\n        # get list of indexes\n        result = s.iloc[[0, 1]]\n        expected = Series([1, 2]).astype(CategoricalDtype([1, 2, 3]))\n        tm.assert_series_equal(result, expected)\n\n        # get boolean array\n        result = s.iloc[[True, False, False]]\n        expected = Series([1]).astype(CategoricalDtype([1, 2, 3]))\n        tm.assert_series_equal(result, expected)",
        "begin_line": 314,
        "end_line": 333,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_listlike#335",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_listlike(self)",
        "snippet": "    def test_loc_listlike(self):\n\n        # list of labels\n        result = self.df.loc[[\"c\", \"a\"]]\n        expected = self.df.iloc[[4, 0, 1, 5]]\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = self.df2.loc[[\"a\", \"b\", \"e\"]]\n        exp_index = CategoricalIndex(list(\"aaabbe\"), categories=list(\"cabe\"), name=\"B\")\n        expected = DataFrame({\"A\": [0, 1, 5, 2, 3, np.nan]}, index=exp_index)\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        # element in the categories but not in the values\n        with pytest.raises(KeyError, match=r\"^'e'$\"):\n            self.df2.loc[\"e\"]\n\n        # assign is ok\n        df = self.df2.copy()\n        df.loc[\"e\"] = 20\n        result = df.loc[[\"a\", \"b\", \"e\"]]\n        exp_index = CategoricalIndex(list(\"aaabbe\"), categories=list(\"cabe\"), name=\"B\")\n        expected = DataFrame({\"A\": [0, 1, 5, 2, 3, 20]}, index=exp_index)\n        tm.assert_frame_equal(result, expected)\n\n        df = self.df2.copy()\n        result = df.loc[[\"a\", \"b\", \"e\"]]\n        exp_index = CategoricalIndex(list(\"aaabbe\"), categories=list(\"cabe\"), name=\"B\")\n        expected = DataFrame({\"A\": [0, 1, 5, 2, 3, np.nan]}, index=exp_index)\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        # not all labels in the categories\n        with pytest.raises(\n            KeyError,\n            match=\"'a list-indexer must only include values that are in the\"\n            \" categories'\",\n        ):\n            self.df2.loc[[\"a\", \"d\"]]",
        "begin_line": 335,
        "end_line": 371,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_listlike_dtypes#373",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_listlike_dtypes(self)",
        "snippet": "    def test_loc_listlike_dtypes(self):\n        # GH 11586\n\n        # unique categories and codes\n        index = CategoricalIndex([\"a\", \"b\", \"c\"])\n        df = DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]}, index=index)\n\n        # unique slice\n        res = df.loc[[\"a\", \"b\"]]\n        exp_index = CategoricalIndex([\"a\", \"b\"], categories=index.categories)\n        exp = DataFrame({\"A\": [1, 2], \"B\": [4, 5]}, index=exp_index)\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        # duplicated slice\n        res = df.loc[[\"a\", \"a\", \"b\"]]\n\n        exp_index = CategoricalIndex([\"a\", \"a\", \"b\"], categories=index.categories)\n        exp = DataFrame({\"A\": [1, 1, 2], \"B\": [4, 4, 5]}, index=exp_index)\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        msg = \"a list-indexer must only include values that are in the categories\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[\"a\", \"x\"]]\n\n        # duplicated categories and codes\n        index = CategoricalIndex([\"a\", \"b\", \"a\"])\n        df = DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]}, index=index)\n\n        # unique slice\n        res = df.loc[[\"a\", \"b\"]]\n        exp = DataFrame(\n            {\"A\": [1, 3, 2], \"B\": [4, 6, 5]}, index=CategoricalIndex([\"a\", \"a\", \"b\"])\n        )\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        # duplicated slice\n        res = df.loc[[\"a\", \"a\", \"b\"]]\n        exp = DataFrame(\n            {\"A\": [1, 3, 1, 3, 2], \"B\": [4, 6, 4, 6, 5]},\n            index=CategoricalIndex([\"a\", \"a\", \"a\", \"a\", \"b\"]),\n        )\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        msg = \"a list-indexer must only include values that are in the categories\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[\"a\", \"x\"]]\n\n        # contains unused category\n        index = CategoricalIndex([\"a\", \"b\", \"a\", \"c\"], categories=list(\"abcde\"))\n        df = DataFrame({\"A\": [1, 2, 3, 4], \"B\": [5, 6, 7, 8]}, index=index)\n\n        res = df.loc[[\"a\", \"b\"]]\n        exp = DataFrame(\n            {\"A\": [1, 3, 2], \"B\": [5, 7, 6]},\n            index=CategoricalIndex([\"a\", \"a\", \"b\"], categories=list(\"abcde\")),\n        )\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        res = df.loc[[\"a\", \"e\"]]\n        exp = DataFrame(\n            {\"A\": [1, 3, np.nan], \"B\": [5, 7, np.nan]},\n            index=CategoricalIndex([\"a\", \"a\", \"e\"], categories=list(\"abcde\")),\n        )\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        # duplicated slice\n        res = df.loc[[\"a\", \"a\", \"b\"]]\n        exp = DataFrame(\n            {\"A\": [1, 3, 1, 3, 2], \"B\": [5, 7, 5, 7, 6]},\n            index=CategoricalIndex([\"a\", \"a\", \"a\", \"a\", \"b\"], categories=list(\"abcde\")),\n        )\n        tm.assert_frame_equal(res, exp, check_index_type=True)\n\n        msg = \"a list-indexer must only include values that are in the categories\"\n        with pytest.raises(KeyError, match=msg):\n            df.loc[[\"a\", \"x\"]]",
        "begin_line": 373,
        "end_line": 448,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_get_indexer_array#450",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_get_indexer_array(self)",
        "snippet": "    def test_get_indexer_array(self):\n        arr = np.array(\n            [Timestamp(\"1999-12-31 00:00:00\"), Timestamp(\"2000-12-31 00:00:00\")],\n            dtype=object,\n        )\n        cats = [Timestamp(\"1999-12-31 00:00:00\"), Timestamp(\"2000-12-31 00:00:00\")]\n        ci = CategoricalIndex(cats, categories=cats, ordered=False, dtype=\"category\")\n        result = ci.get_indexer(arr)\n        expected = np.array([0, 1], dtype=\"intp\")\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 450,
        "end_line": 459,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_get_indexer_same_categories_same_order#461",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_get_indexer_same_categories_same_order(self)",
        "snippet": "    def test_get_indexer_same_categories_same_order(self):\n        ci = CategoricalIndex([\"a\", \"b\"], categories=[\"a\", \"b\"])\n\n        result = ci.get_indexer(CategoricalIndex([\"b\", \"b\"], categories=[\"a\", \"b\"]))\n        expected = np.array([1, 1], dtype=\"intp\")\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 461,
        "end_line": 466,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_get_indexer_same_categories_different_order#468",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_get_indexer_same_categories_different_order(self)",
        "snippet": "    def test_get_indexer_same_categories_different_order(self):\n        # https://github.com/pandas-dev/pandas/issues/19551\n        ci = CategoricalIndex([\"a\", \"b\"], categories=[\"a\", \"b\"])\n\n        result = ci.get_indexer(CategoricalIndex([\"b\", \"b\"], categories=[\"b\", \"a\"]))\n        expected = np.array([1, 1], dtype=\"intp\")\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 468,
        "end_line": 474,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_getitem_with_listlike#476",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_getitem_with_listlike(self)",
        "snippet": "    def test_getitem_with_listlike(self):\n        # GH 16115\n        cats = Categorical([Timestamp(\"12-31-1999\"), Timestamp(\"12-31-2000\")])\n\n        expected = DataFrame(\n            [[1, 0], [0, 1]], dtype=\"uint8\", index=[0, 1], columns=cats\n        )\n        dummies = pd.get_dummies(cats)\n        result = dummies[list(dummies.columns)]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 476,
        "end_line": 485,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_setitem_listlike#487",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_setitem_listlike(self)",
        "snippet": "    def test_setitem_listlike(self):\n\n        # GH 9469\n        # properly coerce the input indexers\n        np.random.seed(1)\n        c = Categorical(\n            np.random.randint(0, 5, size=150000).astype(np.int8)\n        ).add_categories([-1000])\n        indexer = np.array([100000]).astype(np.int64)\n        c[indexer] = -1000\n\n        # we are asserting the code result here\n        # which maps to the -1000 category\n        result = c.codes[np.array([100000]).astype(np.int64)]\n        tm.assert_numpy_array_equal(result, np.array([5], dtype=\"int8\"))",
        "begin_line": 487,
        "end_line": 501,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_ix_categorical_index#503",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_ix_categorical_index(self)",
        "snippet": "    def test_ix_categorical_index(self):\n        # GH 12531\n        df = DataFrame(np.random.randn(3, 3), index=list(\"ABC\"), columns=list(\"XYZ\"))\n        cdf = df.copy()\n        cdf.index = CategoricalIndex(df.index)\n        cdf.columns = CategoricalIndex(df.columns)\n\n        expect = Series(df.loc[\"A\", :], index=cdf.columns, name=\"A\")\n        tm.assert_series_equal(cdf.loc[\"A\", :], expect)\n\n        expect = Series(df.loc[:, \"X\"], index=cdf.index, name=\"X\")\n        tm.assert_series_equal(cdf.loc[:, \"X\"], expect)\n\n        exp_index = CategoricalIndex(list(\"AB\"), categories=[\"A\", \"B\", \"C\"])\n        expect = DataFrame(df.loc[[\"A\", \"B\"], :], columns=cdf.columns, index=exp_index)\n        tm.assert_frame_equal(cdf.loc[[\"A\", \"B\"], :], expect)\n\n        exp_columns = CategoricalIndex(list(\"XY\"), categories=[\"X\", \"Y\", \"Z\"])\n        expect = DataFrame(df.loc[:, [\"X\", \"Y\"]], index=cdf.index, columns=exp_columns)\n        tm.assert_frame_equal(cdf.loc[:, [\"X\", \"Y\"]], expect)\n\n        # non-unique\n        df = DataFrame(np.random.randn(3, 3), index=list(\"ABA\"), columns=list(\"XYX\"))\n        cdf = df.copy()\n        cdf.index = CategoricalIndex(df.index)\n        cdf.columns = CategoricalIndex(df.columns)\n\n        exp_index = CategoricalIndex(list(\"AA\"), categories=[\"A\", \"B\"])\n        expect = DataFrame(df.loc[\"A\", :], columns=cdf.columns, index=exp_index)\n        tm.assert_frame_equal(cdf.loc[\"A\", :], expect)\n\n        exp_columns = CategoricalIndex(list(\"XX\"), categories=[\"X\", \"Y\"])\n        expect = DataFrame(df.loc[:, \"X\"], index=cdf.index, columns=exp_columns)\n        tm.assert_frame_equal(cdf.loc[:, \"X\"], expect)\n\n        expect = DataFrame(\n            df.loc[[\"A\", \"B\"], :],\n            columns=cdf.columns,\n            index=CategoricalIndex(list(\"AAB\")),\n        )\n        tm.assert_frame_equal(cdf.loc[[\"A\", \"B\"], :], expect)\n\n        expect = DataFrame(\n            df.loc[:, [\"X\", \"Y\"]],\n            index=cdf.index,\n            columns=CategoricalIndex(list(\"XXY\")),\n        )\n        tm.assert_frame_equal(cdf.loc[:, [\"X\", \"Y\"]], expect)",
        "begin_line": 503,
        "end_line": 550,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_read_only_source#552",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_read_only_source(self)",
        "snippet": "    def test_read_only_source(self):\n        # GH 10043\n        rw_array = np.eye(10)\n        rw_df = DataFrame(rw_array)\n\n        ro_array = np.eye(10)\n        ro_array.setflags(write=False)\n        ro_df = DataFrame(ro_array)\n\n        tm.assert_frame_equal(rw_df.iloc[[1, 2, 3]], ro_df.iloc[[1, 2, 3]])\n        tm.assert_frame_equal(rw_df.iloc[[1]], ro_df.iloc[[1]])\n        tm.assert_series_equal(rw_df.iloc[1], ro_df.iloc[1])\n        tm.assert_frame_equal(rw_df.iloc[1:3], ro_df.iloc[1:3])\n\n        tm.assert_frame_equal(rw_df.loc[[1, 2, 3]], ro_df.loc[[1, 2, 3]])\n        tm.assert_frame_equal(rw_df.loc[[1]], ro_df.loc[[1]])\n        tm.assert_series_equal(rw_df.loc[1], ro_df.loc[1])\n        tm.assert_frame_equal(rw_df.loc[1:3], ro_df.loc[1:3])",
        "begin_line": 552,
        "end_line": 569,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_reindexing#571",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_reindexing(self)",
        "snippet": "    def test_reindexing(self):\n        df = DataFrame(\n            {\n                \"A\": np.arange(3, dtype=\"int64\"),\n                \"B\": Series(list(\"abc\")).astype(CDT(list(\"cabe\"))),\n            }\n        ).set_index(\"B\")\n\n        # reindexing\n        # convert to a regular index\n        result = df.reindex([\"a\", \"b\", \"e\"])\n        expected = DataFrame({\"A\": [0, 1, np.nan], \"B\": Series(list(\"abe\"))}).set_index(\n            \"B\"\n        )\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex([\"a\", \"b\"])\n        expected = DataFrame({\"A\": [0, 1], \"B\": Series(list(\"ab\"))}).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex([\"e\"])\n        expected = DataFrame({\"A\": [np.nan], \"B\": Series([\"e\"])}).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex([\"d\"])\n        expected = DataFrame({\"A\": [np.nan], \"B\": Series([\"d\"])}).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        # since we are actually reindexing with a Categorical\n        # then return a Categorical\n        cats = list(\"cabe\")\n\n        result = df.reindex(Categorical([\"a\", \"e\"], categories=cats))\n        expected = DataFrame(\n            {\"A\": [0, np.nan], \"B\": Series(list(\"ae\")).astype(CDT(cats))}\n        ).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex(Categorical([\"a\"], categories=cats))\n        expected = DataFrame(\n            {\"A\": [0], \"B\": Series(list(\"a\")).astype(CDT(cats))}\n        ).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex([\"a\", \"b\", \"e\"])\n        expected = DataFrame({\"A\": [0, 1, np.nan], \"B\": Series(list(\"abe\"))}).set_index(\n            \"B\"\n        )\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex([\"a\", \"b\"])\n        expected = DataFrame({\"A\": [0, 1], \"B\": Series(list(\"ab\"))}).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex([\"e\"])\n        expected = DataFrame({\"A\": [np.nan], \"B\": Series([\"e\"])}).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        # give back the type of categorical that we received\n        result = df.reindex(Categorical([\"a\", \"e\"], categories=cats, ordered=True))\n        expected = DataFrame(\n            {\"A\": [0, np.nan], \"B\": Series(list(\"ae\")).astype(CDT(cats, ordered=True))}\n        ).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        result = df.reindex(Categorical([\"a\", \"d\"], categories=[\"a\", \"d\"]))\n        expected = DataFrame(\n            {\"A\": [0, np.nan], \"B\": Series(list(\"ad\")).astype(CDT([\"a\", \"d\"]))}\n        ).set_index(\"B\")\n        tm.assert_frame_equal(result, expected, check_index_type=True)\n\n        # passed duplicate indexers are not allowed\n        msg = \"cannot reindex from a duplicate axis\"\n        with pytest.raises(ValueError, match=msg):\n            self.df2.reindex([\"a\", \"b\"])\n\n        # args NotImplemented ATM\n        msg = r\"argument {} is not implemented for CategoricalIndex\\.reindex\"\n        with pytest.raises(NotImplementedError, match=msg.format(\"method\")):\n            df.reindex([\"a\"], method=\"ffill\")\n        with pytest.raises(NotImplementedError, match=msg.format(\"level\")):\n            df.reindex([\"a\"], level=1)\n        with pytest.raises(NotImplementedError, match=msg.format(\"limit\")):\n            df.reindex([\"a\"], limit=2)",
        "begin_line": 571,
        "end_line": 654,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_slice#656",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_slice(self)",
        "snippet": "    def test_loc_slice(self):\n        # slicing\n        # not implemented ATM\n        # GH9748\n\n        msg = (\n            \"cannot do slice indexing on {klass} with these \"\n            r\"indexers \\[1\\] of {kind}\".format(\n                klass=str(CategoricalIndex), kind=str(int)\n            )\n        )\n        with pytest.raises(TypeError, match=msg):\n            self.df.loc[1:5]",
        "begin_line": 656,
        "end_line": 668,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_and_at_with_categorical_index#674",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_and_at_with_categorical_index(self)",
        "snippet": "    def test_loc_and_at_with_categorical_index(self):\n        # GH 20629\n        s = Series([1, 2, 3], index=pd.CategoricalIndex([\"A\", \"B\", \"C\"]))\n        assert s.loc[\"A\"] == 1\n        assert s.at[\"A\"] == 1\n        df = DataFrame(\n            [[1, 2], [3, 4], [5, 6]], index=pd.CategoricalIndex([\"A\", \"B\", \"C\"])\n        )\n        assert df.loc[\"B\", 1] == 4\n        assert df.at[\"B\", 1] == 4",
        "begin_line": 674,
        "end_line": 683,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_boolean_selection#685",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_boolean_selection(self)",
        "snippet": "    def test_boolean_selection(self):\n\n        df3 = self.df3\n        df4 = self.df4\n\n        result = df3[df3.index == \"a\"]\n        expected = df3.iloc[[]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df4[df4.index == \"a\"]\n        expected = df4.iloc[[]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df3[df3.index == 1]\n        expected = df3.iloc[[0, 1, 3]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df4[df4.index == 1]\n        expected = df4.iloc[[0, 1, 3]]\n        tm.assert_frame_equal(result, expected)\n\n        # since we have an ordered categorical\n\n        # CategoricalIndex([1, 1, 2, 1, 3, 2],\n        #         categories=[3, 2, 1],\n        #         ordered=True,\n        #         name='B')\n        result = df3[df3.index < 2]\n        expected = df3.iloc[[4]]\n        tm.assert_frame_equal(result, expected)\n\n        result = df3[df3.index > 1]\n        expected = df3.iloc[[]]\n        tm.assert_frame_equal(result, expected)\n\n        # unordered\n        # cannot be compared\n\n        # CategoricalIndex([1, 1, 2, 1, 3, 2],\n        #         categories=[3, 2, 1],\n        #         ordered=False,\n        #         name='B')\n        msg = \"Unordered Categoricals can only compare equality or not\"\n        with pytest.raises(TypeError, match=msg):\n            df4[df4.index < 2]\n        with pytest.raises(TypeError, match=msg):\n            df4[df4.index > 1]",
        "begin_line": 685,
        "end_line": 731,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_indexing_with_category#733",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_indexing_with_category(self)",
        "snippet": "    def test_indexing_with_category(self):\n\n        # https://github.com/pandas-dev/pandas/issues/12564\n        # consistent result if comparing as Dataframe\n\n        cat = DataFrame({\"A\": [\"foo\", \"bar\", \"baz\"]})\n        exp = DataFrame({\"A\": [True, False, False]})\n\n        res = cat[[\"A\"]] == \"foo\"\n        tm.assert_frame_equal(res, exp)\n\n        cat[\"A\"] = cat[\"A\"].astype(\"category\")\n\n        res = cat[[\"A\"]] == \"foo\"\n        tm.assert_frame_equal(res, exp)",
        "begin_line": 733,
        "end_line": 747,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_map_with_dict_or_series#749",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_map_with_dict_or_series(self)",
        "snippet": "    def test_map_with_dict_or_series(self):\n        orig_values = [\"a\", \"B\", 1, \"a\"]\n        new_values = [\"one\", 2, 3.0, \"one\"]\n        cur_index = pd.CategoricalIndex(orig_values, name=\"XXX\")\n        expected = pd.CategoricalIndex(\n            new_values, name=\"XXX\", categories=[3.0, 2, \"one\"]\n        )\n\n        mapper = pd.Series(new_values[:-1], index=orig_values[:-1])\n        output = cur_index.map(mapper)\n        # Order of categories in output can be different\n        tm.assert_index_equal(expected, output)\n\n        mapper = {o: n for o, n in zip(orig_values[:-1], new_values[:-1])}\n        output = cur_index.map(mapper)\n        # Order of categories in output can be different\n        tm.assert_index_equal(expected, output)",
        "begin_line": 749,
        "end_line": 765,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_with_non_string_categories#793",
        "src_path": "pandas/tests/indexing/test_categorical.py",
        "class_name": "pandas.tests.indexing.test_categorical.TestCategoricalIndex",
        "signature": "pandas.tests.indexing.test_categorical.TestCategoricalIndex.test_loc_with_non_string_categories(self, idx_values, ordered_fixture)",
        "snippet": "    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):\n        # GH-17569\n        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)\n        df = DataFrame({\"A\": [\"foo\", \"bar\", \"baz\"]}, index=cat_idx)\n\n        # scalar selection\n        result = df.loc[idx_values[0]]\n        expected = Series([\"foo\"], index=[\"A\"], name=idx_values[0])\n        tm.assert_series_equal(result, expected)\n\n        # list selection\n        result = df.loc[idx_values[:2]]\n        expected = DataFrame([\"foo\", \"bar\"], index=cat_idx[:2], columns=[\"A\"])\n        tm.assert_frame_equal(result, expected)\n\n        # scalar assignment\n        result = df.copy()\n        result.loc[idx_values[0]] = \"qux\"\n        expected = DataFrame({\"A\": [\"qux\", \"bar\", \"baz\"]}, index=cat_idx)\n        tm.assert_frame_equal(result, expected)\n\n        # list assignment\n        result = df.copy()\n        result.loc[idx_values[:2], \"A\"] = [\"qux\", \"qux2\"]\n        expected = DataFrame({\"A\": [\"qux\", \"qux2\", \"baz\"]}, index=cat_idx)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 793,
        "end_line": 818,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.conftest.multiindex_dataframe_random_data#9",
        "src_path": "pandas/tests/indexing/multiindex/conftest.py",
        "class_name": "pandas.tests.indexing.multiindex.conftest",
        "signature": "pandas.tests.indexing.multiindex.conftest.multiindex_dataframe_random_data()",
        "snippet": "def multiindex_dataframe_random_data():\n    \"\"\"DataFrame with 2 level MultiIndex with random data\"\"\"\n    index = MultiIndex(\n        levels=[[\"foo\", \"bar\", \"baz\", \"qux\"], [\"one\", \"two\", \"three\"]],\n        codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],\n        names=[\"first\", \"second\"],\n    )\n    return DataFrame(\n        np.random.randn(10, 3), index=index, columns=Index([\"A\", \"B\", \"C\"], name=\"exp\")\n    )",
        "begin_line": 9,
        "end_line": 18,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.multiindex.conftest.multiindex_year_month_day_dataframe_random_data#22",
        "src_path": "pandas/tests/indexing/multiindex/conftest.py",
        "class_name": "pandas.tests.indexing.multiindex.conftest",
        "signature": "pandas.tests.indexing.multiindex.conftest.multiindex_year_month_day_dataframe_random_data()",
        "snippet": "def multiindex_year_month_day_dataframe_random_data():\n    \"\"\"DataFrame with 3 level MultiIndex (year, month, day) covering\n    first 100 business days from 2000-01-01 with random data\"\"\"\n    tdf = tm.makeTimeDataFrame(100)\n    ymd = tdf.groupby([lambda x: x.year, lambda x: x.month, lambda x: x.day]).sum()\n    # use Int64Index, to make sure things work\n    ymd.index.set_levels([lev.astype(\"i8\") for lev in ymd.index.levels], inplace=True)\n    ymd.index.set_names([\"year\", \"month\", \"day\"], inplace=True)\n    return ymd",
        "begin_line": 22,
        "end_line": 30,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.conftest.numeric_indexing_engine_type_and_dtype#22",
        "src_path": "pandas/tests/indexing/conftest.py",
        "class_name": "pandas.tests.indexing.conftest",
        "signature": "pandas.tests.indexing.conftest.numeric_indexing_engine_type_and_dtype(request)",
        "snippet": "def numeric_indexing_engine_type_and_dtype(request):\n    return request.param",
        "begin_line": 22,
        "end_line": 23,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_floats.TestFloatIndexers.check#9",
        "src_path": "pandas/tests/indexing/test_floats.py",
        "class_name": "pandas.tests.indexing.test_floats.TestFloatIndexers",
        "signature": "pandas.tests.indexing.test_floats.TestFloatIndexers.check(self, result, original, indexer, getitem)",
        "snippet": "    def check(self, result, original, indexer, getitem):\n        \"\"\"\n        comparator for results\n        we need to take care if we are indexing on a\n        Series or a frame\n        \"\"\"\n        if isinstance(original, Series):\n            expected = original.iloc[indexer]\n        else:\n            if getitem:\n                expected = original.iloc[:, indexer]\n            else:\n                expected = original.iloc[indexer]\n\n        tm.assert_almost_equal(result, expected)",
        "begin_line": 9,
        "end_line": 23,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_scalar_error#25",
        "src_path": "pandas/tests/indexing/test_floats.py",
        "class_name": "pandas.tests.indexing.test_floats.TestFloatIndexers",
        "signature": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_scalar_error(self)",
        "snippet": "    def test_scalar_error(self):\n\n        # GH 4892\n        # float_indexers should raise exceptions\n        # on appropriate Index types & accessors\n        # this duplicates the code below\n        # but is specifically testing for the error\n        # message\n\n        for index in [\n            tm.makeStringIndex,\n            tm.makeUnicodeIndex,\n            tm.makeCategoricalIndex,\n            tm.makeDateIndex,\n            tm.makeTimedeltaIndex,\n            tm.makePeriodIndex,\n            tm.makeIntIndex,\n            tm.makeRangeIndex,\n        ]:\n\n            i = index(5)\n\n            s = Series(np.arange(len(i)), index=i)\n\n            msg = \"Cannot index by location index\"\n            with pytest.raises(TypeError, match=msg):\n                s.iloc[3.0]\n\n            msg = (\n                \"cannot do positional indexing on {klass} with these \"\n                r\"indexers \\[3\\.0\\] of {kind}\".format(klass=type(i), kind=str(float))\n            )\n            with pytest.raises(TypeError, match=msg):\n                s.iloc[3.0] = 0",
        "begin_line": 25,
        "end_line": 58,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_scalar_non_numeric#60",
        "src_path": "pandas/tests/indexing/test_floats.py",
        "class_name": "pandas.tests.indexing.test_floats.TestFloatIndexers",
        "signature": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_scalar_non_numeric(self)",
        "snippet": "    def test_scalar_non_numeric(self):\n\n        # GH 4892\n        # float_indexers should raise exceptions\n        # on appropriate Index types & accessors\n\n        for index in [\n            tm.makeStringIndex,\n            tm.makeUnicodeIndex,\n            tm.makeCategoricalIndex,\n            tm.makeDateIndex,\n            tm.makeTimedeltaIndex,\n            tm.makePeriodIndex,\n        ]:\n\n            i = index(5)\n\n            for s in [\n                Series(np.arange(len(i)), index=i),\n                DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n            ]:\n\n                # getting\n                for idxr, getitem in [(lambda x: x.iloc, False), (lambda x: x, True)]:\n\n                    # gettitem on a DataFrame is a KeyError as it is indexing\n                    # via labels on the columns\n                    if getitem and isinstance(s, DataFrame):\n                        error = KeyError\n                        msg = r\"^3(\\.0)?$\"\n                    else:\n                        error = TypeError\n                        msg = (\n                            r\"cannot do (label|index|positional) indexing\"\n                            r\" on {klass} with these indexers \\[3\\.0\\] of\"\n                            r\" {kind}|\"\n                            \"Cannot index by location index with a\"\n                            \" non-integer key\".format(klass=type(i), kind=str(float))\n                        )\n                    with pytest.raises(error, match=msg):\n                        idxr(s)[3.0]\n\n                # label based can be a TypeError or KeyError\n                if s.index.inferred_type in {\n                    \"categorical\",\n                    \"string\",\n                    \"unicode\",\n                    \"mixed\",\n                }:\n                    error = KeyError\n                    msg = r\"^3$\"\n                else:\n                    error = TypeError\n                    msg = (\n                        r\"cannot do (label|index) indexing\"\n                        r\" on {klass} with these indexers \\[3\\.0\\] of\"\n                        r\" {kind}\".format(klass=type(i), kind=str(float))\n                    )\n                with pytest.raises(error, match=msg):\n                    s.loc[3.0]\n\n                # contains\n                assert 3.0 not in s\n\n                # setting with a float fails with iloc\n                msg = (\n                    r\"cannot do (label|index|positional) indexing\"\n                    r\" on {klass} with these indexers \\[3\\.0\\] of\"\n                    r\" {kind}\".format(klass=type(i), kind=str(float))\n                )\n                with pytest.raises(TypeError, match=msg):\n                    s.iloc[3.0] = 0\n\n                # setting with an indexer\n                if s.index.inferred_type in [\"categorical\"]:\n                    # Value or Type Error\n                    pass\n                elif s.index.inferred_type in [\"datetime64\", \"timedelta64\", \"period\"]:\n\n                    # these should prob work\n                    # and are inconsisten between series/dataframe ATM\n                    # for idxr in [lambda x: x.ix,\n                    #             lambda x: x]:\n                    #    s2 = s.copy()\n                    #\n                    #    with pytest.raises(TypeError):\n                    #        idxr(s2)[3.0] = 0\n                    pass\n\n                else:\n\n                    s2 = s.copy()\n                    s2.loc[3.0] = 10\n                    assert s2.index.is_object()\n\n                    for idxr in [lambda x: x]:\n                        s2 = s.copy()\n                        idxr(s2)[3.0] = 0\n                        assert s2.index.is_object()\n\n            # fallsback to position selection, series only\n            s = Series(np.arange(len(i)), index=i)\n            s[3]\n            msg = (\n                r\"cannot do (label|index) indexing\"\n                r\" on {klass} with these indexers \\[3\\.0\\] of\"\n                r\" {kind}\".format(klass=type(i), kind=str(float))\n            )\n            with pytest.raises(TypeError, match=msg):\n                s[3.0]",
        "begin_line": 60,
        "end_line": 169,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_scalar_with_mixed#171",
        "src_path": "pandas/tests/indexing/test_floats.py",
        "class_name": "pandas.tests.indexing.test_floats.TestFloatIndexers",
        "signature": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_scalar_with_mixed(self)",
        "snippet": "    def test_scalar_with_mixed(self):\n\n        s2 = Series([1, 2, 3], index=[\"a\", \"b\", \"c\"])\n        s3 = Series([1, 2, 3], index=[\"a\", \"b\", 1.5])\n\n        # lookup in a pure stringstr\n        # with an invalid indexer\n        for idxr in [lambda x: x, lambda x: x.iloc]:\n\n            msg = (\n                r\"cannot do label indexing\"\n                r\" on {klass} with these indexers \\[1\\.0\\] of\"\n                r\" {kind}|\"\n                \"Cannot index by location index with a non-integer key\".format(\n                    klass=str(Index), kind=str(float)\n                )\n            )\n            with pytest.raises(TypeError, match=msg):\n                idxr(s2)[1.0]\n\n        with pytest.raises(KeyError, match=r\"^1$\"):\n            s2.loc[1.0]\n\n        result = s2.loc[\"b\"]\n        expected = 2\n        assert result == expected\n\n        # mixed index so we have label\n        # indexing\n        for idxr in [lambda x: x]:\n\n            msg = (\n                r\"cannot do label indexing\"\n                r\" on {klass} with these indexers \\[1\\.0\\] of\"\n                r\" {kind}\".format(klass=str(Index), kind=str(float))\n            )\n            with pytest.raises(TypeError, match=msg):\n                idxr(s3)[1.0]\n\n            result = idxr(s3)[1]\n            expected = 2\n            assert result == expected\n\n        msg = \"Cannot index by location index with a non-integer key\"\n        with pytest.raises(TypeError, match=msg):\n            s3.iloc[1.0]\n        with pytest.raises(KeyError, match=r\"^1$\"):\n            s3.loc[1.0]\n\n        result = s3.loc[1.5]\n        expected = 3\n        assert result == expected",
        "begin_line": 171,
        "end_line": 222,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_scalar_integer#224",
        "src_path": "pandas/tests/indexing/test_floats.py",
        "class_name": "pandas.tests.indexing.test_floats.TestFloatIndexers",
        "signature": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_scalar_integer(self)",
        "snippet": "    def test_scalar_integer(self):\n\n        # test how scalar float indexers work on int indexes\n\n        # integer index\n        for i in [Int64Index(range(5)), RangeIndex(5)]:\n\n            for s in [\n                Series(np.arange(len(i))),\n                DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),\n            ]:\n\n                # coerce to equal int\n                for idxr, getitem in [(lambda x: x.loc, False), (lambda x: x, True)]:\n\n                    result = idxr(s)[3.0]\n                    self.check(result, s, 3, getitem)\n\n                # coerce to equal int\n                for idxr, getitem in [(lambda x: x.loc, False), (lambda x: x, True)]:\n\n                    if isinstance(s, Series):\n\n                        def compare(x, y):\n                            assert x == y\n\n                        expected = 100\n                    else:\n                        compare = tm.assert_series_equal\n                        if getitem:\n                            expected = Series(100, index=range(len(s)), name=3)\n                        else:\n                            expected = Series(100.0, index=range(len(s)), name=3)\n\n                    s2 = s.copy()\n                    idxr(s2)[3.0] = 100\n\n                    result = idxr(s2)[3.0]\n                    compare(result, expected)\n\n                    result = idxr(s2)[3]\n                    compare(result, expected)\n\n                # contains\n                # coerce to equal int\n                assert 3.0 in s",
        "begin_line": 224,
        "end_line": 269,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_floats.TestFloatIndexers.compare#247",
        "src_path": "pandas/tests/indexing/test_floats.py",
        "class_name": "pandas.tests.indexing.test_floats.TestFloatIndexers",
        "signature": "pandas.tests.indexing.test_floats.TestFloatIndexers.compare(x, y)",
        "snippet": "                        def compare(x, y):\n                            assert x == y",
        "begin_line": 247,
        "end_line": 248,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_scalar_float#271",
        "src_path": "pandas/tests/indexing/test_floats.py",
        "class_name": "pandas.tests.indexing.test_floats.TestFloatIndexers",
        "signature": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_scalar_float(self)",
        "snippet": "    def test_scalar_float(self):\n\n        # scalar float indexers work on a float index\n        index = Index(np.arange(5.0))\n        for s in [\n            Series(np.arange(len(index)), index=index),\n            DataFrame(\n                np.random.randn(len(index), len(index)), index=index, columns=index\n            ),\n        ]:\n\n            # assert all operations except for iloc are ok\n            indexer = index[3]\n            for idxr, getitem in [(lambda x: x.loc, False), (lambda x: x, True)]:\n\n                # getting\n                result = idxr(s)[indexer]\n                self.check(result, s, 3, getitem)\n\n                # setting\n                s2 = s.copy()\n\n                result = idxr(s2)[indexer]\n                self.check(result, s, 3, getitem)\n\n                # random integer is a KeyError\n                with pytest.raises(KeyError, match=r\"^3\\.5$\"):\n                    idxr(s)[3.5]\n\n            # contains\n            assert 3.0 in s\n\n            # iloc succeeds with an integer\n            expected = s.iloc[3]\n            s2 = s.copy()\n\n            s2.iloc[3] = expected\n            result = s2.iloc[3]\n            self.check(result, s, 3, False)\n\n            # iloc raises with a float\n            msg = \"Cannot index by location index with a non-integer key\"\n            with pytest.raises(TypeError, match=msg):\n                s.iloc[3.0]\n\n            msg = (\n                r\"cannot do positional indexing\"\n                r\" on {klass} with these indexers \\[3\\.0\\] of\"\n                r\" {kind}\".format(klass=str(Float64Index), kind=str(float))\n            )\n            with pytest.raises(TypeError, match=msg):\n                s2.iloc[3.0] = 0",
        "begin_line": 271,
        "end_line": 322,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_slice_non_numeric#324",
        "src_path": "pandas/tests/indexing/test_floats.py",
        "class_name": "pandas.tests.indexing.test_floats.TestFloatIndexers",
        "signature": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_slice_non_numeric(self)",
        "snippet": "    def test_slice_non_numeric(self):\n\n        # GH 4892\n        # float_indexers should raise exceptions\n        # on appropriate Index types & accessors\n\n        for index in [\n            tm.makeStringIndex,\n            tm.makeUnicodeIndex,\n            tm.makeDateIndex,\n            tm.makeTimedeltaIndex,\n            tm.makePeriodIndex,\n        ]:\n\n            index = index(5)\n            for s in [\n                Series(range(5), index=index),\n                DataFrame(np.random.randn(5, 2), index=index),\n            ]:\n\n                # getitem\n                for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:\n\n                    msg = (\n                        \"cannot do slice indexing\"\n                        r\" on {klass} with these indexers \\[(3|4)\\.0\\] of\"\n                        \" {kind}\".format(klass=type(index), kind=str(float))\n                    )\n                    with pytest.raises(TypeError, match=msg):\n                        s.iloc[l]\n\n                    for idxr in [lambda x: x.loc, lambda x: x.iloc, lambda x: x]:\n\n                        msg = (\n                            \"cannot do slice indexing\"\n                            r\" on {klass} with these indexers\"\n                            r\" \\[(3|4)(\\.0)?\\]\"\n                            r\" of ({kind_float}|{kind_int})\".format(\n                                klass=type(index),\n                                kind_float=str(float),\n                                kind_int=str(int),\n                            )\n                        )\n                        with pytest.raises(TypeError, match=msg):\n                            idxr(s)[l]\n\n                # setitem\n                for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:\n\n                    msg = (\n                        \"cannot do slice indexing\"\n                        r\" on {klass} with these indexers \\[(3|4)\\.0\\] of\"\n                        \" {kind}\".format(klass=type(index), kind=str(float))\n                    )\n                    with pytest.raises(TypeError, match=msg):\n                        s.iloc[l] = 0\n\n                    for idxr in [lambda x: x.loc, lambda x: x.iloc, lambda x: x]:\n                        msg = (\n                            \"cannot do slice indexing\"\n                            r\" on {klass} with these indexers\"\n                            r\" \\[(3|4)(\\.0)?\\]\"\n                            r\" of ({kind_float}|{kind_int})\".format(\n                                klass=type(index),\n                                kind_float=str(float),\n                                kind_int=str(int),\n                            )\n                        )\n                        with pytest.raises(TypeError, match=msg):\n                            idxr(s)[l] = 0",
        "begin_line": 324,
        "end_line": 393,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_slice_integer#395",
        "src_path": "pandas/tests/indexing/test_floats.py",
        "class_name": "pandas.tests.indexing.test_floats.TestFloatIndexers",
        "signature": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_slice_integer(self)",
        "snippet": "    def test_slice_integer(self):\n\n        # same as above, but for Integer based indexes\n        # these coerce to a like integer\n        # oob indicates if we are out of bounds\n        # of positional indexing\n        for index, oob in [\n            (Int64Index(range(5)), False),\n            (RangeIndex(5), False),\n            (Int64Index(range(5)) + 10, True),\n        ]:\n\n            # s is an in-range index\n            s = Series(range(5), index=index)\n\n            # getitem\n            for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:\n\n                for idxr in [lambda x: x.loc]:\n\n                    result = idxr(s)[l]\n\n                    # these are all label indexing\n                    # except getitem which is positional\n                    # empty\n                    if oob:\n                        indexer = slice(0, 0)\n                    else:\n                        indexer = slice(3, 5)\n                    self.check(result, s, indexer, False)\n\n                # positional indexing\n                msg = (\n                    \"cannot do slice indexing\"\n                    r\" on {klass} with these indexers \\[(3|4)\\.0\\] of\"\n                    \" {kind}\".format(klass=type(index), kind=str(float))\n                )\n                with pytest.raises(TypeError, match=msg):\n                    s[l]\n\n            # getitem out-of-bounds\n            for l in [slice(-6, 6), slice(-6.0, 6.0)]:\n\n                for idxr in [lambda x: x.loc]:\n                    result = idxr(s)[l]\n\n                    # these are all label indexing\n                    # except getitem which is positional\n                    # empty\n                    if oob:\n                        indexer = slice(0, 0)\n                    else:\n                        indexer = slice(-6, 6)\n                    self.check(result, s, indexer, False)\n\n            # positional indexing\n            msg = (\n                \"cannot do slice indexing\"\n                r\" on {klass} with these indexers \\[-6\\.0\\] of\"\n                \" {kind}\".format(klass=type(index), kind=str(float))\n            )\n            with pytest.raises(TypeError, match=msg):\n                s[slice(-6.0, 6.0)]\n\n            # getitem odd floats\n            for l, res1 in [\n                (slice(2.5, 4), slice(3, 5)),\n                (slice(2, 3.5), slice(2, 4)),\n                (slice(2.5, 3.5), slice(3, 4)),\n            ]:\n\n                for idxr in [lambda x: x.loc]:\n\n                    result = idxr(s)[l]\n                    if oob:\n                        res = slice(0, 0)\n                    else:\n                        res = res1\n\n                    self.check(result, s, res, False)\n\n                # positional indexing\n                msg = (\n                    \"cannot do slice indexing\"\n                    r\" on {klass} with these indexers \\[(2|3)\\.5\\] of\"\n                    \" {kind}\".format(klass=type(index), kind=str(float))\n                )\n                with pytest.raises(TypeError, match=msg):\n                    s[l]\n\n            # setitem\n            for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:\n\n                for idxr in [lambda x: x.loc]:\n                    sc = s.copy()\n                    idxr(sc)[l] = 0\n                    result = idxr(sc)[l].values.ravel()\n                    assert (result == 0).all()\n\n                # positional indexing\n                msg = (\n                    \"cannot do slice indexing\"\n                    r\" on {klass} with these indexers \\[(3|4)\\.0\\] of\"\n                    \" {kind}\".format(klass=type(index), kind=str(float))\n                )\n                with pytest.raises(TypeError, match=msg):\n                    s[l] = 0",
        "begin_line": 395,
        "end_line": 501,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_integer_positional_indexing#503",
        "src_path": "pandas/tests/indexing/test_floats.py",
        "class_name": "pandas.tests.indexing.test_floats.TestFloatIndexers",
        "signature": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_integer_positional_indexing(self)",
        "snippet": "    def test_integer_positional_indexing(self):\n        \"\"\" make sure that we are raising on positional indexing\n        w.r.t. an integer index \"\"\"\n\n        s = Series(range(2, 6), index=range(2, 6))\n\n        result = s[2:4]\n        expected = s.iloc[2:4]\n        tm.assert_series_equal(result, expected)\n\n        for idxr in [lambda x: x, lambda x: x.iloc]:\n\n            for l in [slice(2, 4.0), slice(2.0, 4), slice(2.0, 4.0)]:\n\n                klass = RangeIndex\n                msg = (\n                    \"cannot do slice indexing\"\n                    r\" on {klass} with these indexers \\[(2|4)\\.0\\] of\"\n                    \" {kind}\".format(klass=str(klass), kind=str(float))\n                )\n                with pytest.raises(TypeError, match=msg):\n                    idxr(s)[l]",
        "begin_line": 503,
        "end_line": 524,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_slice_integer_frame_getitem#526",
        "src_path": "pandas/tests/indexing/test_floats.py",
        "class_name": "pandas.tests.indexing.test_floats.TestFloatIndexers",
        "signature": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_slice_integer_frame_getitem(self)",
        "snippet": "    def test_slice_integer_frame_getitem(self):\n\n        # similar to above, but on the getitem dim (of a DataFrame)\n        for index in [Int64Index(range(5)), RangeIndex(5)]:\n\n            s = DataFrame(np.random.randn(5, 2), index=index)\n\n            def f(idxr):\n\n                # getitem\n                for l in [slice(0.0, 1), slice(0, 1.0), slice(0.0, 1.0)]:\n\n                    result = idxr(s)[l]\n                    indexer = slice(0, 2)\n                    self.check(result, s, indexer, False)\n\n                    # positional indexing\n                    msg = (\n                        \"cannot do slice indexing\"\n                        r\" on {klass} with these indexers \\[(0|1)\\.0\\] of\"\n                        \" {kind}\".format(klass=type(index), kind=str(float))\n                    )\n                    with pytest.raises(TypeError, match=msg):\n                        s[l]\n\n                # getitem out-of-bounds\n                for l in [slice(-10, 10), slice(-10.0, 10.0)]:\n\n                    result = idxr(s)[l]\n                    self.check(result, s, slice(-10, 10), True)\n\n                # positional indexing\n                msg = (\n                    \"cannot do slice indexing\"\n                    r\" on {klass} with these indexers \\[-10\\.0\\] of\"\n                    \" {kind}\".format(klass=type(index), kind=str(float))\n                )\n                with pytest.raises(TypeError, match=msg):\n                    s[slice(-10.0, 10.0)]\n\n                # getitem odd floats\n                for l, res in [\n                    (slice(0.5, 1), slice(1, 2)),\n                    (slice(0, 0.5), slice(0, 1)),\n                    (slice(0.5, 1.5), slice(1, 2)),\n                ]:\n\n                    result = idxr(s)[l]\n                    self.check(result, s, res, False)\n\n                    # positional indexing\n                    msg = (\n                        \"cannot do slice indexing\"\n                        r\" on {klass} with these indexers \\[0\\.5\\] of\"\n                        \" {kind}\".format(klass=type(index), kind=str(float))\n                    )\n                    with pytest.raises(TypeError, match=msg):\n                        s[l]\n\n                # setitem\n                for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:\n\n                    sc = s.copy()\n                    idxr(sc)[l] = 0\n                    result = idxr(sc)[l].values.ravel()\n                    assert (result == 0).all()\n\n                    # positional indexing\n                    msg = (\n                        \"cannot do slice indexing\"\n                        r\" on {klass} with these indexers \\[(3|4)\\.0\\] of\"\n                        \" {kind}\".format(klass=type(index), kind=str(float))\n                    )\n                    with pytest.raises(TypeError, match=msg):\n                        s[l] = 0\n\n            f(lambda x: x.loc)",
        "begin_line": 526,
        "end_line": 602,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_floats.TestFloatIndexers.f#533",
        "src_path": "pandas/tests/indexing/test_floats.py",
        "class_name": "pandas.tests.indexing.test_floats.TestFloatIndexers",
        "signature": "pandas.tests.indexing.test_floats.TestFloatIndexers.f(idxr)",
        "snippet": "            def f(idxr):\n\n                # getitem\n                for l in [slice(0.0, 1), slice(0, 1.0), slice(0.0, 1.0)]:\n\n                    result = idxr(s)[l]\n                    indexer = slice(0, 2)\n                    self.check(result, s, indexer, False)\n\n                    # positional indexing\n                    msg = (\n                        \"cannot do slice indexing\"\n                        r\" on {klass} with these indexers \\[(0|1)\\.0\\] of\"\n                        \" {kind}\".format(klass=type(index), kind=str(float))\n                    )\n                    with pytest.raises(TypeError, match=msg):\n                        s[l]\n\n                # getitem out-of-bounds\n                for l in [slice(-10, 10), slice(-10.0, 10.0)]:\n\n                    result = idxr(s)[l]\n                    self.check(result, s, slice(-10, 10), True)\n\n                # positional indexing\n                msg = (\n                    \"cannot do slice indexing\"\n                    r\" on {klass} with these indexers \\[-10\\.0\\] of\"\n                    \" {kind}\".format(klass=type(index), kind=str(float))\n                )\n                with pytest.raises(TypeError, match=msg):\n                    s[slice(-10.0, 10.0)]\n\n                # getitem odd floats\n                for l, res in [\n                    (slice(0.5, 1), slice(1, 2)),\n                    (slice(0, 0.5), slice(0, 1)),\n                    (slice(0.5, 1.5), slice(1, 2)),\n                ]:\n\n                    result = idxr(s)[l]\n                    self.check(result, s, res, False)\n\n                    # positional indexing\n                    msg = (\n                        \"cannot do slice indexing\"\n                        r\" on {klass} with these indexers \\[0\\.5\\] of\"\n                        \" {kind}\".format(klass=type(index), kind=str(float))\n                    )\n                    with pytest.raises(TypeError, match=msg):\n                        s[l]\n\n                # setitem\n                for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:\n\n                    sc = s.copy()\n                    idxr(sc)[l] = 0\n                    result = idxr(sc)[l].values.ravel()\n                    assert (result == 0).all()\n\n                    # positional indexing\n                    msg = (\n                        \"cannot do slice indexing\"\n                        r\" on {klass} with these indexers \\[(3|4)\\.0\\] of\"\n                        \" {kind}\".format(klass=type(index), kind=str(float))\n                    )\n                    with pytest.raises(TypeError, match=msg):\n                        s[l] = 0",
        "begin_line": 533,
        "end_line": 600,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_slice_float#604",
        "src_path": "pandas/tests/indexing/test_floats.py",
        "class_name": "pandas.tests.indexing.test_floats.TestFloatIndexers",
        "signature": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_slice_float(self)",
        "snippet": "    def test_slice_float(self):\n\n        # same as above, but for floats\n        index = Index(np.arange(5.0)) + 0.1\n        for s in [\n            Series(range(5), index=index),\n            DataFrame(np.random.randn(5, 2), index=index),\n        ]:\n\n            for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:\n\n                expected = s.iloc[3:4]\n                for idxr in [lambda x: x.loc, lambda x: x]:\n\n                    # getitem\n                    result = idxr(s)[l]\n                    if isinstance(s, Series):\n                        tm.assert_series_equal(result, expected)\n                    else:\n                        tm.assert_frame_equal(result, expected)\n                    # setitem\n                    s2 = s.copy()\n                    idxr(s2)[l] = 0\n                    result = idxr(s2)[l].values.ravel()\n                    assert (result == 0).all()",
        "begin_line": 604,
        "end_line": 628,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_floating_index_doc_example#630",
        "src_path": "pandas/tests/indexing/test_floats.py",
        "class_name": "pandas.tests.indexing.test_floats.TestFloatIndexers",
        "signature": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_floating_index_doc_example(self)",
        "snippet": "    def test_floating_index_doc_example(self):\n\n        index = Index([1.5, 2, 3, 4.5, 5])\n        s = Series(range(5), index=index)\n        assert s[3] == 2\n        assert s.loc[3] == 2\n        assert s.loc[3] == 2\n        assert s.iloc[3] == 3",
        "begin_line": 630,
        "end_line": 637,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_floating_misc#639",
        "src_path": "pandas/tests/indexing/test_floats.py",
        "class_name": "pandas.tests.indexing.test_floats.TestFloatIndexers",
        "signature": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_floating_misc(self)",
        "snippet": "    def test_floating_misc(self):\n\n        # related 236\n        # scalar/slicing of a float index\n        s = Series(np.arange(5), index=np.arange(5) * 2.5, dtype=np.int64)\n\n        # label based slicing\n        result1 = s[1.0:3.0]\n        result2 = s.loc[1.0:3.0]\n        result3 = s.loc[1.0:3.0]\n        tm.assert_series_equal(result1, result2)\n        tm.assert_series_equal(result1, result3)\n\n        # exact indexing when found\n        result1 = s[5.0]\n        result2 = s.loc[5.0]\n        result3 = s.loc[5.0]\n        assert result1 == result2\n        assert result1 == result3\n\n        result1 = s[5]\n        result2 = s.loc[5]\n        result3 = s.loc[5]\n        assert result1 == result2\n        assert result1 == result3\n\n        assert s[5.0] == s[5]\n\n        # value not found (and no fallbacking at all)\n\n        # scalar integers\n        with pytest.raises(KeyError, match=r\"^4\\.0$\"):\n            s.loc[4]\n        with pytest.raises(KeyError, match=r\"^4\\.0$\"):\n            s.loc[4]\n        with pytest.raises(KeyError, match=r\"^4\\.0$\"):\n            s[4]\n\n        # fancy floats/integers create the correct entry (as nan)\n        # fancy tests\n        expected = Series([2, 0], index=Float64Index([5.0, 0.0]))\n        for fancy_idx in [[5.0, 0.0], np.array([5.0, 0.0])]:  # float\n            tm.assert_series_equal(s[fancy_idx], expected)\n            tm.assert_series_equal(s.loc[fancy_idx], expected)\n            tm.assert_series_equal(s.loc[fancy_idx], expected)\n\n        expected = Series([2, 0], index=Index([5, 0], dtype=\"int64\"))\n        for fancy_idx in [[5, 0], np.array([5, 0])]:  # int\n            tm.assert_series_equal(s[fancy_idx], expected)\n            tm.assert_series_equal(s.loc[fancy_idx], expected)\n            tm.assert_series_equal(s.loc[fancy_idx], expected)\n\n        # all should return the same as we are slicing 'the same'\n        result1 = s.loc[2:5]\n        result2 = s.loc[2.0:5.0]\n        result3 = s.loc[2.0:5]\n        result4 = s.loc[2.1:5]\n        tm.assert_series_equal(result1, result2)\n        tm.assert_series_equal(result1, result3)\n        tm.assert_series_equal(result1, result4)\n\n        # previously this did fallback indexing\n        result1 = s[2:5]\n        result2 = s[2.0:5.0]\n        result3 = s[2.0:5]\n        result4 = s[2.1:5]\n        tm.assert_series_equal(result1, result2)\n        tm.assert_series_equal(result1, result3)\n        tm.assert_series_equal(result1, result4)\n\n        result1 = s.loc[2:5]\n        result2 = s.loc[2.0:5.0]\n        result3 = s.loc[2.0:5]\n        result4 = s.loc[2.1:5]\n        tm.assert_series_equal(result1, result2)\n        tm.assert_series_equal(result1, result3)\n        tm.assert_series_equal(result1, result4)\n\n        # combined test\n        result1 = s.loc[2:5]\n        result2 = s.loc[2:5]\n        result3 = s[2:5]\n\n        tm.assert_series_equal(result1, result2)\n        tm.assert_series_equal(result1, result3)\n\n        # list selection\n        result1 = s[[0.0, 5, 10]]\n        result2 = s.loc[[0.0, 5, 10]]\n        result3 = s.loc[[0.0, 5, 10]]\n        result4 = s.iloc[[0, 2, 4]]\n        tm.assert_series_equal(result1, result2)\n        tm.assert_series_equal(result1, result3)\n        tm.assert_series_equal(result1, result4)\n\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            s[[1.6, 5, 10]]\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            s.loc[[1.6, 5, 10]]\n\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            s[[0, 1, 2]]\n        with pytest.raises(KeyError, match=\"with any missing labels\"):\n            s.loc[[0, 1, 2]]\n\n        result1 = s.loc[[2.5, 5]]\n        result2 = s.loc[[2.5, 5]]\n        tm.assert_series_equal(result1, result2)\n        tm.assert_series_equal(result1, Series([1, 2], index=[2.5, 5.0]))\n\n        result1 = s[[2.5]]\n        result2 = s.loc[[2.5]]\n        result3 = s.loc[[2.5]]\n        tm.assert_series_equal(result1, result2)\n        tm.assert_series_equal(result1, result3)\n        tm.assert_series_equal(result1, Series([1], index=[2.5]))",
        "begin_line": 639,
        "end_line": 754,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_floating_tuples#756",
        "src_path": "pandas/tests/indexing/test_floats.py",
        "class_name": "pandas.tests.indexing.test_floats.TestFloatIndexers",
        "signature": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_floating_tuples(self)",
        "snippet": "    def test_floating_tuples(self):\n        # see gh-13509\n        s = Series([(1, 1), (2, 2), (3, 3)], index=[0.0, 0.1, 0.2], name=\"foo\")\n\n        result = s[0.0]\n        assert result == (1, 1)\n\n        expected = Series([(1, 1), (2, 2)], index=[0.0, 0.0], name=\"foo\")\n        s = Series([(1, 1), (2, 2), (3, 3)], index=[0.0, 0.0, 0.2], name=\"foo\")\n\n        result = s[0.0]\n        tm.assert_series_equal(result, expected)",
        "begin_line": 756,
        "end_line": 767,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_float64index_slicing_bug#769",
        "src_path": "pandas/tests/indexing/test_floats.py",
        "class_name": "pandas.tests.indexing.test_floats.TestFloatIndexers",
        "signature": "pandas.tests.indexing.test_floats.TestFloatIndexers.test_float64index_slicing_bug(self)",
        "snippet": "    def test_float64index_slicing_bug(self):\n        # GH 5557, related to slicing a float index\n        ser = {\n            256: 2321.0,\n            1: 78.0,\n            2: 2716.0,\n            3: 0.0,\n            4: 369.0,\n            5: 0.0,\n            6: 269.0,\n            7: 0.0,\n            8: 0.0,\n            9: 0.0,\n            10: 3536.0,\n            11: 0.0,\n            12: 24.0,\n            13: 0.0,\n            14: 931.0,\n            15: 0.0,\n            16: 101.0,\n            17: 78.0,\n            18: 9643.0,\n            19: 0.0,\n            20: 0.0,\n            21: 0.0,\n            22: 63761.0,\n            23: 0.0,\n            24: 446.0,\n            25: 0.0,\n            26: 34773.0,\n            27: 0.0,\n            28: 729.0,\n            29: 78.0,\n            30: 0.0,\n            31: 0.0,\n            32: 3374.0,\n            33: 0.0,\n            34: 1391.0,\n            35: 0.0,\n            36: 361.0,\n            37: 0.0,\n            38: 61808.0,\n            39: 0.0,\n            40: 0.0,\n            41: 0.0,\n            42: 6677.0,\n            43: 0.0,\n            44: 802.0,\n            45: 0.0,\n            46: 2691.0,\n            47: 0.0,\n            48: 3582.0,\n            49: 0.0,\n            50: 734.0,\n            51: 0.0,\n            52: 627.0,\n            53: 70.0,\n            54: 2584.0,\n            55: 0.0,\n            56: 324.0,\n            57: 0.0,\n            58: 605.0,\n            59: 0.0,\n            60: 0.0,\n            61: 0.0,\n            62: 3989.0,\n            63: 10.0,\n            64: 42.0,\n            65: 0.0,\n            66: 904.0,\n            67: 0.0,\n            68: 88.0,\n            69: 70.0,\n            70: 8172.0,\n            71: 0.0,\n            72: 0.0,\n            73: 0.0,\n            74: 64902.0,\n            75: 0.0,\n            76: 347.0,\n            77: 0.0,\n            78: 36605.0,\n            79: 0.0,\n            80: 379.0,\n            81: 70.0,\n            82: 0.0,\n            83: 0.0,\n            84: 3001.0,\n            85: 0.0,\n            86: 1630.0,\n            87: 7.0,\n            88: 364.0,\n            89: 0.0,\n            90: 67404.0,\n            91: 9.0,\n            92: 0.0,\n            93: 0.0,\n            94: 7685.0,\n            95: 0.0,\n            96: 1017.0,\n            97: 0.0,\n            98: 2831.0,\n            99: 0.0,\n            100: 2963.0,\n            101: 0.0,\n            102: 854.0,\n            103: 0.0,\n            104: 0.0,\n            105: 0.0,\n            106: 0.0,\n            107: 0.0,\n            108: 0.0,\n            109: 0.0,\n            110: 0.0,\n            111: 0.0,\n            112: 0.0,\n            113: 0.0,\n            114: 0.0,\n            115: 0.0,\n            116: 0.0,\n            117: 0.0,\n            118: 0.0,\n            119: 0.0,\n            120: 0.0,\n            121: 0.0,\n            122: 0.0,\n            123: 0.0,\n            124: 0.0,\n            125: 0.0,\n            126: 67744.0,\n            127: 22.0,\n            128: 264.0,\n            129: 0.0,\n            260: 197.0,\n            268: 0.0,\n            265: 0.0,\n            269: 0.0,\n            261: 0.0,\n            266: 1198.0,\n            267: 0.0,\n            262: 2629.0,\n            258: 775.0,\n            257: 0.0,\n            263: 0.0,\n            259: 0.0,\n            264: 163.0,\n            250: 10326.0,\n            251: 0.0,\n            252: 1228.0,\n            253: 0.0,\n            254: 2769.0,\n            255: 0.0,\n        }\n\n        # smoke test for the repr\n        s = Series(ser)\n        result = s.value_counts()\n        str(result)",
        "begin_line": 769,
        "end_line": 926,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common._mklbl#13",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common",
        "signature": "pandas.tests.indexing.common._mklbl(prefix, n)",
        "snippet": "def _mklbl(prefix, n):\n    return [\"{prefix}{i}\".format(prefix=prefix, i=i) for i in range(n)]",
        "begin_line": 13,
        "end_line": 14,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common._axify#17",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common",
        "signature": "pandas.tests.indexing.common._axify(obj, key, axis)",
        "snippet": "def _axify(obj, key, axis):\n    # create a tuple accessor\n    axes = [slice(None)] * obj.ndim\n    axes[axis] = key\n    return tuple(axes)",
        "begin_line": 17,
        "end_line": 21,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.setup_method#40",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n\n        self.series_ints = Series(np.random.rand(4), index=np.arange(0, 8, 2))\n        self.frame_ints = DataFrame(\n            np.random.randn(4, 4), index=np.arange(0, 8, 2), columns=np.arange(0, 12, 3)\n        )\n\n        self.series_uints = Series(\n            np.random.rand(4), index=UInt64Index(np.arange(0, 8, 2))\n        )\n        self.frame_uints = DataFrame(\n            np.random.randn(4, 4),\n            index=UInt64Index(range(0, 8, 2)),\n            columns=UInt64Index(range(0, 12, 3)),\n        )\n\n        self.series_floats = Series(\n            np.random.rand(4), index=Float64Index(range(0, 8, 2))\n        )\n        self.frame_floats = DataFrame(\n            np.random.randn(4, 4),\n            index=Float64Index(range(0, 8, 2)),\n            columns=Float64Index(range(0, 12, 3)),\n        )\n\n        m_idces = [\n            MultiIndex.from_product([[1, 2], [3, 4]]),\n            MultiIndex.from_product([[5, 6], [7, 8]]),\n            MultiIndex.from_product([[9, 10], [11, 12]]),\n        ]\n\n        self.series_multi = Series(np.random.rand(4), index=m_idces[0])\n        self.frame_multi = DataFrame(\n            np.random.randn(4, 4), index=m_idces[0], columns=m_idces[1]\n        )\n\n        self.series_labels = Series(np.random.randn(4), index=list(\"abcd\"))\n        self.frame_labels = DataFrame(\n            np.random.randn(4, 4), index=list(\"abcd\"), columns=list(\"ABCD\")\n        )\n\n        self.series_mixed = Series(np.random.randn(4), index=[2, 4, \"null\", 8])\n        self.frame_mixed = DataFrame(np.random.randn(4, 4), index=[2, 4, \"null\", 8])\n\n        self.series_ts = Series(\n            np.random.randn(4), index=date_range(\"20130101\", periods=4)\n        )\n        self.frame_ts = DataFrame(\n            np.random.randn(4, 4), index=date_range(\"20130101\", periods=4)\n        )\n\n        dates_rev = date_range(\"20130101\", periods=4).sort_values(ascending=False)\n        self.series_ts_rev = Series(np.random.randn(4), index=dates_rev)\n        self.frame_ts_rev = DataFrame(np.random.randn(4, 4), index=dates_rev)\n\n        self.frame_empty = DataFrame()\n        self.series_empty = Series(dtype=object)\n\n        # form agglomerates\n        for kind in self._kinds:\n            d = dict()\n            for typ in self._typs:\n                d[typ] = getattr(self, \"{kind}_{typ}\".format(kind=kind, typ=typ))\n\n            setattr(self, kind, d)",
        "begin_line": 40,
        "end_line": 104,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.generate_indices#106",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.generate_indices(self, f, values=False)",
        "snippet": "    def generate_indices(self, f, values=False):\n        \"\"\" generate the indices\n        if values is True , use the axis values\n        is False, use the range\n        \"\"\"\n\n        axes = f.axes\n        if values:\n            axes = (list(range(len(ax))) for ax in axes)\n\n        return itertools.product(*axes)",
        "begin_line": 106,
        "end_line": 116,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.get_result#118",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.get_result(self, obj, method, key, axis)",
        "snippet": "    def get_result(self, obj, method, key, axis):\n        \"\"\" return the result for this obj with this key and this axis \"\"\"\n\n        if isinstance(key, dict):\n            key = key[axis]\n\n        # use an artificial conversion to map the key as integers to the labels\n        # so ix can work for comparisons\n        if method == \"indexer\":\n            method = \"ix\"\n            key = obj._get_axis(axis)[key]\n\n        # in case we actually want 0 index slicing\n        with catch_warnings(record=True):\n            try:\n                xp = getattr(obj, method).__getitem__(_axify(obj, key, axis))\n            except AttributeError:\n                xp = getattr(obj, method).__getitem__(key)\n\n        return xp",
        "begin_line": 118,
        "end_line": 137,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.get_value#139",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.get_value(self, f, i, values=False)",
        "snippet": "    def get_value(self, f, i, values=False):\n        \"\"\" return the value for the location i \"\"\"\n\n        # check against values\n        if values:\n            return f.values[i]\n\n        # this is equiv of f[col][row].....\n        # v = f\n        # for a in reversed(i):\n        #    v = v.__getitem__(a)\n        # return v\n        with catch_warnings(record=True):\n            filterwarnings(\"ignore\", \"\\\\n.ix\", FutureWarning)\n            return f.ix[i]",
        "begin_line": 139,
        "end_line": 153,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.check_values#155",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.check_values(self, f, func, values=False)",
        "snippet": "    def check_values(self, f, func, values=False):\n\n        if f is None:\n            return\n        axes = f.axes\n        indicies = itertools.product(*axes)\n\n        for i in indicies:\n            result = getattr(f, func)[i]\n\n            # check against values\n            if values:\n                expected = f.values[i]\n            else:\n                expected = f\n                for a in reversed(i):\n                    expected = expected.__getitem__(a)\n\n            tm.assert_almost_equal(result, expected)",
        "begin_line": 155,
        "end_line": 173,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base.check_result#175",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base.check_result(self, method1, key1, method2, key2, typs=None, axes=None, fails=None)",
        "snippet": "    def check_result(\n        self, method1, key1, method2, key2, typs=None, axes=None, fails=None,\n    ):\n        def _eq(axis, obj, key1, key2):\n            \"\"\" compare equal for these 2 keys \"\"\"\n            if axis > obj.ndim - 1:\n                return\n\n            try:\n                rs = getattr(obj, method1).__getitem__(_axify(obj, key1, axis))\n\n                with catch_warnings(record=True):\n                    filterwarnings(\"ignore\", \"\\\\n.ix\", FutureWarning)\n                    try:\n                        xp = self.get_result(\n                            obj=obj, method=method2, key=key2, axis=axis\n                        )\n                    except (KeyError, IndexError):\n                        # TODO: why is this allowed?\n                        result = \"no comp\"\n                        return\n\n                if is_scalar(rs) and is_scalar(xp):\n                    assert rs == xp\n                else:\n                    tm.assert_equal(rs, xp)\n\n            except (IndexError, TypeError, KeyError) as detail:\n\n                # if we are in fails, the ok, otherwise raise it\n                if fails is not None:\n                    if isinstance(detail, fails):\n                        result = f\"ok ({type(detail).__name__})\"\n                        return\n\n                result = type(detail).__name__\n                raise AssertionError(result, detail)\n\n        if typs is None:\n            typs = self._typs\n\n        if axes is None:\n            axes = [0, 1]\n        elif not isinstance(axes, (tuple, list)):\n            assert isinstance(axes, int)\n            axes = [axes]\n\n        # check\n        for kind in self._kinds:\n\n            d = getattr(self, kind)\n            for ax in axes:\n                for typ in typs:\n                    if typ not in self._typs:\n                        continue\n\n                    obj = d[typ]\n                    _eq(axis=ax, obj=obj, key1=key1, key2=key2)",
        "begin_line": 175,
        "end_line": 232,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexing.common.Base._eq#178",
        "src_path": "pandas/tests/indexing/common.py",
        "class_name": "pandas.tests.indexing.common.Base",
        "signature": "pandas.tests.indexing.common.Base._eq(axis, obj, key1, key2)",
        "snippet": "        def _eq(axis, obj, key1, key2):\n            \"\"\" compare equal for these 2 keys \"\"\"\n            if axis > obj.ndim - 1:\n                return\n\n            try:\n                rs = getattr(obj, method1).__getitem__(_axify(obj, key1, axis))\n\n                with catch_warnings(record=True):\n                    filterwarnings(\"ignore\", \"\\\\n.ix\", FutureWarning)\n                    try:\n                        xp = self.get_result(\n                            obj=obj, method=method2, key=key2, axis=axis\n                        )\n                    except (KeyError, IndexError):\n                        # TODO: why is this allowed?\n                        result = \"no comp\"\n                        return\n\n                if is_scalar(rs) and is_scalar(xp):\n                    assert rs == xp\n                else:\n                    tm.assert_equal(rs, xp)\n\n            except (IndexError, TypeError, KeyError) as detail:\n\n                # if we are in fails, the ok, otherwise raise it\n                if fails is not None:\n                    if isinstance(detail, fails):\n                        result = f\"ok ({type(detail).__name__})\"\n                        return\n\n                result = type(detail).__name__\n                raise AssertionError(result, detail)",
        "begin_line": 178,
        "end_line": 211,
        "comment": "",
        "is_bug": false
    }
]