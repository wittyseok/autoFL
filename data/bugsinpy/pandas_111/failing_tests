coverage run -m pytest pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories
============================= test session starts ==============================
platform linux -- Python 3.8.3, pytest-5.4.3, py-1.8.1, pluggy-0.13.1
rootdir: /home/user/BugsInPy/temp/projects/pandas, inifile: setup.cfg
plugins: hypothesis-5.16.0
collected 93 items

pandas/tests/indexing/test_categorical.py FFFFFFFFFFFFFFFFF...FFFFFFFF.. [ 32%]
.FFFFFFFFFFFFFFFFF...FFFFFFFF...FFFFFFFFFFFFFFFFF...FFFFFFFF...          [100%]

=================================== FAILURES ===================================
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values0] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb719cd0>
idx_values = [1, 2, 3], ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values1] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb34e940>
idx_values = [-1, -2, -3], ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([-1, -2, -3], categories=[-3, -2, -1], ordered=True, dtype='category')
form = 'label', key = -1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [-1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values2] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb34e280>
idx_values = [1.5, 2.5, 3.5], ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2942: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=True, dtype='category')
form = 'label', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'float'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values3] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb3b6370>
idx_values = [-1.5, -2.5, -3.5], ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2942: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([-1.5, -2.5, -3.5], categories=[-3.5, -2.5, -1.5], ordered=True, dtype='category')
form = 'label', key = -1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [-1.5] of <class 'float'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values4] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb66ca30>
idx_values = array([1, 2, 3], dtype=uint8), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint8'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values5] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb05bd00>
idx_values = array([1, 2, 3], dtype=uint16), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint16'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values6] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb060a30>
idx_values = array([1, 2, 3], dtype=uint32), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint32'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values7] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadaf62f40>
idx_values = array([1, 2, 3], dtype=uint64), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint64'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values8] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb185d60>
idx_values = array([1, 2, 3]), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int64'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values9] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadaffb490>
idx_values = array([1, 2, 3], dtype=int8), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values10] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadaee8d60>
idx_values = array([1, 2, 3], dtype=int16), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values11] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb3012b0>
idx_values = array([1, 2, 3], dtype=int32), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values12] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadaee8f70>
idx_values = array([1, 2, 3]), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values13] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb16bd90>
idx_values = array([1.5, 2.5, 3.5]), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2942: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=True, dtype='category')
form = 'label', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'numpy.float64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values14] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadae18430>
idx_values = array([1.5, 2.5, 3.5], dtype=float32), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2942: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=True, dtype='category')
form = 'label', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'numpy.float32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values15] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadae8b9d0>
idx_values = array([1.5, 2.5, 3.5]), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2942: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=True, dtype='category')
form = 'label', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'numpy.float64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values16] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb543280>
idx_values = array([1, 'b', 3.5], dtype=object), ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 'b', 3.5], categories=[1, 3.5, 'b'], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values20] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadae18c10>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt8
ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values21] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadaf03850>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt16
ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values22] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadadd8a00>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt32
ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values23] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb1e9490>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt64
ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values24] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb55d6d0>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int8
ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values25] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb4a00d0>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int16
ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values26] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb2965b0>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int32
ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[True-idx_values27] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadaeddc40>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int64
ordered_fixture = True

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=True, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values0] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadae761c0>
idx_values = [1, 2, 3], ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values1] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadae735e0>
idx_values = [-1, -2, -3], ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([-1, -2, -3], categories=[-3, -2, -1], ordered=False, dtype='category')
form = 'label', key = -1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [-1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values2] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb16e970>
idx_values = [1.5, 2.5, 3.5], ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2942: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=False, dtype='category')
form = 'label', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'float'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values3] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb032e20>
idx_values = [-1.5, -2.5, -3.5], ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2942: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([-1.5, -2.5, -3.5], categories=[-3.5, -2.5, -1.5], ordered=False, dtype='category')
form = 'label', key = -1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [-1.5] of <class 'float'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values4] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb4c7460>
idx_values = array([1, 2, 3], dtype=uint8), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values5] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb032c40>
idx_values = array([1, 2, 3], dtype=uint16), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values6] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb044d30>
idx_values = array([1, 2, 3], dtype=uint32), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values7] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb52f9a0>
idx_values = array([1, 2, 3], dtype=uint64), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values8] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb56fc70>
idx_values = array([1, 2, 3]), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values9] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb48dd60>
idx_values = array([1, 2, 3], dtype=int8), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values10] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb56ff40>
idx_values = array([1, 2, 3], dtype=int16), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values11] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb0ced00>
idx_values = array([1, 2, 3], dtype=int32), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values12] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb0ab400>
idx_values = array([1, 2, 3]), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values13] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadaeea9a0>
idx_values = array([1.5, 2.5, 3.5]), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2942: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=False, dtype='category')
form = 'label', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'numpy.float64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values14] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb0c5d30>
idx_values = array([1.5, 2.5, 3.5], dtype=float32), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2942: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=False, dtype='category')
form = 'label', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'numpy.float32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values15] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadad0f490>
idx_values = array([1.5, 2.5, 3.5]), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2942: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=False, dtype='category')
form = 'label', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'numpy.float64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values16] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadac9f700>
idx_values = array([1, 'b', 3.5], dtype=object), ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 'b', 3.5], categories=[1, 3.5, 'b'], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values20] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadaf6e790>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt8
ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values21] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb03f190>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt16
ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values22] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb3fd640>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt32
ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values23] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb02e5e0>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt64
ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values24] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadaaea700>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int8
ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values25] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb376a30>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int16
ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values26] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadaaea250>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int32
ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[False-idx_values27] _

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb0333d0>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int64
ordered_fixture = False

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int64'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values0] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb43cb20>
idx_values = [1, 2, 3], ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values1] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb447a90>
idx_values = [-1, -2, -3], ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([-1, -2, -3], categories=[-3, -2, -1], ordered=False, dtype='category')
form = 'label', key = -1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [-1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values2] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadaf87ee0>
idx_values = [1.5, 2.5, 3.5], ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2942: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=False, dtype='category')
form = 'label', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'float'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values3] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadabdb4c0>
idx_values = [-1.5, -2.5, -3.5], ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2942: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([-1.5, -2.5, -3.5], categories=[-3.5, -2.5, -1.5], ordered=False, dtype='category')
form = 'label', key = -1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [-1.5] of <class 'float'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values4] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb368c40>
idx_values = array([1, 2, 3], dtype=uint8), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint8'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values5] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb3785e0>
idx_values = array([1, 2, 3], dtype=uint16), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint16'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values6] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb35c9d0>
idx_values = array([1, 2, 3], dtype=uint32), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint32'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values7] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadad6b6a0>
idx_values = array([1, 2, 3], dtype=uint64), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint64'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values8] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb439550>
idx_values = array([1, 2, 3]), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int64'>

pandas/core/indexes/base.py:3132: TypeError
__ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values9] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadac08580>
idx_values = array([1, 2, 3], dtype=int8), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values10] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb4d5340>
idx_values = array([1, 2, 3], dtype=int16), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values11] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadabaa6a0>
idx_values = array([1, 2, 3], dtype=int32), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values12] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadabaf6a0>
idx_values = array([1, 2, 3]), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values13] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb536af0>
idx_values = array([1.5, 2.5, 3.5]), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2942: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=False, dtype='category')
form = 'label', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'numpy.float64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values14] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbada8771c0>
idx_values = array([1.5, 2.5, 3.5], dtype=float32), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2942: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=False, dtype='category')
form = 'label', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'numpy.float32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values15] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadaf7bfa0>
idx_values = array([1.5, 2.5, 3.5]), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2942: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1.5, 2.5, 3.5], categories=[1.5, 2.5, 3.5], ordered=False, dtype='category')
form = 'label', key = 1.5

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1.5] of <class 'numpy.float64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values16] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbada877760>
idx_values = array([1, 'b', 3.5], dtype=object), ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 'b', 3.5], categories=[1, 3.5, 'b'], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'int'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values20] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb2f2310>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt8
ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values21] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadafe9130>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt16
ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values22] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb2f24f0>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt32
ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values23] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadaf0fca0>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: UInt64
ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.uint64'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values24] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb259400>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int8
ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int8'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values25] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb0abd60>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int16
ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int16'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values26] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb114250>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int32
ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int32'>

pandas/core/indexes/base.py:3132: TypeError
_ TestCategoricalIndex.test_loc_with_non_string_categories[None-idx_values27] __

self = <pandas.tests.indexing.test_categorical.TestCategoricalIndex object at 0x7fbadb114550>
idx_values = <IntegerArray>
[1, 2, 3]
Length: 3, dtype: Int64
ordered_fixture = None

    @pytest.mark.parametrize(
        "idx_values",
        [
            # python types
            [1, 2, 3],
            [-1, -2, -3],
            [1.5, 2.5, 3.5],
            [-1.5, -2.5, -3.5],
            # numpy int/uint
            *[np.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_INT_DTYPES],
            # numpy floats
            *[np.array([1.5, 2.5, 3.5], dtype=dtyp) for dtyp in conftest.FLOAT_DTYPES],
            # numpy object
            np.array([1, "b", 3.5], dtype=object),
            # pandas scalars
            [Interval(1, 4), Interval(4, 6), Interval(6, 9)],
            [Timestamp(2019, 1, 1), Timestamp(2019, 2, 1), Timestamp(2019, 3, 1)],
            [Timedelta(1, "d"), Timedelta(2, "d"), Timedelta(3, "D")],
            # pandas Integer arrays
            *[pd.array([1, 2, 3], dtype=dtype) for dtype in conftest.ALL_EA_INT_DTYPES],
            # other pandas arrays
            pd.IntervalIndex.from_breaks([1, 4, 6, 9]).array,
            pd.date_range("2019-01-01", periods=3).array,
            pd.timedelta_range(start="1d", periods=3).array,
        ],
    )
    def test_loc_with_non_string_categories(self, idx_values, ordered_fixture):
        # GH-17569
        cat_idx = CategoricalIndex(idx_values, ordered=ordered_fixture)
        df = DataFrame({"A": ["foo", "bar", "baz"]}, index=cat_idx)
    
        # scalar selection
>       result = df.loc[idx_values[0]]

pandas/tests/indexing/test_categorical.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2946: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex([1, 2, 3], categories=[1, 2, 3], ordered=False, dtype='category')
form = 'label', key = 1

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [1] of <class 'numpy.int64'>

pandas/core/indexes/base.py:3132: TypeError
=========================== short test summary info ============================
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values0]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values1]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values2]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values3]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values4]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values5]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values6]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values7]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values8]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values9]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values10]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values11]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values12]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values13]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values14]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values15]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values16]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values20]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values21]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values22]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values23]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values24]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values25]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values26]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[True-idx_values27]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values0]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values1]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values2]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values3]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values4]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values5]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values6]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values7]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values8]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values9]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values10]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values11]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values12]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values13]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values14]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values15]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values16]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values20]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values21]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values22]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values23]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values24]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values25]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values26]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[False-idx_values27]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values0]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values1]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values2]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values3]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values4]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values5]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values6]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values7]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values8]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values9]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values10]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values11]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values12]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values13]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values14]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values15]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values16]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values20]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values21]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values22]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values23]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values24]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values25]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values26]
FAILED pandas/tests/indexing/test_categorical.py::TestCategoricalIndex::test_loc_with_non_string_categories[None-idx_values27]
======================== 75 failed, 18 passed in 32.42s ========================

coverage run -m pytest pandas/tests/indexing/test_floats.py::TestFloatIndexers::test_scalar_non_numeric
============================= test session starts ==============================
platform linux -- Python 3.8.3, pytest-5.4.3, py-1.8.1, pluggy-0.13.1
rootdir: /home/user/BugsInPy/temp/projects/pandas, inifile: setup.cfg
plugins: hypothesis-5.16.0
collected 1 item

pandas/tests/indexing/test_floats.py F                                   [100%]

=================================== FAILURES ===================================
__________________ TestFloatIndexers.test_scalar_non_numeric ___________________

self = <pandas.tests.indexing.test_floats.TestFloatIndexers object at 0x7f2980aa8400>

    def test_scalar_non_numeric(self):
    
        # GH 4892
        # float_indexers should raise exceptions
        # on appropriate Index types & accessors
    
        for index in [
            tm.makeStringIndex,
            tm.makeUnicodeIndex,
            tm.makeCategoricalIndex,
            tm.makeDateIndex,
            tm.makeTimedeltaIndex,
            tm.makePeriodIndex,
        ]:
    
            i = index(5)
    
            for s in [
                Series(np.arange(len(i)), index=i),
                DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),
            ]:
    
                # getting
                for idxr, getitem in [(lambda x: x.iloc, False), (lambda x: x, True)]:
    
                    # gettitem on a DataFrame is a KeyError as it is indexing
                    # via labels on the columns
                    if getitem and isinstance(s, DataFrame):
                        error = KeyError
                        msg = r"^3(\.0)?$"
                    else:
                        error = TypeError
                        msg = (
                            r"cannot do (label|index|positional) indexing"
                            r" on {klass} with these indexers \[3\.0\] of"
                            r" {kind}|"
                            "Cannot index by location index with a"
                            " non-integer key".format(klass=type(i), kind=str(float))
                        )
                    with pytest.raises(error, match=msg):
                        idxr(s)[3.0]
    
                # label based can be a TypeError or KeyError
                if s.index.inferred_type in {
                    "categorical",
                    "string",
                    "unicode",
                    "mixed",
                }:
                    error = KeyError
                    msg = r"^3$"
                else:
                    error = TypeError
                    msg = (
                        r"cannot do (label|index) indexing"
                        r" on {klass} with these indexers \[3\.0\] of"
                        r" {kind}".format(klass=type(i), kind=str(float))
                    )
                with pytest.raises(error, match=msg):
>                   s.loc[3.0]

pandas/tests/indexing/test_floats.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/indexing.py:1410: in __getitem__
    return self._getitem_axis(maybe_callable, axis=axis)
pandas/core/indexing.py:1842: in _getitem_axis
    self._validate_key(key, axis)
pandas/core/indexing.py:1709: in _validate_key
    self._convert_scalar_indexer(key, axis)
pandas/core/indexing.py:276: in _convert_scalar_indexer
    return ax._convert_scalar_indexer(key, kind=self.name)
pandas/core/indexes/category.py:702: in _convert_scalar_indexer
    return super()._convert_scalar_indexer(key, kind=kind)
pandas/core/indexes/base.py:2942: in _convert_scalar_indexer
    return self._invalid_indexer("label", key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CategoricalIndex(['qzPN', 'YS0C', 'JQAB', 'qzPN', 'YS0C'], categories=['qzPN', 'YS0C', 'JQAB'], ordered=False, dtype='category')
form = 'label', key = 3.0

    def _invalid_indexer(self, form, key):
        """
        Consistent invalid indexer message.
        """
>       raise TypeError(
            f"cannot do {form} indexing on {type(self)} with these "
            f"indexers [{key}] of {type(key)}"
        )
E       TypeError: cannot do label indexing on <class 'pandas.core.indexes.category.CategoricalIndex'> with these indexers [3.0] of <class 'float'>

pandas/core/indexes/base.py:3132: TypeError
=========================== short test summary info ============================
FAILED pandas/tests/indexing/test_floats.py::TestFloatIndexers::test_scalar_non_numeric
============================== 1 failed in 0.65s ===============================
