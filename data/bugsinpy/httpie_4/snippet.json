[
    {
        "name": "httpie.config.BaseConfigDict.__getattr__#22",
        "src_path": "httpie/config.py",
        "class_name": "httpie.config.BaseConfigDict",
        "signature": "httpie.config.BaseConfigDict.__getattr__(self, item)",
        "snippet": "    def __getattr__(self, item):\n        return self[item]",
        "begin_line": 22,
        "end_line": 23,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001953125,
            "pseudo_dstar_susp": 0.003205128205128205,
            "pseudo_tarantula_susp": 0.0017730496453900709,
            "pseudo_op2_susp": 0.003205128205128205,
            "pseudo_barinel_susp": 0.0017730496453900709
        }
    },
    {
        "name": "httpie.config.BaseConfigDict.path#30",
        "src_path": "httpie/config.py",
        "class_name": "httpie.config.BaseConfigDict",
        "signature": "httpie.config.BaseConfigDict.path(self)",
        "snippet": "    def path(self):\n        \"\"\"Return the config file path creating basedir, if needed.\"\"\"\n        path = self._get_path()\n        try:\n            os.makedirs(os.path.dirname(path), mode=0o700)\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                raise\n        return path",
        "begin_line": 30,
        "end_line": 38,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001953125,
            "pseudo_dstar_susp": 0.003205128205128205,
            "pseudo_tarantula_susp": 0.0017730496453900709,
            "pseudo_op2_susp": 0.003205128205128205,
            "pseudo_barinel_susp": 0.0017730496453900709
        }
    },
    {
        "name": "httpie.config.BaseConfigDict.is_new#40",
        "src_path": "httpie/config.py",
        "class_name": "httpie.config.BaseConfigDict",
        "signature": "httpie.config.BaseConfigDict.is_new(self)",
        "snippet": "    def is_new(self):\n        return not os.path.exists(self._get_path())",
        "begin_line": 40,
        "end_line": 41,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001953125,
            "pseudo_dstar_susp": 0.003205128205128205,
            "pseudo_tarantula_susp": 0.0017730496453900709,
            "pseudo_op2_susp": 0.003205128205128205,
            "pseudo_barinel_susp": 0.0017730496453900709
        }
    },
    {
        "name": "httpie.config.BaseConfigDict.load#43",
        "src_path": "httpie/config.py",
        "class_name": "httpie.config.BaseConfigDict",
        "signature": "httpie.config.BaseConfigDict.load(self)",
        "snippet": "    def load(self):\n        try:\n            with open(self.path, 'rt') as f:\n                try:\n                    data = json.load(f)\n                except ValueError as e:\n                    raise ValueError(\n                        'Invalid %s JSON: %s [%s]' %\n                        (type(self).__name__, e.message, self.path)\n                    )\n                self.update(data)\n        except IOError as e:\n            if e.errno != errno.ENOENT:\n                raise",
        "begin_line": 43,
        "end_line": 56,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.017543859649122806,
            "pseudo_dstar_susp": 0.002070393374741201,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.002070393374741201,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "httpie.config.BaseConfigDict.save#58",
        "src_path": "httpie/config.py",
        "class_name": "httpie.config.BaseConfigDict",
        "signature": "httpie.config.BaseConfigDict.save(self)",
        "snippet": "    def save(self):\n        self['__meta__'] = {\n            'httpie': __version__\n        }\n        if self.helpurl:\n            self['__meta__']['help'] = self.helpurl\n\n        if self.about:\n            self['__meta__']['about'] = self.about\n\n        with open(self.path, 'w') as f:\n            json.dump(self, f, indent=4, sort_keys=True, ensure_ascii=True)\n            f.write('\\n')",
        "begin_line": 58,
        "end_line": 70,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001953125,
            "pseudo_dstar_susp": 0.003205128205128205,
            "pseudo_tarantula_susp": 0.0017730496453900709,
            "pseudo_op2_susp": 0.003205128205128205,
            "pseudo_barinel_susp": 0.0017730496453900709
        }
    },
    {
        "name": "httpie.config.Config.__init__#91",
        "src_path": "httpie/config.py",
        "class_name": "httpie.config.Config",
        "signature": "httpie.config.Config.__init__(self, directory=DEFAULT_CONFIG_DIR)",
        "snippet": "    def __init__(self, directory=DEFAULT_CONFIG_DIR):\n        super(Config, self).__init__()\n        self.update(self.DEFAULTS)\n        self.directory = directory",
        "begin_line": 91,
        "end_line": 94,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001953125,
            "pseudo_dstar_susp": 0.003205128205128205,
            "pseudo_tarantula_susp": 0.0017730496453900709,
            "pseudo_op2_susp": 0.003205128205128205,
            "pseudo_barinel_susp": 0.0017730496453900709
        }
    },
    {
        "name": "httpie.config.Config._get_path#96",
        "src_path": "httpie/config.py",
        "class_name": "httpie.config.Config",
        "signature": "httpie.config.Config._get_path(self)",
        "snippet": "    def _get_path(self):\n        return os.path.join(self.directory, self.name + '.json')",
        "begin_line": 96,
        "end_line": 97,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001953125,
            "pseudo_dstar_susp": 0.003205128205128205,
            "pseudo_tarantula_susp": 0.0017730496453900709,
            "pseudo_op2_susp": 0.003205128205128205,
            "pseudo_barinel_susp": 0.0017730496453900709
        }
    },
    {
        "name": "httpie.output.processing.is_valid_mime#10",
        "src_path": "httpie/output/processing.py",
        "class_name": "httpie.output.processing",
        "signature": "httpie.output.processing.is_valid_mime(mime)",
        "snippet": "def is_valid_mime(mime):\n    return mime and MIME_RE.match(mime)",
        "begin_line": 10,
        "end_line": 11,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018867924528301887,
            "pseudo_dstar_susp": 0.0024271844660194173,
            "pseudo_tarantula_susp": 0.0024154589371980675,
            "pseudo_op2_susp": 0.0024271844660194173,
            "pseudo_barinel_susp": 0.0024154589371980675
        }
    },
    {
        "name": "httpie.output.processing.Conversion.get_converter#16",
        "src_path": "httpie/output/processing.py",
        "class_name": "httpie.output.processing.Conversion",
        "signature": "httpie.output.processing.Conversion.get_converter(self, mime)",
        "snippet": "    def get_converter(self, mime):\n        if is_valid_mime(mime):\n            for converter_class in plugin_manager.get_converters():\n                if converter_class.supports(mime):\n                    return converter_class(mime)",
        "begin_line": 16,
        "end_line": 20,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0011695906432748538,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.output.processing.Formatting.__init__#26",
        "src_path": "httpie/output/processing.py",
        "class_name": "httpie.output.processing.Formatting",
        "signature": "httpie.output.processing.Formatting.__init__(self, groups, env=Environment(), **kwargs)",
        "snippet": "    def __init__(self, groups, env=Environment(), **kwargs):\n        \"\"\"\n        :param groups: names of processor groups to be applied\n        :param env: Environment\n        :param kwargs: additional keyword arguments for processors\n\n        \"\"\"\n        available_plugins = plugin_manager.get_formatters_grouped()\n        self.enabled_plugins = []\n        for group in groups:\n            for cls in available_plugins[group]:\n                p = cls(env=env, **kwargs)\n                if p.enabled:\n                    self.enabled_plugins.append(p)",
        "begin_line": 26,
        "end_line": 39,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005714285714285714,
            "pseudo_dstar_susp": 0.01818181818181818,
            "pseudo_tarantula_susp": 0.003861003861003861,
            "pseudo_op2_susp": 0.01818181818181818,
            "pseudo_barinel_susp": 0.003861003861003861
        }
    },
    {
        "name": "httpie.output.processing.Formatting.format_headers#41",
        "src_path": "httpie/output/processing.py",
        "class_name": "httpie.output.processing.Formatting",
        "signature": "httpie.output.processing.Formatting.format_headers(self, headers)",
        "snippet": "    def format_headers(self, headers):\n        for p in self.enabled_plugins:\n            headers = p.format_headers(headers)\n        return headers",
        "begin_line": 41,
        "end_line": 44,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007142857142857143,
            "pseudo_dstar_susp": 0.045454545454545456,
            "pseudo_tarantula_susp": 0.005,
            "pseudo_op2_susp": 0.045454545454545456,
            "pseudo_barinel_susp": 0.005
        }
    },
    {
        "name": "httpie.output.processing.Formatting.format_body#46",
        "src_path": "httpie/output/processing.py",
        "class_name": "httpie.output.processing.Formatting",
        "signature": "httpie.output.processing.Formatting.format_body(self, content, mime)",
        "snippet": "    def format_body(self, content, mime):\n        if is_valid_mime(mime):\n            for p in self.enabled_plugins:\n                content = p.format_body(content, mime)\n        return content",
        "begin_line": 46,
        "end_line": 50,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024154589371980675,
            "pseudo_dstar_susp": 0.0025575447570332483,
            "pseudo_tarantula_susp": 0.0032679738562091504,
            "pseudo_op2_susp": 0.0025575447570332483,
            "pseudo_barinel_susp": 0.0032679738562091504
        }
    },
    {
        "name": "httpie.output.formatters.json.JSONFormatter.format_body#12",
        "src_path": "httpie/output/formatters/json.py",
        "class_name": "httpie.output.formatters.json.JSONFormatter",
        "signature": "httpie.output.formatters.json.JSONFormatter.format_body(self, body, mime)",
        "snippet": "    def format_body(self, body, mime):\n        if 'json' in mime:\n            try:\n                obj = json.loads(body)\n            except ValueError:\n                # Invalid JSON, ignore.\n                pass\n            else:\n                # Indent, sort keys by name, and avoid\n                # unicode escapes to improve readability.\n                body = json.dumps(obj,\n                                  sort_keys=True,\n                                  ensure_ascii=False,\n                                  indent=DEFAULT_INDENT)\n        return body",
        "begin_line": 12,
        "end_line": 26,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024875621890547263,
            "pseudo_dstar_susp": 0.0025906735751295338,
            "pseudo_tarantula_susp": 0.0033222591362126247,
            "pseudo_op2_susp": 0.0025906735751295338,
            "pseudo_barinel_susp": 0.0033222591362126247
        }
    },
    {
        "name": "httpie.downloads.parse_content_range#40",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads",
        "signature": "httpie.downloads.parse_content_range(content_range, resumed_from)",
        "snippet": "def parse_content_range(content_range, resumed_from):\n    \"\"\"\n    Parse and validate Content-Range header.\n\n    <http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html>\n\n    :param content_range: the value of a Content-Range response header\n                          eg. \"bytes 21010-47021/47022\"\n    :param resumed_from: first byte pos. from the Range request header\n    :return: total size of the response body when fully downloaded.\n\n    \"\"\"\n    if content_range is None:\n        raise ContentRangeError('Missing Content-Range')\n\n    pattern = (\n        '^bytes (?P<first_byte_pos>\\d+)-(?P<last_byte_pos>\\d+)'\n        '/(\\*|(?P<instance_length>\\d+))$'\n    )\n    match = re.match(pattern, content_range)\n\n    if not match:\n        raise ContentRangeError(\n            'Invalid Content-Range format %r' % content_range)\n\n    content_range_dict = match.groupdict()\n    first_byte_pos = int(content_range_dict['first_byte_pos'])\n    last_byte_pos = int(content_range_dict['last_byte_pos'])\n    instance_length = (\n        int(content_range_dict['instance_length'])\n        if content_range_dict['instance_length']\n        else None\n    )\n\n    # \"A byte-content-range-spec with a byte-range-resp-spec whose\n    # last- byte-pos value is less than its first-byte-pos value,\n    # or whose instance-length value is less than or equal to its\n    # last-byte-pos value, is invalid. The recipient of an invalid\n    # byte-content-range- spec MUST ignore it and any content\n    # transferred along with it.\"\n    if (first_byte_pos >= last_byte_pos\n            or (instance_length is not None\n                and instance_length <= last_byte_pos)):\n        raise ContentRangeError(\n            'Invalid Content-Range returned: %r' % content_range)\n\n    if (first_byte_pos != resumed_from\n        or (instance_length is not None\n            and last_byte_pos + 1 != instance_length)):\n        # Not what we asked for.\n        raise ContentRangeError(\n            'Unexpected Content-Range returned (%r)'\n            ' for the requested Range (\"bytes=%d-\")'\n            % (content_range, resumed_from)\n        )\n\n    return last_byte_pos + 1",
        "begin_line": 40,
        "end_line": 96,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0014204545454545455,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.downloads.filename_from_content_disposition#99",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads",
        "signature": "httpie.downloads.filename_from_content_disposition(content_disposition)",
        "snippet": "def filename_from_content_disposition(content_disposition):\n    \"\"\"\n    Extract and validate filename from a Content-Disposition header.\n\n    :param content_disposition: Content-Disposition value\n    :return: the filename if present and valid, otherwise `None`\n\n    \"\"\"\n    # attachment; filename=jakubroztocil-httpie-0.4.1-20-g40bd8f6.tar.gz\n\n    msg = Message('Content-Disposition: %s' % content_disposition)\n    filename = msg.get_filename()\n    if filename:\n        # Basic sanitation.\n        filename = os.path.basename(filename).lstrip('.').strip()\n        if filename:\n            return filename",
        "begin_line": 99,
        "end_line": 115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0010050251256281408,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.downloads.filename_from_url#118",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads",
        "signature": "httpie.downloads.filename_from_url(url, content_type)",
        "snippet": "def filename_from_url(url, content_type):\n    fn = urlsplit(url).path.rstrip('/')\n    fn = os.path.basename(fn) if fn else 'index'\n    if '.' not in fn and content_type:\n        content_type = content_type.split(';')[0]\n        if content_type == 'text/plain':\n            # mimetypes returns '.ksh'\n            ext = '.txt'\n        else:\n            ext = mimetypes.guess_extension(content_type)\n\n        if ext == '.htm':  # Python 3\n            ext = '.html'\n\n        if ext:\n            fn += ext\n\n    return fn",
        "begin_line": 118,
        "end_line": 135,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0014204545454545455,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.downloads.get_unique_filename#138",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads",
        "signature": "httpie.downloads.get_unique_filename(fn, exists=os.path.exists)",
        "snippet": "def get_unique_filename(fn, exists=os.path.exists):\n    attempt = 0\n    while True:\n        suffix = '-' + str(attempt) if attempt > 0 else ''\n        if not exists(fn + suffix):\n            return fn + suffix\n        attempt += 1",
        "begin_line": 138,
        "end_line": 144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0014204545454545455,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.downloads.Download.__init__#149",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Download",
        "signature": "httpie.downloads.Download.__init__(self, output_file=None, resume=False, progress_file=sys.stderr)",
        "snippet": "    def __init__(self, output_file=None,\n                 resume=False, progress_file=sys.stderr):\n        \"\"\"\n        :param resume: Should the download resume if partial download\n                       already exists.\n        :type resume: bool\n\n        :param output_file: The file to store response body in. If not\n                            provided, it will be guessed from the response.\n\n        :param progress_file: Where to report download progress.\n\n        \"\"\"\n        self._output_file = output_file\n        self._resume = resume\n        self._resumed_from = 0\n        self.finished = False\n\n        self.status = Status()\n        self._progress_reporter = ProgressReporterThread(\n            status=self.status,\n            output=progress_file\n        )",
        "begin_line": 149,
        "end_line": 171,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0010799136069114472,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.downloads.Download.pre_request#173",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Download",
        "signature": "httpie.downloads.Download.pre_request(self, request_headers)",
        "snippet": "    def pre_request(self, request_headers):\n        \"\"\"Called just before the HTTP request is sent.\n\n        Might alter `request_headers`.\n\n        :type request_headers: dict\n\n        \"\"\"\n        # Disable content encoding so that we can resume, etc.\n        request_headers['Accept-Encoding'] = None\n        if self._resume:\n            bytes_have = os.path.getsize(self._output_file.name)\n            if bytes_have:\n                # Set ``Range`` header to resume the download\n                # TODO: Use \"If-Range: mtime\" to make sure it's fresh?\n                request_headers['Range'] = 'bytes=%d-' % bytes_have\n                self._resumed_from = bytes_have",
        "begin_line": 173,
        "end_line": 189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0014204545454545455,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.downloads.Download.start#191",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Download",
        "signature": "httpie.downloads.Download.start(self, response)",
        "snippet": "    def start(self, response):\n        \"\"\"\n        Initiate and return a stream for `response` body  with progress\n        callback attached. Can be called only once.\n\n        :param response: Initiated response object with headers already fetched\n        :type response: requests.models.Response\n\n        :return: RawStream, output_file\n\n        \"\"\"\n        assert not self.status.time_started\n\n        try:\n            total_size = int(response.headers['Content-Length'])\n        except (KeyError, ValueError, TypeError):\n            total_size = None\n\n        if self._output_file:\n            if self._resume and response.status_code == PARTIAL_CONTENT:\n                total_size = parse_content_range(\n                    response.headers.get('Content-Range'),\n                    self._resumed_from\n                )\n\n            else:\n                self._resumed_from = 0\n                try:\n                    self._output_file.seek(0)\n                    self._output_file.truncate()\n                except IOError:\n                    pass  # stdout\n        else:\n            # TODO: Should the filename be taken from response.history[0].url?\n            # Output file not specified. Pick a name that doesn't exist yet.\n            fn = None\n            if 'Content-Disposition' in response.headers:\n                fn = filename_from_content_disposition(\n                    response.headers['Content-Disposition'])\n            if not fn:\n                fn = filename_from_url(\n                    url=response.url,\n                    content_type=response.headers.get('Content-Type'),\n                )\n            self._output_file = open(get_unique_filename(fn), mode='a+b')\n\n        self.status.started(\n            resumed_from=self._resumed_from,\n            total_size=total_size\n        )\n\n        stream = RawStream(\n            msg=HTTPResponse(response),\n            with_headers=False,\n            with_body=True,\n            on_body_chunk_downloaded=self.chunk_downloaded,\n            chunk_size=1024 * 8\n        )\n\n        self._progress_reporter.output.write(\n            'Downloading %sto \"%s\"\\n' % (\n                (humanize_bytes(total_size) + ' '\n                 if total_size is not None\n                 else ''),\n                self._output_file.name\n            )\n        )\n        self._progress_reporter.start()\n\n        return stream, self._output_file",
        "begin_line": 191,
        "end_line": 260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0014204545454545455,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.downloads.Download.finish#262",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Download",
        "signature": "httpie.downloads.Download.finish(self)",
        "snippet": "    def finish(self):\n        assert not self.finished\n        self.finished = True\n        self.status.finished()",
        "begin_line": 262,
        "end_line": 265,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0010799136069114472,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.downloads.Download.interrupted#271",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Download",
        "signature": "httpie.downloads.Download.interrupted(self)",
        "snippet": "    def interrupted(self):\n        return (\n            self.finished\n            and self.status.total_size\n            and self.status.total_size != self.status.downloaded\n        )",
        "begin_line": 271,
        "end_line": 276,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0011695906432748538,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.downloads.Download.chunk_downloaded#278",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Download",
        "signature": "httpie.downloads.Download.chunk_downloaded(self, chunk)",
        "snippet": "    def chunk_downloaded(self, chunk):\n        \"\"\"\n        A download progress callback.\n\n        :param chunk: A chunk of response body data that has just\n                      been downloaded and written to the output.\n        :type chunk: bytes\n\n        \"\"\"\n        self.status.chunk_downloaded(len(chunk))",
        "begin_line": 278,
        "end_line": 287,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0010799136069114472,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.downloads.Status.__init__#293",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Status",
        "signature": "httpie.downloads.Status.__init__(self)",
        "snippet": "    def __init__(self):\n        self.downloaded = 0\n        self.total_size = None\n        self.resumed_from = 0\n        self.time_started = None\n        self.time_finished = None",
        "begin_line": 293,
        "end_line": 298,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0010799136069114472,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.downloads.Status.started#300",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Status",
        "signature": "httpie.downloads.Status.started(self, resumed_from=0, total_size=None)",
        "snippet": "    def started(self, resumed_from=0, total_size=None):\n        assert self.time_started is None\n        if total_size is not None:\n            self.total_size = total_size\n        self.downloaded = self.resumed_from = resumed_from\n        self.time_started = time()",
        "begin_line": 300,
        "end_line": 305,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0011695906432748538,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.downloads.Status.chunk_downloaded#307",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Status",
        "signature": "httpie.downloads.Status.chunk_downloaded(self, size)",
        "snippet": "    def chunk_downloaded(self, size):\n        assert self.time_finished is None\n        self.downloaded += size",
        "begin_line": 307,
        "end_line": 309,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0010799136069114472,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.downloads.Status.has_finished#312",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Status",
        "signature": "httpie.downloads.Status.has_finished(self)",
        "snippet": "    def has_finished(self):\n        return self.time_finished is not None",
        "begin_line": 312,
        "end_line": 313,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0009718172983479105,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.downloads.Status.finished#315",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.Status",
        "signature": "httpie.downloads.Status.finished(self)",
        "snippet": "    def finished(self):\n        assert self.time_started is not None\n        assert self.time_finished is None\n        self.time_finished = time()",
        "begin_line": 315,
        "end_line": 318,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0010799136069114472,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.downloads.ProgressReporterThread.__init__#328",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.ProgressReporterThread",
        "signature": "httpie.downloads.ProgressReporterThread.__init__(self, status, output, tick=0.1, update_interval=1)",
        "snippet": "    def __init__(self, status, output, tick=.1, update_interval=1):\n        \"\"\"\n\n        :type status: Status\n        :type output: file\n        \"\"\"\n        super(ProgressReporterThread, self).__init__()\n        self.status = status\n        self.output = output\n        self._tick = tick\n        self._update_interval = update_interval\n        self._spinner_pos = 0\n        self._status_line = ''\n        self._prev_bytes = 0\n        self._prev_time = time()\n        self._should_stop = threading.Event()",
        "begin_line": 328,
        "end_line": 343,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0010799136069114472,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.downloads.ProgressReporterThread.run#349",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.ProgressReporterThread",
        "signature": "httpie.downloads.ProgressReporterThread.run(self)",
        "snippet": "    def run(self):\n        while not self._should_stop.is_set():\n            if self.status.has_finished:\n                self.sum_up()\n                break\n\n            self.report_speed()\n            sleep(self._tick)",
        "begin_line": 349,
        "end_line": 356,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0011695906432748538,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.downloads.ProgressReporterThread.report_speed#358",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.ProgressReporterThread",
        "signature": "httpie.downloads.ProgressReporterThread.report_speed(self)",
        "snippet": "    def report_speed(self):\n\n        now = time()\n\n        if now - self._prev_time >= self._update_interval:\n            downloaded = self.status.downloaded\n            try:\n                speed = ((downloaded - self._prev_bytes)\n                         / (now - self._prev_time))\n            except ZeroDivisionError:\n                speed = 0\n\n            if not self.status.total_size:\n                self._status_line = PROGRESS_NO_CONTENT_LENGTH.format(\n                    downloaded=humanize_bytes(downloaded),\n                    speed=humanize_bytes(speed),\n                )\n            else:\n                try:\n                    percentage = downloaded / self.status.total_size * 100\n                except ZeroDivisionError:\n                    percentage = 0\n\n                if not speed:\n                    eta = '-:--:--'\n                else:\n                    s = int((self.status.total_size - downloaded) / speed)\n                    h, s = divmod(s, 60 * 60)\n                    m, s = divmod(s, 60)\n                    eta = '{0}:{1:0>2}:{2:0>2}'.format(h, m, s)\n\n                self._status_line = PROGRESS.format(\n                    percentage=percentage,\n                    downloaded=humanize_bytes(downloaded),\n                    speed=humanize_bytes(speed),\n                    eta=eta,\n                )\n\n            self._prev_time = now\n            self._prev_bytes = downloaded\n\n        self.output.write(\n            CLEAR_LINE\n            + ' '\n            + SPINNER[self._spinner_pos]\n            + ' '\n            + self._status_line\n        )\n        self.output.flush()\n\n        self._spinner_pos = (self._spinner_pos + 1\n                             if self._spinner_pos + 1 != len(SPINNER)\n                             else 0)",
        "begin_line": 358,
        "end_line": 410,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0014204545454545455,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.downloads.ProgressReporterThread.sum_up#412",
        "src_path": "httpie/downloads.py",
        "class_name": "httpie.downloads.ProgressReporterThread",
        "signature": "httpie.downloads.ProgressReporterThread.sum_up(self)",
        "snippet": "    def sum_up(self):\n        actually_downloaded = (self.status.downloaded\n                               - self.status.resumed_from)\n        time_taken = self.status.time_finished - self.status.time_started\n\n        self.output.write(CLEAR_LINE)\n\n        try:\n            speed = actually_downloaded / time_taken\n        except ZeroDivisionError:\n            # Either time is 0 (not all systems provide `time.time`\n            # with a better precision than 1 second), and/or nothing\n            # has been downloaded.\n            speed = actually_downloaded\n\n        self.output.write(SUMMARY.format(\n            downloaded=humanize_bytes(actually_downloaded),\n            total=(self.status.total_size\n                   and humanize_bytes(self.status.total_size)),\n            speed=humanize_bytes(speed),\n            time=time_taken,\n        ))\n        self.output.flush()",
        "begin_line": 412,
        "end_line": 434,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0012300123001230013,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.context.Environment.__init__#38",
        "src_path": "httpie/context.py",
        "class_name": "httpie.context.Environment",
        "signature": "httpie.context.Environment.__init__(self, **kwargs)",
        "snippet": "    def __init__(self, **kwargs):\n        \"\"\"\n        Use keyword arguments to overwrite\n        any of the class attributes for this instance.\n\n        \"\"\"\n        assert all(hasattr(type(self), attr) for attr in kwargs.keys())\n        self.__dict__.update(**kwargs)\n\n        # Keyword arguments > stream.encoding > default utf8\n        if self.stdin_encoding is None:\n            self.stdin_encoding = getattr(\n                self.stdin, 'encoding', None) or 'utf8'\n        if self.stdout_encoding is None:\n            actual_stdout = self.stdout\n            if is_windows:\n                from colorama import AnsiToWin32\n                if isinstance(self.stdout, AnsiToWin32):\n                    actual_stdout = self.stdout.wrapped\n            self.stdout_encoding = getattr(\n                actual_stdout, 'encoding', None) or 'utf8'",
        "begin_line": 38,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00847457627118644,
            "pseudo_dstar_susp": 0.125,
            "pseudo_tarantula_susp": 0.0016863406408094434,
            "pseudo_op2_susp": 0.125,
            "pseudo_barinel_susp": 0.0016863406408094434
        }
    },
    {
        "name": "httpie.context.Environment.config#61",
        "src_path": "httpie/context.py",
        "class_name": "httpie.context.Environment",
        "signature": "httpie.context.Environment.config(self)",
        "snippet": "    def config(self):\n        if not hasattr(self, '_config'):\n            self._config = Config(directory=self.config_dir)\n            if self._config.is_new():\n                self._config.save()\n            else:\n                self._config.load()\n        return self._config",
        "begin_line": 61,
        "end_line": 68,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008064516129032258,
            "pseudo_dstar_susp": 0.003205128205128205,
            "pseudo_tarantula_susp": 0.011235955056179775,
            "pseudo_op2_susp": 0.003205128205128205,
            "pseudo_barinel_susp": 0.011235955056179775
        }
    },
    {
        "name": "httpie.client.get_response#18",
        "src_path": "httpie/client.py",
        "class_name": "httpie.client",
        "signature": "httpie.client.get_response(args, config_dir)",
        "snippet": "def get_response(args, config_dir):\n    \"\"\"Send the request and return a `request.Response`.\"\"\"\n\n    if not args.session and not args.session_read_only:\n        requests_kwargs = get_requests_kwargs(args)\n        if args.debug:\n            dump_request(requests_kwargs)\n        response = requests.request(**requests_kwargs)\n    else:\n        response = sessions.get_response(\n            args=args,\n            config_dir=config_dir,\n            session_name=args.session or args.session_read_only,\n            read_only=bool(args.session_read_only),\n        )\n\n    return response",
        "begin_line": 18,
        "end_line": 34,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.017543859649122806,
            "pseudo_dstar_susp": 0.007462686567164179,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.007462686567164179,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "httpie.client.encode_headers#42",
        "src_path": "httpie/client.py",
        "class_name": "httpie.client",
        "signature": "httpie.client.encode_headers(headers)",
        "snippet": "def encode_headers(headers):\n    # This allows for unicode headers which is non-standard but practical.\n    # See: https://github.com/jakubroztocil/httpie/issues/212\n    return dict(\n        (name, value.encode('utf8') if isinstance(value, str) else value)\n        for name, value in headers.items()\n    )",
        "begin_line": 42,
        "end_line": 48,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.011235955056179775,
            "pseudo_dstar_susp": 0.2,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.2,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "httpie.client.get_default_headers#51",
        "src_path": "httpie/client.py",
        "class_name": "httpie.client",
        "signature": "httpie.client.get_default_headers(args)",
        "snippet": "def get_default_headers(args):\n    default_headers = {\n        'User-Agent': DEFAULT_UA\n    }\n\n    auto_json = args.data and not args.form\n    # FIXME: Accept is set to JSON with `http url @./file.txt`.\n    if args.json or auto_json:\n        default_headers['Accept'] = 'application/json'\n        if args.json or (auto_json and args.data):\n            default_headers['Content-Type'] = JSON\n\n    elif args.form and not args.files:\n        # If sending files, `requests` will set\n        # the `Content-Type` for us.\n        default_headers['Content-Type'] = FORM\n    return default_headers",
        "begin_line": 51,
        "end_line": 67,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007692307692307693,
            "pseudo_dstar_susp": 0.07142857142857142,
            "pseudo_tarantula_susp": 0.005847953216374269,
            "pseudo_op2_susp": 0.07142857142857142,
            "pseudo_barinel_susp": 0.005917159763313609
        }
    },
    {
        "name": "httpie.client.get_requests_kwargs#70",
        "src_path": "httpie/client.py",
        "class_name": "httpie.client",
        "signature": "httpie.client.get_requests_kwargs(args, base_headers=None)",
        "snippet": "def get_requests_kwargs(args, base_headers=None):\n    \"\"\"\n    Translate our `args` into `requests.request` keyword arguments.\n\n    \"\"\"\n    # Serialize JSON data, if needed.\n    data = args.data\n    auto_json = data and not args.form\n    if args.json or auto_json and isinstance(data, dict):\n        if data:\n            data = json.dumps(data)\n        else:\n            # We need to set data to an empty string to prevent requests\n            # from assigning an empty list to `response.request.data`.\n            data = ''\n\n    # Finalize headers.\n    headers = get_default_headers(args)\n    if base_headers:\n        headers.update(base_headers)\n    headers.update(args.headers)\n    headers = encode_headers(headers)\n\n    credentials = None\n    if args.auth:\n        auth_plugin = plugin_manager.get_auth_plugin(args.auth_type)()\n        credentials = auth_plugin.get_auth(args.auth.key, args.auth.value)\n\n    cert = None\n    if args.cert:\n        cert = args.cert\n        if args.certkey:\n            cert = cert, args.certkey\n\n    kwargs = {\n        'stream': True,\n        'method': args.method.lower(),\n        'url': args.url,\n        'headers': headers,\n        'data': data,\n        'verify': {\n            'yes': True,\n            'no': False\n        }.get(args.verify, args.verify),\n        'cert': cert,\n        'timeout': args.timeout,\n        'auth': credentials,\n        'proxies': dict((p.key, p.value) for p in args.proxy),\n        'files': args.files,\n        'allow_redirects': args.follow,\n        'params': args.params,\n    }\n\n    return kwargs",
        "begin_line": 70,
        "end_line": 123,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.011235955056179775,
            "pseudo_dstar_susp": 0.2,
            "pseudo_tarantula_susp": 0.07142857142857142,
            "pseudo_op2_susp": 0.2,
            "pseudo_barinel_susp": 0.05
        }
    },
    {
        "name": "httpie.plugins.builtin.HTTPBasicAuth.__call__#15",
        "src_path": "httpie/plugins/builtin.py",
        "class_name": "httpie.plugins.builtin.HTTPBasicAuth",
        "signature": "httpie.plugins.builtin.HTTPBasicAuth.__call__(self, r)",
        "snippet": "    def __call__(self, r):\n        \"\"\"\n        Override username/password serialization to allow unicode.\n\n        See https://github.com/jakubroztocil/httpie/issues/212\n\n        \"\"\"\n        r.headers['Authorization'] = type(self).make_header(\n            self.username, self.password).encode('latin1')\n        return r",
        "begin_line": 15,
        "end_line": 24,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010526315789473684,
            "pseudo_dstar_susp": 0.001937984496124031,
            "pseudo_tarantula_susp": 0.01,
            "pseudo_op2_susp": 0.001937984496124031,
            "pseudo_barinel_susp": 0.01
        }
    },
    {
        "name": "httpie.plugins.builtin.HTTPBasicAuth.make_header#27",
        "src_path": "httpie/plugins/builtin.py",
        "class_name": "httpie.plugins.builtin.HTTPBasicAuth",
        "signature": "httpie.plugins.builtin.HTTPBasicAuth.make_header(username, password)",
        "snippet": "    def make_header(username, password):\n        credentials = u'%s:%s' % (username, password)\n        token = b64encode(credentials.encode('utf8')).strip().decode('latin1')\n        return 'Basic %s' % token",
        "begin_line": 27,
        "end_line": 30,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010526315789473684,
            "pseudo_dstar_susp": 0.001937984496124031,
            "pseudo_tarantula_susp": 0.01,
            "pseudo_op2_susp": 0.001937984496124031,
            "pseudo_barinel_susp": 0.01
        }
    },
    {
        "name": "httpie.plugins.builtin.BasicAuthPlugin.get_auth#38",
        "src_path": "httpie/plugins/builtin.py",
        "class_name": "httpie.plugins.builtin.BasicAuthPlugin",
        "signature": "httpie.plugins.builtin.BasicAuthPlugin.get_auth(self, username, password)",
        "snippet": "    def get_auth(self, username, password):\n        return HTTPBasicAuth(username, password)",
        "begin_line": 38,
        "end_line": 39,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.010526315789473684,
            "pseudo_dstar_susp": 0.001937984496124031,
            "pseudo_tarantula_susp": 0.01,
            "pseudo_op2_susp": 0.001937984496124031,
            "pseudo_barinel_susp": 0.01
        }
    },
    {
        "name": "httpie.plugins.builtin.DigestAuthPlugin.get_auth#47",
        "src_path": "httpie/plugins/builtin.py",
        "class_name": "httpie.plugins.builtin.DigestAuthPlugin",
        "signature": "httpie.plugins.builtin.DigestAuthPlugin.get_auth(self, username, password)",
        "snippet": "    def get_auth(self, username, password):\n        return requests.auth.HTTPDigestAuth(username, password)",
        "begin_line": 47,
        "end_line": 48,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0012300123001230013,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.input.Parser.__init__#108",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.Parser",
        "signature": "httpie.input.Parser.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        kwargs['add_help'] = False\n        super(Parser, self).__init__(*args, **kwargs)",
        "begin_line": 108,
        "end_line": 110,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0010050251256281408,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.input.Parser.parse_args#113",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.Parser",
        "signature": "httpie.input.Parser.parse_args(self, env, args=None, namespace=None)",
        "snippet": "    def parse_args(self, env, args=None, namespace=None):\n\n        self.env = env\n        self.args, no_options = super(Parser, self)\\\n            .parse_known_args(args, namespace)\n\n        if self.args.debug:\n            self.args.traceback = True\n\n        # Arguments processing and environment setup.\n        self._apply_no_options(no_options)\n        self._apply_config()\n        self._validate_download_options()\n        self._setup_standard_streams()\n        self._process_output_options()\n        self._process_pretty_options()\n        self._guess_method()\n        self._parse_items()\n        if not self.args.ignore_stdin and not env.stdin_isatty:\n            self._body_from_file(self.env.stdin)\n        if not (self.args.url.startswith((HTTP, HTTPS))):\n            scheme = HTTP\n\n            # See if we're using curl style shorthand for localhost (:3000/foo)\n            shorthand = re.match(r'^:(?!:)(\\d*)(/?.*)$', self.args.url)\n            if shorthand:\n                port = shorthand.group(1)\n                rest = shorthand.group(2)\n                self.args.url = scheme + 'localhost'\n                if port:\n                    self.args.url += ':' + port\n                self.args.url += rest\n            else:\n                self.args.url = scheme + self.args.url\n        self._process_auth()\n\n        return self.args",
        "begin_line": 113,
        "end_line": 149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0026109660574412533,
            "pseudo_dstar_susp": 0.0045871559633027525,
            "pseudo_tarantula_susp": 0.0021598272138228943,
            "pseudo_op2_susp": 0.0045871559633027525,
            "pseudo_barinel_susp": 0.0021598272138228943
        }
    },
    {
        "name": "httpie.input.Parser._print_message#152",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.Parser",
        "signature": "httpie.input.Parser._print_message(self, message, file=None)",
        "snippet": "    def _print_message(self, message, file=None):\n        # Sneak in our stderr/stdout.\n        file = {\n            sys.stdout: self.env.stdout,\n            sys.stderr: self.env.stderr,\n            None: self.env.stderr\n        }.get(file, file)\n        if not hasattr(file, 'buffer') and isinstance(message, str):\n            message = message.encode(self.env.stdout_encoding)\n        super(Parser, self)._print_message(message, file)",
        "begin_line": 152,
        "end_line": 161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0012300123001230013,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.input.Parser._setup_standard_streams#163",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.Parser",
        "signature": "httpie.input.Parser._setup_standard_streams(self)",
        "snippet": "    def _setup_standard_streams(self):\n        \"\"\"\n        Modify `env.stdout` and `env.stdout_isatty` based on args, if needed.\n\n        \"\"\"\n        if not self.env.stdout_isatty and self.args.output_file:\n            self.error('Cannot use --output, -o with redirected output.')\n\n        if self.args.download:\n            # FIXME: Come up with a cleaner solution.\n            if not self.env.stdout_isatty:\n                # Use stdout as the download output file.\n                self.args.output_file = self.env.stdout\n            # With `--download`, we write everything that would normally go to\n            # `stdout` to `stderr` instead. Let's replace the stream so that\n            # we don't have to use many `if`s throughout the codebase.\n            # The response body will be treated separately.\n            self.env.stdout = self.env.stderr\n            self.env.stdout_isatty = self.env.stderr_isatty\n        elif self.args.output_file:\n            # When not `--download`ing, then `--output` simply replaces\n            # `stdout`. The file is opened for appending, which isn't what\n            # we want in this case.\n            self.args.output_file.seek(0)\n            self.args.output_file.truncate()\n            self.env.stdout = self.args.output_file\n            self.env.stdout_isatty = False",
        "begin_line": 163,
        "end_line": 189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002352941176470588,
            "pseudo_dstar_susp": 0.004016064257028112,
            "pseudo_tarantula_susp": 0.002004008016032064,
            "pseudo_op2_susp": 0.004016064257028112,
            "pseudo_barinel_susp": 0.002004008016032064
        }
    },
    {
        "name": "httpie.input.Parser._apply_config#191",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.Parser",
        "signature": "httpie.input.Parser._apply_config(self)",
        "snippet": "    def _apply_config(self):\n        if (not self.args.json\n                and self.env.config.implicit_content_type == 'form'):\n            self.args.form = True",
        "begin_line": 191,
        "end_line": 194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002777777777777778,
            "pseudo_dstar_susp": 0.005128205128205128,
            "pseudo_tarantula_susp": 0.0022727272727272726,
            "pseudo_op2_susp": 0.005128205128205128,
            "pseudo_barinel_susp": 0.0022727272727272726
        }
    },
    {
        "name": "httpie.input.Parser._process_auth#196",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.Parser",
        "signature": "httpie.input.Parser._process_auth(self)",
        "snippet": "    def _process_auth(self):\n        \"\"\"\n        If only a username provided via --auth, then ask for a password.\n        Or, take credentials from the URL, if provided.\n\n        \"\"\"\n        url = urlsplit(self.args.url)\n\n        if self.args.auth:\n            if not self.args.auth.has_password():\n                # Stdin already read (if not a tty) so it's save to prompt.\n                if self.args.ignore_stdin:\n                    self.error('Unable to prompt for passwords because'\n                               ' --ignore-stdin is set.')\n                self.args.auth.prompt_password(url.netloc)\n\n        elif url.username is not None:\n            # Handle http://username:password@hostname/\n            username, password = url.username, url.password\n            self.args.auth = AuthCredentials(\n                key=username,\n                value=password,\n                sep=SEP_CREDENTIALS,\n                orig=SEP_CREDENTIALS.join([username, password])\n            )",
        "begin_line": 196,
        "end_line": 220,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009523809523809525,
            "pseudo_dstar_susp": 0.004219409282700422,
            "pseudo_tarantula_susp": 0.00909090909090909,
            "pseudo_op2_susp": 0.004219409282700422,
            "pseudo_barinel_susp": 0.00909090909090909
        }
    },
    {
        "name": "httpie.input.Parser._apply_no_options#222",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.Parser",
        "signature": "httpie.input.Parser._apply_no_options(self, no_options)",
        "snippet": "    def _apply_no_options(self, no_options):\n        \"\"\"For every `--no-OPTION` in `no_options`, set `args.OPTION` to\n        its default value. This allows for un-setting of options, e.g.,\n        specified in config.\n\n        \"\"\"\n        invalid = []\n\n        for option in no_options:\n            if not option.startswith('--no-'):\n                invalid.append(option)\n                continue\n\n            # --no-option => --option\n            inverted = '--' + option[5:]\n            for action in self._actions:\n                if inverted in action.option_strings:\n                    setattr(self.args, action.dest, action.default)\n                    break\n            else:\n                invalid.append(option)\n\n        if invalid:\n            msg = 'unrecognized arguments: %s'\n            self.error(msg % ' '.join(invalid))",
        "begin_line": 222,
        "end_line": 246,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002183406113537118,
            "pseudo_dstar_susp": 0.0035714285714285713,
            "pseudo_tarantula_susp": 0.0018796992481203006,
            "pseudo_op2_susp": 0.0035714285714285713,
            "pseudo_barinel_susp": 0.0018796992481203006
        }
    },
    {
        "name": "httpie.input.Parser._body_from_file#248",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.Parser",
        "signature": "httpie.input.Parser._body_from_file(self, fd)",
        "snippet": "    def _body_from_file(self, fd):\n        \"\"\"There can only be one source of request data.\n\n        Bytes are always read.\n\n        \"\"\"\n        if self.args.data:\n            self.error('Request body (from stdin or a file) and request '\n                       'data (key=value) cannot be mixed.')\n        self.args.data = getattr(fd, 'buffer', fd).read()",
        "begin_line": 248,
        "end_line": 257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0014204545454545455,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.input.Parser._guess_method#259",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.Parser",
        "signature": "httpie.input.Parser._guess_method(self)",
        "snippet": "    def _guess_method(self):\n        \"\"\"Set `args.method` if not specified to either POST or GET\n        based on whether the request has data or not.\n\n        \"\"\"\n        if self.args.method is None:\n            # Invoked as `http URL'.\n            assert not self.args.items\n            if not self.args.ignore_stdin and not self.env.stdin_isatty:\n                self.args.method = HTTP_POST\n            else:\n                self.args.method = HTTP_GET\n\n        # FIXME: False positive, e.g., \"localhost\" matches but is a valid URL.\n        elif not re.match('^[a-zA-Z]+$', self.args.method):\n            # Invoked as `http URL item+'. The URL is now in `args.method`\n            # and the first ITEM is now incorrectly in `args.url`.\n            try:\n                # Parse the URL as an ITEM and store it as the first ITEM arg.\n                self.args.items.insert(0, KeyValueArgType(\n                    *SEP_GROUP_ALL_ITEMS).__call__(self.args.url))\n\n            except ArgumentTypeError as e:\n                if self.args.traceback:\n                    raise\n                self.error(e.args[0])\n\n            else:\n                # Set the URL correctly\n                self.args.url = self.args.method\n                # Infer the method\n                has_data = (\n                    (not self.args.ignore_stdin and not self.env.stdin_isatty)\n                     or any(item.sep in SEP_GROUP_DATA_ITEMS\n                            for item in self.args.items)\n                )\n                self.args.method = HTTP_POST if has_data else HTTP_GET",
        "begin_line": 259,
        "end_line": 295,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008403361344537815,
            "pseudo_dstar_susp": 0.007462686567164179,
            "pseudo_tarantula_susp": 0.007518796992481203,
            "pseudo_op2_susp": 0.007462686567164179,
            "pseudo_barinel_susp": 0.007518796992481203
        }
    },
    {
        "name": "httpie.input.Parser._parse_items#297",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.Parser",
        "signature": "httpie.input.Parser._parse_items(self)",
        "snippet": "    def _parse_items(self):\n        \"\"\"Parse `args.items` into `args.headers`, `args.data`, `args.params`,\n         and `args.files`.\n\n        \"\"\"\n        self.args.headers = CaseInsensitiveDict()\n        self.args.data = ParamDict() if self.args.form else OrderedDict()\n        self.args.files = OrderedDict()\n        self.args.params = ParamDict()\n\n        try:\n            parse_items(items=self.args.items,\n                        headers=self.args.headers,\n                        data=self.args.data,\n                        files=self.args.files,\n                        params=self.args.params)\n        except ParseError as e:\n            if self.args.traceback:\n                raise\n            self.error(e.args[0])\n\n        if self.args.files and not self.args.form:\n            # `http url @/path/to/file`\n            file_fields = list(self.args.files.keys())\n            if file_fields != ['']:\n                self.error(\n                    'Invalid file fields (perhaps you meant --form?): %s'\n                    % ','.join(file_fields))\n\n            fn, fd = self.args.files['']\n            self.args.files = {}\n\n            self._body_from_file(fd)\n\n            if 'Content-Type' not in self.args.headers:\n                mime, encoding = mimetypes.guess_type(fn, strict=False)\n                if mime:\n                    content_type = mime\n                    if encoding:\n                        content_type = '%s; charset=%s' % (mime, encoding)\n                    self.args.headers['Content-Type'] = content_type",
        "begin_line": 297,
        "end_line": 337,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002403846153846154,
            "pseudo_dstar_susp": 0.004149377593360996,
            "pseudo_tarantula_susp": 0.0020408163265306124,
            "pseudo_op2_susp": 0.004149377593360996,
            "pseudo_barinel_susp": 0.0020408163265306124
        }
    },
    {
        "name": "httpie.input.Parser._process_output_options#339",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.Parser",
        "signature": "httpie.input.Parser._process_output_options(self)",
        "snippet": "    def _process_output_options(self):\n        \"\"\"Apply defaults to output options, or validate the provided ones.\n\n        The default output options are stdout-type-sensitive.\n\n        \"\"\"\n        if not self.args.output_options:\n            self.args.output_options = (\n                OUTPUT_OPTIONS_DEFAULT\n                if self.env.stdout_isatty\n                else OUTPUT_OPTIONS_DEFAULT_STDOUT_REDIRECTED\n            )\n\n        unknown_output_options = set(self.args.output_options) - OUTPUT_OPTIONS\n        if unknown_output_options:\n            self.error(\n                'Unknown output options: %s' % ','.join(unknown_output_options)\n            )\n\n        if self.args.download and OUT_RESP_BODY in self.args.output_options:\n            # Response body is always downloaded with --download and it goes\n            # through a different routine, so we remove it.\n            self.args.output_options = str(\n                set(self.args.output_options) - set(OUT_RESP_BODY))",
        "begin_line": 339,
        "end_line": 362,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022624434389140274,
            "pseudo_dstar_susp": 0.0037593984962406013,
            "pseudo_tarantula_susp": 0.0019305019305019305,
            "pseudo_op2_susp": 0.0037593984962406013,
            "pseudo_barinel_susp": 0.0019305019305019305
        }
    },
    {
        "name": "httpie.input.Parser._process_pretty_options#364",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.Parser",
        "signature": "httpie.input.Parser._process_pretty_options(self)",
        "snippet": "    def _process_pretty_options(self):\n        if self.args.prettify == PRETTY_STDOUT_TTY_ONLY:\n            self.args.prettify = PRETTY_MAP[\n                'all' if self.env.stdout_isatty else 'none']\n        elif self.args.prettify and self.env.is_windows:\n            self.error('Only terminal output can be colorized on Windows.')\n        else:\n            # noinspection PyTypeChecker\n            self.args.prettify = PRETTY_MAP[self.args.prettify]",
        "begin_line": 364,
        "end_line": 372,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0033444816053511705,
            "pseudo_dstar_susp": 0.007462686567164179,
            "pseudo_tarantula_susp": 0.002702702702702703,
            "pseudo_op2_susp": 0.007462686567164179,
            "pseudo_barinel_susp": 0.002702702702702703
        }
    },
    {
        "name": "httpie.input.Parser._validate_download_options#374",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.Parser",
        "signature": "httpie.input.Parser._validate_download_options(self)",
        "snippet": "    def _validate_download_options(self):\n        if not self.args.download:\n            if self.args.download_resume:\n                self.error('--continue only works with --download')\n        if self.args.download_resume and not (\n                self.args.download and self.args.output_file):\n            self.error('--continue requires --output to be specified')",
        "begin_line": 374,
        "end_line": 380,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002352941176470588,
            "pseudo_dstar_susp": 0.004016064257028112,
            "pseudo_tarantula_susp": 0.002004008016032064,
            "pseudo_op2_susp": 0.004016064257028112,
            "pseudo_barinel_susp": 0.002004008016032064
        }
    },
    {
        "name": "httpie.input.KeyValue.__init__#390",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.KeyValue",
        "signature": "httpie.input.KeyValue.__init__(self, key, value, sep, orig)",
        "snippet": "    def __init__(self, key, value, sep, orig):\n        self.key = key\n        self.value = value\n        self.sep = sep\n        self.orig = orig",
        "begin_line": 390,
        "end_line": 394,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004081632653061225,
            "pseudo_dstar_susp": 0.0026954177897574125,
            "pseudo_tarantula_susp": 0.0045662100456621,
            "pseudo_op2_susp": 0.0026954177897574125,
            "pseudo_barinel_susp": 0.0045662100456621
        }
    },
    {
        "name": "httpie.input.KeyValue.__eq__#396",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.KeyValue",
        "signature": "httpie.input.KeyValue.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        return self.__dict__ == other.__dict__",
        "begin_line": 396,
        "end_line": 397,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0014204545454545455,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.input.SessionNameValidator.__call__#405",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.SessionNameValidator",
        "signature": "httpie.input.SessionNameValidator.__call__(self, value)",
        "snippet": "    def __call__(self, value):\n        # Session name can be a path or just a name.\n        if (os.path.sep not in value\n                and not VALID_SESSION_NAME_PATTERN.search(value)):\n            raise ArgumentError(None, self.error_message)\n        return value",
        "begin_line": 405,
        "end_line": 410,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.05555555555555555,
            "pseudo_dstar_susp": 0.0022222222222222222,
            "pseudo_tarantula_susp": 0.043478260869565216,
            "pseudo_op2_susp": 0.0022222222222222222,
            "pseudo_barinel_susp": 0.05
        }
    },
    {
        "name": "httpie.input.KeyValueArgType.__init__#423",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.KeyValueArgType",
        "signature": "httpie.input.KeyValueArgType.__init__(self, *separators)",
        "snippet": "    def __init__(self, *separators):\n        self.separators = separators",
        "begin_line": 423,
        "end_line": 424,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018050541516245488,
            "pseudo_dstar_susp": 0.0017241379310344827,
            "pseudo_tarantula_susp": 0.007518796992481203,
            "pseudo_op2_susp": 0.0017241379310344827,
            "pseudo_barinel_susp": 0.007518796992481203
        }
    },
    {
        "name": "httpie.input.KeyValueArgType.__call__#426",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.KeyValueArgType",
        "signature": "httpie.input.KeyValueArgType.__call__(self, string)",
        "snippet": "    def __call__(self, string):\n        \"\"\"Parse `string` and return `self.key_value_class()` instance.\n\n        The best of `self.separators` is determined (first found, longest).\n        Back slash escaped characters aren't considered as separators\n        (or parts thereof). Literal back slash characters have to be escaped\n        as well (r'\\\\').\n\n        \"\"\"\n\n        class Escaped(str):\n            \"\"\"Represents an escaped character.\"\"\"\n\n        def tokenize(s):\n            \"\"\"Tokenize `s`. There are only two token types - strings\n            and escaped characters:\n\n            tokenize(r'foo\\=bar\\\\baz')\n            => ['foo', Escaped('='), 'bar', Escaped('\\\\'), 'baz']\n\n            \"\"\"\n            tokens = ['']\n            esc = False\n            for c in s:\n                if esc:\n                    tokens.extend([Escaped(c), ''])\n                    esc = False\n                else:\n                    if c == '\\\\':\n                        esc = True\n                    else:\n                        tokens[-1] += c\n            return tokens\n\n        tokens = tokenize(string)\n\n        # Sorting by length ensures that the longest one will be\n        # chosen as it will overwrite any shorter ones starting\n        # at the same position in the `found` dictionary.\n        separators = sorted(self.separators, key=len)\n\n        for i, token in enumerate(tokens):\n\n            if isinstance(token, Escaped):\n                continue\n\n            found = {}\n            for sep in separators:\n                pos = token.find(sep)\n                if pos != -1:\n                    found[pos] = sep\n\n            if found:\n                # Starting first, longest separator found.\n                sep = found[min(found.keys())]\n\n                key, value = token.split(sep, 1)\n\n                # Any preceding tokens are part of the key.\n                key = ''.join(tokens[:i]) + key\n\n                # Any following tokens are part of the value.\n                value += ''.join(tokens[i + 1:])\n\n                break\n\n        else:\n            raise ArgumentTypeError(\n                u'\"%s\" is not a valid value' % string)\n\n        return self.key_value_class(\n            key=key, value=value, sep=sep, orig=string)",
        "begin_line": 426,
        "end_line": 497,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004366812227074236,
            "pseudo_dstar_susp": 0.0028169014084507044,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 0.0028169014084507044,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "httpie.input.Escaped.__call__#426",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.Escaped",
        "signature": "httpie.input.Escaped.__call__(self, string)",
        "snippet": "    def __call__(self, string):\n        \"\"\"Parse `string` and return `self.key_value_class()` instance.\n\n        The best of `self.separators` is determined (first found, longest).\n        Back slash escaped characters aren't considered as separators\n        (or parts thereof). Literal back slash characters have to be escaped\n        as well (r'\\\\').\n\n        \"\"\"\n\n        class Escaped(str):\n            \"\"\"Represents an escaped character.\"\"\"\n\n        def tokenize(s):\n            \"\"\"Tokenize `s`. There are only two token types - strings\n            and escaped characters:\n\n            tokenize(r'foo\\=bar\\\\baz')\n            => ['foo', Escaped('='), 'bar', Escaped('\\\\'), 'baz']\n\n            \"\"\"\n            tokens = ['']\n            esc = False\n            for c in s:\n                if esc:\n                    tokens.extend([Escaped(c), ''])\n                    esc = False\n                else:\n                    if c == '\\\\':\n                        esc = True\n                    else:\n                        tokens[-1] += c\n            return tokens\n\n        tokens = tokenize(string)\n\n        # Sorting by length ensures that the longest one will be\n        # chosen as it will overwrite any shorter ones starting\n        # at the same position in the `found` dictionary.\n        separators = sorted(self.separators, key=len)\n\n        for i, token in enumerate(tokens):\n\n            if isinstance(token, Escaped):\n                continue\n\n            found = {}\n            for sep in separators:\n                pos = token.find(sep)\n                if pos != -1:\n                    found[pos] = sep\n\n            if found:\n                # Starting first, longest separator found.\n                sep = found[min(found.keys())]\n\n                key, value = token.split(sep, 1)\n\n                # Any preceding tokens are part of the key.\n                key = ''.join(tokens[:i]) + key\n\n                # Any following tokens are part of the value.\n                value += ''.join(tokens[i + 1:])\n\n                break\n\n        else:\n            raise ArgumentTypeError(\n                u'\"%s\" is not a valid value' % string)\n\n        return self.key_value_class(\n            key=key, value=value, sep=sep, orig=string)",
        "begin_line": 426,
        "end_line": 497,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.011494252873563218,
            "pseudo_dstar_susp": 0.1111111111111111,
            "pseudo_tarantula_susp": 0.0045662100456621,
            "pseudo_op2_susp": 0.1111111111111111,
            "pseudo_barinel_susp": 0.0045662100456621
        }
    },
    {
        "name": "httpie.input.KeyValueArgType.tokenize#439",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.KeyValueArgType",
        "signature": "httpie.input.KeyValueArgType.tokenize(s)",
        "snippet": "        def tokenize(s):\n            \"\"\"Tokenize `s`. There are only two token types - strings\n            and escaped characters:\n\n            tokenize(r'foo\\=bar\\\\baz')\n            => ['foo', Escaped('='), 'bar', Escaped('\\\\'), 'baz']\n\n            \"\"\"\n            tokens = ['']\n            esc = False\n            for c in s:\n                if esc:\n                    tokens.extend([Escaped(c), ''])\n                    esc = False\n                else:\n                    if c == '\\\\':\n                        esc = True\n                    else:\n                        tokens[-1] += c\n            return tokens",
        "begin_line": 439,
        "end_line": 458,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.011494252873563218,
            "pseudo_dstar_susp": 0.1111111111111111,
            "pseudo_tarantula_susp": 0.0045662100456621,
            "pseudo_op2_susp": 0.1111111111111111,
            "pseudo_barinel_susp": 0.0045662100456621
        }
    },
    {
        "name": "httpie.input.AuthCredentials.has_password#507",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.AuthCredentials",
        "signature": "httpie.input.AuthCredentials.has_password(self)",
        "snippet": "    def has_password(self):\n        return self.value is not None",
        "begin_line": 507,
        "end_line": 508,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009523809523809525,
            "pseudo_dstar_susp": 0.0019047619047619048,
            "pseudo_tarantula_susp": 0.00909090909090909,
            "pseudo_op2_susp": 0.0019047619047619048,
            "pseudo_barinel_susp": 0.00909090909090909
        }
    },
    {
        "name": "httpie.input.AuthCredentials.prompt_password#510",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.AuthCredentials",
        "signature": "httpie.input.AuthCredentials.prompt_password(self, host)",
        "snippet": "    def prompt_password(self, host):\n        try:\n            self.value = self._getpass(\n                'http: password for %s@%s: ' % (self.key, host))\n        except (EOFError, KeyboardInterrupt):\n            sys.stderr.write('\\n')\n            sys.exit(0)",
        "begin_line": 510,
        "end_line": 516,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0014204545454545455,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.input.AuthCredentialsArgType.__call__#524",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.AuthCredentialsArgType",
        "signature": "httpie.input.AuthCredentialsArgType.__call__(self, string)",
        "snippet": "    def __call__(self, string):\n        \"\"\"Parse credentials from `string`.\n\n        (\"username\" or \"username:password\").\n\n        \"\"\"\n        try:\n            return super(AuthCredentialsArgType, self).__call__(string)\n        except ArgumentTypeError:\n            # No password provided, will prompt for it later.\n            return self.key_value_class(\n                key=string,\n                value=None,\n                sep=SEP_CREDENTIALS,\n                orig=string\n            )",
        "begin_line": 524,
        "end_line": 539,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009523809523809525,
            "pseudo_dstar_susp": 0.0019047619047619048,
            "pseudo_tarantula_susp": 0.00909090909090909,
            "pseudo_op2_susp": 0.0019047619047619048,
            "pseudo_barinel_susp": 0.00909090909090909
        }
    },
    {
        "name": "httpie.input.ParamDict.__setitem__#546",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input.ParamDict",
        "signature": "httpie.input.ParamDict.__setitem__(self, key, value)",
        "snippet": "    def __setitem__(self, key, value):\n        \"\"\" If `key` is assigned more than once, `self[key]` holds a\n        `list` of all the values.\n\n        This allows having multiple fields with the same name in form\n        data and URL params.\n\n        \"\"\"\n        if key not in self:\n            super(ParamDict, self).__setitem__(key, value)\n        else:\n            if not isinstance(self[key], list):\n                super(ParamDict, self).__setitem__(key, [self[key]])\n            self[key].append(value)",
        "begin_line": 546,
        "end_line": 559,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0012300123001230013,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.input.parse_items#562",
        "src_path": "httpie/input.py",
        "class_name": "httpie.input",
        "signature": "httpie.input.parse_items(items, data=None, headers=None, files=None, params=None)",
        "snippet": "def parse_items(items, data=None, headers=None, files=None, params=None):\n    \"\"\"Parse `KeyValue` `items` into `data`, `headers`, `files`,\n    and `params`.\n\n    \"\"\"\n    if headers is None:\n        headers = CaseInsensitiveDict()\n    if data is None:\n        data = OrderedDict()\n    if files is None:\n        files = OrderedDict()\n    if params is None:\n        params = ParamDict()\n\n    for item in items:\n        value = item.value\n\n        if item.sep == SEP_HEADERS:\n            target = headers\n        elif item.sep == SEP_QUERY:\n            target = params\n        elif item.sep == SEP_FILES:\n            try:\n                with open(os.path.expanduser(value), 'rb') as f:\n                    value = (os.path.basename(value),\n                             BytesIO(f.read()))\n            except IOError as e:\n                raise ParseError('\"%s\": %s' % (item.orig, e))\n            target = files\n\n        elif item.sep in SEP_GROUP_DATA_ITEMS:\n\n            if item.sep in SEP_GROUP_DATA_EMBED_ITEMS:\n                try:\n                    with open(os.path.expanduser(value), 'rb') as f:\n                        value = f.read().decode('utf8')\n                except IOError as e:\n                    raise ParseError('\"%s\": %s' % (item.orig, e))\n                except UnicodeDecodeError:\n                    raise ParseError(\n                        '\"%s\": cannot embed the content of \"%s\",'\n                        ' not a UTF8 or ASCII-encoded text file'\n                        % (item.orig, item.value)\n                    )\n\n            if item.sep in SEP_GROUP_RAW_JSON_ITEMS:\n                try:\n                    value = json.loads(value)\n                except ValueError as e:\n                    raise ParseError('\"%s\": %s' % (item.orig, e))\n            target = data\n\n        else:\n            raise TypeError(item)\n\n        target[item.key] = value\n\n    return headers, data, files, params",
        "begin_line": 562,
        "end_line": 619,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.09090909090909091,
            "pseudo_dstar_susp": 0.0035714285714285713,
            "pseudo_tarantula_susp": 0.009433962264150943,
            "pseudo_op2_susp": 0.0035714285714285713,
            "pseudo_barinel_susp": 0.009433962264150943
        }
    },
    {
        "name": "httpie.utils.humanize_bytes#4",
        "src_path": "httpie/utils.py",
        "class_name": "httpie.utils",
        "signature": "httpie.utils.humanize_bytes(n, precision=2)",
        "snippet": "def humanize_bytes(n, precision=2):\n    # Author: Doug Latornell\n    # Licence: MIT\n    # URL: http://code.activestate.com/recipes/577081/\n    \"\"\"Return a humanized string representation of a number of bytes.\n\n    Assumes `from __future__ import division`.\n\n    >>> humanize_bytes(1)\n    '1 B'\n    >>> humanize_bytes(1024, precision=1)\n    '1.0 kB'\n    >>> humanize_bytes(1024 * 123, precision=1)\n    '123.0 kB'\n    >>> humanize_bytes(1024 * 12342, precision=1)\n    '12.1 MB'\n    >>> humanize_bytes(1024 * 12342, precision=2)\n    '12.05 MB'\n    >>> humanize_bytes(1024 * 1234, precision=2)\n    '1.21 MB'\n    >>> humanize_bytes(1024 * 1234 * 1111, precision=2)\n    '1.31 GB'\n    >>> humanize_bytes(1024 * 1234 * 1111, precision=1)\n    '1.3 GB'\n\n    \"\"\"\n    abbrevs = [\n        (1 << 50, 'PB'),\n        (1 << 40, 'TB'),\n        (1 << 30, 'GB'),\n        (1 << 20, 'MB'),\n        (1 << 10, 'kB'),\n        (1, 'B')\n    ]\n\n    if n == 1:\n        return '1 B'\n\n    for factor, suffix in abbrevs:\n        if n >= factor:\n            break\n\n    # noinspection PyUnboundLocalVariable\n    return '%.*f %s' % (precision, n / factor, suffix)",
        "begin_line": 4,
        "end_line": 47,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0010050251256281408,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.plugins.manager.PluginManager.__iter__#18",
        "src_path": "httpie/plugins/manager.py",
        "class_name": "httpie.plugins.manager.PluginManager",
        "signature": "httpie.plugins.manager.PluginManager.__iter__(self)",
        "snippet": "    def __iter__(self):\n        return iter(self._plugins)",
        "begin_line": 18,
        "end_line": 19,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005714285714285714,
            "pseudo_dstar_susp": 0.01818181818181818,
            "pseudo_tarantula_susp": 0.003861003861003861,
            "pseudo_op2_susp": 0.01818181818181818,
            "pseudo_barinel_susp": 0.003861003861003861
        }
    },
    {
        "name": "httpie.plugins.manager.PluginManager.load_installed_plugins#25",
        "src_path": "httpie/plugins/manager.py",
        "class_name": "httpie.plugins.manager.PluginManager",
        "signature": "httpie.plugins.manager.PluginManager.load_installed_plugins(self)",
        "snippet": "    def load_installed_plugins(self):\n        for entry_point_name in ENTRY_POINT_NAMES:\n            for entry_point in iter_entry_points(entry_point_name):\n                plugin = entry_point.load()\n                plugin.package_name = entry_point.dist.key\n                self.register(entry_point.load())",
        "begin_line": 25,
        "end_line": 30,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0026109660574412533,
            "pseudo_dstar_susp": 0.0045871559633027525,
            "pseudo_tarantula_susp": 0.0021598272138228943,
            "pseudo_op2_susp": 0.0045871559633027525,
            "pseudo_barinel_susp": 0.0021598272138228943
        }
    },
    {
        "name": "httpie.plugins.manager.PluginManager.get_auth_plugins#33",
        "src_path": "httpie/plugins/manager.py",
        "class_name": "httpie.plugins.manager.PluginManager",
        "signature": "httpie.plugins.manager.PluginManager.get_auth_plugins(self)",
        "snippet": "    def get_auth_plugins(self):\n        return [plugin for plugin in self if issubclass(plugin, AuthPlugin)]",
        "begin_line": 33,
        "end_line": 34,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.1111111111111111,
            "pseudo_dstar_susp": 0.09090909090909091,
            "pseudo_tarantula_susp": 0.00847457627118644,
            "pseudo_op2_susp": 0.09090909090909091,
            "pseudo_barinel_susp": 0.00847457627118644
        }
    },
    {
        "name": "httpie.plugins.manager.PluginManager.get_auth_plugin_mapping#36",
        "src_path": "httpie/plugins/manager.py",
        "class_name": "httpie.plugins.manager.PluginManager",
        "signature": "httpie.plugins.manager.PluginManager.get_auth_plugin_mapping(self)",
        "snippet": "    def get_auth_plugin_mapping(self):\n        return dict((plugin.auth_type, plugin)\n                    for plugin in self.get_auth_plugins())",
        "begin_line": 36,
        "end_line": 38,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.1111111111111111,
            "pseudo_dstar_susp": 0.09090909090909091,
            "pseudo_tarantula_susp": 0.00847457627118644,
            "pseudo_op2_susp": 0.09090909090909091,
            "pseudo_barinel_susp": 0.00847457627118644
        }
    },
    {
        "name": "httpie.plugins.manager.PluginManager.get_auth_plugin#40",
        "src_path": "httpie/plugins/manager.py",
        "class_name": "httpie.plugins.manager.PluginManager",
        "signature": "httpie.plugins.manager.PluginManager.get_auth_plugin(self, auth_type)",
        "snippet": "    def get_auth_plugin(self, auth_type):\n        return self.get_auth_plugin_mapping()[auth_type]",
        "begin_line": 40,
        "end_line": 41,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008695652173913044,
            "pseudo_dstar_susp": 0.0018796992481203006,
            "pseudo_tarantula_susp": 0.00847457627118644,
            "pseudo_op2_susp": 0.0018796992481203006,
            "pseudo_barinel_susp": 0.00847457627118644
        }
    },
    {
        "name": "httpie.plugins.manager.PluginManager.get_formatters#44",
        "src_path": "httpie/plugins/manager.py",
        "class_name": "httpie.plugins.manager.PluginManager",
        "signature": "httpie.plugins.manager.PluginManager.get_formatters(self)",
        "snippet": "    def get_formatters(self):\n        return [plugin for plugin in self\n                if issubclass(plugin, FormatterPlugin)]",
        "begin_line": 44,
        "end_line": 46,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03571428571428571,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.003861003861003861,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.003861003861003861
        }
    },
    {
        "name": "httpie.plugins.manager.PluginManager.get_formatters_grouped#48",
        "src_path": "httpie/plugins/manager.py",
        "class_name": "httpie.plugins.manager.PluginManager",
        "signature": "httpie.plugins.manager.PluginManager.get_formatters_grouped(self)",
        "snippet": "    def get_formatters_grouped(self):\n        groups = {}\n        for group_name, group in groupby(\n                self.get_formatters(),\n                key=lambda p: getattr(p, 'group_name', 'format')):\n            groups[group_name] = list(group)\n        return groups",
        "begin_line": 48,
        "end_line": 54,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03571428571428571,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.003861003861003861,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.003861003861003861
        }
    },
    {
        "name": "httpie.plugins.manager.PluginManager.get_converters#56",
        "src_path": "httpie/plugins/manager.py",
        "class_name": "httpie.plugins.manager.PluginManager",
        "signature": "httpie.plugins.manager.PluginManager.get_converters(self)",
        "snippet": "    def get_converters(self):\n        return [plugin for plugin in self\n                if issubclass(plugin, ConverterPlugin)]",
        "begin_line": 56,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0011695906432748538,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.core.get_exit_status#32",
        "src_path": "httpie/core.py",
        "class_name": "httpie.core",
        "signature": "httpie.core.get_exit_status(http_status, follow=False)",
        "snippet": "def get_exit_status(http_status, follow=False):\n    \"\"\"Translate HTTP status code to exit status code.\"\"\"\n    if 300 <= http_status <= 399 and not follow:\n        # Redirect\n        return ExitStatus.ERROR_HTTP_3XX\n    elif 400 <= http_status <= 499:\n        # Client Error\n        return ExitStatus.ERROR_HTTP_4XX\n    elif 500 <= http_status <= 599:\n        # Server Error\n        return ExitStatus.ERROR_HTTP_5XX\n    else:\n        return ExitStatus.OK",
        "begin_line": 32,
        "end_line": 44,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007518796992481203,
            "pseudo_dstar_susp": 0.0016474464579901153,
            "pseudo_tarantula_susp": 0.1111111111111111,
            "pseudo_op2_susp": 0.0016474464579901153,
            "pseudo_barinel_susp": 0.16666666666666666
        }
    },
    {
        "name": "httpie.core.print_debug_info#47",
        "src_path": "httpie/core.py",
        "class_name": "httpie.core",
        "signature": "httpie.core.print_debug_info(env)",
        "snippet": "def print_debug_info(env):\n    env.stderr.writelines([\n        'HTTPie %s\\n' % httpie_version,\n        'HTTPie data: %s\\n' % env.config.directory,\n        'Requests %s\\n' % requests_version,\n        'Pygments %s\\n' % pygments_version,\n        'Python %s %s\\n' % (sys.version, sys.platform)\n    ])",
        "begin_line": 47,
        "end_line": 54,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0014204545454545455,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.core.decode_args#57",
        "src_path": "httpie/core.py",
        "class_name": "httpie.core",
        "signature": "httpie.core.decode_args(args, stdin_encoding)",
        "snippet": "def decode_args(args, stdin_encoding):\n    \"\"\"\n    Convert all bytes ags to str\n    by decoding them using stdin encoding.\n\n    \"\"\"\n    return [\n        arg.decode(stdin_encoding)\n        if type(arg) == bytes else arg\n        for arg in args\n    ]",
        "begin_line": 57,
        "end_line": 67,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009900990099009901,
            "pseudo_dstar_susp": 0.14285714285714285,
            "pseudo_tarantula_susp": 0.0021598272138228943,
            "pseudo_op2_susp": 0.14285714285714285,
            "pseudo_barinel_susp": 0.0021598272138228943
        }
    },
    {
        "name": "httpie.core.main#70",
        "src_path": "httpie/core.py",
        "class_name": "httpie.core",
        "signature": "httpie.core.main(args=sys.argv[1:], env=Environment())",
        "snippet": "def main(args=sys.argv[1:], env=Environment()):\n    \"\"\"Run the main program and write the output to ``env.stdout``.\n\n    Return exit status code.\n\n    \"\"\"\n    args = decode_args(args, env.stdin_encoding)\n    plugin_manager.load_installed_plugins()\n\n    from httpie.cli import parser\n\n    if env.config.default_options:\n        args = env.config.default_options + args\n\n    def error(msg, *args, **kwargs):\n        msg = msg % args\n        level = kwargs.get('level', 'error')\n        env.stderr.write('\\nhttp: %s: %s\\n' % (level, msg))\n\n    debug = '--debug' in args\n    traceback = debug or '--traceback' in args\n    exit_status = ExitStatus.OK\n\n    if debug:\n        print_debug_info(env)\n        if args == ['--debug']:\n            return exit_status\n\n    download = None\n\n    try:\n        args = parser.parse_args(args=args, env=env)\n\n        if args.download:\n            args.follow = True  # --download implies --follow.\n            download = Download(\n                output_file=args.output_file,\n                progress_file=env.stderr,\n                resume=args.download_resume\n            )\n            download.pre_request(args.headers)\n\n        response = get_response(args, config_dir=env.config.directory)\n\n        if args.check_status or download:\n\n            exit_status = get_exit_status(\n                http_status=response.status_code,\n                follow=args.follow\n            )\n\n            if not env.stdout_isatty and exit_status != ExitStatus.OK:\n                error('HTTP %s %s',\n                      response.raw.status,\n                      response.raw.reason,\n                      level='warning')\n\n        write_kwargs = {\n            'stream': build_output_stream(\n                args, env, response.request, response),\n\n            # This will in fact be `stderr` with `--download`\n            'outfile': env.stdout,\n\n            'flush': env.stdout_isatty or args.stream\n        }\n\n        try:\n\n            if env.is_windows and is_py3 and 'colors' in args.prettify:\n                write_with_colors_win_py3(**write_kwargs)\n            else:\n                write(**write_kwargs)\n\n            if download and exit_status == ExitStatus.OK:\n                # Response body download.\n                download_stream, download_to = download.start(response)\n                write(\n                    stream=download_stream,\n                    outfile=download_to,\n                    flush=False,\n                )\n                download.finish()\n                if download.interrupted:\n                    exit_status = ExitStatus.ERROR\n                    error('Incomplete download: size=%d; downloaded=%d' % (\n                        download.status.total_size,\n                        download.status.downloaded\n                    ))\n\n        except IOError as e:\n            if not traceback and e.errno == errno.EPIPE:\n                # Ignore broken pipes unless --traceback.\n                env.stderr.write('\\n')\n            else:\n                raise\n    except (KeyboardInterrupt, SystemExit):\n        if traceback:\n            raise\n        env.stderr.write('\\n')\n        exit_status = ExitStatus.ERROR\n\n    except requests.Timeout:\n        exit_status = ExitStatus.ERROR_TIMEOUT\n        error('Request timed out (%ss).', args.timeout)\n\n    except Exception as e:\n        # TODO: Better distinction between expected and unexpected errors.\n        #       Network errors vs. bugs, etc.\n        if traceback:\n            raise\n        error('%s: %s', type(e).__name__, str(e))\n        exit_status = ExitStatus.ERROR\n\n    finally:\n        if download and not download.finished:\n            download.failed()\n\n    return exit_status",
        "begin_line": 70,
        "end_line": 188,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0033444816053511705,
            "pseudo_dstar_susp": 0.007462686567164179,
            "pseudo_tarantula_susp": 0.008064516129032258,
            "pseudo_op2_susp": 0.007462686567164179,
            "pseudo_barinel_susp": 0.008064516129032258
        }
    },
    {
        "name": "httpie.core.error#84",
        "src_path": "httpie/core.py",
        "class_name": "httpie.core",
        "signature": "httpie.core.error(msg, *args, **kwargs)",
        "snippet": "    def error(msg, *args, **kwargs):\n        msg = msg % args\n        level = kwargs.get('level', 'error')\n        env.stderr.write('\\nhttp: %s: %s\\n' % (level, msg))",
        "begin_line": 84,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024390243902439024,
            "pseudo_dstar_susp": 0.004219409282700422,
            "pseudo_tarantula_susp": 0.002066115702479339,
            "pseudo_op2_susp": 0.004219409282700422,
            "pseudo_barinel_susp": 0.002066115702479339
        }
    },
    {
        "name": "httpie.plugins.base.FormatterPlugin.__init__#48",
        "src_path": "httpie/plugins/base.py",
        "class_name": "httpie.plugins.base.FormatterPlugin",
        "signature": "httpie.plugins.base.FormatterPlugin.__init__(self, **kwargs)",
        "snippet": "    def __init__(self, **kwargs):\n        \"\"\"\n        :param env: an class:`Environment` instance\n        :param kwargs: additional keyword argument that some\n                       processor might require.\n\n        \"\"\"\n        self.enabled = True\n        self.kwargs = kwargs",
        "begin_line": 48,
        "end_line": 56,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005714285714285714,
            "pseudo_dstar_susp": 0.01818181818181818,
            "pseudo_tarantula_susp": 0.003861003861003861,
            "pseudo_op2_susp": 0.01818181818181818,
            "pseudo_barinel_susp": 0.003861003861003861
        }
    },
    {
        "name": "httpie.plugins.base.FormatterPlugin.format_headers#58",
        "src_path": "httpie/plugins/base.py",
        "class_name": "httpie.plugins.base.FormatterPlugin",
        "signature": "httpie.plugins.base.FormatterPlugin.format_headers(self, headers)",
        "snippet": "    def format_headers(self, headers):\n        \"\"\"Return processed `headers`\n\n        :param headers: The headers as text.\n\n        \"\"\"\n        return headers",
        "begin_line": 58,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007142857142857143,
            "pseudo_dstar_susp": 0.045454545454545456,
            "pseudo_tarantula_susp": 0.005,
            "pseudo_op2_susp": 0.045454545454545456,
            "pseudo_barinel_susp": 0.005
        }
    },
    {
        "name": "httpie.plugins.base.FormatterPlugin.format_body#66",
        "src_path": "httpie/plugins/base.py",
        "class_name": "httpie.plugins.base.FormatterPlugin",
        "signature": "httpie.plugins.base.FormatterPlugin.format_body(self, content, mime)",
        "snippet": "    def format_body(self, content, mime):\n        \"\"\"Return processed `content`.\n\n        :param mime: E.g., 'application/atom+xml'.\n        :param content: The body content as text\n\n        \"\"\"\n        return content",
        "begin_line": 66,
        "end_line": 73,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024875621890547263,
            "pseudo_dstar_susp": 0.0025906735751295338,
            "pseudo_tarantula_susp": 0.0033222591362126247,
            "pseudo_op2_susp": 0.0025906735751295338,
            "pseudo_barinel_susp": 0.0033222591362126247
        }
    },
    {
        "name": "httpie.output.formatters.colors.ColorFormatter.__init__#31",
        "src_path": "httpie/output/formatters/colors.py",
        "class_name": "httpie.output.formatters.colors.ColorFormatter",
        "signature": "httpie.output.formatters.colors.ColorFormatter.__init__(self, env, color_scheme=DEFAULT_STYLE, **kwargs)",
        "snippet": "    def __init__(self, env, color_scheme=DEFAULT_STYLE, **kwargs):\n        super(ColorFormatter, self).__init__(**kwargs)\n        if not env.colors:\n            self.enabled = False\n            return\n\n        # Cache to speed things up when we process streamed body by line.\n        self.lexer_cache = {}\n\n        try:\n            style_class = pygments.styles.get_style_by_name(color_scheme)\n        except ClassNotFound:\n            style_class = Solarized256Style\n\n        if env.is_windows or env.colors == 256:\n            fmt_class = Terminal256Formatter\n        else:\n            fmt_class = TerminalFormatter\n        self.formatter = fmt_class(style=style_class)",
        "begin_line": 31,
        "end_line": 49,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007633587786259542,
            "pseudo_dstar_susp": 0.06666666666666667,
            "pseudo_tarantula_susp": 0.005813953488372093,
            "pseudo_op2_susp": 0.06666666666666667,
            "pseudo_barinel_susp": 0.005813953488372093
        }
    },
    {
        "name": "httpie.output.formatters.colors.ColorFormatter.format_headers#51",
        "src_path": "httpie/output/formatters/colors.py",
        "class_name": "httpie.output.formatters.colors.ColorFormatter",
        "signature": "httpie.output.formatters.colors.ColorFormatter.format_headers(self, headers)",
        "snippet": "    def format_headers(self, headers):\n        return pygments.highlight(headers, HTTPLexer(), self.formatter).strip()",
        "begin_line": 51,
        "end_line": 52,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0012300123001230013,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.output.formatters.colors.ColorFormatter.format_body#54",
        "src_path": "httpie/output/formatters/colors.py",
        "class_name": "httpie.output.formatters.colors.ColorFormatter",
        "signature": "httpie.output.formatters.colors.ColorFormatter.format_body(self, body, mime)",
        "snippet": "    def format_body(self, body, mime):\n        lexer = self.get_lexer(mime)\n        if lexer:\n            body = pygments.highlight(body, lexer, self.formatter)\n        return body.strip()",
        "begin_line": 54,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0010050251256281408,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.output.formatters.colors.ColorFormatter.get_lexer#60",
        "src_path": "httpie/output/formatters/colors.py",
        "class_name": "httpie.output.formatters.colors.ColorFormatter",
        "signature": "httpie.output.formatters.colors.ColorFormatter.get_lexer(self, mime)",
        "snippet": "    def get_lexer(self, mime):\n        if mime in self.lexer_cache:\n            return self.lexer_cache[mime]\n        self.lexer_cache[mime] = get_lexer(mime)\n        return self.lexer_cache[mime]",
        "begin_line": 60,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0014204545454545455,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.output.formatters.colors.get_lexer#67",
        "src_path": "httpie/output/formatters/colors.py",
        "class_name": "httpie.output.formatters.colors",
        "signature": "httpie.output.formatters.colors.get_lexer(mime)",
        "snippet": "def get_lexer(mime):\n    mime_types, lexer_names = [mime], []\n    type_, subtype = mime.split('/')\n    if '+' not in subtype:\n        lexer_names.append(subtype)\n    else:\n        subtype_name, subtype_suffix = subtype.split('+')\n        lexer_names.extend([subtype_name, subtype_suffix])\n        mime_types.extend([\n            '%s/%s' % (type_, subtype_name),\n            '%s/%s' % (type_, subtype_suffix)\n        ])\n    lexer = None\n    for mime_type in mime_types:\n        try:\n            lexer = pygments.lexers.get_lexer_for_mimetype(mime_type)\n            break\n        except ClassNotFound:\n            pass\n    else:\n        for name in lexer_names:\n            try:\n                lexer = pygments.lexers.get_lexer_by_name(name)\n            except ClassNotFound:\n                pass\n    return lexer",
        "begin_line": 67,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0010799136069114472,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.output.streams.write#27",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams",
        "signature": "httpie.output.streams.write(stream, outfile, flush)",
        "snippet": "def write(stream, outfile, flush):\n    \"\"\"Write the output stream.\"\"\"\n    try:\n        # Writing bytes so we use the buffer interface (Python 3).\n        buf = outfile.buffer\n    except AttributeError:\n        buf = outfile\n\n    for chunk in stream:\n        buf.write(chunk)\n        if flush:\n            outfile.flush()",
        "begin_line": 27,
        "end_line": 38,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0049504950495049506,
            "pseudo_dstar_susp": 0.012195121951219513,
            "pseudo_tarantula_susp": 0.003472222222222222,
            "pseudo_op2_susp": 0.012195121951219513,
            "pseudo_barinel_susp": 0.003472222222222222
        }
    },
    {
        "name": "httpie.output.streams.build_output_stream#58",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams",
        "signature": "httpie.output.streams.build_output_stream(args, env, request, response)",
        "snippet": "def build_output_stream(args, env, request, response):\n    \"\"\"Build and return a chain of iterators over the `request`-`response`\n    exchange each of which yields `bytes` chunks.\n\n    \"\"\"\n    req_h = OUT_REQ_HEAD in args.output_options\n    req_b = OUT_REQ_BODY in args.output_options\n    resp_h = OUT_RESP_HEAD in args.output_options\n    resp_b = OUT_RESP_BODY in args.output_options\n    req = req_h or req_b\n    resp = resp_h or resp_b\n\n    output = []\n    Stream = get_stream_type(env, args)\n\n    if req:\n        output.append(Stream(\n            msg=HTTPRequest(request),\n            with_headers=req_h,\n            with_body=req_b))\n\n    if req_b and resp:\n        # Request/Response separator.\n        output.append([b'\\n\\n'])\n\n    if resp:\n        output.append(Stream(\n            msg=HTTPResponse(response),\n            with_headers=resp_h,\n            with_body=resp_b))\n\n    if env.stdout_isatty and resp_b:\n        # Ensure a blank line after the response body.\n        # For terminal output only.\n        output.append([b'\\n\\n'])\n\n    return chain(*output)",
        "begin_line": 58,
        "end_line": 94,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004830917874396135,
            "pseudo_dstar_susp": 0.011494252873563218,
            "pseudo_tarantula_susp": 0.006493506493506494,
            "pseudo_op2_susp": 0.011494252873563218,
            "pseudo_barinel_susp": 0.006493506493506494
        }
    },
    {
        "name": "httpie.output.streams.get_stream_type#97",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams",
        "signature": "httpie.output.streams.get_stream_type(env, args)",
        "snippet": "def get_stream_type(env, args):\n    \"\"\"Pick the right stream type based on `env` and `args`.\n    Wrap it in a partial with the type-specific args so that\n    we don't need to think what stream we are dealing with.\n\n    \"\"\"\n    if not env.stdout_isatty and not args.prettify:\n        Stream = partial(\n            RawStream,\n            chunk_size=RawStream.CHUNK_SIZE_BY_LINE\n            if args.stream\n            else RawStream.CHUNK_SIZE\n        )\n    elif args.prettify:\n        Stream = partial(\n            PrettyStream if args.stream else BufferedPrettyStream,\n            env=env,\n            conversion=Conversion(),\n            formatting=Formatting(env=env, groups=args.prettify,\n                                  color_scheme=args.style),\n        )\n    else:\n        Stream = partial(EncodedStream, env=env)\n\n    return Stream",
        "begin_line": 97,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005714285714285714,
            "pseudo_dstar_susp": 0.01818181818181818,
            "pseudo_tarantula_susp": 0.003861003861003861,
            "pseudo_op2_susp": 0.01818181818181818,
            "pseudo_barinel_susp": 0.003861003861003861
        }
    },
    {
        "name": "httpie.output.streams.BaseStream.__init__#127",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.BaseStream",
        "signature": "httpie.output.streams.BaseStream.__init__(self, msg, with_headers=True, with_body=True, on_body_chunk_downloaded=None)",
        "snippet": "    def __init__(self, msg, with_headers=True, with_body=True,\n                 on_body_chunk_downloaded=None):\n        \"\"\"\n        :param msg: a :class:`models.HTTPMessage` subclass\n        :param with_headers: if `True`, headers will be included\n        :param with_body: if `True`, body will be included\n\n        \"\"\"\n        assert with_headers or with_body\n        self.msg = msg\n        self.with_headers = with_headers\n        self.with_body = with_body\n        self.on_body_chunk_downloaded = on_body_chunk_downloaded",
        "begin_line": 127,
        "end_line": 139,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028735632183908046,
            "pseudo_dstar_susp": 0.00546448087431694,
            "pseudo_tarantula_susp": 0.002369668246445498,
            "pseudo_op2_susp": 0.00546448087431694,
            "pseudo_barinel_susp": 0.002369668246445498
        }
    },
    {
        "name": "httpie.output.streams.BaseStream.get_headers#141",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.BaseStream",
        "signature": "httpie.output.streams.BaseStream.get_headers(self)",
        "snippet": "    def get_headers(self):\n        \"\"\"Return the headers' bytes.\"\"\"\n        return self.msg.headers.encode('utf8')",
        "begin_line": 141,
        "end_line": 143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.000946969696969697,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.output.streams.BaseStream.__iter__#149",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.BaseStream",
        "signature": "httpie.output.streams.BaseStream.__iter__(self)",
        "snippet": "    def __iter__(self):\n        \"\"\"Return an iterator over `self.msg`.\"\"\"\n        if self.with_headers:\n            yield self.get_headers()\n            yield b'\\r\\n\\r\\n'\n\n        if self.with_body:\n            try:\n                for chunk in self.iter_body():\n                    yield chunk\n                    if self.on_body_chunk_downloaded:\n                        self.on_body_chunk_downloaded(chunk)\n            except BinarySuppressedError as e:\n                if self.with_headers:\n                    yield b'\\n'\n                yield e.message",
        "begin_line": 149,
        "end_line": 164,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005,
            "pseudo_dstar_susp": 0.0125,
            "pseudo_tarantula_susp": 0.0034965034965034965,
            "pseudo_op2_susp": 0.0125,
            "pseudo_barinel_susp": 0.0034965034965034965
        }
    },
    {
        "name": "httpie.output.streams.RawStream.__init__#173",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.RawStream",
        "signature": "httpie.output.streams.RawStream.__init__(self, chunk_size=CHUNK_SIZE, **kwargs)",
        "snippet": "    def __init__(self, chunk_size=CHUNK_SIZE, **kwargs):\n        super(RawStream, self).__init__(**kwargs)\n        self.chunk_size = chunk_size",
        "begin_line": 173,
        "end_line": 175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0009132420091324201,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.output.streams.RawStream.iter_body#177",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.RawStream",
        "signature": "httpie.output.streams.RawStream.iter_body(self)",
        "snippet": "    def iter_body(self):\n        return self.msg.iter_body(self.chunk_size)",
        "begin_line": 177,
        "end_line": 178,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.000946969696969697,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.output.streams.EncodedStream.__init__#191",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.EncodedStream",
        "signature": "httpie.output.streams.EncodedStream.__init__(self, env=Environment(), **kwargs)",
        "snippet": "    def __init__(self, env=Environment(), **kwargs):\n\n        super(EncodedStream, self).__init__(**kwargs)\n\n        if env.stdout_isatty:\n            # Use the encoding supported by the terminal.\n            output_encoding = env.stdout_encoding\n        else:\n            # Preserve the message encoding.\n            output_encoding = self.msg.encoding\n\n        # Default to utf8 when unsure.\n        self.output_encoding = output_encoding or 'utf8'",
        "begin_line": 191,
        "end_line": 203,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005025125628140704,
            "pseudo_dstar_susp": 0.012658227848101266,
            "pseudo_tarantula_susp": 0.0035087719298245615,
            "pseudo_op2_susp": 0.012658227848101266,
            "pseudo_barinel_susp": 0.0035087719298245615
        }
    },
    {
        "name": "httpie.output.streams.EncodedStream.iter_body#205",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.EncodedStream",
        "signature": "httpie.output.streams.EncodedStream.iter_body(self)",
        "snippet": "    def iter_body(self):\n\n        for line, lf in self.msg.iter_lines(self.CHUNK_SIZE):\n\n            if b'\\0' in line:\n                raise BinarySuppressedError()\n\n            yield line.decode(self.msg.encoding) \\\n                      .encode(self.output_encoding, 'replace') + lf",
        "begin_line": 205,
        "end_line": 213,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0014204545454545455,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.output.streams.PrettyStream.__init__#227",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.PrettyStream",
        "signature": "httpie.output.streams.PrettyStream.__init__(self, conversion, formatting, **kwargs)",
        "snippet": "    def __init__(self, conversion, formatting, **kwargs):\n        super(PrettyStream, self).__init__(**kwargs)\n        self.formatting = formatting\n        self.conversion = conversion\n        self.mime = self.msg.content_type.split(';')[0]",
        "begin_line": 227,
        "end_line": 231,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005714285714285714,
            "pseudo_dstar_susp": 0.01818181818181818,
            "pseudo_tarantula_susp": 0.003861003861003861,
            "pseudo_op2_susp": 0.01818181818181818,
            "pseudo_barinel_susp": 0.003861003861003861
        }
    },
    {
        "name": "httpie.output.streams.PrettyStream.get_headers#233",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.PrettyStream",
        "signature": "httpie.output.streams.PrettyStream.get_headers(self)",
        "snippet": "    def get_headers(self):\n        return self.formatting.format_headers(\n            self.msg.headers).encode(self.output_encoding)",
        "begin_line": 233,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007142857142857143,
            "pseudo_dstar_susp": 0.045454545454545456,
            "pseudo_tarantula_susp": 0.005,
            "pseudo_op2_susp": 0.045454545454545456,
            "pseudo_barinel_susp": 0.005
        }
    },
    {
        "name": "httpie.output.streams.PrettyStream.iter_body#237",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.PrettyStream",
        "signature": "httpie.output.streams.PrettyStream.iter_body(self)",
        "snippet": "    def iter_body(self):\n        first_chunk = True\n        iter_lines = self.msg.iter_lines(self.CHUNK_SIZE)\n        for line, lf in iter_lines:\n            if b'\\0' in line:\n                if first_chunk:\n                    converter = self.conversion.get_converter(self.mime)\n                    if converter:\n                        body = bytearray()\n                        # noinspection PyAssignmentToLoopOrWithParameter\n                        for line, lf in chain([(line, lf)], iter_lines):\n                            body.extend(line)\n                            body.extend(lf)\n                        self.mime, body = converter.convert(body)\n                        assert isinstance(body, str)\n                        yield self.process_body(body)\n                        return\n                raise BinarySuppressedError()\n            yield self.process_body(line) + lf\n            first_chunk = False",
        "begin_line": 237,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0014204545454545455,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.output.streams.PrettyStream.process_body#258",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.PrettyStream",
        "signature": "httpie.output.streams.PrettyStream.process_body(self, chunk)",
        "snippet": "    def process_body(self, chunk):\n        if not isinstance(chunk, str):\n            # Text when a converter has been used,\n            # otherwise it will always be bytes.\n            chunk = chunk.decode(self.msg.encoding, 'replace')\n        chunk = self.formatting.format_body(content=chunk, mime=self.mime)\n        return chunk.encode(self.output_encoding, 'replace')",
        "begin_line": 258,
        "end_line": 264,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002145922746781116,
            "pseudo_dstar_susp": 0.0025,
            "pseudo_tarantula_susp": 0.0031746031746031746,
            "pseudo_op2_susp": 0.0025,
            "pseudo_barinel_susp": 0.0031746031746031746
        }
    },
    {
        "name": "httpie.output.streams.BufferedPrettyStream.iter_body#277",
        "src_path": "httpie/output/streams.py",
        "class_name": "httpie.output.streams.BufferedPrettyStream",
        "signature": "httpie.output.streams.BufferedPrettyStream.iter_body(self)",
        "snippet": "    def iter_body(self):\n        # Read the whole body before prettifying it,\n        # but bail out immediately if the body is binary.\n        converter = None\n        body = bytearray()\n\n        for chunk in self.msg.iter_body(self.CHUNK_SIZE):\n            if not converter and b'\\0' in chunk:\n                converter = self.conversion.get_converter(self.mime)\n                if not converter:\n                    raise BinarySuppressedError()\n            body.extend(chunk)\n\n        if converter:\n            self.mime, body = converter.convert(body)\n\n        yield self.process_body(body)",
        "begin_line": 277,
        "end_line": 293,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002207505518763797,
            "pseudo_dstar_susp": 0.0025380710659898475,
            "pseudo_tarantula_susp": 0.003236245954692557,
            "pseudo_op2_susp": 0.0025380710659898475,
            "pseudo_barinel_susp": 0.003236245954692557
        }
    },
    {
        "name": "httpie.sessions.get_response#24",
        "src_path": "httpie/sessions.py",
        "class_name": "httpie.sessions",
        "signature": "httpie.sessions.get_response(session_name, config_dir, args, read_only=False)",
        "snippet": "def get_response(session_name, config_dir, args, read_only=False):\n    \"\"\"Like `client.get_response`, but applies permanent\n    aspects of the session to the request.\n\n    \"\"\"\n    from .client import get_requests_kwargs, dump_request\n    if os.path.sep in session_name:\n        path = os.path.expanduser(session_name)\n    else:\n        hostname = (args.headers.get('Host', None)\n                    or urlsplit(args.url).netloc.split('@')[-1])\n        assert re.match('^[a-zA-Z0-9_.:-]+$', hostname)\n\n        # host:port => host_port\n        hostname = hostname.replace(':', '_')\n        path = os.path.join(config_dir,\n                            SESSIONS_DIR_NAME,\n                            hostname,\n                            session_name + '.json')\n\n    session = Session(path)\n    session.load()\n\n    requests_kwargs = get_requests_kwargs(args, base_headers=session.headers)\n    if args.debug:\n        dump_request(requests_kwargs)\n    session.update_headers(requests_kwargs['headers'])\n\n    if args.auth:\n        session.auth = {\n            'type': args.auth_type,\n            'username': args.auth.key,\n            'password': args.auth.value,\n        }\n    elif session.auth:\n        requests_kwargs['auth'] = session.auth\n\n    requests_session = requests.Session()\n    requests_session.cookies = session.cookies\n\n    try:\n        response = requests_session.request(**requests_kwargs)\n    except Exception:\n        raise\n    else:\n        # Existing sessions with `read_only=True` don't get updated.\n        if session.is_new() or not read_only:\n            session.cookies = requests_session.cookies\n            session.save()\n        return response",
        "begin_line": 24,
        "end_line": 73,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.25,
            "pseudo_dstar_susp": 0.0022675736961451248,
            "pseudo_tarantula_susp": 0.25,
            "pseudo_op2_susp": 0.0022675736961451248,
            "pseudo_barinel_susp": 0.16666666666666666
        }
    },
    {
        "name": "httpie.sessions.Session.__init__#80",
        "src_path": "httpie/sessions.py",
        "class_name": "httpie.sessions.Session",
        "signature": "httpie.sessions.Session.__init__(self, path, *args, **kwargs)",
        "snippet": "    def __init__(self, path, *args, **kwargs):\n        super(Session, self).__init__(*args, **kwargs)\n        self._path = path\n        self['headers'] = {}\n        self['cookies'] = {}\n        self['auth'] = {\n            'type': None,\n            'username': None,\n            'password': None\n        }",
        "begin_line": 80,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.017543859649122806,
            "pseudo_dstar_susp": 0.002070393374741201,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.002070393374741201,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "httpie.sessions.Session._get_path#91",
        "src_path": "httpie/sessions.py",
        "class_name": "httpie.sessions.Session",
        "signature": "httpie.sessions.Session._get_path(self)",
        "snippet": "    def _get_path(self):\n        return self._path",
        "begin_line": 91,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.017543859649122806,
            "pseudo_dstar_susp": 0.002070393374741201,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.002070393374741201,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "httpie.sessions.Session.update_headers#94",
        "src_path": "httpie/sessions.py",
        "class_name": "httpie.sessions.Session",
        "signature": "httpie.sessions.Session.update_headers(self, request_headers)",
        "snippet": "    def update_headers(self, request_headers):\n        \"\"\"\n        Update the session headers with the request ones while ignoring\n        certain name prefixes.\n\n        :type request_headers: dict\n\n        \"\"\"\n        for name, value in request_headers.items():\n            value = value.decode('utf8')\n            if name == 'User-Agent' and value.startswith('HTTPie/'):\n                continue\n\n            for prefix in SESSION_IGNORED_HEADER_PREFIXES:\n                if name.lower().startswith(prefix.lower()):\n                    break\n            else:\n                self['headers'][name] = value",
        "begin_line": 94,
        "end_line": 111,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.05555555555555555,
            "pseudo_dstar_susp": 0.0022222222222222222,
            "pseudo_tarantula_susp": 0.043478260869565216,
            "pseudo_op2_susp": 0.0022222222222222222,
            "pseudo_barinel_susp": 0.05
        }
    },
    {
        "name": "httpie.sessions.Session.headers#114",
        "src_path": "httpie/sessions.py",
        "class_name": "httpie.sessions.Session",
        "signature": "httpie.sessions.Session.headers(self)",
        "snippet": "    def headers(self):\n        return self['headers']",
        "begin_line": 114,
        "end_line": 115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.017543859649122806,
            "pseudo_dstar_susp": 0.002070393374741201,
            "pseudo_tarantula_susp": 0.017857142857142856,
            "pseudo_op2_susp": 0.002070393374741201,
            "pseudo_barinel_susp": 0.017857142857142856
        }
    },
    {
        "name": "httpie.sessions.Session.cookies#118",
        "src_path": "httpie/sessions.py",
        "class_name": "httpie.sessions.Session",
        "signature": "httpie.sessions.Session.cookies(self)",
        "snippet": "    def cookies(self):\n        jar = RequestsCookieJar()\n        for name, cookie_dict in self['cookies'].items():\n            jar.set_cookie(create_cookie(\n                name, cookie_dict.pop('value'), **cookie_dict))\n        jar.clear_expired_cookies()\n        return jar",
        "begin_line": 118,
        "end_line": 124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.017543859649122806,
            "pseudo_dstar_susp": 0.002070393374741201,
            "pseudo_tarantula_susp": 0.07142857142857142,
            "pseudo_op2_susp": 0.002070393374741201,
            "pseudo_barinel_susp": 0.05
        }
    },
    {
        "name": "httpie.sessions.Session.cookies#127",
        "src_path": "httpie/sessions.py",
        "class_name": "httpie.sessions.Session",
        "signature": "httpie.sessions.Session.cookies(self, jar)",
        "snippet": "    def cookies(self, jar):\n        \"\"\"\n        :type jar: CookieJar\n        \"\"\"\n        # http://docs.python.org/2/library/cookielib.html#cookie-objects\n        stored_attrs = ['value', 'path', 'secure', 'expires']\n        self['cookies'] = {}\n        for cookie in jar:\n            self['cookies'][cookie.name] = dict(\n                (attname, getattr(cookie, attname))\n                for attname in stored_attrs\n            )",
        "begin_line": 127,
        "end_line": 138,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.125,
            "pseudo_dstar_susp": 0.002352941176470588,
            "pseudo_tarantula_susp": 0.07142857142857142,
            "pseudo_op2_susp": 0.002352941176470588,
            "pseudo_barinel_susp": 0.05
        }
    },
    {
        "name": "httpie.sessions.Session.auth#141",
        "src_path": "httpie/sessions.py",
        "class_name": "httpie.sessions.Session",
        "signature": "httpie.sessions.Session.auth(self)",
        "snippet": "    def auth(self):\n        auth = self.get('auth', None)\n        if not auth or not auth['type']:\n            return\n        auth_plugin = plugin_manager.get_auth_plugin(auth['type'])()\n        return auth_plugin.get_auth(auth['username'], auth['password'])",
        "begin_line": 141,
        "end_line": 146,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.05555555555555555,
            "pseudo_dstar_susp": 0.0017825311942959,
            "pseudo_tarantula_susp": 0.1111111111111111,
            "pseudo_op2_susp": 0.0017825311942959,
            "pseudo_barinel_susp": 0.16666666666666666
        }
    },
    {
        "name": "httpie.sessions.Session.auth#149",
        "src_path": "httpie/sessions.py",
        "class_name": "httpie.sessions.Session",
        "signature": "httpie.sessions.Session.auth(self, auth)",
        "snippet": "    def auth(self, auth):\n        assert set(['type', 'username', 'password']) == set(auth.keys())\n        self['auth'] = auth",
        "begin_line": 149,
        "end_line": 151,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.25,
            "pseudo_dstar_susp": 0.0022675736961451248,
            "pseudo_tarantula_susp": 0.25,
            "pseudo_op2_susp": 0.0022675736961451248,
            "pseudo_barinel_susp": 0.16666666666666666
        }
    },
    {
        "name": "httpie.cli.HTTPieHelpFormatter.__init__#34",
        "src_path": "httpie/cli.py",
        "class_name": "httpie.cli.HTTPieHelpFormatter",
        "signature": "httpie.cli.HTTPieHelpFormatter.__init__(self, max_help_position=6, *args, **kwargs)",
        "snippet": "    def __init__(self, max_help_position=6, *args, **kwargs):\n        # A smaller indent for args help.\n        kwargs['max_help_position'] = max_help_position\n        super(HTTPieHelpFormatter, self).__init__(*args, **kwargs)",
        "begin_line": 34,
        "end_line": 37,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.000946969696969697,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.cli.HTTPieHelpFormatter._split_lines#39",
        "src_path": "httpie/cli.py",
        "class_name": "httpie.cli.HTTPieHelpFormatter",
        "signature": "httpie.cli.HTTPieHelpFormatter._split_lines(self, text, width)",
        "snippet": "    def _split_lines(self, text, width):\n        text = dedent(text).strip() + '\\n\\n'\n        return text.splitlines()",
        "begin_line": 39,
        "end_line": 41,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0014204545454545455,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.models.HTTPMessage.__init__#7",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPMessage",
        "signature": "httpie.models.HTTPMessage.__init__(self, orig)",
        "snippet": "    def __init__(self, orig):\n        self._orig = orig",
        "begin_line": 7,
        "end_line": 8,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028735632183908046,
            "pseudo_dstar_susp": 0.00546448087431694,
            "pseudo_tarantula_susp": 0.002369668246445498,
            "pseudo_op2_susp": 0.00546448087431694,
            "pseudo_barinel_susp": 0.002369668246445498
        }
    },
    {
        "name": "httpie.models.HTTPMessage.content_type#34",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPMessage",
        "signature": "httpie.models.HTTPMessage.content_type(self)",
        "snippet": "    def content_type(self):\n        \"\"\"Return the message content type.\"\"\"\n        ct = self._orig.headers.get('Content-Type', '')\n        if not isinstance(ct, str):\n            ct = ct.decode('utf8')\n        return ct",
        "begin_line": 34,
        "end_line": 39,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005714285714285714,
            "pseudo_dstar_susp": 0.01818181818181818,
            "pseudo_tarantula_susp": 0.003861003861003861,
            "pseudo_op2_susp": 0.01818181818181818,
            "pseudo_barinel_susp": 0.003861003861003861
        }
    },
    {
        "name": "httpie.models.HTTPResponse.iter_body#45",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPResponse",
        "signature": "httpie.models.HTTPResponse.iter_body(self, chunk_size=1)",
        "snippet": "    def iter_body(self, chunk_size=1):\n        return self._orig.iter_content(chunk_size=chunk_size)",
        "begin_line": 45,
        "end_line": 46,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002053388090349076,
            "pseudo_dstar_susp": 0.0024509803921568627,
            "pseudo_tarantula_susp": 0.0030959752321981426,
            "pseudo_op2_susp": 0.0024509803921568627,
            "pseudo_barinel_susp": 0.0030959752321981426
        }
    },
    {
        "name": "httpie.models.HTTPResponse.iter_lines#48",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPResponse",
        "signature": "httpie.models.HTTPResponse.iter_lines(self, chunk_size)",
        "snippet": "    def iter_lines(self, chunk_size):\n        return ((line, b'\\n') for line in self._orig.iter_lines(chunk_size))",
        "begin_line": 48,
        "end_line": 49,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0010799136069114472,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.models.HTTPResponse.headers#53",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPResponse",
        "signature": "httpie.models.HTTPResponse.headers(self)",
        "snippet": "    def headers(self):\n        original = self._orig.raw._original_response\n        version = {9: '0.9', 10: '1.0', 11: '1.1'}[original.version]\n        status_line = 'HTTP/{version} {status} {reason}'.format(\n            version=version,\n            status=original.status,\n            reason=original.reason\n        )\n        headers = [status_line]\n        try:\n            # `original.msg` is a `http.client.HTTPMessage` on Python 3\n            # `_headers` is a 2-tuple\n            headers.extend(\n                '%s: %s' % header for header in original.msg._headers)\n        except AttributeError:\n            # and a `httplib.HTTPMessage` on Python 2.x\n            # `headers` is a list of `name: val<CRLF>`.\n            headers.extend(h.strip() for h in original.msg.headers)\n\n        return '\\r\\n'.join(headers)",
        "begin_line": 53,
        "end_line": 72,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03571428571428571,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.003861003861003861,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.003861003861003861
        }
    },
    {
        "name": "httpie.models.HTTPResponse.encoding#75",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPResponse",
        "signature": "httpie.models.HTTPResponse.encoding(self)",
        "snippet": "    def encoding(self):\n        return self._orig.encoding or 'utf8'",
        "begin_line": 75,
        "end_line": 76,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002145922746781116,
            "pseudo_dstar_susp": 0.0025,
            "pseudo_tarantula_susp": 0.0031746031746031746,
            "pseudo_op2_susp": 0.0025,
            "pseudo_barinel_susp": 0.0031746031746031746
        }
    },
    {
        "name": "httpie.models.HTTPRequest.iter_body#88",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPRequest",
        "signature": "httpie.models.HTTPRequest.iter_body(self, chunk_size)",
        "snippet": "    def iter_body(self, chunk_size):\n        yield self.body",
        "begin_line": 88,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001697792869269949,
            "pseudo_dstar_susp": 0.001697792869269949,
            "pseudo_tarantula_susp": 0.006211180124223602,
            "pseudo_op2_susp": 0.001697792869269949,
            "pseudo_barinel_susp": 0.006172839506172839
        }
    },
    {
        "name": "httpie.models.HTTPRequest.iter_lines#91",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPRequest",
        "signature": "httpie.models.HTTPRequest.iter_lines(self, chunk_size)",
        "snippet": "    def iter_lines(self, chunk_size):\n        yield self.body, b''",
        "begin_line": 91,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0011507479861910242,
            "pseudo_dstar_susp": 0.0011507479861910242,
            "pseudo_tarantula_susp": 0.0011507479861910242,
            "pseudo_op2_susp": 0.0011695906432748538,
            "pseudo_barinel_susp": 0.0011507479861910242
        }
    },
    {
        "name": "httpie.models.HTTPRequest.headers#95",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPRequest",
        "signature": "httpie.models.HTTPRequest.headers(self)",
        "snippet": "    def headers(self):\n        url = urlsplit(self._orig.url)\n\n        request_line = '{method} {path}{query} HTTP/1.1'.format(\n            method=self._orig.method,\n            path=url.path or '/',\n            query='?' + url.query if url.query else ''\n        )\n\n        headers = dict(self._orig.headers)\n\n        if 'Host' not in headers:\n            headers['Host'] = url.netloc.split('@')[-1]\n\n        headers = ['%s: %s' % (name, value)\n                   for name, value in headers.items()]\n\n        headers.insert(0, request_line)\n        headers = '\\r\\n'.join(headers).strip()\n\n        if isinstance(headers, bytes):\n            # Python < 3\n            headers = headers.decode('utf8')\n        return headers",
        "begin_line": 95,
        "end_line": 118,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.011627906976744186,
            "pseudo_dstar_susp": 0.07692307692307693,
            "pseudo_tarantula_susp": 0.00684931506849315,
            "pseudo_op2_susp": 0.07692307692307693,
            "pseudo_barinel_susp": 0.00684931506849315
        }
    },
    {
        "name": "httpie.models.HTTPRequest.encoding#121",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPRequest",
        "signature": "httpie.models.HTTPRequest.encoding(self)",
        "snippet": "    def encoding(self):\n        return 'utf8'",
        "begin_line": 121,
        "end_line": 122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017211703958691911,
            "pseudo_dstar_susp": 0.0017035775127768314,
            "pseudo_tarantula_susp": 0.006289308176100629,
            "pseudo_op2_susp": 0.0017035775127768314,
            "pseudo_barinel_susp": 0.006369426751592357
        }
    },
    {
        "name": "httpie.models.HTTPRequest.body#125",
        "src_path": "httpie/models.py",
        "class_name": "httpie.models.HTTPRequest",
        "signature": "httpie.models.HTTPRequest.body(self)",
        "snippet": "    def body(self):\n        body = self._orig.body\n        if isinstance(body, str):\n            # Happens with JSON/form request data parsed from the command line.\n            body = body.encode('utf8')\n        return body or b''",
        "begin_line": 125,
        "end_line": 130,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0016806722689075631,
            "pseudo_dstar_susp": 0.0016891891891891893,
            "pseudo_tarantula_susp": 0.005952380952380952,
            "pseudo_op2_susp": 0.0016891891891891893,
            "pseudo_barinel_susp": 0.005917159763313609
        }
    },
    {
        "name": "httpie.output.formatters.xml.XMLFormatter.format_body#42",
        "src_path": "httpie/output/formatters/xml.py",
        "class_name": "httpie.output.formatters.xml.XMLFormatter",
        "signature": "httpie.output.formatters.xml.XMLFormatter.format_body(self, body, mime)",
        "snippet": "    def format_body(self, body, mime):\n        if 'xml' in mime:\n            # FIXME: orig NS names get forgotten during the conversion, etc.\n            try:\n                root = ElementTree.fromstring(body.encode('utf8'))\n            except ElementTree.ParseError:\n                # Ignore invalid XML errors (skips attempting to pretty print)\n                pass\n            else:\n                indent(root)\n                # Use the original declaration\n                declaration = DECLARATION_RE.match(body)\n                doctype = DOCTYPE_RE.match(body)\n                body = ElementTree.tostring(root, encoding='utf-8')\\\n                                  .decode('utf8')\n                if doctype:\n                    body = '%s\\n%s' % (doctype.group(0), body)\n                if declaration:\n                    body = '%s\\n%s' % (declaration.group(0), body)\n        return body",
        "begin_line": 42,
        "end_line": 61,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024875621890547263,
            "pseudo_dstar_susp": 0.0025906735751295338,
            "pseudo_tarantula_susp": 0.0033222591362126247,
            "pseudo_op2_susp": 0.0025906735751295338,
            "pseudo_barinel_susp": 0.0033222591362126247
        }
    },
    {
        "name": "httpie.output.formatters.headers.HeadersFormatter.format_headers#6",
        "src_path": "httpie/output/formatters/headers.py",
        "class_name": "httpie.output.formatters.headers.HeadersFormatter",
        "signature": "httpie.output.formatters.headers.HeadersFormatter.format_headers(self, headers)",
        "snippet": "    def format_headers(self, headers):\n        \"\"\"\n        Sorts headers by name while retaining relative\n        order of multiple headers with the same name.\n\n        \"\"\"\n        lines = headers.splitlines()\n        headers = sorted(lines[1:], key=lambda h: h.split(':')[0])\n        return '\\r\\n'.join(lines[:1] + headers)",
        "begin_line": 6,
        "end_line": 14,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.038461538461538464,
            "pseudo_dstar_susp": 1.0,
            "pseudo_tarantula_susp": 0.005,
            "pseudo_op2_susp": 1.0,
            "pseudo_barinel_susp": 0.005
        }
    }
]