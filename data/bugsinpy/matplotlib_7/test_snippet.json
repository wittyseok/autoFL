[
    {
        "name": "lib.matplotlib.tests.test_colors.test_create_lookup_table#24",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_create_lookup_table(N, result)",
        "snippet": "def test_create_lookup_table(N, result):\n    data = [(0.0, 1.0, 1.0), (0.5, 0.2, 0.2), (1.0, 0.0, 0.0)]\n    assert_array_almost_equal(mcolors._create_lookup_table(N, data), result)",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_resample#29",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_resample()",
        "snippet": "def test_resample():\n    \"\"\"\n    GitHub issue #6025 pointed to incorrect ListedColormap._resample;\n    here we test the method for LinearSegmentedColormap as well.\n    \"\"\"\n    n = 101\n    colorlist = np.empty((n, 4), float)\n    colorlist[:, 0] = np.linspace(0, 1, n)\n    colorlist[:, 1] = 0.2\n    colorlist[:, 2] = np.linspace(1, 0, n)\n    colorlist[:, 3] = 0.7\n    lsc = mcolors.LinearSegmentedColormap.from_list('lsc', colorlist)\n    lc = mcolors.ListedColormap(colorlist)\n    # Set some bad values for testing too\n    for cmap in [lsc, lc]:\n        cmap.set_under('r')\n        cmap.set_over('g')\n        cmap.set_bad('b')\n    lsc3 = lsc._resample(3)\n    lc3 = lc._resample(3)\n    expected = np.array([[0.0, 0.2, 1.0, 0.7],\n                         [0.5, 0.2, 0.5, 0.7],\n                         [1.0, 0.2, 0.0, 0.7]], float)\n    assert_array_almost_equal(lsc3([0, 0.5, 1]), expected)\n    assert_array_almost_equal(lc3([0, 0.5, 1]), expected)\n    # Test over/under was copied properly\n    assert_array_almost_equal(lsc(np.inf), lsc3(np.inf))\n    assert_array_almost_equal(lsc(-np.inf), lsc3(-np.inf))\n    assert_array_almost_equal(lsc(np.nan), lsc3(np.nan))\n    assert_array_almost_equal(lc(np.inf), lc3(np.inf))\n    assert_array_almost_equal(lc(-np.inf), lc3(-np.inf))\n    assert_array_almost_equal(lc(np.nan), lc3(np.nan))",
        "begin_line": 29,
        "end_line": 60,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_register_cmap#63",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_register_cmap()",
        "snippet": "def test_register_cmap():\n    new_cm = copy.copy(plt.cm.viridis)\n    cm.register_cmap('viridis2', new_cm)\n    assert plt.get_cmap('viridis2') == new_cm\n\n    with pytest.raises(ValueError,\n                       match='Arguments must include a name or a Colormap'):\n        cm.register_cmap()",
        "begin_line": 63,
        "end_line": 70,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_colormap_global_set_warn#73",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_colormap_global_set_warn()",
        "snippet": "def test_colormap_global_set_warn():\n    new_cm = plt.get_cmap('viridis')\n    # Store the old value so we don't override the state later on.\n    orig_cmap = copy.copy(new_cm)\n    with pytest.warns(cbook.MatplotlibDeprecationWarning,\n                      match=\"You are modifying the state of a globally\"):\n        # This should warn now because we've modified the global state\n        new_cm.set_under('k')\n\n    # This shouldn't warn because it is a copy\n    copy.copy(new_cm).set_under('b')\n\n    # Test that registering and then modifying warns\n    plt.register_cmap(name='test_cm', cmap=copy.copy(orig_cmap))\n    new_cm = plt.get_cmap('test_cm')\n    with pytest.warns(cbook.MatplotlibDeprecationWarning,\n                      match=\"You are modifying the state of a globally\"):\n        # This should warn now because we've modified the global state\n        new_cm.set_under('k')\n\n    # Re-register the original\n    plt.register_cmap(cmap=orig_cmap)",
        "begin_line": 73,
        "end_line": 94,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_colormap_dict_deprecate#97",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_colormap_dict_deprecate()",
        "snippet": "def test_colormap_dict_deprecate():\n    # Make sure we warn on get and set access into cmap_d\n    with pytest.warns(cbook.MatplotlibDeprecationWarning,\n                      match=\"The global colormaps dictionary is no longer\"):\n        cm = plt.cm.cmap_d['viridis']\n\n    with pytest.warns(cbook.MatplotlibDeprecationWarning,\n                      match=\"The global colormaps dictionary is no longer\"):\n        plt.cm.cmap_d['test'] = cm",
        "begin_line": 97,
        "end_line": 105,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_colormap_copy#108",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_colormap_copy()",
        "snippet": "def test_colormap_copy():\n    cm = plt.cm.Reds\n    cm_copy = copy.copy(cm)\n    with np.errstate(invalid='ignore'):\n        ret1 = cm_copy([-1, 0, .5, 1, np.nan, np.inf])\n    cm2 = copy.copy(cm_copy)\n    cm2.set_bad('g')\n    with np.errstate(invalid='ignore'):\n        ret2 = cm_copy([-1, 0, .5, 1, np.nan, np.inf])\n    assert_array_equal(ret1, ret2)",
        "begin_line": 108,
        "end_line": 117,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_colormap_endian#120",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_colormap_endian()",
        "snippet": "def test_colormap_endian():\n    \"\"\"\n    GitHub issue #1005: a bug in putmask caused erroneous\n    mapping of 1.0 when input from a non-native-byteorder\n    array.\n    \"\"\"\n    cmap = cm.get_cmap(\"jet\")\n    # Test under, over, and invalid along with values 0 and 1.\n    a = [-0.5, 0, 0.5, 1, 1.5, np.nan]\n    for dt in [\"f2\", \"f4\", \"f8\"]:\n        anative = np.ma.masked_invalid(np.array(a, dtype=dt))\n        aforeign = anative.byteswap().newbyteorder()\n        assert_array_equal(cmap(anative), cmap(aforeign))",
        "begin_line": 120,
        "end_line": 132,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_colormap_invalid#135",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_colormap_invalid()",
        "snippet": "def test_colormap_invalid():\n    \"\"\"\n    GitHub issue #9892: Handling of nan's were getting mapped to under\n    rather than bad. This tests to make sure all invalid values\n    (-inf, nan, inf) are mapped respectively to (under, bad, over).\n    \"\"\"\n    cmap = cm.get_cmap(\"plasma\")\n    x = np.array([-np.inf, -1, 0, np.nan, .7, 2, np.inf])\n\n    expected = np.array([[0.050383, 0.029803, 0.527975, 1.],\n                         [0.050383, 0.029803, 0.527975, 1.],\n                         [0.050383, 0.029803, 0.527975, 1.],\n                         [0.,       0.,       0.,       0.],\n                         [0.949217, 0.517763, 0.295662, 1.],\n                         [0.940015, 0.975158, 0.131326, 1.],\n                         [0.940015, 0.975158, 0.131326, 1.]])\n    assert_array_equal(cmap(x), expected)\n\n    # Test masked representation (-inf, inf) are now masked\n    expected = np.array([[0.,       0.,       0.,       0.],\n                         [0.050383, 0.029803, 0.527975, 1.],\n                         [0.050383, 0.029803, 0.527975, 1.],\n                         [0.,       0.,       0.,       0.],\n                         [0.949217, 0.517763, 0.295662, 1.],\n                         [0.940015, 0.975158, 0.131326, 1.],\n                         [0.,       0.,       0.,       0.]])\n    assert_array_equal(cmap(np.ma.masked_invalid(x)), expected)\n\n    # Test scalar representations\n    assert_array_equal(cmap(-np.inf), cmap(0))\n    assert_array_equal(cmap(np.inf), cmap(1.0))\n    assert_array_equal(cmap(np.nan), np.array([0., 0., 0., 0.]))",
        "begin_line": 135,
        "end_line": 166,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_colormap_return_types#169",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_colormap_return_types()",
        "snippet": "def test_colormap_return_types():\n    \"\"\"\n    Make sure that tuples are returned for scalar input and\n    that the proper shapes are returned for ndarrays.\n    \"\"\"\n    cmap = cm.get_cmap(\"plasma\")\n    # Test return types and shapes\n    # scalar input needs to return a tuple of length 4\n    assert isinstance(cmap(0.5), tuple)\n    assert len(cmap(0.5)) == 4\n\n    # input array returns an ndarray of shape x.shape + (4,)\n    x = np.ones(4)\n    assert cmap(x).shape == x.shape + (4,)\n\n    # multi-dimensional array input\n    x2d = np.zeros((2, 2))\n    assert cmap(x2d).shape == x2d.shape + (4,)",
        "begin_line": 169,
        "end_line": 186,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_BoundaryNorm#189",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_BoundaryNorm()",
        "snippet": "def test_BoundaryNorm():\n    \"\"\"\n    GitHub issue #1258: interpolation was failing with numpy\n    1.7 pre-release.\n    \"\"\"\n\n    boundaries = [0, 1.1, 2.2]\n    vals = [-1, 0, 1, 2, 2.2, 4]\n\n    # Without interpolation\n    expected = [-1, 0, 0, 1, 2, 2]\n    ncolors = len(boundaries) - 1\n    bn = mcolors.BoundaryNorm(boundaries, ncolors)\n    assert_array_equal(bn(vals), expected)\n\n    # ncolors != len(boundaries) - 1 triggers interpolation\n    expected = [-1, 0, 0, 2, 3, 3]\n    ncolors = len(boundaries)\n    bn = mcolors.BoundaryNorm(boundaries, ncolors)\n    assert_array_equal(bn(vals), expected)\n\n    # more boundaries for a third color\n    boundaries = [0, 1, 2, 3]\n    vals = [-1, 0.1, 1.1, 2.2, 4]\n    ncolors = 5\n    expected = [-1, 0, 2, 4, 5]\n    bn = mcolors.BoundaryNorm(boundaries, ncolors)\n    assert_array_equal(bn(vals), expected)\n\n    # a scalar as input should not trigger an error and should return a scalar\n    boundaries = [0, 1, 2]\n    vals = [-1, 0.1, 1.1, 2.2]\n    bn = mcolors.BoundaryNorm(boundaries, 2)\n    expected = [-1, 0, 1, 2]\n    for v, ex in zip(vals, expected):\n        ret = bn(v)\n        assert isinstance(ret, int)\n        assert_array_equal(ret, ex)\n        assert_array_equal(bn([v]), ex)\n\n    # same with interp\n    bn = mcolors.BoundaryNorm(boundaries, 3)\n    expected = [-1, 0, 2, 3]\n    for v, ex in zip(vals, expected):\n        ret = bn(v)\n        assert isinstance(ret, int)\n        assert_array_equal(ret, ex)\n        assert_array_equal(bn([v]), ex)\n\n    # Clipping\n    bn = mcolors.BoundaryNorm(boundaries, 3, clip=True)\n    expected = [0, 0, 2, 2]\n    for v, ex in zip(vals, expected):\n        ret = bn(v)\n        assert isinstance(ret, int)\n        assert_array_equal(ret, ex)\n        assert_array_equal(bn([v]), ex)\n\n    # Masked arrays\n    boundaries = [0, 1.1, 2.2]\n    vals = np.ma.masked_invalid([-1., np.NaN, 0, 1.4, 9])\n\n    # Without interpolation\n    ncolors = len(boundaries) - 1\n    bn = mcolors.BoundaryNorm(boundaries, ncolors)\n    expected = np.ma.masked_array([-1, -99, 0, 1, 2], mask=[0, 1, 0, 0, 0])\n    assert_array_equal(bn(vals), expected)\n\n    # With interpolation\n    bn = mcolors.BoundaryNorm(boundaries, len(boundaries))\n    expected = np.ma.masked_array([-1, -99, 0, 2, 3], mask=[0, 1, 0, 0, 0])\n    assert_array_equal(bn(vals), expected)\n\n    # Non-trivial masked arrays\n    vals = np.ma.masked_invalid([np.Inf, np.NaN])\n    assert np.all(bn(vals).mask)\n    vals = np.ma.masked_invalid([np.Inf])\n    assert np.all(bn(vals).mask)",
        "begin_line": 189,
        "end_line": 266,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_lognorm_invalid#270",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_lognorm_invalid(vmin, vmax)",
        "snippet": "def test_lognorm_invalid(vmin, vmax):\n    # Check that invalid limits in LogNorm error\n    norm = mcolors.LogNorm(vmin=vmin, vmax=vmax)\n    with pytest.raises(ValueError):\n        norm(1)\n    with pytest.raises(ValueError):\n        norm.inverse(1)",
        "begin_line": 270,
        "end_line": 276,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_LogNorm#279",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_LogNorm()",
        "snippet": "def test_LogNorm():\n    \"\"\"\n    LogNorm ignored clip, now it has the same\n    behavior as Normalize, e.g., values > vmax are bigger than 1\n    without clip, with clip they are 1.\n    \"\"\"\n    ln = mcolors.LogNorm(clip=True, vmax=5)\n    assert_array_equal(ln([1, 6]), [0, 1.0])",
        "begin_line": 279,
        "end_line": 286,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_PowerNorm#289",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_PowerNorm()",
        "snippet": "def test_PowerNorm():\n    a = np.array([0, 0.5, 1, 1.5], dtype=float)\n    pnorm = mcolors.PowerNorm(1)\n    norm = mcolors.Normalize()\n    assert_array_almost_equal(norm(a), pnorm(a))\n\n    a = np.array([-0.5, 0, 2, 4, 8], dtype=float)\n    expected = [0, 0, 1/16, 1/4, 1]\n    pnorm = mcolors.PowerNorm(2, vmin=0, vmax=8)\n    assert_array_almost_equal(pnorm(a), expected)\n    assert pnorm(a[0]) == expected[0]\n    assert pnorm(a[2]) == expected[2]\n    assert_array_almost_equal(a[1:], pnorm.inverse(pnorm(a))[1:])\n\n    # Clip = True\n    a = np.array([-0.5, 0, 1, 8, 16], dtype=float)\n    expected = [0, 0, 0, 1, 1]\n    pnorm = mcolors.PowerNorm(2, vmin=2, vmax=8, clip=True)\n    assert_array_almost_equal(pnorm(a), expected)\n    assert pnorm(a[0]) == expected[0]\n    assert pnorm(a[-1]) == expected[-1]\n\n    # Clip = True at call time\n    a = np.array([-0.5, 0, 1, 8, 16], dtype=float)\n    expected = [0, 0, 0, 1, 1]\n    pnorm = mcolors.PowerNorm(2, vmin=2, vmax=8, clip=False)\n    assert_array_almost_equal(pnorm(a, clip=True), expected)\n    assert pnorm(a[0], clip=True) == expected[0]\n    assert pnorm(a[-1], clip=True) == expected[-1]",
        "begin_line": 289,
        "end_line": 317,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_PowerNorm_translation_invariance#320",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_PowerNorm_translation_invariance()",
        "snippet": "def test_PowerNorm_translation_invariance():\n    a = np.array([0, 1/2, 1], dtype=float)\n    expected = [0, 1/8, 1]\n    pnorm = mcolors.PowerNorm(vmin=0, vmax=1, gamma=3)\n    assert_array_almost_equal(pnorm(a), expected)\n    pnorm = mcolors.PowerNorm(vmin=-2, vmax=-1, gamma=3)\n    assert_array_almost_equal(pnorm(a - 2), expected)",
        "begin_line": 320,
        "end_line": 326,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_Normalize#329",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_Normalize()",
        "snippet": "def test_Normalize():\n    norm = mcolors.Normalize()\n    vals = np.arange(-10, 10, 1, dtype=float)\n    _inverse_tester(norm, vals)\n    _scalar_tester(norm, vals)\n    _mask_tester(norm, vals)\n\n    # Handle integer input correctly (don't overflow when computing max-min,\n    # i.e. 127-(-128) here).\n    vals = np.array([-128, 127], dtype=np.int8)\n    norm = mcolors.Normalize(vals.min(), vals.max())\n    assert_array_equal(np.asarray(norm(vals)), [0, 1])\n\n    # Don't lose precision on longdoubles (float128 on Linux):\n    # for array inputs...\n    vals = np.array([1.2345678901, 9.8765432109], dtype=np.longdouble)\n    norm = mcolors.Normalize(vals.min(), vals.max())\n    assert_array_equal(np.asarray(norm(vals)), [0, 1])\n    # and for scalar ones.\n    eps = np.finfo(np.longdouble).resolution\n    norm = plt.Normalize(1, 1 + 100 * eps)\n    # This returns exactly 0.5 when longdouble is extended precision (80-bit),\n    # but only a value close to it when it is quadruple precision (128-bit).\n    assert 0 < norm(1 + 50 * eps) < 1",
        "begin_line": 329,
        "end_line": 352,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_autoscale#355",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_autoscale()",
        "snippet": "def test_TwoSlopeNorm_autoscale():\n    norm = mcolors.TwoSlopeNorm(vcenter=20)\n    norm.autoscale([10, 20, 30, 40])\n    assert norm.vmin == 10.\n    assert norm.vmax == 40.",
        "begin_line": 355,
        "end_line": 359,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_autoscale_None_vmin#362",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_autoscale_None_vmin()",
        "snippet": "def test_TwoSlopeNorm_autoscale_None_vmin():\n    norm = mcolors.TwoSlopeNorm(2, vmin=0, vmax=None)\n    norm.autoscale_None([1, 2, 3, 4, 5])\n    assert norm(5) == 1\n    assert norm.vmax == 5",
        "begin_line": 362,
        "end_line": 366,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_autoscale_None_vmax#369",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_autoscale_None_vmax()",
        "snippet": "def test_TwoSlopeNorm_autoscale_None_vmax():\n    norm = mcolors.TwoSlopeNorm(2, vmin=None, vmax=10)\n    norm.autoscale_None([1, 2, 3, 4, 5])\n    assert norm(1) == 0\n    assert norm.vmin == 1",
        "begin_line": 369,
        "end_line": 373,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_scale#376",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_scale()",
        "snippet": "def test_TwoSlopeNorm_scale():\n    norm = mcolors.TwoSlopeNorm(2)\n    assert norm.scaled() is False\n    norm([1, 2, 3, 4])\n    assert norm.scaled() is True",
        "begin_line": 376,
        "end_line": 380,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_scaleout_center#383",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_scaleout_center()",
        "snippet": "def test_TwoSlopeNorm_scaleout_center():\n    # test the vmin never goes above vcenter\n    norm = mcolors.TwoSlopeNorm(vcenter=0)\n    norm([1, 2, 3, 5])\n    assert norm.vmin == 0\n    assert norm.vmax == 5",
        "begin_line": 383,
        "end_line": 388,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_scaleout_center_max#391",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_scaleout_center_max()",
        "snippet": "def test_TwoSlopeNorm_scaleout_center_max():\n    # test the vmax never goes below vcenter\n    norm = mcolors.TwoSlopeNorm(vcenter=0)\n    norm([-1, -2, -3, -5])\n    assert norm.vmax == 0\n    assert norm.vmin == -5",
        "begin_line": 391,
        "end_line": 396,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_Even#399",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_Even()",
        "snippet": "def test_TwoSlopeNorm_Even():\n    norm = mcolors.TwoSlopeNorm(vmin=-1, vcenter=0, vmax=4)\n    vals = np.array([-1.0, -0.5, 0.0, 1.0, 2.0, 3.0, 4.0])\n    expected = np.array([0.0, 0.25, 0.5, 0.625, 0.75, 0.875, 1.0])\n    assert_array_equal(norm(vals), expected)",
        "begin_line": 399,
        "end_line": 403,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_Odd#406",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_Odd()",
        "snippet": "def test_TwoSlopeNorm_Odd():\n    norm = mcolors.TwoSlopeNorm(vmin=-2, vcenter=0, vmax=5)\n    vals = np.array([-2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0])\n    expected = np.array([0.0, 0.25, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])\n    assert_array_equal(norm(vals), expected)",
        "begin_line": 406,
        "end_line": 410,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_VminEqualsVcenter#413",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_VminEqualsVcenter()",
        "snippet": "def test_TwoSlopeNorm_VminEqualsVcenter():\n    with pytest.raises(ValueError):\n        mcolors.TwoSlopeNorm(vmin=-2, vcenter=-2, vmax=2)",
        "begin_line": 413,
        "end_line": 415,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_VmaxEqualsVcenter#418",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_VmaxEqualsVcenter()",
        "snippet": "def test_TwoSlopeNorm_VmaxEqualsVcenter():\n    with pytest.raises(ValueError):\n        mcolors.TwoSlopeNorm(vmin=-2, vcenter=2, vmax=2)",
        "begin_line": 418,
        "end_line": 420,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_VminGTVcenter#423",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_VminGTVcenter()",
        "snippet": "def test_TwoSlopeNorm_VminGTVcenter():\n    with pytest.raises(ValueError):\n        mcolors.TwoSlopeNorm(vmin=10, vcenter=0, vmax=20)",
        "begin_line": 423,
        "end_line": 425,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_TwoSlopeNorm_VminGTVmax#428",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_TwoSlopeNorm_VminGTVmax()",
        "snippet": "def test_TwoSlopeNorm_TwoSlopeNorm_VminGTVmax():\n    with pytest.raises(ValueError):\n        mcolors.TwoSlopeNorm(vmin=10, vcenter=0, vmax=5)",
        "begin_line": 428,
        "end_line": 430,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_VcenterGTVmax#433",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_VcenterGTVmax()",
        "snippet": "def test_TwoSlopeNorm_VcenterGTVmax():\n    with pytest.raises(ValueError):\n        mcolors.TwoSlopeNorm(vmin=10, vcenter=25, vmax=20)",
        "begin_line": 433,
        "end_line": 435,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_premature_scaling#438",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_TwoSlopeNorm_premature_scaling()",
        "snippet": "def test_TwoSlopeNorm_premature_scaling():\n    norm = mcolors.TwoSlopeNorm(vcenter=2)\n    with pytest.raises(ValueError):\n        norm.inverse(np.array([0.1, 0.5, 0.9]))",
        "begin_line": 438,
        "end_line": 441,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_SymLogNorm#444",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_SymLogNorm()",
        "snippet": "def test_SymLogNorm():\n    \"\"\"\n    Test SymLogNorm behavior\n    \"\"\"\n    norm = mcolors.SymLogNorm(3, vmax=5, linscale=1.2, base=np.e)\n    vals = np.array([-30, -1, 2, 6], dtype=float)\n    normed_vals = norm(vals)\n    expected = [0., 0.53980074, 0.826991, 1.02758204]\n    assert_array_almost_equal(normed_vals, expected)\n    _inverse_tester(norm, vals)\n    _scalar_tester(norm, vals)\n    _mask_tester(norm, vals)\n\n    # Ensure that specifying vmin returns the same result as above\n    norm = mcolors.SymLogNorm(3, vmin=-30, vmax=5, linscale=1.2, base=np.e)\n    normed_vals = norm(vals)\n    assert_array_almost_equal(normed_vals, expected)\n\n    # test something more easily checked.\n    norm = mcolors.SymLogNorm(1, vmin=-np.e**3, vmax=np.e**3, base=np.e)\n    nn = norm([-np.e**3, -np.e**2, -np.e**1, -1,\n              0, 1, np.e**1, np.e**2, np.e**3])\n    xx = np.array([0., 0.109123, 0.218246, 0.32737, 0.5, 0.67263,\n                   0.781754, 0.890877, 1.])\n    assert_array_almost_equal(nn, xx)\n    norm = mcolors.SymLogNorm(1, vmin=-10**3, vmax=10**3, base=10)\n    nn = norm([-10**3, -10**2, -10**1, -1,\n              0, 1, 10**1, 10**2, 10**3])\n    xx = np.array([0., 0.121622, 0.243243, 0.364865, 0.5, 0.635135,\n                   0.756757, 0.878378, 1.])\n    assert_array_almost_equal(nn, xx)",
        "begin_line": 444,
        "end_line": 474,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_SymLogNorm_colorbar#477",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_SymLogNorm_colorbar()",
        "snippet": "def test_SymLogNorm_colorbar():\n    \"\"\"\n    Test un-called SymLogNorm in a colorbar.\n    \"\"\"\n    norm = mcolors.SymLogNorm(0.1, vmin=-1, vmax=1, linscale=1, base=np.e)\n    fig = plt.figure()\n    mcolorbar.ColorbarBase(fig.add_subplot(111), norm=norm)\n    plt.close(fig)",
        "begin_line": 477,
        "end_line": 484,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_SymLogNorm_single_zero#487",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_SymLogNorm_single_zero()",
        "snippet": "def test_SymLogNorm_single_zero():\n    \"\"\"\n    Test SymLogNorm to ensure it is not adding sub-ticks to zero label\n    \"\"\"\n    fig = plt.figure()\n    norm = mcolors.SymLogNorm(1e-5, vmin=-1, vmax=1, base=np.e)\n    cbar = mcolorbar.ColorbarBase(fig.add_subplot(111), norm=norm)\n    ticks = cbar.get_ticks()\n    assert sum(ticks == 0) == 1\n    plt.close(fig)",
        "begin_line": 487,
        "end_line": 496,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors._inverse_tester#499",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors._inverse_tester(norm_instance, vals)",
        "snippet": "def _inverse_tester(norm_instance, vals):\n    \"\"\"\n    Checks if the inverse of the given normalization is working.\n    \"\"\"\n    assert_array_almost_equal(norm_instance.inverse(norm_instance(vals)), vals)",
        "begin_line": 499,
        "end_line": 503,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors._scalar_tester#506",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors._scalar_tester(norm_instance, vals)",
        "snippet": "def _scalar_tester(norm_instance, vals):\n    \"\"\"\n    Checks if scalars and arrays are handled the same way.\n    Tests only for float.\n    \"\"\"\n    scalar_result = [norm_instance(float(v)) for v in vals]\n    assert_array_almost_equal(scalar_result, norm_instance(vals))",
        "begin_line": 506,
        "end_line": 512,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors._mask_tester#515",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors._mask_tester(norm_instance, vals)",
        "snippet": "def _mask_tester(norm_instance, vals):\n    \"\"\"\n    Checks mask handling\n    \"\"\"\n    masked_array = np.ma.array(vals)\n    masked_array[0] = np.ma.masked\n    assert_array_equal(masked_array.mask, norm_instance(masked_array).mask)",
        "begin_line": 515,
        "end_line": 521,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_cmap_and_norm_from_levels_and_colors#525",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_cmap_and_norm_from_levels_and_colors()",
        "snippet": "def test_cmap_and_norm_from_levels_and_colors():\n    data = np.linspace(-2, 4, 49).reshape(7, 7)\n    levels = [-1, 2, 2.5, 3]\n    colors = ['red', 'green', 'blue', 'yellow', 'black']\n    extend = 'both'\n    cmap, norm = mcolors.from_levels_and_colors(levels, colors, extend=extend)\n\n    ax = plt.axes()\n    m = plt.pcolormesh(data, cmap=cmap, norm=norm)\n    plt.colorbar(m)\n\n    # Hide the axes labels (but not the colorbar ones, as they are useful)\n    ax.tick_params(labelleft=False, labelbottom=False)",
        "begin_line": 525,
        "end_line": 537,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_cmap_and_norm_from_levels_and_colors2#540",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_cmap_and_norm_from_levels_and_colors2()",
        "snippet": "def test_cmap_and_norm_from_levels_and_colors2():\n    levels = [-1, 2, 2.5, 3]\n    colors = ['red', (0, 1, 0), 'blue', (0.5, 0.5, 0.5), (0.0, 0.0, 0.0, 1.0)]\n    clr = mcolors.to_rgba_array(colors)\n    bad = (0.1, 0.1, 0.1, 0.1)\n    no_color = (0.0, 0.0, 0.0, 0.0)\n    masked_value = 'masked_value'\n\n    # Define the test values which are of interest.\n    # Note: levels are lev[i] <= v < lev[i+1]\n    tests = [('both', None, {-2: clr[0],\n                             -1: clr[1],\n                             2: clr[2],\n                             2.25: clr[2],\n                             3: clr[4],\n                             3.5: clr[4],\n                             masked_value: bad}),\n\n             ('min', -1, {-2: clr[0],\n                          -1: clr[1],\n                          2: clr[2],\n                          2.25: clr[2],\n                          3: no_color,\n                          3.5: no_color,\n                          masked_value: bad}),\n\n             ('max', -1, {-2: no_color,\n                          -1: clr[0],\n                          2: clr[1],\n                          2.25: clr[1],\n                          3: clr[3],\n                          3.5: clr[3],\n                          masked_value: bad}),\n\n             ('neither', -2, {-2: no_color,\n                              -1: clr[0],\n                              2: clr[1],\n                              2.25: clr[1],\n                              3: no_color,\n                              3.5: no_color,\n                              masked_value: bad}),\n             ]\n\n    for extend, i1, cases in tests:\n        cmap, norm = mcolors.from_levels_and_colors(levels, colors[0:i1],\n                                                    extend=extend)\n        cmap.set_bad(bad)\n        for d_val, expected_color in cases.items():\n            if d_val == masked_value:\n                d_val = np.ma.array([1], mask=True)\n            else:\n                d_val = [d_val]\n            assert_array_equal(expected_color, cmap(norm(d_val))[0],\n                               'Wih extend={0!r} and data '\n                               'value={1!r}'.format(extend, d_val))\n\n    with pytest.raises(ValueError):\n        mcolors.from_levels_and_colors(levels, colors)",
        "begin_line": 540,
        "end_line": 597,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_rgb_hsv_round_trip#600",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_rgb_hsv_round_trip()",
        "snippet": "def test_rgb_hsv_round_trip():\n    for a_shape in [(500, 500, 3), (500, 3), (1, 3), (3,)]:\n        np.random.seed(0)\n        tt = np.random.random(a_shape)\n        assert_array_almost_equal(\n            tt, mcolors.hsv_to_rgb(mcolors.rgb_to_hsv(tt)))\n        assert_array_almost_equal(\n            tt, mcolors.rgb_to_hsv(mcolors.hsv_to_rgb(tt)))",
        "begin_line": 600,
        "end_line": 607,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_autoscale_masked#610",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_autoscale_masked()",
        "snippet": "def test_autoscale_masked():\n    # Test for #2336. Previously fully masked data would trigger a ValueError.\n    data = np.ma.masked_all((12, 20))\n    plt.pcolor(data)\n    plt.draw()",
        "begin_line": 610,
        "end_line": 614,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_light_source_topo_surface#618",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_light_source_topo_surface()",
        "snippet": "def test_light_source_topo_surface():\n    \"\"\"Shades a DEM using different v.e.'s and blend modes.\"\"\"\n    with cbook.get_sample_data('jacksboro_fault_dem.npz') as file, \\\n         np.load(file) as dem:\n        elev = dem['elevation']\n        dx, dy = dem['dx'], dem['dy']\n        # Get the true cellsize in meters for accurate vertical exaggeration\n        # Convert from decimal degrees to meters\n        dx = 111320.0 * dx * np.cos(dem['ymin'])\n        dy = 111320.0 * dy\n\n    ls = mcolors.LightSource(315, 45)\n    cmap = cm.gist_earth\n\n    fig, axs = plt.subplots(nrows=3, ncols=3)\n    for row, mode in zip(axs, ['hsv', 'overlay', 'soft']):\n        for ax, ve in zip(row, [0.1, 1, 10]):\n            rgb = ls.shade(elev, cmap, vert_exag=ve, dx=dx, dy=dy,\n                           blend_mode=mode)\n            ax.imshow(rgb)\n            ax.set(xticks=[], yticks=[])",
        "begin_line": 618,
        "end_line": 638,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_light_source_shading_default#641",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_light_source_shading_default()",
        "snippet": "def test_light_source_shading_default():\n    \"\"\"\n    Array comparison test for the default \"hsv\" blend mode. Ensure the\n    default result doesn't change without warning.\n    \"\"\"\n    y, x = np.mgrid[-1.2:1.2:8j, -1.2:1.2:8j]\n    z = 10 * np.cos(x**2 + y**2)\n\n    cmap = plt.cm.copper\n    ls = mcolors.LightSource(315, 45)\n    rgb = ls.shade(z, cmap)\n\n    # Result stored transposed and rounded for more compact display...\n    expect = np.array(\n        [[[0.00, 0.45, 0.90, 0.90, 0.82, 0.62, 0.28, 0.00],\n          [0.45, 0.94, 0.99, 1.00, 1.00, 0.96, 0.65, 0.17],\n          [0.90, 0.99, 1.00, 1.00, 1.00, 1.00, 0.94, 0.35],\n          [0.90, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 0.49],\n          [0.82, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 0.41],\n          [0.62, 0.96, 1.00, 1.00, 1.00, 1.00, 0.90, 0.07],\n          [0.28, 0.65, 0.94, 1.00, 1.00, 0.90, 0.35, 0.01],\n          [0.00, 0.17, 0.35, 0.49, 0.41, 0.07, 0.01, 0.00]],\n\n         [[0.00, 0.28, 0.59, 0.72, 0.62, 0.40, 0.18, 0.00],\n          [0.28, 0.78, 0.93, 0.92, 0.83, 0.66, 0.39, 0.11],\n          [0.59, 0.93, 0.99, 1.00, 0.92, 0.75, 0.50, 0.21],\n          [0.72, 0.92, 1.00, 0.99, 0.93, 0.76, 0.51, 0.18],\n          [0.62, 0.83, 0.92, 0.93, 0.87, 0.68, 0.42, 0.08],\n          [0.40, 0.66, 0.75, 0.76, 0.68, 0.52, 0.23, 0.02],\n          [0.18, 0.39, 0.50, 0.51, 0.42, 0.23, 0.00, 0.00],\n          [0.00, 0.11, 0.21, 0.18, 0.08, 0.02, 0.00, 0.00]],\n\n         [[0.00, 0.18, 0.38, 0.46, 0.39, 0.26, 0.11, 0.00],\n          [0.18, 0.50, 0.70, 0.75, 0.64, 0.44, 0.25, 0.07],\n          [0.38, 0.70, 0.91, 0.98, 0.81, 0.51, 0.29, 0.13],\n          [0.46, 0.75, 0.98, 0.96, 0.84, 0.48, 0.22, 0.12],\n          [0.39, 0.64, 0.81, 0.84, 0.71, 0.31, 0.11, 0.05],\n          [0.26, 0.44, 0.51, 0.48, 0.31, 0.10, 0.03, 0.01],\n          [0.11, 0.25, 0.29, 0.22, 0.11, 0.03, 0.00, 0.00],\n          [0.00, 0.07, 0.13, 0.12, 0.05, 0.01, 0.00, 0.00]],\n\n         [[1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00]]\n         ]).T\n\n    assert_array_almost_equal(rgb, expect, decimal=2)",
        "begin_line": 641,
        "end_line": 692,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_light_source_shading_empty_mask#695",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_light_source_shading_empty_mask()",
        "snippet": "def test_light_source_shading_empty_mask():\n    y, x = np.mgrid[-1.2:1.2:8j, -1.2:1.2:8j]\n    z0 = 10 * np.cos(x**2 + y**2)\n    z1 = np.ma.array(z0)\n\n    cmap = plt.cm.copper\n    ls = mcolors.LightSource(315, 45)\n    rgb0 = ls.shade(z0, cmap)\n    rgb1 = ls.shade(z1, cmap)\n\n    assert_array_almost_equal(rgb0, rgb1)",
        "begin_line": 695,
        "end_line": 705,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_light_source_masked_shading#711",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_light_source_masked_shading()",
        "snippet": "def test_light_source_masked_shading():\n    \"\"\"\n    Array comparison test for a surface with a masked portion. Ensures that\n    we don't wind up with \"fringes\" of odd colors around masked regions.\n    \"\"\"\n    y, x = np.mgrid[-1.2:1.2:8j, -1.2:1.2:8j]\n    z = 10 * np.cos(x**2 + y**2)\n\n    z = np.ma.masked_greater(z, 9.9)\n\n    cmap = plt.cm.copper\n    ls = mcolors.LightSource(315, 45)\n    rgb = ls.shade(z, cmap)\n\n    # Result stored transposed and rounded for more compact display...\n    expect = np.array(\n        [[[0.00, 0.46, 0.91, 0.91, 0.84, 0.64, 0.29, 0.00],\n          [0.46, 0.96, 1.00, 1.00, 1.00, 0.97, 0.67, 0.18],\n          [0.91, 1.00, 1.00, 1.00, 1.00, 1.00, 0.96, 0.36],\n          [0.91, 1.00, 1.00, 0.00, 0.00, 1.00, 1.00, 0.51],\n          [0.84, 1.00, 1.00, 0.00, 0.00, 1.00, 1.00, 0.44],\n          [0.64, 0.97, 1.00, 1.00, 1.00, 1.00, 0.94, 0.09],\n          [0.29, 0.67, 0.96, 1.00, 1.00, 0.94, 0.38, 0.01],\n          [0.00, 0.18, 0.36, 0.51, 0.44, 0.09, 0.01, 0.00]],\n\n         [[0.00, 0.29, 0.61, 0.75, 0.64, 0.41, 0.18, 0.00],\n          [0.29, 0.81, 0.95, 0.93, 0.85, 0.68, 0.40, 0.11],\n          [0.61, 0.95, 1.00, 0.78, 0.78, 0.77, 0.52, 0.22],\n          [0.75, 0.93, 0.78, 0.00, 0.00, 0.78, 0.54, 0.19],\n          [0.64, 0.85, 0.78, 0.00, 0.00, 0.78, 0.45, 0.08],\n          [0.41, 0.68, 0.77, 0.78, 0.78, 0.55, 0.25, 0.02],\n          [0.18, 0.40, 0.52, 0.54, 0.45, 0.25, 0.00, 0.00],\n          [0.00, 0.11, 0.22, 0.19, 0.08, 0.02, 0.00, 0.00]],\n\n         [[0.00, 0.19, 0.39, 0.48, 0.41, 0.26, 0.12, 0.00],\n          [0.19, 0.52, 0.73, 0.78, 0.66, 0.46, 0.26, 0.07],\n          [0.39, 0.73, 0.95, 0.50, 0.50, 0.53, 0.30, 0.14],\n          [0.48, 0.78, 0.50, 0.00, 0.00, 0.50, 0.23, 0.12],\n          [0.41, 0.66, 0.50, 0.00, 0.00, 0.50, 0.11, 0.05],\n          [0.26, 0.46, 0.53, 0.50, 0.50, 0.11, 0.03, 0.01],\n          [0.12, 0.26, 0.30, 0.23, 0.11, 0.03, 0.00, 0.00],\n          [0.00, 0.07, 0.14, 0.12, 0.05, 0.01, 0.00, 0.00]],\n\n         [[1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 0.00, 0.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 0.00, 0.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00],\n          [1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00]],\n         ]).T\n\n    assert_array_almost_equal(rgb, expect, decimal=2)",
        "begin_line": 711,
        "end_line": 764,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_light_source_hillshading#767",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_light_source_hillshading()",
        "snippet": "def test_light_source_hillshading():\n    \"\"\"\n    Compare the current hillshading method against one that should be\n    mathematically equivalent. Illuminates a cone from a range of angles.\n    \"\"\"\n\n    def alternative_hillshade(azimuth, elev, z):\n        illum = _sph2cart(*_azimuth2math(azimuth, elev))\n        illum = np.array(illum)\n\n        dy, dx = np.gradient(-z)\n        dy = -dy\n        dz = np.ones_like(dy)\n        normals = np.dstack([dx, dy, dz])\n        normals /= np.linalg.norm(normals, axis=2)[..., None]\n\n        intensity = np.tensordot(normals, illum, axes=(2, 0))\n        intensity -= intensity.min()\n        intensity /= intensity.ptp()\n        return intensity\n\n    y, x = np.mgrid[5:0:-1, :5]\n    z = -np.hypot(x - x.mean(), y - y.mean())\n\n    for az, elev in itertools.product(range(0, 390, 30), range(0, 105, 15)):\n        ls = mcolors.LightSource(az, elev)\n        h1 = ls.hillshade(z)\n        h2 = alternative_hillshade(az, elev, z)\n        assert_array_almost_equal(h1, h2)",
        "begin_line": 767,
        "end_line": 795,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.alternative_hillshade#773",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.alternative_hillshade(azimuth, elev, z)",
        "snippet": "    def alternative_hillshade(azimuth, elev, z):\n        illum = _sph2cart(*_azimuth2math(azimuth, elev))\n        illum = np.array(illum)\n\n        dy, dx = np.gradient(-z)\n        dy = -dy\n        dz = np.ones_like(dy)\n        normals = np.dstack([dx, dy, dz])\n        normals /= np.linalg.norm(normals, axis=2)[..., None]\n\n        intensity = np.tensordot(normals, illum, axes=(2, 0))\n        intensity -= intensity.min()\n        intensity /= intensity.ptp()\n        return intensity",
        "begin_line": 773,
        "end_line": 786,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_light_source_planar_hillshading#798",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_light_source_planar_hillshading()",
        "snippet": "def test_light_source_planar_hillshading():\n    \"\"\"\n    Ensure that the illumination intensity is correct for planar surfaces.\n    \"\"\"\n\n    def plane(azimuth, elevation, x, y):\n        \"\"\"\n        Create a plane whose normal vector is at the given azimuth and\n        elevation.\n        \"\"\"\n        theta, phi = _azimuth2math(azimuth, elevation)\n        a, b, c = _sph2cart(theta, phi)\n        z = -(a*x + b*y) / c\n        return z\n\n    def angled_plane(azimuth, elevation, angle, x, y):\n        \"\"\"\n        Create a plane whose normal vector is at an angle from the given\n        azimuth and elevation.\n        \"\"\"\n        elevation = elevation + angle\n        if elevation > 90:\n            azimuth = (azimuth + 180) % 360\n            elevation = (90 - elevation) % 90\n        return plane(azimuth, elevation, x, y)\n\n    y, x = np.mgrid[5:0:-1, :5]\n    for az, elev in itertools.product(range(0, 390, 30), range(0, 105, 15)):\n        ls = mcolors.LightSource(az, elev)\n\n        # Make a plane at a range of angles to the illumination\n        for angle in range(0, 105, 15):\n            z = angled_plane(az, elev, angle, x, y)\n            h = ls.hillshade(z)\n            assert_array_almost_equal(h, np.cos(np.radians(angle)))",
        "begin_line": 798,
        "end_line": 832,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.plane#803",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.plane(azimuth, elevation, x, y)",
        "snippet": "    def plane(azimuth, elevation, x, y):\n        \"\"\"\n        Create a plane whose normal vector is at the given azimuth and\n        elevation.\n        \"\"\"\n        theta, phi = _azimuth2math(azimuth, elevation)\n        a, b, c = _sph2cart(theta, phi)\n        z = -(a*x + b*y) / c\n        return z",
        "begin_line": 803,
        "end_line": 811,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.angled_plane#813",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.angled_plane(azimuth, elevation, angle, x, y)",
        "snippet": "    def angled_plane(azimuth, elevation, angle, x, y):\n        \"\"\"\n        Create a plane whose normal vector is at an angle from the given\n        azimuth and elevation.\n        \"\"\"\n        elevation = elevation + angle\n        if elevation > 90:\n            azimuth = (azimuth + 180) % 360\n            elevation = (90 - elevation) % 90\n        return plane(azimuth, elevation, x, y)",
        "begin_line": 813,
        "end_line": 822,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_color_names#835",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_color_names()",
        "snippet": "def test_color_names():\n    assert mcolors.to_hex(\"blue\") == \"#0000ff\"\n    assert mcolors.to_hex(\"xkcd:blue\") == \"#0343df\"\n    assert mcolors.to_hex(\"tab:blue\") == \"#1f77b4\"",
        "begin_line": 835,
        "end_line": 838,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors._sph2cart#841",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors._sph2cart(theta, phi)",
        "snippet": "def _sph2cart(theta, phi):\n    x = np.cos(theta) * np.sin(phi)\n    y = np.sin(theta) * np.sin(phi)\n    z = np.cos(phi)\n    return x, y, z",
        "begin_line": 841,
        "end_line": 845,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors._azimuth2math#848",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors._azimuth2math(azimuth, elevation)",
        "snippet": "def _azimuth2math(azimuth, elevation):\n    \"\"\"\n    Convert from clockwise-from-north and up-from-horizontal to mathematical\n    conventions.\n    \"\"\"\n    theta = np.radians((90 - azimuth) % 360)\n    phi = np.radians(90 - elevation)\n    return theta, phi",
        "begin_line": 848,
        "end_line": 855,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_pandas_iterable#858",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_pandas_iterable(pd)",
        "snippet": "def test_pandas_iterable(pd):\n    # Using a list or series yields equivalent\n    # color maps, i.e the series isn't seen as\n    # a single color\n    lst = ['red', 'blue', 'green']\n    s = pd.Series(lst)\n    cm1 = mcolors.ListedColormap(lst, N=5)\n    cm2 = mcolors.ListedColormap(s, N=5)\n    assert_array_equal(cm1.colors, cm2.colors)",
        "begin_line": 858,
        "end_line": 866,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_colormap_reversing#870",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_colormap_reversing(name)",
        "snippet": "def test_colormap_reversing(name):\n    \"\"\"\n    Check the generated _lut data of a colormap and corresponding reversed\n    colormap if they are almost the same.\n    \"\"\"\n    cmap = plt.get_cmap(name)\n    cmap_r = cmap.reversed()\n    if not cmap_r._isinit:\n        cmap._init()\n        cmap_r._init()\n    assert_array_almost_equal(cmap._lut[:-3], cmap_r._lut[-4::-1])\n    # Test the bad, over, under values too\n    assert_array_almost_equal(cmap(-np.inf), cmap_r(np.inf))\n    assert_array_almost_equal(cmap(np.inf), cmap_r(-np.inf))\n    assert_array_almost_equal(cmap(np.nan), cmap_r(np.nan))",
        "begin_line": 870,
        "end_line": 884,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_cn#887",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_cn()",
        "snippet": "def test_cn():\n    matplotlib.rcParams['axes.prop_cycle'] = cycler('color',\n                                                    ['blue', 'r'])\n    assert mcolors.to_hex(\"C0\") == '#0000ff'\n    assert mcolors.to_hex(\"C1\") == '#ff0000'\n\n    matplotlib.rcParams['axes.prop_cycle'] = cycler('color',\n                                                    ['xkcd:blue', 'r'])\n    assert mcolors.to_hex(\"C0\") == '#0343df'\n    assert mcolors.to_hex(\"C1\") == '#ff0000'\n    assert mcolors.to_hex(\"C10\") == '#0343df'\n    assert mcolors.to_hex(\"C11\") == '#ff0000'\n\n    matplotlib.rcParams['axes.prop_cycle'] = cycler('color', ['8e4585', 'r'])\n\n    assert mcolors.to_hex(\"C0\") == '#8e4585'\n    # if '8e4585' gets parsed as a float before it gets detected as a hex\n    # colour it will be interpreted as a very large number.\n    # this mustn't happen.\n    assert mcolors.to_rgb(\"C0\")[0] != np.inf",
        "begin_line": 887,
        "end_line": 906,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_conversions#909",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_conversions()",
        "snippet": "def test_conversions():\n    # to_rgba_array(\"none\") returns a (0, 4) array.\n    assert_array_equal(mcolors.to_rgba_array(\"none\"), np.zeros((0, 4)))\n    assert_array_equal(mcolors.to_rgba_array([]), np.zeros((0, 4)))\n    # a list of grayscale levels, not a single color.\n    assert_array_equal(\n        mcolors.to_rgba_array([\".2\", \".5\", \".8\"]),\n        np.vstack([mcolors.to_rgba(c) for c in [\".2\", \".5\", \".8\"]]))\n    # alpha is properly set.\n    assert mcolors.to_rgba((1, 1, 1), .5) == (1, 1, 1, .5)\n    assert mcolors.to_rgba(\".1\", .5) == (.1, .1, .1, .5)\n    # builtin round differs between py2 and py3.\n    assert mcolors.to_hex((.7, .7, .7)) == \"#b2b2b2\"\n    # hex roundtrip.\n    hex_color = \"#1234abcd\"\n    assert mcolors.to_hex(mcolors.to_rgba(hex_color), keep_alpha=True) == \\\n        hex_color",
        "begin_line": 909,
        "end_line": 925,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_conversions_masked#928",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_conversions_masked()",
        "snippet": "def test_conversions_masked():\n    x1 = np.ma.array(['k', 'b'], mask=[True, False])\n    x2 = np.ma.array([[0, 0, 0, 1], [0, 0, 1, 1]])\n    x2[0] = np.ma.masked\n    assert mcolors.to_rgba(x1[0]) == (0, 0, 0, 0)\n    assert_array_equal(mcolors.to_rgba_array(x1),\n                       [[0, 0, 0, 0], [0, 0, 1, 1]])\n    assert_array_equal(mcolors.to_rgba_array(x2), mcolors.to_rgba_array(x1))",
        "begin_line": 928,
        "end_line": 935,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_to_rgba_array_single_str#938",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_to_rgba_array_single_str()",
        "snippet": "def test_to_rgba_array_single_str():\n    # single color name is valid\n    assert_array_equal(mcolors.to_rgba_array(\"red\"), [(1, 0, 0, 1)])\n\n    # single char color sequence is deprecated\n    with pytest.warns(cbook.MatplotlibDeprecationWarning,\n                      match=\"Using a string of single character colors as a \"\n                            \"color sequence is deprecated\"):\n        array = mcolors.to_rgba_array(\"rgb\")\n    assert_array_equal(array, [(1, 0, 0, 1), (0, 0.5, 0, 1), (0, 0, 1, 1)])\n\n    with pytest.raises(ValueError,\n                       match=\"neither a valid single color nor a color \"\n                             \"sequence\"):\n        mcolors.to_rgba_array(\"rgbx\")",
        "begin_line": 938,
        "end_line": 952,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_failed_conversions#955",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_failed_conversions()",
        "snippet": "def test_failed_conversions():\n    with pytest.raises(ValueError):\n        mcolors.to_rgba('5')\n    with pytest.raises(ValueError):\n        mcolors.to_rgba('-1')\n    with pytest.raises(ValueError):\n        mcolors.to_rgba('nan')\n    with pytest.raises(ValueError):\n        mcolors.to_rgba('unknown_color')\n    with pytest.raises(ValueError):\n        # Gray must be a string to distinguish 3-4 grays from RGB or RGBA.\n        mcolors.to_rgba(0.4)",
        "begin_line": 955,
        "end_line": 966,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_grey_gray#969",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_grey_gray()",
        "snippet": "def test_grey_gray():\n    color_mapping = mcolors._colors_full_map\n    for k in color_mapping.keys():\n        if 'grey' in k:\n            assert color_mapping[k] == color_mapping[k.replace('grey', 'gray')]\n        if 'gray' in k:\n            assert color_mapping[k] == color_mapping[k.replace('gray', 'grey')]",
        "begin_line": 969,
        "end_line": 975,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_tableau_order#978",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_tableau_order()",
        "snippet": "def test_tableau_order():\n    dflt_cycle = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728',\n                  '#9467bd', '#8c564b', '#e377c2', '#7f7f7f',\n                  '#bcbd22', '#17becf']\n\n    assert list(mcolors.TABLEAU_COLORS.values()) == dflt_cycle",
        "begin_line": 978,
        "end_line": 983,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_ndarray_subclass_norm#986",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_ndarray_subclass_norm()",
        "snippet": "def test_ndarray_subclass_norm():\n    # Emulate an ndarray subclass that handles units\n    # which objects when adding or subtracting with other\n    # arrays. See #6622 and #8696\n    class MyArray(np.ndarray):\n        def __isub__(self, other):\n            raise RuntimeError\n\n        def __add__(self, other):\n            raise RuntimeError\n\n    data = np.arange(-10, 10, 1, dtype=float).reshape((10, 2))\n    mydata = data.view(MyArray)\n\n    for norm in [mcolors.Normalize(), mcolors.LogNorm(),\n                 mcolors.SymLogNorm(3, vmax=5, linscale=1, base=np.e),\n                 mcolors.Normalize(vmin=mydata.min(), vmax=mydata.max()),\n                 mcolors.SymLogNorm(3, vmin=mydata.min(), vmax=mydata.max(),\n                                    base=np.e),\n                 mcolors.PowerNorm(1)]:\n        assert_array_equal(norm(mydata), norm(data))\n        fig, ax = plt.subplots()\n        ax.imshow(mydata, norm=norm)\n        fig.canvas.draw()  # Check that no warning is emitted.",
        "begin_line": 986,
        "end_line": 1009,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.MyArray.test_ndarray_subclass_norm#986",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors.MyArray",
        "signature": "lib.matplotlib.tests.test_colors.MyArray.test_ndarray_subclass_norm()",
        "snippet": "def test_ndarray_subclass_norm():\n    # Emulate an ndarray subclass that handles units\n    # which objects when adding or subtracting with other\n    # arrays. See #6622 and #8696\n    class MyArray(np.ndarray):\n        def __isub__(self, other):\n            raise RuntimeError\n\n        def __add__(self, other):\n            raise RuntimeError\n\n    data = np.arange(-10, 10, 1, dtype=float).reshape((10, 2))\n    mydata = data.view(MyArray)\n\n    for norm in [mcolors.Normalize(), mcolors.LogNorm(),\n                 mcolors.SymLogNorm(3, vmax=5, linscale=1, base=np.e),\n                 mcolors.Normalize(vmin=mydata.min(), vmax=mydata.max()),\n                 mcolors.SymLogNorm(3, vmin=mydata.min(), vmax=mydata.max(),\n                                    base=np.e),\n                 mcolors.PowerNorm(1)]:\n        assert_array_equal(norm(mydata), norm(data))\n        fig, ax = plt.subplots()\n        ax.imshow(mydata, norm=norm)\n        fig.canvas.draw()  # Check that no warning is emitted.",
        "begin_line": 986,
        "end_line": 1009,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.MyArray.__isub__#991",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors.MyArray",
        "signature": "lib.matplotlib.tests.test_colors.MyArray.__isub__(self, other)",
        "snippet": "        def __isub__(self, other):\n            raise RuntimeError",
        "begin_line": 991,
        "end_line": 992,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.MyArray.__add__#994",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors.MyArray",
        "signature": "lib.matplotlib.tests.test_colors.MyArray.__add__(self, other)",
        "snippet": "        def __add__(self, other):\n            raise RuntimeError",
        "begin_line": 994,
        "end_line": 995,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_same_color#1012",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_same_color()",
        "snippet": "def test_same_color():\n    assert mcolors.same_color('k', (0, 0, 0))\n    assert not mcolors.same_color('w', (1, 1, 0))",
        "begin_line": 1012,
        "end_line": 1014,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_hex_shorthand_notation#1017",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_hex_shorthand_notation()",
        "snippet": "def test_hex_shorthand_notation():\n    assert mcolors.same_color(\"#123\", \"#112233\")\n    assert mcolors.same_color(\"#123a\", \"#112233aa\")",
        "begin_line": 1017,
        "end_line": 1019,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_colors.test_DivergingNorm_deprecated#1022",
        "src_path": "lib/matplotlib/tests/test_colors.py",
        "class_name": "lib.matplotlib.tests.test_colors",
        "signature": "lib.matplotlib.tests.test_colors.test_DivergingNorm_deprecated()",
        "snippet": "def test_DivergingNorm_deprecated():\n    with pytest.warns(cbook.MatplotlibDeprecationWarning):\n        norm = mcolors.DivergingNorm(vcenter=0)",
        "begin_line": 1022,
        "end_line": 1024,
        "comment": "",
        "is_bug": false
    }
]