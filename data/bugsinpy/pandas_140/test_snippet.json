[
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_issues#12",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_issues()",
        "snippet": "def test_apply_issues():\n    # GH 5788\n\n    s = \"\"\"2011.05.16,00:00,1.40893\n2011.05.16,01:00,1.40760\n2011.05.16,02:00,1.40750\n2011.05.16,03:00,1.40649\n2011.05.17,02:00,1.40893\n2011.05.17,03:00,1.40760\n2011.05.17,04:00,1.40750\n2011.05.17,05:00,1.40649\n2011.05.18,02:00,1.40893\n2011.05.18,03:00,1.40760\n2011.05.18,04:00,1.40750\n2011.05.18,05:00,1.40649\"\"\"\n\n    df = pd.read_csv(\n        StringIO(s),\n        header=None,\n        names=[\"date\", \"time\", \"value\"],\n        parse_dates=[[\"date\", \"time\"]],\n    )\n    df = df.set_index(\"date_time\")\n\n    expected = df.groupby(df.index.date).idxmax()\n    result = df.groupby(df.index.date).apply(lambda x: x.idxmax())\n    tm.assert_frame_equal(result, expected)\n\n    # GH 5789\n    # don't auto coerce dates\n    df = pd.read_csv(StringIO(s), header=None, names=[\"date\", \"time\", \"value\"])\n    exp_idx = pd.Index(\n        [\"2011.05.16\", \"2011.05.17\", \"2011.05.18\"], dtype=object, name=\"date\"\n    )\n    expected = Series([\"00:00\", \"02:00\", \"02:00\"], index=exp_idx)\n    result = df.groupby(\"date\").apply(lambda x: x[\"time\"][x[\"value\"].idxmax()])\n    tm.assert_series_equal(result, expected)",
        "begin_line": 12,
        "end_line": 48,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_trivial#51",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_trivial()",
        "snippet": "def test_apply_trivial():\n    # GH 20066\n    # trivial apply: ignore input and return a constant dataframe.\n    df = pd.DataFrame(\n        {\"key\": [\"a\", \"a\", \"b\", \"b\", \"a\"], \"data\": [1.0, 2.0, 3.0, 4.0, 5.0]},\n        columns=[\"key\", \"data\"],\n    )\n    expected = pd.concat([df.iloc[1:], df.iloc[1:]], axis=1, keys=[\"float64\", \"object\"])\n    result = df.groupby([str(x) for x in df.dtypes], axis=1).apply(\n        lambda x: df.iloc[1:]\n    )\n\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 51,
        "end_line": 63,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_trivial_fail#71",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_trivial_fail()",
        "snippet": "def test_apply_trivial_fail():\n    # GH 20066\n    # trivial apply fails if the constant dataframe has the same index\n    # with the one used to create GroupBy object.\n    df = pd.DataFrame(\n        {\"key\": [\"a\", \"a\", \"b\", \"b\", \"a\"], \"data\": [1.0, 2.0, 3.0, 4.0, 5.0]},\n        columns=[\"key\", \"data\"],\n    )\n    expected = pd.concat([df, df], axis=1, keys=[\"float64\", \"object\"])\n    result = df.groupby([str(x) for x in df.dtypes], axis=1).apply(lambda x: df)\n\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 71,
        "end_line": 82,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_fast_apply#85",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_fast_apply()",
        "snippet": "def test_fast_apply():\n    # make sure that fast apply is correctly called\n    # rather than raising any kind of error\n    # otherwise the python path will be callsed\n    # which slows things down\n    N = 1000\n    labels = np.random.randint(0, 2000, size=N)\n    labels2 = np.random.randint(0, 3, size=N)\n    df = DataFrame(\n        {\n            \"key\": labels,\n            \"key2\": labels2,\n            \"value1\": np.random.randn(N),\n            \"value2\": [\"foo\", \"bar\", \"baz\", \"qux\"] * (N // 4),\n        }\n    )\n\n    def f(g):\n        return 1\n\n    g = df.groupby([\"key\", \"key2\"])\n\n    grouper = g.grouper\n\n    splitter = grouper._get_splitter(g._selected_obj, axis=g.axis)\n    group_keys = grouper._get_group_keys()\n\n    values, mutated = splitter.fast_apply(f, group_keys)\n\n    assert not mutated",
        "begin_line": 85,
        "end_line": 114,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.f#102",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.f(g)",
        "snippet": "    def f(g):\n        return 1",
        "begin_line": 102,
        "end_line": 103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_group_apply_once_per_group#147",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_group_apply_once_per_group(df, group_names)",
        "snippet": "def test_group_apply_once_per_group(df, group_names):\n    # GH2936, GH7739, GH10519, GH2656, GH12155, GH20084, GH21417\n\n    # This test should ensure that a function is only evaluated\n    # once per group. Previously the function has been evaluated twice\n    # on the first group to check if the Cython index slider is safe to use\n    # This test ensures that the side effect (append to list) is only triggered\n    # once per group\n\n    names = []\n    # cannot parameterize over the functions since they need external\n    # `names` to detect side effects\n\n    def f_copy(group):\n        # this takes the fast apply path\n        names.append(group.name)\n        return group.copy()\n\n    def f_nocopy(group):\n        # this takes the slow apply path\n        names.append(group.name)\n        return group\n\n    def f_scalar(group):\n        # GH7739, GH2656\n        names.append(group.name)\n        return 0\n\n    def f_none(group):\n        # GH10519, GH12155, GH21417\n        names.append(group.name)\n        return None\n\n    def f_constant_df(group):\n        # GH2936, GH20084\n        names.append(group.name)\n        return DataFrame({\"a\": [1], \"b\": [1]})\n\n    for func in [f_copy, f_nocopy, f_scalar, f_none, f_constant_df]:\n        del names[:]\n\n        df.groupby(\"a\").apply(func)\n        assert names == group_names",
        "begin_line": 147,
        "end_line": 189,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.f_copy#160",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.f_copy(group)",
        "snippet": "    def f_copy(group):\n        # this takes the fast apply path\n        names.append(group.name)\n        return group.copy()",
        "begin_line": 160,
        "end_line": 163,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.f_nocopy#165",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.f_nocopy(group)",
        "snippet": "    def f_nocopy(group):\n        # this takes the slow apply path\n        names.append(group.name)\n        return group",
        "begin_line": 165,
        "end_line": 168,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.f_scalar#170",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.f_scalar(group)",
        "snippet": "    def f_scalar(group):\n        # GH7739, GH2656\n        names.append(group.name)\n        return 0",
        "begin_line": 170,
        "end_line": 173,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.f_none#175",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.f_none(group)",
        "snippet": "    def f_none(group):\n        # GH10519, GH12155, GH21417\n        names.append(group.name)\n        return None",
        "begin_line": 175,
        "end_line": 178,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.f_constant_df#180",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.f_constant_df(group)",
        "snippet": "    def f_constant_df(group):\n        # GH2936, GH20084\n        names.append(group.name)\n        return DataFrame({\"a\": [1], \"b\": [1]})",
        "begin_line": 180,
        "end_line": 183,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_with_mixed_dtype#192",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_with_mixed_dtype()",
        "snippet": "def test_apply_with_mixed_dtype():\n    # GH3480, apply with mixed dtype on axis=1 breaks in 0.11\n    df = DataFrame(\n        {\n            \"foo1\": np.random.randn(6),\n            \"foo2\": [\"one\", \"two\", \"two\", \"three\", \"one\", \"two\"],\n        }\n    )\n    result = df.apply(lambda x: x, axis=1).dtypes\n    expected = df.dtypes\n    tm.assert_series_equal(result, expected)\n\n    # GH 3610 incorrect dtype conversion with as_index=False\n    df = DataFrame({\"c1\": [1, 2, 6, 6, 8]})\n    df[\"c2\"] = df.c1 / 2.0\n    result1 = df.groupby(\"c2\").mean().reset_index().c2\n    result2 = df.groupby(\"c2\", as_index=False).mean().c2\n    tm.assert_series_equal(result1, result2)",
        "begin_line": 192,
        "end_line": 209,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_groupby_as_index_apply#212",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_groupby_as_index_apply(df)",
        "snippet": "def test_groupby_as_index_apply(df):\n    # GH #4648 and #3417\n    df = DataFrame(\n        {\n            \"item_id\": [\"b\", \"b\", \"a\", \"c\", \"a\", \"b\"],\n            \"user_id\": [1, 2, 1, 1, 3, 1],\n            \"time\": range(6),\n        }\n    )\n\n    g_as = df.groupby(\"user_id\", as_index=True)\n    g_not_as = df.groupby(\"user_id\", as_index=False)\n\n    res_as = g_as.head(2).index\n    res_not_as = g_not_as.head(2).index\n    exp = Index([0, 1, 2, 4])\n    tm.assert_index_equal(res_as, exp)\n    tm.assert_index_equal(res_not_as, exp)\n\n    res_as_apply = g_as.apply(lambda x: x.head(2)).index\n    res_not_as_apply = g_not_as.apply(lambda x: x.head(2)).index\n\n    # apply doesn't maintain the original ordering\n    # changed in GH5610 as the as_index=False returns a MI here\n    exp_not_as_apply = MultiIndex.from_tuples([(0, 0), (0, 2), (1, 1), (2, 4)])\n    tp = [(1, 0), (1, 2), (2, 1), (3, 4)]\n    exp_as_apply = MultiIndex.from_tuples(tp, names=[\"user_id\", None])\n\n    tm.assert_index_equal(res_as_apply, exp_as_apply)\n    tm.assert_index_equal(res_not_as_apply, exp_not_as_apply)\n\n    ind = Index(list(\"abcde\"))\n    df = DataFrame([[1, 2], [2, 3], [1, 4], [1, 5], [2, 6]], index=ind)\n    res = df.groupby(0, as_index=False).apply(lambda x: x).index\n    tm.assert_index_equal(res, ind)",
        "begin_line": 212,
        "end_line": 246,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_concat_preserve_names#249",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_concat_preserve_names(three_group)",
        "snippet": "def test_apply_concat_preserve_names(three_group):\n    grouped = three_group.groupby([\"A\", \"B\"])\n\n    def desc(group):\n        result = group.describe()\n        result.index.name = \"stat\"\n        return result\n\n    def desc2(group):\n        result = group.describe()\n        result.index.name = \"stat\"\n        result = result[: len(group)]\n        # weirdo\n        return result\n\n    def desc3(group):\n        result = group.describe()\n\n        # names are different\n        result.index.name = \"stat_{:d}\".format(len(group))\n\n        result = result[: len(group)]\n        # weirdo\n        return result\n\n    result = grouped.apply(desc)\n    assert result.index.names == (\"A\", \"B\", \"stat\")\n\n    result2 = grouped.apply(desc2)\n    assert result2.index.names == (\"A\", \"B\", \"stat\")\n\n    result3 = grouped.apply(desc3)\n    assert result3.index.names == (\"A\", \"B\", None)",
        "begin_line": 249,
        "end_line": 281,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.desc#252",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.desc(group)",
        "snippet": "    def desc(group):\n        result = group.describe()\n        result.index.name = \"stat\"\n        return result",
        "begin_line": 252,
        "end_line": 255,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.desc2#257",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.desc2(group)",
        "snippet": "    def desc2(group):\n        result = group.describe()\n        result.index.name = \"stat\"\n        result = result[: len(group)]\n        # weirdo\n        return result",
        "begin_line": 257,
        "end_line": 262,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.desc3#264",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.desc3(group)",
        "snippet": "    def desc3(group):\n        result = group.describe()\n\n        # names are different\n        result.index.name = \"stat_{:d}\".format(len(group))\n\n        result = result[: len(group)]\n        # weirdo\n        return result",
        "begin_line": 264,
        "end_line": 272,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_series_to_frame#284",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_series_to_frame()",
        "snippet": "def test_apply_series_to_frame():\n    def f(piece):\n        with np.errstate(invalid=\"ignore\"):\n            logged = np.log(piece)\n        return DataFrame(\n            {\"value\": piece, \"demeaned\": piece - piece.mean(), \"logged\": logged}\n        )\n\n    dr = bdate_range(\"1/1/2000\", periods=100)\n    ts = Series(np.random.randn(100), index=dr)\n\n    grouped = ts.groupby(lambda x: x.month)\n    result = grouped.apply(f)\n\n    assert isinstance(result, DataFrame)\n    tm.assert_index_equal(result.index, ts.index)",
        "begin_line": 284,
        "end_line": 299,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.f#285",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.f(piece)",
        "snippet": "    def f(piece):\n        with np.errstate(invalid=\"ignore\"):\n            logged = np.log(piece)\n        return DataFrame(\n            {\"value\": piece, \"demeaned\": piece - piece.mean(), \"logged\": logged}\n        )",
        "begin_line": 285,
        "end_line": 290,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_series_yield_constant#302",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_series_yield_constant(df)",
        "snippet": "def test_apply_series_yield_constant(df):\n    result = df.groupby([\"A\", \"B\"])[\"C\"].apply(len)\n    assert result.index.names[:2] == (\"A\", \"B\")",
        "begin_line": 302,
        "end_line": 304,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_frame_yield_constant#307",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_frame_yield_constant(df)",
        "snippet": "def test_apply_frame_yield_constant(df):\n    # GH13568\n    result = df.groupby([\"A\", \"B\"]).apply(len)\n    assert isinstance(result, Series)\n    assert result.name is None\n\n    result = df.groupby([\"A\", \"B\"])[[\"C\", \"D\"]].apply(len)\n    assert isinstance(result, Series)\n    assert result.name is None",
        "begin_line": 307,
        "end_line": 315,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_frame_to_series#318",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_frame_to_series(df)",
        "snippet": "def test_apply_frame_to_series(df):\n    grouped = df.groupby([\"A\", \"B\"])\n    result = grouped.apply(len)\n    expected = grouped.count()[\"C\"]\n    tm.assert_index_equal(result.index, expected.index)\n    tm.assert_numpy_array_equal(result.values, expected.values)",
        "begin_line": 318,
        "end_line": 323,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_frame_concat_series#326",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_frame_concat_series()",
        "snippet": "def test_apply_frame_concat_series():\n    def trans(group):\n        return group.groupby(\"B\")[\"C\"].sum().sort_values()[:2]\n\n    def trans2(group):\n        grouped = group.groupby(df.reindex(group.index)[\"B\"])\n        return grouped.sum().sort_values()[:2]\n\n    df = DataFrame(\n        {\n            \"A\": np.random.randint(0, 5, 1000),\n            \"B\": np.random.randint(0, 5, 1000),\n            \"C\": np.random.randn(1000),\n        }\n    )\n\n    result = df.groupby(\"A\").apply(trans)\n    exp = df.groupby(\"A\")[\"C\"].apply(trans2)\n    tm.assert_series_equal(result, exp, check_names=False)\n    assert result.name == \"C\"",
        "begin_line": 326,
        "end_line": 345,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.trans#327",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.trans(group)",
        "snippet": "    def trans(group):\n        return group.groupby(\"B\")[\"C\"].sum().sort_values()[:2]",
        "begin_line": 327,
        "end_line": 328,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.trans2#330",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.trans2(group)",
        "snippet": "    def trans2(group):\n        grouped = group.groupby(df.reindex(group.index)[\"B\"])\n        return grouped.sum().sort_values()[:2]",
        "begin_line": 330,
        "end_line": 332,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_transform#348",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_transform(ts)",
        "snippet": "def test_apply_transform(ts):\n    grouped = ts.groupby(lambda x: x.month)\n    result = grouped.apply(lambda x: x * 2)\n    expected = grouped.transform(lambda x: x * 2)\n    tm.assert_series_equal(result, expected)",
        "begin_line": 348,
        "end_line": 352,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_multikey_corner#355",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_multikey_corner(tsframe)",
        "snippet": "def test_apply_multikey_corner(tsframe):\n    grouped = tsframe.groupby([lambda x: x.year, lambda x: x.month])\n\n    def f(group):\n        return group.sort_values(\"A\")[-5:]\n\n    result = grouped.apply(f)\n    for key, group in grouped:\n        tm.assert_frame_equal(result.loc[key], f(group))",
        "begin_line": 355,
        "end_line": 363,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.f#358",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.f(group)",
        "snippet": "    def f(group):\n        return group.sort_values(\"A\")[-5:]",
        "begin_line": 358,
        "end_line": 359,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_chunk_view#366",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_chunk_view()",
        "snippet": "def test_apply_chunk_view():\n    # Low level tinkering could be unsafe, make sure not\n    df = DataFrame({\"key\": [1, 1, 1, 2, 2, 2, 3, 3, 3], \"value\": range(9)})\n\n    result = df.groupby(\"key\", group_keys=False).apply(lambda x: x[:2])\n    expected = df.take([0, 1, 3, 4, 6, 7])\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 366,
        "end_line": 372,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_no_name_column_conflict#375",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_no_name_column_conflict()",
        "snippet": "def test_apply_no_name_column_conflict():\n    df = DataFrame(\n        {\n            \"name\": [1, 1, 1, 1, 1, 1, 2, 2, 2, 2],\n            \"name2\": [0, 0, 0, 1, 1, 1, 0, 0, 1, 1],\n            \"value\": range(9, -1, -1),\n        }\n    )\n\n    # it works! #2605\n    grouped = df.groupby([\"name\", \"name2\"])\n    grouped.apply(lambda x: x.sort_values(\"value\", inplace=True))",
        "begin_line": 375,
        "end_line": 386,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_typecast_fail#389",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_typecast_fail()",
        "snippet": "def test_apply_typecast_fail():\n    df = DataFrame(\n        {\n            \"d\": [1.0, 1.0, 1.0, 2.0, 2.0, 2.0],\n            \"c\": np.tile([\"a\", \"b\", \"c\"], 2),\n            \"v\": np.arange(1.0, 7.0),\n        }\n    )\n\n    def f(group):\n        v = group[\"v\"]\n        group[\"v2\"] = (v - v.min()) / (v.max() - v.min())\n        return group\n\n    result = df.groupby(\"d\").apply(f)\n\n    expected = df.copy()\n    expected[\"v2\"] = np.tile([0.0, 0.5, 1], 2)\n\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 389,
        "end_line": 408,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.f#398",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.f(group)",
        "snippet": "    def f(group):\n        v = group[\"v\"]\n        group[\"v2\"] = (v - v.min()) / (v.max() - v.min())\n        return group",
        "begin_line": 398,
        "end_line": 401,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_multiindex_fail#411",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_multiindex_fail()",
        "snippet": "def test_apply_multiindex_fail():\n    index = MultiIndex.from_arrays([[0, 0, 0, 1, 1, 1], [1, 2, 3, 1, 2, 3]])\n    df = DataFrame(\n        {\n            \"d\": [1.0, 1.0, 1.0, 2.0, 2.0, 2.0],\n            \"c\": np.tile([\"a\", \"b\", \"c\"], 2),\n            \"v\": np.arange(1.0, 7.0),\n        },\n        index=index,\n    )\n\n    def f(group):\n        v = group[\"v\"]\n        group[\"v2\"] = (v - v.min()) / (v.max() - v.min())\n        return group\n\n    result = df.groupby(\"d\").apply(f)\n\n    expected = df.copy()\n    expected[\"v2\"] = np.tile([0.0, 0.5, 1], 2)\n\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 411,
        "end_line": 432,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.f#422",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.f(group)",
        "snippet": "    def f(group):\n        v = group[\"v\"]\n        group[\"v2\"] = (v - v.min()) / (v.max() - v.min())\n        return group",
        "begin_line": 422,
        "end_line": 425,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_corner#435",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_corner(tsframe)",
        "snippet": "def test_apply_corner(tsframe):\n    result = tsframe.groupby(lambda x: x.year).apply(lambda x: x * 2)\n    expected = tsframe * 2\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 435,
        "end_line": 438,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_without_copy#441",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_without_copy()",
        "snippet": "def test_apply_without_copy():\n    # GH 5545\n    # returning a non-copy in an applied function fails\n\n    data = DataFrame(\n        {\n            \"id_field\": [100, 100, 200, 300],\n            \"category\": [\"a\", \"b\", \"c\", \"c\"],\n            \"value\": [1, 2, 3, 4],\n        }\n    )\n\n    def filt1(x):\n        if x.shape[0] == 1:\n            return x.copy()\n        else:\n            return x[x.category == \"c\"]\n\n    def filt2(x):\n        if x.shape[0] == 1:\n            return x\n        else:\n            return x[x.category == \"c\"]\n\n    expected = data.groupby(\"id_field\").apply(filt1)\n    result = data.groupby(\"id_field\").apply(filt2)\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 441,
        "end_line": 467,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.filt1#453",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.filt1(x)",
        "snippet": "    def filt1(x):\n        if x.shape[0] == 1:\n            return x.copy()\n        else:\n            return x[x.category == \"c\"]",
        "begin_line": 453,
        "end_line": 457,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.filt2#459",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.filt2(x)",
        "snippet": "    def filt2(x):\n        if x.shape[0] == 1:\n            return x\n        else:\n            return x[x.category == \"c\"]",
        "begin_line": 459,
        "end_line": 463,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_corner_cases#470",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_corner_cases()",
        "snippet": "def test_apply_corner_cases():\n    # #535, can't use sliding iterator\n\n    N = 1000\n    labels = np.random.randint(0, 100, size=N)\n    df = DataFrame(\n        {\n            \"key\": labels,\n            \"value1\": np.random.randn(N),\n            \"value2\": [\"foo\", \"bar\", \"baz\", \"qux\"] * (N // 4),\n        }\n    )\n\n    grouped = df.groupby(\"key\")\n\n    def f(g):\n        g[\"value3\"] = g[\"value1\"] * 2\n        return g\n\n    result = grouped.apply(f)\n    assert \"value3\" in result",
        "begin_line": 470,
        "end_line": 490,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.f#485",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.f(g)",
        "snippet": "    def f(g):\n        g[\"value3\"] = g[\"value1\"] * 2\n        return g",
        "begin_line": 485,
        "end_line": 487,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_numeric_coercion_when_datetime#493",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_numeric_coercion_when_datetime()",
        "snippet": "def test_apply_numeric_coercion_when_datetime():\n    # In the past, group-by/apply operations have been over-eager\n    # in converting dtypes to numeric, in the presence of datetime\n    # columns.  Various GH issues were filed, the reproductions\n    # for which are here.\n\n    # GH 15670\n    df = pd.DataFrame(\n        {\"Number\": [1, 2], \"Date\": [\"2017-03-02\"] * 2, \"Str\": [\"foo\", \"inf\"]}\n    )\n    expected = df.groupby([\"Number\"]).apply(lambda x: x.iloc[0])\n    df.Date = pd.to_datetime(df.Date)\n    result = df.groupby([\"Number\"]).apply(lambda x: x.iloc[0])\n    tm.assert_series_equal(result[\"Str\"], expected[\"Str\"])\n\n    # GH 15421\n    df = pd.DataFrame(\n        {\"A\": [10, 20, 30], \"B\": [\"foo\", \"3\", \"4\"], \"T\": [pd.Timestamp(\"12:31:22\")] * 3}\n    )\n\n    def get_B(g):\n        return g.iloc[0][[\"B\"]]\n\n    result = df.groupby(\"A\").apply(get_B)[\"B\"]\n    expected = df.B\n    expected.index = df.A\n    tm.assert_series_equal(result, expected)\n\n    # GH 14423\n    def predictions(tool):\n        out = pd.Series(index=[\"p1\", \"p2\", \"useTime\"], dtype=object)\n        if \"step1\" in list(tool.State):\n            out[\"p1\"] = str(tool[tool.State == \"step1\"].Machine.values[0])\n        if \"step2\" in list(tool.State):\n            out[\"p2\"] = str(tool[tool.State == \"step2\"].Machine.values[0])\n            out[\"useTime\"] = str(tool[tool.State == \"step2\"].oTime.values[0])\n        return out\n\n    df1 = pd.DataFrame(\n        {\n            \"Key\": [\"B\", \"B\", \"A\", \"A\"],\n            \"State\": [\"step1\", \"step2\", \"step1\", \"step2\"],\n            \"oTime\": [\"\", \"2016-09-19 05:24:33\", \"\", \"2016-09-19 23:59:04\"],\n            \"Machine\": [\"23\", \"36L\", \"36R\", \"36R\"],\n        }\n    )\n    df2 = df1.copy()\n    df2.oTime = pd.to_datetime(df2.oTime)\n    expected = df1.groupby(\"Key\").apply(predictions).p1\n    result = df2.groupby(\"Key\").apply(predictions).p1\n    tm.assert_series_equal(expected, result)",
        "begin_line": 493,
        "end_line": 543,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.get_B#513",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.get_B(g)",
        "snippet": "    def get_B(g):\n        return g.iloc[0][[\"B\"]]",
        "begin_line": 513,
        "end_line": 514,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.predictions#522",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.predictions(tool)",
        "snippet": "    def predictions(tool):\n        out = pd.Series(index=[\"p1\", \"p2\", \"useTime\"], dtype=object)\n        if \"step1\" in list(tool.State):\n            out[\"p1\"] = str(tool[tool.State == \"step1\"].Machine.values[0])\n        if \"step2\" in list(tool.State):\n            out[\"p2\"] = str(tool[tool.State == \"step2\"].Machine.values[0])\n            out[\"useTime\"] = str(tool[tool.State == \"step2\"].oTime.values[0])\n        return out",
        "begin_line": 522,
        "end_line": 529,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_time_field_bug#546",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_time_field_bug()",
        "snippet": "def test_time_field_bug():\n    # Test a fix for the following error related to GH issue 11324 When\n    # non-key fields in a group-by dataframe contained time-based fields\n    # that were not returned by the apply function, an exception would be\n    # raised.\n\n    df = pd.DataFrame({\"a\": 1, \"b\": [datetime.now() for nn in range(10)]})\n\n    def func_with_no_date(batch):\n        return pd.Series({\"c\": 2})\n\n    def func_with_date(batch):\n        return pd.Series({\"b\": datetime(2015, 1, 1), \"c\": 2})\n\n    dfg_no_conversion = df.groupby(by=[\"a\"]).apply(func_with_no_date)\n    dfg_no_conversion_expected = pd.DataFrame({\"c\": 2}, index=[1])\n    dfg_no_conversion_expected.index.name = \"a\"\n\n    dfg_conversion = df.groupby(by=[\"a\"]).apply(func_with_date)\n    dfg_conversion_expected = pd.DataFrame(\n        {\"b\": datetime(2015, 1, 1), \"c\": 2}, index=[1]\n    )\n    dfg_conversion_expected.index.name = \"a\"\n\n    tm.assert_frame_equal(dfg_no_conversion, dfg_no_conversion_expected)\n    tm.assert_frame_equal(dfg_conversion, dfg_conversion_expected)",
        "begin_line": 546,
        "end_line": 571,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.func_with_no_date#554",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.func_with_no_date(batch)",
        "snippet": "    def func_with_no_date(batch):\n        return pd.Series({\"c\": 2})",
        "begin_line": 554,
        "end_line": 555,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.func_with_date#557",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.func_with_date(batch)",
        "snippet": "    def func_with_date(batch):\n        return pd.Series({\"b\": datetime(2015, 1, 1), \"c\": 2})",
        "begin_line": 557,
        "end_line": 558,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_gb_apply_list_of_unequal_len_arrays#574",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_gb_apply_list_of_unequal_len_arrays()",
        "snippet": "def test_gb_apply_list_of_unequal_len_arrays():\n\n    # GH1738\n    df = DataFrame(\n        {\n            \"group1\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"a\", \"a\", \"a\", \"b\", \"b\", \"b\"],\n            \"group2\": [\"c\", \"c\", \"d\", \"d\", \"d\", \"e\", \"c\", \"c\", \"d\", \"d\", \"d\", \"e\"],\n            \"weight\": [1.1, 2, 3, 4, 5, 6, 2, 4, 6, 8, 1, 2],\n            \"value\": [7.1, 8, 9, 10, 11, 12, 8, 7, 6, 5, 4, 3],\n        }\n    )\n    df = df.set_index([\"group1\", \"group2\"])\n    df_grouped = df.groupby(level=[\"group1\", \"group2\"], sort=True)\n\n    def noddy(value, weight):\n        out = np.array(value * weight).repeat(3)\n        return out\n\n    # the kernel function returns arrays of unequal length\n    # pandas sniffs the first one, sees it's an array and not\n    # a list, and assumed the rest are of equal length\n    # and so tries a vstack\n\n    # don't die\n    df_grouped.apply(lambda x: noddy(x.value, x.weight))",
        "begin_line": 574,
        "end_line": 598,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.noddy#588",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.noddy(value, weight)",
        "snippet": "    def noddy(value, weight):\n        out = np.array(value * weight).repeat(3)\n        return out",
        "begin_line": 588,
        "end_line": 590,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_groupby_apply_all_none#601",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_groupby_apply_all_none()",
        "snippet": "def test_groupby_apply_all_none():\n    # Tests to make sure no errors if apply function returns all None\n    # values. Issue 9684.\n    test_df = DataFrame({\"groups\": [0, 0, 1, 1], \"random_vars\": [8, 7, 4, 5]})\n\n    def test_func(x):\n        pass\n\n    result = test_df.groupby(\"groups\").apply(test_func)\n    expected = DataFrame()\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 601,
        "end_line": 611,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_func#606",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_func(x)",
        "snippet": "    def test_func(x):\n        pass",
        "begin_line": 606,
        "end_line": 607,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_groupby_apply_none_first#614",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_groupby_apply_none_first()",
        "snippet": "def test_groupby_apply_none_first():\n    # GH 12824. Tests if apply returns None first.\n    test_df1 = DataFrame({\"groups\": [1, 1, 1, 2], \"vars\": [0, 1, 2, 3]})\n    test_df2 = DataFrame({\"groups\": [1, 2, 2, 2], \"vars\": [0, 1, 2, 3]})\n\n    def test_func(x):\n        if x.shape[0] < 2:\n            return None\n        return x.iloc[[0, -1]]\n\n    result1 = test_df1.groupby(\"groups\").apply(test_func)\n    result2 = test_df2.groupby(\"groups\").apply(test_func)\n    index1 = MultiIndex.from_arrays([[1, 1], [0, 2]], names=[\"groups\", None])\n    index2 = MultiIndex.from_arrays([[2, 2], [1, 3]], names=[\"groups\", None])\n    expected1 = DataFrame({\"groups\": [1, 1], \"vars\": [0, 2]}, index=index1)\n    expected2 = DataFrame({\"groups\": [2, 2], \"vars\": [1, 3]}, index=index2)\n    tm.assert_frame_equal(result1, expected1)\n    tm.assert_frame_equal(result2, expected2)",
        "begin_line": 614,
        "end_line": 631,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_func#619",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_func(x)",
        "snippet": "    def test_func(x):\n        if x.shape[0] < 2:\n            return None\n        return x.iloc[[0, -1]]",
        "begin_line": 619,
        "end_line": 622,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_groupby_apply_return_empty_chunk#634",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_groupby_apply_return_empty_chunk()",
        "snippet": "def test_groupby_apply_return_empty_chunk():\n    # GH 22221: apply filter which returns some empty groups\n    df = pd.DataFrame(dict(value=[0, 1], group=[\"filled\", \"empty\"]))\n    groups = df.groupby(\"group\")\n    result = groups.apply(lambda group: group[group.value != 1][\"value\"])\n    expected = pd.Series(\n        [0],\n        name=\"value\",\n        index=MultiIndex.from_product(\n            [[\"empty\", \"filled\"], [0]], names=[\"group\", None]\n        ).drop(\"empty\"),\n    )\n    tm.assert_series_equal(result, expected)",
        "begin_line": 634,
        "end_line": 646,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_with_mixed_types#649",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_with_mixed_types()",
        "snippet": "def test_apply_with_mixed_types():\n    # gh-20949\n    df = pd.DataFrame({\"A\": \"a a b\".split(), \"B\": [1, 2, 3], \"C\": [4, 6, 5]})\n    g = df.groupby(\"A\")\n\n    result = g.transform(lambda x: x / x.sum())\n    expected = pd.DataFrame({\"B\": [1 / 3.0, 2 / 3.0, 1], \"C\": [0.4, 0.6, 1.0]})\n    tm.assert_frame_equal(result, expected)\n\n    result = g.apply(lambda x: x / x.sum())\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 649,
        "end_line": 659,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.test_apply.test_apply_datetime_issue#666",
        "src_path": "pandas/tests/groupby/test_apply.py",
        "class_name": "pandas.tests.groupby.test_apply",
        "signature": "pandas.tests.groupby.test_apply.test_apply_datetime_issue(group_column_dtlike)",
        "snippet": "def test_apply_datetime_issue(group_column_dtlike):\n    # GH-28247\n    # groupby-apply throws an error if one of the columns in the DataFrame\n    #   is a datetime object and the column labels are different from\n    #   standard int values in range(len(num_columns))\n\n    df = pd.DataFrame({\"a\": [\"foo\"], \"b\": [group_column_dtlike]})\n    result = df.groupby(\"a\").apply(lambda x: pd.Series([\"spam\"], index=[42]))\n\n    expected = pd.DataFrame(\n        [\"spam\"], Index([\"foo\"], dtype=\"object\", name=\"a\"), columns=[42]\n    )\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 666,
        "end_line": 678,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.mframe#10",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.mframe()",
        "snippet": "def mframe():\n    index = MultiIndex(\n        levels=[[\"foo\", \"bar\", \"baz\", \"qux\"], [\"one\", \"two\", \"three\"]],\n        codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],\n        names=[\"first\", \"second\"],\n    )\n    return DataFrame(np.random.randn(10, 3), index=index, columns=[\"A\", \"B\", \"C\"])",
        "begin_line": 10,
        "end_line": 16,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.df#20",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.df()",
        "snippet": "def df():\n    return DataFrame(\n        {\n            \"A\": [\"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"foo\"],\n            \"B\": [\"one\", \"one\", \"two\", \"three\", \"two\", \"two\", \"one\", \"three\"],\n            \"C\": np.random.randn(8),\n            \"D\": np.random.randn(8),\n        }\n    )",
        "begin_line": 20,
        "end_line": 28,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.ts#32",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.ts()",
        "snippet": "def ts():\n    return tm.makeTimeSeries()",
        "begin_line": 32,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.tsd#37",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.tsd()",
        "snippet": "def tsd():\n    return tm.getTimeSeriesData()",
        "begin_line": 37,
        "end_line": 38,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.tsframe#42",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.tsframe(tsd)",
        "snippet": "def tsframe(tsd):\n    return DataFrame(tsd)",
        "begin_line": 42,
        "end_line": 43,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.df_mixed_floats#47",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.df_mixed_floats()",
        "snippet": "def df_mixed_floats():\n    return DataFrame(\n        {\n            \"A\": [\"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"foo\"],\n            \"B\": [\"one\", \"one\", \"two\", \"three\", \"two\", \"two\", \"one\", \"three\"],\n            \"C\": np.random.randn(8),\n            \"D\": np.array(np.random.randn(8), dtype=\"float32\"),\n        }\n    )",
        "begin_line": 47,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.three_group#59",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.three_group()",
        "snippet": "def three_group():\n    return DataFrame(\n        {\n            \"A\": [\n                \"foo\",\n                \"foo\",\n                \"foo\",\n                \"foo\",\n                \"bar\",\n                \"bar\",\n                \"bar\",\n                \"bar\",\n                \"foo\",\n                \"foo\",\n                \"foo\",\n            ],\n            \"B\": [\n                \"one\",\n                \"one\",\n                \"one\",\n                \"two\",\n                \"one\",\n                \"one\",\n                \"one\",\n                \"two\",\n                \"two\",\n                \"two\",\n                \"one\",\n            ],\n            \"C\": [\n                \"dull\",\n                \"dull\",\n                \"shiny\",\n                \"dull\",\n                \"dull\",\n                \"shiny\",\n                \"shiny\",\n                \"dull\",\n                \"shiny\",\n                \"shiny\",\n                \"shiny\",\n            ],\n            \"D\": np.random.randn(11),\n            \"E\": np.random.randn(11),\n            \"F\": np.random.randn(11),\n        }\n    )",
        "begin_line": 59,
        "end_line": 105,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.groupby.conftest.reduction_func#109",
        "src_path": "pandas/tests/groupby/conftest.py",
        "class_name": "pandas.tests.groupby.conftest",
        "signature": "pandas.tests.groupby.conftest.reduction_func(request)",
        "snippet": "def reduction_func(request):\n    \"\"\"yields the string names of all groupby reduction functions, one at a time.\n    \"\"\"\n    return request.param",
        "begin_line": 109,
        "end_line": 112,
        "comment": "",
        "is_bug": false
    }
]