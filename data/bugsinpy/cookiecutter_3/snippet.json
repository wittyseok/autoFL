[
    {
        "name": "cookiecutter.environment.ExtensionLoaderMixin.__init__#17",
        "src_path": "cookiecutter/environment.py",
        "class_name": "cookiecutter.environment.ExtensionLoaderMixin",
        "signature": "cookiecutter.environment.ExtensionLoaderMixin.__init__(self, **kwargs)",
        "snippet": "    def __init__(self, **kwargs):\n        \"\"\"Initialize the Jinja2 Environment object while loading extensions.\n\n        Does the following:\n\n        1. Establishes default_extensions (currently just a Time feature)\n        2. Reads extensions set in the cookiecutter.json _extensions key.\n        3. Attempts to load the extensions. Provides useful error if fails.\n        \"\"\"\n        context = kwargs.pop('context', {})\n\n        default_extensions = [\n            'cookiecutter.extensions.JsonifyExtension',\n            'jinja2_time.TimeExtension',\n        ]\n        extensions = default_extensions + self._read_extensions(context)\n\n        try:\n            super(ExtensionLoaderMixin, self).__init__(\n                extensions=extensions,\n                **kwargs\n            )\n        except ImportError as err:\n            raise UnknownExtension('Unable to load extension: {}'.format(err))",
        "begin_line": 17,
        "end_line": 40,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0033222591362126247,
            "pseudo_dstar_susp": 0.0625,
            "pseudo_tarantula_susp": 0.002380952380952381,
            "pseudo_op2_susp": 0.0625,
            "pseudo_barinel_susp": 0.002380952380952381
        }
    },
    {
        "name": "cookiecutter.environment.ExtensionLoaderMixin._read_extensions#42",
        "src_path": "cookiecutter/environment.py",
        "class_name": "cookiecutter.environment.ExtensionLoaderMixin",
        "signature": "cookiecutter.environment.ExtensionLoaderMixin._read_extensions(self, context)",
        "snippet": "    def _read_extensions(self, context):\n        \"\"\"Return list of extensions as str to be passed on to the Jinja2 env.\n\n        If context does not contain the relevant info, return an empty\n        list instead.\n        \"\"\"\n        try:\n            extensions = context['cookiecutter']['_extensions']\n        except KeyError:\n            return []\n        else:\n            return [str(ext) for ext in extensions]",
        "begin_line": 42,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0033222591362126247,
            "pseudo_dstar_susp": 0.0625,
            "pseudo_tarantula_susp": 0.002380952380952381,
            "pseudo_op2_susp": 0.0625,
            "pseudo_barinel_susp": 0.002380952380952381
        }
    },
    {
        "name": "cookiecutter.environment.StrictEnvironment.__init__#63",
        "src_path": "cookiecutter/environment.py",
        "class_name": "cookiecutter.environment.StrictEnvironment",
        "signature": "cookiecutter.environment.StrictEnvironment.__init__(self, **kwargs)",
        "snippet": "    def __init__(self, **kwargs):\n        \"\"\"Set the standard Cookiecutter StrictEnvironment.\n\n        Also loading extensions defined in cookiecutter.json's _extensions key.\n        \"\"\"\n        super(StrictEnvironment, self).__init__(\n            undefined=StrictUndefined,\n            **kwargs\n        )",
        "begin_line": 63,
        "end_line": 71,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0033222591362126247,
            "pseudo_dstar_susp": 0.0625,
            "pseudo_tarantula_susp": 0.002380952380952381,
            "pseudo_op2_susp": 0.0625,
            "pseudo_barinel_susp": 0.002380952380952381
        }
    },
    {
        "name": "cookiecutter.repository.is_repo_url#22",
        "src_path": "cookiecutter/repository.py",
        "class_name": "cookiecutter.repository",
        "signature": "cookiecutter.repository.is_repo_url(value)",
        "snippet": "def is_repo_url(value):\n    \"\"\"Return True if value is a repository URL.\"\"\"\n    return bool(REPO_REGEX.match(value))",
        "begin_line": 22,
        "end_line": 24,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002,
            "pseudo_dstar_susp": 0.002,
            "pseudo_tarantula_susp": 0.002008032128514056,
            "pseudo_op2_susp": 0.002,
            "pseudo_barinel_susp": 0.002008032128514056
        }
    },
    {
        "name": "cookiecutter.repository.is_zip_file#27",
        "src_path": "cookiecutter/repository.py",
        "class_name": "cookiecutter.repository",
        "signature": "cookiecutter.repository.is_zip_file(value)",
        "snippet": "def is_zip_file(value):\n    \"\"\"Return True if value is a zip file.\"\"\"\n    return value.lower().endswith('.zip')",
        "begin_line": 27,
        "end_line": 29,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002127659574468085,
            "pseudo_dstar_susp": 0.002127659574468085,
            "pseudo_tarantula_susp": 0.002232142857142857,
            "pseudo_op2_susp": 0.002127659574468085,
            "pseudo_barinel_susp": 0.002232142857142857
        }
    },
    {
        "name": "cookiecutter.repository.expand_abbreviations#32",
        "src_path": "cookiecutter/repository.py",
        "class_name": "cookiecutter.repository",
        "signature": "cookiecutter.repository.expand_abbreviations(template, abbreviations)",
        "snippet": "def expand_abbreviations(template, abbreviations):\n    \"\"\"Expand abbreviations in a template name.\n\n    :param template: The project template name.\n    :param abbreviations: Abbreviation definitions.\n    \"\"\"\n    if template in abbreviations:\n        return abbreviations[template]\n\n    # Split on colon. If there is no colon, rest will be empty\n    # and prefix will be the whole template\n    prefix, sep, rest = template.partition(':')\n    if prefix in abbreviations:\n        return abbreviations[prefix].format(rest)\n\n    return template",
        "begin_line": 32,
        "end_line": 47,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020491803278688526,
            "pseudo_dstar_susp": 0.0020491803278688526,
            "pseudo_tarantula_susp": 0.00205761316872428,
            "pseudo_op2_susp": 0.0020491803278688526,
            "pseudo_barinel_susp": 0.00205761316872428
        }
    },
    {
        "name": "cookiecutter.repository.repository_has_cookiecutter_json#50",
        "src_path": "cookiecutter/repository.py",
        "class_name": "cookiecutter.repository",
        "signature": "cookiecutter.repository.repository_has_cookiecutter_json(repo_directory)",
        "snippet": "def repository_has_cookiecutter_json(repo_directory):\n    \"\"\"Determine if `repo_directory` contains a `cookiecutter.json` file.\n\n    :param repo_directory: The candidate repository directory.\n    :return: True if the `repo_directory` is valid, else False.\n    \"\"\"\n    repo_directory_exists = os.path.isdir(repo_directory)\n\n    repo_config_exists = os.path.isfile(\n        os.path.join(repo_directory, 'cookiecutter.json')\n    )\n    return repo_directory_exists and repo_config_exists",
        "begin_line": 50,
        "end_line": 61,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002127659574468085,
            "pseudo_dstar_susp": 0.002127659574468085,
            "pseudo_tarantula_susp": 0.002232142857142857,
            "pseudo_op2_susp": 0.002127659574468085,
            "pseudo_barinel_susp": 0.002232142857142857
        }
    },
    {
        "name": "cookiecutter.repository.determine_repo_dir#64",
        "src_path": "cookiecutter/repository.py",
        "class_name": "cookiecutter.repository",
        "signature": "cookiecutter.repository.determine_repo_dir(template, abbreviations, clone_to_dir, checkout, no_input, password=None)",
        "snippet": "def determine_repo_dir(template, abbreviations, clone_to_dir, checkout,\n                       no_input, password=None):\n    \"\"\"\n    Locate the repository directory from a template reference.\n\n    Applies repository abbreviations to the template reference.\n    If the template refers to a repository URL, clone it.\n    If the template is a path to a local repository, use it.\n\n    :param template: A directory containing a project template directory,\n        or a URL to a git repository.\n    :param abbreviations: A dictionary of repository abbreviation\n        definitions.\n    :param clone_to_dir: The directory to clone the repository into.\n    :param checkout: The branch, tag or commit ID to checkout after clone.\n    :param no_input: Prompt the user at command line for manual configuration?\n    :param password: The password to use when extracting the repository.\n    :return: A tuple containing the cookiecutter template directory, and\n        a boolean descriving whether that directory should be cleaned up\n        after the template has been instantiated.\n    :raises: `RepositoryNotFound` if a repository directory could not be found.\n    \"\"\"\n    template = expand_abbreviations(template, abbreviations)\n\n    if is_zip_file(template):\n        unzipped_dir = unzip(\n            zip_uri=template,\n            is_url=is_repo_url(template),\n            clone_to_dir=clone_to_dir,\n            no_input=no_input,\n            password=password\n        )\n        repository_candidates = [unzipped_dir]\n        cleanup = True\n    elif is_repo_url(template):\n        cloned_repo = clone(\n            repo_url=template,\n            checkout=checkout,\n            clone_to_dir=clone_to_dir,\n            no_input=no_input,\n        )\n        repository_candidates = [cloned_repo]\n        cleanup = False\n    else:\n        repository_candidates = [\n            template,\n            os.path.join(clone_to_dir, template)\n        ]\n        cleanup = False\n\n    for repo_candidate in repository_candidates:\n        if repository_has_cookiecutter_json(repo_candidate):\n            return repo_candidate, cleanup\n\n    raise RepositoryNotFound(\n        'A valid repository for \"{}\" could not be found in the following '\n        'locations:\\n{}'.format(\n            template,\n            '\\n'.join(repository_candidates)\n        )\n    )",
        "begin_line": 64,
        "end_line": 124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0021598272138228943,
            "pseudo_dstar_susp": 0.0021598272138228943,
            "pseudo_tarantula_susp": 0.0022727272727272726,
            "pseudo_op2_susp": 0.0021598272138228943,
            "pseudo_barinel_susp": 0.0022727272727272726
        }
    },
    {
        "name": "cookiecutter.utils.force_delete#19",
        "src_path": "cookiecutter/utils.py",
        "class_name": "cookiecutter.utils",
        "signature": "cookiecutter.utils.force_delete(func, path, exc_info)",
        "snippet": "def force_delete(func, path, exc_info):\n    \"\"\"Error handler for `shutil.rmtree()` equivalent to `rm -rf`.\n\n    Usage: `shutil.rmtree(path, onerror=force_delete)`\n    From stackoverflow.com/questions/1889597\n    \"\"\"\n    os.chmod(path, stat.S_IWRITE)\n    func(path)",
        "begin_line": 19,
        "end_line": 26,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006060606060606061,
            "pseudo_dstar_susp": 0.003048780487804878,
            "pseudo_tarantula_susp": 0.006802721088435374,
            "pseudo_op2_susp": 0.003048780487804878,
            "pseudo_barinel_susp": 0.006802721088435374
        }
    },
    {
        "name": "cookiecutter.utils.rmtree#29",
        "src_path": "cookiecutter/utils.py",
        "class_name": "cookiecutter.utils",
        "signature": "cookiecutter.utils.rmtree(path)",
        "snippet": "def rmtree(path):\n    \"\"\"Remove a directory and all its contents. Like rm -rf on Unix.\n\n    :param path: A directory path.\n    \"\"\"\n    shutil.rmtree(path, onerror=force_delete)",
        "begin_line": 29,
        "end_line": 34,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003355704697986577,
            "pseudo_dstar_susp": 0.07142857142857142,
            "pseudo_tarantula_susp": 0.0027247956403269754,
            "pseudo_op2_susp": 0.07142857142857142,
            "pseudo_barinel_susp": 0.0027247956403269754
        }
    },
    {
        "name": "cookiecutter.utils.make_sure_path_exists#37",
        "src_path": "cookiecutter/utils.py",
        "class_name": "cookiecutter.utils",
        "signature": "cookiecutter.utils.make_sure_path_exists(path)",
        "snippet": "def make_sure_path_exists(path):\n    \"\"\"Ensure that a directory exists.\n\n    :param path: A directory path.\n    \"\"\"\n    logger.debug('Making sure path exists: {}'.format(path))\n    try:\n        os.makedirs(path)\n        logger.debug('Created directory at: {}'.format(path))\n    except OSError as exception:\n        if exception.errno != errno.EEXIST:\n            return False\n    return True",
        "begin_line": 37,
        "end_line": 49,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035335689045936395,
            "pseudo_dstar_susp": 0.16666666666666666,
            "pseudo_tarantula_susp": 0.003355704697986577,
            "pseudo_op2_susp": 0.16666666666666666,
            "pseudo_barinel_susp": 0.003355704697986577
        }
    },
    {
        "name": "cookiecutter.utils.work_in#53",
        "src_path": "cookiecutter/utils.py",
        "class_name": "cookiecutter.utils",
        "signature": "cookiecutter.utils.work_in(dirname=None)",
        "snippet": "def work_in(dirname=None):\n    \"\"\"Context manager version of os.chdir.\n\n    When exited, returns to the working directory prior to entering.\n    \"\"\"\n    curdir = os.getcwd()\n    try:\n        if dirname is not None:\n            os.chdir(dirname)\n        yield\n    finally:\n        os.chdir(curdir)",
        "begin_line": 53,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006060606060606061,
            "pseudo_dstar_susp": 0.005681818181818182,
            "pseudo_tarantula_susp": 0.006802721088435374,
            "pseudo_op2_susp": 0.005681818181818182,
            "pseudo_barinel_susp": 0.006802721088435374
        }
    },
    {
        "name": "cookiecutter.utils.make_executable#67",
        "src_path": "cookiecutter/utils.py",
        "class_name": "cookiecutter.utils",
        "signature": "cookiecutter.utils.make_executable(script_path)",
        "snippet": "def make_executable(script_path):\n    \"\"\"Make `script_path` executable.\n\n    :param script_path: The file to change\n    \"\"\"\n    status = os.stat(script_path)\n    os.chmod(script_path, status.st_mode | stat.S_IEXEC)",
        "begin_line": 67,
        "end_line": 73,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002277904328018223,
            "pseudo_dstar_susp": 0.002188183807439825,
            "pseudo_tarantula_susp": 0.002857142857142857,
            "pseudo_op2_susp": 0.002188183807439825,
            "pseudo_barinel_susp": 0.002857142857142857
        }
    },
    {
        "name": "cookiecutter.utils.prompt_and_delete#76",
        "src_path": "cookiecutter/utils.py",
        "class_name": "cookiecutter.utils",
        "signature": "cookiecutter.utils.prompt_and_delete(path, no_input=False)",
        "snippet": "def prompt_and_delete(path, no_input=False):\n    \"\"\"\n    Ask user if it's okay to delete the previously-downloaded file/directory.\n\n    If yes, delete it. If no, checks to see if the old version should be\n    reused. If yes, it's reused; otherwise, Cookiecutter exits.\n\n    :param path: Previously downloaded zipfile.\n    :param no_input: Suppress prompt to delete repo and just delete it.\n    :return: True if the content was deleted\n    \"\"\"\n    # Suppress prompt if called via API\n    if no_input:\n        ok_to_delete = True\n    else:\n        question = (\n            \"You've downloaded {} before. \"\n            \"Is it okay to delete and re-download it?\"\n        ).format(path)\n\n        ok_to_delete = read_user_yes_no(question, 'yes')\n\n    if ok_to_delete:\n        if os.path.isdir(path):\n            rmtree(path)\n        else:\n            os.remove(path)\n        return True\n    else:\n        ok_to_reuse = read_user_yes_no(\n            \"Do you want to re-use the existing version?\", 'yes'\n        )\n\n        if ok_to_reuse:\n            return False\n\n        sys.exit()",
        "begin_line": 76,
        "end_line": 112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006060606060606061,
            "pseudo_dstar_susp": 0.003048780487804878,
            "pseudo_tarantula_susp": 0.006802721088435374,
            "pseudo_op2_susp": 0.003048780487804878,
            "pseudo_barinel_susp": 0.006802721088435374
        }
    },
    {
        "name": "cookiecutter.zipfile.unzip#18",
        "src_path": "cookiecutter/zipfile.py",
        "class_name": "cookiecutter.zipfile",
        "signature": "cookiecutter.zipfile.unzip(zip_uri, is_url, clone_to_dir='.', no_input=False, password=None)",
        "snippet": "def unzip(zip_uri, is_url, clone_to_dir='.', no_input=False, password=None):\n    \"\"\"Download and unpack a zipfile at a given URI.\n\n    This will download the zipfile to the cookiecutter repository,\n    and unpack into a temporary directory.\n\n    :param zip_uri: The URI for the zipfile.\n    :param is_url: Is the zip URI a URL or a file?\n    :param clone_to_dir: The cookiecutter repository directory\n        to put the archive into.\n    :param no_input: Suppress any prompts\n    :param password: The password to use when unpacking the repository.\n    \"\"\"\n    # Ensure that clone_to_dir exists\n    clone_to_dir = os.path.expanduser(clone_to_dir)\n    make_sure_path_exists(clone_to_dir)\n\n    if is_url:\n        # Build the name of the cached zipfile,\n        # and prompt to delete if it already exists.\n        identifier = zip_uri.rsplit('/', 1)[1]\n        zip_path = os.path.join(clone_to_dir, identifier)\n\n        if os.path.exists(zip_path):\n            download = prompt_and_delete(zip_path, no_input=no_input)\n        else:\n            download = True\n\n        if download:\n            # (Re) download the zipfile\n            r = requests.get(zip_uri, stream=True)\n            with open(zip_path, 'wb') as f:\n                for chunk in r.iter_content(chunk_size=1024):\n                    if chunk:  # filter out keep-alive new chunks\n                        f.write(chunk)\n    else:\n        # Just use the local zipfile as-is.\n        zip_path = os.path.abspath(zip_uri)\n\n    # Now unpack the repository. The zipfile will be unpacked\n    # into a temporary directory\n    try:\n        zip_file = ZipFile(zip_path)\n\n        if len(zip_file.namelist()) == 0:\n            raise InvalidZipRepository(\n                'Zip repository {} is empty'.format(zip_uri)\n            )\n\n        # The first record in the zipfile should be the directory entry for\n        # the archive. If it isn't a directory, there's a problem.\n        first_filename = zip_file.namelist()[0]\n        if not first_filename.endswith('/'):\n            raise InvalidZipRepository(\n                'Zip repository {} does not include '\n                'a top-level directory'.format(zip_uri)\n            )\n\n        # Construct the final target directory\n        project_name = first_filename[:-1]\n        unzip_base = tempfile.mkdtemp()\n        unzip_path = os.path.join(unzip_base, project_name)\n\n        # Extract the zip file into the temporary directory\n        try:\n            zip_file.extractall(path=unzip_base)\n        except RuntimeError:\n            # File is password protected; try to get a password from the\n            # environment; if that doesn't work, ask the user.\n            if password is not None:\n                try:\n                    zip_file.extractall(\n                        path=unzip_base,\n                        pwd=password.encode('utf-8')\n                    )\n                except RuntimeError:\n                    raise InvalidZipRepository(\n                        'Invalid password provided for protected repository'\n                    )\n            elif no_input:\n                raise InvalidZipRepository(\n                    'Unable to unlock password protected repository'\n                )\n            else:\n                retry = 0\n                while retry is not None:\n                    try:\n                        password = read_repo_password('Repo password')\n                        zip_file.extractall(\n                            path=unzip_base,\n                            pwd=password.encode('utf-8')\n                        )\n                        retry = None\n                    except RuntimeError:\n                        retry += 1\n                        if retry == 3:\n                            raise InvalidZipRepository(\n                                'Invalid password provided '\n                                'for protected repository'\n                            )\n\n    except BadZipFile:\n        raise InvalidZipRepository(\n            'Zip repository {} is not a valid zip archive:'.format(zip_uri)\n        )\n\n    return unzip_path",
        "begin_line": 18,
        "end_line": 124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006060606060606061,
            "pseudo_dstar_susp": 0.003048780487804878,
            "pseudo_tarantula_susp": 0.006802721088435374,
            "pseudo_op2_susp": 0.003048780487804878,
            "pseudo_barinel_susp": 0.006802721088435374
        }
    },
    {
        "name": "cookiecutter.extensions.JsonifyExtension.__init__#13",
        "src_path": "cookiecutter/extensions.py",
        "class_name": "cookiecutter.extensions.JsonifyExtension",
        "signature": "cookiecutter.extensions.JsonifyExtension.__init__(self, environment)",
        "snippet": "    def __init__(self, environment):\n        \"\"\"Initialize the extension with the given environment.\"\"\"\n        super(JsonifyExtension, self).__init__(environment)\n\n        def jsonify(obj):\n            return json.dumps(obj, sort_keys=True, indent=4)\n\n        environment.filters['jsonify'] = jsonify",
        "begin_line": 13,
        "end_line": 20,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022271714922048997,
            "pseudo_dstar_susp": 0.005235602094240838,
            "pseudo_tarantula_susp": 0.0021551724137931034,
            "pseudo_op2_susp": 0.005235602094240838,
            "pseudo_barinel_susp": 0.0021551724137931034
        }
    },
    {
        "name": "cookiecutter.extensions.JsonifyExtension.jsonify#17",
        "src_path": "cookiecutter/extensions.py",
        "class_name": "cookiecutter.extensions.JsonifyExtension",
        "signature": "cookiecutter.extensions.JsonifyExtension.jsonify(obj)",
        "snippet": "        def jsonify(obj):\n            return json.dumps(obj, sort_keys=True, indent=4)",
        "begin_line": 17,
        "end_line": 18,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002183406113537118,
            "pseudo_dstar_susp": 0.005,
            "pseudo_tarantula_susp": 0.002105263157894737,
            "pseudo_op2_susp": 0.005,
            "pseudo_barinel_susp": 0.002105263157894737
        }
    },
    {
        "name": "cookiecutter.config._expand_path#36",
        "src_path": "cookiecutter/config.py",
        "class_name": "cookiecutter.config",
        "signature": "cookiecutter.config._expand_path(path)",
        "snippet": "def _expand_path(path):\n    \"\"\"Expand both environment variables and user home in the given path.\"\"\"\n    path = os.path.expandvars(path)\n    path = os.path.expanduser(path)\n    return path",
        "begin_line": 36,
        "end_line": 40,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0033444816053511705,
            "pseudo_dstar_susp": 0.0022371364653243847,
            "pseudo_tarantula_susp": 0.0034965034965034965,
            "pseudo_op2_susp": 0.0022371364653243847,
            "pseudo_barinel_susp": 0.0034965034965034965
        }
    },
    {
        "name": "cookiecutter.config.merge_configs#43",
        "src_path": "cookiecutter/config.py",
        "class_name": "cookiecutter.config",
        "signature": "cookiecutter.config.merge_configs(default, overwrite)",
        "snippet": "def merge_configs(default, overwrite):\n    \"\"\"Recursively update a dict with the key/value pair of another.\n\n    Dict values that are dictionaries themselves will be updated, whilst\n    preserving existing keys.\n    \"\"\"\n    new_config = copy.deepcopy(default)\n\n    for k, v in overwrite.items():\n        # Make sure to preserve existing items in\n        # nested dicts, for example `abbreviations`\n        if isinstance(v, dict):\n            new_config[k] = merge_configs(default[k], v)\n        else:\n            new_config[k] = v\n\n    return new_config",
        "begin_line": 43,
        "end_line": 59,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002890173410404624,
            "pseudo_dstar_susp": 0.002232142857142857,
            "pseudo_tarantula_susp": 0.003472222222222222,
            "pseudo_op2_susp": 0.002232142857142857,
            "pseudo_barinel_susp": 0.003472222222222222
        }
    },
    {
        "name": "cookiecutter.config.get_config#62",
        "src_path": "cookiecutter/config.py",
        "class_name": "cookiecutter.config",
        "signature": "cookiecutter.config.get_config(config_path)",
        "snippet": "def get_config(config_path):\n    \"\"\"Retrieve the config from the specified path, returning a config dict.\"\"\"\n    if not os.path.exists(config_path):\n        raise ConfigDoesNotExistException\n\n    logger.debug('config_path is {0}'.format(config_path))\n    with io.open(config_path, encoding='utf-8') as file_handle:\n        try:\n            yaml_dict = poyo.parse_string(file_handle.read())\n        except poyo.exceptions.PoyoException as e:\n            raise InvalidConfiguration(\n                'Unable to parse YAML file {}. Error: {}'\n                ''.format(config_path, e)\n            )\n\n    config_dict = merge_configs(DEFAULT_CONFIG, yaml_dict)\n\n    raw_replay_dir = config_dict['replay_dir']\n    config_dict['replay_dir'] = _expand_path(raw_replay_dir)\n\n    raw_cookies_dir = config_dict['cookiecutters_dir']\n    config_dict['cookiecutters_dir'] = _expand_path(raw_cookies_dir)\n\n    return config_dict",
        "begin_line": 62,
        "end_line": 85,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002777777777777778,
            "pseudo_dstar_susp": 0.0022271714922048997,
            "pseudo_tarantula_susp": 0.0034602076124567475,
            "pseudo_op2_susp": 0.0022271714922048997,
            "pseudo_barinel_susp": 0.0034602076124567475
        }
    },
    {
        "name": "cookiecutter.config.get_user_config#88",
        "src_path": "cookiecutter/config.py",
        "class_name": "cookiecutter.config",
        "signature": "cookiecutter.config.get_user_config(config_file=None, default_config=False)",
        "snippet": "def get_user_config(config_file=None, default_config=False):\n    \"\"\"Return the user config as a dict.\n\n    If ``default_config`` is True, ignore ``config_file`` and return default\n    values for the config parameters.\n\n    If a path to a ``config_file`` is given, that is different from the default\n    location, load the user config from that.\n\n    Otherwise look up the config file path in the ``COOKIECUTTER_CONFIG``\n    environment variable. If set, load the config from this path. This will\n    raise an error if the specified path is not valid.\n\n    If the environment variable is not set, try the default config file path\n    before falling back to the default config values.\n    \"\"\"\n    # Do NOT load a config. Return defaults instead.\n    if default_config:\n        return copy.copy(DEFAULT_CONFIG)\n\n    # Load the given config file\n    if config_file and config_file is not USER_CONFIG_PATH:\n        return get_config(config_file)\n\n    try:\n        # Does the user set up a config environment variable?\n        env_config_file = os.environ['COOKIECUTTER_CONFIG']\n    except KeyError:\n        # Load an optional user config if it exists\n        # otherwise return the defaults\n        if os.path.exists(USER_CONFIG_PATH):\n            return get_config(USER_CONFIG_PATH)\n        else:\n            return copy.copy(DEFAULT_CONFIG)\n    else:\n        # There is a config environment variable. Try to load it.\n        # Do not check for existence, so invalid file paths raise an error.\n        return get_config(env_config_file)",
        "begin_line": 88,
        "end_line": 125,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0021551724137931034,
            "pseudo_dstar_susp": 0.0021551724137931034,
            "pseudo_tarantula_susp": 0.0022624434389140274,
            "pseudo_op2_susp": 0.0021551724137931034,
            "pseudo_barinel_susp": 0.0022624434389140274
        }
    },
    {
        "name": "cookiecutter.log.configure_logger#22",
        "src_path": "cookiecutter/log.py",
        "class_name": "cookiecutter.log",
        "signature": "cookiecutter.log.configure_logger(stream_level='DEBUG', debug_file=None)",
        "snippet": "def configure_logger(stream_level='DEBUG', debug_file=None):\n    \"\"\"Configure logging for cookiecutter.\n\n    Set up logging to stdout with given level. If ``debug_file`` is given set\n    up logging to file with DEBUG level.\n    \"\"\"\n    # Set up 'cookiecutter' logger\n    logger = logging.getLogger('cookiecutter')\n    logger.setLevel(logging.DEBUG)\n\n    # Remove all attached handlers, in case there was\n    # a logger with using the name 'cookiecutter'\n    del logger.handlers[:]\n\n    # Create a file handler if a log file is provided\n    if debug_file is not None:\n        debug_formatter = logging.Formatter(LOG_FORMATS['DEBUG'])\n        file_handler = logging.FileHandler(debug_file)\n        file_handler.setLevel(LOG_LEVELS['DEBUG'])\n        file_handler.setFormatter(debug_formatter)\n        logger.addHandler(file_handler)\n\n    # Get settings based on the given stream_level\n    log_formatter = logging.Formatter(LOG_FORMATS[stream_level])\n    log_level = LOG_LEVELS[stream_level]\n\n    # Create a stream handler\n    stream_handler = logging.StreamHandler(stream=sys.stdout)\n    stream_handler.setLevel(log_level)\n    stream_handler.setFormatter(log_formatter)\n    logger.addHandler(stream_handler)\n\n    return logger",
        "begin_line": 22,
        "end_line": 54,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002277904328018223,
            "pseudo_dstar_susp": 0.002188183807439825,
            "pseudo_tarantula_susp": 0.002857142857142857,
            "pseudo_op2_susp": 0.002188183807439825,
            "pseudo_barinel_susp": 0.002857142857142857
        }
    },
    {
        "name": "cookiecutter.generate.is_copy_only_path#33",
        "src_path": "cookiecutter/generate.py",
        "class_name": "cookiecutter.generate",
        "signature": "cookiecutter.generate.is_copy_only_path(path, context)",
        "snippet": "def is_copy_only_path(path, context):\n    \"\"\"Check whether the given `path` should only be copied and not rendered.\n\n    Returns True if `path` matches a pattern in the given `context` dict,\n    otherwise False.\n\n    :param path: A file-system path referring to a file or dir that\n        should be rendered or just copied.\n    :param context: cookiecutter context.\n    \"\"\"\n    try:\n        for dont_render in context['cookiecutter']['_copy_without_render']:\n            if fnmatch.fnmatch(path, dont_render):\n                return True\n    except KeyError:\n        return False\n\n    return False",
        "begin_line": 33,
        "end_line": 50,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03125,
            "pseudo_dstar_susp": 0.25,
            "pseudo_tarantula_susp": 0.07692307692307693,
            "pseudo_op2_susp": 0.25,
            "pseudo_barinel_susp": 0.07692307692307693
        }
    },
    {
        "name": "cookiecutter.generate.apply_overwrites_to_context#53",
        "src_path": "cookiecutter/generate.py",
        "class_name": "cookiecutter.generate",
        "signature": "cookiecutter.generate.apply_overwrites_to_context(context, overwrite_context)",
        "snippet": "def apply_overwrites_to_context(context, overwrite_context):\n    \"\"\"Modify the given context in place based on the overwrite_context.\"\"\"\n    for variable, overwrite in overwrite_context.items():\n        if variable not in context:\n            # Do not include variables which are not used in the template\n            continue\n\n        context_value = context[variable]\n\n        if isinstance(context_value, list):\n            # We are dealing with a choice variable\n            if overwrite in context_value:\n                # This overwrite is actually valid for the given context\n                # Let's set it as default (by definition first item in list)\n                # see ``cookiecutter.prompt.prompt_choice_for_config``\n                context_value.remove(overwrite)\n                context_value.insert(0, overwrite)\n        else:\n            # Simply overwrite the value for this variable\n            context[variable] = overwrite",
        "begin_line": 53,
        "end_line": 72,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002320185614849188,
            "pseudo_dstar_susp": 0.0022123893805309734,
            "pseudo_tarantula_susp": 0.0034129692832764505,
            "pseudo_op2_susp": 0.0022123893805309734,
            "pseudo_barinel_susp": 0.0034129692832764505
        }
    },
    {
        "name": "cookiecutter.generate.generate_context#75",
        "src_path": "cookiecutter/generate.py",
        "class_name": "cookiecutter.generate",
        "signature": "cookiecutter.generate.generate_context(context_file='cookiecutter.json', default_context=None, extra_context=None)",
        "snippet": "def generate_context(context_file='cookiecutter.json', default_context=None,\n                     extra_context=None):\n    \"\"\"Generate the context for a Cookiecutter project template.\n\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n    context = OrderedDict([])\n\n    try:\n        with open(context_file) as file_handle:\n            obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message))\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logger.debug('Context generated is {}'.format(context))\n    return context",
        "begin_line": 75,
        "end_line": 114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002127659574468085,
            "pseudo_dstar_susp": 0.002127659574468085,
            "pseudo_tarantula_susp": 0.002232142857142857,
            "pseudo_op2_susp": 0.002127659574468085,
            "pseudo_barinel_susp": 0.002232142857142857
        }
    },
    {
        "name": "cookiecutter.generate.generate_file#117",
        "src_path": "cookiecutter/generate.py",
        "class_name": "cookiecutter.generate",
        "signature": "cookiecutter.generate.generate_file(project_dir, infile, context, env)",
        "snippet": "def generate_file(project_dir, infile, context, env):\n    \"\"\"Render filename of infile as name of outfile, handle infile correctly.\n\n    Dealing with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n    logger.debug('Processing file {}'.format(infile))\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = env.from_string(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logger.debug('The resulting file name is empty: {0}'.format(outfile))\n        return\n\n    logger.debug('Created file at {0}'.format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logger.debug(\"Check {} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logger.debug(\n            'Copying binary {} to {} without rendering'\n            ''.format(infile, outfile)\n        )\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        logger.debug('Writing contents to file {}'.format(outfile))\n\n        with io.open(outfile, 'w', encoding='utf-8') as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
        "begin_line": 117,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002717391304347826,
            "pseudo_dstar_susp": 0.008264462809917356,
            "pseudo_tarantula_susp": 0.00267379679144385,
            "pseudo_op2_susp": 0.008264462809917356,
            "pseudo_barinel_susp": 0.00267379679144385
        }
    },
    {
        "name": "cookiecutter.generate.render_and_create_dir#183",
        "src_path": "cookiecutter/generate.py",
        "class_name": "cookiecutter.generate",
        "signature": "cookiecutter.generate.render_and_create_dir(dirname, context, output_dir, environment, overwrite_if_exists=False)",
        "snippet": "def render_and_create_dir(dirname, context, output_dir, environment,\n                          overwrite_if_exists=False):\n    \"\"\"Render name of a directory, create the directory, return its path.\"\"\"\n    name_tmpl = environment.from_string(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n\n    logger.debug('Rendered dir {} must exist in output_dir {}'.format(\n        dir_to_create,\n        output_dir\n    ))\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if output_dir_exists:\n        if overwrite_if_exists:\n            logger.debug(\n                'Output directory {} already exists,'\n                'overwriting it'.format(dir_to_create)\n            )\n        else:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n    else:\n        make_sure_path_exists(dir_to_create)\n\n    return dir_to_create, not output_dir_exists",
        "begin_line": 183,
        "end_line": 212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035087719298245615,
            "pseudo_dstar_susp": 0.125,
            "pseudo_tarantula_susp": 0.0033333333333333335,
            "pseudo_op2_susp": 0.125,
            "pseudo_barinel_susp": 0.0033333333333333335
        }
    },
    {
        "name": "cookiecutter.generate.ensure_dir_is_templated#215",
        "src_path": "cookiecutter/generate.py",
        "class_name": "cookiecutter.generate",
        "signature": "cookiecutter.generate.ensure_dir_is_templated(dirname)",
        "snippet": "def ensure_dir_is_templated(dirname):\n    \"\"\"Ensure that dirname is a templated directory name.\"\"\"\n    if '{{' in dirname and '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException",
        "begin_line": 215,
        "end_line": 220,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0034602076124567475,
            "pseudo_dstar_susp": 0.08333333333333333,
            "pseudo_tarantula_susp": 0.002857142857142857,
            "pseudo_op2_susp": 0.08333333333333333,
            "pseudo_barinel_susp": 0.002857142857142857
        }
    },
    {
        "name": "cookiecutter.generate._run_hook_from_repo_dir#223",
        "src_path": "cookiecutter/generate.py",
        "class_name": "cookiecutter.generate",
        "signature": "cookiecutter.generate._run_hook_from_repo_dir(repo_dir, hook_name, project_dir, context, delete_project_on_failure)",
        "snippet": "def _run_hook_from_repo_dir(repo_dir, hook_name, project_dir, context,\n                            delete_project_on_failure):\n    \"\"\"Run hook from repo directory, clean project directory if hook fails.\n\n    :param repo_dir: Project template input directory.\n    :param hook_name: The hook to execute.\n    :param project_dir: The directory to execute the script from.\n    :param context: Cookiecutter project context.\n    :param delete_project_on_failure: Delete the project directory on hook\n        failure?\n    \"\"\"\n    with work_in(repo_dir):\n        try:\n            run_hook(hook_name, project_dir, context)\n        except FailedHookException:\n            if delete_project_on_failure:\n                rmtree(project_dir)\n            logger.error(\n                \"Stopping generation because {} hook \"\n                \"script didn't exit successfully\".format(hook_name)\n            )\n            raise",
        "begin_line": 223,
        "end_line": 244,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035460992907801418,
            "pseudo_dstar_susp": 0.2,
            "pseudo_tarantula_susp": 0.003389830508474576,
            "pseudo_op2_susp": 0.2,
            "pseudo_barinel_susp": 0.003389830508474576
        }
    },
    {
        "name": "cookiecutter.generate.generate_files#247",
        "src_path": "cookiecutter/generate.py",
        "class_name": "cookiecutter.generate",
        "signature": "cookiecutter.generate.generate_files(repo_dir, context=None, output_dir='.', overwrite_if_exists=False)",
        "snippet": "def generate_files(repo_dir, context=None, output_dir='.',\n                   overwrite_if_exists=False):\n    \"\"\"Render the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists.\n    \"\"\"\n    template_dir = find_template(repo_dir)\n    logger.debug('Generating project from {}...'.format(template_dir))\n    context = context or OrderedDict([])\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    env = StrictEnvironment(\n        context=context,\n        keep_trailing_newline=True,\n    )\n    try:\n        project_dir, output_directory_created = render_and_create_dir(\n            unrendered_dir,\n            context,\n            output_dir,\n            env,\n            overwrite_if_exists\n        )\n    except UndefinedError as err:\n        msg = \"Unable to create project directory '{}'\".format(unrendered_dir)\n        raise UndefinedVariableInTemplate(msg, err, context)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logger.debug('Project directory is {}'.format(project_dir))\n\n    # if we created the output directory, then it's ok to remove it\n    # if rendering fails\n    delete_project_on_failure = output_directory_created\n\n    _run_hook_from_repo_dir(\n        repo_dir,\n        'pre_gen_project',\n        project_dir,\n        context,\n        delete_project_on_failure\n    )\n\n    with work_in(template_dir):\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if is_copy_only_path(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                logger.debug(\n                    'Copying dir {} to {} without rendering'\n                    ''.format(indir, outdir)\n                )\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                try:\n                    render_and_create_dir(\n                        unrendered_dir,\n                        context,\n                        output_dir,\n                        env,\n                        overwrite_if_exists\n                    )\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    _dir = os.path.relpath(unrendered_dir, output_dir)\n                    msg = \"Unable to create directory '{}'\".format(_dir)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if is_copy_only_path(infile, context):\n                    outfile_tmpl = env.from_string(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logger.debug(\n                        'Copying file {} to {} without rendering'\n                        ''.format(infile, outfile)\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                try:\n                    generate_file(project_dir, infile, context, env)\n                except UndefinedError as err:\n                    if delete_project_on_failure:\n                        rmtree(project_dir)\n                    msg = \"Unable to create file '{}'\".format(infile)\n                    raise UndefinedVariableInTemplate(msg, err, context)\n\n    _run_hook_from_repo_dir(\n        repo_dir,\n        'post_gen_project',\n        project_dir,\n        context,\n        delete_project_on_failure\n    )\n\n    return project_dir",
        "begin_line": 247,
        "end_line": 379,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03125,
            "pseudo_dstar_susp": 0.1111111111111111,
            "pseudo_tarantula_susp": 0.07692307692307693,
            "pseudo_op2_susp": 0.1111111111111111,
            "pseudo_barinel_susp": 0.07692307692307693
        }
    },
    {
        "name": "cookiecutter.find.find_template#13",
        "src_path": "cookiecutter/find.py",
        "class_name": "cookiecutter.find",
        "signature": "cookiecutter.find.find_template(repo_dir)",
        "snippet": "def find_template(repo_dir):\n    \"\"\"Determine which child directory of `repo_dir` is the project template.\n\n    :param repo_dir: Local directory of newly cloned repo.\n    :returns project_template: Relative path to project template.\n    \"\"\"\n    logger.debug('Searching {} for the project template.'.format(repo_dir))\n\n    repo_dir_contents = os.listdir(repo_dir)\n\n    project_template = None\n    for item in repo_dir_contents:\n        if 'cookiecutter' in item and '{{' in item and '}}' in item:\n            project_template = item\n            break\n\n    if project_template:\n        project_template = os.path.join(repo_dir, project_template)\n        logger.debug(\n            'The project template appears to be {}'.format(project_template)\n        )\n        return project_template\n    else:\n        raise NonTemplatedInputDirException",
        "begin_line": 13,
        "end_line": 36,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003484320557491289,
            "pseudo_dstar_susp": 0.1,
            "pseudo_tarantula_susp": 0.0029069767441860465,
            "pseudo_op2_susp": 0.1,
            "pseudo_barinel_susp": 0.0029069767441860465
        }
    },
    {
        "name": "cookiecutter.hooks.valid_hook#26",
        "src_path": "cookiecutter/hooks.py",
        "class_name": "cookiecutter.hooks",
        "signature": "cookiecutter.hooks.valid_hook(hook_file, hook_name)",
        "snippet": "def valid_hook(hook_file, hook_name):\n    \"\"\"Determine if a hook file is valid.\n\n    :param hook_file: The hook file to consider for validity\n    :param hook_name: The hook to find\n    :return: The hook file validity\n    \"\"\"\n    filename = os.path.basename(hook_file)\n    basename = os.path.splitext(filename)[0]\n\n    matching_hook = basename == hook_name\n    supported_hook = basename in _HOOKS\n    backup_file = filename.endswith('~')\n\n    return matching_hook and supported_hook and not backup_file",
        "begin_line": 26,
        "end_line": 40,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002277904328018223,
            "pseudo_dstar_susp": 0.002188183807439825,
            "pseudo_tarantula_susp": 0.002857142857142857,
            "pseudo_op2_susp": 0.002188183807439825,
            "pseudo_barinel_susp": 0.002857142857142857
        }
    },
    {
        "name": "cookiecutter.hooks.find_hook#43",
        "src_path": "cookiecutter/hooks.py",
        "class_name": "cookiecutter.hooks",
        "signature": "cookiecutter.hooks.find_hook(hook_name, hooks_dir='hooks')",
        "snippet": "def find_hook(hook_name, hooks_dir='hooks'):\n    \"\"\"Return a dict of all hook scripts provided.\n\n    Must be called with the project template as the current working directory.\n    Dict's key will be the hook/script's name, without extension, while values\n    will be the absolute path to the script. Missing scripts will not be\n    included in the returned dict.\n\n    :param hook_name: The hook to find\n    :param hooks_dir: The hook directory in the template\n    :return: The absolute path to the hook script or None\n    \"\"\"\n    logger.debug('hooks_dir is {}'.format(os.path.abspath(hooks_dir)))\n\n    if not os.path.isdir(hooks_dir):\n        logger.debug('No hooks/ dir in template_dir')\n        return None\n\n    for hook_file in os.listdir(hooks_dir):\n        if valid_hook(hook_file, hook_name):\n            return os.path.abspath(os.path.join(hooks_dir, hook_file))\n\n    return None",
        "begin_line": 43,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0034602076124567475,
            "pseudo_dstar_susp": 0.08333333333333333,
            "pseudo_tarantula_susp": 0.002857142857142857,
            "pseudo_op2_susp": 0.08333333333333333,
            "pseudo_barinel_susp": 0.002857142857142857
        }
    },
    {
        "name": "cookiecutter.hooks.run_script#68",
        "src_path": "cookiecutter/hooks.py",
        "class_name": "cookiecutter.hooks",
        "signature": "cookiecutter.hooks.run_script(script_path, cwd='.')",
        "snippet": "def run_script(script_path, cwd='.'):\n    \"\"\"Execute a script from a working directory.\n\n    :param script_path: Absolute path to the script to run.\n    :param cwd: The directory to run the script from.\n    \"\"\"\n    run_thru_shell = sys.platform.startswith('win')\n    if script_path.endswith('.py'):\n        script_command = [sys.executable, script_path]\n    else:\n        script_command = [script_path]\n\n    utils.make_executable(script_path)\n\n    try:\n        proc = subprocess.Popen(\n            script_command,\n            shell=run_thru_shell,\n            cwd=cwd\n        )\n        exit_status = proc.wait()\n        if exit_status != EXIT_SUCCESS:\n            raise FailedHookException(\n                'Hook script failed (exit status: {})'.format(exit_status)\n            )\n    except OSError as os_error:\n        if os_error.errno == errno.ENOEXEC:\n            raise FailedHookException(\n                'Hook script failed, might be an '\n                'empty file or missing a shebang'\n            )\n        raise FailedHookException(\n            'Hook script failed (error: {})'.format(os_error)\n        )",
        "begin_line": 68,
        "end_line": 101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002277904328018223,
            "pseudo_dstar_susp": 0.002188183807439825,
            "pseudo_tarantula_susp": 0.002857142857142857,
            "pseudo_op2_susp": 0.002188183807439825,
            "pseudo_barinel_susp": 0.002857142857142857
        }
    },
    {
        "name": "cookiecutter.hooks.run_script_with_context#104",
        "src_path": "cookiecutter/hooks.py",
        "class_name": "cookiecutter.hooks",
        "signature": "cookiecutter.hooks.run_script_with_context(script_path, cwd, context)",
        "snippet": "def run_script_with_context(script_path, cwd, context):\n    \"\"\"Execute a script after rendering it with Jinja.\n\n    :param script_path: Absolute path to the script to run.\n    :param cwd: The directory to run the script from.\n    :param context: Cookiecutter project template context.\n    \"\"\"\n    _, extension = os.path.splitext(script_path)\n\n    contents = io.open(script_path, 'r', encoding='utf-8').read()\n\n    with tempfile.NamedTemporaryFile(\n        delete=False,\n        mode='wb',\n        suffix=extension\n    ) as temp:\n        env = StrictEnvironment(\n            context=context,\n            keep_trailing_newline=True,\n        )\n        template = env.from_string(contents)\n        output = template.render(**context)\n        temp.write(output.encode('utf-8'))\n\n    run_script(temp.name, cwd)",
        "begin_line": 104,
        "end_line": 128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002304147465437788,
            "pseudo_dstar_susp": 0.0022026431718061676,
            "pseudo_tarantula_susp": 0.0033783783783783786,
            "pseudo_op2_susp": 0.0022026431718061676,
            "pseudo_barinel_susp": 0.0033783783783783786
        }
    },
    {
        "name": "cookiecutter.hooks.run_hook#131",
        "src_path": "cookiecutter/hooks.py",
        "class_name": "cookiecutter.hooks",
        "signature": "cookiecutter.hooks.run_hook(hook_name, project_dir, context)",
        "snippet": "def run_hook(hook_name, project_dir, context):\n    \"\"\"\n    Try to find and execute a hook from the specified project directory.\n\n    :param hook_name: The hook to execute.\n    :param project_dir: The directory to execute the script from.\n    :param context: Cookiecutter project context.\n    \"\"\"\n    script = find_hook(hook_name)\n    if script is None:\n        logger.debug('No {} hook found'.format(hook_name))\n        return\n    logger.debug('Running hook {}'.format(hook_name))\n    run_script_with_context(script, project_dir, context)",
        "begin_line": 131,
        "end_line": 144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035335689045936395,
            "pseudo_dstar_susp": 0.16666666666666666,
            "pseudo_tarantula_susp": 0.003355704697986577,
            "pseudo_op2_susp": 0.16666666666666666,
            "pseudo_barinel_susp": 0.003355704697986577
        }
    },
    {
        "name": "cookiecutter.exceptions.UndefinedVariableInTemplate.__init__#95",
        "src_path": "cookiecutter/exceptions.py",
        "class_name": "cookiecutter.exceptions.UndefinedVariableInTemplate",
        "signature": "cookiecutter.exceptions.UndefinedVariableInTemplate.__init__(self, message, error, context)",
        "snippet": "    def __init__(self, message, error, context):\n        self.message = message\n        self.error = error\n        self.context = context",
        "begin_line": 95,
        "end_line": 98,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002331002331002331,
            "pseudo_dstar_susp": 0.0022222222222222222,
            "pseudo_tarantula_susp": 0.0034482758620689655,
            "pseudo_op2_susp": 0.0022222222222222222,
            "pseudo_barinel_susp": 0.0034482758620689655
        }
    },
    {
        "name": "cookiecutter.exceptions.UndefinedVariableInTemplate.__str__#100",
        "src_path": "cookiecutter/exceptions.py",
        "class_name": "cookiecutter.exceptions.UndefinedVariableInTemplate",
        "signature": "cookiecutter.exceptions.UndefinedVariableInTemplate.__str__(self)",
        "snippet": "    def __str__(self):\n        return (\n            \"{self.message}. \"\n            \"Error message: {self.error.message}. \"\n            \"Context: {self.context}\"\n        ).format(**locals())",
        "begin_line": 100,
        "end_line": 105,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003676470588235294,
            "pseudo_dstar_susp": 0.002304147465437788,
            "pseudo_tarantula_susp": 0.0036900369003690036,
            "pseudo_op2_susp": 0.002304147465437788,
            "pseudo_barinel_susp": 0.0036900369003690036
        }
    },
    {
        "name": "cookiecutter.vcs.identify_repo#26",
        "src_path": "cookiecutter/vcs.py",
        "class_name": "cookiecutter.vcs",
        "signature": "cookiecutter.vcs.identify_repo(repo_url)",
        "snippet": "def identify_repo(repo_url):\n    \"\"\"Determine if `repo_url` should be treated as a URL to a git or hg repo.\n\n    Repos can be identified by prepending \"hg+\" or \"git+\" to the repo URL.\n\n    :param repo_url: Repo URL of unknown type.\n    :returns: ('git', repo_url), ('hg', repo_url), or None.\n    \"\"\"\n    repo_url_values = repo_url.split('+')\n    if len(repo_url_values) == 2:\n        repo_type = repo_url_values[0]\n        if repo_type in [\"git\", \"hg\"]:\n            return repo_type, repo_url_values[1]\n        else:\n            raise UnknownRepoType\n    else:\n        if 'git' in repo_url:\n            return 'git', repo_url\n        elif 'bitbucket' in repo_url:\n            return 'hg', repo_url\n        else:\n            raise UnknownRepoType",
        "begin_line": 26,
        "end_line": 47,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002320185614849188,
            "pseudo_dstar_susp": 0.0022123893805309734,
            "pseudo_tarantula_susp": 0.0034129692832764505,
            "pseudo_op2_susp": 0.0022123893805309734,
            "pseudo_barinel_susp": 0.0034129692832764505
        }
    },
    {
        "name": "cookiecutter.vcs.is_vcs_installed#50",
        "src_path": "cookiecutter/vcs.py",
        "class_name": "cookiecutter.vcs",
        "signature": "cookiecutter.vcs.is_vcs_installed(repo_type)",
        "snippet": "def is_vcs_installed(repo_type):\n    \"\"\"\n    Check if the version control system for a repo type is installed.\n\n    :param repo_type:\n    \"\"\"\n    return bool(which(repo_type))",
        "begin_line": 50,
        "end_line": 56,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006060606060606061,
            "pseudo_dstar_susp": 0.003048780487804878,
            "pseudo_tarantula_susp": 0.006802721088435374,
            "pseudo_op2_susp": 0.003048780487804878,
            "pseudo_barinel_susp": 0.006802721088435374
        }
    },
    {
        "name": "cookiecutter.vcs.clone#59",
        "src_path": "cookiecutter/vcs.py",
        "class_name": "cookiecutter.vcs",
        "signature": "cookiecutter.vcs.clone(repo_url, checkout=None, clone_to_dir='.', no_input=False)",
        "snippet": "def clone(repo_url, checkout=None, clone_to_dir='.', no_input=False):\n    \"\"\"Clone a repo to the current directory.\n\n    :param repo_url: Repo URL of unknown type.\n    :param checkout: The branch, tag or commit ID to checkout after clone.\n    :param clone_to_dir: The directory to clone to.\n                         Defaults to the current directory.\n    :param no_input: Suppress all user prompts when calling via API.\n    \"\"\"\n    # Ensure that clone_to_dir exists\n    clone_to_dir = os.path.expanduser(clone_to_dir)\n    make_sure_path_exists(clone_to_dir)\n\n    # identify the repo_type\n    repo_type, repo_url = identify_repo(repo_url)\n\n    # check that the appropriate VCS for the repo_type is installed\n    if not is_vcs_installed(repo_type):\n        msg = \"'{0}' is not installed.\".format(repo_type)\n        raise VCSNotInstalled(msg)\n\n    repo_url = repo_url.rstrip('/')\n    tail = os.path.split(repo_url)[1]\n    if repo_type == 'git':\n        repo_dir = os.path.normpath(os.path.join(clone_to_dir,\n                                                 tail.rsplit('.git')[0]))\n    elif repo_type == 'hg':\n        repo_dir = os.path.normpath(os.path.join(clone_to_dir, tail))\n    logger.debug('repo_dir is {0}'.format(repo_dir))\n\n    if os.path.isdir(repo_dir):\n        clone = prompt_and_delete(repo_dir, no_input=no_input)\n    else:\n        clone = True\n\n    if clone:\n        try:\n            subprocess.check_output(\n                [repo_type, 'clone', repo_url],\n                cwd=clone_to_dir,\n                stderr=subprocess.STDOUT,\n            )\n            if checkout is not None:\n                subprocess.check_output(\n                    [repo_type, 'checkout', checkout],\n                    cwd=repo_dir,\n                    stderr=subprocess.STDOUT,\n                )\n        except subprocess.CalledProcessError as clone_error:\n            output = clone_error.output.decode('utf-8')\n            if 'not found' in output.lower():\n                raise RepositoryNotFound(\n                    'The repository {} could not be found, '\n                    'have you made a typo?'.format(repo_url)\n                )\n            if any(error in output for error in BRANCH_ERRORS):\n                raise RepositoryCloneFailed(\n                    'The {} branch of repository {} could not found, '\n                    'have you made a typo?'.format(checkout, repo_url)\n                )\n            raise\n\n    return repo_dir",
        "begin_line": 59,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006060606060606061,
            "pseudo_dstar_susp": 0.003048780487804878,
            "pseudo_tarantula_susp": 0.006802721088435374,
            "pseudo_op2_susp": 0.003048780487804878,
            "pseudo_barinel_susp": 0.006802721088435374
        }
    },
    {
        "name": "cookiecutter.cli.version_msg#27",
        "src_path": "cookiecutter/cli.py",
        "class_name": "cookiecutter.cli",
        "signature": "cookiecutter.cli.version_msg()",
        "snippet": "def version_msg():\n    \"\"\"Return the Cookiecutter version, location and Python powering it.\"\"\"\n    python_version = sys.version[:3]\n    location = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n    message = u'Cookiecutter %(version)s from {} (Python {})'\n    return message.format(location, python_version)",
        "begin_line": 27,
        "end_line": 32,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03125,
            "pseudo_dstar_susp": 0.02702702702702703,
            "pseudo_tarantula_susp": 0.006802721088435374,
            "pseudo_op2_susp": 0.02702702702702703,
            "pseudo_barinel_susp": 0.006802721088435374
        }
    },
    {
        "name": "cookiecutter.cli.validate_extra_context#35",
        "src_path": "cookiecutter/cli.py",
        "class_name": "cookiecutter.cli",
        "signature": "cookiecutter.cli.validate_extra_context(ctx, param, value)",
        "snippet": "def validate_extra_context(ctx, param, value):\n    \"\"\"Validate extra context.\"\"\"\n    for s in value:\n        if '=' not in s:\n            raise click.BadParameter(\n                'EXTRA_CONTEXT should contain items of the form key=value; '\n                \"'{}' doesn't match that form\".format(s)\n            )\n\n    # Convert tuple -- e.g.: (u'program_name=foobar', u'startsecs=66')\n    # to dict -- e.g.: {'program_name': 'foobar', 'startsecs': '66'}\n    return collections.OrderedDict(s.split('=', 1) for s in value) or None",
        "begin_line": 35,
        "end_line": 46,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03125,
            "pseudo_dstar_susp": 0.017241379310344827,
            "pseudo_tarantula_susp": 0.07692307692307693,
            "pseudo_op2_susp": 0.017241379310344827,
            "pseudo_barinel_susp": 0.07692307692307693
        }
    },
    {
        "name": "cookiecutter.cli.main#91",
        "src_path": "cookiecutter/cli.py",
        "class_name": "cookiecutter.cli",
        "signature": "cookiecutter.cli.main(template, extra_context, no_input, checkout, verbose, replay, overwrite_if_exists, output_dir, config_file, default_config, debug_file)",
        "snippet": "def main(\n        template, extra_context, no_input, checkout, verbose,\n        replay, overwrite_if_exists, output_dir, config_file,\n        default_config, debug_file):\n    \"\"\"Create a project from a Cookiecutter project template (TEMPLATE).\n\n    Cookiecutter is free and open source software, developed and managed by\n    volunteers. If you would like to help out or fund the project, please get\n    in touch at https://github.com/audreyr/cookiecutter.\n    \"\"\"\n    # If you _need_ to support a local template in a directory\n    # called 'help', use a qualified path to the directory.\n    if template == u'help':\n        click.echo(click.get_current_context().get_help())\n        sys.exit(0)\n\n    configure_logger(\n        stream_level='DEBUG' if verbose else 'INFO',\n        debug_file=debug_file,\n    )\n\n    try:\n        cookiecutter(\n            template, checkout, no_input,\n            extra_context=extra_context,\n            replay=replay,\n            overwrite_if_exists=overwrite_if_exists,\n            output_dir=output_dir,\n            config_file=config_file,\n            default_config=default_config,\n            password=os.environ.get('COOKIECUTTER_REPO_PASSWORD')\n        )\n    except (OutputDirExistsException,\n            InvalidModeException,\n            FailedHookException,\n            UnknownExtension,\n            InvalidZipRepository,\n            RepositoryNotFound,\n            RepositoryCloneFailed) as e:\n        click.echo(e)\n        sys.exit(1)\n    except UndefinedVariableInTemplate as undefined_err:\n        click.echo('{}'.format(undefined_err.message))\n        click.echo('Error message: {}'.format(undefined_err.error.message))\n\n        context_str = json.dumps(\n            undefined_err.context,\n            indent=4,\n            sort_keys=True\n        )\n        click.echo('Context: {}'.format(context_str))\n        sys.exit(1)",
        "begin_line": 91,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006060606060606061,
            "pseudo_dstar_susp": 0.003048780487804878,
            "pseudo_tarantula_susp": 0.006802721088435374,
            "pseudo_op2_susp": 0.003048780487804878,
            "pseudo_barinel_susp": 0.006802721088435374
        }
    },
    {
        "name": "cookiecutter.replay.get_file_name#17",
        "src_path": "cookiecutter/replay.py",
        "class_name": "cookiecutter.replay",
        "signature": "cookiecutter.replay.get_file_name(replay_dir, template_name)",
        "snippet": "def get_file_name(replay_dir, template_name):\n    file_name = '{}.json'.format(template_name)\n    return os.path.join(replay_dir, file_name)",
        "begin_line": 17,
        "end_line": 19,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002173913043478261,
            "pseudo_dstar_susp": 0.002173913043478261,
            "pseudo_tarantula_susp": 0.0023148148148148147,
            "pseudo_op2_susp": 0.002173913043478261,
            "pseudo_barinel_susp": 0.0023148148148148147
        }
    },
    {
        "name": "cookiecutter.replay.dump#22",
        "src_path": "cookiecutter/replay.py",
        "class_name": "cookiecutter.replay",
        "signature": "cookiecutter.replay.dump(replay_dir, template_name, context)",
        "snippet": "def dump(replay_dir, template_name, context):\n    if not make_sure_path_exists(replay_dir):\n        raise IOError('Unable to create replay dir at {}'.format(replay_dir))\n\n    if not isinstance(template_name, basestring):\n        raise TypeError('Template name is required to be of type str')\n\n    if not isinstance(context, dict):\n        raise TypeError('Context is required to be of type dict')\n\n    if 'cookiecutter' not in context:\n        raise ValueError('Context is required to contain a cookiecutter key')\n\n    replay_file = get_file_name(replay_dir, template_name)\n\n    with open(replay_file, 'w') as outfile:\n        json.dump(context, outfile)",
        "begin_line": 22,
        "end_line": 38,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0021691973969631237,
            "pseudo_dstar_susp": 0.0021691973969631237,
            "pseudo_tarantula_susp": 0.00228310502283105,
            "pseudo_op2_susp": 0.0021691973969631237,
            "pseudo_barinel_susp": 0.00228310502283105
        }
    },
    {
        "name": "cookiecutter.replay.load#41",
        "src_path": "cookiecutter/replay.py",
        "class_name": "cookiecutter.replay",
        "signature": "cookiecutter.replay.load(replay_dir, template_name)",
        "snippet": "def load(replay_dir, template_name):\n    if not isinstance(template_name, basestring):\n        raise TypeError('Template name is required to be of type str')\n\n    replay_file = get_file_name(replay_dir, template_name)\n\n    with open(replay_file, 'r') as infile:\n        context = json.load(infile)\n\n    if 'cookiecutter' not in context:\n        raise ValueError('Context is required to contain a cookiecutter key')\n\n    return context",
        "begin_line": 41,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003676470588235294,
            "pseudo_dstar_susp": 0.002304147465437788,
            "pseudo_tarantula_susp": 0.0036900369003690036,
            "pseudo_op2_susp": 0.002304147465437788,
            "pseudo_barinel_susp": 0.0036900369003690036
        }
    },
    {
        "name": "cookiecutter.prompt.read_user_variable#24",
        "src_path": "cookiecutter/prompt.py",
        "class_name": "cookiecutter.prompt",
        "signature": "cookiecutter.prompt.read_user_variable(var_name, default_value)",
        "snippet": "def read_user_variable(var_name, default_value):\n    \"\"\"Prompt the user for the given variable and return the entered value\n    or the given default.\n\n    :param str var_name: Variable of the context to query the user\n    :param default_value: Value that will be returned if no input happens\n    \"\"\"\n    # Please see http://click.pocoo.org/4/api/#click.prompt\n    return click.prompt(var_name, default=default_value)",
        "begin_line": 24,
        "end_line": 32,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006060606060606061,
            "pseudo_dstar_susp": 0.003048780487804878,
            "pseudo_tarantula_susp": 0.006802721088435374,
            "pseudo_op2_susp": 0.003048780487804878,
            "pseudo_barinel_susp": 0.006802721088435374
        }
    },
    {
        "name": "cookiecutter.prompt.read_user_yes_no#35",
        "src_path": "cookiecutter/prompt.py",
        "class_name": "cookiecutter.prompt",
        "signature": "cookiecutter.prompt.read_user_yes_no(question, default_value)",
        "snippet": "def read_user_yes_no(question, default_value):\n    \"\"\"Prompt the user to reply with 'yes' or 'no' (or equivalent values).\n\n    Note:\n      Possible choices are 'true', '1', 'yes', 'y' or 'false', '0', 'no', 'n'\n\n    :param str question: Question to the user\n    :param default_value: Value that will be returned if no input happens\n    \"\"\"\n    # Please see http://click.pocoo.org/4/api/#click.prompt\n    return click.prompt(\n        question,\n        default=default_value,\n        type=click.BOOL\n    )",
        "begin_line": 35,
        "end_line": 49,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006060606060606061,
            "pseudo_dstar_susp": 0.003048780487804878,
            "pseudo_tarantula_susp": 0.006802721088435374,
            "pseudo_op2_susp": 0.003048780487804878,
            "pseudo_barinel_susp": 0.006802721088435374
        }
    },
    {
        "name": "cookiecutter.prompt.read_repo_password#52",
        "src_path": "cookiecutter/prompt.py",
        "class_name": "cookiecutter.prompt",
        "signature": "cookiecutter.prompt.read_repo_password(question)",
        "snippet": "def read_repo_password(question):\n    \"\"\"Prompt the user to enter a password\n\n    :param str question: Question to the user\n    \"\"\"\n    # Please see http://click.pocoo.org/4/api/#click.prompt\n    return click.prompt(question, hide_input=True)",
        "begin_line": 52,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006060606060606061,
            "pseudo_dstar_susp": 0.003048780487804878,
            "pseudo_tarantula_susp": 0.006802721088435374,
            "pseudo_op2_susp": 0.003048780487804878,
            "pseudo_barinel_susp": 0.006802721088435374
        }
    },
    {
        "name": "cookiecutter.prompt.read_user_choice#61",
        "src_path": "cookiecutter/prompt.py",
        "class_name": "cookiecutter.prompt",
        "signature": "cookiecutter.prompt.read_user_choice(var_name, options)",
        "snippet": "def read_user_choice(var_name, options):\n    \"\"\"Prompt the user to choose from several options for the given variable.\n\n    The first item will be returned if no input happens.\n\n    :param str var_name: Variable as specified in the context\n    :param list options: Sequence of options that are available to select from\n    :return: Exactly one item of ``options`` that has been chosen by the user\n    \"\"\"\n    # Please see http://click.pocoo.org/4/api/#click.prompt\n    if not isinstance(options, list):\n        raise TypeError\n\n    if not options:\n        raise ValueError\n\n    choice_map = OrderedDict(\n        (u'{}'.format(i), value) for i, value in enumerate(options, 1)\n    )\n    choices = choice_map.keys()\n    default = u'1'\n\n    choice_lines = [u'{} - {}'.format(*c) for c in choice_map.items()]\n    prompt = u'\\n'.join((\n        u'Select {}:'.format(var_name),\n        u'\\n'.join(choice_lines),\n        u'Choose from {}'.format(u', '.join(choices))\n    ))\n\n    user_choice = click.prompt(\n        prompt, type=click.Choice(choices), default=default\n    )\n    return choice_map[user_choice]",
        "begin_line": 61,
        "end_line": 93,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.003676470588235294,
            "pseudo_dstar_susp": 0.002304147465437788,
            "pseudo_tarantula_susp": 0.0036900369003690036,
            "pseudo_op2_susp": 0.002304147465437788,
            "pseudo_barinel_susp": 0.0036900369003690036
        }
    },
    {
        "name": "cookiecutter.prompt.process_json#96",
        "src_path": "cookiecutter/prompt.py",
        "class_name": "cookiecutter.prompt",
        "signature": "cookiecutter.prompt.process_json(user_value)",
        "snippet": "def process_json(user_value):\n    try:\n        user_dict = json.loads(\n            user_value,\n            object_pairs_hook=OrderedDict,\n        )\n    except Exception:\n        # Leave it up to click to ask the user again\n        raise click.UsageError('Unable to decode to JSON.')\n\n    if not isinstance(user_dict, dict):\n        # Leave it up to click to ask the user again\n        raise click.UsageError('Requires JSON dict.')\n\n    return user_dict",
        "begin_line": 96,
        "end_line": 110,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003401360544217687,
            "pseudo_dstar_susp": 0.002257336343115124,
            "pseudo_tarantula_susp": 0.0035587188612099642,
            "pseudo_op2_susp": 0.002257336343115124,
            "pseudo_barinel_susp": 0.0035587188612099642
        }
    },
    {
        "name": "cookiecutter.prompt.read_user_dict#113",
        "src_path": "cookiecutter/prompt.py",
        "class_name": "cookiecutter.prompt",
        "signature": "cookiecutter.prompt.read_user_dict(var_name, default_value)",
        "snippet": "def read_user_dict(var_name, default_value):\n    \"\"\"Prompt the user to provide a dictionary of data.\n\n    :param str var_name: Variable as specified in the context\n    :param default_value: Value that will be returned if no input is provided\n    :return: A Python dictionary to use in the context.\n    \"\"\"\n    # Please see http://click.pocoo.org/4/api/#click.prompt\n    if not isinstance(default_value, dict):\n        raise TypeError\n\n    default_display = 'default'\n\n    user_value = click.prompt(\n        var_name,\n        default=default_display,\n        type=click.STRING,\n        value_proc=process_json,\n    )\n\n    if user_value == default_display:\n        # Return the given default w/o any processing\n        return default_value\n    return user_value",
        "begin_line": 113,
        "end_line": 136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006060606060606061,
            "pseudo_dstar_susp": 0.003048780487804878,
            "pseudo_tarantula_susp": 0.006802721088435374,
            "pseudo_op2_susp": 0.003048780487804878,
            "pseudo_barinel_susp": 0.006802721088435374
        }
    },
    {
        "name": "cookiecutter.prompt.render_variable#139",
        "src_path": "cookiecutter/prompt.py",
        "class_name": "cookiecutter.prompt",
        "signature": "cookiecutter.prompt.render_variable(env, raw, cookiecutter_dict)",
        "snippet": "def render_variable(env, raw, cookiecutter_dict):\n    \"\"\"Inside the prompting taken from the cookiecutter.json file, this renders\n    the next variable. For example, if a project_name is \"Peanut Butter\n    Cookie\", the repo_name could be be rendered with:\n\n        `{{ cookiecutter.project_name.replace(\" \", \"_\") }}`.\n\n    This is then presented to the user as the default.\n\n    :param Environment env: A Jinja2 Environment object.\n    :param str raw: The next value to be prompted for by the user.\n    :param dict cookiecutter_dict: The current context as it's gradually\n        being populated with variables.\n    :return: The rendered value for the default variable.\n    \"\"\"\n    if raw is None:\n        return None\n    elif isinstance(raw, dict):\n        return {\n            render_variable(env, k, cookiecutter_dict):\n                render_variable(env, v, cookiecutter_dict)\n            for k, v in raw.items()\n        }\n    elif isinstance(raw, list):\n        return [\n            render_variable(env, v, cookiecutter_dict)\n            for v in raw\n        ]\n    elif not isinstance(raw, basestring):\n        raw = str(raw)\n\n    template = env.from_string(raw)\n\n    rendered_template = template.render(cookiecutter=cookiecutter_dict)\n    return rendered_template",
        "begin_line": 139,
        "end_line": 173,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020491803278688526,
            "pseudo_dstar_susp": 0.0020491803278688526,
            "pseudo_tarantula_susp": 0.00205761316872428,
            "pseudo_op2_susp": 0.0020491803278688526,
            "pseudo_barinel_susp": 0.00205761316872428
        }
    },
    {
        "name": "cookiecutter.prompt.prompt_choice_for_config#176",
        "src_path": "cookiecutter/prompt.py",
        "class_name": "cookiecutter.prompt",
        "signature": "cookiecutter.prompt.prompt_choice_for_config(cookiecutter_dict, env, key, options, no_input)",
        "snippet": "def prompt_choice_for_config(cookiecutter_dict, env, key, options, no_input):\n    \"\"\"Prompt the user which option to choose from the given. Each of the\n    possible choices is rendered beforehand.\n    \"\"\"\n    rendered_options = [\n        render_variable(env, raw, cookiecutter_dict) for raw in options\n    ]\n\n    if no_input:\n        return rendered_options[0]\n    return read_user_choice(key, rendered_options)",
        "begin_line": 176,
        "end_line": 186,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003676470588235294,
            "pseudo_dstar_susp": 0.002304147465437788,
            "pseudo_tarantula_susp": 0.0036900369003690036,
            "pseudo_op2_susp": 0.002304147465437788,
            "pseudo_barinel_susp": 0.0036900369003690036
        }
    },
    {
        "name": "cookiecutter.prompt.prompt_for_config#189",
        "src_path": "cookiecutter/prompt.py",
        "class_name": "cookiecutter.prompt",
        "signature": "cookiecutter.prompt.prompt_for_config(context, no_input=False)",
        "snippet": "def prompt_for_config(context, no_input=False):\n    \"\"\"\n    Prompts the user to enter new config, using context as a source for the\n    field names and sample values.\n\n    :param no_input: Prompt the user at command line for manual configuration?\n    \"\"\"\n    cookiecutter_dict = OrderedDict([])\n    env = StrictEnvironment(context=context)\n\n    # First pass: Handle simple and raw variables, plus choices.\n    # These must be done first because the dictionaries keys and\n    # values might refer to them.\n    for key, raw in iteritems(context[u'cookiecutter']):\n        if key.startswith(u'_'):\n            cookiecutter_dict[key] = raw\n            continue\n\n        try:\n            if isinstance(raw, list):\n                # We are dealing with a choice variable\n                val = prompt_choice_for_config(\n                    cookiecutter_dict, env, key, raw, no_input\n                )\n                cookiecutter_dict[key] = val\n            elif not isinstance(raw, dict):\n                # We are dealing with a regular variable\n                val = render_variable(env, raw, cookiecutter_dict)\n\n                if not no_input:\n                    val = read_user_variable(key, val)\n\n                cookiecutter_dict[key] = val\n        except UndefinedError as err:\n            msg = \"Unable to render variable '{}'\".format(key)\n            raise UndefinedVariableInTemplate(msg, err, context)\n\n    # Second pass; handle the dictionaries.\n    for key, raw in iteritems(context[u'cookiecutter']):\n\n        try:\n            if isinstance(raw, dict):\n                # We are dealing with a dict variable\n                val = render_variable(env, raw, cookiecutter_dict)\n\n                if not no_input:\n                    val = read_user_dict(key, val)\n\n                cookiecutter_dict[key] = val\n        except UndefinedError as err:\n            msg = \"Unable to render variable '{}'\".format(key)\n            raise UndefinedVariableInTemplate(msg, err, context)\n\n    return cookiecutter_dict",
        "begin_line": 189,
        "end_line": 242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002004008016032064,
            "pseudo_dstar_susp": 0.002004008016032064,
            "pseudo_tarantula_susp": 0.002012072434607646,
            "pseudo_op2_susp": 0.002004008016032064,
            "pseudo_barinel_susp": 0.002012072434607646
        }
    },
    {
        "name": "cookiecutter.main.cookiecutter#25",
        "src_path": "cookiecutter/main.py",
        "class_name": "cookiecutter.main",
        "signature": "cookiecutter.main.cookiecutter(template, checkout=None, no_input=False, extra_context=None, replay=False, overwrite_if_exists=False, output_dir='.', config_file=None, default_config=False, password=None)",
        "snippet": "def cookiecutter(\n        template, checkout=None, no_input=False, extra_context=None,\n        replay=False, overwrite_if_exists=False, output_dir='.',\n        config_file=None, default_config=False, password=None):\n    \"\"\"\n    Run Cookiecutter just as if using it from the command line.\n\n    :param template: A directory containing a project template directory,\n        or a URL to a git repository.\n    :param checkout: The branch, tag or commit ID to checkout after clone.\n    :param no_input: Prompt the user at command line for manual configuration?\n    :param extra_context: A dictionary of context that overrides default\n        and user configuration.\n    :param: overwrite_if_exists: Overwrite the contents of output directory\n        if it exists\n    :param output_dir: Where to output the generated project dir into.\n    :param config_file: User configuration file path.\n    :param default_config: Use default values rather than a config file.\n    :param password: The password to use when extracting the repository.\n    \"\"\"\n    if replay and ((no_input is not False) or (extra_context is not None)):\n        err_msg = (\n            \"You can not use both replay and no_input or extra_context \"\n            \"at the same time.\"\n        )\n        raise InvalidModeException(err_msg)\n\n    config_dict = get_user_config(\n        config_file=config_file,\n        default_config=default_config,\n    )\n\n    repo_dir, cleanup = determine_repo_dir(\n        template=template,\n        abbreviations=config_dict['abbreviations'],\n        clone_to_dir=config_dict['cookiecutters_dir'],\n        checkout=checkout,\n        no_input=no_input,\n        password=password\n    )\n\n    template_name = os.path.basename(os.path.abspath(repo_dir))\n\n    if replay:\n        context = load(config_dict['replay_dir'], template_name)\n    else:\n        context_file = os.path.join(repo_dir, 'cookiecutter.json')\n        logger.debug('context_file is {}'.format(context_file))\n\n        context = generate_context(\n            context_file=context_file,\n            default_context=config_dict['default_context'],\n            extra_context=extra_context,\n        )\n\n        # prompt the user to manually configure at the command line.\n        # except when 'no-input' flag is set\n        context['cookiecutter'] = prompt_for_config(context, no_input)\n\n        # include template dir or url in the context dict\n        context['cookiecutter']['_template'] = template\n\n        dump(config_dict['replay_dir'], template_name, context)\n\n    # Create project from local context and project template.\n    result = generate_files(\n        repo_dir=repo_dir,\n        context=context,\n        overwrite_if_exists=overwrite_if_exists,\n        output_dir=output_dir\n    )\n\n    # Cleanup (if required)\n    if cleanup:\n        rmtree(repo_dir)\n\n    return result",
        "begin_line": 25,
        "end_line": 101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0021645021645021645,
            "pseudo_dstar_susp": 0.0021645021645021645,
            "pseudo_tarantula_susp": 0.002277904328018223,
            "pseudo_op2_susp": 0.0021645021645021645,
            "pseudo_barinel_susp": 0.002277904328018223
        }
    }
]