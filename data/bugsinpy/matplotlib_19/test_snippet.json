[
    {
        "name": "lib.matplotlib.tests.test_axes.test_get_labels#37",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_get_labels()",
        "snippet": "def test_get_labels():\n    fig, ax = plt.subplots()\n    ax.set_xlabel('x label')\n    ax.set_ylabel('y label')\n    assert ax.get_xlabel() == 'x label'\n    assert ax.get_ylabel() == 'y label'",
        "begin_line": 37,
        "end_line": 42,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_label_loc_vertical#46",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_label_loc_vertical(fig_test, fig_ref)",
        "snippet": "def test_label_loc_vertical(fig_test, fig_ref):\n    ax = fig_test.subplots()\n    sc = ax.scatter([1, 2], [1, 2], c=[1, 2])\n    ax.set_ylabel('Y Label', loc='top')\n    ax.set_xlabel('X Label', loc='right')\n    cbar = fig_test.colorbar(sc)\n    cbar.set_label(\"Z Label\", loc='top')\n\n    ax = fig_ref.subplots()\n    sc = ax.scatter([1, 2], [1, 2], c=[1, 2])\n    ax.set_ylabel('Y Label', y=1, ha='right')\n    ax.set_xlabel('X Label', x=1, ha='right')\n    cbar = fig_ref.colorbar(sc)\n    cbar.set_label(\"Z Label\", y=1, ha='right')",
        "begin_line": 46,
        "end_line": 59,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_label_loc_horizontal#63",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_label_loc_horizontal(fig_test, fig_ref)",
        "snippet": "def test_label_loc_horizontal(fig_test, fig_ref):\n    ax = fig_test.subplots()\n    sc = ax.scatter([1, 2], [1, 2], c=[1, 2])\n    ax.set_ylabel('Y Label', loc='bottom')\n    ax.set_xlabel('X Label', loc='left')\n    cbar = fig_test.colorbar(sc, orientation='horizontal')\n    cbar.set_label(\"Z Label\", loc='left')\n\n    ax = fig_ref.subplots()\n    sc = ax.scatter([1, 2], [1, 2], c=[1, 2])\n    ax.set_ylabel('Y Label', y=0, ha='left')\n    ax.set_xlabel('X Label', x=0, ha='left')\n    cbar = fig_ref.colorbar(sc, orientation='horizontal')\n    cbar.set_label(\"Z Label\", x=0, ha='left')",
        "begin_line": 63,
        "end_line": 76,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_label_loc_rc#80",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_label_loc_rc(fig_test, fig_ref)",
        "snippet": "def test_label_loc_rc(fig_test, fig_ref):\n    with matplotlib.rc_context({\"xaxis.labellocation\": \"right\",\n                                \"yaxis.labellocation\": \"top\"}):\n        ax = fig_test.subplots()\n        sc = ax.scatter([1, 2], [1, 2], c=[1, 2])\n        ax.set_ylabel('Y Label')\n        ax.set_xlabel('X Label')\n        cbar = fig_test.colorbar(sc, orientation='horizontal')\n        cbar.set_label(\"Z Label\")\n\n    ax = fig_ref.subplots()\n    sc = ax.scatter([1, 2], [1, 2], c=[1, 2])\n    ax.set_ylabel('Y Label', y=1, ha='right')\n    ax.set_xlabel('X Label', x=1, ha='right')\n    cbar = fig_ref.colorbar(sc, orientation='horizontal')\n    cbar.set_label(\"Z Label\", x=1, ha='right')",
        "begin_line": 80,
        "end_line": 95,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_acorr#99",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_acorr()",
        "snippet": "def test_acorr():\n    # Remove this line when this test image is regenerated.\n    plt.rcParams['text.kerning_factor'] = 6\n\n    np.random.seed(19680801)\n    n = 512\n    x = np.random.normal(0, 1, n).cumsum()\n\n    fig, ax = plt.subplots()\n    ax.acorr(x, maxlags=n - 1, label='acorr')\n    ax.legend()",
        "begin_line": 99,
        "end_line": 109,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_spy#113",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_spy()",
        "snippet": "def test_spy():\n    np.random.seed(19680801)\n    a = np.ones(32 * 32)\n    a[:16 * 32] = 0\n    np.random.shuffle(a)\n    a = np.reshape(a, (32, 32))\n\n    fig, ax = plt.subplots()\n    ax.spy(a)",
        "begin_line": 113,
        "end_line": 121,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_spy_invalid_kwargs#124",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_spy_invalid_kwargs()",
        "snippet": "def test_spy_invalid_kwargs():\n    fig, ax = plt.subplots()\n    for unsupported_kw in [{'interpolation': 'nearest'},\n                           {'marker': 'o', 'linestyle': 'solid'}]:\n        with pytest.raises(TypeError):\n            ax.spy(np.eye(3, 3), **unsupported_kw)",
        "begin_line": 124,
        "end_line": 129,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_matshow#133",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_matshow()",
        "snippet": "def test_matshow():\n    np.random.seed(19680801)\n    a = np.random.rand(32, 32)\n\n    fig, ax = plt.subplots()\n    ax.matshow(a)",
        "begin_line": 133,
        "end_line": 138,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_formatter_ticker#147",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_formatter_ticker()",
        "snippet": "def test_formatter_ticker():\n    import matplotlib.testing.jpl_units as units\n    units.register()\n\n    # This should affect the tick size.  (Tests issue #543)\n    matplotlib.rcParams['lines.markeredgewidth'] = 30\n\n    # This essentially test to see if user specified labels get overwritten\n    # by the auto labeler functionality of the axes.\n    xdata = [x*units.sec for x in range(10)]\n    ydata1 = [(1.5*y - 0.5)*units.km for y in range(10)]\n    ydata2 = [(1.75*y - 1.0)*units.km for y in range(10)]\n\n    ax = plt.figure().subplots()\n    ax.set_xlabel(\"x-label 001\")\n\n    ax = plt.figure().subplots()\n    ax.set_xlabel(\"x-label 001\")\n    ax.plot(xdata, ydata1, color='blue', xunits=\"sec\")\n\n    ax = plt.figure().subplots()\n    ax.set_xlabel(\"x-label 001\")\n    ax.plot(xdata, ydata1, color='blue', xunits=\"sec\")\n    ax.set_xlabel(\"x-label 003\")\n\n    ax = plt.figure().subplots()\n    ax.plot(xdata, ydata1, color='blue', xunits=\"sec\")\n    ax.plot(xdata, ydata2, color='green', xunits=\"hour\")\n    ax.set_xlabel(\"x-label 004\")\n\n    # See SF bug 2846058\n    # https://sourceforge.net/tracker/?func=detail&aid=2846058&group_id=80706&atid=560720\n    ax = plt.figure().subplots()\n    ax.plot(xdata, ydata1, color='blue', xunits=\"sec\")\n    ax.plot(xdata, ydata2, color='green', xunits=\"hour\")\n    ax.set_xlabel(\"x-label 005\")\n    ax.autoscale_view()",
        "begin_line": 147,
        "end_line": 183,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twin_axis_locators_formatters#187",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twin_axis_locators_formatters()",
        "snippet": "def test_twin_axis_locators_formatters():\n    vals = np.linspace(0, 1, num=5, endpoint=True)\n    locs = np.sin(np.pi * vals / 2.0)\n\n    majl = plt.FixedLocator(locs)\n    minl = plt.FixedLocator([0.1, 0.2, 0.3])\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(1, 1, 1)\n    ax1.plot([0.1, 100], [0, 1])\n    ax1.yaxis.set_major_locator(majl)\n    ax1.yaxis.set_minor_locator(minl)\n    ax1.yaxis.set_major_formatter(plt.FormatStrFormatter('%08.2lf'))\n    ax1.yaxis.set_minor_formatter(plt.FixedFormatter(['tricks', 'mind',\n                                                      'jedi']))\n\n    ax1.xaxis.set_major_locator(plt.LinearLocator())\n    ax1.xaxis.set_minor_locator(plt.FixedLocator([15, 35, 55, 75]))\n    ax1.xaxis.set_major_formatter(plt.FormatStrFormatter('%05.2lf'))\n    ax1.xaxis.set_minor_formatter(plt.FixedFormatter(['c', '3', 'p', 'o']))\n    ax1.twiny()\n    ax1.twinx()",
        "begin_line": 187,
        "end_line": 208,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twinx_cla#211",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twinx_cla()",
        "snippet": "def test_twinx_cla():\n    fig, ax = plt.subplots()\n    ax2 = ax.twinx()\n    ax3 = ax2.twiny()\n    plt.draw()\n    assert not ax2.xaxis.get_visible()\n    assert not ax2.patch.get_visible()\n    ax2.cla()\n    ax3.cla()\n\n    assert not ax2.xaxis.get_visible()\n    assert not ax2.patch.get_visible()\n    assert ax2.yaxis.get_visible()\n\n    assert ax3.xaxis.get_visible()\n    assert not ax3.patch.get_visible()\n    assert not ax3.yaxis.get_visible()\n\n    assert ax.xaxis.get_visible()\n    assert ax.patch.get_visible()\n    assert ax.yaxis.get_visible()",
        "begin_line": 211,
        "end_line": 231,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twinx_axis_scales#235",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twinx_axis_scales()",
        "snippet": "def test_twinx_axis_scales():\n    x = np.array([0, 0.5, 1])\n    y = 0.5 * x\n    x2 = np.array([0, 1, 2])\n    y2 = 2 * x2\n\n    fig = plt.figure()\n    ax = fig.add_axes((0, 0, 1, 1), autoscalex_on=False, autoscaley_on=False)\n    ax.plot(x, y, color='blue', lw=10)\n\n    ax2 = plt.twinx(ax)\n    ax2.plot(x2, y2, 'r--', lw=5)\n\n    ax.margins(0, 0)\n    ax2.margins(0, 0)",
        "begin_line": 235,
        "end_line": 249,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twin_inherit_autoscale_setting#252",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twin_inherit_autoscale_setting()",
        "snippet": "def test_twin_inherit_autoscale_setting():\n    fig, ax = plt.subplots()\n    ax_x_on = ax.twinx()\n    ax.set_autoscalex_on(False)\n    ax_x_off = ax.twinx()\n\n    assert ax_x_on.get_autoscalex_on()\n    assert not ax_x_off.get_autoscalex_on()\n\n    ax_y_on = ax.twiny()\n    ax.set_autoscaley_on(False)\n    ax_y_off = ax.twiny()\n\n    assert ax_y_on.get_autoscaley_on()\n    assert not ax_y_off.get_autoscaley_on()",
        "begin_line": 252,
        "end_line": 266,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_inverted_cla#269",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_inverted_cla()",
        "snippet": "def test_inverted_cla():\n    # GitHub PR #5450. Setting autoscale should reset\n    # axes to be non-inverted.\n    # plotting an image, then 1d graph, axis is now down\n    fig = plt.figure(0)\n    ax = fig.gca()\n    # 1. test that a new axis is not inverted per default\n    assert not ax.xaxis_inverted()\n    assert not ax.yaxis_inverted()\n    img = np.random.random((100, 100))\n    ax.imshow(img)\n    # 2. test that a image axis is inverted\n    assert not ax.xaxis_inverted()\n    assert ax.yaxis_inverted()\n    # 3. test that clearing and plotting a line, axes are\n    # not inverted\n    ax.cla()\n    x = np.linspace(0, 2*np.pi, 100)\n    ax.plot(x, np.cos(x))\n    assert not ax.xaxis_inverted()\n    assert not ax.yaxis_inverted()\n\n    # 4. autoscaling should not bring back axes to normal\n    ax.cla()\n    ax.imshow(img)\n    plt.autoscale()\n    assert not ax.xaxis_inverted()\n    assert ax.yaxis_inverted()\n\n    # 5. two shared axes. Inverting the master axis should invert the shared\n    # axes; clearing the master axis should bring axes in shared\n    # axes back to normal.\n    ax0 = plt.subplot(211)\n    ax1 = plt.subplot(212, sharey=ax0)\n    ax0.yaxis.set_inverted(True)\n    assert ax1.yaxis_inverted()\n    ax1.plot(x, np.cos(x))\n    ax0.cla()\n    assert not ax1.yaxis_inverted()\n    ax1.cla()\n    # 6. clearing the nonmaster should not touch limits\n    ax0.imshow(img)\n    ax1.plot(x, np.cos(x))\n    ax1.cla()\n    assert ax.yaxis_inverted()\n\n    # clean up\n    plt.close(fig)",
        "begin_line": 269,
        "end_line": 316,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_minorticks_on_rcParams_both#320",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_minorticks_on_rcParams_both(fig_test, fig_ref)",
        "snippet": "def test_minorticks_on_rcParams_both(fig_test, fig_ref):\n    with matplotlib.rc_context({\"xtick.minor.visible\": True,\n                                \"ytick.minor.visible\": True}):\n        ax_test = fig_test.subplots()\n        ax_test.plot([0, 1], [0, 1])\n    ax_ref = fig_ref.subplots()\n    ax_ref.plot([0, 1], [0, 1])\n    ax_ref.minorticks_on()",
        "begin_line": 320,
        "end_line": 327,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_autoscale_tiny_range#331",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_autoscale_tiny_range()",
        "snippet": "def test_autoscale_tiny_range():\n    # github pull #904\n    fig, axs = plt.subplots(2, 2)\n    for i, ax in enumerate(axs.flat):\n        y1 = 10**(-11 - i)\n        ax.plot([0, 1], [1, 1 + y1])",
        "begin_line": 331,
        "end_line": 336,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_autoscale_tight#340",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_autoscale_tight()",
        "snippet": "def test_autoscale_tight():\n    fig, ax = plt.subplots(1, 1)\n    ax.plot([1, 2, 3, 4])\n    ax.autoscale(enable=True, axis='x', tight=False)\n    ax.autoscale(enable=True, axis='y', tight=True)\n    assert_allclose(ax.get_xlim(), (-0.15, 3.15))\n    assert_allclose(ax.get_ylim(), (1.0, 4.0))",
        "begin_line": 340,
        "end_line": 346,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_autoscale_log_shared#350",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_autoscale_log_shared()",
        "snippet": "def test_autoscale_log_shared():\n    # related to github #7587\n    # array starts at zero to trigger _minpos handling\n    x = np.arange(100, dtype=float)\n    fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\n    ax1.loglog(x, x)\n    ax2.semilogx(x, x)\n    ax1.autoscale(tight=True)\n    ax2.autoscale(tight=True)\n    plt.draw()\n    lims = (x[1], x[-1])\n    assert_allclose(ax1.get_xlim(), lims)\n    assert_allclose(ax1.get_ylim(), lims)\n    assert_allclose(ax2.get_xlim(), lims)\n    assert_allclose(ax2.get_ylim(), (x[0], x[-1]))",
        "begin_line": 350,
        "end_line": 364,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_use_sticky_edges#368",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_use_sticky_edges()",
        "snippet": "def test_use_sticky_edges():\n    fig, ax = plt.subplots()\n    ax.imshow([[0, 1], [2, 3]], origin='lower')\n    assert_allclose(ax.get_xlim(), (-0.5, 1.5))\n    assert_allclose(ax.get_ylim(), (-0.5, 1.5))\n    ax.use_sticky_edges = False\n    ax.autoscale()\n    xlim = (-0.5 - 2 * ax._xmargin, 1.5 + 2 * ax._xmargin)\n    ylim = (-0.5 - 2 * ax._ymargin, 1.5 + 2 * ax._ymargin)\n    assert_allclose(ax.get_xlim(), xlim)\n    assert_allclose(ax.get_ylim(), ylim)\n    # Make sure it is reversible:\n    ax.use_sticky_edges = True\n    ax.autoscale()\n    assert_allclose(ax.get_xlim(), (-0.5, 1.5))\n    assert_allclose(ax.get_ylim(), (-0.5, 1.5))",
        "begin_line": 368,
        "end_line": 383,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_basic_annotate#387",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_basic_annotate()",
        "snippet": "def test_basic_annotate():\n    # Setup some data\n    t = np.arange(0.0, 5.0, 0.01)\n    s = np.cos(2.0*np.pi * t)\n\n    # Offset Points\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, autoscale_on=False, xlim=(-1, 5), ylim=(-3, 5))\n    line, = ax.plot(t, s, lw=3, color='purple')\n\n    ax.annotate('local max', xy=(3, 1), xycoords='data',\n                xytext=(3, 3), textcoords='offset points')",
        "begin_line": 387,
        "end_line": 399,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_arrow_simple#403",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_arrow_simple()",
        "snippet": "def test_arrow_simple():\n    # Simple image test for ax.arrow\n    # kwargs that take discrete values\n    length_includes_head = (True, False)\n    shape = ('full', 'left', 'right')\n    head_starts_at_zero = (True, False)\n    # Create outer product of values\n    kwargs = product(length_includes_head, shape, head_starts_at_zero)\n\n    fig, axs = plt.subplots(3, 4)\n    for i, (ax, kwarg) in enumerate(zip(axs.flat, kwargs)):\n        ax.set_xlim(-2, 2)\n        ax.set_ylim(-2, 2)\n        # Unpack kwargs\n        (length_includes_head, shape, head_starts_at_zero) = kwarg\n        theta = 2 * np.pi * i / 12\n        # Draw arrow\n        ax.arrow(0, 0, np.sin(theta), np.cos(theta),\n                 width=theta/100,\n                 length_includes_head=length_includes_head,\n                 shape=shape,\n                 head_starts_at_zero=head_starts_at_zero,\n                 head_width=theta / 10,\n                 head_length=theta / 10)",
        "begin_line": 403,
        "end_line": 426,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_arrow_empty#429",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_arrow_empty()",
        "snippet": "def test_arrow_empty():\n    _, ax = plt.subplots()\n    # Create an empty FancyArrow\n    ax.arrow(0, 0, 0, 0, head_length=0)",
        "begin_line": 429,
        "end_line": 432,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_annotate_default_arrow#435",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_annotate_default_arrow()",
        "snippet": "def test_annotate_default_arrow():\n    # Check that we can make an annotation arrow with only default properties.\n    fig, ax = plt.subplots()\n    ann = ax.annotate(\"foo\", (0, 1), xytext=(2, 3))\n    assert ann.arrow_patch is None\n    ann = ax.annotate(\"foo\", (0, 1), xytext=(2, 3), arrowprops={})\n    assert ann.arrow_patch is not None",
        "begin_line": 435,
        "end_line": 441,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_annotations#445",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_annotations()",
        "snippet": "def test_polar_annotations():\n    # you can specify the xypoint and the xytext in different\n    # positions and coordinate systems, and optionally turn on a\n    # connecting line and mark the point with a marker.  Annotations\n    # work on polar axes too.  In the example below, the xy point is\n    # in native coordinates (xycoords defaults to 'data').  For a\n    # polar axes, this is in (theta, radius) space.  The text in this\n    # example is placed in the fractional figure coordinate system.\n    # Text keyword args like horizontal and vertical alignment are\n    # respected\n\n    # Setup some data\n    r = np.arange(0.0, 1.0, 0.001)\n    theta = 2.0 * 2.0 * np.pi * r\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, polar=True)\n    line, = ax.plot(theta, r, color='#ee8d18', lw=3)\n    line, = ax.plot((0, 0), (0, 1), color=\"#0000ff\", lw=1)\n\n    ind = 800\n    thisr, thistheta = r[ind], theta[ind]\n    ax.plot([thistheta], [thisr], 'o')\n    ax.annotate('a polar annotation',\n                xy=(thistheta, thisr),  # theta, radius\n                xytext=(0.05, 0.05),    # fraction, fraction\n                textcoords='figure fraction',\n                arrowprops=dict(facecolor='black', shrink=0.05),\n                horizontalalignment='left',\n                verticalalignment='baseline',\n                )\n\n    ax.tick_params(axis='x', tick1On=True, tick2On=True, direction='out')",
        "begin_line": 445,
        "end_line": 477,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_coord_annotations#481",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_coord_annotations()",
        "snippet": "def test_polar_coord_annotations():\n    # You can also use polar notation on a cartesian axes.  Here the\n    # native coordinate system ('data') is cartesian, so you need to\n    # specify the xycoords and textcoords as 'polar' if you want to\n    # use (theta, radius)\n    from matplotlib.patches import Ellipse\n    el = Ellipse((0, 0), 10, 20, facecolor='r', alpha=0.5)\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, aspect='equal')\n\n    ax.add_artist(el)\n    el.set_clip_box(ax.bbox)\n\n    ax.annotate('the top',\n                xy=(np.pi/2., 10.),      # theta, radius\n                xytext=(np.pi/3, 20.),   # theta, radius\n                xycoords='polar',\n                textcoords='polar',\n                arrowprops=dict(facecolor='black', shrink=0.05),\n                horizontalalignment='left',\n                verticalalignment='baseline',\n                clip_on=True,  # clip to the axes bounding box\n                )\n\n    ax.set_xlim(-20, 20)\n    ax.set_ylim(-20, 20)",
        "begin_line": 481,
        "end_line": 507,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_alignment#511",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_alignment()",
        "snippet": "def test_polar_alignment():\n    \"\"\"\n    Test that changing the vertical/horizontal alignment of a polar graph\n    works as expected.\n    \"\"\"\n    angles = np.arange(0, 360, 90)\n    grid_values = [0, 0.2, 0.4, 0.6, 0.8, 1]\n\n    fig = plt.figure()\n    rect = [0.1, 0.1, 0.8, 0.8]\n\n    horizontal = fig.add_axes(rect, polar=True, label='horizontal')\n    horizontal.set_thetagrids(angles)\n\n    vertical = fig.add_axes(rect, polar=True, label='vertical')\n    vertical.patch.set_visible(False)\n\n    for i in range(2):\n        fig.axes[i].set_rgrids(\n            grid_values, angle=angles[i],\n            horizontalalignment='left', verticalalignment='top')",
        "begin_line": 511,
        "end_line": 531,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_fill_units#535",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_fill_units()",
        "snippet": "def test_fill_units():\n    from datetime import datetime\n    import matplotlib.testing.jpl_units as units\n    units.register()\n\n    # generate some data\n    t = units.Epoch(\"ET\", dt=datetime(2009, 4, 27))\n    value = 10.0 * units.deg\n    day = units.Duration(\"ET\", 24.0 * 60.0 * 60.0)\n\n    fig = plt.figure()\n\n    # Top-Left\n    ax1 = fig.add_subplot(221)\n    ax1.plot([t], [value], yunits='deg', color='red')\n    ax1.fill([733525.0, 733525.0, 733526.0, 733526.0],\n             [0.0, 0.0, 90.0, 0.0], 'b')\n\n    # Top-Right\n    ax2 = fig.add_subplot(222)\n    ax2.plot([t], [value], yunits='deg', color='red')\n    ax2.fill([t, t, t + day, t + day],\n             [0.0, 0.0, 90.0, 0.0], 'b')\n\n    # Bottom-Left\n    ax3 = fig.add_subplot(223)\n    ax3.plot([t], [value], yunits='deg', color='red')\n    ax3.fill([733525.0, 733525.0, 733526.0, 733526.0],\n             [0 * units.deg, 0 * units.deg, 90 * units.deg, 0 * units.deg],\n             'b')\n\n    # Bottom-Right\n    ax4 = fig.add_subplot(224)\n    ax4.plot([t], [value], yunits='deg', color='red')\n    ax4.fill([t, t, t + day, t + day],\n             [0 * units.deg, 0 * units.deg, 90 * units.deg, 0 * units.deg],\n             facecolor=\"blue\")\n\n    fig.autofmt_xdate()",
        "begin_line": 535,
        "end_line": 573,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_single_point#577",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_single_point()",
        "snippet": "def test_single_point():\n    # Issue #1796: don't let lines.marker affect the grid\n    matplotlib.rcParams['lines.marker'] = 'o'\n    matplotlib.rcParams['axes.grid'] = True\n\n    plt.figure()\n    plt.subplot(211)\n    plt.plot([0], [0], 'o')\n\n    plt.subplot(212)\n    plt.plot([1], [1], 'o')\n\n    # Reuse testcase from above for a labeled data test\n    data = {'a': [0], 'b': [1]}\n\n    plt.figure()\n    plt.subplot(211)\n    plt.plot('a', 'a', 'o', data=data)\n\n    plt.subplot(212)\n    plt.plot('b', 'b', 'o', data=data)",
        "begin_line": 577,
        "end_line": 597,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_single_date#601",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_single_date()",
        "snippet": "def test_single_date():\n    # use former defaults to match existing baseline image\n    plt.rcParams['axes.formatter.limits'] = -7, 7\n\n    time1 = [721964.0]\n    data1 = [-65.54]\n\n    plt.subplot(211)\n    plt.plot_date(time1, data1, 'o', color='r')\n\n    plt.subplot(212)\n    plt.plot(time1, data1, 'o', color='r')",
        "begin_line": 601,
        "end_line": 612,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shaped_data#616",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shaped_data(fig_test, fig_ref)",
        "snippet": "def test_shaped_data(fig_test, fig_ref):\n    row = np.arange(10).reshape((1, -1))\n    col = np.arange(0, 100, 10).reshape((-1, 1))\n\n    axs = fig_test.subplots(2)\n    axs[0].plot(row)  # Actually plots nothing (columns are single points).\n    axs[1].plot(col)  # Same as plotting 1d.\n\n    axs = fig_ref.subplots(2)\n    # xlim from the implicit \"x=0\", ylim from the row datalim.\n    axs[0].set(xlim=(-.06, .06), ylim=(0, 9))\n    axs[1].plot(col.ravel())",
        "begin_line": 616,
        "end_line": 627,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_structured_data#630",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_structured_data()",
        "snippet": "def test_structured_data():\n    # support for structured data\n    pts = np.array([(1, 1), (2, 2)], dtype=[(\"ones\", float), (\"twos\", float)])\n\n    # this should not read second name as a format and raise ValueError\n    axs = plt.figure().subplots(2)\n    axs[0].plot(\"ones\", \"twos\", data=pts)\n    axs[1].plot(\"ones\", \"twos\", \"r\", data=pts)",
        "begin_line": 630,
        "end_line": 637,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_twice#640",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_twice()",
        "snippet": "def test_polar_twice():\n    fig = plt.figure()\n    plt.polar([1, 2], [.1, .2])\n    plt.polar([3, 4], [.3, .4])\n    assert len(fig.axes) == 1, 'More than one polar axes created.'",
        "begin_line": 640,
        "end_line": 644,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_wrap#648",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_wrap(fig_test, fig_ref)",
        "snippet": "def test_polar_wrap(fig_test, fig_ref):\n    ax = fig_test.add_subplot(projection=\"polar\")\n    ax.plot(np.deg2rad([179, -179]), [0.2, 0.1])\n    ax.plot(np.deg2rad([2, -2]), [0.2, 0.1])\n    ax = fig_ref.add_subplot(projection=\"polar\")\n    ax.plot(np.deg2rad([179, 181]), [0.2, 0.1])\n    ax.plot(np.deg2rad([2, 358]), [0.2, 0.1])",
        "begin_line": 648,
        "end_line": 654,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_units_1#658",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_units_1(fig_test, fig_ref)",
        "snippet": "def test_polar_units_1(fig_test, fig_ref):\n    import matplotlib.testing.jpl_units as units\n    units.register()\n    xs = [30.0, 45.0, 60.0, 90.0]\n    ys = [1.0, 2.0, 3.0, 4.0]\n\n    plt.figure(fig_test.number)\n    plt.polar([x * units.deg for x in xs], ys)\n\n    ax = fig_ref.add_subplot(projection=\"polar\")\n    ax.plot(np.deg2rad(xs), ys)\n    ax.set(xlabel=\"deg\")",
        "begin_line": 658,
        "end_line": 669,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_units_2#673",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_units_2(fig_test, fig_ref)",
        "snippet": "def test_polar_units_2(fig_test, fig_ref):\n    import matplotlib.testing.jpl_units as units\n    units.register()\n    xs = [30.0, 45.0, 60.0, 90.0]\n    xs_deg = [x * units.deg for x in xs]\n    ys = [1.0, 2.0, 3.0, 4.0]\n    ys_km = [y * units.km for y in ys]\n\n    plt.figure(fig_test.number)\n    # test {theta,r}units.\n    plt.polar(xs_deg, ys_km, thetaunits=\"rad\", runits=\"km\")\n    assert isinstance(plt.gca().get_xaxis().get_major_formatter(),\n                      units.UnitDblFormatter)\n\n    ax = fig_ref.add_subplot(projection=\"polar\")\n    ax.plot(np.deg2rad(xs), ys)\n    ax.xaxis.set_major_formatter(mticker.FuncFormatter(\"{:.12}\".format))\n    ax.set(xlabel=\"rad\", ylabel=\"km\")",
        "begin_line": 673,
        "end_line": 690,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_rmin#694",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_rmin()",
        "snippet": "def test_polar_rmin():\n    r = np.arange(0, 3.0, 0.01)\n    theta = 2*np.pi*r\n\n    fig = plt.figure()\n    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True)\n    ax.plot(theta, r)\n    ax.set_rmax(2.0)\n    ax.set_rmin(0.5)",
        "begin_line": 694,
        "end_line": 702,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_negative_rmin#706",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_negative_rmin()",
        "snippet": "def test_polar_negative_rmin():\n    r = np.arange(-3.0, 0.0, 0.01)\n    theta = 2*np.pi*r\n\n    fig = plt.figure()\n    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True)\n    ax.plot(theta, r)\n    ax.set_rmax(0.0)\n    ax.set_rmin(-3.0)",
        "begin_line": 706,
        "end_line": 714,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_rorigin#718",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_rorigin()",
        "snippet": "def test_polar_rorigin():\n    r = np.arange(0, 3.0, 0.01)\n    theta = 2*np.pi*r\n\n    fig = plt.figure()\n    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True)\n    ax.plot(theta, r)\n    ax.set_rmax(2.0)\n    ax.set_rmin(0.5)\n    ax.set_rorigin(0.0)",
        "begin_line": 718,
        "end_line": 727,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_invertedylim#731",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_invertedylim()",
        "snippet": "def test_polar_invertedylim():\n    fig = plt.figure()\n    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True)\n    ax.set_ylim(2, 0)",
        "begin_line": 731,
        "end_line": 734,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_invertedylim_rorigin#738",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_invertedylim_rorigin()",
        "snippet": "def test_polar_invertedylim_rorigin():\n    fig = plt.figure()\n    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True)\n    ax.set_ylim(2, 0)\n    ax.set_rorigin(3)",
        "begin_line": 738,
        "end_line": 742,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_theta_position#746",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_theta_position()",
        "snippet": "def test_polar_theta_position():\n    r = np.arange(0, 3.0, 0.01)\n    theta = 2*np.pi*r\n\n    fig = plt.figure()\n    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True)\n    ax.plot(theta, r)\n    ax.set_theta_zero_location(\"NW\", 30)\n    ax.set_theta_direction('clockwise')",
        "begin_line": 746,
        "end_line": 754,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_rlabel_position#758",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_rlabel_position()",
        "snippet": "def test_polar_rlabel_position():\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='polar')\n    ax.set_rlabel_position(315)\n    ax.tick_params(rotation='auto')",
        "begin_line": 758,
        "end_line": 762,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_theta_limits#766",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_theta_limits()",
        "snippet": "def test_polar_theta_limits():\n    r = np.arange(0, 3.0, 0.01)\n    theta = 2*np.pi*r\n\n    theta_mins = np.arange(15.0, 361.0, 90.0)\n    theta_maxs = np.arange(50.0, 361.0, 90.0)\n    DIRECTIONS = ('out', 'in', 'inout')\n\n    fig, axs = plt.subplots(len(theta_mins), len(theta_maxs),\n                            subplot_kw={'polar': True},\n                            figsize=(8, 6))\n\n    for i, start in enumerate(theta_mins):\n        for j, end in enumerate(theta_maxs):\n            ax = axs[i, j]\n            ax.plot(theta, r)\n            if start < end:\n                ax.set_thetamin(start)\n                ax.set_thetamax(end)\n            else:\n                # Plot with clockwise orientation instead.\n                ax.set_thetamin(end)\n                ax.set_thetamax(start)\n                ax.set_theta_direction('clockwise')\n            ax.tick_params(tick1On=True, tick2On=True,\n                           direction=DIRECTIONS[i % len(DIRECTIONS)],\n                           rotation='auto')\n            ax.yaxis.set_tick_params(label2On=True, rotation='auto')",
        "begin_line": 766,
        "end_line": 793,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_rlim#797",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_rlim(fig_test, fig_ref)",
        "snippet": "def test_polar_rlim(fig_test, fig_ref):\n    ax = fig_test.subplots(subplot_kw={'polar': True})\n    ax.set_rlim(top=10)\n    ax.set_rlim(bottom=.5)\n\n    ax = fig_ref.subplots(subplot_kw={'polar': True})\n    ax.set_rmax(10.)\n    ax.set_rmin(.5)",
        "begin_line": 797,
        "end_line": 804,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_rlim_bottom#808",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_rlim_bottom(fig_test, fig_ref)",
        "snippet": "def test_polar_rlim_bottom(fig_test, fig_ref):\n    ax = fig_test.subplots(subplot_kw={'polar': True})\n    ax.set_rlim(bottom=[.5, 10])\n\n    ax = fig_ref.subplots(subplot_kw={'polar': True})\n    ax.set_rmax(10.)\n    ax.set_rmin(.5)",
        "begin_line": 808,
        "end_line": 814,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_rlim_zero#817",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_rlim_zero()",
        "snippet": "def test_polar_rlim_zero():\n    ax = plt.figure().add_subplot(projection='polar')\n    ax.plot(np.arange(10), np.arange(10) + .01)\n    assert ax.get_ylim()[0] == 0",
        "begin_line": 817,
        "end_line": 820,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_aitoff_proj#825",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_aitoff_proj()",
        "snippet": "def test_aitoff_proj():\n    \"\"\"\n    Test aitoff projection ref.:\n    https://github.com/matplotlib/matplotlib/pull/14451\n    \"\"\"\n    x = np.linspace(-np.pi, np.pi, 20)\n    y = np.linspace(-np.pi / 2, np.pi / 2, 20)\n    X, Y = np.meshgrid(x, y)\n\n    fig, ax = plt.subplots(figsize=(8, 4.2),\n                           subplot_kw=dict(projection=\"aitoff\"))\n    ax.grid()\n    ax.plot(X.flat, Y.flat, 'o', markersize=4)",
        "begin_line": 825,
        "end_line": 837,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axvspan_epoch#841",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axvspan_epoch()",
        "snippet": "def test_axvspan_epoch():\n    from datetime import datetime\n    import matplotlib.testing.jpl_units as units\n    units.register()\n\n    # generate some data\n    t0 = units.Epoch(\"ET\", dt=datetime(2009, 1, 20))\n    tf = units.Epoch(\"ET\", dt=datetime(2009, 1, 21))\n    dt = units.Duration(\"ET\", units.day.convert(\"sec\"))\n\n    ax = plt.gca()\n    plt.axvspan(t0, tf, facecolor=\"blue\", alpha=0.25)\n    ax.set_xlim(t0 - 5.0*dt, tf + 5.0*dt)",
        "begin_line": 841,
        "end_line": 853,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axhspan_epoch#857",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axhspan_epoch()",
        "snippet": "def test_axhspan_epoch():\n    from datetime import datetime\n    import matplotlib.testing.jpl_units as units\n    units.register()\n\n    # generate some data\n    t0 = units.Epoch(\"ET\", dt=datetime(2009, 1, 20))\n    tf = units.Epoch(\"ET\", dt=datetime(2009, 1, 21))\n    dt = units.Duration(\"ET\", units.day.convert(\"sec\"))\n\n    ax = plt.gca()\n    ax.axhspan(t0, tf, facecolor=\"blue\", alpha=0.25)\n    ax.set_ylim(t0 - 5.0*dt, tf + 5.0*dt)",
        "begin_line": 857,
        "end_line": 869,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hexbin_extent#873",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hexbin_extent()",
        "snippet": "def test_hexbin_extent():\n    # this test exposes sf bug 2856228\n    fig, ax = plt.subplots()\n    data = (np.arange(2000) / 2000).reshape((2, 1000))\n    x, y = data\n\n    ax.hexbin(x, y, extent=[.1, .3, .6, .7])\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"x\": x, \"y\": y}\n\n    fig, ax = plt.subplots()\n    ax.hexbin(\"x\", \"y\", extent=[.1, .3, .6, .7], data=data)",
        "begin_line": 873,
        "end_line": 885,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hexbin_empty#889",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hexbin_empty()",
        "snippet": "def test_hexbin_empty():\n    # From #3886: creating hexbin from empty dataset raises ValueError\n    ax = plt.gca()\n    ax.hexbin([], [])",
        "begin_line": 889,
        "end_line": 892,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hexbin_pickable#895",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hexbin_pickable()",
        "snippet": "def test_hexbin_pickable():\n    # From #1973: Test that picking a hexbin collection works\n    class FauxMouseEvent:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n\n    fig, ax = plt.subplots()\n    data = (np.arange(200) / 200).reshape((2, 100))\n    x, y = data\n    hb = ax.hexbin(x, y, extent=[.1, .3, .6, .7], picker=-1)\n\n    assert hb.contains(FauxMouseEvent(400, 300))[0]",
        "begin_line": 895,
        "end_line": 907,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.FauxMouseEvent.test_hexbin_pickable#895",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.FauxMouseEvent",
        "signature": "lib.matplotlib.tests.test_axes.FauxMouseEvent.test_hexbin_pickable()",
        "snippet": "def test_hexbin_pickable():\n    # From #1973: Test that picking a hexbin collection works\n    class FauxMouseEvent:\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n\n    fig, ax = plt.subplots()\n    data = (np.arange(200) / 200).reshape((2, 100))\n    x, y = data\n    hb = ax.hexbin(x, y, extent=[.1, .3, .6, .7], picker=-1)\n\n    assert hb.contains(FauxMouseEvent(400, 300))[0]",
        "begin_line": 895,
        "end_line": 907,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.FauxMouseEvent.__init__#898",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.FauxMouseEvent",
        "signature": "lib.matplotlib.tests.test_axes.FauxMouseEvent.__init__(self, x, y)",
        "snippet": "        def __init__(self, x, y):\n            self.x = x\n            self.y = y",
        "begin_line": 898,
        "end_line": 900,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hexbin_log#911",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hexbin_log()",
        "snippet": "def test_hexbin_log():\n    # Issue #1636 (and also test log scaled colorbar)\n    np.random.seed(19680801)\n    n = 100000\n    x = np.random.standard_normal(n)\n    y = 2.0 + 3.0 * x + 4.0 * np.random.standard_normal(n)\n    y = np.power(2, y * 0.5)\n\n    fig, ax = plt.subplots()\n    h = ax.hexbin(x, y, yscale='log', bins='log')\n    plt.colorbar(h)",
        "begin_line": 911,
        "end_line": 921,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_inverted_limits#924",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_inverted_limits()",
        "snippet": "def test_inverted_limits():\n    # Test gh:1553\n    # Calling invert_xaxis prior to plotting should not disable autoscaling\n    # while still maintaining the inverted direction\n    fig, ax = plt.subplots()\n    ax.invert_xaxis()\n    ax.plot([-5, -3, 2, 4], [1, 2, -3, 5])\n\n    assert ax.get_xlim() == (4, -5)\n    assert ax.get_ylim() == (-3, 5)\n    plt.close()\n\n    fig, ax = plt.subplots()\n    ax.invert_yaxis()\n    ax.plot([-5, -3, 2, 4], [1, 2, -3, 5])\n\n    assert ax.get_xlim() == (-5, 4)\n    assert ax.get_ylim() == (5, -3)\n\n    # Test inverting nonlinear axes.\n    fig, ax = plt.subplots()\n    ax.set_yscale(\"log\")\n    ax.set_ylim(10, 1)\n    assert ax.get_ylim() == (10, 1)",
        "begin_line": 924,
        "end_line": 947,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_nonfinite_limits#951",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_nonfinite_limits()",
        "snippet": "def test_nonfinite_limits():\n    x = np.arange(0., np.e, 0.01)\n    # silence divide by zero warning from log(0)\n    with np.errstate(divide='ignore'):\n        y = np.log(x)\n    x[len(x)//2] = np.nan\n    fig, ax = plt.subplots()\n    ax.plot(x, y)",
        "begin_line": 951,
        "end_line": 958,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_imshow#962",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_imshow()",
        "snippet": "def test_imshow():\n    # use former defaults to match existing baseline image\n    matplotlib.rcParams['image.interpolation'] = 'nearest'\n    # Create a NxN image\n    N = 100\n    (x, y) = np.indices((N, N))\n    x -= N//2\n    y -= N//2\n    r = np.sqrt(x**2+y**2-x*y)\n\n    # Create a contour plot at N/4 and extract both the clip path and transform\n    fig, ax = plt.subplots()\n    ax.imshow(r)\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"r\": r}\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.imshow(\"r\", data=data)",
        "begin_line": 962,
        "end_line": 980,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_imshow_clip#984",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_imshow_clip()",
        "snippet": "def test_imshow_clip():\n    # As originally reported by Gellule Xg <gellule.xg@free.fr>\n    # use former defaults to match existing baseline image\n    matplotlib.rcParams['image.interpolation'] = 'nearest'\n\n    # Create a NxN image\n    N = 100\n    (x, y) = np.indices((N, N))\n    x -= N//2\n    y -= N//2\n    r = np.sqrt(x**2+y**2-x*y)\n\n    # Create a contour plot at N/4 and extract both the clip path and transform\n    fig, ax = plt.subplots()\n\n    c = ax.contour(r, [N/4])\n    x = c.collections[0]\n    clipPath = x.get_paths()[0]\n    clipTransform = x.get_transform()\n\n    from matplotlib.transforms import TransformedPath\n    clip_path = TransformedPath(clipPath, clipTransform)\n\n    # Plot the image clipped by the contour\n    ax.imshow(r, clip_path=clip_path)",
        "begin_line": 984,
        "end_line": 1008,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_imshow_norm_vminvmax#1012",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_imshow_norm_vminvmax(fig_test, fig_ref)",
        "snippet": "def test_imshow_norm_vminvmax(fig_test, fig_ref):\n    \"\"\"Parameters vmin, vmax should be ignored if norm is given.\"\"\"\n    a = [[1, 2], [3, 4]]\n    ax = fig_ref.subplots()\n    ax.imshow(a, vmin=0, vmax=5)\n    ax = fig_test.subplots()\n    with pytest.warns(MatplotlibDeprecationWarning,\n                      match=\"Passing parameters norm and vmin/vmax \"\n                            \"simultaneously is deprecated.\"):\n        ax.imshow(a, norm=mcolors.Normalize(-10, 10), vmin=0, vmax=5)",
        "begin_line": 1012,
        "end_line": 1021,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polycollection_joinstyle#1025",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polycollection_joinstyle()",
        "snippet": "def test_polycollection_joinstyle():\n    # Bug #2890979 reported by Matthew West\n\n    from matplotlib import collections as mcoll\n\n    fig, ax = plt.subplots()\n    verts = np.array([[1, 1], [1, 2], [2, 2], [2, 1]])\n    c = mcoll.PolyCollection([verts], linewidths=40)\n    ax.add_collection(c)\n    ax.set_xbound(0, 3)\n    ax.set_ybound(0, 3)",
        "begin_line": 1025,
        "end_line": 1035,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_fill_between_input#1049",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_fill_between_input(x, y1, y2)",
        "snippet": "def test_fill_between_input(x, y1, y2):\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.fill_between(x, y1, y2)",
        "begin_line": 1049,
        "end_line": 1052,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_fill_betweenx_input#1066",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_fill_betweenx_input(y, x1, x2)",
        "snippet": "def test_fill_betweenx_input(y, x1, x2):\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.fill_betweenx(y, x1, x2)",
        "begin_line": 1066,
        "end_line": 1069,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_fill_between_interpolate#1073",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_fill_between_interpolate()",
        "snippet": "def test_fill_between_interpolate():\n    x = np.arange(0.0, 2, 0.02)\n    y1 = np.sin(2*np.pi*x)\n    y2 = 1.2*np.sin(4*np.pi*x)\n\n    fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\n    ax1.plot(x, y1, x, y2, color='black')\n    ax1.fill_between(x, y1, y2, where=y2 >= y1, facecolor='white', hatch='/',\n                     interpolate=True)\n    ax1.fill_between(x, y1, y2, where=y2 <= y1, facecolor='red',\n                     interpolate=True)\n\n    # Test support for masked arrays.\n    y2 = np.ma.masked_greater(y2, 1.0)\n    # Test that plotting works for masked arrays with the first element masked\n    y2[0] = np.ma.masked\n    ax2.plot(x, y1, x, y2, color='black')\n    ax2.fill_between(x, y1, y2, where=y2 >= y1, facecolor='green',\n                     interpolate=True)\n    ax2.fill_between(x, y1, y2, where=y2 <= y1, facecolor='red',\n                     interpolate=True)",
        "begin_line": 1073,
        "end_line": 1093,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_fill_between_interpolate_decreasing#1098",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_fill_between_interpolate_decreasing()",
        "snippet": "def test_fill_between_interpolate_decreasing():\n    p = np.array([724.3, 700, 655])\n    t = np.array([9.4, 7, 2.2])\n    prof = np.array([7.9, 6.6, 3.8])\n\n    fig, ax = plt.subplots(figsize=(9, 9))\n\n    ax.plot(t, p, 'tab:red')\n    ax.plot(prof, p, 'k')\n\n    ax.fill_betweenx(p, t, prof, where=prof < t,\n                     facecolor='blue', interpolate=True, alpha=0.4)\n    ax.fill_betweenx(p, t, prof, where=prof > t,\n                     facecolor='red', interpolate=True, alpha=0.4)\n\n    ax.set_xlim(0, 30)\n    ax.set_ylim(800, 600)",
        "begin_line": 1098,
        "end_line": 1114,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_symlog#1121",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_symlog()",
        "snippet": "def test_symlog():\n    x = np.array([0, 1, 2, 4, 6, 9, 12, 24])\n    y = np.array([1000000, 500000, 100000, 100, 5, 0, 0, 0])\n\n    fig, ax = plt.subplots()\n    ax.plot(x, y)\n    ax.set_yscale('symlog')\n    ax.set_xscale('linear')\n    ax.set_ylim(-1, 10000000)",
        "begin_line": 1121,
        "end_line": 1129,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_symlog2#1133",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_symlog2()",
        "snippet": "def test_symlog2():\n    # Numbers from -50 to 50, with 0.1 as step\n    x = np.arange(-50, 50, 0.001)\n\n    fig, axs = plt.subplots(5, 1)\n    for ax, linthreshx in zip(axs, [20., 2., 1., 0.1, 0.01]):\n        ax.plot(x, x)\n        ax.set_xscale('symlog', linthreshx=linthreshx)\n        ax.grid(True)\n    axs[-1].set_ylim(-0.1, 0.1)",
        "begin_line": 1133,
        "end_line": 1142,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolorargs_5205#1145",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolorargs_5205()",
        "snippet": "def test_pcolorargs_5205():\n    # Smoketest to catch issue found in gh:5205\n    x = [-1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5]\n    y = [-1.5, -1.25, -1.0, -0.75, -0.5, -0.25, 0,\n         0.25, 0.5, 0.75, 1.0, 1.25, 1.5]\n    X, Y = np.meshgrid(x, y)\n    Z = np.hypot(X, Y)\n\n    plt.pcolor(Z)\n    plt.pcolor(list(Z))\n    plt.pcolor(x, y, Z)\n    plt.pcolor(X, Y, list(Z))",
        "begin_line": 1145,
        "end_line": 1156,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolormesh#1160",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolormesh()",
        "snippet": "def test_pcolormesh():\n    n = 12\n    x = np.linspace(-1.5, 1.5, n)\n    y = np.linspace(-1.5, 1.5, n*2)\n    X, Y = np.meshgrid(x, y)\n    Qx = np.cos(Y) - np.cos(X)\n    Qz = np.sin(Y) + np.sin(X)\n    Qx = (Qx + 1.1)\n    Z = np.hypot(X, Y) / 5\n    Z = (Z - Z.min()) / Z.ptp()\n\n    # The color array can include masked values:\n    Zm = ma.masked_where(np.abs(Qz) < 0.5 * np.max(Qz), Z)\n\n    fig, (ax1, ax2, ax3) = plt.subplots(1, 3)\n    ax1.pcolormesh(Qx, Qz, Z, lw=0.5, edgecolors='k')\n    ax2.pcolormesh(Qx, Qz, Z, lw=2, edgecolors=['b', 'w'])\n    ax3.pcolormesh(Qx, Qz, Z, shading=\"gouraud\")",
        "begin_line": 1160,
        "end_line": 1177,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolormesh_alpha#1182",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolormesh_alpha()",
        "snippet": "def test_pcolormesh_alpha():\n    n = 12\n    X, Y = np.meshgrid(\n        np.linspace(-1.5, 1.5, n),\n        np.linspace(-1.5, 1.5, n*2)\n    )\n    Qx = X\n    Qy = Y + np.sin(X)\n    Z = np.hypot(X, Y) / 5\n    Z = (Z - Z.min()) / Z.ptp()\n    vir = plt.get_cmap(\"viridis\", 16)\n    # make another colormap with varying alpha\n    colors = vir(np.arange(16))\n    colors[:, 3] = 0.5 + 0.5*np.sin(np.arange(16))\n    cmap = mcolors.ListedColormap(colors)\n\n    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\n    for ax in ax1, ax2, ax3, ax4:\n        ax.add_patch(mpatches.Rectangle(\n            (0, -1.5), 1.5, 3, facecolor=[.7, .1, .1, .5], zorder=0\n        ))\n    # ax1, ax2: constant alpha\n    ax1.pcolormesh(Qx, Qy, Z, cmap=vir, alpha=0.4, shading='flat', zorder=1)\n    ax2.pcolormesh(Qx, Qy, Z, cmap=vir, alpha=0.4, shading='gouraud', zorder=1)\n    # ax3, ax4: alpha from colormap\n    ax3.pcolormesh(Qx, Qy, Z, cmap=cmap, shading='flat', zorder=1)\n    ax4.pcolormesh(Qx, Qy, Z, cmap=cmap, shading='gouraud', zorder=1)",
        "begin_line": 1182,
        "end_line": 1208,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolormesh_datetime_axis#1213",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolormesh_datetime_axis()",
        "snippet": "def test_pcolormesh_datetime_axis():\n    fig = plt.figure()\n    fig.subplots_adjust(hspace=0.4, top=0.98, bottom=.15)\n    base = datetime.datetime(2013, 1, 1)\n    x = np.array([base + datetime.timedelta(days=d) for d in range(21)])\n    y = np.arange(21)\n    z1, z2 = np.meshgrid(np.arange(20), np.arange(20))\n    z = z1 * z2\n    plt.subplot(221)\n    plt.pcolormesh(x[:-1], y[:-1], z)\n    plt.subplot(222)\n    plt.pcolormesh(x, y, z)\n    x = np.repeat(x[np.newaxis], 21, axis=0)\n    y = np.repeat(y[:, np.newaxis], 21, axis=1)\n    plt.subplot(223)\n    plt.pcolormesh(x[:-1, :-1], y[:-1, :-1], z)\n    plt.subplot(224)\n    plt.pcolormesh(x, y, z)\n    for ax in fig.get_axes():\n        for label in ax.get_xticklabels():\n            label.set_ha('right')\n            label.set_rotation(30)",
        "begin_line": 1213,
        "end_line": 1234,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolor_datetime_axis#1239",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolor_datetime_axis()",
        "snippet": "def test_pcolor_datetime_axis():\n    fig = plt.figure()\n    fig.subplots_adjust(hspace=0.4, top=0.98, bottom=.15)\n    base = datetime.datetime(2013, 1, 1)\n    x = np.array([base + datetime.timedelta(days=d) for d in range(21)])\n    y = np.arange(21)\n    z1, z2 = np.meshgrid(np.arange(20), np.arange(20))\n    z = z1 * z2\n    plt.subplot(221)\n    plt.pcolor(x[:-1], y[:-1], z)\n    plt.subplot(222)\n    plt.pcolor(x, y, z)\n    x = np.repeat(x[np.newaxis], 21, axis=0)\n    y = np.repeat(y[:, np.newaxis], 21, axis=1)\n    plt.subplot(223)\n    plt.pcolor(x[:-1, :-1], y[:-1, :-1], z)\n    plt.subplot(224)\n    plt.pcolor(x, y, z)\n    for ax in fig.get_axes():\n        for label in ax.get_xticklabels():\n            label.set_ha('right')\n            label.set_rotation(30)",
        "begin_line": 1239,
        "end_line": 1260,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolorargs#1263",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolorargs()",
        "snippet": "def test_pcolorargs():\n    n = 12\n    x = np.linspace(-1.5, 1.5, n)\n    y = np.linspace(-1.5, 1.5, n*2)\n    X, Y = np.meshgrid(x, y)\n    Z = np.hypot(X, Y) / 5\n\n    _, ax = plt.subplots()\n    with pytest.raises(TypeError):\n        ax.pcolormesh(y, x, Z)\n    with pytest.raises(TypeError):\n        ax.pcolormesh(X, Y, Z.T)\n    with pytest.raises(TypeError):\n        ax.pcolormesh(x, y, Z[:-1, :-1], shading=\"gouraud\")\n    with pytest.raises(TypeError):\n        ax.pcolormesh(X, Y, Z[:-1, :-1], shading=\"gouraud\")\n    x[0] = np.NaN\n    with pytest.raises(ValueError):\n        ax.pcolormesh(x, y, Z[:-1, :-1])\n    with np.errstate(invalid='ignore'):\n        x = np.ma.array(x, mask=(x < 0))\n    with pytest.raises(ValueError):\n        ax.pcolormesh(x, y, Z[:-1, :-1])",
        "begin_line": 1263,
        "end_line": 1285,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_canonical#1289",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_canonical()",
        "snippet": "def test_canonical():\n    fig, ax = plt.subplots()\n    ax.plot([1, 2, 3])",
        "begin_line": 1289,
        "end_line": 1291,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_arc_angles#1295",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_arc_angles()",
        "snippet": "def test_arc_angles():\n    from matplotlib import patches\n    # Ellipse parameters\n    w = 2\n    h = 1\n    centre = (0.2, 0.5)\n    scale = 2\n\n    fig, axs = plt.subplots(3, 3)\n    for i, ax in enumerate(axs.flat):\n        theta2 = i * 360 / 9\n        theta1 = theta2 - 45\n\n        ax.add_patch(patches.Ellipse(centre, w, h, alpha=0.3))\n        ax.add_patch(patches.Arc(centre, w, h, theta1=theta1, theta2=theta2))\n        # Straight lines intersecting start and end of arc\n        ax.plot([scale * np.cos(np.deg2rad(theta1)) + centre[0],\n                 centre[0],\n                 scale * np.cos(np.deg2rad(theta2)) + centre[0]],\n                [scale * np.sin(np.deg2rad(theta1)) + centre[1],\n                 centre[1],\n                 scale * np.sin(np.deg2rad(theta2)) + centre[1]])\n\n        ax.set_xlim(-scale, scale)\n        ax.set_ylim(-scale, scale)\n\n        # This looks the same, but it triggers a different code path when it\n        # gets large enough.\n        w *= 10\n        h *= 10\n        centre = (centre[0] * 10, centre[1] * 10)\n        scale *= 10",
        "begin_line": 1295,
        "end_line": 1326,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_arc_ellipse#1330",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_arc_ellipse()",
        "snippet": "def test_arc_ellipse():\n    from matplotlib import patches\n    xcenter, ycenter = 0.38, 0.52\n    width, height = 1e-1, 3e-1\n    angle = -30\n\n    theta = np.deg2rad(np.arange(360))\n    x = width / 2. * np.cos(theta)\n    y = height / 2. * np.sin(theta)\n\n    rtheta = np.deg2rad(angle)\n    R = np.array([\n        [np.cos(rtheta), -np.sin(rtheta)],\n        [np.sin(rtheta), np.cos(rtheta)]])\n\n    x, y = np.dot(R, np.array([x, y]))\n    x += xcenter\n    y += ycenter\n\n    fig = plt.figure()\n    ax = fig.add_subplot(211, aspect='auto')\n    ax.fill(x, y, alpha=0.2, facecolor='yellow', edgecolor='yellow',\n            linewidth=1, zorder=1)\n\n    e1 = patches.Arc((xcenter, ycenter), width, height,\n                     angle=angle, linewidth=2, fill=False, zorder=2)\n\n    ax.add_patch(e1)\n\n    ax = fig.add_subplot(212, aspect='equal')\n    ax.fill(x, y, alpha=0.2, facecolor='green', edgecolor='green', zorder=1)\n    e2 = patches.Arc((xcenter, ycenter), width, height,\n                     angle=angle, linewidth=2, fill=False, zorder=2)\n\n    ax.add_patch(e2)",
        "begin_line": 1330,
        "end_line": 1364,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markevery#1368",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markevery()",
        "snippet": "def test_markevery():\n    x = np.linspace(0, 10, 100)\n    y = np.sin(x) * np.sqrt(x/10 + 0.5)\n\n    # check marker only plot\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(x, y, 'o', label='default')\n    ax.plot(x, y, 'd', markevery=None, label='mark all')\n    ax.plot(x, y, 's', markevery=10, label='mark every 10')\n    ax.plot(x, y, '+', markevery=(5, 20), label='mark every 5 starting at 10')\n    ax.legend()",
        "begin_line": 1368,
        "end_line": 1379,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markevery_line#1383",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markevery_line()",
        "snippet": "def test_markevery_line():\n    x = np.linspace(0, 10, 100)\n    y = np.sin(x) * np.sqrt(x/10 + 0.5)\n\n    # check line/marker combos\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(x, y, '-o', label='default')\n    ax.plot(x, y, '-d', markevery=None, label='mark all')\n    ax.plot(x, y, '-s', markevery=10, label='mark every 10')\n    ax.plot(x, y, '-+', markevery=(5, 20), label='mark every 5 starting at 10')\n    ax.legend()",
        "begin_line": 1383,
        "end_line": 1394,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markevery_linear_scales#1398",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markevery_linear_scales()",
        "snippet": "def test_markevery_linear_scales():\n    cases = [None,\n             8,\n             (30, 8),\n             [16, 24, 30], [0, -1],\n             slice(100, 200, 3),\n             0.1, 0.3, 1.5,\n             (0.0, 0.1), (0.45, 0.1)]\n\n    cols = 3\n    gs = matplotlib.gridspec.GridSpec(len(cases) // cols + 1, cols)\n\n    delta = 0.11\n    x = np.linspace(0, 10 - 2 * delta, 200) + delta\n    y = np.sin(x) + 1.0 + delta\n\n    for i, case in enumerate(cases):\n        row = (i // cols)\n        col = i % cols\n        plt.subplot(gs[row, col])\n        plt.title('markevery=%s' % str(case))\n        plt.plot(x, y, 'o', ls='-', ms=4,  markevery=case)",
        "begin_line": 1398,
        "end_line": 1419,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markevery_linear_scales_zoomed#1423",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markevery_linear_scales_zoomed()",
        "snippet": "def test_markevery_linear_scales_zoomed():\n    cases = [None,\n             8,\n             (30, 8),\n             [16, 24, 30], [0, -1],\n             slice(100, 200, 3),\n             0.1, 0.3, 1.5,\n             (0.0, 0.1), (0.45, 0.1)]\n\n    cols = 3\n    gs = matplotlib.gridspec.GridSpec(len(cases) // cols + 1, cols)\n\n    delta = 0.11\n    x = np.linspace(0, 10 - 2 * delta, 200) + delta\n    y = np.sin(x) + 1.0 + delta\n\n    for i, case in enumerate(cases):\n        row = (i // cols)\n        col = i % cols\n        plt.subplot(gs[row, col])\n        plt.title('markevery=%s' % str(case))\n        plt.plot(x, y, 'o', ls='-', ms=4,  markevery=case)\n        plt.xlim((6, 6.7))\n        plt.ylim((1.1, 1.7))",
        "begin_line": 1423,
        "end_line": 1446,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markevery_log_scales#1450",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markevery_log_scales()",
        "snippet": "def test_markevery_log_scales():\n    cases = [None,\n             8,\n             (30, 8),\n             [16, 24, 30], [0, -1],\n             slice(100, 200, 3),\n             0.1, 0.3, 1.5,\n             (0.0, 0.1), (0.45, 0.1)]\n\n    cols = 3\n    gs = matplotlib.gridspec.GridSpec(len(cases) // cols + 1, cols)\n\n    delta = 0.11\n    x = np.linspace(0, 10 - 2 * delta, 200) + delta\n    y = np.sin(x) + 1.0 + delta\n\n    for i, case in enumerate(cases):\n        row = (i // cols)\n        col = i % cols\n        plt.subplot(gs[row, col])\n        plt.title('markevery=%s' % str(case))\n        plt.xscale('log')\n        plt.yscale('log')\n        plt.plot(x, y, 'o', ls='-', ms=4,  markevery=case)",
        "begin_line": 1450,
        "end_line": 1473,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markevery_polar#1477",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markevery_polar()",
        "snippet": "def test_markevery_polar():\n    cases = [None,\n             8,\n             (30, 8),\n             [16, 24, 30], [0, -1],\n             slice(100, 200, 3),\n             0.1, 0.3, 1.5,\n             (0.0, 0.1), (0.45, 0.1)]\n\n    cols = 3\n    gs = matplotlib.gridspec.GridSpec(len(cases) // cols + 1, cols)\n\n    r = np.linspace(0, 3.0, 200)\n    theta = 2 * np.pi * r\n\n    for i, case in enumerate(cases):\n        row = (i // cols)\n        col = i % cols\n        plt.subplot(gs[row, col], polar=True)\n        plt.title('markevery=%s' % str(case))\n        plt.plot(theta, r, 'o', ls='-', ms=4,  markevery=case)",
        "begin_line": 1477,
        "end_line": 1497,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_marker_edges#1501",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_marker_edges()",
        "snippet": "def test_marker_edges():\n    x = np.linspace(0, 1, 10)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(x, np.sin(x), 'y.', ms=30.0, mew=0, mec='r')\n    ax.plot(x+0.1, np.sin(x), 'y.', ms=30.0, mew=1, mec='r')\n    ax.plot(x+0.2, np.sin(x), 'y.', ms=30.0, mew=2, mec='b')",
        "begin_line": 1501,
        "end_line": 1507,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_tick_label_single#1511",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_tick_label_single()",
        "snippet": "def test_bar_tick_label_single():\n    # From 2516: plot bar with array of string labels for x axis\n    ax = plt.gca()\n    ax.bar(0, 1, align='edge', tick_label='0')\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"a\": 0, \"b\": 1}\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax = plt.gca()\n    ax.bar(\"a\", \"b\", align='edge', tick_label='0', data=data)",
        "begin_line": 1511,
        "end_line": 1521,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_ticklabel_fail#1524",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_ticklabel_fail()",
        "snippet": "def test_bar_ticklabel_fail():\n    fig, ax = plt.subplots()\n    ax.bar([], [])",
        "begin_line": 1524,
        "end_line": 1526,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_tick_label_multiple#1530",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_tick_label_multiple()",
        "snippet": "def test_bar_tick_label_multiple():\n    # From 2516: plot bar with array of string labels for x axis\n    ax = plt.gca()\n    ax.bar([1, 2.5], [1, 2], width=[0.2, 0.5], tick_label=['a', 'b'],\n           align='center')",
        "begin_line": 1530,
        "end_line": 1534,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_tick_label_multiple_old_alignment#1538",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_tick_label_multiple_old_alignment()",
        "snippet": "def test_bar_tick_label_multiple_old_alignment():\n    # Test that the alignment for class is backward compatible\n    matplotlib.rcParams[\"ytick.alignment\"] = \"center\"\n    ax = plt.gca()\n    ax.bar([1, 2.5], [1, 2], width=[0.2, 0.5], tick_label=['a', 'b'],\n           align='center')",
        "begin_line": 1538,
        "end_line": 1543,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_decimal_center#1547",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_decimal_center(fig_test, fig_ref)",
        "snippet": "def test_bar_decimal_center(fig_test, fig_ref):\n    ax = fig_test.subplots()\n    x0 = [1.5, 8.4, 5.3, 4.2]\n    y0 = [1.1, 2.2, 3.3, 4.4]\n    x = [Decimal(x) for x in x0]\n    y = [Decimal(y) for y in y0]\n    # Test image - vertical, align-center bar chart with Decimal() input\n    ax.bar(x, y, align='center')\n    # Reference image\n    ax = fig_ref.subplots()\n    ax.bar(x0, y0, align='center')",
        "begin_line": 1547,
        "end_line": 1557,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_barh_decimal_center#1561",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_barh_decimal_center(fig_test, fig_ref)",
        "snippet": "def test_barh_decimal_center(fig_test, fig_ref):\n    ax = fig_test.subplots()\n    x0 = [1.5, 8.4, 5.3, 4.2]\n    y0 = [1.1, 2.2, 3.3, 4.4]\n    x = [Decimal(x) for x in x0]\n    y = [Decimal(y) for y in y0]\n    # Test image - horizontal, align-center bar chart with Decimal() input\n    ax.barh(x, y, height=[0.5, 0.5, 1, 1], align='center')\n    # Reference image\n    ax = fig_ref.subplots()\n    ax.barh(x0, y0, height=[0.5, 0.5, 1, 1], align='center')",
        "begin_line": 1561,
        "end_line": 1571,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_decimal_width#1575",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_decimal_width(fig_test, fig_ref)",
        "snippet": "def test_bar_decimal_width(fig_test, fig_ref):\n    x = [1.5, 8.4, 5.3, 4.2]\n    y = [1.1, 2.2, 3.3, 4.4]\n    w0 = [0.7, 1.45, 1, 2]\n    w = [Decimal(i) for i in w0]\n    # Test image - vertical bar chart with Decimal() width\n    ax = fig_test.subplots()\n    ax.bar(x, y, width=w, align='center')\n    # Reference image\n    ax = fig_ref.subplots()\n    ax.bar(x, y, width=w0, align='center')",
        "begin_line": 1575,
        "end_line": 1585,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_barh_decimal_height#1589",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_barh_decimal_height(fig_test, fig_ref)",
        "snippet": "def test_barh_decimal_height(fig_test, fig_ref):\n    x = [1.5, 8.4, 5.3, 4.2]\n    y = [1.1, 2.2, 3.3, 4.4]\n    h0 = [0.7, 1.45, 1, 2]\n    h = [Decimal(i) for i in h0]\n    # Test image - horizontal bar chart with Decimal() height\n    ax = fig_test.subplots()\n    ax.barh(x, y, height=h, align='center')\n    # Reference image\n    ax = fig_ref.subplots()\n    ax.barh(x, y, height=h0, align='center')",
        "begin_line": 1589,
        "end_line": 1599,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_color_none_alpha#1602",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_color_none_alpha()",
        "snippet": "def test_bar_color_none_alpha():\n    ax = plt.gca()\n    rects = ax.bar([1, 2], [2, 4], alpha=0.3, color='none', edgecolor='r')\n    for rect in rects:\n        assert rect.get_facecolor() == (0, 0, 0, 0)\n        assert rect.get_edgecolor() == (1, 0, 0, 0.3)",
        "begin_line": 1602,
        "end_line": 1607,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_edgecolor_none_alpha#1610",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_edgecolor_none_alpha()",
        "snippet": "def test_bar_edgecolor_none_alpha():\n    ax = plt.gca()\n    rects = ax.bar([1, 2], [2, 4], alpha=0.3, color='r', edgecolor='none')\n    for rect in rects:\n        assert rect.get_facecolor() == (1, 0, 0, 0.3)\n        assert rect.get_edgecolor() == (0, 0, 0, 0)",
        "begin_line": 1610,
        "end_line": 1615,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_barh_tick_label#1619",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_barh_tick_label()",
        "snippet": "def test_barh_tick_label():\n    # From 2516: plot barh with array of string labels for y axis\n    ax = plt.gca()\n    ax.barh([1, 2.5], [1, 2], height=[0.2, 0.5], tick_label=['a', 'b'],\n            align='center')",
        "begin_line": 1619,
        "end_line": 1623,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_timedelta#1626",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_timedelta()",
        "snippet": "def test_bar_timedelta():\n    \"\"\"smoketest that bar can handle width and height in delta units\"\"\"\n    fig, ax = plt.subplots()\n    ax.bar(datetime.datetime(2018, 1, 1), 1.,\n           width=datetime.timedelta(hours=3))\n    ax.bar(datetime.datetime(2018, 1, 1), 1.,\n           xerr=datetime.timedelta(hours=2),\n           width=datetime.timedelta(hours=3))\n    fig, ax = plt.subplots()\n    ax.barh(datetime.datetime(2018, 1, 1), 1,\n            height=datetime.timedelta(hours=3))\n    ax.barh(datetime.datetime(2018, 1, 1), 1,\n            height=datetime.timedelta(hours=3),\n            yerr=datetime.timedelta(hours=2))\n    fig, ax = plt.subplots()\n    ax.barh([datetime.datetime(2018, 1, 1), datetime.datetime(2018, 1, 1)],\n            np.array([1, 1.5]),\n            height=datetime.timedelta(hours=3))\n    ax.barh([datetime.datetime(2018, 1, 1), datetime.datetime(2018, 1, 1)],\n            np.array([1, 1.5]),\n            height=[datetime.timedelta(hours=t) for t in [1, 2]])\n    ax.broken_barh([(datetime.datetime(2018, 1, 1),\n                     datetime.timedelta(hours=1))],\n                   (10, 20))",
        "begin_line": 1626,
        "end_line": 1649,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_dates_pandas#1652",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_dates_pandas(pd)",
        "snippet": "def test_boxplot_dates_pandas(pd):\n    # smoke test for boxplot and dates in pandas\n    data = np.random.rand(5, 2)\n    years = pd.date_range('1/1/2000',\n                          periods=2, freq=pd.DateOffset(years=1)).year\n    plt.figure()\n    plt.boxplot(data, positions=years)",
        "begin_line": 1652,
        "end_line": 1658,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_pandas#1661",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_pandas(pd)",
        "snippet": "def test_bar_pandas(pd):\n    # Smoke test for pandas\n    df = pd.DataFrame(\n        {'year': [2018, 2018, 2018],\n         'month': [1, 1, 1],\n         'day': [1, 2, 3],\n         'value': [1, 2, 3]})\n    df['date'] = pd.to_datetime(df[['year', 'month', 'day']])\n\n    monthly = df[['date', 'value']].groupby(['date']).sum()\n    dates = monthly.index\n    forecast = monthly['value']\n    baseline = monthly['value']\n\n    fig, ax = plt.subplots()\n    ax.bar(dates, forecast, width=10, align='center')\n    ax.plot(dates, baseline, color='orange', lw=4)",
        "begin_line": 1661,
        "end_line": 1677,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_pandas_indexed#1680",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_pandas_indexed(pd)",
        "snippet": "def test_bar_pandas_indexed(pd):\n    # Smoke test for indexed pandas\n    df = pd.DataFrame({\"x\": [1., 2., 3.], \"width\": [.2, .4, .6]},\n                       index=[1, 2, 3])\n    fig, ax = plt.subplots()\n    ax.bar(df.x, 1., width=df.width)",
        "begin_line": 1680,
        "end_line": 1685,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_log#1689",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_log()",
        "snippet": "def test_hist_log():\n    data0 = np.linspace(0, 1, 200)**3\n    data = np.concatenate([1 - data0, 1 + data0])\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(data, fill=False, log=True)",
        "begin_line": 1689,
        "end_line": 1694,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_log_2#1698",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_log_2(fig_test, fig_ref)",
        "snippet": "def test_hist_log_2(fig_test, fig_ref):\n    axs_test = fig_test.subplots(2, 3)\n    axs_ref = fig_ref.subplots(2, 3)\n    for i, histtype in enumerate([\"bar\", \"step\", \"stepfilled\"]):\n        # Set log scale, then call hist().\n        axs_test[0, i].set_yscale(\"log\")\n        axs_test[0, i].hist(1, 1, histtype=histtype)\n        # Call hist(), then set log scale.\n        axs_test[1, i].hist(1, 1, histtype=histtype)\n        axs_test[1, i].set_yscale(\"log\")\n        # Use hist(..., log=True).\n        for ax in axs_ref[:, i]:\n            ax.hist(1, 1, log=True, histtype=histtype)",
        "begin_line": 1698,
        "end_line": 1710,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_bar_empty#1714",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_bar_empty()",
        "snippet": "def test_hist_bar_empty():\n    # From #3886: creating hist from empty dataset raises ValueError\n    ax = plt.gca()\n    ax.hist([], histtype='bar')",
        "begin_line": 1714,
        "end_line": 1717,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step_empty#1721",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step_empty()",
        "snippet": "def test_hist_step_empty():\n    # From #3886: creating hist from empty dataset raises ValueError\n    ax = plt.gca()\n    ax.hist([], histtype='step')",
        "begin_line": 1721,
        "end_line": 1724,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step_filled#1728",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step_filled()",
        "snippet": "def test_hist_step_filled():\n    np.random.seed(0)\n    x = np.random.randn(1000, 3)\n    n_bins = 10\n\n    kwargs = [{'fill': True}, {'fill': False}, {'fill': None}, {}]*2\n    types = ['step']*4+['stepfilled']*4\n    fig, axs = plt.subplots(nrows=2, ncols=4)\n\n    for kg, _type, ax in zip(kwargs, types, axs.flat):\n        ax.hist(x, n_bins, histtype=_type, stacked=True, **kg)\n        ax.set_title('%s/%s' % (kg, _type))\n        ax.set_ylim(bottom=-50)\n\n    patches = axs[0, 0].patches\n    assert all(p.get_facecolor() == p.get_edgecolor() for p in patches)",
        "begin_line": 1728,
        "end_line": 1743,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_density#1747",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_density()",
        "snippet": "def test_hist_density():\n    np.random.seed(19680801)\n    data = np.random.standard_normal(2000)\n    fig, ax = plt.subplots()\n    ax.hist(data, density=True)",
        "begin_line": 1747,
        "end_line": 1751,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_unequal_bins_density#1754",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_unequal_bins_density()",
        "snippet": "def test_hist_unequal_bins_density():\n    # Test correct behavior of normalized histogram with unequal bins\n    # https://github.com/matplotlib/matplotlib/issues/9557\n    rng = np.random.RandomState(57483)\n    t = rng.randn(100)\n    bins = [-3, -1, -0.5, 0, 1, 5]\n    mpl_heights, _, _ = plt.hist(t, bins=bins, density=True)\n    np_heights, _ = np.histogram(t, bins=bins, density=True)\n    assert_allclose(mpl_heights, np_heights)",
        "begin_line": 1754,
        "end_line": 1762,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_datetime_datasets#1765",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_datetime_datasets()",
        "snippet": "def test_hist_datetime_datasets():\n    data = [[datetime.datetime(2017, 1, 1), datetime.datetime(2017, 1, 1)],\n            [datetime.datetime(2017, 1, 1), datetime.datetime(2017, 1, 2)]]\n    fig, ax = plt.subplots()\n    ax.hist(data, stacked=True)\n    ax.hist(data, stacked=False)",
        "begin_line": 1765,
        "end_line": 1770,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_datetime_datasets_bins#1779",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_datetime_datasets_bins(bins_preprocess)",
        "snippet": "def test_hist_datetime_datasets_bins(bins_preprocess):\n    data = [[datetime.datetime(2019, 1, 5), datetime.datetime(2019, 1, 11),\n             datetime.datetime(2019, 2, 1), datetime.datetime(2019, 3, 1)],\n            [datetime.datetime(2019, 1, 11), datetime.datetime(2019, 2, 5),\n             datetime.datetime(2019, 2, 18), datetime.datetime(2019, 3, 1)]]\n\n    date_edges = [datetime.datetime(2019, 1, 1), datetime.datetime(2019, 2, 1),\n                  datetime.datetime(2019, 3, 1)]\n\n    fig, ax = plt.subplots()\n    _, bins, _ = ax.hist(data, bins=bins_preprocess(date_edges), stacked=True)\n    np.testing.assert_allclose(bins, mpl.dates.date2num(date_edges))\n\n    _, bins, _ = ax.hist(data, bins=bins_preprocess(date_edges), stacked=False)\n    np.testing.assert_allclose(bins, mpl.dates.date2num(date_edges))",
        "begin_line": 1779,
        "end_line": 1793,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_with_empty_input#1800",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_with_empty_input(data, expected_number_of_hists)",
        "snippet": "def test_hist_with_empty_input(data, expected_number_of_hists):\n    hists, _, _ = plt.hist(data)\n    hists = np.asarray(hists)\n\n    if hists.ndim == 1:\n        assert 1 == expected_number_of_hists\n    else:\n        assert hists.shape[0] == expected_number_of_hists",
        "begin_line": 1800,
        "end_line": 1807,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.contour_dat#1810",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.contour_dat()",
        "snippet": "def contour_dat():\n    x = np.linspace(-3, 5, 150)\n    y = np.linspace(-3, 5, 120)\n    z = np.cos(x) + np.sin(y[:, np.newaxis])\n    return x, y, z",
        "begin_line": 1810,
        "end_line": 1814,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_contour_hatching#1818",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_contour_hatching()",
        "snippet": "def test_contour_hatching():\n    x, y, z = contour_dat()\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.contourf(x, y, z, 7, hatches=['/', '\\\\', '//', '-'],\n                cmap=plt.get_cmap('gray'),\n                extend='both', alpha=0.5)",
        "begin_line": 1818,
        "end_line": 1824,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_contour_colorbar#1828",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_contour_colorbar()",
        "snippet": "def test_contour_colorbar():\n    x, y, z = contour_dat()\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    cs = ax.contourf(x, y, z, levels=np.arange(-1.8, 1.801, 0.2),\n                     cmap=plt.get_cmap('RdBu'),\n                     vmin=-0.6,\n                     vmax=0.6,\n                     extend='both')\n    cs1 = ax.contour(x, y, z, levels=np.arange(-2.2, -0.599, 0.2),\n                     colors=['y'],\n                     linestyles='solid',\n                     linewidths=2)\n    cs2 = ax.contour(x, y, z, levels=np.arange(0.6, 2.2, 0.2),\n                     colors=['c'],\n                     linewidths=2)\n    cbar = fig.colorbar(cs, ax=ax)\n    cbar.add_lines(cs1)\n    cbar.add_lines(cs2, erase=False)",
        "begin_line": 1828,
        "end_line": 1847,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist2d#1851",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist2d()",
        "snippet": "def test_hist2d():\n    np.random.seed(0)\n    # make it not symmetric in case we switch x and y axis\n    x = np.random.randn(100)*2+5\n    y = np.random.randn(100)-2\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist2d(x, y, bins=10, rasterized=True)\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"x\": x, \"y\": y}\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist2d(\"x\", \"y\", bins=10, data=data, rasterized=True)",
        "begin_line": 1851,
        "end_line": 1864,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist2d_transpose#1868",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist2d_transpose()",
        "snippet": "def test_hist2d_transpose():\n    np.random.seed(0)\n    # make sure the output from np.histogram is transposed before\n    # passing to pcolorfast\n    x = np.array([5]*100)\n    y = np.random.randn(100)-2\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist2d(x, y, bins=10, rasterized=True)",
        "begin_line": 1868,
        "end_line": 1876,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist2d_density_normed#1879",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist2d_density_normed()",
        "snippet": "def test_hist2d_density_normed():\n    x, y = np.random.random((2, 100))\n    ax = plt.figure().subplots()\n    for obj in [ax, plt]:\n        obj.hist2d(x, y, density=True)\n        with pytest.warns(MatplotlibDeprecationWarning):\n            obj.hist2d(x, y, normed=True)\n        with pytest.warns(MatplotlibDeprecationWarning):\n            obj.hist2d(x, y, density=True, normed=True)",
        "begin_line": 1879,
        "end_line": 1887,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_plot#1892",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_plot(self)",
        "snippet": "    def test_scatter_plot(self):\n        data = {\"x\": np.array([3, 4, 2, 6]), \"y\": np.array([2, 5, 2, 3]),\n                \"c\": ['r', 'y', 'b', 'lime'], \"s\": [24, 15, 19, 29],\n                \"c2\": ['0.5', '0.6', '0.7', '0.8']}\n\n        fig, ax = plt.subplots()\n        ax.scatter(data[\"x\"] - 1., data[\"y\"] - 1., c=data[\"c\"], s=data[\"s\"])\n        ax.scatter(data[\"x\"] + 1., data[\"y\"] + 1., c=data[\"c2\"], s=data[\"s\"])\n        ax.scatter(\"x\", \"y\", c=\"c\", s=\"s\", data=data)",
        "begin_line": 1892,
        "end_line": 1900,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_marker#1903",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_marker(self)",
        "snippet": "    def test_scatter_marker(self):\n        fig, (ax0, ax1, ax2) = plt.subplots(ncols=3)\n        ax0.scatter([3, 4, 2, 6], [2, 5, 2, 3],\n                    c=[(1, 0, 0), 'y', 'b', 'lime'],\n                    s=[60, 50, 40, 30],\n                    edgecolors=['k', 'r', 'g', 'b'],\n                    marker='s')\n        ax1.scatter([3, 4, 2, 6], [2, 5, 2, 3],\n                    c=[(1, 0, 0), 'y', 'b', 'lime'],\n                    s=[60, 50, 40, 30],\n                    edgecolors=['k', 'r', 'g', 'b'],\n                    marker=mmarkers.MarkerStyle('o', fillstyle='top'))\n        # unit area ellipse\n        rx, ry = 3, 1\n        area = rx * ry * np.pi\n        theta = np.linspace(0, 2 * np.pi, 21)\n        verts = np.column_stack([np.cos(theta) * rx / area,\n                                 np.sin(theta) * ry / area])\n        ax2.scatter([3, 4, 2, 6], [2, 5, 2, 3],\n                    c=[(1, 0, 0), 'y', 'b', 'lime'],\n                    s=[60, 50, 40, 30],\n                    edgecolors=['k', 'r', 'g', 'b'],\n                    marker=verts)",
        "begin_line": 1903,
        "end_line": 1925,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_2D#1928",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_2D(self)",
        "snippet": "    def test_scatter_2D(self):\n        x = np.arange(3)\n        y = np.arange(2)\n        x, y = np.meshgrid(x, y)\n        z = x + y\n        fig, ax = plt.subplots()\n        ax.scatter(x, y, c=z, s=200, edgecolors='face')",
        "begin_line": 1928,
        "end_line": 1934,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_decimal#1937",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_decimal(self, fig_test, fig_ref)",
        "snippet": "    def test_scatter_decimal(self, fig_test, fig_ref):\n        x0 = np.array([1.5, 8.4, 5.3, 4.2])\n        y0 = np.array([1.1, 2.2, 3.3, 4.4])\n        x = np.array([Decimal(i) for i in x0])\n        y = np.array([Decimal(i) for i in y0])\n        c = ['r', 'y', 'b', 'lime']\n        s = [24, 15, 19, 29]\n        # Test image - scatter plot with Decimal() input\n        ax = fig_test.subplots()\n        ax.scatter(x, y, c=c, s=s)\n        # Reference image\n        ax = fig_ref.subplots()\n        ax.scatter(x0, y0, c=c, s=s)",
        "begin_line": 1937,
        "end_line": 1949,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_color#1951",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_color(self)",
        "snippet": "    def test_scatter_color(self):\n        # Try to catch cases where 'c' kwarg should have been used.\n        with pytest.raises(ValueError):\n            plt.scatter([1, 2], [1, 2], color=[0.1, 0.2])\n        with pytest.raises(ValueError):\n            plt.scatter([1, 2, 3], [1, 2, 3], color=[1, 2, 3])",
        "begin_line": 1951,
        "end_line": 1956,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_size_arg_size#1958",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_size_arg_size(self)",
        "snippet": "    def test_scatter_size_arg_size(self):\n        x = np.arange(4)\n        with pytest.raises(ValueError):\n            plt.scatter(x, x, x[1:])\n        with pytest.raises(ValueError):\n            plt.scatter(x[1:], x[1:], x)",
        "begin_line": 1958,
        "end_line": 1963,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_invalid_color#1966",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_invalid_color(self, fig_test, fig_ref)",
        "snippet": "    def test_scatter_invalid_color(self, fig_test, fig_ref):\n        ax = fig_test.subplots()\n        cmap = plt.get_cmap(\"viridis\", 16)\n        cmap.set_bad(\"k\", 1)\n        # Set a nonuniform size to prevent the last call to `scatter` (plotting\n        # the invalid points separately in fig_ref) from using the marker\n        # stamping fast path, which would result in slightly offset markers.\n        ax.scatter(range(4), range(4),\n                   c=[1, np.nan, 2, np.nan], s=[1, 2, 3, 4],\n                   cmap=cmap, plotnonfinite=True)\n        ax = fig_ref.subplots()\n        cmap = plt.get_cmap(\"viridis\", 16)\n        ax.scatter([0, 2], [0, 2], c=[1, 2], s=[1, 3], cmap=cmap)\n        ax.scatter([1, 3], [1, 3], s=[2, 4], color=\"k\")",
        "begin_line": 1966,
        "end_line": 1979,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_no_invalid_color#1982",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_no_invalid_color(self, fig_test, fig_ref)",
        "snippet": "    def test_scatter_no_invalid_color(self, fig_test, fig_ref):\n        # With plotninfinite=False we plot only 2 points.\n        ax = fig_test.subplots()\n        cmap = plt.get_cmap(\"viridis\", 16)\n        cmap.set_bad(\"k\", 1)\n        ax.scatter(range(4), range(4),\n                   c=[1, np.nan, 2, np.nan], s=[1, 2, 3, 4],\n                   cmap=cmap, plotnonfinite=False)\n        ax = fig_ref.subplots()\n        ax.scatter([0, 2], [0, 2], c=[1, 2], s=[1, 3], cmap=cmap)",
        "begin_line": 1982,
        "end_line": 1991,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_norm_vminvmax#1994",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_norm_vminvmax(self, fig_test, fig_ref)",
        "snippet": "    def test_scatter_norm_vminvmax(self, fig_test, fig_ref):\n        \"\"\"Parameters vmin, vmax should be ignored if norm is given.\"\"\"\n        x = [1, 2, 3]\n        ax = fig_ref.subplots()\n        ax.scatter(x, x, c=x, vmin=0, vmax=5)\n        ax = fig_test.subplots()\n        with pytest.warns(MatplotlibDeprecationWarning,\n                          match=\"Passing parameters norm and vmin/vmax \"\n                                \"simultaneously is deprecated.\"):\n            ax.scatter(x, x, c=x, norm=mcolors.Normalize(-10, 10),\n                       vmin=0, vmax=5)",
        "begin_line": 1994,
        "end_line": 2004,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_single_point#2007",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_single_point(self, fig_test, fig_ref)",
        "snippet": "    def test_scatter_single_point(self, fig_test, fig_ref):\n        ax = fig_test.subplots()\n        ax.scatter(1, 1, c=1)\n        ax = fig_ref.subplots()\n        ax.scatter([1], [1], c=[1])",
        "begin_line": 2007,
        "end_line": 2011,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_different_shapes#2014",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_different_shapes(self, fig_test, fig_ref)",
        "snippet": "    def test_scatter_different_shapes(self, fig_test, fig_ref):\n        x = np.arange(10)\n        ax = fig_test.subplots()\n        ax.scatter(x, x.reshape(2, 5), c=x.reshape(5, 2))\n        ax = fig_ref.subplots()\n        ax.scatter(x.reshape(5, 2), x, c=x.reshape(2, 5))",
        "begin_line": 2014,
        "end_line": 2019,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_c#2068",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_c(self, c_case, re_key)",
        "snippet": "    def test_scatter_c(self, c_case, re_key):\n        def get_next_color():\n            return 'blue'  # currently unused\n\n        from matplotlib.axes import Axes\n\n        xsize = 4\n\n        # Additional checking of *c* (introduced in #11383).\n        REGEXP = {\n            \"shape\": \"^'c' argument has [0-9]+ elements\",  # shape mismatch\n            \"conversion\": \"^'c' argument must be a color\",  # bad vals\n            }\n\n        if re_key is None:\n            Axes._parse_scatter_color_args(\n                c=c_case, edgecolors=\"black\", kwargs={}, xsize=xsize,\n                get_next_color_func=get_next_color)\n        else:\n            with pytest.raises(ValueError, match=REGEXP[re_key]):\n                Axes._parse_scatter_color_args(\n                    c=c_case, edgecolors=\"black\", kwargs={}, xsize=xsize,\n                    get_next_color_func=get_next_color)",
        "begin_line": 2068,
        "end_line": 2090,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.get_next_color#2069",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.get_next_color()",
        "snippet": "        def get_next_color():\n            return 'blue'  # currently unused",
        "begin_line": 2069,
        "end_line": 2070,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes._params#2093",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes._params(c=None, xsize=2, **kwargs)",
        "snippet": "def _params(c=None, xsize=2, **kwargs):\n    edgecolors = kwargs.pop('edgecolors', None)\n    return (c, edgecolors, kwargs if kwargs is not None else {}, xsize)",
        "begin_line": 2093,
        "end_line": 2095,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_parse_scatter_color_args#2112",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_parse_scatter_color_args(params, expected_result)",
        "snippet": "def test_parse_scatter_color_args(params, expected_result):\n    def get_next_color():\n        return 'blue'  # currently unused\n\n    from matplotlib.axes import Axes\n    c, colors, _edgecolors = Axes._parse_scatter_color_args(\n        *params, get_next_color_func=get_next_color)\n    assert c == expected_result.c\n    assert_allclose(colors, expected_result.colors)",
        "begin_line": 2112,
        "end_line": 2120,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.get_next_color#2113",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.get_next_color()",
        "snippet": "    def get_next_color():\n        return 'blue'  # currently unused",
        "begin_line": 2113,
        "end_line": 2114,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_parse_scatter_color_args_edgecolors#2139",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_parse_scatter_color_args_edgecolors(kwargs, expected_edgecolors)",
        "snippet": "def test_parse_scatter_color_args_edgecolors(kwargs, expected_edgecolors):\n    def get_next_color():\n        return 'blue'  # currently unused\n\n    from matplotlib.axes import Axes\n    c = kwargs.pop('c', None)\n    edgecolors = kwargs.pop('edgecolors', None)\n    _, _, result_edgecolors = \\\n        Axes._parse_scatter_color_args(c, edgecolors, kwargs, xsize=2,\n                                       get_next_color_func=get_next_color)\n    assert result_edgecolors == expected_edgecolors",
        "begin_line": 2139,
        "end_line": 2149,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.get_next_color#2140",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.get_next_color()",
        "snippet": "    def get_next_color():\n        return 'blue'  # currently unused",
        "begin_line": 2140,
        "end_line": 2141,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_as_mpl_axes_api#2152",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_as_mpl_axes_api()",
        "snippet": "def test_as_mpl_axes_api():\n    # tests the _as_mpl_axes api\n    from matplotlib.projections.polar import PolarAxes\n    import matplotlib.axes as maxes\n\n    class Polar:\n        def __init__(self):\n            self.theta_offset = 0\n\n        def _as_mpl_axes(self):\n            # implement the matplotlib axes interface\n            return PolarAxes, {'theta_offset': self.theta_offset}\n\n    prj = Polar()\n    prj2 = Polar()\n    prj2.theta_offset = np.pi\n    prj3 = Polar()\n\n    # testing axes creation with plt.axes\n    ax = plt.axes([0, 0, 1, 1], projection=prj)\n    assert type(ax) == PolarAxes\n    ax_via_gca = plt.gca(projection=prj)\n    assert ax_via_gca is ax\n    plt.close()\n\n    # testing axes creation with gca\n    ax = plt.gca(projection=prj)\n    assert type(ax) == maxes._subplots.subplot_class_factory(PolarAxes)\n    ax_via_gca = plt.gca(projection=prj)\n    assert ax_via_gca is ax\n    # try getting the axes given a different polar projection\n    with pytest.warns(UserWarning) as rec:\n        ax_via_gca = plt.gca(projection=prj2)\n        assert len(rec) == 1\n        assert 'Requested projection is different' in str(rec[0].message)\n    assert ax_via_gca is not ax\n    assert ax.get_theta_offset() == 0\n    assert ax_via_gca.get_theta_offset() == np.pi\n    # try getting the axes given an == (not is) polar projection\n    with pytest.warns(UserWarning):\n        ax_via_gca = plt.gca(projection=prj3)\n        assert len(rec) == 1\n        assert 'Requested projection is different' in str(rec[0].message)\n    assert ax_via_gca is ax\n    plt.close()\n\n    # testing axes creation with subplot\n    ax = plt.subplot(121, projection=prj)\n    assert type(ax) == maxes._subplots.subplot_class_factory(PolarAxes)\n    plt.close()",
        "begin_line": 2152,
        "end_line": 2201,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.Polar.test_as_mpl_axes_api#2152",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.Polar",
        "signature": "lib.matplotlib.tests.test_axes.Polar.test_as_mpl_axes_api()",
        "snippet": "def test_as_mpl_axes_api():\n    # tests the _as_mpl_axes api\n    from matplotlib.projections.polar import PolarAxes\n    import matplotlib.axes as maxes\n\n    class Polar:\n        def __init__(self):\n            self.theta_offset = 0\n\n        def _as_mpl_axes(self):\n            # implement the matplotlib axes interface\n            return PolarAxes, {'theta_offset': self.theta_offset}\n\n    prj = Polar()\n    prj2 = Polar()\n    prj2.theta_offset = np.pi\n    prj3 = Polar()\n\n    # testing axes creation with plt.axes\n    ax = plt.axes([0, 0, 1, 1], projection=prj)\n    assert type(ax) == PolarAxes\n    ax_via_gca = plt.gca(projection=prj)\n    assert ax_via_gca is ax\n    plt.close()\n\n    # testing axes creation with gca\n    ax = plt.gca(projection=prj)\n    assert type(ax) == maxes._subplots.subplot_class_factory(PolarAxes)\n    ax_via_gca = plt.gca(projection=prj)\n    assert ax_via_gca is ax\n    # try getting the axes given a different polar projection\n    with pytest.warns(UserWarning) as rec:\n        ax_via_gca = plt.gca(projection=prj2)\n        assert len(rec) == 1\n        assert 'Requested projection is different' in str(rec[0].message)\n    assert ax_via_gca is not ax\n    assert ax.get_theta_offset() == 0\n    assert ax_via_gca.get_theta_offset() == np.pi\n    # try getting the axes given an == (not is) polar projection\n    with pytest.warns(UserWarning):\n        ax_via_gca = plt.gca(projection=prj3)\n        assert len(rec) == 1\n        assert 'Requested projection is different' in str(rec[0].message)\n    assert ax_via_gca is ax\n    plt.close()\n\n    # testing axes creation with subplot\n    ax = plt.subplot(121, projection=prj)\n    assert type(ax) == maxes._subplots.subplot_class_factory(PolarAxes)\n    plt.close()",
        "begin_line": 2152,
        "end_line": 2201,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.Polar.__init__#2158",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.Polar",
        "signature": "lib.matplotlib.tests.test_axes.Polar.__init__(self)",
        "snippet": "        def __init__(self):\n            self.theta_offset = 0",
        "begin_line": 2158,
        "end_line": 2159,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.Polar._as_mpl_axes#2161",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.Polar",
        "signature": "lib.matplotlib.tests.test_axes.Polar._as_mpl_axes(self)",
        "snippet": "        def _as_mpl_axes(self):\n            # implement the matplotlib axes interface\n            return PolarAxes, {'theta_offset': self.theta_offset}",
        "begin_line": 2161,
        "end_line": 2163,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pyplot_axes#2204",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pyplot_axes()",
        "snippet": "def test_pyplot_axes():\n    # test focusing of Axes in other Figure\n    fig1, ax1 = plt.subplots()\n    fig2, ax2 = plt.subplots()\n    plt.sca(ax1)\n    assert ax1 is plt.gca()\n    assert fig1 is plt.gcf()\n    plt.close(fig1)\n    plt.close(fig2)",
        "begin_line": 2204,
        "end_line": 2212,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_log_scales#2216",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_log_scales()",
        "snippet": "def test_log_scales():\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    ax.plot(np.log(np.linspace(0.1, 100)))\n    ax.set_yscale('log', basey=5.5)\n    ax.invert_yaxis()\n    ax.set_xscale('log', basex=9.0)",
        "begin_line": 2216,
        "end_line": 2222,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_log_scales_no_data#2225",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_log_scales_no_data()",
        "snippet": "def test_log_scales_no_data():\n    _, ax = plt.subplots()\n    ax.set(xscale=\"log\", yscale=\"log\")\n    ax.xaxis.set_major_locator(mticker.MultipleLocator(1))\n    assert ax.get_xlim() == ax.get_ylim() == (1, 10)",
        "begin_line": 2225,
        "end_line": 2229,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_log_scales_invalid#2232",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_log_scales_invalid()",
        "snippet": "def test_log_scales_invalid():\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    ax.set_xscale('log')\n    with pytest.warns(UserWarning, match='Attempted to set non-positive'):\n        ax.set_xlim(-1, 10)\n    ax.set_yscale('log')\n    with pytest.warns(UserWarning, match='Attempted to set non-positive'):\n        ax.set_ylim(-1, 10)",
        "begin_line": 2232,
        "end_line": 2240,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_no_data#2243",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_no_data()",
        "snippet": "def test_polar_no_data():\n    plt.subplot(projection=\"polar\")\n    ax = plt.gca()\n    assert ax.get_rmin() == 0 and ax.get_rmax() == 1\n    plt.close(\"all\")\n    # Used to behave differently (by triggering an autoscale with no data).\n    plt.polar()\n    ax = plt.gca()\n    assert ax.get_rmin() == 0 and ax.get_rmax() == 1",
        "begin_line": 2243,
        "end_line": 2251,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_stackplot#2255",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_stackplot()",
        "snippet": "def test_stackplot():\n    fig = plt.figure()\n    x = np.linspace(0, 10, 10)\n    y1 = 1.0 * x\n    y2 = 2.0 * x + 1\n    y3 = 3.0 * x + 2\n    ax = fig.add_subplot(1, 1, 1)\n    ax.stackplot(x, y1, y2, y3)\n    ax.set_xlim((0, 10))\n    ax.set_ylim((0, 70))\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"x\": x, \"y1\": y1, \"y2\": y2, \"y3\": y3}\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    ax.stackplot(\"x\", \"y1\", \"y2\", \"y3\", data=data)\n    ax.set_xlim((0, 10))\n    ax.set_ylim((0, 70))",
        "begin_line": 2255,
        "end_line": 2272,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_stackplot_baseline#2276",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_stackplot_baseline()",
        "snippet": "def test_stackplot_baseline():\n    np.random.seed(0)\n\n    def layers(n, m):\n        a = np.zeros((m, n))\n        for i in range(n):\n            for j in range(5):\n                x = 1 / (.1 + np.random.random())\n                y = 2 * np.random.random() - .5\n                z = 10 / (.1 + np.random.random())\n                a[:, i] += x * np.exp(-((np.arange(m) / m - y) * z) ** 2)\n        return a\n\n    d = layers(3, 100)\n    d[50, :] = 0  # test for fixed weighted wiggle (issue #6313)\n\n    fig, axs = plt.subplots(2, 2)\n\n    axs[0, 0].stackplot(range(100), d.T, baseline='zero')\n    axs[0, 1].stackplot(range(100), d.T, baseline='sym')\n    axs[1, 0].stackplot(range(100), d.T, baseline='wiggle')\n    axs[1, 1].stackplot(range(100), d.T, baseline='weighted_wiggle')",
        "begin_line": 2276,
        "end_line": 2297,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.layers#2279",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.layers(n, m)",
        "snippet": "    def layers(n, m):\n        a = np.zeros((m, n))\n        for i in range(n):\n            for j in range(5):\n                x = 1 / (.1 + np.random.random())\n                y = 2 * np.random.random() - .5\n                z = 10 / (.1 + np.random.random())\n                a[:, i] += x * np.exp(-((np.arange(m) / m - y) * z) ** 2)\n        return a",
        "begin_line": 2279,
        "end_line": 2287,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes._bxp_test_helper#2300",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes._bxp_test_helper(stats_kwargs={}, transform_stats=lambda s: s, bxp_kwargs={})",
        "snippet": "def _bxp_test_helper(\n        stats_kwargs={}, transform_stats=lambda s: s, bxp_kwargs={}):\n    np.random.seed(937)\n    logstats = mpl.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4)), **stats_kwargs)\n    fig, ax = plt.subplots()\n    if bxp_kwargs.get('vert', True):\n        ax.set_yscale('log')\n    else:\n        ax.set_xscale('log')\n    # Work around baseline images generate back when bxp did not respect the\n    # boxplot.boxprops.linewidth rcParam when patch_artist is False.\n    if not bxp_kwargs.get('patch_artist', False):\n        mpl.rcParams['boxplot.boxprops.linewidth'] = \\\n            mpl.rcParams['lines.linewidth']\n    ax.bxp(transform_stats(logstats), **bxp_kwargs)",
        "begin_line": 2300,
        "end_line": 2315,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_baseline#2321",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_baseline()",
        "snippet": "def test_bxp_baseline():\n    _bxp_test_helper()",
        "begin_line": 2321,
        "end_line": 2322,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_rangewhis#2328",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_rangewhis()",
        "snippet": "def test_bxp_rangewhis():\n    _bxp_test_helper(stats_kwargs=dict(whis=[0, 100]))",
        "begin_line": 2328,
        "end_line": 2329,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_precentilewhis#2335",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_precentilewhis()",
        "snippet": "def test_bxp_precentilewhis():\n    _bxp_test_helper(stats_kwargs=dict(whis=[5, 95]))",
        "begin_line": 2335,
        "end_line": 2336,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_with_xlabels#2342",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_with_xlabels()",
        "snippet": "def test_bxp_with_xlabels():\n    def transform(stats):\n        for s, label in zip(stats, list('ABCD')):\n            s['label'] = label\n        return stats\n\n    _bxp_test_helper(transform_stats=transform)",
        "begin_line": 2342,
        "end_line": 2348,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.transform#2343",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.transform(stats)",
        "snippet": "    def transform(stats):\n        for s, label in zip(stats, list('ABCD')):\n            s['label'] = label\n        return stats",
        "begin_line": 2343,
        "end_line": 2346,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_horizontal#2356",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_horizontal()",
        "snippet": "def test_bxp_horizontal():\n    _bxp_test_helper(bxp_kwargs=dict(vert=False))",
        "begin_line": 2356,
        "end_line": 2357,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_with_ylabels#2364",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_with_ylabels()",
        "snippet": "def test_bxp_with_ylabels():\n    def transform(stats):\n        for s, label in zip(stats, list('ABCD')):\n            s['label'] = label\n        return stats\n\n    _bxp_test_helper(transform_stats=transform, bxp_kwargs=dict(vert=False))",
        "begin_line": 2364,
        "end_line": 2370,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.transform#2365",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.transform(stats)",
        "snippet": "    def transform(stats):\n        for s, label in zip(stats, list('ABCD')):\n            s['label'] = label\n        return stats",
        "begin_line": 2365,
        "end_line": 2368,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_patchartist#2377",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_patchartist()",
        "snippet": "def test_bxp_patchartist():\n    _bxp_test_helper(bxp_kwargs=dict(patch_artist=True))",
        "begin_line": 2377,
        "end_line": 2378,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_custompatchartist#2385",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_custompatchartist()",
        "snippet": "def test_bxp_custompatchartist():\n    _bxp_test_helper(bxp_kwargs=dict(\n        patch_artist=True,\n        boxprops=dict(facecolor='yellow', edgecolor='green', ls=':')))",
        "begin_line": 2385,
        "end_line": 2388,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_customoutlier#2395",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_customoutlier()",
        "snippet": "def test_bxp_customoutlier():\n    _bxp_test_helper(bxp_kwargs=dict(\n        flierprops=dict(linestyle='none', marker='d', mfc='g')))",
        "begin_line": 2395,
        "end_line": 2397,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_showcustommean#2404",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_showcustommean()",
        "snippet": "def test_bxp_showcustommean():\n    _bxp_test_helper(bxp_kwargs=dict(\n        showmeans=True,\n        meanprops=dict(linestyle='none', marker='d', mfc='green'),\n    ))",
        "begin_line": 2404,
        "end_line": 2408,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_custombox#2415",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_custombox()",
        "snippet": "def test_bxp_custombox():\n    _bxp_test_helper(bxp_kwargs=dict(\n        boxprops=dict(linestyle='--', color='b', lw=3)))",
        "begin_line": 2415,
        "end_line": 2417,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_custommedian#2424",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_custommedian()",
        "snippet": "def test_bxp_custommedian():\n    _bxp_test_helper(bxp_kwargs=dict(\n        medianprops=dict(linestyle='--', color='b', lw=3)))",
        "begin_line": 2424,
        "end_line": 2426,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_customcap#2433",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_customcap()",
        "snippet": "def test_bxp_customcap():\n    _bxp_test_helper(bxp_kwargs=dict(\n        capprops=dict(linestyle='--', color='g', lw=3)))",
        "begin_line": 2433,
        "end_line": 2435,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_customwhisker#2442",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_customwhisker()",
        "snippet": "def test_bxp_customwhisker():\n    _bxp_test_helper(bxp_kwargs=dict(\n        whiskerprops=dict(linestyle='-', color='m', lw=3)))",
        "begin_line": 2442,
        "end_line": 2444,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_shownotches#2451",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_shownotches()",
        "snippet": "def test_bxp_shownotches():\n    _bxp_test_helper(bxp_kwargs=dict(shownotches=True))",
        "begin_line": 2451,
        "end_line": 2452,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_nocaps#2459",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_nocaps()",
        "snippet": "def test_bxp_nocaps():\n    _bxp_test_helper(bxp_kwargs=dict(showcaps=False))",
        "begin_line": 2459,
        "end_line": 2460,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_nobox#2467",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_nobox()",
        "snippet": "def test_bxp_nobox():\n    _bxp_test_helper(bxp_kwargs=dict(showbox=False))",
        "begin_line": 2467,
        "end_line": 2468,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_no_flier_stats#2475",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_no_flier_stats()",
        "snippet": "def test_bxp_no_flier_stats():\n    def transform(stats):\n        for s in stats:\n            s.pop('fliers', None)\n        return stats\n\n    _bxp_test_helper(transform_stats=transform,\n                     bxp_kwargs=dict(showfliers=False))",
        "begin_line": 2475,
        "end_line": 2482,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.transform#2476",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.transform(stats)",
        "snippet": "    def transform(stats):\n        for s in stats:\n            s.pop('fliers', None)\n        return stats",
        "begin_line": 2476,
        "end_line": 2479,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_showmean#2489",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_showmean()",
        "snippet": "def test_bxp_showmean():\n    _bxp_test_helper(bxp_kwargs=dict(showmeans=True, meanline=False))",
        "begin_line": 2489,
        "end_line": 2490,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_showmeanasline#2497",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_showmeanasline()",
        "snippet": "def test_bxp_showmeanasline():\n    _bxp_test_helper(bxp_kwargs=dict(showmeans=True, meanline=True))",
        "begin_line": 2497,
        "end_line": 2498,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_scalarwidth#2505",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_scalarwidth()",
        "snippet": "def test_bxp_scalarwidth():\n    _bxp_test_helper(bxp_kwargs=dict(widths=.25))",
        "begin_line": 2505,
        "end_line": 2506,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_customwidths#2513",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_customwidths()",
        "snippet": "def test_bxp_customwidths():\n    _bxp_test_helper(bxp_kwargs=dict(widths=[0.10, 0.25, 0.65, 0.85]))",
        "begin_line": 2513,
        "end_line": 2514,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_custompositions#2521",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_custompositions()",
        "snippet": "def test_bxp_custompositions():\n    _bxp_test_helper(bxp_kwargs=dict(positions=[1, 5, 6, 7]))",
        "begin_line": 2521,
        "end_line": 2522,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_bad_widths#2525",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_bad_widths()",
        "snippet": "def test_bxp_bad_widths():\n    with pytest.raises(ValueError):\n        _bxp_test_helper(bxp_kwargs=dict(widths=[1]))",
        "begin_line": 2525,
        "end_line": 2527,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_bad_positions#2530",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_bad_positions()",
        "snippet": "def test_bxp_bad_positions():\n    with pytest.raises(ValueError):\n        _bxp_test_helper(bxp_kwargs=dict(positions=[2, 3]))",
        "begin_line": 2530,
        "end_line": 2532,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot#2536",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot()",
        "snippet": "def test_boxplot():\n    # Randomness used for bootstrapping.\n    np.random.seed(937)\n\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n\n    ax.boxplot([x, x], bootstrap=10000, notch=1)\n    ax.set_ylim((-30, 30))\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"x\": [x, x]}\n    fig, ax = plt.subplots()\n    ax.boxplot(\"x\", bootstrap=10000, notch=1, data=data)\n    ax.set_ylim((-30, 30))",
        "begin_line": 2536,
        "end_line": 2551,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_sym2#2555",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_sym2()",
        "snippet": "def test_boxplot_sym2():\n    # Randomness used for bootstrapping.\n    np.random.seed(937)\n\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, [ax1, ax2] = plt.subplots(1, 2)\n\n    ax1.boxplot([x, x], bootstrap=10000, sym='^')\n    ax1.set_ylim((-30, 30))\n\n    ax2.boxplot([x, x], bootstrap=10000, sym='g')\n    ax2.set_ylim((-30, 30))",
        "begin_line": 2555,
        "end_line": 2567,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_sym#2574",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_sym()",
        "snippet": "def test_boxplot_sym():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n\n    ax.boxplot([x, x], sym='gs')\n    ax.set_ylim((-30, 30))",
        "begin_line": 2574,
        "end_line": 2580,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_autorange_whiskers#2586",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_autorange_whiskers()",
        "snippet": "def test_boxplot_autorange_whiskers():\n    # Randomness used for bootstrapping.\n    np.random.seed(937)\n\n    x = np.ones(140)\n    x = np.hstack([0, x, 2])\n\n    fig1, ax1 = plt.subplots()\n    ax1.boxplot([x, x], bootstrap=10000, notch=1)\n    ax1.set_ylim((-5, 5))\n\n    fig2, ax2 = plt.subplots()\n    ax2.boxplot([x, x], bootstrap=10000, notch=1, autorange=True)\n    ax2.set_ylim((-5, 5))",
        "begin_line": 2586,
        "end_line": 2599,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes._rc_test_bxp_helper#2602",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes._rc_test_bxp_helper(ax, rc_dict)",
        "snippet": "def _rc_test_bxp_helper(ax, rc_dict):\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    with matplotlib.rc_context(rc_dict):\n        ax.boxplot([x, x])\n    return ax",
        "begin_line": 2602,
        "end_line": 2607,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_rc_parameters#2613",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_rc_parameters()",
        "snippet": "def test_boxplot_rc_parameters():\n    # Randomness used for bootstrapping.\n    np.random.seed(937)\n\n    fig, ax = plt.subplots(3)\n\n    rc_axis0 = {\n        'boxplot.notch': True,\n        'boxplot.whiskers': [5, 95],\n        'boxplot.bootstrap': 10000,\n\n        'boxplot.flierprops.color': 'b',\n        'boxplot.flierprops.marker': 'o',\n        'boxplot.flierprops.markerfacecolor': 'g',\n        'boxplot.flierprops.markeredgecolor': 'b',\n        'boxplot.flierprops.markersize': 5,\n        'boxplot.flierprops.linestyle': '--',\n        'boxplot.flierprops.linewidth': 2.0,\n\n        'boxplot.boxprops.color': 'r',\n        'boxplot.boxprops.linewidth': 2.0,\n        'boxplot.boxprops.linestyle': '--',\n\n        'boxplot.capprops.color': 'c',\n        'boxplot.capprops.linewidth': 2.0,\n        'boxplot.capprops.linestyle': '--',\n\n        'boxplot.medianprops.color': 'k',\n        'boxplot.medianprops.linewidth': 2.0,\n        'boxplot.medianprops.linestyle': '--',\n    }\n\n    rc_axis1 = {\n        'boxplot.vertical': False,\n        'boxplot.whiskers': [0, 100],\n        'boxplot.patchartist': True,\n    }\n\n    rc_axis2 = {\n        'boxplot.whiskers': 2.0,\n        'boxplot.showcaps': False,\n        'boxplot.showbox': False,\n        'boxplot.showfliers': False,\n        'boxplot.showmeans': True,\n        'boxplot.meanline': True,\n\n        'boxplot.meanprops.color': 'c',\n        'boxplot.meanprops.linewidth': 2.0,\n        'boxplot.meanprops.linestyle': '--',\n\n        'boxplot.whiskerprops.color': 'r',\n        'boxplot.whiskerprops.linewidth': 2.0,\n        'boxplot.whiskerprops.linestyle': '-.',\n    }\n    dict_list = [rc_axis0, rc_axis1, rc_axis2]\n    for axis, rc_axis in zip(ax, dict_list):\n        _rc_test_bxp_helper(axis, rc_axis)\n\n    assert (matplotlib.patches.PathPatch in\n            [type(t) for t in ax[1].get_children()])",
        "begin_line": 2613,
        "end_line": 2672,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_with_CIarray#2677",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_with_CIarray()",
        "snippet": "def test_boxplot_with_CIarray():\n    # Randomness used for bootstrapping.\n    np.random.seed(937)\n\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    CIs = np.array([[-1.5, 3.], [-1., 3.5]])\n\n    # show a boxplot with Matplotlib medians and confidence intervals, and\n    # another with manual values\n    ax.boxplot([x, x], bootstrap=10000, usermedians=[None, 1.0],\n               conf_intervals=CIs, notch=1)\n    ax.set_ylim((-30, 30))",
        "begin_line": 2677,
        "end_line": 2691,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_no_weird_whisker#2696",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_no_weird_whisker()",
        "snippet": "def test_boxplot_no_weird_whisker():\n    x = np.array([3, 9000, 150, 88, 350, 200000, 1400, 960],\n                 dtype=np.float64)\n    ax1 = plt.axes()\n    ax1.boxplot(x)\n    ax1.set_yscale('log')\n    ax1.yaxis.grid(False, which='minor')\n    ax1.xaxis.grid(False)",
        "begin_line": 2696,
        "end_line": 2703,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_bad_medians_1#2706",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_bad_medians_1()",
        "snippet": "def test_boxplot_bad_medians_1():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.boxplot(x, usermedians=[1, 2])",
        "begin_line": 2706,
        "end_line": 2711,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_bad_medians_2#2714",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_bad_medians_2()",
        "snippet": "def test_boxplot_bad_medians_2():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.boxplot([x, x], usermedians=[[1, 2], [1, 2]])",
        "begin_line": 2714,
        "end_line": 2719,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_bad_ci_1#2722",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_bad_ci_1()",
        "snippet": "def test_boxplot_bad_ci_1():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.boxplot([x, x], conf_intervals=[[1, 2]])",
        "begin_line": 2722,
        "end_line": 2727,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_zorder#2730",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_zorder()",
        "snippet": "def test_boxplot_zorder():\n    x = np.arange(10)\n    fix, ax = plt.subplots()\n    assert ax.boxplot(x)['boxes'][0].get_zorder() == 2\n    assert ax.boxplot(x, zorder=10)['boxes'][0].get_zorder() == 10",
        "begin_line": 2730,
        "end_line": 2734,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_bad_ci_2#2737",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_bad_ci_2()",
        "snippet": "def test_boxplot_bad_ci_2():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.boxplot([x, x], conf_intervals=[[1, 2], [1]])",
        "begin_line": 2737,
        "end_line": 2742,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_marker_behavior#2745",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_marker_behavior()",
        "snippet": "def test_boxplot_marker_behavior():\n    plt.rcParams['lines.marker'] = 's'\n    plt.rcParams['boxplot.flierprops.marker'] = 'o'\n    plt.rcParams['boxplot.meanprops.marker'] = '^'\n    fig, ax = plt.subplots()\n    test_data = np.arange(100)\n    test_data[-1] = 150  # a flier point\n    bxp_handle = ax.boxplot(test_data, showmeans=True)\n    for bxp_lines in ['whiskers', 'caps', 'boxes', 'medians']:\n        for each_line in bxp_handle[bxp_lines]:\n            # Ensure that the rcParams['lines.marker'] is overridden by ''\n            assert each_line.get_marker() == ''\n\n    # Ensure that markers for fliers and means aren't overridden with ''\n    assert bxp_handle['fliers'][0].get_marker() == 'o'\n    assert bxp_handle['means'][0].get_marker() == '^'",
        "begin_line": 2745,
        "end_line": 2760,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_mod_artist_after_plotting#2765",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_mod_artist_after_plotting()",
        "snippet": "def test_boxplot_mod_artist_after_plotting():\n    x = [0.15, 0.11, 0.06, 0.06, 0.12, 0.56, -0.56]\n    fig, ax = plt.subplots()\n    bp = ax.boxplot(x, sym=\"o\")\n    for key in bp:\n        for obj in bp[key]:\n            obj.set_color('green')",
        "begin_line": 2765,
        "end_line": 2771,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_baseline#2776",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_baseline()",
        "snippet": "def test_vert_violinplot_baseline():\n    # First 9 digits of frac(sqrt(2))\n    np.random.seed(414213562)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax = plt.axes()\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=0)\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"d\": data}\n    fig, ax = plt.subplots()\n    ax = plt.axes()\n    ax.violinplot(\"d\", positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=0, data=data)",
        "begin_line": 2776,
        "end_line": 2789,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showmeans#2793",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showmeans()",
        "snippet": "def test_vert_violinplot_showmeans():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(3))\n    np.random.seed(732050807)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=1, showextrema=0,\n                  showmedians=0)",
        "begin_line": 2793,
        "end_line": 2799,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showextrema#2803",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showextrema()",
        "snippet": "def test_vert_violinplot_showextrema():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(5))\n    np.random.seed(236067977)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=1,\n                  showmedians=0)",
        "begin_line": 2803,
        "end_line": 2809,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showmedians#2813",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showmedians()",
        "snippet": "def test_vert_violinplot_showmedians():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(7))\n    np.random.seed(645751311)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=1)",
        "begin_line": 2813,
        "end_line": 2819,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showall#2823",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showall()",
        "snippet": "def test_vert_violinplot_showall():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(11))\n    np.random.seed(316624790)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=1, showextrema=1,\n                  showmedians=1,\n                  quantiles=[[0.1, 0.9], [0.2, 0.8], [0.3, 0.7], [0.4, 0.6]])",
        "begin_line": 2823,
        "end_line": 2830,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_custompoints_10#2834",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_custompoints_10()",
        "snippet": "def test_vert_violinplot_custompoints_10():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(13))\n    np.random.seed(605551275)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=0, points=10)",
        "begin_line": 2834,
        "end_line": 2840,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_custompoints_200#2844",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_custompoints_200()",
        "snippet": "def test_vert_violinplot_custompoints_200():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(17))\n    np.random.seed(123105625)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=0, points=200)",
        "begin_line": 2844,
        "end_line": 2850,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_baseline#2854",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_baseline()",
        "snippet": "def test_horiz_violinplot_baseline():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(19))\n    np.random.seed(358898943)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=0, showmedians=0)",
        "begin_line": 2854,
        "end_line": 2860,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showmedians#2864",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showmedians()",
        "snippet": "def test_horiz_violinplot_showmedians():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(23))\n    np.random.seed(795831523)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=0, showmedians=1)",
        "begin_line": 2864,
        "end_line": 2870,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showmeans#2874",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showmeans()",
        "snippet": "def test_horiz_violinplot_showmeans():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(29))\n    np.random.seed(385164807)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=1,\n                  showextrema=0, showmedians=0)",
        "begin_line": 2874,
        "end_line": 2880,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showextrema#2884",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showextrema()",
        "snippet": "def test_horiz_violinplot_showextrema():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(31))\n    np.random.seed(567764362)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=1, showmedians=0)",
        "begin_line": 2884,
        "end_line": 2890,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showall#2894",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showall()",
        "snippet": "def test_horiz_violinplot_showall():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(37))\n    np.random.seed(82762530)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=1,\n                  showextrema=1, showmedians=1,\n                  quantiles=[[0.1, 0.9], [0.2, 0.8], [0.3, 0.7], [0.4, 0.6]])",
        "begin_line": 2894,
        "end_line": 2901,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_custompoints_10#2905",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_custompoints_10()",
        "snippet": "def test_horiz_violinplot_custompoints_10():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(41))\n    np.random.seed(403124237)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=0, showmedians=0, points=10)",
        "begin_line": 2905,
        "end_line": 2911,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_custompoints_200#2915",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_custompoints_200()",
        "snippet": "def test_horiz_violinplot_custompoints_200():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(43))\n    np.random.seed(557438524)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=0, showmedians=0, points=200)",
        "begin_line": 2915,
        "end_line": 2921,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_violinplot_bad_positions#2924",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_violinplot_bad_positions()",
        "snippet": "def test_violinplot_bad_positions():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(47))\n    np.random.seed(855654600)\n    data = [np.random.normal(size=100) for i in range(4)]\n    with pytest.raises(ValueError):\n        ax.violinplot(data, positions=range(5))",
        "begin_line": 2924,
        "end_line": 2930,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_violinplot_bad_widths#2933",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_violinplot_bad_widths()",
        "snippet": "def test_violinplot_bad_widths():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(53))\n    np.random.seed(280109889)\n    data = [np.random.normal(size=100) for i in range(4)]\n    with pytest.raises(ValueError):\n        ax.violinplot(data, positions=range(4), widths=[1, 2, 3])",
        "begin_line": 2933,
        "end_line": 2939,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_violinplot_bad_quantiles#2942",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_violinplot_bad_quantiles()",
        "snippet": "def test_violinplot_bad_quantiles():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(73))\n    np.random.seed(544003745)\n    data = [np.random.normal(size=100)]\n\n    # Different size quantile list and plots\n    with pytest.raises(ValueError):\n        ax.violinplot(data, quantiles=[[0.1, 0.2], [0.5, 0.7]])",
        "begin_line": 2942,
        "end_line": 2950,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_violinplot_outofrange_quantiles#2953",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_violinplot_outofrange_quantiles()",
        "snippet": "def test_violinplot_outofrange_quantiles():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(79))\n    np.random.seed(888194417)\n    data = [np.random.normal(size=100)]\n\n    # Quantile value above 100\n    with pytest.raises(ValueError):\n        ax.violinplot(data, quantiles=[[0.1, 0.2, 0.3, 1.05]])\n\n    # Quantile value below 0\n    with pytest.raises(ValueError):\n        ax.violinplot(data, quantiles=[[-0.05, 0.2, 0.3, 0.75]])",
        "begin_line": 2953,
        "end_line": 2965,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_violinplot_single_list_quantiles#2969",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_violinplot_single_list_quantiles(fig_test, fig_ref)",
        "snippet": "def test_violinplot_single_list_quantiles(fig_test, fig_ref):\n    # Ensures quantile list for 1D can be passed in as single list\n    # First 9 digits of frac(sqrt(83))\n    np.random.seed(110433579)\n    data = [np.random.normal(size=100)]\n\n    # Test image\n    ax = fig_test.subplots()\n    ax.violinplot(data, quantiles=[0.1, 0.3, 0.9])\n\n    # Reference image\n    ax = fig_ref.subplots()\n    ax.violinplot(data, quantiles=[[0.1, 0.3, 0.9]])",
        "begin_line": 2969,
        "end_line": 2981,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_manage_xticks#2984",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_manage_xticks()",
        "snippet": "def test_manage_xticks():\n    _, ax = plt.subplots()\n    ax.set_xlim(0, 4)\n    old_xlim = ax.get_xlim()\n    np.random.seed(0)\n    y1 = np.random.normal(10, 3, 20)\n    y2 = np.random.normal(3, 1, 20)\n    ax.boxplot([y1, y2], positions=[1, 2], manage_ticks=False)\n    new_xlim = ax.get_xlim()\n    assert_array_equal(old_xlim, new_xlim)",
        "begin_line": 2984,
        "end_line": 2993,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_not_single#2996",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_not_single()",
        "snippet": "def test_boxplot_not_single():\n    fig, ax = plt.subplots()\n    ax.boxplot(np.random.rand(100), positions=[3])\n    ax.boxplot(np.random.rand(100), positions=[5])\n    fig.canvas.draw()\n    assert ax.get_xlim() == (2.5, 5.5)\n    assert list(ax.get_xticks()) == [3, 5]\n    assert [t.get_text() for t in ax.get_xticklabels()] == [\"3\", \"5\"]",
        "begin_line": 2996,
        "end_line": 3003,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_tick_space_size_0#3006",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_tick_space_size_0()",
        "snippet": "def test_tick_space_size_0():\n    # allow font size to be zero, which affects ticks when there is\n    # no other text in the figure.\n    plt.plot([0, 1], [0, 1])\n    matplotlib.rcParams.update({'font.size': 0})\n    b = io.BytesIO()\n    plt.savefig(b, dpi=80, format='raw')",
        "begin_line": 3006,
        "end_line": 3012,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar#3016",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar()",
        "snippet": "def test_errorbar():\n    x = np.arange(0.1, 4, 0.5)\n    y = np.exp(-x)\n\n    yerr = 0.1 + 0.2*np.sqrt(x)\n    xerr = 0.1 + yerr\n\n    # First illustrate basic pyplot interface, using defaults where possible.\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.errorbar(x, y, xerr=0.2, yerr=0.4)\n    ax.set_title(\"Simplest errorbars, 0.2 in x, 0.4 in y\")\n\n    # Now switch to a more OO interface to exercise more features.\n    fig, axs = plt.subplots(nrows=2, ncols=2, sharex=True)\n    ax = axs[0, 0]\n    # Try a Nx1 shaped error just to check\n    with pytest.warns(MatplotlibDeprecationWarning):\n        ax.errorbar(x, y, yerr=np.reshape(yerr, (len(y), 1)), fmt='o')\n    ax.set_title('Vert. symmetric')\n\n    # With 4 subplots, reduce the number of axis ticks to avoid crowding.\n    ax.locator_params(nbins=4)\n\n    ax = axs[0, 1]\n    ax.errorbar(x, y, xerr=xerr, fmt='o', alpha=0.4)\n    ax.set_title('Hor. symmetric w/ alpha')\n\n    ax = axs[1, 0]\n    ax.errorbar(x, y, yerr=[yerr, 2*yerr], xerr=[xerr, 2*xerr], fmt='--o')\n    ax.set_title('H, V asymmetric')\n\n    ax = axs[1, 1]\n    ax.set_yscale('log')\n    # Here we have to be careful to keep all y values positive:\n    ylower = np.maximum(1e-2, y - yerr)\n    yerr_lower = y - ylower\n\n    ax.errorbar(x, y, yerr=[yerr_lower, 2*yerr], xerr=xerr,\n                fmt='o', ecolor='g', capthick=2)\n    ax.set_title('Mixed sym., log y')\n\n    fig.suptitle('Variable errorbars')\n\n    # Reuse the first testcase from above for a labeled data test\n    data = {\"x\": x, \"y\": y}\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.errorbar(\"x\", \"y\", xerr=0.2, yerr=0.4, data=data)\n    ax.set_title(\"Simplest errorbars, 0.2 in x, 0.4 in y\")",
        "begin_line": 3016,
        "end_line": 3065,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar_colorcycle#3068",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar_colorcycle()",
        "snippet": "def test_errorbar_colorcycle():\n\n    f, ax = plt.subplots()\n    x = np.arange(10)\n    y = 2*x\n\n    e1, _, _ = ax.errorbar(x, y, c=None)\n    e2, _, _ = ax.errorbar(x, 2*y, c=None)\n    ln1, = ax.plot(x, 4*y)\n\n    assert mcolors.to_rgba(e1.get_color()) == mcolors.to_rgba('C0')\n    assert mcolors.to_rgba(e2.get_color()) == mcolors.to_rgba('C1')\n    assert mcolors.to_rgba(ln1.get_color()) == mcolors.to_rgba('C2')",
        "begin_line": 3068,
        "end_line": 3080,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar_shape#3083",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar_shape()",
        "snippet": "def test_errorbar_shape():\n    fig = plt.figure()\n    ax = fig.gca()\n\n    x = np.arange(0.1, 4, 0.5)\n    y = np.exp(-x)\n    yerr1 = 0.1 + 0.2*np.sqrt(x)\n    yerr = np.vstack((yerr1, 2*yerr1)).T\n    xerr = 0.1 + yerr\n\n    with pytest.raises(ValueError):\n        ax.errorbar(x, y, yerr=yerr, fmt='o')\n    with pytest.raises(ValueError):\n        ax.errorbar(x, y, xerr=xerr, fmt='o')\n    with pytest.raises(ValueError):\n        ax.errorbar(x, y, yerr=yerr, xerr=xerr, fmt='o')",
        "begin_line": 3083,
        "end_line": 3098,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar_limits#3102",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar_limits()",
        "snippet": "def test_errorbar_limits():\n    x = np.arange(0.5, 5.5, 0.5)\n    y = np.exp(-x)\n    xerr = 0.1\n    yerr = 0.2\n    ls = 'dotted'\n\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n\n    # standard error bars\n    plt.errorbar(x, y, xerr=xerr, yerr=yerr, ls=ls, color='blue')\n\n    # including upper limits\n    uplims = np.zeros_like(x)\n    uplims[[1, 5, 9]] = True\n    plt.errorbar(x, y+0.5, xerr=xerr, yerr=yerr, uplims=uplims, ls=ls,\n                 color='green')\n\n    # including lower limits\n    lolims = np.zeros_like(x)\n    lolims[[2, 4, 8]] = True\n    plt.errorbar(x, y+1.0, xerr=xerr, yerr=yerr, lolims=lolims, ls=ls,\n                 color='red')\n\n    # including upper and lower limits\n    plt.errorbar(x, y+1.5, marker='o', ms=8, xerr=xerr, yerr=yerr,\n                 lolims=lolims, uplims=uplims, ls=ls, color='magenta')\n\n    # including xlower and xupper limits\n    xerr = 0.2\n    yerr = np.full_like(x, 0.2)\n    yerr[[3, 6]] = 0.3\n    xlolims = lolims\n    xuplims = uplims\n    lolims = np.zeros_like(x)\n    uplims = np.zeros_like(x)\n    lolims[[6]] = True\n    uplims[[3]] = True\n    plt.errorbar(x, y+2.1, marker='o', ms=8, xerr=xerr, yerr=yerr,\n                 xlolims=xlolims, xuplims=xuplims, uplims=uplims,\n                 lolims=lolims, ls='none', mec='blue', capsize=0,\n                 color='cyan')\n    ax.set_xlim((0, 5.5))\n    ax.set_title('Errorbar upper and lower limits')",
        "begin_line": 3102,
        "end_line": 3146,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errobar_nonefmt#3149",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errobar_nonefmt()",
        "snippet": "def test_errobar_nonefmt():\n    # Check that passing 'none' as a format still plots errorbars\n    x = np.arange(5)\n    y = np.arange(5)\n\n    plotline, _, barlines = plt.errorbar(x, y, xerr=1, yerr=1, fmt='none')\n    assert plotline is None\n    for errbar in barlines:\n        assert np.all(errbar.get_color() == mcolors.to_rgba('C0'))",
        "begin_line": 3149,
        "end_line": 3157,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar_with_prop_cycle#3162",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar_with_prop_cycle()",
        "snippet": "def test_errorbar_with_prop_cycle():\n    _cycle = cycler(ls=['--', ':'], marker=['s', 's'], mfc=['k', 'w'])\n    plt.rc(\"axes\", prop_cycle=_cycle)\n    fig, ax = plt.subplots()\n    ax.errorbar(x=[2, 4, 10], y=[3, 2, 4], yerr=0.5)\n    ax.errorbar(x=[2, 4, 10], y=[6, 4, 2], yerr=0.5)",
        "begin_line": 3162,
        "end_line": 3167,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar_offsets#3171",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar_offsets(fig_test, fig_ref)",
        "snippet": "def test_errorbar_offsets(fig_test, fig_ref):\n    x = np.linspace(0, 1, 15)\n    y = x * (1-x)\n    yerr = y/6\n\n    ax_ref = fig_ref.subplots()\n    ax_test = fig_test.subplots()\n\n    for color, shift in zip('rgbk', [0, 0, 2, 7]):\n        y += .02\n\n        # Using feature in question\n        ax_test.errorbar(x, y, yerr, errorevery=(shift, 4),\n                         capsize=4, c=color)\n\n        # Using manual errorbars\n        # n.b. errorbar draws the main plot at z=2.1 by default\n        ax_ref.plot(x, y, c=color, zorder=2.1)\n        ax_ref.errorbar(x[shift::4], y[shift::4], yerr[shift::4],\n                        capsize=4, c=color, fmt='none')",
        "begin_line": 3171,
        "end_line": 3190,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled#3194",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled()",
        "snippet": "def test_hist_stacked_stepfilled():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    d2 = np.linspace(0, 10, 50)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), histtype=\"stepfilled\", stacked=True)\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"x\": (d1, d2)}\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(\"x\", histtype=\"stepfilled\", stacked=True, data=data)",
        "begin_line": 3194,
        "end_line": 3206,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_offset#3210",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_offset()",
        "snippet": "def test_hist_offset():\n    # make some data\n    d1 = np.linspace(0, 10, 50)\n    d2 = np.linspace(1, 3, 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(d1, bottom=5)\n    ax.hist(d2, bottom=15)",
        "begin_line": 3210,
        "end_line": 3217,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step#3221",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step()",
        "snippet": "def test_hist_step():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(d1, histtype=\"step\")\n    ax.set_ylim(0, 10)\n    ax.set_xlim(-1, 5)",
        "begin_line": 3221,
        "end_line": 3228,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step_horiz#3232",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step_horiz()",
        "snippet": "def test_hist_step_horiz():\n    # make some data\n    d1 = np.linspace(0, 10, 50)\n    d2 = np.linspace(1, 3, 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), histtype=\"step\", orientation=\"horizontal\")",
        "begin_line": 3232,
        "end_line": 3238,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_weighted#3242",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_weighted()",
        "snippet": "def test_hist_stacked_weighted():\n    # make some data\n    d1 = np.linspace(0, 10, 50)\n    d2 = np.linspace(1, 3, 20)\n    w1 = np.linspace(0.01, 3.5, 50)\n    w2 = np.linspace(0.05, 2., 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), weights=(w1, w2), histtype=\"stepfilled\", stacked=True)",
        "begin_line": 3242,
        "end_line": 3250,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_stem#3256",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_stem(use_line_collection)",
        "snippet": "def test_stem(use_line_collection):\n    x = np.linspace(0.1, 2 * np.pi, 100)\n    args = (x, np.cos(x))\n    # Label is a single space to force a legend to be drawn, but to avoid any\n    # text being drawn\n    kwargs = dict(linefmt='C2-.', markerfmt='k+', basefmt='C1-.',\n                  label=' ', use_line_collection=use_line_collection)\n\n    fig, ax = plt.subplots()\n    if use_line_collection:\n        ax.stem(*args, **kwargs)\n    else:\n        with pytest.warns(UserWarning):\n            ax.stem(*args, **kwargs)\n\n    ax.legend()",
        "begin_line": 3256,
        "end_line": 3271,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_stem_params#3275",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_stem_params(fig_test, fig_ref)",
        "snippet": "def test_stem_params(fig_test, fig_ref):\n    x = np.linspace(0, 3.14, 37)\n    y = np.sin(x)\n\n    ax = fig_test.subplots()\n    ax.stem(x, y, linefmt='grey', use_line_collection=True)\n\n    ax = fig_ref.subplots()\n    with pytest.warns(UserWarning):\n        ax.stem(x, y, linefmt='grey')",
        "begin_line": 3275,
        "end_line": 3284,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_stem_args#3287",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_stem_args()",
        "snippet": "def test_stem_args():\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n\n    x = list(range(10))\n    y = list(range(10))\n\n    # Test the call signatures\n    ax.stem(y, use_line_collection=True)\n    ax.stem(x, y, use_line_collection=True)\n    ax.stem(x, y, 'r--', use_line_collection=True)\n    ax.stem(x, y, 'r--', basefmt='b--', use_line_collection=True)",
        "begin_line": 3287,
        "end_line": 3298,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_stem_dates#3301",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_stem_dates()",
        "snippet": "def test_stem_dates():\n    fig, ax = plt.subplots(1, 1)\n    from dateutil import parser\n    x = parser.parse(\"2013-9-28 11:00:00\")\n    y = 100\n\n    x1 = parser.parse(\"2013-9-28 12:00:00\")\n    y1 = 200\n\n    ax.stem([x, x1], [y, y1], \"*-\", use_line_collection=True)",
        "begin_line": 3301,
        "end_line": 3310,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled_alpha#3314",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled_alpha()",
        "snippet": "def test_hist_stacked_stepfilled_alpha():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    d2 = np.linspace(0, 10, 50)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), histtype=\"stepfilled\", stacked=True, alpha=0.5)",
        "begin_line": 3314,
        "end_line": 3320,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_step#3324",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_step()",
        "snippet": "def test_hist_stacked_step():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    d2 = np.linspace(0, 10, 50)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), histtype=\"step\", stacked=True)",
        "begin_line": 3324,
        "end_line": 3330,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_density#3334",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_density()",
        "snippet": "def test_hist_stacked_density():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    d2 = np.linspace(0, 10, 50)\n    fig, ax = plt.subplots()\n    ax.hist((d1, d2), stacked=True, density=True)",
        "begin_line": 3334,
        "end_line": 3339,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step_bottom#3343",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step_bottom()",
        "snippet": "def test_hist_step_bottom():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(d1, bottom=np.arange(10), histtype=\"stepfilled\")",
        "begin_line": 3343,
        "end_line": 3348,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stepfilled_geometry#3351",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stepfilled_geometry()",
        "snippet": "def test_hist_stepfilled_geometry():\n    bins = [0, 1, 2, 3]\n    data = [0, 0, 1, 1, 1, 2]\n    _, _, (polygon, ) = plt.hist(data,\n                                 bins=bins,\n                                 histtype='stepfilled')\n    xy = [[0, 0], [0, 2], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1],\n          [3, 0], [2, 0], [2, 0], [1, 0], [1, 0], [0, 0]]\n    assert_array_equal(polygon.get_xy(), xy)",
        "begin_line": 3351,
        "end_line": 3359,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step_geometry#3362",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step_geometry()",
        "snippet": "def test_hist_step_geometry():\n    bins = [0, 1, 2, 3]\n    data = [0, 0, 1, 1, 1, 2]\n    _, _, (polygon, ) = plt.hist(data,\n                                 bins=bins,\n                                 histtype='step')\n    xy = [[0, 0], [0, 2], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1], [3, 0]]\n    assert_array_equal(polygon.get_xy(), xy)",
        "begin_line": 3362,
        "end_line": 3369,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stepfilled_bottom_geometry#3372",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stepfilled_bottom_geometry()",
        "snippet": "def test_hist_stepfilled_bottom_geometry():\n    bins = [0, 1, 2, 3]\n    data = [0, 0, 1, 1, 1, 2]\n    _, _, (polygon, ) = plt.hist(data,\n                                 bins=bins,\n                                 bottom=[1, 2, 1.5],\n                                 histtype='stepfilled')\n    xy = [[0, 1], [0, 3], [1, 3], [1, 5], [2, 5], [2, 2.5], [3, 2.5],\n          [3, 1.5], [2, 1.5], [2, 2], [1, 2], [1, 1], [0, 1]]\n    assert_array_equal(polygon.get_xy(), xy)",
        "begin_line": 3372,
        "end_line": 3381,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step_bottom_geometry#3384",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step_bottom_geometry()",
        "snippet": "def test_hist_step_bottom_geometry():\n    bins = [0, 1, 2, 3]\n    data = [0, 0, 1, 1, 1, 2]\n    _, _, (polygon, ) = plt.hist(data,\n                                 bins=bins,\n                                 bottom=[1, 2, 1.5],\n                                 histtype='step')\n    xy = [[0, 1], [0, 3], [1, 3], [1, 5], [2, 5], [2, 2.5], [3, 2.5], [3, 1.5]]\n    assert_array_equal(polygon.get_xy(), xy)",
        "begin_line": 3384,
        "end_line": 3392,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled_geometry#3395",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled_geometry()",
        "snippet": "def test_hist_stacked_stepfilled_geometry():\n    bins = [0, 1, 2, 3]\n    data_1 = [0, 0, 1, 1, 1, 2]\n    data_2 = [0, 1, 2]\n    _, _, patches = plt.hist([data_1, data_2],\n                             bins=bins,\n                             stacked=True,\n                             histtype='stepfilled')\n\n    assert len(patches) == 2\n\n    polygon,  = patches[0]\n    xy = [[0, 0], [0, 2], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1],\n          [3, 0], [2, 0], [2, 0], [1, 0], [1, 0], [0, 0]]\n    assert_array_equal(polygon.get_xy(), xy)\n\n    polygon,  = patches[1]\n    xy = [[0, 2], [0, 3], [1, 3], [1, 4], [2, 4], [2, 2], [3, 2],\n          [3, 1], [2, 1], [2, 3], [1, 3], [1, 2], [0, 2]]\n    assert_array_equal(polygon.get_xy(), xy)",
        "begin_line": 3395,
        "end_line": 3414,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_step_geometry#3417",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_step_geometry()",
        "snippet": "def test_hist_stacked_step_geometry():\n    bins = [0, 1, 2, 3]\n    data_1 = [0, 0, 1, 1, 1, 2]\n    data_2 = [0, 1, 2]\n    _, _, patches = plt.hist([data_1, data_2],\n                             bins=bins,\n                             stacked=True,\n                             histtype='step')\n\n    assert len(patches) == 2\n\n    polygon,  = patches[0]\n    xy = [[0, 0], [0, 2], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1], [3, 0]]\n    assert_array_equal(polygon.get_xy(), xy)\n\n    polygon,  = patches[1]\n    xy = [[0, 2], [0, 3], [1, 3], [1, 4], [2, 4], [2, 2], [3, 2], [3, 1]]\n    assert_array_equal(polygon.get_xy(), xy)",
        "begin_line": 3417,
        "end_line": 3434,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled_bottom_geometry#3437",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled_bottom_geometry()",
        "snippet": "def test_hist_stacked_stepfilled_bottom_geometry():\n    bins = [0, 1, 2, 3]\n    data_1 = [0, 0, 1, 1, 1, 2]\n    data_2 = [0, 1, 2]\n    _, _, patches = plt.hist([data_1, data_2],\n                             bins=bins,\n                             stacked=True,\n                             bottom=[1, 2, 1.5],\n                             histtype='stepfilled')\n\n    assert len(patches) == 2\n\n    polygon,  = patches[0]\n    xy = [[0, 1], [0, 3], [1, 3], [1, 5], [2, 5], [2, 2.5], [3, 2.5],\n          [3, 1.5], [2, 1.5], [2, 2], [1, 2], [1, 1], [0, 1]]\n    assert_array_equal(polygon.get_xy(), xy)\n\n    polygon,  = patches[1]\n    xy = [[0, 3], [0, 4], [1, 4], [1, 6], [2, 6], [2, 3.5], [3, 3.5],\n          [3, 2.5], [2, 2.5], [2, 5], [1, 5], [1, 3], [0, 3]]\n    assert_array_equal(polygon.get_xy(), xy)",
        "begin_line": 3437,
        "end_line": 3457,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_step_bottom_geometry#3460",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_step_bottom_geometry()",
        "snippet": "def test_hist_stacked_step_bottom_geometry():\n    bins = [0, 1, 2, 3]\n    data_1 = [0, 0, 1, 1, 1, 2]\n    data_2 = [0, 1, 2]\n    _, _, patches = plt.hist([data_1, data_2],\n                             bins=bins,\n                             stacked=True,\n                             bottom=[1, 2, 1.5],\n                             histtype='step')\n\n    assert len(patches) == 2\n\n    polygon,  = patches[0]\n    xy = [[0, 1], [0, 3], [1, 3], [1, 5], [2, 5], [2, 2.5], [3, 2.5], [3, 1.5]]\n    assert_array_equal(polygon.get_xy(), xy)\n\n    polygon,  = patches[1]\n    xy = [[0, 3], [0, 4], [1, 4], [1, 6], [2, 6], [2, 3.5], [3, 3.5], [3, 2.5]]\n    assert_array_equal(polygon.get_xy(), xy)",
        "begin_line": 3460,
        "end_line": 3478,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_bar#3482",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_bar()",
        "snippet": "def test_hist_stacked_bar():\n    # make some data\n    d = [[100, 100, 100, 100, 200, 320, 450, 80, 20, 600, 310, 800],\n         [20, 23, 50, 11, 100, 420], [120, 120, 120, 140, 140, 150, 180],\n         [60, 60, 60, 60, 300, 300, 5, 5, 5, 5, 10, 300],\n         [555, 555, 555, 30, 30, 30, 30, 30, 100, 100, 100, 100, 30, 30],\n         [30, 30, 30, 30, 400, 400, 400, 400, 400, 400, 400, 400]]\n    colors = [(0.5759849696758961, 1.0, 0.0), (0.0, 1.0, 0.350624650815206),\n              (0.0, 1.0, 0.6549834156005998), (0.0, 0.6569064625276622, 1.0),\n              (0.28302699607823545, 0.0, 1.0), (0.6849123462299822, 0.0, 1.0)]\n    labels = ['green', 'orange', ' yellow', 'magenta', 'black']\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(d, bins=10, histtype='barstacked', align='mid', color=colors,\n            label=labels)\n    ax.legend(loc='upper right', bbox_to_anchor=(1.0, 1.0), ncol=1)",
        "begin_line": 3482,
        "end_line": 3497,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_emptydata#3500",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_emptydata()",
        "snippet": "def test_hist_emptydata():\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist([[], range(10), range(10)], histtype=\"step\")",
        "begin_line": 3500,
        "end_line": 3503,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_labels#3506",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_labels()",
        "snippet": "def test_hist_labels():\n    # test singleton labels OK\n    fig, ax = plt.subplots()\n    l = ax.hist([0, 1], label=0)\n    assert l[2][0].get_label() == '0'\n    l = ax.hist([0, 1], label=[0])\n    assert l[2][0].get_label() == '0'\n    l = ax.hist([0, 1], label=None)\n    assert l[2][0].get_label() == '_nolegend_'\n    l = ax.hist([0, 1], label='0')\n    assert l[2][0].get_label() == '0'\n    l = ax.hist([0, 1], label='00')\n    assert l[2][0].get_label() == '00'",
        "begin_line": 3506,
        "end_line": 3518,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_transparent_markers#3522",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_transparent_markers()",
        "snippet": "def test_transparent_markers():\n    np.random.seed(0)\n    data = np.random.random(50)\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(data, 'D', mfc='none', markersize=100)",
        "begin_line": 3522,
        "end_line": 3528,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_rgba_markers#3532",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_rgba_markers()",
        "snippet": "def test_rgba_markers():\n    fig, axs = plt.subplots(ncols=2)\n    rcolors = [(1, 0, 0, 1), (1, 0, 0, 0.5)]\n    bcolors = [(0, 0, 1, 1), (0, 0, 1, 0.5)]\n    alphas = [None, 0.2]\n    kw = dict(ms=100, mew=20)\n    for i, alpha in enumerate(alphas):\n        for j, rcolor in enumerate(rcolors):\n            for k, bcolor in enumerate(bcolors):\n                axs[i].plot(j+1, k+1, 'o', mfc=bcolor, mec=rcolor,\n                            alpha=alpha, **kw)\n                axs[i].plot(j+1, k+3, 'x', mec=rcolor, alpha=alpha, **kw)\n    for ax in axs:\n        ax.axis([-1, 4, 0, 5])",
        "begin_line": 3532,
        "end_line": 3545,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_mollweide_grid#3549",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_mollweide_grid()",
        "snippet": "def test_mollweide_grid():\n    # test that both horizontal and vertical gridlines appear on the Mollweide\n    # projection\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='mollweide')\n    ax.grid()",
        "begin_line": 3549,
        "end_line": 3554,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_mollweide_forward_inverse_closure#3557",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_mollweide_forward_inverse_closure()",
        "snippet": "def test_mollweide_forward_inverse_closure():\n    # test that the round-trip Mollweide forward->inverse transformation is an\n    # approximate identity\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='mollweide')\n\n    # set up 1-degree grid in longitude, latitude\n    lon = np.linspace(-np.pi, np.pi, 360)\n    lat = np.linspace(-np.pi / 2.0, np.pi / 2.0, 180)\n    lon, lat = np.meshgrid(lon, lat)\n    ll = np.vstack((lon.flatten(), lat.flatten())).T\n\n    # perform forward transform\n    xy = ax.transProjection.transform(ll)\n\n    # perform inverse transform\n    ll2 = ax.transProjection.inverted().transform(xy)\n\n    # compare\n    np.testing.assert_array_almost_equal(ll, ll2, 3)",
        "begin_line": 3557,
        "end_line": 3576,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_mollweide_inverse_forward_closure#3579",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_mollweide_inverse_forward_closure()",
        "snippet": "def test_mollweide_inverse_forward_closure():\n    # test that the round-trip Mollweide inverse->forward transformation is an\n    # approximate identity\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='mollweide')\n\n    # set up grid in x, y\n    x = np.linspace(0, 1, 500)\n    x, y = np.meshgrid(x, x)\n    xy = np.vstack((x.flatten(), y.flatten())).T\n\n    # perform inverse transform\n    ll = ax.transProjection.inverted().transform(xy)\n\n    # perform forward transform\n    xy2 = ax.transProjection.transform(ll)\n\n    # compare\n    np.testing.assert_array_almost_equal(xy, xy2, 3)",
        "begin_line": 3579,
        "end_line": 3597,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_alpha#3601",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_alpha()",
        "snippet": "def test_alpha():\n    np.random.seed(0)\n    data = np.random.random(50)\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n\n    # alpha=.5 markers, solid line\n    ax.plot(data, '-D', color=[1, 0, 0], mfc=[1, 0, 0, .5],\n            markersize=20, lw=10)\n\n    # everything solid by kwarg\n    ax.plot(data + 2, '-D', color=[1, 0, 0, .5], mfc=[1, 0, 0, .5],\n            markersize=20, lw=10,\n            alpha=1)\n\n    # everything alpha=.5 by kwarg\n    ax.plot(data + 4, '-D', color=[1, 0, 0], mfc=[1, 0, 0],\n            markersize=20, lw=10,\n            alpha=.5)\n\n    # everything alpha=.5 by colors\n    ax.plot(data + 6, '-D', color=[1, 0, 0, .5], mfc=[1, 0, 0, .5],\n            markersize=20, lw=10)\n\n    # alpha=.5 line, solid markers\n    ax.plot(data + 8, '-D', color=[1, 0, 0, .5], mfc=[1, 0, 0],\n            markersize=20, lw=10)",
        "begin_line": 3601,
        "end_line": 3628,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eventplot#3632",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eventplot()",
        "snippet": "def test_eventplot():\n    np.random.seed(0)\n\n    data1 = np.random.random([32, 20]).tolist()\n    data2 = np.random.random([6, 20]).tolist()\n    data = data1 + data2\n    num_datasets = len(data)\n\n    colors1 = [[0, 1, .7]] * len(data1)\n    colors2 = [[1, 0, 0],\n               [0, 1, 0],\n               [0, 0, 1],\n               [1, .75, 0],\n               [1, 0, 1],\n               [0, 1, 1]]\n    colors = colors1 + colors2\n\n    lineoffsets1 = 12 + np.arange(0, len(data1)) * .33\n    lineoffsets2 = [-15, -3, 1, 1.5, 6, 10]\n    lineoffsets = lineoffsets1.tolist() + lineoffsets2\n\n    linelengths1 = [.33] * len(data1)\n    linelengths2 = [5, 2, 1, 1, 3, 1.5]\n    linelengths = linelengths1 + linelengths2\n\n    fig = plt.figure()\n    axobj = fig.add_subplot(111)\n    colls = axobj.eventplot(data, colors=colors, lineoffsets=lineoffsets,\n                            linelengths=linelengths)\n\n    num_collections = len(colls)\n    assert num_collections == num_datasets\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"pos\": data, \"c\": colors, \"lo\": lineoffsets, \"ll\": linelengths}\n    fig = plt.figure()\n    axobj = fig.add_subplot(111)\n    colls = axobj.eventplot(\"pos\", colors=\"c\", lineoffsets=\"lo\",\n                            linelengths=\"ll\", data=data)\n    num_collections = len(colls)\n    assert num_collections == num_datasets",
        "begin_line": 3632,
        "end_line": 3672,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eventplot_defaults#3676",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eventplot_defaults()",
        "snippet": "def test_eventplot_defaults():\n    \"\"\"\n    test that eventplot produces the correct output given the default params\n    (see bug #3728)\n    \"\"\"\n    np.random.seed(0)\n\n    data1 = np.random.random([32, 20]).tolist()\n    data2 = np.random.random([6, 20]).tolist()\n    data = data1 + data2\n\n    fig = plt.figure()\n    axobj = fig.add_subplot(111)\n    axobj.eventplot(data)",
        "begin_line": 3676,
        "end_line": 3689,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eventplot_colors#3697",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eventplot_colors(colors)",
        "snippet": "def test_eventplot_colors(colors):\n    \"\"\"Test the *colors* parameter of eventplot. Inspired by the issue #8193.\n    \"\"\"\n    data = [[i] for i in range(4)]  # 4 successive events of different nature\n\n    # Build the list of the expected colors\n    expected = [c if c is not None else 'C0' for c in colors]\n    # Convert the list into an array of RGBA values\n    # NB: ['rgbk'] is not a valid argument for to_rgba_array, while 'rgbk' is.\n    if len(expected) == 1:\n        expected = expected[0]\n    expected = np.broadcast_to(mcolors.to_rgba_array(expected), (len(data), 4))\n\n    fig, ax = plt.subplots()\n    if len(colors) == 1:  # tuple with a single string (like '0.5' or 'rgbk')\n        colors = colors[0]\n    collections = ax.eventplot(data, colors=colors)\n\n    for coll, color in zip(collections, expected):\n        assert_allclose(coll.get_color(), color)",
        "begin_line": 3697,
        "end_line": 3716,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eventplot_problem_kwargs#3720",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eventplot_problem_kwargs(recwarn)",
        "snippet": "def test_eventplot_problem_kwargs(recwarn):\n    \"\"\"\n    test that 'singular' versions of LineCollection props raise an\n    IgnoredKeywordWarning rather than overriding the 'plural' versions (e.g.\n    to prevent 'color' from overriding 'colors', see issue #4297)\n    \"\"\"\n    np.random.seed(0)\n\n    data1 = np.random.random([20]).tolist()\n    data2 = np.random.random([10]).tolist()\n    data = [data1, data2]\n\n    fig = plt.figure()\n    axobj = fig.add_subplot(111)\n\n    axobj.eventplot(data,\n                    colors=['r', 'b'],\n                    color=['c', 'm'],\n                    linewidths=[2, 1],\n                    linewidth=[1, 2],\n                    linestyles=['solid', 'dashed'],\n                    linestyle=['dashdot', 'dotted'])\n\n    # check that three IgnoredKeywordWarnings were raised\n    assert len(recwarn) == 3\n    assert all(issubclass(wi.category, MatplotlibDeprecationWarning)\n               for wi in recwarn)",
        "begin_line": 3720,
        "end_line": 3746,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_empty_eventplot#3749",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_empty_eventplot()",
        "snippet": "def test_empty_eventplot():\n    fig, ax = plt.subplots(1, 1)\n    ax.eventplot([[]], colors=[(0.0, 0.0, 0.0, 0.0)])\n    plt.draw()",
        "begin_line": 3749,
        "end_line": 3752,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eventplot_orientation#3758",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eventplot_orientation(data, orientation)",
        "snippet": "def test_eventplot_orientation(data, orientation):\n    \"\"\"Introduced when fixing issue #6412.\"\"\"\n    opts = {} if orientation == \"_empty\" else {'orientation': orientation}\n    fig, ax = plt.subplots(1, 1)\n    ax.eventplot(data, **opts)\n    plt.draw()",
        "begin_line": 3758,
        "end_line": 3763,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_marker_styles#3767",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_marker_styles()",
        "snippet": "def test_marker_styles():\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    for y, marker in enumerate(sorted(matplotlib.markers.MarkerStyle.markers,\n                                      key=lambda x: str(type(x))+str(x))):\n        ax.plot((y % 2)*5 + np.arange(10)*10, np.ones(10)*10*y, linestyle='',\n                marker=marker, markersize=10+y/5, label=marker)",
        "begin_line": 3767,
        "end_line": 3773,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markers_fillstyle_rcparams#3777",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markers_fillstyle_rcparams()",
        "snippet": "def test_markers_fillstyle_rcparams():\n    fig, ax = plt.subplots()\n    x = np.arange(7)\n    for idx, (style, marker) in enumerate(\n            [('top', 's'), ('bottom', 'o'), ('none', '^')]):\n        matplotlib.rcParams['markers.fillstyle'] = style\n        ax.plot(x+idx, marker=marker)",
        "begin_line": 3777,
        "end_line": 3783,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vertex_markers#3787",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vertex_markers()",
        "snippet": "def test_vertex_markers():\n    data = list(range(10))\n    marker_as_tuple = ((-1, -1), (1, -1), (1, 1), (-1, 1))\n    marker_as_list = [(-1, -1), (1, -1), (1, 1), (-1, 1)]\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(data, linestyle='', marker=marker_as_tuple, mfc='k')\n    ax.plot(data[::-1], linestyle='', marker=marker_as_list, mfc='b')\n    ax.set_xlim([-1, 10])\n    ax.set_ylim([-1, 10])",
        "begin_line": 3787,
        "end_line": 3796,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eb_line_zorder#3801",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eb_line_zorder()",
        "snippet": "def test_eb_line_zorder():\n    x = list(range(10))\n\n    # First illustrate basic pyplot interface, using defaults where possible.\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.plot(x, lw=10, zorder=5)\n    ax.axhline(1, color='red', lw=10, zorder=1)\n    ax.axhline(5, color='green', lw=10, zorder=10)\n    ax.axvline(7, color='m', lw=10, zorder=7)\n    ax.axvline(2, color='k', lw=10, zorder=3)\n\n    ax.set_title(\"axvline and axhline zorder test\")\n\n    # Now switch to a more OO interface to exercise more features.\n    fig = plt.figure()\n    ax = fig.gca()\n    x = list(range(10))\n    y = np.zeros(10)\n    yerr = list(range(10))\n    ax.errorbar(x, y, yerr=yerr, zorder=5, lw=5, color='r')\n    for j in range(10):\n        ax.axhline(j, lw=5, color='k', zorder=j)\n        ax.axhline(-j, lw=5, color='k', zorder=j)\n\n    ax.set_title(\"errorbar zorder test\")",
        "begin_line": 3801,
        "end_line": 3826,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axline#3830",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axline(fig_test, fig_ref)",
        "snippet": "def test_axline(fig_test, fig_ref):\n    ax = fig_test.subplots()\n    ax.set(xlim=(-1, 1), ylim=(-1, 1))\n    ax.axline((0, 0), (1, 1))\n    ax.axline((0, 0), (1, 0), color='C1')\n    ax.axline((0, 0.5), (1, 0.5), color='C2')\n\n    ax = fig_ref.subplots()\n    ax.set(xlim=(-1, 1), ylim=(-1, 1))\n    ax.plot([-1, 1], [-1, 1])\n    ax.axhline(0, color='C1')\n    ax.axhline(0.5, color='C2')",
        "begin_line": 3830,
        "end_line": 3841,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vlines#3846",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vlines()",
        "snippet": "def test_vlines():\n    # normal\n    x1 = [2, 3, 4, 5, 7]\n    y1 = [2, -6, 3, 8, 2]\n    fig1, ax1 = plt.subplots()\n    ax1.vlines(x1, 0, y1, colors='g', linewidth=5)\n\n    # GH #7406\n    x2 = [2, 3, 4, 5, 6, 7]\n    y2 = [2, -6, 3, 8, np.nan, 2]\n    fig2, (ax2, ax3, ax4) = plt.subplots(nrows=3, figsize=(4, 8))\n    ax2.vlines(x2, 0, y2, colors='g', linewidth=5)\n\n    x3 = [2, 3, 4, 5, 6, 7]\n    y3 = [np.nan, 2, -6, 3, 8, 2]\n    ax3.vlines(x3, 0, y3, colors='r', linewidth=3, linestyle='--')\n\n    x4 = [2, 3, 4, 5, 6, 7]\n    y4 = [np.nan, 2, -6, 3, 8, np.nan]\n    ax4.vlines(x4, 0, y4, colors='k', linewidth=2)\n\n    # tweak the x-axis so we can see the lines better\n    for ax in [ax1, ax2, ax3, ax4]:\n        ax.set_xlim(0, 10)\n\n    # check that the y-lims are all automatically the same\n    assert ax1.get_ylim() == ax2.get_ylim()\n    assert ax1.get_ylim() == ax3.get_ylim()\n    assert ax1.get_ylim() == ax4.get_ylim()\n\n    fig3, ax5 = plt.subplots()\n    x5 = np.ma.masked_equal([2, 4, 6, 8, 10, 12], 8)\n    ymin5 = np.ma.masked_equal([0, 1, -1, 0, 2, 1], 2)\n    ymax5 = np.ma.masked_equal([13, 14, 15, 16, 17, 18], 18)\n    ax5.vlines(x5, ymin5, ymax5, colors='k', linewidth=2)\n    ax5.set_xlim(0, 15)",
        "begin_line": 3846,
        "end_line": 3881,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hlines#3886",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hlines()",
        "snippet": "def test_hlines():\n    # normal\n    y1 = [2, 3, 4, 5, 7]\n    x1 = [2, -6, 3, 8, 2]\n    fig1, ax1 = plt.subplots()\n    ax1.hlines(y1, 0, x1, colors='g', linewidth=5)\n\n    # GH #7406\n    y2 = [2, 3, 4, 5, 6, 7]\n    x2 = [2, -6, 3, 8, np.nan, 2]\n    fig2, (ax2, ax3, ax4) = plt.subplots(nrows=3, figsize=(4, 8))\n    ax2.hlines(y2, 0, x2, colors='g', linewidth=5)\n\n    y3 = [2, 3, 4, 5, 6, 7]\n    x3 = [np.nan, 2, -6, 3, 8, 2]\n    ax3.hlines(y3, 0, x3, colors='r', linewidth=3, linestyle='--')\n\n    y4 = [2, 3, 4, 5, 6, 7]\n    x4 = [np.nan, 2, -6, 3, 8, np.nan]\n    ax4.hlines(y4, 0, x4, colors='k', linewidth=2)\n\n    # tweak the y-axis so we can see the lines better\n    for ax in [ax1, ax2, ax3, ax4]:\n        ax.set_ylim(0, 10)\n\n    # check that the x-lims are all automatically the same\n    assert ax1.get_xlim() == ax2.get_xlim()\n    assert ax1.get_xlim() == ax3.get_xlim()\n    assert ax1.get_xlim() == ax4.get_xlim()\n\n    fig3, ax5 = plt.subplots()\n    y5 = np.ma.masked_equal([2, 4, 6, 8, 10, 12], 8)\n    xmin5 = np.ma.masked_equal([0, 1, -1, 0, 2, 1], 2)\n    xmax5 = np.ma.masked_equal([13, 14, 15, 16, 17, 18], 18)\n    ax5.hlines(y5, xmin5, xmax5, colors='k', linewidth=2)\n    ax5.set_ylim(0, 15)",
        "begin_line": 3886,
        "end_line": 3921,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_step_linestyle#3925",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_step_linestyle()",
        "snippet": "def test_step_linestyle():\n    x = y = np.arange(10)\n\n    # First illustrate basic pyplot interface, using defaults where possible.\n    fig, ax_lst = plt.subplots(2, 2)\n    ax_lst = ax_lst.flatten()\n\n    ln_styles = ['-', '--', '-.', ':']\n\n    for ax, ls in zip(ax_lst, ln_styles):\n        ax.step(x, y, lw=5, linestyle=ls, where='pre')\n        ax.step(x, y + 1, lw=5, linestyle=ls, where='mid')\n        ax.step(x, y + 2, lw=5, linestyle=ls, where='post')\n        ax.set_xlim([-1, 5])\n        ax.set_ylim([-1, 7])\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"X\": x, \"Y0\": y, \"Y1\": y+1, \"Y2\": y+2}\n    fig, ax_lst = plt.subplots(2, 2)\n    ax_lst = ax_lst.flatten()\n    ln_styles = ['-', '--', '-.', ':']\n    for ax, ls in zip(ax_lst, ln_styles):\n        ax.step(\"X\", \"Y0\", lw=5, linestyle=ls, where='pre', data=data)\n        ax.step(\"X\", \"Y1\", lw=5, linestyle=ls, where='mid', data=data)\n        ax.step(\"X\", \"Y2\", lw=5, linestyle=ls, where='post', data=data)\n        ax.set_xlim([-1, 5])\n        ax.set_ylim([-1, 7])",
        "begin_line": 3925,
        "end_line": 3951,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_mixed_collection#3955",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_mixed_collection()",
        "snippet": "def test_mixed_collection():\n    from matplotlib import patches\n    from matplotlib import collections\n\n    # First illustrate basic pyplot interface, using defaults where possible.\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n\n    c = patches.Circle((8, 8), radius=4, facecolor='none', edgecolor='green')\n\n    # PDF can optimize this one\n    p1 = collections.PatchCollection([c], match_original=True)\n    p1.set_offsets([[0, 0], [24, 24]])\n    p1.set_linewidths([1, 5])\n\n    # PDF can't optimize this one, because the alpha of the edge changes\n    p2 = collections.PatchCollection([c], match_original=True)\n    p2.set_offsets([[48, 0], [-32, -16]])\n    p2.set_linewidths([1, 5])\n    p2.set_edgecolors([[0, 0, 0.1, 1.0], [0, 0, 0.1, 0.5]])\n\n    ax.patch.set_color('0.5')\n    ax.add_collection(p1)\n    ax.add_collection(p2)\n\n    ax.set_xlim(0, 16)\n    ax.set_ylim(0, 16)",
        "begin_line": 3955,
        "end_line": 3981,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_subplot_key_hash#3984",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_subplot_key_hash()",
        "snippet": "def test_subplot_key_hash():\n    ax = plt.subplot(np.float64(5.5), np.int64(1), np.float64(1.2))\n    ax.twinx()\n    assert ax.get_subplotspec().get_geometry() == (5, 1, 0, 0)",
        "begin_line": 3984,
        "end_line": 3987,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_freqs#3992",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_freqs()",
        "snippet": "def test_specgram_freqs():\n    \"\"\"test axes.specgram in default (psd) mode with sinusoidal stimuli\"\"\"\n\n    # use former defaults to match existing baseline image\n    matplotlib.rcParams['image.interpolation'] = 'nearest'\n\n    n = 1000\n    Fs = 10.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    fstims2 = [Fs/4.7, Fs/5.6, Fs/11.9]\n\n    NFFT = int(10 * Fs / min(fstims1 + fstims2))\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y1 = np.zeros(x.size)\n    y2 = np.zeros(x.size)\n    for fstim1, fstim2 in zip(fstims1, fstims2):\n        y1 += np.sin(fstim1 * x * np.pi * 2)\n        y2 += np.sin(fstim2 * x * np.pi * 2)\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n    fig2 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax21 = fig2.add_subplot(3, 1, 1)\n    ax22 = fig2.add_subplot(3, 1, 2)\n    ax23 = fig2.add_subplot(3, 1, 3)\n\n    ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='default')\n    ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='onesided')\n    ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='twosided')\n\n    ax21.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='default',\n                  scale='linear', norm=matplotlib.colors.LogNorm())\n    ax22.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='onesided',\n                  scale='linear', norm=matplotlib.colors.LogNorm())\n    ax23.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='twosided',\n                  scale='linear', norm=matplotlib.colors.LogNorm())",
        "begin_line": 3992,
        "end_line": 4043,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_noise#4048",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_noise()",
        "snippet": "def test_specgram_noise():\n    \"\"\"test axes.specgram in default (psd) mode with noise stimuli\"\"\"\n\n    # use former defaults to match existing baseline image\n    matplotlib.rcParams['image.interpolation'] = 'nearest'\n\n    np.random.seed(0)\n\n    n = 1000\n    Fs = 10.\n\n    NFFT = int(10 * Fs / 11)\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n    fig2 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax21 = fig2.add_subplot(3, 1, 1)\n    ax22 = fig2.add_subplot(3, 1, 2)\n    ax23 = fig2.add_subplot(3, 1, 3)\n\n    ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='default')\n    ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='onesided')\n    ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='twosided')\n\n    ax21.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='default',\n                  scale='linear', norm=matplotlib.colors.LogNorm())\n    ax22.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='onesided',\n                  scale='linear', norm=matplotlib.colors.LogNorm())\n    ax23.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='twosided',\n                  scale='linear', norm=matplotlib.colors.LogNorm())",
        "begin_line": 4048,
        "end_line": 4093,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_magnitude_freqs#4099",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_magnitude_freqs()",
        "snippet": "def test_specgram_magnitude_freqs():\n    \"\"\"test axes.specgram in magnitude mode with sinusoidal stimuli\"\"\"\n\n    # use former defaults to match existing baseline image\n    matplotlib.rcParams['image.interpolation'] = 'nearest'\n\n    n = 1000\n    Fs = 10.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    fstims2 = [Fs/4.7, Fs/5.6, Fs/11.9]\n\n    NFFT = int(100 * Fs / min(fstims1 + fstims2))\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y1 = np.zeros(x.size)\n    y2 = np.zeros(x.size)\n    for i, (fstim1, fstim2) in enumerate(zip(fstims1, fstims2)):\n        y1 += np.sin(fstim1 * x * np.pi * 2)\n        y2 += np.sin(fstim2 * x * np.pi * 2)\n        y1[-1] = y1[-1]/y1[-1]\n        y2[-1] = y2[-1]/y2[-1]\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n    fig2 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax21 = fig2.add_subplot(3, 1, 1)\n    ax22 = fig2.add_subplot(3, 1, 2)\n    ax23 = fig2.add_subplot(3, 1, 3)\n\n    ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='default', mode='magnitude')\n    ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='onesided', mode='magnitude')\n    ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='twosided', mode='magnitude')\n\n    ax21.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='default', mode='magnitude',\n                  scale='linear', norm=matplotlib.colors.LogNorm())\n    ax22.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='onesided', mode='magnitude',\n                  scale='linear', norm=matplotlib.colors.LogNorm())\n    ax23.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='twosided', mode='magnitude',\n                  scale='linear', norm=matplotlib.colors.LogNorm())",
        "begin_line": 4099,
        "end_line": 4152,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_magnitude_noise#4158",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_magnitude_noise()",
        "snippet": "def test_specgram_magnitude_noise():\n    \"\"\"test axes.specgram in magnitude mode with noise stimuli\"\"\"\n\n    # use former defaults to match existing baseline image\n    matplotlib.rcParams['image.interpolation'] = 'nearest'\n\n    np.random.seed(0)\n\n    n = 1000\n    Fs = 10.\n\n    NFFT = int(10 * Fs / 11)\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n    fig2 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax21 = fig2.add_subplot(3, 1, 1)\n    ax22 = fig2.add_subplot(3, 1, 2)\n    ax23 = fig2.add_subplot(3, 1, 3)\n\n    ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='default', mode='magnitude')\n    ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='onesided', mode='magnitude')\n    ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='twosided', mode='magnitude')\n\n    ax21.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='default', mode='magnitude',\n                  scale='linear', norm=matplotlib.colors.LogNorm())\n    ax22.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='onesided', mode='magnitude',\n                  scale='linear', norm=matplotlib.colors.LogNorm())\n    ax23.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='twosided', mode='magnitude',\n                  scale='linear', norm=matplotlib.colors.LogNorm())",
        "begin_line": 4158,
        "end_line": 4203,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_angle_freqs#4208",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_angle_freqs()",
        "snippet": "def test_specgram_angle_freqs():\n    \"\"\"test axes.specgram in angle mode with sinusoidal stimuli\"\"\"\n\n    # use former defaults to match existing baseline image\n    matplotlib.rcParams['image.interpolation'] = 'nearest'\n\n    n = 1000\n    Fs = 10.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    fstims2 = [Fs/4.7, Fs/5.6, Fs/11.9]\n\n    NFFT = int(10 * Fs / min(fstims1 + fstims2))\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y1 = np.zeros(x.size)\n    y2 = np.zeros(x.size)\n    for i, (fstim1, fstim2) in enumerate(zip(fstims1, fstims2)):\n        y1 += np.sin(fstim1 * x * np.pi * 2)\n        y2 += np.sin(fstim2 * x * np.pi * 2)\n        y1[-1] = y1[-1]/y1[-1]\n        y2[-1] = y2[-1]/y2[-1]\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='default', mode='angle')\n    ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='onesided', mode='angle')\n    ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='twosided', mode='angle')\n\n    with pytest.raises(ValueError):\n        ax11.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='default',\n                      mode='phase', scale='dB')\n\n    with pytest.raises(ValueError):\n        ax12.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='onesided',\n                      mode='phase', scale='dB')\n\n    with pytest.raises(ValueError):\n        ax13.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='twosided',\n                      mode='phase', scale='dB')",
        "begin_line": 4208,
        "end_line": 4261,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_noise_angle#4266",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_noise_angle()",
        "snippet": "def test_specgram_noise_angle():\n    \"\"\"test axes.specgram in angle mode with noise stimuli\"\"\"\n\n    # use former defaults to match existing baseline image\n    matplotlib.rcParams['image.interpolation'] = 'nearest'\n\n    np.random.seed(0)\n\n    n = 1000\n    Fs = 10.\n\n    NFFT = int(10 * Fs / 11)\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='default', mode='angle')\n    ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='onesided', mode='angle')\n    ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='twosided', mode='angle')\n\n    with pytest.raises(ValueError):\n        ax11.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='default',\n                      mode='phase', scale='dB')\n\n    with pytest.raises(ValueError):\n        ax12.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='onesided',\n                      mode='phase', scale='dB')\n\n    with pytest.raises(ValueError):\n        ax13.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='twosided',\n                      mode='phase', scale='dB')",
        "begin_line": 4266,
        "end_line": 4311,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_freqs_phase#4316",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_freqs_phase()",
        "snippet": "def test_specgram_freqs_phase():\n    \"\"\"test axes.specgram in phase mode with sinusoidal stimuli\"\"\"\n\n    # use former defaults to match existing baseline image\n    matplotlib.rcParams['image.interpolation'] = 'nearest'\n    n = 1000\n    Fs = 10.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    fstims2 = [Fs/4.7, Fs/5.6, Fs/11.9]\n\n    NFFT = int(10 * Fs / min(fstims1 + fstims2))\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y1 = np.zeros(x.size)\n    y2 = np.zeros(x.size)\n    for i, (fstim1, fstim2) in enumerate(zip(fstims1, fstims2)):\n        y1 += np.sin(fstim1 * x * np.pi * 2)\n        y2 += np.sin(fstim2 * x * np.pi * 2)\n        y1[-1] = y1[-1]/y1[-1]\n        y2[-1] = y2[-1]/y2[-1]\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='default', mode='phase')\n    ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='onesided', mode='phase')\n    ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='twosided', mode='phase')\n\n    with pytest.raises(ValueError):\n        ax11.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='default',\n                      mode='phase', scale='dB')\n\n    with pytest.raises(ValueError):\n        ax12.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='onesided',\n                      mode='phase', scale='dB')\n\n    with pytest.raises(ValueError):\n        ax13.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='twosided',\n                      mode='phase', scale='dB')",
        "begin_line": 4316,
        "end_line": 4368,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_noise_phase#4373",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_noise_phase()",
        "snippet": "def test_specgram_noise_phase():\n    \"\"\"test axes.specgram in phase mode with noise stimuli\"\"\"\n\n    # use former defaults to match existing baseline image\n    matplotlib.rcParams['image.interpolation'] = 'nearest'\n    np.random.seed(0)\n\n    n = 1000\n    Fs = 10.\n\n    NFFT = int(10 * Fs / 11)\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2])\n\n    fig1 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax11.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='default', mode='phase')\n    ax12.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='onesided', mode='phase')\n    ax13.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                  pad_to=pad_to, sides='twosided', mode='phase')\n\n    with pytest.raises(ValueError):\n        ax11.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='default',\n                      mode='phase', scale='dB')\n\n    with pytest.raises(ValueError):\n        ax12.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='onesided',\n                      mode='phase', scale='dB')\n\n    with pytest.raises(ValueError):\n        ax13.specgram(y, NFFT=NFFT, Fs=Fs,\n                      noverlap=noverlap, pad_to=pad_to, sides='twosided',\n                      mode='phase', scale='dB')",
        "begin_line": 4373,
        "end_line": 4417,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_psd_freqs#4421",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_psd_freqs()",
        "snippet": "def test_psd_freqs():\n    \"\"\"test axes.psd with sinusoidal stimuli\"\"\"\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    fstims2 = [Fs/4.7, Fs/5.6, Fs/11.9]\n\n    NFFT = int(1000 * Fs / min(fstims1 + fstims2))\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y1 = np.zeros(x.size)\n    y2 = np.zeros(x.size)\n    for fstim1, fstim2 in zip(fstims1, fstims2):\n        y1 += np.sin(fstim1 * x * np.pi * 2)\n        y2 += np.sin(fstim2 * x * np.pi * 2)\n    y = np.hstack([y1, y2])\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    psd1, freqs1 = ax1.psd(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default')\n    psd2, freqs2 = ax2.psd(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided',\n                           return_line=False)\n    psd3, freqs3, line3 = ax3.psd(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                                  pad_to=pad_to, sides='twosided',\n                                  return_line=True)\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')",
        "begin_line": 4421,
        "end_line": 4461,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_psd_noise#4465",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_psd_noise()",
        "snippet": "def test_psd_noise():\n    \"\"\"test axes.psd with noise stimuli\"\"\"\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2])\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    psd1, freqs1 = ax1.psd(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default')\n    psd2, freqs2 = ax2.psd(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided',\n                           return_line=False)\n    psd3, freqs3, line3 = ax3.psd(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                                  pad_to=pad_to, sides='twosided',\n                                  return_line=True)\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')",
        "begin_line": 4465,
        "end_line": 4499,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_csd_freqs#4503",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_csd_freqs()",
        "snippet": "def test_csd_freqs():\n    \"\"\"test axes.csd with sinusoidal stimuli\"\"\"\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    fstims2 = [Fs/4.7, Fs/5.6, Fs/11.9]\n\n    NFFT = int(1000 * Fs / min(fstims1 + fstims2))\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y1 = np.zeros(x.size)\n    y2 = np.zeros(x.size)\n    for fstim1, fstim2 in zip(fstims1, fstims2):\n        y1 += np.sin(fstim1 * x * np.pi * 2)\n        y2 += np.sin(fstim2 * x * np.pi * 2)\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    csd1, freqs1 = ax1.csd(y1, y2, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default')\n    csd2, freqs2 = ax2.csd(y1, y2, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided',\n                           return_line=False)\n    csd3, freqs3, line3 = ax3.csd(y1, y2, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                                  pad_to=pad_to, sides='twosided',\n                                  return_line=True)\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')",
        "begin_line": 4503,
        "end_line": 4542,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_csd_noise#4546",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_csd_noise()",
        "snippet": "def test_csd_noise():\n    \"\"\"test axes.csd with noise stimuli\"\"\"\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    noverlap = int(NFFT / 2)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    csd1, freqs1 = ax1.csd(y1, y2, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='default')\n    csd2, freqs2 = ax2.csd(y1, y2, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                           pad_to=pad_to, sides='onesided',\n                           return_line=False)\n    csd3, freqs3, line3 = ax3.csd(y1, y2, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                                  pad_to=pad_to, sides='twosided',\n                                  return_line=True)\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')",
        "begin_line": 4546,
        "end_line": 4579,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_magnitude_spectrum_freqs#4585",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_magnitude_spectrum_freqs()",
        "snippet": "def test_magnitude_spectrum_freqs():\n    \"\"\"test axes.magnitude_spectrum with sinusoidal stimuli\"\"\"\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n\n    NFFT = int(1000 * Fs / min(fstims1))\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y = np.zeros(x.size)\n    for i, fstim1 in enumerate(fstims1):\n        y += np.sin(fstim1 * x * np.pi * 2) * 10**i\n    y = y\n\n    fig1 = plt.figure()\n    fig2 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax21 = fig2.add_subplot(3, 1, 1)\n    ax22 = fig2.add_subplot(3, 1, 2)\n    ax23 = fig2.add_subplot(3, 1, 3)\n\n    spec11, freqs11, line11 = ax11.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='default')\n    spec12, freqs12, line12 = ax12.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='onesided')\n    spec13, freqs13, line13 = ax13.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='twosided')\n\n    spec21, freqs21, line21 = ax21.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='default',\n                                                      scale='dB')\n    spec22, freqs22, line22 = ax22.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='onesided',\n                                                      scale='dB')\n    spec23, freqs23, line23 = ax23.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='twosided',\n                                                      scale='dB')\n\n    ax11.set_xlabel('')\n    ax12.set_xlabel('')\n    ax13.set_xlabel('')\n    ax11.set_ylabel('')\n    ax12.set_ylabel('')\n    ax13.set_ylabel('')\n\n    ax21.set_xlabel('')\n    ax22.set_xlabel('')\n    ax23.set_xlabel('')\n    ax21.set_ylabel('')\n    ax22.set_ylabel('')\n    ax23.set_ylabel('')",
        "begin_line": 4585,
        "end_line": 4642,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_magnitude_spectrum_noise#4648",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_magnitude_spectrum_noise()",
        "snippet": "def test_magnitude_spectrum_noise():\n    \"\"\"test axes.magnitude_spectrum with noise stimuli\"\"\"\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2]) - .5\n\n    fig1 = plt.figure()\n    fig2 = plt.figure()\n\n    ax11 = fig1.add_subplot(3, 1, 1)\n    ax12 = fig1.add_subplot(3, 1, 2)\n    ax13 = fig1.add_subplot(3, 1, 3)\n\n    ax21 = fig2.add_subplot(3, 1, 1)\n    ax22 = fig2.add_subplot(3, 1, 2)\n    ax23 = fig2.add_subplot(3, 1, 3)\n\n    spec11, freqs11, line11 = ax11.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='default')\n    spec12, freqs12, line12 = ax12.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='onesided')\n    spec13, freqs13, line13 = ax13.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='twosided')\n\n    spec21, freqs21, line21 = ax21.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='default',\n                                                      scale='dB')\n    spec22, freqs22, line22 = ax22.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='onesided',\n                                                      scale='dB')\n    spec23, freqs23, line23 = ax23.magnitude_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                                      sides='twosided',\n                                                      scale='dB')\n\n    ax11.set_xlabel('')\n    ax12.set_xlabel('')\n    ax13.set_xlabel('')\n    ax11.set_ylabel('')\n    ax12.set_ylabel('')\n    ax13.set_ylabel('')\n\n    ax21.set_xlabel('')\n    ax22.set_xlabel('')\n    ax23.set_xlabel('')\n    ax21.set_ylabel('')\n    ax22.set_ylabel('')\n    ax23.set_ylabel('')",
        "begin_line": 4648,
        "end_line": 4702,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_angle_spectrum_freqs#4706",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_angle_spectrum_freqs()",
        "snippet": "def test_angle_spectrum_freqs():\n    \"\"\"test axes.angle_spectrum with sinusoidal stimuli\"\"\"\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n\n    NFFT = int(1000 * Fs / min(fstims1))\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y = np.zeros(x.size)\n    for i, fstim1 in enumerate(fstims1):\n        y += np.sin(fstim1 * x * np.pi * 2) * 10**i\n    y = y\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    spec1, freqs1, line1 = ax1.angle_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='default')\n    spec2, freqs2, line2 = ax2.angle_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='onesided')\n    spec3, freqs3, line3 = ax3.angle_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='twosided')\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')",
        "begin_line": 4706,
        "end_line": 4740,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_angle_spectrum_noise#4744",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_angle_spectrum_noise()",
        "snippet": "def test_angle_spectrum_noise():\n    \"\"\"test axes.angle_spectrum with noise stimuli\"\"\"\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2]) - .5\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    spec1, freqs1, line1 = ax1.angle_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='default')\n    spec2, freqs2, line2 = ax2.angle_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='onesided')\n    spec3, freqs3, line3 = ax3.angle_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='twosided')\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')",
        "begin_line": 4744,
        "end_line": 4775,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_phase_spectrum_freqs#4779",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_phase_spectrum_freqs()",
        "snippet": "def test_phase_spectrum_freqs():\n    \"\"\"test axes.phase_spectrum with sinusoidal stimuli\"\"\"\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n\n    NFFT = int(1000 * Fs / min(fstims1))\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n\n    y = np.zeros(x.size)\n    for i, fstim1 in enumerate(fstims1):\n        y += np.sin(fstim1 * x * np.pi * 2) * 10**i\n    y = y\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    spec1, freqs1, line1 = ax1.phase_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='default')\n    spec2, freqs2, line2 = ax2.phase_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='onesided')\n    spec3, freqs3, line3 = ax3.phase_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='twosided')\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')",
        "begin_line": 4779,
        "end_line": 4813,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_phase_spectrum_noise#4817",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_phase_spectrum_noise()",
        "snippet": "def test_phase_spectrum_noise():\n    \"\"\"test axes.phase_spectrum with noise stimuli\"\"\"\n    np.random.seed(0)\n\n    n = 10000\n    Fs = 100.\n\n    NFFT = int(1000 * Fs / 11)\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    y1 = np.random.standard_normal(n)\n    y2 = np.random.rand(n)\n    y = np.hstack([y1, y2]) - .5\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(3, 1, 1)\n    ax2 = fig.add_subplot(3, 1, 2)\n    ax3 = fig.add_subplot(3, 1, 3)\n\n    spec1, freqs1, line1 = ax1.phase_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='default')\n    spec2, freqs2, line2 = ax2.phase_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='onesided')\n    spec3, freqs3, line3 = ax3.phase_spectrum(y, Fs=Fs, pad_to=pad_to,\n                                              sides='twosided')\n\n    ax1.set_xlabel('')\n    ax2.set_xlabel('')\n    ax3.set_xlabel('')\n    ax1.set_ylabel('')\n    ax2.set_ylabel('')\n    ax3.set_ylabel('')",
        "begin_line": 4817,
        "end_line": 4848,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twin_spines#4852",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twin_spines()",
        "snippet": "def test_twin_spines():\n\n    def make_patch_spines_invisible(ax):\n        ax.set_frame_on(True)\n        ax.patch.set_visible(False)\n        for sp in ax.spines.values():\n            sp.set_visible(False)\n\n    fig = plt.figure(figsize=(4, 3))\n    fig.subplots_adjust(right=0.75)\n\n    host = fig.add_subplot(111)\n    par1 = host.twinx()\n    par2 = host.twinx()\n\n    # Offset the right spine of par2.  The ticks and label have already been\n    # placed on the right by twinx above.\n    par2.spines[\"right\"].set_position((\"axes\", 1.2))\n    # Having been created by twinx, par2 has its frame off, so the line of\n    # its detached spine is invisible.  First, activate the frame but make\n    # the patch and spines invisible.\n    make_patch_spines_invisible(par2)\n    # Second, show the right spine.\n    par2.spines[\"right\"].set_visible(True)\n\n    p1, = host.plot([0, 1, 2], [0, 1, 2], \"b-\")\n    p2, = par1.plot([0, 1, 2], [0, 3, 2], \"r-\")\n    p3, = par2.plot([0, 1, 2], [50, 30, 15], \"g-\")\n\n    host.set_xlim(0, 2)\n    host.set_ylim(0, 2)\n    par1.set_ylim(0, 4)\n    par2.set_ylim(1, 65)\n\n    host.yaxis.label.set_color(p1.get_color())\n    par1.yaxis.label.set_color(p2.get_color())\n    par2.yaxis.label.set_color(p3.get_color())\n\n    tkw = dict(size=4, width=1.5)\n    host.tick_params(axis='y', colors=p1.get_color(), **tkw)\n    par1.tick_params(axis='y', colors=p2.get_color(), **tkw)\n    par2.tick_params(axis='y', colors=p3.get_color(), **tkw)\n    host.tick_params(axis='x', **tkw)",
        "begin_line": 4852,
        "end_line": 4894,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.make_patch_spines_invisible#4854",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.make_patch_spines_invisible(ax)",
        "snippet": "    def make_patch_spines_invisible(ax):\n        ax.set_frame_on(True)\n        ax.patch.set_visible(False)\n        for sp in ax.spines.values():\n            sp.set_visible(False)",
        "begin_line": 4854,
        "end_line": 4858,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twin_spines_on_top#4899",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twin_spines_on_top()",
        "snippet": "def test_twin_spines_on_top():\n    matplotlib.rcParams['axes.linewidth'] = 48.0\n    matplotlib.rcParams['lines.linewidth'] = 48.0\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(1, 1, 1)\n\n    data = np.array([[1000, 1100, 1200, 1250],\n                     [310, 301, 360, 400]])\n\n    ax2 = ax1.twinx()\n\n    ax1.plot(data[0], data[1]/1E3, color='#BEAED4')\n    ax1.fill_between(data[0], data[1]/1E3, color='#BEAED4', alpha=.8)\n\n    ax2.plot(data[0], data[1]/1E3, color='#7FC97F')\n    ax2.fill_between(data[0], data[1]/1E3, color='#7FC97F', alpha=.5)\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"i\": data[0], \"j\": data[1]/1E3}\n    fig = plt.figure()\n    ax1 = fig.add_subplot(1, 1, 1)\n    ax2 = ax1.twinx()\n    ax1.plot(\"i\", \"j\", color='#BEAED4', data=data)\n    ax1.fill_between(\"i\", \"j\", color='#BEAED4', alpha=.8, data=data)\n    ax2.plot(\"i\", \"j\", color='#7FC97F', data=data)\n    ax2.fill_between(\"i\", \"j\", color='#7FC97F', alpha=.5, data=data)",
        "begin_line": 4899,
        "end_line": 4925,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_rcparam_grid_minor#4928",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_rcparam_grid_minor()",
        "snippet": "def test_rcparam_grid_minor():\n    orig_grid = matplotlib.rcParams['axes.grid']\n    orig_locator = matplotlib.rcParams['axes.grid.which']\n\n    matplotlib.rcParams['axes.grid'] = True\n\n    values = (\n        (('both'), (True, True)),\n        (('major'), (True, False)),\n        (('minor'), (False, True))\n        )\n\n    for locator, result in values:\n        matplotlib.rcParams['axes.grid.which'] = locator\n        fig = plt.figure()\n        ax = fig.add_subplot(1, 1, 1)\n        assert (ax.xaxis._gridOnMajor, ax.xaxis._gridOnMinor) == result\n\n    matplotlib.rcParams['axes.grid'] = orig_grid\n    matplotlib.rcParams['axes.grid.which'] = orig_locator",
        "begin_line": 4928,
        "end_line": 4947,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vline_limit#4950",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vline_limit()",
        "snippet": "def test_vline_limit():\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.axvline(0.5)\n    ax.plot([-0.1, 0, 0.2, 0.1])\n    (ymin, ymax) = ax.get_ylim()\n    assert_allclose(ax.get_ylim(), (-.1, .2))",
        "begin_line": 4950,
        "end_line": 4956,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_empty_shared_subplots#4959",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_empty_shared_subplots()",
        "snippet": "def test_empty_shared_subplots():\n    # empty plots with shared axes inherit limits from populated plots\n    fig, axs = plt.subplots(nrows=1, ncols=2, sharex=True, sharey=True)\n    axs[0].plot([1, 2, 3], [2, 4, 6])\n    x0, x1 = axs[1].get_xlim()\n    y0, y1 = axs[1].get_ylim()\n    assert x0 <= 1\n    assert x1 >= 3\n    assert y0 <= 2\n    assert y1 >= 6",
        "begin_line": 4959,
        "end_line": 4968,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shared_with_aspect_1#4971",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shared_with_aspect_1()",
        "snippet": "def test_shared_with_aspect_1():\n    # allow sharing one axis\n    for adjustable in ['box', 'datalim']:\n        fig, axs = plt.subplots(nrows=2, sharex=True)\n        axs[0].set_aspect(2, adjustable=adjustable, share=True)\n        assert axs[1].get_aspect() == 2\n        assert axs[1].get_adjustable() == adjustable\n\n        fig, axs = plt.subplots(nrows=2, sharex=True)\n        axs[0].set_aspect(2, adjustable=adjustable)\n        assert axs[1].get_aspect() == 'auto'",
        "begin_line": 4971,
        "end_line": 4981,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shared_with_aspect_2#4984",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shared_with_aspect_2()",
        "snippet": "def test_shared_with_aspect_2():\n    # Share 2 axes only with 'box':\n    fig, axs = plt.subplots(nrows=2, sharex=True, sharey=True)\n    axs[0].set_aspect(2, share=True)\n    axs[0].plot([1, 2], [3, 4])\n    axs[1].plot([3, 4], [1, 2])\n    plt.draw()  # Trigger apply_aspect().\n    assert axs[0].get_xlim() == axs[1].get_xlim()\n    assert axs[0].get_ylim() == axs[1].get_ylim()",
        "begin_line": 4984,
        "end_line": 4992,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shared_with_aspect_3#4995",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shared_with_aspect_3()",
        "snippet": "def test_shared_with_aspect_3():\n    # Different aspect ratios:\n    for adjustable in ['box', 'datalim']:\n        fig, axs = plt.subplots(nrows=2, sharey=True)\n        axs[0].set_aspect(2, adjustable=adjustable)\n        axs[1].set_aspect(0.5, adjustable=adjustable)\n        axs[0].plot([1, 2], [3, 4])\n        axs[1].plot([3, 4], [1, 2])\n        plt.draw()  # Trigger apply_aspect().\n        assert axs[0].get_xlim() != axs[1].get_xlim()\n        assert axs[0].get_ylim() == axs[1].get_ylim()\n        fig_aspect = fig.bbox_inches.height / fig.bbox_inches.width\n        for ax in axs:\n            p = ax.get_position()\n            box_aspect = p.height / p.width\n            lim_aspect = ax.viewLim.height / ax.viewLim.width\n            expected = fig_aspect * box_aspect / lim_aspect\n            assert round(expected, 4) == round(ax.get_aspect(), 4)",
        "begin_line": 4995,
        "end_line": 5012,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_not_datalim_adjustable#5015",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_not_datalim_adjustable()",
        "snippet": "def test_polar_not_datalim_adjustable():\n    ax = plt.figure().add_subplot(projection=\"polar\")\n    with pytest.raises(ValueError):\n        ax.set_adjustable(\"datalim\")",
        "begin_line": 5015,
        "end_line": 5018,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twin_with_aspect#5022",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twin_with_aspect(twin)",
        "snippet": "def test_twin_with_aspect(twin):\n    fig, ax = plt.subplots()\n    # test twinx or twiny\n    ax_twin = getattr(ax, 'twin{}'.format(twin))()\n    ax.set_aspect(5)\n    ax_twin.set_aspect(2)\n    assert_array_equal(ax.bbox.extents,\n                       ax_twin.bbox.extents)",
        "begin_line": 5022,
        "end_line": 5029,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_relim_visible_only#5032",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_relim_visible_only()",
        "snippet": "def test_relim_visible_only():\n    x1 = (0., 10.)\n    y1 = (0., 10.)\n    x2 = (-10., 20.)\n    y2 = (-10., 30.)\n\n    fig = matplotlib.figure.Figure()\n    ax = fig.add_subplot(111)\n    ax.plot(x1, y1)\n    assert ax.get_xlim() == x1\n    assert ax.get_ylim() == y1\n    l = ax.plot(x2, y2)\n    assert ax.get_xlim() == x2\n    assert ax.get_ylim() == y2\n    l[0].set_visible(False)\n    assert ax.get_xlim() == x2\n    assert ax.get_ylim() == y2\n\n    ax.relim(visible_only=True)\n    ax.autoscale_view()\n\n    assert ax.get_xlim() == x1\n    assert ax.get_ylim() == y1",
        "begin_line": 5032,
        "end_line": 5054,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_text_labelsize#5057",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_text_labelsize()",
        "snippet": "def test_text_labelsize():\n    \"\"\"\n    tests for issue #1172\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.tick_params(labelsize='large')\n    ax.tick_params(direction='out')",
        "begin_line": 5057,
        "end_line": 5064,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_default#5068",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_default()",
        "snippet": "def test_pie_default():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n    fig1, ax1 = plt.subplots(figsize=(8, 6))\n    ax1.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90)",
        "begin_line": 5068,
        "end_line": 5076,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_linewidth_0#5081",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_linewidth_0()",
        "snippet": "def test_pie_linewidth_0():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0})\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"l\": labels, \"s\": sizes, \"c\": colors, \"ex\": explode}\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.pie(\"s\", explode=\"ex\", labels=\"l\", colors=\"c\",\n           autopct='%1.1f%%', shadow=True, startangle=90,\n           wedgeprops={'linewidth': 0}, data=data)\n    ax.axis('equal')\n\n    # And again to test the pyplot functions which should also be able to be\n    # called with a data kwarg\n    plt.figure()\n    plt.pie(\"s\", explode=\"ex\", labels=\"l\", colors=\"c\",\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0}, data=data)\n    plt.axis('equal')",
        "begin_line": 5081,
        "end_line": 5109,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_center_radius#5113",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_center_radius()",
        "snippet": "def test_pie_center_radius():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0}, center=(1, 2), radius=1.5)\n\n    plt.annotate(\"Center point\", xy=(1, 2), xytext=(1, 1.5),\n                 arrowprops=dict(arrowstyle=\"->\",\n                                 connectionstyle=\"arc3\"))\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')",
        "begin_line": 5113,
        "end_line": 5128,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_linewidth_2#5132",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_linewidth_2()",
        "snippet": "def test_pie_linewidth_2():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 2})\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')",
        "begin_line": 5132,
        "end_line": 5143,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_ccw_true#5147",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_ccw_true()",
        "snippet": "def test_pie_ccw_true():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            counterclock=True)\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')",
        "begin_line": 5147,
        "end_line": 5158,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_frame_grid#5162",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_frame_grid()",
        "snippet": "def test_pie_frame_grid():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    # only \"explode\" the 2nd slice (i.e. 'Hogs')\n    explode = (0, 0.1, 0, 0)\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0},\n            frame=True, center=(2, 2))\n\n    plt.pie(sizes[::-1], explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0},\n            frame=True, center=(5, 2))\n\n    plt.pie(sizes, explode=explode[::-1], labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0},\n            frame=True, center=(3, 5))\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')",
        "begin_line": 5162,
        "end_line": 5185,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_rotatelabels_true#5189",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_rotatelabels_true()",
        "snippet": "def test_pie_rotatelabels_true():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Hogwarts', 'Frogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            rotatelabels=True)\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')",
        "begin_line": 5189,
        "end_line": 5200,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_nolabel_but_legend#5204",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_nolabel_but_legend()",
        "snippet": "def test_pie_nolabel_but_legend():\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90, labeldistance=None,\n            rotatelabels=True)\n    plt.axis('equal')\n    plt.ylim(-1.2, 1.2)\n    plt.legend()",
        "begin_line": 5204,
        "end_line": 5214,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_textprops#5217",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_textprops()",
        "snippet": "def test_pie_textprops():\n    data = [23, 34, 45]\n    labels = [\"Long name 1\", \"Long name 2\", \"Long name 3\"]\n\n    textprops = dict(horizontalalignment=\"center\",\n                     verticalalignment=\"top\",\n                     rotation=90,\n                     rotation_mode=\"anchor\",\n                     size=12, color=\"red\")\n\n    _, texts, autopct = plt.gca().pie(data, labels=labels, autopct='%.2f',\n                                      textprops=textprops)\n    for labels in [texts, autopct]:\n        for tx in labels:\n            assert tx.get_ha() == textprops[\"horizontalalignment\"]\n            assert tx.get_va() == textprops[\"verticalalignment\"]\n            assert tx.get_rotation() == textprops[\"rotation\"]\n            assert tx.get_rotation_mode() == textprops[\"rotation_mode\"]\n            assert tx.get_size() == textprops[\"size\"]\n            assert tx.get_color() == textprops[\"color\"]",
        "begin_line": 5217,
        "end_line": 5236,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_set_get_ticklabels#5240",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_set_get_ticklabels()",
        "snippet": "def test_set_get_ticklabels():\n    # test issue 2246\n    fig, ax = plt.subplots(2)\n    ha = ['normal', 'set_x/yticklabels']\n\n    ax[0].plot(np.arange(10))\n    ax[0].set_title(ha[0])\n\n    ax[1].plot(np.arange(10))\n    ax[1].set_title(ha[1])\n\n    # set ticklabel to 1 plot in normal way\n    ax[0].set_xticks(range(10))\n    ax[0].set_yticks(range(10))\n    ax[0].set_xticklabels(['a', 'b', 'c', 'd'])\n    ax[0].set_yticklabels(['11', '12', '13', '14'])\n\n    # set ticklabel to the other plot, expect the 2 plots have same label\n    # setting pass get_ticklabels return value as ticklabels argument\n    ax[1].set_xticks(ax[0].get_xticks())\n    ax[1].set_yticks(ax[0].get_yticks())\n    ax[1].set_xticklabels(ax[0].get_xticklabels())\n    ax[1].set_yticklabels(ax[0].get_yticklabels())",
        "begin_line": 5240,
        "end_line": 5262,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_retain_tick_visibility#5266",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_retain_tick_visibility()",
        "snippet": "def test_retain_tick_visibility():\n    fig, ax = plt.subplots()\n    plt.plot([0, 1, 2], [0, -1, 4])\n    plt.setp(ax.get_yticklabels(), visible=False)\n    ax.tick_params(axis=\"y\", which=\"both\", length=0)",
        "begin_line": 5266,
        "end_line": 5270,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_tick_label_update#5273",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_tick_label_update()",
        "snippet": "def test_tick_label_update():\n    # test issue 9397\n\n    fig, ax = plt.subplots()\n\n    # Set up a dummy formatter\n    def formatter_func(x, pos):\n        return \"unit value\" if x == 1 else \"\"\n    ax.xaxis.set_major_formatter(plt.FuncFormatter(formatter_func))\n\n    # Force some of the x-axis ticks to be outside of the drawn range\n    ax.set_xticks([-1, 0, 1, 2, 3])\n    ax.set_xlim(-0.5, 2.5)\n\n    ax.figure.canvas.draw()\n    tick_texts = [tick.get_text() for tick in ax.xaxis.get_ticklabels()]\n    assert tick_texts == [\"\", \"\", \"unit value\", \"\", \"\"]",
        "begin_line": 5273,
        "end_line": 5289,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.formatter_func#5279",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.formatter_func(x, pos)",
        "snippet": "    def formatter_func(x, pos):\n        return \"unit value\" if x == 1 else \"\"",
        "begin_line": 5279,
        "end_line": 5280,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_o_marker_path_snap#5293",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_o_marker_path_snap()",
        "snippet": "def test_o_marker_path_snap():\n    fig, ax = plt.subplots()\n    ax.margins(.1)\n    for ms in range(1, 15):\n        ax.plot([1, 2, ], np.ones(2) + ms, 'o', ms=ms)\n\n    for ms in np.linspace(1, 10, 25):\n        ax.plot([3, 4, ], np.ones(2) + ms, 'o', ms=ms)",
        "begin_line": 5293,
        "end_line": 5300,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_margins#5303",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_margins()",
        "snippet": "def test_margins():\n    # test all ways margins can be called\n    data = [1, 10]\n    xmin = 0.0\n    xmax = len(data) - 1.0\n    ymin = min(data)\n    ymax = max(data)\n\n    fig1, ax1 = plt.subplots(1, 1)\n    ax1.plot(data)\n    ax1.margins(1)\n    assert ax1.margins() == (1, 1)\n    assert ax1.get_xlim() == (xmin - (xmax - xmin) * 1,\n                              xmax + (xmax - xmin) * 1)\n    assert ax1.get_ylim() == (ymin - (ymax - ymin) * 1,\n                              ymax + (ymax - ymin) * 1)\n\n    fig2, ax2 = plt.subplots(1, 1)\n    ax2.plot(data)\n    ax2.margins(0.5, 2)\n    assert ax2.margins() == (0.5, 2)\n    assert ax2.get_xlim() == (xmin - (xmax - xmin) * 0.5,\n                              xmax + (xmax - xmin) * 0.5)\n    assert ax2.get_ylim() == (ymin - (ymax - ymin) * 2,\n                              ymax + (ymax - ymin) * 2)\n\n    fig3, ax3 = plt.subplots(1, 1)\n    ax3.plot(data)\n    ax3.margins(x=-0.2, y=0.5)\n    assert ax3.margins() == (-0.2, 0.5)\n    assert ax3.get_xlim() == (xmin - (xmax - xmin) * -0.2,\n                              xmax + (xmax - xmin) * -0.2)\n    assert ax3.get_ylim() == (ymin - (ymax - ymin) * 0.5,\n                              ymax + (ymax - ymin) * 0.5)",
        "begin_line": 5303,
        "end_line": 5336,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_length_one_hist#5339",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_length_one_hist()",
        "snippet": "def test_length_one_hist():\n    fig, ax = plt.subplots()\n    ax.hist(1)\n    ax.hist([1])",
        "begin_line": 5339,
        "end_line": 5342,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pathological_hexbin#5345",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pathological_hexbin(recwarn)",
        "snippet": "def test_pathological_hexbin(recwarn):\n    # issue #2863\n    mylist = [10] * 100\n    fig, ax = plt.subplots(1, 1)\n    ax.hexbin(mylist, mylist)\n    fig.savefig(io.BytesIO())\n    assert len(recwarn) == 0",
        "begin_line": 5345,
        "end_line": 5351,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_color_None#5354",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_color_None()",
        "snippet": "def test_color_None():\n    # issue 3855\n    fig, ax = plt.subplots()\n    ax.plot([1, 2], [1, 2], color=None)",
        "begin_line": 5354,
        "end_line": 5357,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_color_alias#5360",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_color_alias()",
        "snippet": "def test_color_alias():\n    # issues 4157 and 4162\n    fig, ax = plt.subplots()\n    line = ax.plot([0, 1], c='lime')[0]\n    assert 'lime' == line.get_color()",
        "begin_line": 5360,
        "end_line": 5364,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_numerical_hist_label#5367",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_numerical_hist_label()",
        "snippet": "def test_numerical_hist_label():\n    fig, ax = plt.subplots()\n    ax.hist([range(15)] * 5, label=range(5))\n    ax.legend()",
        "begin_line": 5367,
        "end_line": 5370,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_unicode_hist_label#5373",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_unicode_hist_label()",
        "snippet": "def test_unicode_hist_label():\n    fig, ax = plt.subplots()\n    a = (b'\\xe5\\xbe\\x88\\xe6\\xbc\\x82\\xe4\\xba\\xae, ' +\n         b'r\\xc3\\xb6m\\xc3\\xa4n ch\\xc3\\xa4r\\xc3\\xa1ct\\xc3\\xa8rs')\n    b = b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d'\n    labels = [a.decode('utf-8'),\n              'hi aardvark',\n              b.decode('utf-8'),\n              ]\n\n    ax.hist([range(15)] * 3, label=labels)\n    ax.legend()",
        "begin_line": 5373,
        "end_line": 5384,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_move_offsetlabel#5387",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_move_offsetlabel()",
        "snippet": "def test_move_offsetlabel():\n    data = np.random.random(10) * 1e-22\n\n    fig, ax = plt.subplots()\n    ax.plot(data)\n    fig.canvas.draw()\n    before = ax.yaxis.offsetText.get_position()\n    ax.yaxis.tick_right()\n    fig.canvas.draw()\n    after = ax.yaxis.offsetText.get_position()\n    assert after[0] > before[0] and after[1] == before[1]\n\n    fig, ax = plt.subplots()\n    ax.plot(data)\n    fig.canvas.draw()\n    before = ax.xaxis.offsetText.get_position()\n    ax.xaxis.tick_top()\n    fig.canvas.draw()\n    after = ax.xaxis.offsetText.get_position()\n    assert after[0] == before[0] and after[1] > before[1]",
        "begin_line": 5387,
        "end_line": 5406,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_rc_spines#5410",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_rc_spines()",
        "snippet": "def test_rc_spines():\n    rc_dict = {\n        'axes.spines.left': False,\n        'axes.spines.right': False,\n        'axes.spines.top': False,\n        'axes.spines.bottom': False}\n    with matplotlib.rc_context(rc_dict):\n        fig, ax = plt.subplots()",
        "begin_line": 5410,
        "end_line": 5417,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_rc_grid#5421",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_rc_grid()",
        "snippet": "def test_rc_grid():\n    fig = plt.figure()\n    rc_dict0 = {\n        'axes.grid': True,\n        'axes.grid.axis': 'both'\n    }\n    rc_dict1 = {\n        'axes.grid': True,\n        'axes.grid.axis': 'x'\n    }\n    rc_dict2 = {\n        'axes.grid': True,\n        'axes.grid.axis': 'y'\n    }\n    dict_list = [rc_dict0, rc_dict1, rc_dict2]\n\n    for i, rc_dict in enumerate(dict_list, 1):\n        with matplotlib.rc_context(rc_dict):\n            fig.add_subplot(3, 1, i)",
        "begin_line": 5421,
        "end_line": 5439,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_rc_tick#5442",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_rc_tick()",
        "snippet": "def test_rc_tick():\n    d = {'xtick.bottom': False, 'xtick.top': True,\n         'ytick.left': True, 'ytick.right': False}\n    with plt.rc_context(rc=d):\n        fig = plt.figure()\n        ax1 = fig.add_subplot(1, 1, 1)\n        xax = ax1.xaxis\n        yax = ax1.yaxis\n        # tick1On bottom/left\n        assert not xax._major_tick_kw['tick1On']\n        assert xax._major_tick_kw['tick2On']\n        assert not xax._minor_tick_kw['tick1On']\n        assert xax._minor_tick_kw['tick2On']\n\n        assert yax._major_tick_kw['tick1On']\n        assert not yax._major_tick_kw['tick2On']\n        assert yax._minor_tick_kw['tick1On']\n        assert not yax._minor_tick_kw['tick2On']",
        "begin_line": 5442,
        "end_line": 5459,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_rc_major_minor_tick#5462",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_rc_major_minor_tick()",
        "snippet": "def test_rc_major_minor_tick():\n    d = {'xtick.top': True, 'ytick.right': True,  # Enable all ticks\n         'xtick.bottom': True, 'ytick.left': True,\n         # Selectively disable\n         'xtick.minor.bottom': False, 'xtick.major.bottom': False,\n         'ytick.major.left': False, 'ytick.minor.left': False}\n    with plt.rc_context(rc=d):\n        fig = plt.figure()\n        ax1 = fig.add_subplot(1, 1, 1)\n        xax = ax1.xaxis\n        yax = ax1.yaxis\n        # tick1On bottom/left\n        assert not xax._major_tick_kw['tick1On']\n        assert xax._major_tick_kw['tick2On']\n        assert not xax._minor_tick_kw['tick1On']\n        assert xax._minor_tick_kw['tick2On']\n\n        assert not yax._major_tick_kw['tick1On']\n        assert yax._major_tick_kw['tick2On']\n        assert not yax._minor_tick_kw['tick1On']\n        assert yax._minor_tick_kw['tick2On']",
        "begin_line": 5462,
        "end_line": 5482,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_square_plot#5485",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_square_plot()",
        "snippet": "def test_square_plot():\n    x = np.arange(4)\n    y = np.array([1., 3., 5., 7.])\n    fig, ax = plt.subplots()\n    ax.plot(x, y, 'mo')\n    ax.axis('square')\n    xlim, ylim = ax.get_xlim(), ax.get_ylim()\n    assert np.diff(xlim) == np.diff(ylim)\n    assert ax.get_aspect() == 1\n    assert_array_almost_equal(\n        ax.get_position(original=True).extents, (0.125, 0.1, 0.9, 0.9))\n    assert_array_almost_equal(\n        ax.get_position(original=False).extents, (0.2125, 0.1, 0.8125, 0.9))",
        "begin_line": 5485,
        "end_line": 5497,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bad_plot_args#5500",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bad_plot_args()",
        "snippet": "def test_bad_plot_args():\n    with pytest.raises(ValueError):\n        plt.plot(None)\n    with pytest.raises(ValueError):\n        plt.plot(None, None)\n    with pytest.raises(ValueError):\n        plt.plot(np.zeros((2, 2)), np.zeros((2, 3)))\n    with pytest.raises(ValueError):\n        plt.plot((np.arange(5).reshape((1, -1)), np.arange(5).reshape(-1, 1)))",
        "begin_line": 5500,
        "end_line": 5508,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolorfast#5525",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolorfast(xy, data, cls)",
        "snippet": "def test_pcolorfast(xy, data, cls):\n    fig, ax = plt.subplots()\n    assert type(ax.pcolorfast(*xy, data)) == cls",
        "begin_line": 5525,
        "end_line": 5527,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shared_scale#5530",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shared_scale()",
        "snippet": "def test_shared_scale():\n    fig, axs = plt.subplots(2, 2, sharex=True, sharey=True)\n\n    axs[0, 0].set_xscale(\"log\")\n    axs[0, 0].set_yscale(\"log\")\n\n    for ax in axs.flat:\n        assert ax.get_yscale() == 'log'\n        assert ax.get_xscale() == 'log'\n\n    axs[1, 1].set_xscale(\"linear\")\n    axs[1, 1].set_yscale(\"linear\")\n\n    for ax in axs.flat:\n        assert ax.get_yscale() == 'linear'\n        assert ax.get_xscale() == 'linear'",
        "begin_line": 5530,
        "end_line": 5545,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shared_bool#5548",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shared_bool()",
        "snippet": "def test_shared_bool():\n    with pytest.raises(TypeError):\n        plt.subplot(sharex=True)\n    with pytest.raises(TypeError):\n        plt.subplot(sharey=True)",
        "begin_line": 5548,
        "end_line": 5552,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_violin_point_mass#5555",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_violin_point_mass()",
        "snippet": "def test_violin_point_mass():\n    \"\"\"Violin plot should handle point mass pdf gracefully.\"\"\"\n    plt.violinplot(np.array([0, 0]))",
        "begin_line": 5555,
        "end_line": 5557,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.generate_errorbar_inputs#5560",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.generate_errorbar_inputs()",
        "snippet": "def generate_errorbar_inputs():\n    base_xy = cycler('x', [np.arange(5)]) + cycler('y', [np.ones(5)])\n    err_cycler = cycler('err', [1,\n                                [1, 1, 1, 1, 1],\n                                [[1, 1, 1, 1, 1],\n                                 [1, 1, 1, 1, 1]],\n                                [[1]] * 5,\n                                np.ones(5),\n                                np.ones((2, 5)),\n                                np.ones((5, 1)),\n                                None\n                                ])\n    xerr_cy = cycler('xerr', err_cycler)\n    yerr_cy = cycler('yerr', err_cycler)\n\n    empty = ((cycler('x', [[]]) + cycler('y', [[]])) *\n             cycler('xerr', [[], None]) * cycler('yerr', [[], None]))\n    xerr_only = base_xy * xerr_cy\n    yerr_only = base_xy * yerr_cy\n    both_err = base_xy * yerr_cy * xerr_cy\n\n    return [*xerr_only, *yerr_only, *both_err, *empty]",
        "begin_line": 5560,
        "end_line": 5581,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar_inputs_shotgun#5585",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar_inputs_shotgun(kwargs)",
        "snippet": "def test_errorbar_inputs_shotgun(kwargs):\n    # (n, 1)-shaped error deprecation already tested by test_errorbar.\n    with mpl.cbook._suppress_matplotlib_deprecation_warning():\n        ax = plt.gca()\n        eb = ax.errorbar(**kwargs)\n        eb.remove()",
        "begin_line": 5585,
        "end_line": 5590,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_dash_offset#5594",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_dash_offset()",
        "snippet": "def test_dash_offset():\n    fig, ax = plt.subplots()\n    x = np.linspace(0, 10)\n    y = np.ones_like(x)\n    for j in range(0, 100, 2):\n        ax.plot(x, j*y, ls=(j, (10, 10)), lw=5, color='k')",
        "begin_line": 5594,
        "end_line": 5599,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_title_pad#5602",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_title_pad()",
        "snippet": "def test_title_pad():\n    # check that title padding puts the title in the right\n    # place...\n    fig, ax = plt.subplots()\n    ax.set_title('aardvark', pad=30.)\n    m = ax.titleOffsetTrans.get_matrix()\n    assert m[1, -1] == (30. / 72. * fig.dpi)\n    ax.set_title('aardvark', pad=0.)\n    m = ax.titleOffsetTrans.get_matrix()\n    assert m[1, -1] == 0.\n    # check that it is reverted...\n    ax.set_title('aardvark', pad=None)\n    m = ax.titleOffsetTrans.get_matrix()\n    assert m[1, -1] == (matplotlib.rcParams['axes.titlepad'] / 72. * fig.dpi)",
        "begin_line": 5602,
        "end_line": 5615,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_title_location_roundtrip#5618",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_title_location_roundtrip()",
        "snippet": "def test_title_location_roundtrip():\n    fig, ax = plt.subplots()\n    # set default title location\n    plt.rcParams['axes.titlelocation'] = 'center'\n    ax.set_title('aardvark')\n    ax.set_title('left', loc='left')\n    ax.set_title('right', loc='right')\n\n    assert 'left' == ax.get_title(loc='left')\n    assert 'right' == ax.get_title(loc='right')\n    assert 'aardvark' == ax.get_title(loc='center')\n\n    with pytest.raises(ValueError):\n        ax.get_title(loc='foo')\n    with pytest.raises(ValueError):\n        ax.set_title('fail', loc='foo')",
        "begin_line": 5618,
        "end_line": 5633,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_loglog#5637",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_loglog()",
        "snippet": "def test_loglog():\n    fig, ax = plt.subplots()\n    x = np.arange(1, 11)\n    ax.loglog(x, x**3, lw=5)\n    ax.tick_params(length=25, width=2)\n    ax.tick_params(length=15, width=2, which='minor')",
        "begin_line": 5637,
        "end_line": 5642,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_loglog_nonpos#5646",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_loglog_nonpos()",
        "snippet": "def test_loglog_nonpos():\n    fig, ax = plt.subplots(3, 3)\n    x = np.arange(1, 11)\n    y = x**3\n    y[7] = -3.\n    x[4] = -10\n    for nn, mcx in enumerate(['mask', 'clip', '']):\n        for mm, mcy in enumerate(['mask', 'clip', '']):\n            kws = {}\n            if mcx:\n                kws['nonposx'] = mcx\n            if mcy:\n                kws['nonposy'] = mcy\n            ax[mm, nn].loglog(x, y**3, lw=2, **kws)",
        "begin_line": 5646,
        "end_line": 5659,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axes_margins#5663",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axes_margins()",
        "snippet": "def test_axes_margins():\n    fig, ax = plt.subplots()\n    ax.plot([0, 1, 2, 3])\n    assert ax.get_ybound()[0] != 0\n\n    fig, ax = plt.subplots()\n    ax.bar([0, 1, 2, 3], [1, 1, 1, 1])\n    assert ax.get_ybound()[0] == 0\n\n    fig, ax = plt.subplots()\n    ax.barh([0, 1, 2, 3], [1, 1, 1, 1])\n    assert ax.get_xbound()[0] == 0\n\n    fig, ax = plt.subplots()\n    ax.pcolor(np.zeros((10, 10)))\n    assert ax.get_xbound() == (0, 10)\n    assert ax.get_ybound() == (0, 10)\n\n    fig, ax = plt.subplots()\n    ax.pcolorfast(np.zeros((10, 10)))\n    assert ax.get_xbound() == (0, 10)\n    assert ax.get_ybound() == (0, 10)\n\n    fig, ax = plt.subplots()\n    ax.hist(np.arange(10))\n    assert ax.get_ybound()[0] == 0\n\n    fig, ax = plt.subplots()\n    ax.imshow(np.zeros((10, 10)))\n    assert ax.get_xbound() == (-0.5, 9.5)\n    assert ax.get_ybound() == (-0.5, 9.5)",
        "begin_line": 5663,
        "end_line": 5693,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.shared_axis_remover#5697",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.shared_axis_remover(request)",
        "snippet": "def shared_axis_remover(request):\n    def _helper_x(ax):\n        ax2 = ax.twinx()\n        ax2.remove()\n        ax.set_xlim(0, 15)\n        r = ax.xaxis.get_major_locator()()\n        assert r[-1] > 14\n\n    def _helper_y(ax):\n        ax2 = ax.twiny()\n        ax2.remove()\n        ax.set_ylim(0, 15)\n        r = ax.yaxis.get_major_locator()()\n        assert r[-1] > 14\n\n    return {\"x\": _helper_x, \"y\": _helper_y}[request.param]",
        "begin_line": 5697,
        "end_line": 5712,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes._helper_x#5698",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes._helper_x(ax)",
        "snippet": "    def _helper_x(ax):\n        ax2 = ax.twinx()\n        ax2.remove()\n        ax.set_xlim(0, 15)\n        r = ax.xaxis.get_major_locator()()\n        assert r[-1] > 14",
        "begin_line": 5698,
        "end_line": 5703,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes._helper_y#5705",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes._helper_y(ax)",
        "snippet": "    def _helper_y(ax):\n        ax2 = ax.twiny()\n        ax2.remove()\n        ax.set_ylim(0, 15)\n        r = ax.yaxis.get_major_locator()()\n        assert r[-1] > 14",
        "begin_line": 5705,
        "end_line": 5710,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.shared_axes_generator#5716",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.shared_axes_generator(request)",
        "snippet": "def shared_axes_generator(request):\n    # test all of the ways to get fig/ax sets\n    if request.param == 'gca':\n        fig = plt.figure()\n        ax = fig.gca()\n    elif request.param == 'subplots':\n        fig, ax = plt.subplots()\n    elif request.param == 'subplots_shared':\n        fig, ax_lst = plt.subplots(2, 2, sharex='all', sharey='all')\n        ax = ax_lst[0][0]\n    elif request.param == 'add_axes':\n        fig = plt.figure()\n        ax = fig.add_axes([.1, .1, .8, .8])\n    return fig, ax",
        "begin_line": 5716,
        "end_line": 5729,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_remove_shared_axes#5732",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_remove_shared_axes(shared_axes_generator, shared_axis_remover)",
        "snippet": "def test_remove_shared_axes(shared_axes_generator, shared_axis_remover):\n    # test all of the ways to get fig/ax sets\n    fig, ax = shared_axes_generator\n    shared_axis_remover(ax)",
        "begin_line": 5732,
        "end_line": 5735,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_remove_shared_axes_relim#5738",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_remove_shared_axes_relim()",
        "snippet": "def test_remove_shared_axes_relim():\n    fig, ax_lst = plt.subplots(2, 2, sharex='all', sharey='all')\n    ax = ax_lst[0][0]\n    orig_xlim = ax_lst[0][1].get_xlim()\n    ax.remove()\n    ax.set_xlim(0, 5)\n    assert_array_equal(ax_lst[0][1].get_xlim(), orig_xlim)",
        "begin_line": 5738,
        "end_line": 5744,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shared_axes_autoscale#5747",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shared_axes_autoscale()",
        "snippet": "def test_shared_axes_autoscale():\n    l = np.arange(-80, 90, 40)\n    t = np.random.random_sample((l.size, l.size))\n\n    ax1 = plt.subplot(211)\n    ax1.set_xlim(-1000, 1000)\n    ax1.set_ylim(-1000, 1000)\n    ax1.contour(l, l, t)\n\n    ax2 = plt.subplot(212, sharex=ax1, sharey=ax1)\n    ax2.contour(l, l, t)\n    assert not ax1.get_autoscalex_on() and not ax2.get_autoscalex_on()\n    assert not ax1.get_autoscaley_on() and not ax2.get_autoscaley_on()\n    assert ax1.get_xlim() == ax2.get_xlim() == (-1000, 1000)\n    assert ax1.get_ylim() == ax2.get_ylim() == (-1000, 1000)",
        "begin_line": 5747,
        "end_line": 5761,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_adjust_numtick_aspect#5764",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_adjust_numtick_aspect()",
        "snippet": "def test_adjust_numtick_aspect():\n    fig, ax = plt.subplots()\n    ax.yaxis.get_major_locator().set_params(nbins='auto')\n    ax.set_xlim(0, 1000)\n    ax.set_aspect('equal')\n    fig.canvas.draw()\n    assert len(ax.yaxis.get_major_locator()()) == 2\n    ax.set_ylim(0, 1000)\n    fig.canvas.draw()\n    assert len(ax.yaxis.get_major_locator()()) > 2",
        "begin_line": 5764,
        "end_line": 5773,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_auto_numticks#5777",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_auto_numticks()",
        "snippet": "def test_auto_numticks():\n    # Make tiny, empty subplots, verify that there are only 3 ticks.\n    fig, axs = plt.subplots(4, 4)",
        "begin_line": 5777,
        "end_line": 5779,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_auto_numticks_log#5783",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_auto_numticks_log()",
        "snippet": "def test_auto_numticks_log():\n    # Verify that there are not too many ticks with a large log range.\n    fig, ax = plt.subplots()\n    matplotlib.rcParams['axes.autolimit_mode'] = 'round_numbers'\n    ax.loglog([1e-20, 1e5], [1e-16, 10])",
        "begin_line": 5783,
        "end_line": 5787,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_broken_barh_empty#5790",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_broken_barh_empty()",
        "snippet": "def test_broken_barh_empty():\n    fig, ax = plt.subplots()\n    ax.broken_barh([], (.1, .5))",
        "begin_line": 5790,
        "end_line": 5792,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_broken_barh_timedelta#5795",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_broken_barh_timedelta()",
        "snippet": "def test_broken_barh_timedelta():\n    \"\"\"Check that timedelta works as x, dx pair for this method.\"\"\"\n    fig, ax = plt.subplots()\n    pp = ax.broken_barh([(datetime.datetime(2018, 11, 9, 0, 0, 0),\n                          datetime.timedelta(hours=1))], [1, 2])\n    assert pp.get_paths()[0].vertices[0, 0] == 737007.0\n    assert pp.get_paths()[0].vertices[2, 0] == 737007.0 + 1 / 24",
        "begin_line": 5795,
        "end_line": 5801,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pandas_pcolormesh#5804",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pandas_pcolormesh(pd)",
        "snippet": "def test_pandas_pcolormesh(pd):\n    time = pd.date_range('2000-01-01', periods=10)\n    depth = np.arange(20)\n    data = np.random.rand(20, 10)\n\n    fig, ax = plt.subplots()\n    ax.pcolormesh(time, depth, data)",
        "begin_line": 5804,
        "end_line": 5810,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pandas_indexing_dates#5813",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pandas_indexing_dates(pd)",
        "snippet": "def test_pandas_indexing_dates(pd):\n    dates = np.arange('2005-02', '2005-03', dtype='datetime64[D]')\n    values = np.sin(np.array(range(len(dates))))\n    df = pd.DataFrame({'dates': dates, 'values': values})\n\n    ax = plt.gca()\n\n    without_zero_index = df[np.array(df.index) % 2 == 1].copy()\n    ax.plot('dates', 'values', data=without_zero_index)",
        "begin_line": 5813,
        "end_line": 5821,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pandas_errorbar_indexing#5824",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pandas_errorbar_indexing(pd)",
        "snippet": "def test_pandas_errorbar_indexing(pd):\n    df = pd.DataFrame(np.random.uniform(size=(5, 4)),\n                      columns=['x', 'y', 'xe', 'ye'],\n                      index=[1, 2, 3, 4, 5])\n    fig, ax = plt.subplots()\n    ax.errorbar('x', 'y', xerr='xe', yerr='ye', data=df)",
        "begin_line": 5824,
        "end_line": 5829,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pandas_index_shape#5832",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pandas_index_shape(pd)",
        "snippet": "def test_pandas_index_shape(pd):\n    df = pd.DataFrame({\"XX\": [4, 5, 6], \"YY\": [7, 1, 2]})\n    fig, ax = plt.subplots()\n    ax.plot(df.index, df['YY'])",
        "begin_line": 5832,
        "end_line": 5835,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pandas_indexing_hist#5838",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pandas_indexing_hist(pd)",
        "snippet": "def test_pandas_indexing_hist(pd):\n    ser_1 = pd.Series(data=[1, 2, 2, 3, 3, 4, 4, 4, 4, 5])\n    ser_2 = ser_1.iloc[1:]\n    fig, ax = plt.subplots()\n    ax.hist(ser_2)",
        "begin_line": 5838,
        "end_line": 5842,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pandas_bar_align_center#5845",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pandas_bar_align_center(pd)",
        "snippet": "def test_pandas_bar_align_center(pd):\n    # Tests fix for issue 8767\n    df = pd.DataFrame({'a': range(2), 'b': range(2)})\n\n    fig, ax = plt.subplots(1)\n\n    ax.bar(df.loc[df['a'] == 1, 'b'],\n           df.loc[df['a'] == 1, 'b'],\n           align='center')\n\n    fig.canvas.draw()",
        "begin_line": 5845,
        "end_line": 5855,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axis_set_tick_params_labelsize_labelcolor#5858",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axis_set_tick_params_labelsize_labelcolor()",
        "snippet": "def test_axis_set_tick_params_labelsize_labelcolor():\n    # Tests fix for issue 4346\n    axis_1 = plt.subplot()\n    axis_1.yaxis.set_tick_params(labelsize=30, labelcolor='red',\n                                 direction='out')\n\n    # Expected values after setting the ticks\n    assert axis_1.yaxis.majorTicks[0]._size == 4.0\n    assert axis_1.yaxis.majorTicks[0].tick1line.get_color() == 'k'\n    assert axis_1.yaxis.majorTicks[0].label1.get_size() == 30.0\n    assert axis_1.yaxis.majorTicks[0].label1.get_color() == 'red'",
        "begin_line": 5858,
        "end_line": 5868,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axes_tick_params_gridlines#5871",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axes_tick_params_gridlines()",
        "snippet": "def test_axes_tick_params_gridlines():\n    # Now treating grid params like other Tick params\n    ax = plt.subplot()\n    ax.tick_params(grid_color='b', grid_linewidth=5, grid_alpha=0.5,\n                   grid_linestyle='dashdot')\n    for axis in ax.xaxis, ax.yaxis:\n        assert axis.majorTicks[0].gridline.get_color() == 'b'\n        assert axis.majorTicks[0].gridline.get_linewidth() == 5\n        assert axis.majorTicks[0].gridline.get_alpha() == 0.5\n        assert axis.majorTicks[0].gridline.get_linestyle() == '-.'",
        "begin_line": 5871,
        "end_line": 5880,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axes_tick_params_ylabelside#5883",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axes_tick_params_ylabelside()",
        "snippet": "def test_axes_tick_params_ylabelside():\n    # Tests fix for issue 10267\n    ax = plt.subplot()\n    ax.tick_params(labelleft=False, labelright=True,\n                   which='major')\n    ax.tick_params(labelleft=False, labelright=True,\n                   which='minor')\n    # expects left false, right true\n    assert ax.yaxis.majorTicks[0].label1.get_visible() is False\n    assert ax.yaxis.majorTicks[0].label2.get_visible() is True\n    assert ax.yaxis.minorTicks[0].label1.get_visible() is False\n    assert ax.yaxis.minorTicks[0].label2.get_visible() is True",
        "begin_line": 5883,
        "end_line": 5894,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axes_tick_params_xlabelside#5897",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axes_tick_params_xlabelside()",
        "snippet": "def test_axes_tick_params_xlabelside():\n    # Tests fix for issue 10267\n    ax = plt.subplot()\n    ax.tick_params(labeltop=True, labelbottom=False,\n                   which='major')\n    ax.tick_params(labeltop=True, labelbottom=False,\n                   which='minor')\n    # expects top True, bottom False\n    # label1.get_visible() mapped to labelbottom\n    # label2.get_visible() mapped to labeltop\n    assert ax.xaxis.majorTicks[0].label1.get_visible() is False\n    assert ax.xaxis.majorTicks[0].label2.get_visible() is True\n    assert ax.xaxis.minorTicks[0].label1.get_visible() is False\n    assert ax.xaxis.minorTicks[0].label2.get_visible() is True",
        "begin_line": 5897,
        "end_line": 5910,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_none_kwargs#5913",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_none_kwargs()",
        "snippet": "def test_none_kwargs():\n    ax = plt.figure().subplots()\n    ln, = ax.plot(range(32), linestyle=None)\n    assert ln.get_linestyle() == '-'",
        "begin_line": 5913,
        "end_line": 5916,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_ls_ds_conflict#5919",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_ls_ds_conflict()",
        "snippet": "def test_ls_ds_conflict():\n    # Passing the drawstyle with the linestyle is deprecated since 3.1.\n    # We still need to test this until it's removed from the code.\n    # But we don't want to see the deprecation warning in the test.\n    with matplotlib.cbook._suppress_matplotlib_deprecation_warning(), \\\n         pytest.raises(ValueError):\n        plt.plot(range(32), linestyle='steps-pre:', drawstyle='steps-post')",
        "begin_line": 5919,
        "end_line": 5925,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_uint8#5928",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_uint8()",
        "snippet": "def test_bar_uint8():\n    xs = [0, 1, 2, 3]\n    b = plt.bar(np.array(xs, dtype=np.uint8), [2, 3, 4, 5], align=\"edge\")\n    for (patch, x) in zip(b.patches, xs):\n        assert patch.xy[0] == x",
        "begin_line": 5928,
        "end_line": 5932,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_date_timezone_x#5936",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_date_timezone_x()",
        "snippet": "def test_date_timezone_x():\n    # Tests issue 5575\n    time_index = [datetime.datetime(2016, 2, 22, hour=x,\n                                    tzinfo=dutz.gettz('Canada/Eastern'))\n                  for x in range(3)]\n\n    # Same Timezone\n    plt.figure(figsize=(20, 12))\n    plt.subplot(2, 1, 1)\n    plt.plot_date(time_index, [3] * 3, tz='Canada/Eastern')\n\n    # Different Timezone\n    plt.subplot(2, 1, 2)\n    plt.plot_date(time_index, [3] * 3, tz='UTC')",
        "begin_line": 5936,
        "end_line": 5949,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_date_timezone_y#5953",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_date_timezone_y()",
        "snippet": "def test_date_timezone_y():\n    # Tests issue 5575\n    time_index = [datetime.datetime(2016, 2, 22, hour=x,\n                                    tzinfo=dutz.gettz('Canada/Eastern'))\n                  for x in range(3)]\n\n    # Same Timezone\n    plt.figure(figsize=(20, 12))\n    plt.subplot(2, 1, 1)\n    plt.plot_date([3] * 3,\n                  time_index, tz='Canada/Eastern', xdate=False, ydate=True)\n\n    # Different Timezone\n    plt.subplot(2, 1, 2)\n    plt.plot_date([3] * 3, time_index, tz='UTC', xdate=False, ydate=True)",
        "begin_line": 5953,
        "end_line": 5967,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_date_timezone_x_and_y#5971",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_date_timezone_x_and_y()",
        "snippet": "def test_date_timezone_x_and_y():\n    # Tests issue 5575\n    UTC = datetime.timezone.utc\n    time_index = [datetime.datetime(2016, 2, 22, hour=x, tzinfo=UTC)\n                  for x in range(3)]\n\n    # Same Timezone\n    plt.figure(figsize=(20, 12))\n    plt.subplot(2, 1, 1)\n    plt.plot_date(time_index, time_index, tz='UTC', ydate=True)\n\n    # Different Timezone\n    plt.subplot(2, 1, 2)\n    plt.plot_date(time_index, time_index, tz='US/Eastern', ydate=True)",
        "begin_line": 5971,
        "end_line": 5984,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axisbelow#5988",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axisbelow()",
        "snippet": "def test_axisbelow():\n    # Test 'line' setting added in 6287.\n    # Show only grids, not frame or ticks, to make this test\n    # independent of future change to drawing order of those elements.\n    axs = plt.figure().subplots(ncols=3, sharex=True, sharey=True)\n    settings = (False, 'line', True)\n\n    for ax, setting in zip(axs, settings):\n        ax.plot((0, 10), (0, 10), lw=10, color='m')\n        circ = mpatches.Circle((3, 3), color='r')\n        ax.add_patch(circ)\n        ax.grid(color='c', linestyle='-', linewidth=3)\n        ax.tick_params(top=False, bottom=False,\n                       left=False, right=False)\n        for spine in ax.spines.values():\n            spine.set_visible(False)\n        ax.set_axisbelow(setting)",
        "begin_line": 5988,
        "end_line": 6004,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_titletwiny#6008",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_titletwiny()",
        "snippet": "def test_titletwiny():\n    # Remove this line when this test image is regenerated.\n    plt.rcParams['text.kerning_factor'] = 6\n\n    # Test that title is put above xlabel if xlabel at top\n    fig, ax = plt.subplots()\n    fig.subplots_adjust(top=0.8)\n    ax2 = ax.twiny()\n    ax.set_xlabel('Xlabel')\n    ax2.set_xlabel('Xlabel2')\n    ax.set_title('Title')",
        "begin_line": 6008,
        "end_line": 6018,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_titlesetpos#6021",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_titlesetpos()",
        "snippet": "def test_titlesetpos():\n    # Test that title stays put if we set it manually\n    fig, ax = plt.subplots()\n    fig.subplots_adjust(top=0.8)\n    ax2 = ax.twiny()\n    ax.set_xlabel('Xlabel')\n    ax2.set_xlabel('Xlabel2')\n    ax.set_title('Title')\n    pos = (0.5, 1.11)\n    ax.title.set_position(pos)\n    renderer = fig.canvas.get_renderer()\n    ax._update_title_position(renderer)\n    assert ax.title.get_position() == pos",
        "begin_line": 6021,
        "end_line": 6033,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_title_xticks_top#6036",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_title_xticks_top()",
        "snippet": "def test_title_xticks_top():\n    # Test that title moves if xticks on top of axes.\n    fig, ax = plt.subplots()\n    ax.xaxis.set_ticks_position('top')\n    ax.set_title('xlabel top')\n    fig.canvas.draw()\n    assert ax.title.get_position()[1] > 1.04",
        "begin_line": 6036,
        "end_line": 6042,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_title_xticks_top_both#6045",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_title_xticks_top_both()",
        "snippet": "def test_title_xticks_top_both():\n    # Test that title moves if xticks on top of axes.\n    fig, ax = plt.subplots()\n    ax.tick_params(axis=\"x\", bottom=True, top=True,\n                             labelbottom=True, labeltop=True)\n    ax.set_title('xlabel top')\n    fig.canvas.draw()\n    assert ax.title.get_position()[1] > 1.04",
        "begin_line": 6045,
        "end_line": 6052,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_offset_label_color#6055",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_offset_label_color()",
        "snippet": "def test_offset_label_color():\n    # Tests issue 6440\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    ax.plot([1.01e9, 1.02e9, 1.03e9])\n    ax.yaxis.set_tick_params(labelcolor='red')\n    assert ax.yaxis.get_offset_text().get_color() == 'red'",
        "begin_line": 6055,
        "end_line": 6061,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_large_offset#6064",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_large_offset()",
        "snippet": "def test_large_offset():\n    fig, ax = plt.subplots()\n    ax.plot((1 + np.array([0, 1.e-12])) * 1.e27)\n    fig.canvas.draw()",
        "begin_line": 6064,
        "end_line": 6067,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_barb_units#6070",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_barb_units()",
        "snippet": "def test_barb_units():\n    fig, ax = plt.subplots()\n    dates = [datetime.datetime(2017, 7, 15, 18, i) for i in range(0, 60, 10)]\n    y = np.linspace(0, 5, len(dates))\n    u = v = np.linspace(0, 50, len(dates))\n    ax.barbs(dates, y, u, v)",
        "begin_line": 6070,
        "end_line": 6075,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_quiver_units#6078",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_quiver_units()",
        "snippet": "def test_quiver_units():\n    fig, ax = plt.subplots()\n    dates = [datetime.datetime(2017, 7, 15, 18, i) for i in range(0, 60, 10)]\n    y = np.linspace(0, 5, len(dates))\n    u = v = np.linspace(0, 50, len(dates))\n    ax.quiver(dates, y, u, v)",
        "begin_line": 6078,
        "end_line": 6083,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_color_cycle#6086",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_color_cycle()",
        "snippet": "def test_bar_color_cycle():\n    to_rgb = mcolors.to_rgb\n    fig, ax = plt.subplots()\n    for j in range(5):\n        ln, = ax.plot(range(3))\n        brs = ax.bar(range(3), range(3))\n        for br in brs:\n            assert to_rgb(ln.get_color()) == to_rgb(br.get_facecolor())",
        "begin_line": 6086,
        "end_line": 6093,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_tick_param_label_rotation#6096",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_tick_param_label_rotation()",
        "snippet": "def test_tick_param_label_rotation():\n    fix, (ax, ax2) = plt.subplots(1, 2)\n    ax.plot([0, 1], [0, 1])\n    ax2.plot([0, 1], [0, 1])\n    ax.xaxis.set_tick_params(which='both', rotation=75)\n    ax.yaxis.set_tick_params(which='both', rotation=90)\n    for text in ax.get_xticklabels(which='both'):\n        assert text.get_rotation() == 75\n    for text in ax.get_yticklabels(which='both'):\n        assert text.get_rotation() == 90\n\n    ax2.tick_params(axis='x', labelrotation=53)\n    ax2.tick_params(axis='y', rotation=35)\n    for text in ax2.get_xticklabels(which='major'):\n        assert text.get_rotation() == 53\n    for text in ax2.get_yticklabels(which='major'):\n        assert text.get_rotation() == 35",
        "begin_line": 6096,
        "end_line": 6112,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_fillbetween_cycle#6116",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_fillbetween_cycle()",
        "snippet": "def test_fillbetween_cycle():\n    fig, ax = plt.subplots()\n\n    for j in range(3):\n        cc = ax.fill_between(range(3), range(3))\n        target = mcolors.to_rgba('C{}'.format(j))\n        assert tuple(cc.get_facecolors().squeeze()) == tuple(target)\n\n    for j in range(3, 6):\n        cc = ax.fill_betweenx(range(3), range(3))\n        target = mcolors.to_rgba('C{}'.format(j))\n        assert tuple(cc.get_facecolors().squeeze()) == tuple(target)\n\n    target = mcolors.to_rgba('k')\n\n    for al in ['facecolor', 'facecolors', 'color']:\n        cc = ax.fill_between(range(3), range(3), **{al: 'k'})\n        assert tuple(cc.get_facecolors().squeeze()) == tuple(target)\n\n    edge_target = mcolors.to_rgba('k')\n    for j, el in enumerate(['edgecolor', 'edgecolors'], start=6):\n        cc = ax.fill_between(range(3), range(3), **{el: 'k'})\n        face_target = mcolors.to_rgba('C{}'.format(j))\n        assert tuple(cc.get_facecolors().squeeze()) == tuple(face_target)\n        assert tuple(cc.get_edgecolors().squeeze()) == tuple(edge_target)",
        "begin_line": 6116,
        "end_line": 6140,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_log_margins#6143",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_log_margins()",
        "snippet": "def test_log_margins():\n    plt.rcParams['axes.autolimit_mode'] = 'data'\n    fig, ax = plt.subplots()\n    margin = 0.05\n    ax.set_xmargin(margin)\n    ax.semilogx([10, 100], [10, 100])\n    xlim0, xlim1 = ax.get_xlim()\n    transform = ax.xaxis.get_transform()\n    xlim0t, xlim1t = transform.transform([xlim0, xlim1])\n    x0t, x1t = transform.transform([10, 100])\n    delta = (x1t - x0t) * margin\n    assert_allclose([xlim0t + delta, xlim1t - delta], [x0t, x1t])",
        "begin_line": 6143,
        "end_line": 6154,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_color_length_mismatch#6157",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_color_length_mismatch()",
        "snippet": "def test_color_length_mismatch():\n    N = 5\n    x, y = np.arange(N), np.arange(N)\n    colors = np.arange(N+1)\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.scatter(x, y, c=colors)\n    c_rgb = (0.5, 0.5, 0.5)\n    ax.scatter(x, y, c=c_rgb)\n    ax.scatter(x, y, c=[c_rgb] * N)",
        "begin_line": 6157,
        "end_line": 6166,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eventplot_legend#6169",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eventplot_legend()",
        "snippet": "def test_eventplot_legend():\n    plt.eventplot([1.0], label='Label')\n    plt.legend()",
        "begin_line": 6169,
        "end_line": 6171,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_broadcast_args#6174",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_broadcast_args()",
        "snippet": "def test_bar_broadcast_args():\n    fig, ax = plt.subplots()\n    # Check that a bar chart with a single height for all bars works.\n    ax.bar(range(4), 1)\n    # Check that a horizontal chart with one width works.\n    ax.bar(0, 1, bottom=range(4), width=1, orientation='horizontal')\n    # Check that edgecolor gets broadcast.\n    rect1, rect2 = ax.bar([0, 1], [0, 1], edgecolor=(.1, .2, .3, .4))\n    assert rect1.get_edgecolor() == rect2.get_edgecolor() == (.1, .2, .3, .4)",
        "begin_line": 6174,
        "end_line": 6182,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_invalid_axis_limits#6185",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_invalid_axis_limits()",
        "snippet": "def test_invalid_axis_limits():\n    plt.plot([0, 1], [0, 1])\n    with pytest.raises(ValueError):\n        plt.xlim(np.nan)\n    with pytest.raises(ValueError):\n        plt.xlim(np.inf)\n    with pytest.raises(ValueError):\n        plt.ylim(np.nan)\n    with pytest.raises(ValueError):\n        plt.ylim(np.inf)",
        "begin_line": 6185,
        "end_line": 6194,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_minorticks_on#6200",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_minorticks_on(xscale, yscale)",
        "snippet": "def test_minorticks_on(xscale, yscale):\n    ax = plt.subplot(111)\n    ax.plot([1, 2, 3, 4])\n    ax.set_xscale(xscale)\n    ax.set_yscale(yscale)\n    ax.minorticks_on()",
        "begin_line": 6200,
        "end_line": 6205,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twinx_knows_limits#6208",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twinx_knows_limits()",
        "snippet": "def test_twinx_knows_limits():\n    fig, ax = plt.subplots()\n\n    ax.axvspan(1, 2)\n    xtwin = ax.twinx()\n    xtwin.plot([0, 0.5], [1, 2])\n    # control axis\n    fig2, ax2 = plt.subplots()\n\n    ax2.axvspan(1, 2)\n    ax2.plot([0, 0.5], [1, 2])\n\n    assert_array_equal(xtwin.viewLim.intervalx, ax2.viewLim.intervalx)",
        "begin_line": 6208,
        "end_line": 6220,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_zero_linewidth#6223",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_zero_linewidth()",
        "snippet": "def test_zero_linewidth():\n    # Check that setting a zero linewidth doesn't error\n    plt.plot([0, 1], [0, 1], ls='--', lw=0)",
        "begin_line": 6223,
        "end_line": 6225,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_gridlines#6228",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_gridlines()",
        "snippet": "def test_polar_gridlines():\n    fig = plt.figure()\n    ax = fig.add_subplot(111, polar=True)\n\n    # make all major grid lines lighter, only x grid lines set in 2.1.0\n    ax.grid(alpha=0.2)\n\n    # hide y tick labels, no effect in 2.1.0\n    plt.setp(ax.yaxis.get_ticklabels(), visible=False)\n\n    fig.canvas.draw()\n\n    assert ax.xaxis.majorTicks[0].gridline.get_alpha() == .2\n    assert ax.yaxis.majorTicks[0].gridline.get_alpha() == .2",
        "begin_line": 6228,
        "end_line": 6241,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_empty_errorbar_legend#6244",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_empty_errorbar_legend()",
        "snippet": "def test_empty_errorbar_legend():\n    fig, ax = plt.subplots()\n    ax.errorbar([], [], xerr=[], label='empty y')\n    ax.errorbar([], [], yerr=[], label='empty x')\n    ax.legend()",
        "begin_line": 6244,
        "end_line": 6248,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_plot_decimal#6252",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_plot_decimal(fig_test, fig_ref)",
        "snippet": "def test_plot_decimal(fig_test, fig_ref):\n    x0 = np.arange(-10, 10, 0.3)\n    y0 = [5.2 * x ** 3 - 2.1 * x ** 2 + 7.34 * x + 4.5 for x in x0]\n    x = [Decimal(i) for i in x0]\n    y = [Decimal(i) for i in y0]\n    # Test image - line plot with Decimal input\n    fig_test.subplots().plot(x, y)\n    # Reference image\n    fig_ref.subplots().plot(x0, y0)",
        "begin_line": 6252,
        "end_line": 6260,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markerfacecolor_none_alpha#6265",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markerfacecolor_none_alpha(fig_test, fig_ref)",
        "snippet": "def test_markerfacecolor_none_alpha(fig_test, fig_ref):\n    fig_test.subplots().plot(0, \"o\", mfc=\"none\", alpha=.5)\n    fig_ref.subplots().plot(0, \"o\", mfc=\"w\", alpha=.5)",
        "begin_line": 6265,
        "end_line": 6267,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_tick_padding_tightbbox#6270",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_tick_padding_tightbbox()",
        "snippet": "def test_tick_padding_tightbbox():\n    \"\"\"Test that tick padding gets turned off if axis is off\"\"\"\n    plt.rcParams[\"xtick.direction\"] = \"out\"\n    plt.rcParams[\"ytick.direction\"] = \"out\"\n    fig, ax = plt.subplots()\n    bb = ax.get_tightbbox(fig.canvas.get_renderer())\n    ax.axis('off')\n    bb2 = ax.get_tightbbox(fig.canvas.get_renderer())\n    assert bb.x0 < bb2.x0\n    assert bb.y0 < bb2.y0",
        "begin_line": 6270,
        "end_line": 6279,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_inset#6282",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_inset()",
        "snippet": "def test_inset():\n    \"\"\"\n    Ensure that inset_ax argument is indeed optional\n    \"\"\"\n    dx, dy = 0.05, 0.05\n    # generate 2 2d grids for the x & y bounds\n    y, x = np.mgrid[slice(1, 5 + dy, dy),\n                    slice(1, 5 + dx, dx)]\n    z = np.sin(x) ** 10 + np.cos(10 + y * x) * np.cos(x)\n\n    fig, ax = plt.subplots()\n    ax.pcolormesh(x, y, z)\n    ax.set_aspect(1.)\n    ax.apply_aspect()\n    # we need to apply_aspect to make the drawing below work.\n\n    xlim = [1.5, 2.15]\n    ylim = [2, 2.5]\n\n    rect = [xlim[0], ylim[0], xlim[1] - xlim[0], ylim[1] - ylim[0]]\n\n    rec, connectors = ax.indicate_inset(bounds=rect)\n    assert connectors is None\n    fig.canvas.draw()\n    xx = np.array([[1.5, 2.],\n                   [2.15, 2.5]])\n    assert np.all(rec.get_bbox().get_points() == xx)",
        "begin_line": 6282,
        "end_line": 6308,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_zoom_inset#6311",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_zoom_inset()",
        "snippet": "def test_zoom_inset():\n    dx, dy = 0.05, 0.05\n    # generate 2 2d grids for the x & y bounds\n    y, x = np.mgrid[slice(1, 5 + dy, dy),\n                    slice(1, 5 + dx, dx)]\n    z = np.sin(x)**10 + np.cos(10 + y*x) * np.cos(x)\n\n    fig, ax = plt.subplots()\n    ax.pcolormesh(x, y, z)\n    ax.set_aspect(1.)\n    ax.apply_aspect()\n    # we need to apply_aspect to make the drawing below work.\n\n    # Make the inset_axes...  Position axes coordinates...\n    axin1 = ax.inset_axes([0.7, 0.7, 0.35, 0.35])\n    # redraw the data in the inset axes...\n    axin1.pcolormesh(x, y, z)\n    axin1.set_xlim([1.5, 2.15])\n    axin1.set_ylim([2, 2.5])\n    axin1.set_aspect(ax.get_aspect())\n\n    rec, connectors = ax.indicate_inset_zoom(axin1)\n    assert len(connectors) == 4\n    fig.canvas.draw()\n    xx = np.array([[1.5,  2.],\n                   [2.15, 2.5]])\n    assert(np.all(rec.get_bbox().get_points() == xx))\n    xx = np.array([[0.6325, 0.692308],\n                   [0.8425, 0.907692]])\n    np.testing.assert_allclose(axin1.get_position().get_points(),\n            xx, rtol=1e-4)",
        "begin_line": 6311,
        "end_line": 6341,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_indicate_inset_inverted#6346",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_indicate_inset_inverted(x_inverted, y_inverted)",
        "snippet": "def test_indicate_inset_inverted(x_inverted, y_inverted):\n    \"\"\"\n    Test that the inset lines are correctly located with inverted data axes.\n    \"\"\"\n    fig, (ax1, ax2) = plt.subplots(1, 2)\n\n    x = np.arange(10)\n    ax1.plot(x, x, 'o')\n    if x_inverted:\n        ax1.invert_xaxis()\n    if y_inverted:\n        ax1.invert_yaxis()\n\n    rect, bounds = ax1.indicate_inset([2, 2, 5, 4], ax2)\n    lower_left, upper_left, lower_right, upper_right = bounds\n\n    sign_x = -1 if x_inverted else 1\n    sign_y = -1 if y_inverted else 1\n    assert sign_x * (lower_right.xy2[0] - lower_left.xy2[0]) > 0\n    assert sign_x * (upper_right.xy2[0] - upper_left.xy2[0]) > 0\n    assert sign_y * (upper_left.xy2[1] - lower_left.xy2[1]) > 0\n    assert sign_y * (upper_right.xy2[1] - lower_right.xy2[1]) > 0",
        "begin_line": 6346,
        "end_line": 6367,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_set_position#6370",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_set_position()",
        "snippet": "def test_set_position():\n    fig, ax = plt.subplots()\n    ax.set_aspect(3.)\n    ax.set_position([0.1, 0.1, 0.4, 0.4], which='both')\n    assert np.allclose(ax.get_position().width, 0.1)\n    ax.set_aspect(2.)\n    ax.set_position([0.1, 0.1, 0.4, 0.4], which='original')\n    assert np.allclose(ax.get_position().width, 0.15)\n    ax.set_aspect(3.)\n    ax.set_position([0.1, 0.1, 0.4, 0.4], which='active')\n    assert np.allclose(ax.get_position().width, 0.1)",
        "begin_line": 6370,
        "end_line": 6380,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_spines_properbbox_after_zoom#6383",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_spines_properbbox_after_zoom()",
        "snippet": "def test_spines_properbbox_after_zoom():\n    fig, ax = plt.subplots()\n    bb = ax.spines['bottom'].get_window_extent(fig.canvas.get_renderer())\n    # this is what zoom calls:\n    ax._set_view_from_bbox((320, 320, 500, 500), 'in',\n                           None, False, False)\n    bb2 = ax.spines['bottom'].get_window_extent(fig.canvas.get_renderer())\n    np.testing.assert_allclose(bb.get_points(), bb2.get_points(), rtol=1e-6)",
        "begin_line": 6383,
        "end_line": 6390,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_cartopy_backcompat#6393",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_cartopy_backcompat()",
        "snippet": "def test_cartopy_backcompat():\n    import matplotlib\n    import matplotlib.axes\n    import matplotlib.axes._subplots\n\n    class Dummy(matplotlib.axes.Axes):\n        ...\n\n    class DummySubplot(matplotlib.axes.SubplotBase, Dummy):\n        _axes_class = Dummy\n\n    matplotlib.axes._subplots._subplot_classes[Dummy] = DummySubplot\n\n    FactoryDummySubplot = matplotlib.axes.subplot_class_factory(Dummy)\n\n    assert DummySubplot is FactoryDummySubplot",
        "begin_line": 6393,
        "end_line": 6408,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.Dummy.test_cartopy_backcompat#6393",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.Dummy",
        "signature": "lib.matplotlib.tests.test_axes.Dummy.test_cartopy_backcompat()",
        "snippet": "def test_cartopy_backcompat():\n    import matplotlib\n    import matplotlib.axes\n    import matplotlib.axes._subplots\n\n    class Dummy(matplotlib.axes.Axes):\n        ...\n\n    class DummySubplot(matplotlib.axes.SubplotBase, Dummy):\n        _axes_class = Dummy\n\n    matplotlib.axes._subplots._subplot_classes[Dummy] = DummySubplot\n\n    FactoryDummySubplot = matplotlib.axes.subplot_class_factory(Dummy)\n\n    assert DummySubplot is FactoryDummySubplot",
        "begin_line": 6393,
        "end_line": 6408,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.DummySubplot.test_cartopy_backcompat#6393",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.DummySubplot",
        "signature": "lib.matplotlib.tests.test_axes.DummySubplot.test_cartopy_backcompat()",
        "snippet": "def test_cartopy_backcompat():\n    import matplotlib\n    import matplotlib.axes\n    import matplotlib.axes._subplots\n\n    class Dummy(matplotlib.axes.Axes):\n        ...\n\n    class DummySubplot(matplotlib.axes.SubplotBase, Dummy):\n        _axes_class = Dummy\n\n    matplotlib.axes._subplots._subplot_classes[Dummy] = DummySubplot\n\n    FactoryDummySubplot = matplotlib.axes.subplot_class_factory(Dummy)\n\n    assert DummySubplot is FactoryDummySubplot",
        "begin_line": 6393,
        "end_line": 6408,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_gettightbbox_ignoreNaN#6411",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_gettightbbox_ignoreNaN()",
        "snippet": "def test_gettightbbox_ignoreNaN():\n    fig, ax = plt.subplots()\n    remove_ticks_and_titles(fig)\n    ax.text(np.NaN, 1, 'Boo')\n    renderer = fig.canvas.get_renderer()\n    np.testing.assert_allclose(ax.get_tightbbox(renderer).width, 496)",
        "begin_line": 6411,
        "end_line": 6416,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_scatter_series_non_zero_index#6419",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_scatter_series_non_zero_index(pd)",
        "snippet": "def test_scatter_series_non_zero_index(pd):\n    # create non-zero index\n    ids = range(10, 18)\n    x = pd.Series(np.random.uniform(size=8), index=ids)\n    y = pd.Series(np.random.uniform(size=8), index=ids)\n    c = pd.Series([1, 1, 1, 1, 1, 0, 0, 0], index=ids)\n    plt.scatter(x, y, c)",
        "begin_line": 6419,
        "end_line": 6425,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_scatter_empty_data#6428",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_scatter_empty_data()",
        "snippet": "def test_scatter_empty_data():\n    # making sure this does not raise an exception\n    plt.scatter([], [])\n    plt.scatter([], [], s=[], c=[])",
        "begin_line": 6428,
        "end_line": 6431,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_annotate_across_transforms#6436",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_annotate_across_transforms()",
        "snippet": "def test_annotate_across_transforms():\n    x = np.linspace(0, 10, 200)\n    y = np.exp(-x) * np.sin(x)\n\n    fig, ax = plt.subplots(figsize=(3.39, 3))\n    ax.plot(x, y)\n    axins = ax.inset_axes([0.4, 0.5, 0.3, 0.3])\n    axins.set_aspect(0.2)\n    axins.xaxis.set_visible(False)\n    axins.yaxis.set_visible(False)\n    ax.annotate(\"\", xy=(x[150], y[150]), xycoords=ax.transData,\n            xytext=(1, 0), textcoords=axins.transAxes,\n            arrowprops=dict(arrowstyle=\"->\"))",
        "begin_line": 6436,
        "end_line": 6448,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_deprecated_uppercase_colors#6451",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_deprecated_uppercase_colors()",
        "snippet": "def test_deprecated_uppercase_colors():\n    # Remove after end of deprecation period.\n    fig, ax = plt.subplots()\n    with pytest.warns(MatplotlibDeprecationWarning):\n        ax.plot([1, 2], color=\"B\")\n        fig.canvas.draw()",
        "begin_line": 6451,
        "end_line": 6456,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_secondary_xy#6460",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_secondary_xy()",
        "snippet": "def test_secondary_xy():\n    fig, axs = plt.subplots(1, 2, figsize=(10, 5), constrained_layout=True)\n\n    def invert(x):\n        with np.errstate(divide='ignore'):\n            return 1 / x\n\n    for nn, ax in enumerate(axs):\n        ax.plot(np.arange(2, 11), np.arange(2, 11))\n        if nn == 0:\n            secax = ax.secondary_xaxis\n        else:\n            secax = ax.secondary_yaxis\n\n        secax(0.2, functions=(invert, invert))\n        secax(0.4, functions=(lambda x: 2 * x, lambda x: x / 2))\n        secax(0.6, functions=(lambda x: x**2, lambda x: x**(1/2)))\n        secax(0.8)",
        "begin_line": 6460,
        "end_line": 6477,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.invert#6463",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.invert(x)",
        "snippet": "    def invert(x):\n        with np.errstate(divide='ignore'):\n            return 1 / x",
        "begin_line": 6463,
        "end_line": 6465,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_secondary_fail#6480",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_secondary_fail()",
        "snippet": "def test_secondary_fail():\n    fig, ax = plt.subplots()\n    ax.plot(np.arange(2, 11), np.arange(2, 11))\n    with pytest.raises(ValueError):\n        ax.secondary_xaxis(0.2, functions=(lambda x: 1 / x))\n    with pytest.raises(ValueError):\n        ax.secondary_xaxis('right')\n    with pytest.raises(ValueError):\n        ax.secondary_yaxis('bottom')",
        "begin_line": 6480,
        "end_line": 6488,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_secondary_resize#6491",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_secondary_resize()",
        "snippet": "def test_secondary_resize():\n    fig, ax = plt.subplots(figsize=(10, 5))\n    ax.plot(np.arange(2, 11), np.arange(2, 11))\n    def invert(x):\n        with np.errstate(divide='ignore'):\n            return 1 / x\n\n    ax.secondary_xaxis('top', functions=(invert, invert))\n    fig.canvas.draw()\n    fig.set_size_inches((7, 4))\n    assert_allclose(ax.get_position().extents, [0.125, 0.1, 0.9, 0.9])",
        "begin_line": 6491,
        "end_line": 6501,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.invert#6494",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.invert(x)",
        "snippet": "    def invert(x):\n        with np.errstate(divide='ignore'):\n            return 1 / x",
        "begin_line": 6494,
        "end_line": 6496,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_secondary_minorloc#6504",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_secondary_minorloc()",
        "snippet": "def test_secondary_minorloc():\n    fig, ax = plt.subplots(figsize=(10, 5))\n    ax.plot(np.arange(2, 11), np.arange(2, 11))\n    def invert(x):\n        with np.errstate(divide='ignore'):\n            return 1 / x\n\n    secax = ax.secondary_xaxis('top', functions=(invert, invert))\n    assert isinstance(secax._axis.get_minor_locator(),\n                      mticker.NullLocator)\n    secax.minorticks_on()\n    assert isinstance(secax._axis.get_minor_locator(),\n                      mticker.AutoMinorLocator)\n    ax.set_xscale('log')\n    plt.draw()\n    assert isinstance(secax._axis.get_minor_locator(),\n                      mticker.LogLocator)\n    ax.set_xscale('linear')\n    plt.draw()\n    assert isinstance(secax._axis.get_minor_locator(),\n                      mticker.NullLocator)",
        "begin_line": 6504,
        "end_line": 6524,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.invert#6507",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.invert(x)",
        "snippet": "    def invert(x):\n        with np.errstate(divide='ignore'):\n            return 1 / x",
        "begin_line": 6507,
        "end_line": 6509,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.color_boxes#6527",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.color_boxes(fig, axs)",
        "snippet": "def color_boxes(fig, axs):\n    \"\"\"\n    Helper for the tests below that test the extents of various axes elements\n    \"\"\"\n    fig.canvas.draw()\n\n    renderer = fig.canvas.get_renderer()\n    bbaxis = []\n    for nn, axx in enumerate([axs.xaxis, axs.yaxis]):\n        bb = axx.get_tightbbox(renderer)\n        if bb:\n            axisr = plt.Rectangle((bb.x0, bb.y0), width=bb.width,\n                     height=bb.height, linewidth=0.7, edgecolor='y',\n                    facecolor=\"none\", transform=None, zorder=3)\n            fig.add_artist(axisr)\n        bbaxis += [bb]\n\n    bbspines = []\n    for nn, a in enumerate(['bottom', 'top', 'left', 'right']):\n        bb = axs.spines[a].get_window_extent(renderer)\n        spiner = plt.Rectangle((bb.x0, bb.y0), width=bb.width,\n                              height=bb.height, linewidth=0.7,\n                              edgecolor=\"green\", facecolor=\"none\",\n                              transform=None, zorder=3)\n        fig.add_artist(spiner)\n        bbspines += [bb]\n\n    bb = axs.get_window_extent()\n    rect2 = plt.Rectangle((bb.x0, bb.y0), width=bb.width, height=bb.height,\n                         linewidth=1.5, edgecolor=\"magenta\",\n                         facecolor=\"none\", transform=None, zorder=2)\n    fig.add_artist(rect2)\n    bbax = bb\n\n    bb2 = axs.get_tightbbox(renderer)\n    rect2 = plt.Rectangle((bb2.x0, bb2.y0), width=bb2.width,\n                         height=bb2.height, linewidth=3, edgecolor=\"red\",\n                         facecolor=\"none\", transform=None, zorder=1)\n    fig.add_artist(rect2)\n    bbtb = bb2\n    return bbaxis, bbspines, bbax, bbtb",
        "begin_line": 6527,
        "end_line": 6567,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_normal_axes#6570",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_normal_axes()",
        "snippet": "def test_normal_axes():\n    with rc_context({'_internal.classic_mode': False}):\n        fig, ax = plt.subplots(dpi=200, figsize=(6, 6))\n        fig.canvas.draw()\n        plt.close(fig)\n        bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n\n    # test the axis bboxes\n    target = [\n        [123.375, 75.88888888888886, 983.25, 33.0],\n        [85.51388888888889, 99.99999999999997, 53.375, 993.0]\n    ]\n    for nn, b in enumerate(bbaxis):\n        targetbb = mtransforms.Bbox.from_bounds(*target[nn])\n        assert_array_almost_equal(b.bounds, targetbb.bounds, decimal=2)\n\n    target = [\n        [150.0, 119.999, 930.0, 11.111],\n        [150.0, 1080.0, 930.0, 0.0],\n        [150.0, 119.9999, 11.111, 960.0],\n        [1068.8888, 119.9999, 11.111, 960.0]\n    ]\n    for nn, b in enumerate(bbspines):\n        targetbb = mtransforms.Bbox.from_bounds(*target[nn])\n        assert_array_almost_equal(b.bounds, targetbb.bounds, decimal=2)\n\n    target = [150.0, 119.99999999999997, 930.0, 960.0]\n    targetbb = mtransforms.Bbox.from_bounds(*target)\n    assert_array_almost_equal(bbax.bounds, targetbb.bounds, decimal=2)\n\n    target = [85.5138, 75.88888, 1021.11, 1017.11]\n    targetbb = mtransforms.Bbox.from_bounds(*target)\n    assert_array_almost_equal(bbtb.bounds, targetbb.bounds, decimal=2)\n\n    # test that get_position roundtrips to get_window_extent\n    axbb = ax.get_position().transformed(fig.transFigure).bounds\n    assert_array_almost_equal(axbb, ax.get_window_extent().bounds, decimal=2)",
        "begin_line": 6570,
        "end_line": 6606,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_nodecorator#6609",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_nodecorator()",
        "snippet": "def test_nodecorator():\n    with rc_context({'_internal.classic_mode': False}):\n        fig, ax = plt.subplots(dpi=200, figsize=(6, 6))\n        fig.canvas.draw()\n        ax.set(xticklabels=[], yticklabels=[])\n        bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n\n    # test the axis bboxes\n    target = [\n        None,\n        None\n    ]\n    for nn, b in enumerate(bbaxis):\n        assert b is None\n\n    target = [\n        [150.0, 119.999, 930.0, 11.111],\n        [150.0, 1080.0, 930.0, 0.0],\n        [150.0, 119.9999, 11.111, 960.0],\n        [1068.8888, 119.9999, 11.111, 960.0]\n    ]\n    for nn, b in enumerate(bbspines):\n        targetbb = mtransforms.Bbox.from_bounds(*target[nn])\n        assert_allclose(b.bounds, targetbb.bounds, atol=1e-2)\n\n    target = [150.0, 119.99999999999997, 930.0, 960.0]\n    targetbb = mtransforms.Bbox.from_bounds(*target)\n    assert_allclose(bbax.bounds, targetbb.bounds, atol=1e-2)\n\n    target = [150., 120., 930., 960.]\n    targetbb = mtransforms.Bbox.from_bounds(*target)\n    assert_allclose(bbtb.bounds, targetbb.bounds, atol=1e-2)",
        "begin_line": 6609,
        "end_line": 6640,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_displaced_spine#6643",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_displaced_spine()",
        "snippet": "def test_displaced_spine():\n    with rc_context({'_internal.classic_mode': False}):\n        fig, ax = plt.subplots(dpi=200, figsize=(6, 6))\n        ax.set(xticklabels=[], yticklabels=[])\n        ax.spines['bottom'].set_position(('axes', -0.1))\n        fig.canvas.draw()\n        bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n\n    target = [\n        [150., 24., 930., 11.111111],\n        [150.0, 1080.0, 930.0, 0.0],\n        [150.0, 119.9999, 11.111, 960.0],\n        [1068.8888, 119.9999, 11.111, 960.0]\n    ]\n    for nn, b in enumerate(bbspines):\n        targetbb = mtransforms.Bbox.from_bounds(*target[nn])\n\n    target = [150.0, 119.99999999999997, 930.0, 960.0]\n    targetbb = mtransforms.Bbox.from_bounds(*target)\n    assert_allclose(bbax.bounds, targetbb.bounds, atol=1e-2)\n\n    target = [150., 24., 930., 1056.]\n    targetbb = mtransforms.Bbox.from_bounds(*target)\n    assert_allclose(bbtb.bounds, targetbb.bounds, atol=1e-2)",
        "begin_line": 6643,
        "end_line": 6666,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_tickdirs#6669",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_tickdirs()",
        "snippet": "def test_tickdirs():\n    \"\"\"\n    Switch the tickdirs and make sure the bboxes switch with them\n    \"\"\"\n    targets = [[[150.0, 120.0, 930.0, 11.1111],\n                [150.0, 120.0, 11.111, 960.0]],\n               [[150.0, 108.8889, 930.0, 11.111111111111114],\n                [138.889, 120, 11.111, 960.0]],\n               [[150.0, 114.44444444444441, 930.0, 11.111111111111114],\n                [144.44444444444446, 119.999, 11.111, 960.0]]]\n    for dnum, dirs in enumerate(['in', 'out', 'inout']):\n        with rc_context({'_internal.classic_mode': False}):\n            fig, ax = plt.subplots(dpi=200, figsize=(6, 6))\n            ax.tick_params(direction=dirs)\n            fig.canvas.draw()\n            bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n            for nn, num in enumerate([0, 2]):\n                targetbb = mtransforms.Bbox.from_bounds(*targets[dnum][nn])\n                assert_allclose(bbspines[num].bounds, targetbb.bounds,\n                               atol=1e-2)",
        "begin_line": 6669,
        "end_line": 6688,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_minor_accountedfor#6691",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_minor_accountedfor()",
        "snippet": "def test_minor_accountedfor():\n    with rc_context({'_internal.classic_mode': False}):\n        fig, ax = plt.subplots(dpi=200, figsize=(6, 6))\n        fig.canvas.draw()\n        ax.tick_params(which='both', direction='out')\n\n        bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n        bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n        targets = [[150.0, 108.88888888888886, 930.0, 11.111111111111114],\n                   [138.8889, 119.9999, 11.1111, 960.0]]\n        for n in range(2):\n            targetbb = mtransforms.Bbox.from_bounds(*targets[n])\n            assert_allclose(bbspines[n * 2].bounds, targetbb.bounds,\n                           atol=1e-2)\n\n        fig, ax = plt.subplots(dpi=200, figsize=(6, 6))\n        fig.canvas.draw()\n        ax.tick_params(which='both', direction='out')\n        ax.minorticks_on()\n        ax.tick_params(axis='both', which='minor', length=30)\n        fig.canvas.draw()\n        bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n        targets = [[150.0, 36.66666666666663, 930.0, 83.33333333333334],\n                   [66.6667, 120.0, 83.3333, 960.0]]\n\n        for n in range(2):\n            targetbb = mtransforms.Bbox.from_bounds(*targets[n])\n            assert_allclose(bbspines[n * 2].bounds, targetbb.bounds,\n                           atol=1e-2)",
        "begin_line": 6691,
        "end_line": 6719,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_get_tightbbox_polar#6722",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_get_tightbbox_polar()",
        "snippet": "def test_get_tightbbox_polar():\n    fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n    fig.canvas.draw()\n    bb = ax.get_tightbbox(fig.canvas.get_renderer())\n    assert_allclose(bb.extents,\n        [107.7778,  29.2778, 539.7847, 450.7222], rtol=1e-03)",
        "begin_line": 6722,
        "end_line": 6727,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axis_bool_arguments#6731",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axis_bool_arguments(fig_test, fig_ref)",
        "snippet": "def test_axis_bool_arguments(fig_test, fig_ref):\n    # Test if False and \"off\" give the same\n    fig_test.add_subplot(211).axis(False)\n    fig_ref.add_subplot(211).axis(\"off\")\n    # Test if True after False gives the same as \"on\"\n    ax = fig_test.add_subplot(212)\n    ax.axis(False)\n    ax.axis(True)\n    fig_ref.add_subplot(212).axis(\"on\")",
        "begin_line": 6731,
        "end_line": 6739,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axis_extent_arg#6742",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axis_extent_arg()",
        "snippet": "def test_axis_extent_arg():\n    fig, ax = plt.subplots()\n    xmin = 5\n    xmax = 10\n    ymin = 15\n    ymax = 20\n    extent = ax.axis([xmin, xmax, ymin, ymax])\n\n    # test that the docstring is correct\n    assert tuple(extent) == (xmin, xmax, ymin, ymax)\n\n    # test that limits were set per the docstring\n    assert (xmin, xmax) == ax.get_xlim()\n    assert (ymin, ymax) == ax.get_ylim()",
        "begin_line": 6742,
        "end_line": 6755,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_datetime_masked#6758",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_datetime_masked()",
        "snippet": "def test_datetime_masked():\n    # make sure that all-masked data falls back to the viewlim\n    # set in convert.axisinfo....\n    x = np.array([datetime.datetime(2017, 1, n) for n in range(1, 6)])\n    y = np.array([1, 2, 3, 4, 5])\n    m = np.ma.masked_greater(y, 0)\n\n    fig, ax = plt.subplots()\n    ax.plot(x, m)\n    # these are the default viewlim\n    assert ax.get_xlim() == (730120.0, 733773.0)",
        "begin_line": 6758,
        "end_line": 6768,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_auto_bins#6771",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_auto_bins()",
        "snippet": "def test_hist_auto_bins():\n    _, bins, _ = plt.hist([[1, 2, 3], [3, 4, 5, 6]], bins='auto')\n    assert bins[0] <= 1\n    assert bins[-1] >= 6",
        "begin_line": 6771,
        "end_line": 6774,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_nan_data#6777",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_nan_data()",
        "snippet": "def test_hist_nan_data():\n    fig, (ax1, ax2) = plt.subplots(2)\n\n    data = [1, 2, 3]\n    nan_data = data + [np.nan]\n\n    bins, edges, _ = ax1.hist(data)\n    with np.errstate(invalid='ignore'):\n        nanbins, nanedges, _ = ax2.hist(nan_data)\n\n    np.testing.assert_allclose(bins, nanbins)\n    np.testing.assert_allclose(edges, nanedges)",
        "begin_line": 6777,
        "end_line": 6788,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_range_and_density#6791",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_range_and_density()",
        "snippet": "def test_hist_range_and_density():\n    _, bins, _ = plt.hist(np.random.rand(10), \"auto\",\n                          range=(0, 1), density=True)\n    assert bins[0] == 0\n    assert bins[-1] == 1",
        "begin_line": 6791,
        "end_line": 6795,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_errbar_zorder#6798",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_errbar_zorder()",
        "snippet": "def test_bar_errbar_zorder():\n    # Check that the zorder of errorbars is always greater than the bar they\n    # are plotted on\n    fig, ax = plt.subplots()\n    x = [1, 2, 3]\n    barcont = ax.bar(x=x, height=x, yerr=x, capsize=5, zorder=3)\n\n    data_line, caplines, barlinecols = barcont.errorbar.lines\n    for bar in barcont.patches:\n        for capline in caplines:\n            assert capline.zorder > bar.zorder\n        for barlinecol in barlinecols:\n            assert barlinecol.zorder > bar.zorder",
        "begin_line": 6798,
        "end_line": 6810,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_set_ticks_inverted#6813",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_set_ticks_inverted()",
        "snippet": "def test_set_ticks_inverted():\n    fig, ax = plt.subplots()\n    ax.invert_xaxis()\n    ax.set_xticks([.3, .7])\n    assert ax.get_xlim() == (1, 0)",
        "begin_line": 6813,
        "end_line": 6817,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_aspect_nonlinear_adjustable_box#6820",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_aspect_nonlinear_adjustable_box()",
        "snippet": "def test_aspect_nonlinear_adjustable_box():\n    fig = plt.figure(figsize=(10, 10))  # Square.\n\n    ax = fig.add_subplot()\n    ax.plot([.4, .6], [.4, .6])  # Set minpos to keep logit happy.\n    ax.set(xscale=\"log\", xlim=(1, 10),\n           yscale=\"logit\", ylim=(1/11, 1/1001),\n           aspect=1, adjustable=\"box\")\n    ax.margins(0)\n    pos = fig.transFigure.transform_bbox(ax.get_position())\n    assert pos.height / pos.width == pytest.approx(2)",
        "begin_line": 6820,
        "end_line": 6830,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_aspect_nonlinear_adjustable_datalim#6833",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_aspect_nonlinear_adjustable_datalim()",
        "snippet": "def test_aspect_nonlinear_adjustable_datalim():\n    fig = plt.figure(figsize=(10, 10))  # Square.\n\n    ax = fig.add_axes([.1, .1, .8, .8])  # Square.\n    ax.plot([.4, .6], [.4, .6])  # Set minpos to keep logit happy.\n    ax.set(xscale=\"log\", xlim=(1, 100),\n           yscale=\"logit\", ylim=(1 / 101, 1 / 11),\n           aspect=1, adjustable=\"datalim\")\n    ax.margins(0)\n    ax.apply_aspect()\n\n    assert ax.get_xlim() == pytest.approx([1*10**(1/2), 100/10**(1/2)])\n    assert ax.get_ylim() == (1 / 101, 1 / 11)",
        "begin_line": 6833,
        "end_line": 6845,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_box_aspect#6848",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_box_aspect()",
        "snippet": "def test_box_aspect():\n    # Test if axes with box_aspect=1 has same dimensions\n    # as axes with aspect equal and adjustable=\"box\"\n\n    fig1, ax1 = plt.subplots()\n    axtwin = ax1.twinx()\n    axtwin.plot([12, 344])\n\n    ax1.set_box_aspect(1)\n\n    fig2, ax2 = plt.subplots()\n    ax2.margins(0)\n    ax2.plot([0, 2], [6, 8])\n    ax2.set_aspect(\"equal\", adjustable=\"box\")\n\n    fig1.canvas.draw()\n    fig2.canvas.draw()\n\n    bb1 = ax1.get_position()\n    bbt = axtwin.get_position()\n    bb2 = ax2.get_position()\n\n    assert_array_equal(bb1.extents, bb2.extents)\n    assert_array_equal(bbt.extents, bb2.extents)",
        "begin_line": 6848,
        "end_line": 6871,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_box_aspect_custom_position#6874",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_box_aspect_custom_position()",
        "snippet": "def test_box_aspect_custom_position():\n    # Test if axes with custom position and box_aspect\n    # behaves the same independent of the order of setting those.\n\n    fig1, ax1 = plt.subplots()\n    ax1.set_position([0.1, 0.1, 0.9, 0.2])\n    fig1.canvas.draw()\n    ax1.set_box_aspect(1.)\n\n    fig2, ax2 = plt.subplots()\n    ax2.set_box_aspect(1.)\n    fig2.canvas.draw()\n    ax2.set_position([0.1, 0.1, 0.9, 0.2])\n\n    fig1.canvas.draw()\n    fig2.canvas.draw()\n\n    bb1 = ax1.get_position()\n    bb2 = ax2.get_position()\n\n    assert_array_equal(bb1.extents, bb2.extents)",
        "begin_line": 6874,
        "end_line": 6894,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bbox_aspect_axes_init#6897",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bbox_aspect_axes_init()",
        "snippet": "def test_bbox_aspect_axes_init():\n    # Test that box_aspect can be given to axes init and produces\n    # all equal square axes.\n    fig, axs = plt.subplots(2, 3, subplot_kw=dict(box_aspect=1),\n                        constrained_layout=True)\n    fig.canvas.draw()\n    renderer = fig.canvas.get_renderer()\n    sizes = []\n    for ax in axs.flat:\n        bb = ax.get_window_extent(renderer)\n        sizes.extend([bb.width, bb.height])\n\n    assert_allclose(sizes, sizes[0])",
        "begin_line": 6897,
        "end_line": 6909,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pi_get_negative_values#6912",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pi_get_negative_values()",
        "snippet": "def test_pi_get_negative_values():\n    # Test the ValueError raised when feeding negative values into axes.pie\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.pie([5, 5, -3], explode=[0, .1, .2])",
        "begin_line": 6912,
        "end_line": 6916,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_invisible_axes#6919",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_invisible_axes()",
        "snippet": "def test_invisible_axes():\n    # invisible axes should not respond to events...\n    fig, ax = plt.subplots()\n    assert fig.canvas.inaxes((200, 200)) is not None\n    ax.set_visible(False)\n    assert fig.canvas.inaxes((200, 200)) is None",
        "begin_line": 6919,
        "end_line": 6924,
        "comment": "",
        "is_bug": false
    }
]