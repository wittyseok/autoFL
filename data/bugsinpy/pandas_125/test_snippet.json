[
    {
        "name": "pandas.tests.frame.conftest.float_frame_with_na#9",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.float_frame_with_na()",
        "snippet": "def float_frame_with_na():\n    \"\"\"\n    Fixture for DataFrame of floats with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']; some entries are missing\n\n                       A         B         C         D\n    ABwBzA0ljw -1.128865 -0.897161  0.046603  0.274997\n    DJiRzmbyQF  0.728869  0.233502  0.722431 -0.890872\n    neMgPD5UBF  0.486072 -1.027393 -0.031553  1.449522\n    0yWA4n8VeX -1.937191 -1.142531  0.805215 -0.462018\n    3slYUbbqU1  0.153260  1.164691  1.489795 -0.545826\n    soujjZ0A08       NaN       NaN       NaN       NaN\n    7W6NLGsjB9       NaN       NaN       NaN       NaN\n    ...              ...       ...       ...       ...\n    uhfeaNkCR1 -0.231210 -0.340472  0.244717 -0.901590\n    n6p7GYuBIV -0.419052  1.922721 -0.125361 -0.727717\n    ZhzAeY6p1y  1.234374 -1.425359 -0.827038 -0.633189\n    uWdPsORyUh  0.046738 -0.980445 -1.102965  0.605503\n    3DJA6aN590 -0.091018 -1.684734 -1.100900  0.215947\n    2GBPAzdbMk -2.883405 -1.021071  1.209877  1.633083\n    sHadBoyVHw -2.223032 -0.326384  0.258931  0.245517\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    # set some NAs\n    df.loc[5:10] = np.nan\n    df.loc[15:20, -2:] = np.nan\n    return df",
        "begin_line": 9,
        "end_line": 38,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.bool_frame_with_na#42",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.bool_frame_with_na()",
        "snippet": "def bool_frame_with_na():\n    \"\"\"\n    Fixture for DataFrame of booleans with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']; some entries are missing\n\n                    A      B      C      D\n    zBZxY2IDGd  False  False  False  False\n    IhBWBMWllt  False   True   True   True\n    ctjdvZSR6R   True  False   True   True\n    AVTujptmxb  False   True  False   True\n    G9lrImrSWq  False  False  False   True\n    sFFwdIUfz2    NaN    NaN    NaN    NaN\n    s15ptEJnRb    NaN    NaN    NaN    NaN\n    ...           ...    ...    ...    ...\n    UW41KkDyZ4   True   True  False  False\n    l9l6XkOdqV   True  False  False  False\n    X2MeZfzDYA  False   True  False  False\n    xWkIKU7vfX  False   True  False   True\n    QOhL6VmpGU  False  False  False   True\n    22PwkRJdat  False   True  False  False\n    kfboQ3VeIK   True  False   True  False\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData()) > 0\n    df = df.astype(object)\n    # set some NAs\n    df.loc[5:10] = np.nan\n    df.loc[15:20, -2:] = np.nan\n    return df",
        "begin_line": 42,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.int_frame#76",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.int_frame()",
        "snippet": "def int_frame():\n    \"\"\"\n    Fixture for DataFrame of ints with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']\n\n                A  B  C  D\n    vpBeWjM651  1  0  1  0\n    5JyxmrP1En -1  0  0  0\n    qEDaoD49U2 -1  1  0  0\n    m66TkTfsFe  0  0  0  0\n    EHPaNzEUFm -1  0 -1  0\n    fpRJCevQhi  2  0  0  0\n    OlQvnmfi3Q  0  0 -2  0\n    ...        .. .. .. ..\n    uB1FPlz4uP  0  0  0  1\n    EcSe6yNzCU  0  0 -1  0\n    L50VudaiI8 -1  1 -2  0\n    y3bpw4nwIp  0 -1  0  0\n    H0RdLLwrCT  1  1  0  0\n    rY82K0vMwm  0  0  0  0\n    1OPIUjnkjk  2  0  0  0\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame({k: v.astype(int) for k, v in tm.getSeriesData().items()})\n    # force these all to int64 to avoid platform testing issues\n    return DataFrame({c: s for c, s in df.items()}, dtype=np.int64)",
        "begin_line": 76,
        "end_line": 103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.datetime_frame#107",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.datetime_frame()",
        "snippet": "def datetime_frame():\n    \"\"\"\n    Fixture for DataFrame of floats with DatetimeIndex\n\n    Columns are ['A', 'B', 'C', 'D']\n\n                       A         B         C         D\n    2000-01-03 -1.122153  0.468535  0.122226  1.693711\n    2000-01-04  0.189378  0.486100  0.007864 -1.216052\n    2000-01-05  0.041401 -0.835752 -0.035279 -0.414357\n    2000-01-06  0.430050  0.894352  0.090719  0.036939\n    2000-01-07 -0.620982 -0.668211 -0.706153  1.466335\n    2000-01-10 -0.752633  0.328434 -0.815325  0.699674\n    2000-01-11 -2.236969  0.615737 -0.829076 -1.196106\n    ...              ...       ...       ...       ...\n    2000-02-03  1.642618 -0.579288  0.046005  1.385249\n    2000-02-04 -0.544873 -1.160962 -0.284071 -1.418351\n    2000-02-07 -2.656149 -0.601387  1.410148  0.444150\n    2000-02-08 -1.201881 -1.289040  0.772992 -1.445300\n    2000-02-09  1.377373  0.398619  1.008453 -0.928207\n    2000-02-10  0.473194 -0.636677  0.984058  0.511519\n    2000-02-11 -0.965556  0.408313 -1.312844 -0.381948\n\n    [30 rows x 4 columns]\n    \"\"\"\n    return DataFrame(tm.getTimeSeriesData())",
        "begin_line": 107,
        "end_line": 132,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.float_string_frame#136",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.float_string_frame()",
        "snippet": "def float_string_frame():\n    \"\"\"\n    Fixture for DataFrame of floats and strings with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D', 'foo'].\n\n                       A         B         C         D  foo\n    w3orJvq07g -1.594062 -1.084273 -1.252457  0.356460  bar\n    PeukuVdmz2  0.109855 -0.955086 -0.809485  0.409747  bar\n    ahp2KvwiM8 -1.533729 -0.142519 -0.154666  1.302623  bar\n    3WSJ7BUCGd  2.484964  0.213829  0.034778 -2.327831  bar\n    khdAmufk0U -0.193480 -0.743518 -0.077987  0.153646  bar\n    LE2DZiFlrE -0.193566 -1.343194 -0.107321  0.959978  bar\n    HJXSJhVn7b  0.142590  1.257603 -0.659409 -0.223844  bar\n    ...              ...       ...       ...       ...  ...\n    9a1Vypttgw -1.316394  1.601354  0.173596  1.213196  bar\n    h5d1gVFbEy  0.609475  1.106738 -0.155271  0.294630  bar\n    mK9LsTQG92  1.303613  0.857040 -1.019153  0.369468  bar\n    oOLksd9gKH  0.558219 -0.134491 -0.289869 -0.951033  bar\n    9jgoOjKyHg  0.058270 -0.496110 -0.413212 -0.852659  bar\n    jZLDHclHAO  0.096298  1.267510  0.549206 -0.005235  bar\n    lR0nxDp1C2 -2.119350 -0.794384  0.544118  0.145849  bar\n\n    [30 rows x 5 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    df[\"foo\"] = \"bar\"\n    return df",
        "begin_line": 136,
        "end_line": 163,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_float_frame#167",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_float_frame()",
        "snippet": "def mixed_float_frame():\n    \"\"\"\n    Fixture for DataFrame of different float types with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D'].\n\n                       A         B         C         D\n    GI7bbDaEZe -0.237908 -0.246225 -0.468506  0.752993\n    KGp9mFepzA -1.140809 -0.644046 -1.225586  0.801588\n    VeVYLAb1l2 -1.154013 -1.677615  0.690430 -0.003731\n    kmPME4WKhO  0.979578  0.998274 -0.776367  0.897607\n    CPyopdXTiz  0.048119 -0.257174  0.836426  0.111266\n    0kJZQndAj0  0.274357 -0.281135 -0.344238  0.834541\n    tqdwQsaHG8 -0.979716 -0.519897  0.582031  0.144710\n    ...              ...       ...       ...       ...\n    7FhZTWILQj -2.906357  1.261039 -0.780273 -0.537237\n    4pUDPM4eGq -2.042512 -0.464382 -0.382080  1.132612\n    B8dUgUzwTi -1.506637 -0.364435  1.087891  0.297653\n    hErlVYjVv9  1.477453 -0.495515 -0.713867  1.438427\n    1BKN3o7YLs  0.127535 -0.349812 -0.881836  0.489827\n    9S4Ekn7zga  1.445518 -2.095149  0.031982  0.373204\n    xN1dNn6OV6  1.425017 -0.983995 -0.363281 -0.224502\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    df.A = df.A.astype(\"float32\")\n    df.B = df.B.astype(\"float32\")\n    df.C = df.C.astype(\"float16\")\n    df.D = df.D.astype(\"float64\")\n    return df",
        "begin_line": 167,
        "end_line": 197,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_int_frame#201",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_int_frame()",
        "snippet": "def mixed_int_frame():\n    \"\"\"\n    Fixture for DataFrame of different int types with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D'].\n\n                A  B    C    D\n    mUrCZ67juP  0  1    2    2\n    rw99ACYaKS  0  1    0    0\n    7QsEcpaaVU  0  1    1    1\n    xkrimI2pcE  0  1    0    0\n    dz01SuzoS8  0  1  255  255\n    ccQkqOHX75 -1  1    0    0\n    DN0iXaoDLd  0  1    0    0\n    ...        .. ..  ...  ...\n    Dfb141wAaQ  1  1  254  254\n    IPD8eQOVu5  0  1    0    0\n    CcaKulsCmv  0  1    0    0\n    rIBa8gu7E5  0  1    0    0\n    RP6peZmh5o  0  1    1    1\n    NMb9pipQWQ  0  1    0    0\n    PqgbJEzjib  0  1    3    3\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame({k: v.astype(int) for k, v in tm.getSeriesData().items()})\n    df.A = df.A.astype(\"int32\")\n    df.B = np.ones(len(df.B), dtype=\"uint64\")\n    df.C = df.C.astype(\"uint8\")\n    df.D = df.C.astype(\"int64\")\n    return df",
        "begin_line": 201,
        "end_line": 231,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_type_frame#235",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_type_frame()",
        "snippet": "def mixed_type_frame():\n    \"\"\"\n    Fixture for DataFrame of float/int/string columns with RangeIndex\n    Columns are ['a', 'b', 'c', 'float32', 'int32'].\n    \"\"\"\n    return DataFrame(\n        {\n            \"a\": 1.0,\n            \"b\": 2,\n            \"c\": \"foo\",\n            \"float32\": np.array([1.0] * 10, dtype=\"float32\"),\n            \"int32\": np.array([1] * 10, dtype=\"int32\"),\n        },\n        index=np.arange(10),\n    )",
        "begin_line": 235,
        "end_line": 249,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.timezone_frame#253",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.timezone_frame()",
        "snippet": "def timezone_frame():\n    \"\"\"\n    Fixture for DataFrame of date_range Series with different time zones\n\n    Columns are ['A', 'B', 'C']; some entries are missing\n\n               A                         B                         C\n    0 2013-01-01 2013-01-01 00:00:00-05:00 2013-01-01 00:00:00+01:00\n    1 2013-01-02                       NaT                       NaT\n    2 2013-01-03 2013-01-03 00:00:00-05:00 2013-01-03 00:00:00+01:00\n    \"\"\"\n    df = DataFrame(\n        {\n            \"A\": date_range(\"20130101\", periods=3),\n            \"B\": date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n            \"C\": date_range(\"20130101\", periods=3, tz=\"CET\"),\n        }\n    )\n    df.iloc[1, 1] = NaT\n    df.iloc[1, 2] = NaT\n    return df",
        "begin_line": 253,
        "end_line": 273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.uint64_frame#277",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.uint64_frame()",
        "snippet": "def uint64_frame():\n    \"\"\"\n    Fixture for DataFrame with uint64 values\n\n    Columns are ['A', 'B']\n    \"\"\"\n    return DataFrame(\n        {\"A\": np.arange(3), \"B\": [2 ** 63, 2 ** 63 + 5, 2 ** 63 + 10]}, dtype=np.uint64\n    )",
        "begin_line": 277,
        "end_line": 285,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.simple_frame#289",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.simple_frame()",
        "snippet": "def simple_frame():\n    \"\"\"\n    Fixture for simple 3x3 DataFrame\n\n    Columns are ['one', 'two', 'three'], index is ['a', 'b', 'c'].\n\n       one  two  three\n    a  1.0  2.0    3.0\n    b  4.0  5.0    6.0\n    c  7.0  8.0    9.0\n    \"\"\"\n    arr = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])\n\n    return DataFrame(arr, columns=[\"one\", \"two\", \"three\"], index=[\"a\", \"b\", \"c\"])",
        "begin_line": 289,
        "end_line": 302,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.frame_of_index_cols#306",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.frame_of_index_cols()",
        "snippet": "def frame_of_index_cols():\n    \"\"\"\n    Fixture for DataFrame of columns that can be used for indexing\n\n    Columns are ['A', 'B', 'C', 'D', 'E', ('tuple', 'as', 'label')];\n    'A' & 'B' contain duplicates (but are jointly unique), the rest are unique.\n\n         A      B  C         D         E  (tuple, as, label)\n    0  foo    one  a  0.608477 -0.012500           -1.664297\n    1  foo    two  b -0.633460  0.249614           -0.364411\n    2  foo  three  c  0.615256  2.154968           -0.834666\n    3  bar    one  d  0.234246  1.085675            0.718445\n    4  bar    two  e  0.533841 -0.005702           -3.533912\n    \"\"\"\n    df = DataFrame(\n        {\n            \"A\": [\"foo\", \"foo\", \"foo\", \"bar\", \"bar\"],\n            \"B\": [\"one\", \"two\", \"three\", \"one\", \"two\"],\n            \"C\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n            \"D\": np.random.randn(5),\n            \"E\": np.random.randn(5),\n            (\"tuple\", \"as\", \"label\"): np.random.randn(5),\n        }\n    )\n    return df",
        "begin_line": 306,
        "end_line": 330,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_algos.test_factorize#10",
        "src_path": "pandas/tests/arrays/categorical/test_algos.py",
        "class_name": "pandas.tests.arrays.categorical.test_algos",
        "signature": "pandas.tests.arrays.categorical.test_algos.test_factorize(categories, ordered)",
        "snippet": "def test_factorize(categories, ordered):\n    cat = pd.Categorical(\n        [\"b\", \"b\", \"a\", \"c\", None], categories=categories, ordered=ordered\n    )\n    codes, uniques = pd.factorize(cat)\n    expected_codes = np.array([0, 0, 1, 2, -1], dtype=np.intp)\n    expected_uniques = pd.Categorical(\n        [\"b\", \"a\", \"c\"], categories=categories, ordered=ordered\n    )\n\n    tm.assert_numpy_array_equal(codes, expected_codes)\n    tm.assert_categorical_equal(uniques, expected_uniques)",
        "begin_line": 10,
        "end_line": 21,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_algos.test_factorized_sort#24",
        "src_path": "pandas/tests/arrays/categorical/test_algos.py",
        "class_name": "pandas.tests.arrays.categorical.test_algos",
        "signature": "pandas.tests.arrays.categorical.test_algos.test_factorized_sort()",
        "snippet": "def test_factorized_sort():\n    cat = pd.Categorical([\"b\", \"b\", None, \"a\"])\n    codes, uniques = pd.factorize(cat, sort=True)\n    expected_codes = np.array([1, 1, -1, 0], dtype=np.intp)\n    expected_uniques = pd.Categorical([\"a\", \"b\"])\n\n    tm.assert_numpy_array_equal(codes, expected_codes)\n    tm.assert_categorical_equal(uniques, expected_uniques)",
        "begin_line": 24,
        "end_line": 31,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_algos.test_factorized_sort_ordered#34",
        "src_path": "pandas/tests/arrays/categorical/test_algos.py",
        "class_name": "pandas.tests.arrays.categorical.test_algos",
        "signature": "pandas.tests.arrays.categorical.test_algos.test_factorized_sort_ordered()",
        "snippet": "def test_factorized_sort_ordered():\n    cat = pd.Categorical(\n        [\"b\", \"b\", None, \"a\"], categories=[\"c\", \"b\", \"a\"], ordered=True\n    )\n\n    codes, uniques = pd.factorize(cat, sort=True)\n    expected_codes = np.array([0, 0, -1, 1], dtype=np.intp)\n    expected_uniques = pd.Categorical(\n        [\"b\", \"a\"], categories=[\"c\", \"b\", \"a\"], ordered=True\n    )\n\n    tm.assert_numpy_array_equal(codes, expected_codes)\n    tm.assert_categorical_equal(uniques, expected_uniques)",
        "begin_line": 34,
        "end_line": 46,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_algos.test_isin_cats#49",
        "src_path": "pandas/tests/arrays/categorical/test_algos.py",
        "class_name": "pandas.tests.arrays.categorical.test_algos",
        "signature": "pandas.tests.arrays.categorical.test_algos.test_isin_cats()",
        "snippet": "def test_isin_cats():\n    # GH2003\n    cat = pd.Categorical([\"a\", \"b\", np.nan])\n\n    result = cat.isin([\"a\", np.nan])\n    expected = np.array([True, False, True], dtype=bool)\n    tm.assert_numpy_array_equal(expected, result)\n\n    result = cat.isin([\"a\", \"c\"])\n    expected = np.array([True, False, False], dtype=bool)\n    tm.assert_numpy_array_equal(expected, result)",
        "begin_line": 49,
        "end_line": 59,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_algos.test_replace#66",
        "src_path": "pandas/tests/arrays/categorical/test_algos.py",
        "class_name": "pandas.tests.arrays.categorical.test_algos",
        "signature": "pandas.tests.arrays.categorical.test_algos.test_replace(to_replace, value, result)",
        "snippet": "def test_replace(to_replace, value, result):\n    # GH 26988\n    cat = pd.Categorical([\"a\", \"b\"])\n    expected = pd.Categorical(result)\n    result = cat.replace(to_replace, value)\n    tm.assert_categorical_equal(result, expected)\n    if to_replace == \"b\":  # the \"c\" test is supposed to be unchanged\n        with pytest.raises(AssertionError):\n            # ensure non-inplace call does not affect original\n            tm.assert_categorical_equal(cat, expected)\n    cat.replace(to_replace, value, inplace=True)\n    tm.assert_categorical_equal(cat, expected)",
        "begin_line": 66,
        "end_line": 77,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_algos.test_isin_empty#81",
        "src_path": "pandas/tests/arrays/categorical/test_algos.py",
        "class_name": "pandas.tests.arrays.categorical.test_algos",
        "signature": "pandas.tests.arrays.categorical.test_algos.test_isin_empty(empty)",
        "snippet": "def test_isin_empty(empty):\n    s = pd.Categorical([\"a\", \"b\"])\n    expected = np.array([False, False], dtype=bool)\n\n    result = s.isin(empty)\n    tm.assert_numpy_array_equal(expected, result)",
        "begin_line": 81,
        "end_line": 86,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_algos.TestTake.test_take_warns#92",
        "src_path": "pandas/tests/arrays/categorical/test_algos.py",
        "class_name": "pandas.tests.arrays.categorical.test_algos.TestTake",
        "signature": "pandas.tests.arrays.categorical.test_algos.TestTake.test_take_warns(self)",
        "snippet": "    def test_take_warns(self):\n        cat = pd.Categorical([\"a\", \"b\"])\n        with tm.assert_produces_warning(FutureWarning):\n            cat.take([0, -1])",
        "begin_line": 92,
        "end_line": 95,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_algos.TestTake.test_take_positive_no_warning#97",
        "src_path": "pandas/tests/arrays/categorical/test_algos.py",
        "class_name": "pandas.tests.arrays.categorical.test_algos.TestTake",
        "signature": "pandas.tests.arrays.categorical.test_algos.TestTake.test_take_positive_no_warning(self)",
        "snippet": "    def test_take_positive_no_warning(self):\n        cat = pd.Categorical([\"a\", \"b\"])\n        with tm.assert_produces_warning(None):\n            cat.take([0, 0])",
        "begin_line": 97,
        "end_line": 100,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_algos.TestTake.test_take_bounds#102",
        "src_path": "pandas/tests/arrays/categorical/test_algos.py",
        "class_name": "pandas.tests.arrays.categorical.test_algos.TestTake",
        "signature": "pandas.tests.arrays.categorical.test_algos.TestTake.test_take_bounds(self, allow_fill)",
        "snippet": "    def test_take_bounds(self, allow_fill):\n        # https://github.com/pandas-dev/pandas/issues/20664\n        cat = pd.Categorical([\"a\", \"b\", \"a\"])\n        with pytest.raises(IndexError):\n            cat.take([4, 5], allow_fill=allow_fill)",
        "begin_line": 102,
        "end_line": 106,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_algos.TestTake.test_take_empty#108",
        "src_path": "pandas/tests/arrays/categorical/test_algos.py",
        "class_name": "pandas.tests.arrays.categorical.test_algos.TestTake",
        "signature": "pandas.tests.arrays.categorical.test_algos.TestTake.test_take_empty(self, allow_fill)",
        "snippet": "    def test_take_empty(self, allow_fill):\n        # https://github.com/pandas-dev/pandas/issues/20664\n        cat = pd.Categorical([], categories=[\"a\", \"b\"])\n        with pytest.raises(IndexError):\n            cat.take([0], allow_fill=allow_fill)",
        "begin_line": 108,
        "end_line": 112,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_algos.TestTake.test_positional_take#114",
        "src_path": "pandas/tests/arrays/categorical/test_algos.py",
        "class_name": "pandas.tests.arrays.categorical.test_algos.TestTake",
        "signature": "pandas.tests.arrays.categorical.test_algos.TestTake.test_positional_take(self, ordered_fixture)",
        "snippet": "    def test_positional_take(self, ordered_fixture):\n        cat = pd.Categorical(\n            [\"a\", \"a\", \"b\", \"b\"], categories=[\"b\", \"a\"], ordered=ordered_fixture\n        )\n        result = cat.take([0, 1, 2], allow_fill=False)\n        expected = pd.Categorical(\n            [\"a\", \"a\", \"b\"], categories=cat.categories, ordered=ordered_fixture\n        )\n        tm.assert_categorical_equal(result, expected)",
        "begin_line": 114,
        "end_line": 122,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_algos.TestTake.test_positional_take_unobserved#124",
        "src_path": "pandas/tests/arrays/categorical/test_algos.py",
        "class_name": "pandas.tests.arrays.categorical.test_algos.TestTake",
        "signature": "pandas.tests.arrays.categorical.test_algos.TestTake.test_positional_take_unobserved(self, ordered_fixture)",
        "snippet": "    def test_positional_take_unobserved(self, ordered_fixture):\n        cat = pd.Categorical(\n            [\"a\", \"b\"], categories=[\"a\", \"b\", \"c\"], ordered=ordered_fixture\n        )\n        result = cat.take([1, 0], allow_fill=False)\n        expected = pd.Categorical(\n            [\"b\", \"a\"], categories=cat.categories, ordered=ordered_fixture\n        )\n        tm.assert_categorical_equal(result, expected)",
        "begin_line": 124,
        "end_line": 132,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_algos.TestTake.test_take_allow_fill#134",
        "src_path": "pandas/tests/arrays/categorical/test_algos.py",
        "class_name": "pandas.tests.arrays.categorical.test_algos.TestTake",
        "signature": "pandas.tests.arrays.categorical.test_algos.TestTake.test_take_allow_fill(self)",
        "snippet": "    def test_take_allow_fill(self):\n        # https://github.com/pandas-dev/pandas/issues/23296\n        cat = pd.Categorical([\"a\", \"a\", \"b\"])\n        result = cat.take([0, -1, -1], allow_fill=True)\n        expected = pd.Categorical([\"a\", np.nan, np.nan], categories=[\"a\", \"b\"])\n        tm.assert_categorical_equal(result, expected)",
        "begin_line": 134,
        "end_line": 139,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_algos.TestTake.test_take_fill_with_negative_one#141",
        "src_path": "pandas/tests/arrays/categorical/test_algos.py",
        "class_name": "pandas.tests.arrays.categorical.test_algos.TestTake",
        "signature": "pandas.tests.arrays.categorical.test_algos.TestTake.test_take_fill_with_negative_one(self)",
        "snippet": "    def test_take_fill_with_negative_one(self):\n        # -1 was a category\n        cat = pd.Categorical([-1, 0, 1])\n        result = cat.take([0, -1, 1], allow_fill=True, fill_value=-1)\n        expected = pd.Categorical([-1, -1, 0], categories=[-1, 0, 1])\n        tm.assert_categorical_equal(result, expected)",
        "begin_line": 141,
        "end_line": 146,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_algos.TestTake.test_take_fill_value#148",
        "src_path": "pandas/tests/arrays/categorical/test_algos.py",
        "class_name": "pandas.tests.arrays.categorical.test_algos.TestTake",
        "signature": "pandas.tests.arrays.categorical.test_algos.TestTake.test_take_fill_value(self)",
        "snippet": "    def test_take_fill_value(self):\n        # https://github.com/pandas-dev/pandas/issues/23296\n        cat = pd.Categorical([\"a\", \"b\", \"c\"])\n        result = cat.take([0, 1, -1], fill_value=\"a\", allow_fill=True)\n        expected = pd.Categorical([\"a\", \"b\", \"a\"], categories=[\"a\", \"b\", \"c\"])\n        tm.assert_categorical_equal(result, expected)",
        "begin_line": 148,
        "end_line": 153,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.arrays.categorical.test_algos.TestTake.test_take_fill_value_new_raises#155",
        "src_path": "pandas/tests/arrays/categorical/test_algos.py",
        "class_name": "pandas.tests.arrays.categorical.test_algos.TestTake",
        "signature": "pandas.tests.arrays.categorical.test_algos.TestTake.test_take_fill_value_new_raises(self)",
        "snippet": "    def test_take_fill_value_new_raises(self):\n        # https://github.com/pandas-dev/pandas/issues/23296\n        cat = pd.Categorical([\"a\", \"b\", \"c\"])\n        xpr = r\"'fill_value' \\('d'\\) is not in this Categorical's categories.\"\n        with pytest.raises(TypeError, match=xpr):\n            cat.take([0, 1, -1], fill_value=\"d\", allow_fill=True)",
        "begin_line": 155,
        "end_line": 160,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common._check_mixed_float#1",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common",
        "signature": "pandas.tests.frame.common._check_mixed_float(df, dtype=None)",
        "snippet": "def _check_mixed_float(df, dtype=None):\n    # float16 are most likely to be upcasted to float32\n    dtypes = dict(A=\"float32\", B=\"float32\", C=\"float16\", D=\"float64\")\n    if isinstance(dtype, str):\n        dtypes = {k: dtype for k, v in dtypes.items()}\n    elif isinstance(dtype, dict):\n        dtypes.update(dtype)\n    if dtypes.get(\"A\"):\n        assert df.dtypes[\"A\"] == dtypes[\"A\"]\n    if dtypes.get(\"B\"):\n        assert df.dtypes[\"B\"] == dtypes[\"B\"]\n    if dtypes.get(\"C\"):\n        assert df.dtypes[\"C\"] == dtypes[\"C\"]\n    if dtypes.get(\"D\"):\n        assert df.dtypes[\"D\"] == dtypes[\"D\"]",
        "begin_line": 1,
        "end_line": 15,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common._check_mixed_int#18",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common",
        "signature": "pandas.tests.frame.common._check_mixed_int(df, dtype=None)",
        "snippet": "def _check_mixed_int(df, dtype=None):\n    dtypes = dict(A=\"int32\", B=\"uint64\", C=\"uint8\", D=\"int64\")\n    if isinstance(dtype, str):\n        dtypes = {k: dtype for k, v in dtypes.items()}\n    elif isinstance(dtype, dict):\n        dtypes.update(dtype)\n    if dtypes.get(\"A\"):\n        assert df.dtypes[\"A\"] == dtypes[\"A\"]\n    if dtypes.get(\"B\"):\n        assert df.dtypes[\"B\"] == dtypes[\"B\"]\n    if dtypes.get(\"C\"):\n        assert df.dtypes[\"C\"] == dtypes[\"C\"]\n    if dtypes.get(\"D\"):\n        assert df.dtypes[\"D\"] == dtypes[\"D\"]",
        "begin_line": 18,
        "end_line": 31,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.mix_ab#15",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace",
        "signature": "pandas.tests.frame.test_replace.mix_ab()",
        "snippet": "def mix_ab() -> Dict[str, list]:\n    return {\"a\": list(range(4)), \"b\": list(\"ab..\")}",
        "begin_line": 15,
        "end_line": 16,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.mix_abc#20",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace",
        "signature": "pandas.tests.frame.test_replace.mix_abc()",
        "snippet": "def mix_abc() -> Dict[str, list]:\n    return {\"a\": list(range(4)), \"b\": list(\"ab..\"), \"c\": [\"a\", \"b\", np.nan, \"d\"]}",
        "begin_line": 20,
        "end_line": 21,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_inplace#25",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_inplace(self, datetime_frame, float_string_frame)",
        "snippet": "    def test_replace_inplace(self, datetime_frame, float_string_frame):\n        datetime_frame[\"A\"][:5] = np.nan\n        datetime_frame[\"A\"][-5:] = np.nan\n\n        tsframe = datetime_frame.copy()\n        tsframe.replace(np.nan, 0, inplace=True)\n        tm.assert_frame_equal(tsframe, datetime_frame.fillna(0))\n\n        # mixed type\n        mf = float_string_frame\n        mf.iloc[5:20, mf.columns.get_loc(\"foo\")] = np.nan\n        mf.iloc[-10:, mf.columns.get_loc(\"A\")] = np.nan\n\n        result = float_string_frame.replace(np.nan, 0)\n        expected = float_string_frame.fillna(value=0)\n        tm.assert_frame_equal(result, expected)\n\n        tsframe = datetime_frame.copy()\n        tsframe.replace([np.nan], [0], inplace=True)\n        tm.assert_frame_equal(tsframe, datetime_frame.fillna(0))",
        "begin_line": 25,
        "end_line": 44,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_scalar#46",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_scalar(self, mix_ab)",
        "snippet": "    def test_regex_replace_scalar(self, mix_ab):\n        obj = {\"a\": list(\"ab..\"), \"b\": list(\"efgh\")}\n        dfobj = DataFrame(obj)\n        dfmix = DataFrame(mix_ab)\n\n        # simplest cases\n        # regex -> value\n        # obj frame\n        res = dfobj.replace(r\"\\s*\\.\\s*\", np.nan, regex=True)\n        tm.assert_frame_equal(dfobj, res.fillna(\".\"))\n\n        # mixed\n        res = dfmix.replace(r\"\\s*\\.\\s*\", np.nan, regex=True)\n        tm.assert_frame_equal(dfmix, res.fillna(\".\"))\n\n        # regex -> regex\n        # obj frame\n        res = dfobj.replace(r\"\\s*(\\.)\\s*\", r\"\\1\\1\\1\", regex=True)\n        objc = obj.copy()\n        objc[\"a\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(objc)\n        tm.assert_frame_equal(res, expec)\n\n        # with mixed\n        res = dfmix.replace(r\"\\s*(\\.)\\s*\", r\"\\1\\1\\1\", regex=True)\n        mixc = mix_ab.copy()\n        mixc[\"b\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(mixc)\n        tm.assert_frame_equal(res, expec)\n\n        # everything with compiled regexs as well\n        res = dfobj.replace(re.compile(r\"\\s*\\.\\s*\"), np.nan, regex=True)\n        tm.assert_frame_equal(dfobj, res.fillna(\".\"))\n\n        # mixed\n        res = dfmix.replace(re.compile(r\"\\s*\\.\\s*\"), np.nan, regex=True)\n        tm.assert_frame_equal(dfmix, res.fillna(\".\"))\n\n        # regex -> regex\n        # obj frame\n        res = dfobj.replace(re.compile(r\"\\s*(\\.)\\s*\"), r\"\\1\\1\\1\")\n        objc = obj.copy()\n        objc[\"a\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(objc)\n        tm.assert_frame_equal(res, expec)\n\n        # with mixed\n        res = dfmix.replace(re.compile(r\"\\s*(\\.)\\s*\"), r\"\\1\\1\\1\")\n        mixc = mix_ab.copy()\n        mixc[\"b\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(mixc)\n        tm.assert_frame_equal(res, expec)\n\n        res = dfmix.replace(regex=re.compile(r\"\\s*(\\.)\\s*\"), value=r\"\\1\\1\\1\")\n        mixc = mix_ab.copy()\n        mixc[\"b\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(mixc)\n        tm.assert_frame_equal(res, expec)\n\n        res = dfmix.replace(regex=r\"\\s*(\\.)\\s*\", value=r\"\\1\\1\\1\")\n        mixc = mix_ab.copy()\n        mixc[\"b\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(mixc)\n        tm.assert_frame_equal(res, expec)",
        "begin_line": 46,
        "end_line": 109,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_scalar_inplace#111",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_scalar_inplace(self, mix_ab)",
        "snippet": "    def test_regex_replace_scalar_inplace(self, mix_ab):\n        obj = {\"a\": list(\"ab..\"), \"b\": list(\"efgh\")}\n        dfobj = DataFrame(obj)\n        dfmix = DataFrame(mix_ab)\n\n        # simplest cases\n        # regex -> value\n        # obj frame\n        res = dfobj.copy()\n        res.replace(r\"\\s*\\.\\s*\", np.nan, regex=True, inplace=True)\n        tm.assert_frame_equal(dfobj, res.fillna(\".\"))\n\n        # mixed\n        res = dfmix.copy()\n        res.replace(r\"\\s*\\.\\s*\", np.nan, regex=True, inplace=True)\n        tm.assert_frame_equal(dfmix, res.fillna(\".\"))\n\n        # regex -> regex\n        # obj frame\n        res = dfobj.copy()\n        res.replace(r\"\\s*(\\.)\\s*\", r\"\\1\\1\\1\", regex=True, inplace=True)\n        objc = obj.copy()\n        objc[\"a\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(objc)\n        tm.assert_frame_equal(res, expec)\n\n        # with mixed\n        res = dfmix.copy()\n        res.replace(r\"\\s*(\\.)\\s*\", r\"\\1\\1\\1\", regex=True, inplace=True)\n        mixc = mix_ab.copy()\n        mixc[\"b\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(mixc)\n        tm.assert_frame_equal(res, expec)\n\n        # everything with compiled regexs as well\n        res = dfobj.copy()\n        res.replace(re.compile(r\"\\s*\\.\\s*\"), np.nan, regex=True, inplace=True)\n        tm.assert_frame_equal(dfobj, res.fillna(\".\"))\n\n        # mixed\n        res = dfmix.copy()\n        res.replace(re.compile(r\"\\s*\\.\\s*\"), np.nan, regex=True, inplace=True)\n        tm.assert_frame_equal(dfmix, res.fillna(\".\"))\n\n        # regex -> regex\n        # obj frame\n        res = dfobj.copy()\n        res.replace(re.compile(r\"\\s*(\\.)\\s*\"), r\"\\1\\1\\1\", regex=True, inplace=True)\n        objc = obj.copy()\n        objc[\"a\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(objc)\n        tm.assert_frame_equal(res, expec)\n\n        # with mixed\n        res = dfmix.copy()\n        res.replace(re.compile(r\"\\s*(\\.)\\s*\"), r\"\\1\\1\\1\", regex=True, inplace=True)\n        mixc = mix_ab.copy()\n        mixc[\"b\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(mixc)\n        tm.assert_frame_equal(res, expec)\n\n        res = dfobj.copy()\n        res.replace(regex=r\"\\s*\\.\\s*\", value=np.nan, inplace=True)\n        tm.assert_frame_equal(dfobj, res.fillna(\".\"))\n\n        # mixed\n        res = dfmix.copy()\n        res.replace(regex=r\"\\s*\\.\\s*\", value=np.nan, inplace=True)\n        tm.assert_frame_equal(dfmix, res.fillna(\".\"))\n\n        # regex -> regex\n        # obj frame\n        res = dfobj.copy()\n        res.replace(regex=r\"\\s*(\\.)\\s*\", value=r\"\\1\\1\\1\", inplace=True)\n        objc = obj.copy()\n        objc[\"a\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(objc)\n        tm.assert_frame_equal(res, expec)\n\n        # with mixed\n        res = dfmix.copy()\n        res.replace(regex=r\"\\s*(\\.)\\s*\", value=r\"\\1\\1\\1\", inplace=True)\n        mixc = mix_ab.copy()\n        mixc[\"b\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(mixc)\n        tm.assert_frame_equal(res, expec)\n\n        # everything with compiled regexs as well\n        res = dfobj.copy()\n        res.replace(regex=re.compile(r\"\\s*\\.\\s*\"), value=np.nan, inplace=True)\n        tm.assert_frame_equal(dfobj, res.fillna(\".\"))\n\n        # mixed\n        res = dfmix.copy()\n        res.replace(regex=re.compile(r\"\\s*\\.\\s*\"), value=np.nan, inplace=True)\n        tm.assert_frame_equal(dfmix, res.fillna(\".\"))\n\n        # regex -> regex\n        # obj frame\n        res = dfobj.copy()\n        res.replace(regex=re.compile(r\"\\s*(\\.)\\s*\"), value=r\"\\1\\1\\1\", inplace=True)\n        objc = obj.copy()\n        objc[\"a\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(objc)\n        tm.assert_frame_equal(res, expec)\n\n        # with mixed\n        res = dfmix.copy()\n        res.replace(regex=re.compile(r\"\\s*(\\.)\\s*\"), value=r\"\\1\\1\\1\", inplace=True)\n        mixc = mix_ab.copy()\n        mixc[\"b\"] = [\"a\", \"b\", \"...\", \"...\"]\n        expec = DataFrame(mixc)\n        tm.assert_frame_equal(res, expec)",
        "begin_line": 111,
        "end_line": 223,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_list_obj#225",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_list_obj(self)",
        "snippet": "    def test_regex_replace_list_obj(self):\n        obj = {\"a\": list(\"ab..\"), \"b\": list(\"efgh\"), \"c\": list(\"helo\")}\n        dfobj = DataFrame(obj)\n\n        # lists of regexes and values\n        # list of [re1, re2, ..., reN] -> [v1, v2, ..., vN]\n        to_replace_res = [r\"\\s*\\.\\s*\", r\"e|f|g\"]\n        values = [np.nan, \"crap\"]\n        res = dfobj.replace(to_replace_res, values, regex=True)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", np.nan, np.nan],\n                \"b\": [\"crap\"] * 3 + [\"h\"],\n                \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [re1, re2, .., reN]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"(e|f|g)\"]\n        values = [r\"\\1\\1\", r\"\\1_crap\"]\n        res = dfobj.replace(to_replace_res, values, regex=True)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", \"..\", \"..\"],\n                \"b\": [\"e_crap\", \"f_crap\", \"g_crap\", \"h\"],\n                \"c\": [\"h\", \"e_crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [(re1 or v1), (re2 or v2), ..., (reN\n        # or vN)]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"e\"]\n        values = [r\"\\1\\1\", r\"crap\"]\n        res = dfobj.replace(to_replace_res, values, regex=True)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", \"..\", \"..\"],\n                \"b\": [\"crap\", \"f\", \"g\", \"h\"],\n                \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"e\"]\n        values = [r\"\\1\\1\", r\"crap\"]\n        res = dfobj.replace(value=values, regex=to_replace_res)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", \"..\", \"..\"],\n                \"b\": [\"crap\", \"f\", \"g\", \"h\"],\n                \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)",
        "begin_line": 225,
        "end_line": 280,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_list_obj_inplace#282",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_list_obj_inplace(self)",
        "snippet": "    def test_regex_replace_list_obj_inplace(self):\n        # same as above with inplace=True\n        # lists of regexes and values\n        obj = {\"a\": list(\"ab..\"), \"b\": list(\"efgh\"), \"c\": list(\"helo\")}\n        dfobj = DataFrame(obj)\n\n        # lists of regexes and values\n        # list of [re1, re2, ..., reN] -> [v1, v2, ..., vN]\n        to_replace_res = [r\"\\s*\\.\\s*\", r\"e|f|g\"]\n        values = [np.nan, \"crap\"]\n        res = dfobj.copy()\n        res.replace(to_replace_res, values, inplace=True, regex=True)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", np.nan, np.nan],\n                \"b\": [\"crap\"] * 3 + [\"h\"],\n                \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [re1, re2, .., reN]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"(e|f|g)\"]\n        values = [r\"\\1\\1\", r\"\\1_crap\"]\n        res = dfobj.copy()\n        res.replace(to_replace_res, values, inplace=True, regex=True)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", \"..\", \"..\"],\n                \"b\": [\"e_crap\", \"f_crap\", \"g_crap\", \"h\"],\n                \"c\": [\"h\", \"e_crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [(re1 or v1), (re2 or v2), ..., (reN\n        # or vN)]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"e\"]\n        values = [r\"\\1\\1\", r\"crap\"]\n        res = dfobj.copy()\n        res.replace(to_replace_res, values, inplace=True, regex=True)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", \"..\", \"..\"],\n                \"b\": [\"crap\", \"f\", \"g\", \"h\"],\n                \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"e\"]\n        values = [r\"\\1\\1\", r\"crap\"]\n        res = dfobj.copy()\n        res.replace(value=values, regex=to_replace_res, inplace=True)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", \"..\", \"..\"],\n                \"b\": [\"crap\", \"f\", \"g\", \"h\"],\n                \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)",
        "begin_line": 282,
        "end_line": 343,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_list_mixed#345",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_list_mixed(self, mix_ab)",
        "snippet": "    def test_regex_replace_list_mixed(self, mix_ab):\n        # mixed frame to make sure this doesn't break things\n        dfmix = DataFrame(mix_ab)\n\n        # lists of regexes and values\n        # list of [re1, re2, ..., reN] -> [v1, v2, ..., vN]\n        to_replace_res = [r\"\\s*\\.\\s*\", r\"a\"]\n        values = [np.nan, \"crap\"]\n        mix2 = {\"a\": list(range(4)), \"b\": list(\"ab..\"), \"c\": list(\"halo\")}\n        dfmix2 = DataFrame(mix2)\n        res = dfmix2.replace(to_replace_res, values, regex=True)\n        expec = DataFrame(\n            {\n                \"a\": mix2[\"a\"],\n                \"b\": [\"crap\", \"b\", np.nan, np.nan],\n                \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [re1, re2, .., reN]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"(a|b)\"]\n        values = [r\"\\1\\1\", r\"\\1_crap\"]\n        res = dfmix.replace(to_replace_res, values, regex=True)\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"a_crap\", \"b_crap\", \"..\", \"..\"]})\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [(re1 or v1), (re2 or v2), ..., (reN\n        # or vN)]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"a\", r\"(b)\"]\n        values = [r\"\\1\\1\", r\"crap\", r\"\\1_crap\"]\n        res = dfmix.replace(to_replace_res, values, regex=True)\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"crap\", \"b_crap\", \"..\", \"..\"]})\n        tm.assert_frame_equal(res, expec)\n\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"a\", r\"(b)\"]\n        values = [r\"\\1\\1\", r\"crap\", r\"\\1_crap\"]\n        res = dfmix.replace(regex=to_replace_res, value=values)\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"crap\", \"b_crap\", \"..\", \"..\"]})\n        tm.assert_frame_equal(res, expec)",
        "begin_line": 345,
        "end_line": 384,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_list_mixed_inplace#386",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_list_mixed_inplace(self, mix_ab)",
        "snippet": "    def test_regex_replace_list_mixed_inplace(self, mix_ab):\n        dfmix = DataFrame(mix_ab)\n        # the same inplace\n        # lists of regexes and values\n        # list of [re1, re2, ..., reN] -> [v1, v2, ..., vN]\n        to_replace_res = [r\"\\s*\\.\\s*\", r\"a\"]\n        values = [np.nan, \"crap\"]\n        res = dfmix.copy()\n        res.replace(to_replace_res, values, inplace=True, regex=True)\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"crap\", \"b\", np.nan, np.nan]})\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [re1, re2, .., reN]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"(a|b)\"]\n        values = [r\"\\1\\1\", r\"\\1_crap\"]\n        res = dfmix.copy()\n        res.replace(to_replace_res, values, inplace=True, regex=True)\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"a_crap\", \"b_crap\", \"..\", \"..\"]})\n        tm.assert_frame_equal(res, expec)\n\n        # list of [re1, re2, ..., reN] -> [(re1 or v1), (re2 or v2), ..., (reN\n        # or vN)]\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"a\", r\"(b)\"]\n        values = [r\"\\1\\1\", r\"crap\", r\"\\1_crap\"]\n        res = dfmix.copy()\n        res.replace(to_replace_res, values, inplace=True, regex=True)\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"crap\", \"b_crap\", \"..\", \"..\"]})\n        tm.assert_frame_equal(res, expec)\n\n        to_replace_res = [r\"\\s*(\\.)\\s*\", r\"a\", r\"(b)\"]\n        values = [r\"\\1\\1\", r\"crap\", r\"\\1_crap\"]\n        res = dfmix.copy()\n        res.replace(regex=to_replace_res, value=values, inplace=True)\n        expec = DataFrame({\"a\": mix_ab[\"a\"], \"b\": [\"crap\", \"b_crap\", \"..\", \"..\"]})\n        tm.assert_frame_equal(res, expec)",
        "begin_line": 386,
        "end_line": 420,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_dict_mixed#422",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_dict_mixed(self, mix_abc)",
        "snippet": "    def test_regex_replace_dict_mixed(self, mix_abc):\n        dfmix = DataFrame(mix_abc)\n\n        # dicts\n        # single dict {re1: v1}, search the whole frame\n        # need test for this...\n\n        # list of dicts {re1: v1, re2: v2, ..., re3: v3}, search the whole\n        # frame\n        res = dfmix.replace({\"b\": r\"\\s*\\.\\s*\"}, {\"b\": np.nan}, regex=True)\n        res2 = dfmix.copy()\n        res2.replace({\"b\": r\"\\s*\\.\\s*\"}, {\"b\": np.nan}, inplace=True, regex=True)\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [\"a\", \"b\", np.nan, np.nan], \"c\": mix_abc[\"c\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n\n        # list of dicts {re1: re11, re2: re12, ..., reN: re1N}, search the\n        # whole frame\n        res = dfmix.replace({\"b\": r\"\\s*(\\.)\\s*\"}, {\"b\": r\"\\1ty\"}, regex=True)\n        res2 = dfmix.copy()\n        res2.replace({\"b\": r\"\\s*(\\.)\\s*\"}, {\"b\": r\"\\1ty\"}, inplace=True, regex=True)\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [\"a\", \"b\", \".ty\", \".ty\"], \"c\": mix_abc[\"c\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n\n        res = dfmix.replace(regex={\"b\": r\"\\s*(\\.)\\s*\"}, value={\"b\": r\"\\1ty\"})\n        res2 = dfmix.copy()\n        res2.replace(regex={\"b\": r\"\\s*(\\.)\\s*\"}, value={\"b\": r\"\\1ty\"}, inplace=True)\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [\"a\", \"b\", \".ty\", \".ty\"], \"c\": mix_abc[\"c\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n\n        # scalar -> dict\n        # to_replace regex, {value: value}\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [np.nan, \"b\", \".\", \".\"], \"c\": mix_abc[\"c\"]}\n        )\n        res = dfmix.replace(\"a\", {\"b\": np.nan}, regex=True)\n        res2 = dfmix.copy()\n        res2.replace(\"a\", {\"b\": np.nan}, regex=True, inplace=True)\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n\n        res = dfmix.replace(\"a\", {\"b\": np.nan}, regex=True)\n        res2 = dfmix.copy()\n        res2.replace(regex=\"a\", value={\"b\": np.nan}, inplace=True)\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [np.nan, \"b\", \".\", \".\"], \"c\": mix_abc[\"c\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)",
        "begin_line": 422,
        "end_line": 478,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_dict_nested#480",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_dict_nested(self, mix_abc)",
        "snippet": "    def test_regex_replace_dict_nested(self, mix_abc):\n        # nested dicts will not work until this is implemented for Series\n        dfmix = DataFrame(mix_abc)\n        res = dfmix.replace({\"b\": {r\"\\s*\\.\\s*\": np.nan}}, regex=True)\n        res2 = dfmix.copy()\n        res4 = dfmix.copy()\n        res2.replace({\"b\": {r\"\\s*\\.\\s*\": np.nan}}, inplace=True, regex=True)\n        res3 = dfmix.replace(regex={\"b\": {r\"\\s*\\.\\s*\": np.nan}})\n        res4.replace(regex={\"b\": {r\"\\s*\\.\\s*\": np.nan}}, inplace=True)\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [\"a\", \"b\", np.nan, np.nan], \"c\": mix_abc[\"c\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n        tm.assert_frame_equal(res3, expec)\n        tm.assert_frame_equal(res4, expec)",
        "begin_line": 480,
        "end_line": 495,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_dict_nested_non_first_character#497",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_dict_nested_non_first_character(self)",
        "snippet": "    def test_regex_replace_dict_nested_non_first_character(self):\n        # GH 25259\n        df = pd.DataFrame({\"first\": [\"abc\", \"bca\", \"cab\"]})\n        expected = pd.DataFrame({\"first\": [\".bc\", \"bc.\", \"c.b\"]})\n        result = df.replace({\"a\": \".\"}, regex=True)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 497,
        "end_line": 502,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_dict_nested_gh4115#504",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_dict_nested_gh4115(self)",
        "snippet": "    def test_regex_replace_dict_nested_gh4115(self):\n        df = pd.DataFrame({\"Type\": [\"Q\", \"T\", \"Q\", \"Q\", \"T\"], \"tmp\": 2})\n        expected = DataFrame({\"Type\": [0, 1, 0, 0, 1], \"tmp\": 2})\n        result = df.replace({\"Type\": {\"Q\": 0, \"T\": 1}})\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 504,
        "end_line": 508,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_list_to_scalar#510",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_list_to_scalar(self, mix_abc)",
        "snippet": "    def test_regex_replace_list_to_scalar(self, mix_abc):\n        df = DataFrame(mix_abc)\n        expec = DataFrame(\n            {\n                \"a\": mix_abc[\"a\"],\n                \"b\": np.array([np.nan] * 4),\n                \"c\": [np.nan, np.nan, np.nan, \"d\"],\n            }\n        )\n        res = df.replace([r\"\\s*\\.\\s*\", \"a|b\"], np.nan, regex=True)\n        res2 = df.copy()\n        res3 = df.copy()\n        res2.replace([r\"\\s*\\.\\s*\", \"a|b\"], np.nan, regex=True, inplace=True)\n        res3.replace(regex=[r\"\\s*\\.\\s*\", \"a|b\"], value=np.nan, inplace=True)\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n        tm.assert_frame_equal(res3, expec)",
        "begin_line": 510,
        "end_line": 526,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_str_to_numeric#528",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_str_to_numeric(self, mix_abc)",
        "snippet": "    def test_regex_replace_str_to_numeric(self, mix_abc):\n        # what happens when you try to replace a numeric value with a regex?\n        df = DataFrame(mix_abc)\n        res = df.replace(r\"\\s*\\.\\s*\", 0, regex=True)\n        res2 = df.copy()\n        res2.replace(r\"\\s*\\.\\s*\", 0, inplace=True, regex=True)\n        res3 = df.copy()\n        res3.replace(regex=r\"\\s*\\.\\s*\", value=0, inplace=True)\n        expec = DataFrame({\"a\": mix_abc[\"a\"], \"b\": [\"a\", \"b\", 0, 0], \"c\": mix_abc[\"c\"]})\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n        tm.assert_frame_equal(res3, expec)",
        "begin_line": 528,
        "end_line": 539,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_regex_list_to_numeric#541",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_regex_list_to_numeric(self, mix_abc)",
        "snippet": "    def test_regex_replace_regex_list_to_numeric(self, mix_abc):\n        df = DataFrame(mix_abc)\n        res = df.replace([r\"\\s*\\.\\s*\", \"b\"], 0, regex=True)\n        res2 = df.copy()\n        res2.replace([r\"\\s*\\.\\s*\", \"b\"], 0, regex=True, inplace=True)\n        res3 = df.copy()\n        res3.replace(regex=[r\"\\s*\\.\\s*\", \"b\"], value=0, inplace=True)\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [\"a\", 0, 0, 0], \"c\": [\"a\", 0, np.nan, \"d\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n        tm.assert_frame_equal(res3, expec)",
        "begin_line": 541,
        "end_line": 553,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_series_of_regexes#555",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_series_of_regexes(self, mix_abc)",
        "snippet": "    def test_regex_replace_series_of_regexes(self, mix_abc):\n        df = DataFrame(mix_abc)\n        s1 = Series({\"b\": r\"\\s*\\.\\s*\"})\n        s2 = Series({\"b\": np.nan})\n        res = df.replace(s1, s2, regex=True)\n        res2 = df.copy()\n        res2.replace(s1, s2, inplace=True, regex=True)\n        res3 = df.copy()\n        res3.replace(regex=s1, value=s2, inplace=True)\n        expec = DataFrame(\n            {\"a\": mix_abc[\"a\"], \"b\": [\"a\", \"b\", np.nan, np.nan], \"c\": mix_abc[\"c\"]}\n        )\n        tm.assert_frame_equal(res, expec)\n        tm.assert_frame_equal(res2, expec)\n        tm.assert_frame_equal(res3, expec)",
        "begin_line": 555,
        "end_line": 569,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_numeric_to_object_conversion#571",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_regex_replace_numeric_to_object_conversion(self, mix_abc)",
        "snippet": "    def test_regex_replace_numeric_to_object_conversion(self, mix_abc):\n        df = DataFrame(mix_abc)\n        expec = DataFrame({\"a\": [\"a\", 1, 2, 3], \"b\": mix_abc[\"b\"], \"c\": mix_abc[\"c\"]})\n        res = df.replace(0, \"a\")\n        tm.assert_frame_equal(res, expec)\n        assert res.a.dtype == np.object_",
        "begin_line": 571,
        "end_line": 576,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_regex_metachar#579",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_regex_metachar(self, metachar)",
        "snippet": "    def test_replace_regex_metachar(self, metachar):\n        df = DataFrame({\"a\": [metachar, \"else\"]})\n        result = df.replace({\"a\": {metachar: \"paren\"}})\n        expected = DataFrame({\"a\": [\"paren\", \"else\"]})\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 579,
        "end_line": 583,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace#585",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace(self, datetime_frame)",
        "snippet": "    def test_replace(self, datetime_frame):\n        datetime_frame[\"A\"][:5] = np.nan\n        datetime_frame[\"A\"][-5:] = np.nan\n\n        zero_filled = datetime_frame.replace(np.nan, -1e8)\n        tm.assert_frame_equal(zero_filled, datetime_frame.fillna(-1e8))\n        tm.assert_frame_equal(zero_filled.replace(-1e8, np.nan), datetime_frame)\n\n        datetime_frame[\"A\"][:5] = np.nan\n        datetime_frame[\"A\"][-5:] = np.nan\n        datetime_frame[\"B\"][:5] = -1e8\n\n        # empty\n        df = DataFrame(index=[\"a\", \"b\"])\n        tm.assert_frame_equal(df, df.replace(5, 7))\n\n        # GH 11698\n        # test for mixed data types.\n        df = pd.DataFrame(\n            [(\"-\", pd.to_datetime(\"20150101\")), (\"a\", pd.to_datetime(\"20150102\"))]\n        )\n        df1 = df.replace(\"-\", np.nan)\n        expected_df = pd.DataFrame(\n            [(np.nan, pd.to_datetime(\"20150101\")), (\"a\", pd.to_datetime(\"20150102\"))]\n        )\n        tm.assert_frame_equal(df1, expected_df)",
        "begin_line": 585,
        "end_line": 610,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_list#612",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_list(self)",
        "snippet": "    def test_replace_list(self):\n        obj = {\"a\": list(\"ab..\"), \"b\": list(\"efgh\"), \"c\": list(\"helo\")}\n        dfobj = DataFrame(obj)\n\n        # lists of regexes and values\n        # list of [v1, v2, ..., vN] -> [v1, v2, ..., vN]\n        to_replace_res = [r\".\", r\"e\"]\n        values = [np.nan, \"crap\"]\n        res = dfobj.replace(to_replace_res, values)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", np.nan, np.nan],\n                \"b\": [\"crap\", \"f\", \"g\", \"h\"],\n                \"c\": [\"h\", \"crap\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)\n\n        # list of [v1, v2, ..., vN] -> [v1, v2, .., vN]\n        to_replace_res = [r\".\", r\"f\"]\n        values = [r\"..\", r\"crap\"]\n        res = dfobj.replace(to_replace_res, values)\n        expec = DataFrame(\n            {\n                \"a\": [\"a\", \"b\", \"..\", \"..\"],\n                \"b\": [\"e\", \"crap\", \"g\", \"h\"],\n                \"c\": [\"h\", \"e\", \"l\", \"o\"],\n            }\n        )\n        tm.assert_frame_equal(res, expec)",
        "begin_line": 612,
        "end_line": 641,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_with_empty_list#643",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_with_empty_list(self)",
        "snippet": "    def test_replace_with_empty_list(self):\n        # GH 21977\n        s = pd.Series([[\"a\", \"b\"], [], np.nan, [1]])\n        df = pd.DataFrame({\"col\": s})\n        expected = df\n        result = df.replace([], np.nan)\n        tm.assert_frame_equal(result, expected)\n\n        # GH 19266\n        with pytest.raises(ValueError, match=\"cannot assign mismatch\"):\n            df.replace({np.nan: []})\n        with pytest.raises(ValueError, match=\"cannot assign mismatch\"):\n            df.replace({np.nan: [\"dummy\", \"alt\"]})",
        "begin_line": 643,
        "end_line": 655,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_series_dict#657",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_series_dict(self)",
        "snippet": "    def test_replace_series_dict(self):\n        # from GH 3064\n        df = DataFrame({\"zero\": {\"a\": 0.0, \"b\": 1}, \"one\": {\"a\": 2.0, \"b\": 0}})\n        result = df.replace(0, {\"zero\": 0.5, \"one\": 1.0})\n        expected = DataFrame({\"zero\": {\"a\": 0.5, \"b\": 1}, \"one\": {\"a\": 2.0, \"b\": 1.0}})\n        tm.assert_frame_equal(result, expected)\n\n        result = df.replace(0, df.mean())\n        tm.assert_frame_equal(result, expected)\n\n        # series to series/dict\n        df = DataFrame({\"zero\": {\"a\": 0.0, \"b\": 1}, \"one\": {\"a\": 2.0, \"b\": 0}})\n        s = Series({\"zero\": 0.0, \"one\": 2.0})\n        result = df.replace(s, {\"zero\": 0.5, \"one\": 1.0})\n        expected = DataFrame({\"zero\": {\"a\": 0.5, \"b\": 1}, \"one\": {\"a\": 1.0, \"b\": 0.0}})\n        tm.assert_frame_equal(result, expected)\n\n        result = df.replace(s, df.mean())\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 657,
        "end_line": 675,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_convert#677",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_convert(self)",
        "snippet": "    def test_replace_convert(self):\n        # gh 3907\n        df = DataFrame([[\"foo\", \"bar\", \"bah\"], [\"bar\", \"foo\", \"bah\"]])\n        m = {\"foo\": 1, \"bar\": 2, \"bah\": 3}\n        rep = df.replace(m)\n        expec = Series([np.int64] * 3)\n        res = rep.dtypes\n        tm.assert_series_equal(expec, res)",
        "begin_line": 677,
        "end_line": 684,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_mixed#686",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_mixed(self, float_string_frame)",
        "snippet": "    def test_replace_mixed(self, float_string_frame):\n        mf = float_string_frame\n        mf.iloc[5:20, mf.columns.get_loc(\"foo\")] = np.nan\n        mf.iloc[-10:, mf.columns.get_loc(\"A\")] = np.nan\n\n        result = float_string_frame.replace(np.nan, -18)\n        expected = float_string_frame.fillna(value=-18)\n        tm.assert_frame_equal(result, expected)\n        tm.assert_frame_equal(result.replace(-18, np.nan), float_string_frame)\n\n        result = float_string_frame.replace(np.nan, -1e8)\n        expected = float_string_frame.fillna(value=-1e8)\n        tm.assert_frame_equal(result, expected)\n        tm.assert_frame_equal(result.replace(-1e8, np.nan), float_string_frame)\n\n        # int block upcasting\n        df = DataFrame(\n            {\n                \"A\": Series([1.0, 2.0], dtype=\"float64\"),\n                \"B\": Series([0, 1], dtype=\"int64\"),\n            }\n        )\n        expected = DataFrame(\n            {\n                \"A\": Series([1.0, 2.0], dtype=\"float64\"),\n                \"B\": Series([0.5, 1], dtype=\"float64\"),\n            }\n        )\n        result = df.replace(0, 0.5)\n        tm.assert_frame_equal(result, expected)\n\n        df.replace(0, 0.5, inplace=True)\n        tm.assert_frame_equal(df, expected)\n\n        # int block splitting\n        df = DataFrame(\n            {\n                \"A\": Series([1.0, 2.0], dtype=\"float64\"),\n                \"B\": Series([0, 1], dtype=\"int64\"),\n                \"C\": Series([1, 2], dtype=\"int64\"),\n            }\n        )\n        expected = DataFrame(\n            {\n                \"A\": Series([1.0, 2.0], dtype=\"float64\"),\n                \"B\": Series([0.5, 1], dtype=\"float64\"),\n                \"C\": Series([1, 2], dtype=\"int64\"),\n            }\n        )\n        result = df.replace(0, 0.5)\n        tm.assert_frame_equal(result, expected)\n\n        # to object block upcasting\n        df = DataFrame(\n            {\n                \"A\": Series([1.0, 2.0], dtype=\"float64\"),\n                \"B\": Series([0, 1], dtype=\"int64\"),\n            }\n        )\n        expected = DataFrame(\n            {\n                \"A\": Series([1, \"foo\"], dtype=\"object\"),\n                \"B\": Series([0, 1], dtype=\"int64\"),\n            }\n        )\n        result = df.replace(2, \"foo\")\n        tm.assert_frame_equal(result, expected)\n\n        expected = DataFrame(\n            {\n                \"A\": Series([\"foo\", \"bar\"], dtype=\"object\"),\n                \"B\": Series([0, \"foo\"], dtype=\"object\"),\n            }\n        )\n        result = df.replace([1, 2], [\"foo\", \"bar\"])\n        tm.assert_frame_equal(result, expected)\n\n        # test case from\n        df = DataFrame(\n            {\"A\": Series([3, 0], dtype=\"int64\"), \"B\": Series([0, 3], dtype=\"int64\")}\n        )\n        result = df.replace(3, df.mean().to_dict())\n        expected = df.copy().astype(\"float64\")\n        m = df.mean()\n        expected.iloc[0, 0] = m[0]\n        expected.iloc[1, 1] = m[1]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 686,
        "end_line": 772,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_simple_nested_dict#774",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_simple_nested_dict(self)",
        "snippet": "    def test_replace_simple_nested_dict(self):\n        df = DataFrame({\"col\": range(1, 5)})\n        expected = DataFrame({\"col\": [\"a\", 2, 3, \"b\"]})\n\n        result = df.replace({\"col\": {1: \"a\", 4: \"b\"}})\n        tm.assert_frame_equal(expected, result)\n\n        # in this case, should be the same as the not nested version\n        result = df.replace({1: \"a\", 4: \"b\"})\n        tm.assert_frame_equal(expected, result)",
        "begin_line": 774,
        "end_line": 783,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_simple_nested_dict_with_nonexistent_value#785",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_simple_nested_dict_with_nonexistent_value(self)",
        "snippet": "    def test_replace_simple_nested_dict_with_nonexistent_value(self):\n        df = DataFrame({\"col\": range(1, 5)})\n        expected = DataFrame({\"col\": [\"a\", 2, 3, \"b\"]})\n\n        result = df.replace({-1: \"-\", 1: \"a\", 4: \"b\"})\n        tm.assert_frame_equal(expected, result)\n\n        result = df.replace({\"col\": {-1: \"-\", 1: \"a\", 4: \"b\"}})\n        tm.assert_frame_equal(expected, result)",
        "begin_line": 785,
        "end_line": 793,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_value_is_none#795",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_value_is_none(self, datetime_frame)",
        "snippet": "    def test_replace_value_is_none(self, datetime_frame):\n        orig_value = datetime_frame.iloc[0, 0]\n        orig2 = datetime_frame.iloc[1, 0]\n\n        datetime_frame.iloc[0, 0] = np.nan\n        datetime_frame.iloc[1, 0] = 1\n\n        result = datetime_frame.replace(to_replace={np.nan: 0})\n        expected = datetime_frame.T.replace(to_replace={np.nan: 0}).T\n        tm.assert_frame_equal(result, expected)\n\n        result = datetime_frame.replace(to_replace={np.nan: 0, 1: -1e8})\n        tsframe = datetime_frame.copy()\n        tsframe.iloc[0, 0] = 0\n        tsframe.iloc[1, 0] = -1e8\n        expected = tsframe\n        tm.assert_frame_equal(expected, result)\n        datetime_frame.iloc[0, 0] = orig_value\n        datetime_frame.iloc[1, 0] = orig2",
        "begin_line": 795,
        "end_line": 813,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_for_new_dtypes#815",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_for_new_dtypes(self, datetime_frame)",
        "snippet": "    def test_replace_for_new_dtypes(self, datetime_frame):\n\n        # dtypes\n        tsframe = datetime_frame.copy().astype(np.float32)\n        tsframe[\"A\"][:5] = np.nan\n        tsframe[\"A\"][-5:] = np.nan\n\n        zero_filled = tsframe.replace(np.nan, -1e8)\n        tm.assert_frame_equal(zero_filled, tsframe.fillna(-1e8))\n        tm.assert_frame_equal(zero_filled.replace(-1e8, np.nan), tsframe)\n\n        tsframe[\"A\"][:5] = np.nan\n        tsframe[\"A\"][-5:] = np.nan\n        tsframe[\"B\"][:5] = -1e8\n\n        b = tsframe[\"B\"]\n        b[b == -1e8] = np.nan\n        tsframe[\"B\"] = b\n        result = tsframe.fillna(method=\"bfill\")\n        tm.assert_frame_equal(result, tsframe.fillna(method=\"bfill\"))",
        "begin_line": 815,
        "end_line": 834,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_dtypes#909",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_dtypes(self, frame, to_replace, value, expected)",
        "snippet": "    def test_replace_dtypes(self, frame, to_replace, value, expected):\n        result = getattr(frame, \"replace\")(to_replace, value)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 909,
        "end_line": 911,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_input_formats_listlike#913",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_input_formats_listlike(self)",
        "snippet": "    def test_replace_input_formats_listlike(self):\n        # both dicts\n        to_rep = {\"A\": np.nan, \"B\": 0, \"C\": \"\"}\n        values = {\"A\": 0, \"B\": -1, \"C\": \"missing\"}\n        df = DataFrame(\n            {\"A\": [np.nan, 0, np.inf], \"B\": [0, 2, 5], \"C\": [\"\", \"asdf\", \"fd\"]}\n        )\n        filled = df.replace(to_rep, values)\n        expected = {k: v.replace(to_rep[k], values[k]) for k, v in df.items()}\n        tm.assert_frame_equal(filled, DataFrame(expected))\n\n        result = df.replace([0, 2, 5], [5, 2, 0])\n        expected = DataFrame(\n            {\"A\": [np.nan, 5, np.inf], \"B\": [5, 2, 0], \"C\": [\"\", \"asdf\", \"fd\"]}\n        )\n        tm.assert_frame_equal(result, expected)\n\n        # scalar to dict\n        values = {\"A\": 0, \"B\": -1, \"C\": \"missing\"}\n        df = DataFrame(\n            {\"A\": [np.nan, 0, np.nan], \"B\": [0, 2, 5], \"C\": [\"\", \"asdf\", \"fd\"]}\n        )\n        filled = df.replace(np.nan, values)\n        expected = {k: v.replace(np.nan, values[k]) for k, v in df.items()}\n        tm.assert_frame_equal(filled, DataFrame(expected))\n\n        # list to list\n        to_rep = [np.nan, 0, \"\"]\n        values = [-2, -1, \"missing\"]\n        result = df.replace(to_rep, values)\n        expected = df.copy()\n        for i in range(len(to_rep)):\n            expected.replace(to_rep[i], values[i], inplace=True)\n        tm.assert_frame_equal(result, expected)\n\n        msg = r\"Replacement lists must match in length\\. Expecting 3 got 2\"\n        with pytest.raises(ValueError, match=msg):\n            df.replace(to_rep, values[1:])",
        "begin_line": 913,
        "end_line": 950,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_input_formats_scalar#952",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_input_formats_scalar(self)",
        "snippet": "    def test_replace_input_formats_scalar(self):\n        df = DataFrame(\n            {\"A\": [np.nan, 0, np.inf], \"B\": [0, 2, 5], \"C\": [\"\", \"asdf\", \"fd\"]}\n        )\n\n        # dict to scalar\n        to_rep = {\"A\": np.nan, \"B\": 0, \"C\": \"\"}\n        filled = df.replace(to_rep, 0)\n        expected = {k: v.replace(to_rep[k], 0) for k, v in df.items()}\n        tm.assert_frame_equal(filled, DataFrame(expected))\n\n        msg = \"value argument must be scalar, dict, or Series\"\n        with pytest.raises(TypeError, match=msg):\n            df.replace(to_rep, [np.nan, 0, \"\"])\n\n        # list to scalar\n        to_rep = [np.nan, 0, \"\"]\n        result = df.replace(to_rep, -1)\n        expected = df.copy()\n        for i in range(len(to_rep)):\n            expected.replace(to_rep[i], -1, inplace=True)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 952,
        "end_line": 973,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_limit#975",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_limit(self)",
        "snippet": "    def test_replace_limit(self):\n        pass",
        "begin_line": 975,
        "end_line": 976,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_dict_no_regex#978",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_dict_no_regex(self)",
        "snippet": "    def test_replace_dict_no_regex(self):\n        answer = Series(\n            {\n                0: \"Strongly Agree\",\n                1: \"Agree\",\n                2: \"Neutral\",\n                3: \"Disagree\",\n                4: \"Strongly Disagree\",\n            }\n        )\n        weights = {\n            \"Agree\": 4,\n            \"Disagree\": 2,\n            \"Neutral\": 3,\n            \"Strongly Agree\": 5,\n            \"Strongly Disagree\": 1,\n        }\n        expected = Series({0: 5, 1: 4, 2: 3, 3: 2, 4: 1})\n        result = answer.replace(weights)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 978,
        "end_line": 997,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_series_no_regex#999",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_series_no_regex(self)",
        "snippet": "    def test_replace_series_no_regex(self):\n        answer = Series(\n            {\n                0: \"Strongly Agree\",\n                1: \"Agree\",\n                2: \"Neutral\",\n                3: \"Disagree\",\n                4: \"Strongly Disagree\",\n            }\n        )\n        weights = Series(\n            {\n                \"Agree\": 4,\n                \"Disagree\": 2,\n                \"Neutral\": 3,\n                \"Strongly Agree\": 5,\n                \"Strongly Disagree\": 1,\n            }\n        )\n        expected = Series({0: 5, 1: 4, 2: 3, 3: 2, 4: 1})\n        result = answer.replace(weights)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 999,
        "end_line": 1020,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_dict_tuple_list_ordering_remains_the_same#1022",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_dict_tuple_list_ordering_remains_the_same(self)",
        "snippet": "    def test_replace_dict_tuple_list_ordering_remains_the_same(self):\n        df = DataFrame(dict(A=[np.nan, 1]))\n        res1 = df.replace(to_replace={np.nan: 0, 1: -1e8})\n        res2 = df.replace(to_replace=(1, np.nan), value=[-1e8, 0])\n        res3 = df.replace(to_replace=[1, np.nan], value=[-1e8, 0])\n\n        expected = DataFrame({\"A\": [0, -1e8]})\n        tm.assert_frame_equal(res1, res2)\n        tm.assert_frame_equal(res2, res3)\n        tm.assert_frame_equal(res3, expected)",
        "begin_line": 1022,
        "end_line": 1031,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_doesnt_replace_without_regex#1033",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_doesnt_replace_without_regex(self)",
        "snippet": "    def test_replace_doesnt_replace_without_regex(self):\n        raw = \"\"\"fol T_opp T_Dir T_Enh\n        0    1     0     0    vo\n        1    2    vr     0     0\n        2    2     0     0     0\n        3    3     0    bt     0\"\"\"\n        df = pd.read_csv(StringIO(raw), sep=r\"\\s+\")\n        res = df.replace({r\"\\D\": 1})\n        tm.assert_frame_equal(df, res)",
        "begin_line": 1033,
        "end_line": 1041,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_bool_with_string#1043",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_bool_with_string(self)",
        "snippet": "    def test_replace_bool_with_string(self):\n        df = DataFrame({\"a\": [True, False], \"b\": list(\"ab\")})\n        result = df.replace(True, \"a\")\n        expected = DataFrame({\"a\": [\"a\", False], \"b\": df.b})\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1043,
        "end_line": 1047,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_pure_bool_with_string_no_op#1049",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_pure_bool_with_string_no_op(self)",
        "snippet": "    def test_replace_pure_bool_with_string_no_op(self):\n        df = DataFrame(np.random.rand(2, 2) > 0.5)\n        result = df.replace(\"asdf\", \"fdsa\")\n        tm.assert_frame_equal(df, result)",
        "begin_line": 1049,
        "end_line": 1052,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_bool_with_bool#1054",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_bool_with_bool(self)",
        "snippet": "    def test_replace_bool_with_bool(self):\n        df = DataFrame(np.random.rand(2, 2) > 0.5)\n        result = df.replace(False, True)\n        expected = DataFrame(np.ones((2, 2), dtype=bool))\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1054,
        "end_line": 1058,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_with_dict_with_bool_keys#1060",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_with_dict_with_bool_keys(self)",
        "snippet": "    def test_replace_with_dict_with_bool_keys(self):\n        df = DataFrame({0: [True, False], 1: [False, True]})\n        with pytest.raises(TypeError, match=\"Cannot compare types .+\"):\n            df.replace({\"asdf\": \"asdb\", True: \"yes\"})",
        "begin_line": 1060,
        "end_line": 1063,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_truthy#1065",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_truthy(self)",
        "snippet": "    def test_replace_truthy(self):\n        df = DataFrame({\"a\": [True, True]})\n        r = df.replace([np.inf, -np.inf], np.nan)\n        e = df\n        tm.assert_frame_equal(r, e)",
        "begin_line": 1065,
        "end_line": 1069,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_nested_dict_overlapping_keys_replace_int#1071",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_nested_dict_overlapping_keys_replace_int(self)",
        "snippet": "    def test_nested_dict_overlapping_keys_replace_int(self):\n        # GH 27660 keep behaviour consistent for simple dictionary and\n        # nested dictionary replacement\n        df = DataFrame({\"a\": list(range(1, 5))})\n\n        result = df.replace({\"a\": dict(zip(range(1, 5), range(2, 6)))})\n        expected = df.replace(dict(zip(range(1, 5), range(2, 6))))\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1071,
        "end_line": 1078,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_nested_dict_overlapping_keys_replace_str#1080",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_nested_dict_overlapping_keys_replace_str(self)",
        "snippet": "    def test_nested_dict_overlapping_keys_replace_str(self):\n        # GH 27660\n        a = np.arange(1, 5)\n        astr = a.astype(str)\n        bstr = np.arange(2, 6).astype(str)\n        df = DataFrame({\"a\": astr})\n        result = df.replace(dict(zip(astr, bstr)))\n        expected = df.replace({\"a\": dict(zip(astr, bstr))})\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1080,
        "end_line": 1088,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_swapping_bug#1090",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_swapping_bug(self)",
        "snippet": "    def test_replace_swapping_bug(self):\n        df = pd.DataFrame({\"a\": [True, False, True]})\n        res = df.replace({\"a\": {True: \"Y\", False: \"N\"}})\n        expect = pd.DataFrame({\"a\": [\"Y\", \"N\", \"Y\"]})\n        tm.assert_frame_equal(res, expect)\n\n        df = pd.DataFrame({\"a\": [0, 1, 0]})\n        res = df.replace({\"a\": {0: \"Y\", 1: \"N\"}})\n        expect = pd.DataFrame({\"a\": [\"Y\", \"N\", \"Y\"]})\n        tm.assert_frame_equal(res, expect)",
        "begin_line": 1090,
        "end_line": 1099,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_period#1101",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_period(self)",
        "snippet": "    def test_replace_period(self):\n        d = {\n            \"fname\": {\n                \"out_augmented_AUG_2011.json\": pd.Period(year=2011, month=8, freq=\"M\"),\n                \"out_augmented_JAN_2011.json\": pd.Period(year=2011, month=1, freq=\"M\"),\n                \"out_augmented_MAY_2012.json\": pd.Period(year=2012, month=5, freq=\"M\"),\n                \"out_augmented_SUBSIDY_WEEK.json\": pd.Period(\n                    year=2011, month=4, freq=\"M\"\n                ),\n                \"out_augmented_AUG_2012.json\": pd.Period(year=2012, month=8, freq=\"M\"),\n                \"out_augmented_MAY_2011.json\": pd.Period(year=2011, month=5, freq=\"M\"),\n                \"out_augmented_SEP_2013.json\": pd.Period(year=2013, month=9, freq=\"M\"),\n            }\n        }\n\n        df = pd.DataFrame(\n            [\n                \"out_augmented_AUG_2012.json\",\n                \"out_augmented_SEP_2013.json\",\n                \"out_augmented_SUBSIDY_WEEK.json\",\n                \"out_augmented_MAY_2012.json\",\n                \"out_augmented_MAY_2011.json\",\n                \"out_augmented_AUG_2011.json\",\n                \"out_augmented_JAN_2011.json\",\n            ],\n            columns=[\"fname\"],\n        )\n        assert set(df.fname.values) == set(d[\"fname\"].keys())\n        # We don't support converting object -> specialized EA in\n        # replace yet.\n        expected = DataFrame(\n            {\"fname\": [d[\"fname\"][k] for k in df.fname.values]}, dtype=object\n        )\n        result = df.replace(d)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1101,
        "end_line": 1135,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_datetime#1137",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_datetime(self)",
        "snippet": "    def test_replace_datetime(self):\n        d = {\n            \"fname\": {\n                \"out_augmented_AUG_2011.json\": pd.Timestamp(\"2011-08\"),\n                \"out_augmented_JAN_2011.json\": pd.Timestamp(\"2011-01\"),\n                \"out_augmented_MAY_2012.json\": pd.Timestamp(\"2012-05\"),\n                \"out_augmented_SUBSIDY_WEEK.json\": pd.Timestamp(\"2011-04\"),\n                \"out_augmented_AUG_2012.json\": pd.Timestamp(\"2012-08\"),\n                \"out_augmented_MAY_2011.json\": pd.Timestamp(\"2011-05\"),\n                \"out_augmented_SEP_2013.json\": pd.Timestamp(\"2013-09\"),\n            }\n        }\n\n        df = pd.DataFrame(\n            [\n                \"out_augmented_AUG_2012.json\",\n                \"out_augmented_SEP_2013.json\",\n                \"out_augmented_SUBSIDY_WEEK.json\",\n                \"out_augmented_MAY_2012.json\",\n                \"out_augmented_MAY_2011.json\",\n                \"out_augmented_AUG_2011.json\",\n                \"out_augmented_JAN_2011.json\",\n            ],\n            columns=[\"fname\"],\n        )\n        assert set(df.fname.values) == set(d[\"fname\"].keys())\n        expected = DataFrame({\"fname\": [d[\"fname\"][k] for k in df.fname.values]})\n        result = df.replace(d)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1137,
        "end_line": 1165,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_datetimetz#1167",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_datetimetz(self)",
        "snippet": "    def test_replace_datetimetz(self):\n\n        # GH 11326\n        # behaving poorly when presented with a datetime64[ns, tz]\n        df = DataFrame(\n            {\n                \"A\": date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n                \"B\": [0, np.nan, 2],\n            }\n        )\n        result = df.replace(np.nan, 1)\n        expected = DataFrame(\n            {\n                \"A\": date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n                \"B\": Series([0, 1, 2], dtype=\"float64\"),\n            }\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.fillna(1)\n        tm.assert_frame_equal(result, expected)\n\n        result = df.replace(0, np.nan)\n        expected = DataFrame(\n            {\n                \"A\": date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n                \"B\": [np.nan, np.nan, 2],\n            }\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.replace(\n            Timestamp(\"20130102\", tz=\"US/Eastern\"),\n            Timestamp(\"20130104\", tz=\"US/Eastern\"),\n        )\n        expected = DataFrame(\n            {\n                \"A\": [\n                    Timestamp(\"20130101\", tz=\"US/Eastern\"),\n                    Timestamp(\"20130104\", tz=\"US/Eastern\"),\n                    Timestamp(\"20130103\", tz=\"US/Eastern\"),\n                ],\n                \"B\": [0, np.nan, 2],\n            }\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.iloc[1, 0] = np.nan\n        result = result.replace({\"A\": pd.NaT}, Timestamp(\"20130104\", tz=\"US/Eastern\"))\n        tm.assert_frame_equal(result, expected)\n\n        # coerce to object\n        result = df.copy()\n        result.iloc[1, 0] = np.nan\n        result = result.replace({\"A\": pd.NaT}, Timestamp(\"20130104\", tz=\"US/Pacific\"))\n        expected = DataFrame(\n            {\n                \"A\": [\n                    Timestamp(\"20130101\", tz=\"US/Eastern\"),\n                    Timestamp(\"20130104\", tz=\"US/Pacific\"),\n                    Timestamp(\"20130103\", tz=\"US/Eastern\"),\n                ],\n                \"B\": [0, np.nan, 2],\n            }\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = df.copy()\n        result.iloc[1, 0] = np.nan\n        result = result.replace({\"A\": np.nan}, Timestamp(\"20130104\"))\n        expected = DataFrame(\n            {\n                \"A\": [\n                    Timestamp(\"20130101\", tz=\"US/Eastern\"),\n                    Timestamp(\"20130104\"),\n                    Timestamp(\"20130103\", tz=\"US/Eastern\"),\n                ],\n                \"B\": [0, np.nan, 2],\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1167,
        "end_line": 1248,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_with_empty_dictlike#1250",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_with_empty_dictlike(self, mix_abc)",
        "snippet": "    def test_replace_with_empty_dictlike(self, mix_abc):\n        # GH 15289\n        df = DataFrame(mix_abc)\n        tm.assert_frame_equal(df, df.replace({}))\n        tm.assert_frame_equal(df, df.replace(Series([])))\n\n        tm.assert_frame_equal(df, df.replace({\"b\": {}}))\n        tm.assert_frame_equal(df, df.replace(Series({\"b\": {}})))",
        "begin_line": 1250,
        "end_line": 1257,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_method#1291",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_method(self, to_replace, method, expected)",
        "snippet": "    def test_replace_method(self, to_replace, method, expected):\n        # GH 19632\n        df = DataFrame({\"A\": [0, 1, 2], \"B\": [5, np.nan, 7], \"C\": [\"a\", \"b\", \"c\"]})\n\n        result = df.replace(to_replace=to_replace, value=None, method=method)\n        expected = DataFrame(expected)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1291,
        "end_line": 1297,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_categorical_replace_with_dict#1303",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_categorical_replace_with_dict(self, replace_dict, final_data)",
        "snippet": "    def test_categorical_replace_with_dict(self, replace_dict, final_data):\n        # GH 26988\n        df = DataFrame([[1, 1], [2, 2]], columns=[\"a\", \"b\"], dtype=\"category\")\n        expected = DataFrame(final_data, columns=[\"a\", \"b\"], dtype=\"category\")\n        expected[\"a\"] = expected[\"a\"].cat.set_categories([1, 2, 3])\n        expected[\"b\"] = expected[\"b\"].cat.set_categories([1, 2, 3])\n        result = df.replace(replace_dict, 3)\n        tm.assert_frame_equal(result, expected)\n        with pytest.raises(AssertionError):\n            # ensure non-inplace call does not affect original\n            tm.assert_frame_equal(df, expected)\n        df.replace(replace_dict, 3, inplace=True)\n        tm.assert_frame_equal(df, expected)",
        "begin_line": 1303,
        "end_line": 1315,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_commutative#1332",
        "src_path": "pandas/tests/frame/test_replace.py",
        "class_name": "pandas.tests.frame.test_replace.TestDataFrameReplace",
        "signature": "pandas.tests.frame.test_replace.TestDataFrameReplace.test_replace_commutative(self, df, to_replace, exp)",
        "snippet": "    def test_replace_commutative(self, df, to_replace, exp):\n        # GH 16051\n        # DataFrame.replace() overwrites when values are non-numeric\n        # also added to data frame whilst issue was for series\n\n        df = pd.DataFrame(df)\n\n        expected = pd.DataFrame(exp)\n        result = df.replace(to_replace)\n\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1332,
        "end_line": 1342,
        "comment": "",
        "is_bug": false
    }
]