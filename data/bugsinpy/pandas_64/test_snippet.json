[
    {
        "name": "pandas.tests.io.excel.conftest.frame#11",
        "src_path": "pandas/tests/io/excel/conftest.py",
        "class_name": "pandas.tests.io.excel.conftest",
        "signature": "pandas.tests.io.excel.conftest.frame(float_frame)",
        "snippet": "def frame(float_frame):\n    \"\"\"\n    Returns the first ten items in fixture \"float_frame\".\n    \"\"\"\n    return float_frame[:10]",
        "begin_line": 11,
        "end_line": 15,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.conftest.tsframe#19",
        "src_path": "pandas/tests/io/excel/conftest.py",
        "class_name": "pandas.tests.io.excel.conftest",
        "signature": "pandas.tests.io.excel.conftest.tsframe()",
        "snippet": "def tsframe():\n    return tm.makeTimeDataFrame()[:5]",
        "begin_line": 19,
        "end_line": 20,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.conftest.merge_cells#24",
        "src_path": "pandas/tests/io/excel/conftest.py",
        "class_name": "pandas.tests.io.excel.conftest",
        "signature": "pandas.tests.io.excel.conftest.merge_cells(request)",
        "snippet": "def merge_cells(request):\n    return request.param",
        "begin_line": 24,
        "end_line": 25,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.conftest.df_ref#29",
        "src_path": "pandas/tests/io/excel/conftest.py",
        "class_name": "pandas.tests.io.excel.conftest",
        "signature": "pandas.tests.io.excel.conftest.df_ref(datapath)",
        "snippet": "def df_ref(datapath):\n    \"\"\"\n    Obtain the reference data from read_csv with the Python engine.\n    \"\"\"\n    filepath = datapath(\"io\", \"data\", \"csv\", \"test1.csv\")\n    df_ref = read_csv(filepath, index_col=0, parse_dates=True, engine=\"python\")\n    return df_ref",
        "begin_line": 29,
        "end_line": 35,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.conftest.read_ext#39",
        "src_path": "pandas/tests/io/excel/conftest.py",
        "class_name": "pandas.tests.io.excel.conftest",
        "signature": "pandas.tests.io.excel.conftest.read_ext(request)",
        "snippet": "def read_ext(request):\n    \"\"\"\n    Valid extensions for reading Excel files.\n    \"\"\"\n    return request.param",
        "begin_line": 39,
        "end_line": 43,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.conftest.check_for_file_leaks#47",
        "src_path": "pandas/tests/io/excel/conftest.py",
        "class_name": "pandas.tests.io.excel.conftest",
        "signature": "pandas.tests.io.excel.conftest.check_for_file_leaks()",
        "snippet": "def check_for_file_leaks():\n    \"\"\"\n    Fixture to run around every test to ensure that we are not leaking files.\n\n    See also\n    --------\n    _test_decorators.check_file_leaks\n    \"\"\"\n    # GH#30162\n    psutil = td.safe_import(\"psutil\")\n    if not psutil:\n        yield\n\n    else:\n        proc = psutil.Process()\n        flist = proc.open_files()\n        yield\n        flist2 = proc.open_files()\n        assert flist == flist2",
        "begin_line": 47,
        "end_line": 65,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.pytables.conftest.setup_mode#13",
        "src_path": "pandas/tests/io/pytables/conftest.py",
        "class_name": "pandas.tests.io.pytables.conftest",
        "signature": "pandas.tests.io.pytables.conftest.setup_mode()",
        "snippet": "def setup_mode():\n    \"\"\" Reset testing mode fixture\"\"\"\n    tm.reset_testing_mode()\n    yield\n    tm.set_testing_mode()",
        "begin_line": 13,
        "end_line": 17,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.conftest.salaries_table#23",
        "src_path": "pandas/tests/io/conftest.py",
        "class_name": "pandas.tests.io.conftest",
        "signature": "pandas.tests.io.conftest.salaries_table(datapath)",
        "snippet": "def salaries_table(datapath):\n    \"\"\"DataFrame with the salaries dataset\"\"\"\n    return read_csv(datapath(\"io\", \"parser\", \"data\", \"salaries.csv\"), sep=\"\\t\")",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.BaseParser.update_kwargs#14",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest.BaseParser",
        "signature": "pandas.tests.io.parser.conftest.BaseParser.update_kwargs(self, kwargs)",
        "snippet": "    def update_kwargs(self, kwargs):\n        kwargs = kwargs.copy()\n        kwargs.update(dict(engine=self.engine, low_memory=self.low_memory))\n\n        return kwargs",
        "begin_line": 14,
        "end_line": 18,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.BaseParser.read_csv#20",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest.BaseParser",
        "signature": "pandas.tests.io.parser.conftest.BaseParser.read_csv(self, *args, **kwargs)",
        "snippet": "    def read_csv(self, *args, **kwargs):\n        kwargs = self.update_kwargs(kwargs)\n        return read_csv(*args, **kwargs)",
        "begin_line": 20,
        "end_line": 22,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.BaseParser.read_table#24",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest.BaseParser",
        "signature": "pandas.tests.io.parser.conftest.BaseParser.read_table(self, *args, **kwargs)",
        "snippet": "    def read_table(self, *args, **kwargs):\n        kwargs = self.update_kwargs(kwargs)\n        return read_table(*args, **kwargs)",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.csv_dir_path#48",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.csv_dir_path(datapath)",
        "snippet": "def csv_dir_path(datapath):\n    \"\"\"\n    The directory path to the data files needed for parser tests.\n    \"\"\"\n    return datapath(\"io\", \"parser\", \"data\")",
        "begin_line": 48,
        "end_line": 52,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.csv1#56",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.csv1(csv_dir_path)",
        "snippet": "def csv1(csv_dir_path):\n    \"\"\"\n    The path to the data file \"test1.csv\" needed for parser tests.\n    \"\"\"\n    return os.path.join(csv_dir_path, \"test1.csv\")",
        "begin_line": 56,
        "end_line": 60,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.all_parsers#77",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.all_parsers(request)",
        "snippet": "def all_parsers(request):\n    \"\"\"\n    Fixture all of the CSV parsers.\n    \"\"\"\n    return request.param",
        "begin_line": 77,
        "end_line": 81,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.c_parser_only#85",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.c_parser_only(request)",
        "snippet": "def c_parser_only(request):\n    \"\"\"\n    Fixture all of the CSV parsers using the C engine.\n    \"\"\"\n    return request.param",
        "begin_line": 85,
        "end_line": 89,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.python_parser_only#93",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.python_parser_only(request)",
        "snippet": "def python_parser_only(request):\n    \"\"\"\n    Fixture all of the CSV parsers using the Python engine.\n    \"\"\"\n    return request.param",
        "begin_line": 93,
        "end_line": 97,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.utf_value#111",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.utf_value(request)",
        "snippet": "def utf_value(request):\n    \"\"\"\n    Fixture for all possible integer values for a UTF encoding.\n    \"\"\"\n    return request.param",
        "begin_line": 111,
        "end_line": 115,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.encoding_fmt#119",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.encoding_fmt(request)",
        "snippet": "def encoding_fmt(request):\n    \"\"\"\n    Fixture for all possible string formats of a UTF encoding.\n    \"\"\"\n    return request.param",
        "begin_line": 119,
        "end_line": 123,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.path#26",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers",
        "signature": "pandas.tests.io.excel.test_writers.path(ext)",
        "snippet": "def path(ext):\n    \"\"\"\n    Fixture to open file for use in each test case.\n    \"\"\"\n    with tm.ensure_clean(ext) as file_path:\n        yield file_path",
        "begin_line": 26,
        "end_line": 31,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.set_engine#35",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers",
        "signature": "pandas.tests.io.excel.test_writers.set_engine(engine, ext)",
        "snippet": "def set_engine(engine, ext):\n    \"\"\"\n    Fixture to set engine for use in each test case.\n\n    Rather than requiring `engine=...` to be provided explicitly as an\n    argument in each test, this fixture sets a global option to dictate\n    which engine should be used to write Excel files. After executing\n    the test it rolls back said change to the global option.\n    \"\"\"\n    option_name = \"io.excel.{ext}.writer\".format(ext=ext.strip(\".\"))\n    prev_engine = get_option(option_name)\n    set_option(option_name, engine)\n    yield\n    set_option(option_name, prev_engine)  # Roll back option change",
        "begin_line": 35,
        "end_line": 48,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestRoundTrip.test_read_one_empty_col_no_header#60",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestRoundTrip",
        "signature": "pandas.tests.io.excel.test_writers.TestRoundTrip.test_read_one_empty_col_no_header(self, ext, header, expected)",
        "snippet": "    def test_read_one_empty_col_no_header(self, ext, header, expected):\n        # xref gh-12292\n        filename = \"no_header\"\n        df = pd.DataFrame([[\"\", 1, 100], [\"\", 2, 200], [\"\", 3, 300], [\"\", 4, 400]])\n\n        with tm.ensure_clean(ext) as path:\n            df.to_excel(path, filename, index=False, header=False)\n            result = pd.read_excel(path, filename, usecols=[0], header=header)\n\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 60,
        "end_line": 69,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestRoundTrip.test_read_one_empty_col_with_header#77",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestRoundTrip",
        "signature": "pandas.tests.io.excel.test_writers.TestRoundTrip.test_read_one_empty_col_with_header(self, ext, header, expected)",
        "snippet": "    def test_read_one_empty_col_with_header(self, ext, header, expected):\n        filename = \"with_header\"\n        df = pd.DataFrame([[\"\", 1, 100], [\"\", 2, 200], [\"\", 3, 300], [\"\", 4, 400]])\n\n        with tm.ensure_clean(ext) as path:\n            df.to_excel(path, \"with_header\", index=False, header=True)\n            result = pd.read_excel(path, filename, usecols=[0], header=header)\n\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 77,
        "end_line": 85,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestRoundTrip.test_set_column_names_in_parameter#89",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestRoundTrip",
        "signature": "pandas.tests.io.excel.test_writers.TestRoundTrip.test_set_column_names_in_parameter(self, ext)",
        "snippet": "    def test_set_column_names_in_parameter(self, ext):\n        # GH 12870 : pass down column names associated with\n        # keyword argument names\n        refdf = pd.DataFrame([[1, \"foo\"], [2, \"bar\"], [3, \"baz\"]], columns=[\"a\", \"b\"])\n\n        with tm.ensure_clean(ext) as pth:\n            with ExcelWriter(pth) as writer:\n                refdf.to_excel(writer, \"Data_no_head\", header=False, index=False)\n                refdf.to_excel(writer, \"Data_with_head\", index=False)\n\n            refdf.columns = [\"A\", \"B\"]\n\n            with ExcelFile(pth) as reader:\n                xlsdf_no_head = pd.read_excel(\n                    reader, \"Data_no_head\", header=None, names=[\"A\", \"B\"]\n                )\n                xlsdf_with_head = pd.read_excel(\n                    reader, \"Data_with_head\", index_col=None, names=[\"A\", \"B\"]\n                )\n\n            tm.assert_frame_equal(xlsdf_no_head, refdf)\n            tm.assert_frame_equal(xlsdf_with_head, refdf)",
        "begin_line": 89,
        "end_line": 110,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestRoundTrip.test_creating_and_reading_multiple_sheets#114",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestRoundTrip",
        "signature": "pandas.tests.io.excel.test_writers.TestRoundTrip.test_creating_and_reading_multiple_sheets(self, ext)",
        "snippet": "    def test_creating_and_reading_multiple_sheets(self, ext):\n        # see gh-9450\n        #\n        # Test reading multiple sheets, from a runtime\n        # created Excel file with multiple sheets.\n        def tdf(col_sheet_name):\n            d, i = [11, 22, 33], [1, 2, 3]\n            return DataFrame(d, i, columns=[col_sheet_name])\n\n        sheets = [\"AAA\", \"BBB\", \"CCC\"]\n\n        dfs = [tdf(s) for s in sheets]\n        dfs = dict(zip(sheets, dfs))\n\n        with tm.ensure_clean(ext) as pth:\n            with ExcelWriter(pth) as ew:\n                for sheetname, df in dfs.items():\n                    df.to_excel(ew, sheetname)\n\n            dfs_returned = pd.read_excel(pth, sheet_name=sheets, index_col=0)\n\n            for s in sheets:\n                tm.assert_frame_equal(dfs[s], dfs_returned[s])",
        "begin_line": 114,
        "end_line": 136,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestRoundTrip.tdf#119",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestRoundTrip",
        "signature": "pandas.tests.io.excel.test_writers.TestRoundTrip.tdf(col_sheet_name)",
        "snippet": "        def tdf(col_sheet_name):\n            d, i = [11, 22, 33], [1, 2, 3]\n            return DataFrame(d, i, columns=[col_sheet_name])",
        "begin_line": 119,
        "end_line": 121,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestRoundTrip.test_read_excel_multiindex_empty_level#139",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestRoundTrip",
        "signature": "pandas.tests.io.excel.test_writers.TestRoundTrip.test_read_excel_multiindex_empty_level(self, ext)",
        "snippet": "    def test_read_excel_multiindex_empty_level(self, ext):\n        # see gh-12453\n        with tm.ensure_clean(ext) as path:\n            df = DataFrame(\n                {\n                    (\"One\", \"x\"): {0: 1},\n                    (\"Two\", \"X\"): {0: 3},\n                    (\"Two\", \"Y\"): {0: 7},\n                    (\"Zero\", \"\"): {0: 0},\n                }\n            )\n\n            expected = DataFrame(\n                {\n                    (\"One\", \"x\"): {0: 1},\n                    (\"Two\", \"X\"): {0: 3},\n                    (\"Two\", \"Y\"): {0: 7},\n                    (\"Zero\", \"Unnamed: 4_level_1\"): {0: 0},\n                }\n            )\n\n            df.to_excel(path)\n            actual = pd.read_excel(path, header=[0, 1], index_col=0)\n            tm.assert_frame_equal(actual, expected)\n\n            df = pd.DataFrame(\n                {\n                    (\"Beg\", \"\"): {0: 0},\n                    (\"Middle\", \"x\"): {0: 1},\n                    (\"Tail\", \"X\"): {0: 3},\n                    (\"Tail\", \"Y\"): {0: 7},\n                }\n            )\n\n            expected = pd.DataFrame(\n                {\n                    (\"Beg\", \"Unnamed: 1_level_1\"): {0: 0},\n                    (\"Middle\", \"x\"): {0: 1},\n                    (\"Tail\", \"X\"): {0: 3},\n                    (\"Tail\", \"Y\"): {0: 7},\n                }\n            )\n\n            df.to_excel(path)\n            actual = pd.read_excel(path, header=[0, 1], index_col=0)\n            tm.assert_frame_equal(actual, expected)",
        "begin_line": 139,
        "end_line": 184,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestRoundTrip.test_excel_multindex_roundtrip#191",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestRoundTrip",
        "signature": "pandas.tests.io.excel.test_writers.TestRoundTrip.test_excel_multindex_roundtrip(self, ext, c_idx_names, r_idx_names, c_idx_levels, r_idx_levels)",
        "snippet": "    def test_excel_multindex_roundtrip(\n        self, ext, c_idx_names, r_idx_names, c_idx_levels, r_idx_levels\n    ):\n        # see gh-4679\n        with tm.ensure_clean(ext) as pth:\n            if c_idx_levels == 1 and c_idx_names:\n                pytest.skip(\n                    \"Column index name cannot be serialized unless it's a MultiIndex\"\n                )\n\n            # Empty name case current read in as\n            # unnamed levels, not Nones.\n            check_names = r_idx_names or r_idx_levels <= 1\n\n            df = tm.makeCustomDataframe(\n                5, 5, c_idx_names, r_idx_names, c_idx_levels, r_idx_levels\n            )\n            df.to_excel(pth)\n\n            act = pd.read_excel(\n                pth,\n                index_col=list(range(r_idx_levels)),\n                header=list(range(c_idx_levels)),\n            )\n            tm.assert_frame_equal(df, act, check_names=check_names)\n\n            df.iloc[0, :] = np.nan\n            df.to_excel(pth)\n\n            act = pd.read_excel(\n                pth,\n                index_col=list(range(r_idx_levels)),\n                header=list(range(c_idx_levels)),\n            )\n            tm.assert_frame_equal(df, act, check_names=check_names)\n\n            df.iloc[-1, :] = np.nan\n            df.to_excel(pth)\n            act = pd.read_excel(\n                pth,\n                index_col=list(range(r_idx_levels)),\n                header=list(range(c_idx_levels)),\n            )\n            tm.assert_frame_equal(df, act, check_names=check_names)",
        "begin_line": 191,
        "end_line": 234,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestRoundTrip.test_read_excel_parse_dates#238",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestRoundTrip",
        "signature": "pandas.tests.io.excel.test_writers.TestRoundTrip.test_read_excel_parse_dates(self, ext)",
        "snippet": "    def test_read_excel_parse_dates(self, ext):\n        # see gh-11544, gh-12051\n        df = DataFrame(\n            {\"col\": [1, 2, 3], \"date_strings\": pd.date_range(\"2012-01-01\", periods=3)}\n        )\n        df2 = df.copy()\n        df2[\"date_strings\"] = df2[\"date_strings\"].dt.strftime(\"%m/%d/%Y\")\n\n        with tm.ensure_clean(ext) as pth:\n            df2.to_excel(pth)\n\n            res = pd.read_excel(pth, index_col=0)\n            tm.assert_frame_equal(df2, res)\n\n            res = pd.read_excel(pth, parse_dates=[\"date_strings\"], index_col=0)\n            tm.assert_frame_equal(df, res)\n\n            date_parser = lambda x: datetime.strptime(x, \"%m/%d/%Y\")\n            res = pd.read_excel(\n                pth, parse_dates=[\"date_strings\"], date_parser=date_parser, index_col=0\n            )\n            tm.assert_frame_equal(df, res)",
        "begin_line": 238,
        "end_line": 259,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestRoundTrip.test_multiindex_interval_datetimes#261",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestRoundTrip",
        "signature": "pandas.tests.io.excel.test_writers.TestRoundTrip.test_multiindex_interval_datetimes(self, ext)",
        "snippet": "    def test_multiindex_interval_datetimes(self, ext):\n        # GH 30986\n        midx = pd.MultiIndex.from_arrays(\n            [\n                range(4),\n                pd.interval_range(\n                    start=pd.Timestamp(\"2020-01-01\"), periods=4, freq=\"6M\"\n                ),\n            ]\n        )\n        df = pd.DataFrame(range(4), index=midx)\n        with tm.ensure_clean(ext) as pth:\n            df.to_excel(pth)\n            result = pd.read_excel(pth, index_col=[0, 1])\n        expected = pd.DataFrame(\n            range(4),\n            pd.MultiIndex.from_arrays(\n                [\n                    range(4),\n                    [\n                        \"(2020-01-31, 2020-07-31]\",\n                        \"(2020-07-31, 2021-01-31]\",\n                        \"(2021-01-31, 2021-07-31]\",\n                        \"(2021-07-31, 2022-01-31]\",\n                    ],\n                ]\n            ),\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 261,
        "end_line": 289,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_excel_sheet_size#304",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_excel_sheet_size(self, path)",
        "snippet": "    def test_excel_sheet_size(self, path):\n\n        # GH 26080\n        breaking_row_count = 2 ** 20 + 1\n        breaking_col_count = 2 ** 14 + 1\n        # purposely using two arrays to prevent memory issues while testing\n        row_arr = np.zeros(shape=(breaking_row_count, 1))\n        col_arr = np.zeros(shape=(1, breaking_col_count))\n        row_df = pd.DataFrame(row_arr)\n        col_df = pd.DataFrame(col_arr)\n\n        msg = \"sheet is too large\"\n        with pytest.raises(ValueError, match=msg):\n            row_df.to_excel(path)\n\n        with pytest.raises(ValueError, match=msg):\n            col_df.to_excel(path)",
        "begin_line": 304,
        "end_line": 320,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_excel_sheet_by_name_raise#322",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_excel_sheet_by_name_raise(self, path)",
        "snippet": "    def test_excel_sheet_by_name_raise(self, path):\n        import xlrd\n\n        gt = DataFrame(np.random.randn(10, 2))\n        gt.to_excel(path)\n\n        xl = ExcelFile(path)\n        df = pd.read_excel(xl, 0, index_col=0)\n\n        tm.assert_frame_equal(gt, df)\n\n        with pytest.raises(xlrd.XLRDError):\n            pd.read_excel(xl, \"0\")",
        "begin_line": 322,
        "end_line": 334,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_excel_writer_context_manager#336",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_excel_writer_context_manager(self, frame, path)",
        "snippet": "    def test_excel_writer_context_manager(self, frame, path):\n        with ExcelWriter(path) as writer:\n            frame.to_excel(writer, \"Data1\")\n            frame2 = frame.copy()\n            frame2.columns = frame.columns[::-1]\n            frame2.to_excel(writer, \"Data2\")\n\n        with ExcelFile(path) as reader:\n            found_df = pd.read_excel(reader, \"Data1\", index_col=0)\n            found_df2 = pd.read_excel(reader, \"Data2\", index_col=0)\n\n            tm.assert_frame_equal(found_df, frame)\n            tm.assert_frame_equal(found_df2, frame2)",
        "begin_line": 336,
        "end_line": 348,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_roundtrip#350",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_roundtrip(self, frame, path)",
        "snippet": "    def test_roundtrip(self, frame, path):\n        frame = frame.copy()\n        frame[\"A\"][:5] = np.nan\n\n        frame.to_excel(path, \"test1\")\n        frame.to_excel(path, \"test1\", columns=[\"A\", \"B\"])\n        frame.to_excel(path, \"test1\", header=False)\n        frame.to_excel(path, \"test1\", index=False)\n\n        # test roundtrip\n        frame.to_excel(path, \"test1\")\n        recons = pd.read_excel(path, \"test1\", index_col=0)\n        tm.assert_frame_equal(frame, recons)\n\n        frame.to_excel(path, \"test1\", index=False)\n        recons = pd.read_excel(path, \"test1\", index_col=None)\n        recons.index = frame.index\n        tm.assert_frame_equal(frame, recons)\n\n        frame.to_excel(path, \"test1\", na_rep=\"NA\")\n        recons = pd.read_excel(path, \"test1\", index_col=0, na_values=[\"NA\"])\n        tm.assert_frame_equal(frame, recons)\n\n        # GH 3611\n        frame.to_excel(path, \"test1\", na_rep=\"88\")\n        recons = pd.read_excel(path, \"test1\", index_col=0, na_values=[\"88\"])\n        tm.assert_frame_equal(frame, recons)\n\n        frame.to_excel(path, \"test1\", na_rep=\"88\")\n        recons = pd.read_excel(path, \"test1\", index_col=0, na_values=[88, 88.0])\n        tm.assert_frame_equal(frame, recons)\n\n        # GH 6573\n        frame.to_excel(path, \"Sheet1\")\n        recons = pd.read_excel(path, index_col=0)\n        tm.assert_frame_equal(frame, recons)\n\n        frame.to_excel(path, \"0\")\n        recons = pd.read_excel(path, index_col=0)\n        tm.assert_frame_equal(frame, recons)\n\n        # GH 8825 Pandas Series should provide to_excel method\n        s = frame[\"A\"]\n        s.to_excel(path)\n        recons = pd.read_excel(path, index_col=0)\n        tm.assert_frame_equal(s.to_frame(), recons)",
        "begin_line": 350,
        "end_line": 395,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_mixed#397",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_mixed(self, frame, path)",
        "snippet": "    def test_mixed(self, frame, path):\n        mixed_frame = frame.copy()\n        mixed_frame[\"foo\"] = \"bar\"\n\n        mixed_frame.to_excel(path, \"test1\")\n        reader = ExcelFile(path)\n        recons = pd.read_excel(reader, \"test1\", index_col=0)\n        tm.assert_frame_equal(mixed_frame, recons)",
        "begin_line": 397,
        "end_line": 404,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_ts_frame#406",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_ts_frame(self, tsframe, path)",
        "snippet": "    def test_ts_frame(self, tsframe, path):\n        df = tsframe\n\n        df.to_excel(path, \"test1\")\n        reader = ExcelFile(path)\n\n        recons = pd.read_excel(reader, \"test1\", index_col=0)\n        tm.assert_frame_equal(df, recons)",
        "begin_line": 406,
        "end_line": 413,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_basics_with_nan#415",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_basics_with_nan(self, frame, path)",
        "snippet": "    def test_basics_with_nan(self, frame, path):\n        frame = frame.copy()\n        frame[\"A\"][:5] = np.nan\n        frame.to_excel(path, \"test1\")\n        frame.to_excel(path, \"test1\", columns=[\"A\", \"B\"])\n        frame.to_excel(path, \"test1\", header=False)\n        frame.to_excel(path, \"test1\", index=False)",
        "begin_line": 415,
        "end_line": 421,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_int_types#424",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_int_types(self, np_type, path)",
        "snippet": "    def test_int_types(self, np_type, path):\n        # Test np.int values read come back as int\n        # (rather than float which is Excel's format).\n        df = DataFrame(np.random.randint(-10, 10, size=(10, 2)), dtype=np_type)\n        df.to_excel(path, \"test1\")\n\n        reader = ExcelFile(path)\n        recons = pd.read_excel(reader, \"test1\", index_col=0)\n\n        int_frame = df.astype(np.int64)\n        tm.assert_frame_equal(int_frame, recons)\n\n        recons2 = pd.read_excel(path, \"test1\", index_col=0)\n        tm.assert_frame_equal(int_frame, recons2)\n\n        # Test with convert_float=False comes back as float.\n        float_frame = df.astype(float)\n        recons = pd.read_excel(path, \"test1\", convert_float=False, index_col=0)\n        tm.assert_frame_equal(\n            recons, float_frame, check_index_type=False, check_column_type=False\n        )",
        "begin_line": 424,
        "end_line": 444,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_float_types#447",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_float_types(self, np_type, path)",
        "snippet": "    def test_float_types(self, np_type, path):\n        # Test np.float values read come back as float.\n        df = DataFrame(np.random.random_sample(10), dtype=np_type)\n        df.to_excel(path, \"test1\")\n\n        reader = ExcelFile(path)\n        recons = pd.read_excel(reader, \"test1\", index_col=0).astype(np_type)\n\n        tm.assert_frame_equal(df, recons, check_dtype=False)",
        "begin_line": 447,
        "end_line": 455,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_bool_types#458",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_bool_types(self, np_type, path)",
        "snippet": "    def test_bool_types(self, np_type, path):\n        # Test np.bool values read come back as float.\n        df = DataFrame([1, 0, True, False], dtype=np_type)\n        df.to_excel(path, \"test1\")\n\n        reader = ExcelFile(path)\n        recons = pd.read_excel(reader, \"test1\", index_col=0).astype(np_type)\n\n        tm.assert_frame_equal(df, recons)",
        "begin_line": 458,
        "end_line": 466,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_inf_roundtrip#468",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_inf_roundtrip(self, path)",
        "snippet": "    def test_inf_roundtrip(self, path):\n        df = DataFrame([(1, np.inf), (2, 3), (5, -np.inf)])\n        df.to_excel(path, \"test1\")\n\n        reader = ExcelFile(path)\n        recons = pd.read_excel(reader, \"test1\", index_col=0)\n\n        tm.assert_frame_equal(df, recons)",
        "begin_line": 468,
        "end_line": 475,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_sheets#477",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_sheets(self, frame, tsframe, path)",
        "snippet": "    def test_sheets(self, frame, tsframe, path):\n        frame = frame.copy()\n        frame[\"A\"][:5] = np.nan\n\n        frame.to_excel(path, \"test1\")\n        frame.to_excel(path, \"test1\", columns=[\"A\", \"B\"])\n        frame.to_excel(path, \"test1\", header=False)\n        frame.to_excel(path, \"test1\", index=False)\n\n        # Test writing to separate sheets\n        writer = ExcelWriter(path)\n        frame.to_excel(writer, \"test1\")\n        tsframe.to_excel(writer, \"test2\")\n        writer.save()\n        reader = ExcelFile(path)\n        recons = pd.read_excel(reader, \"test1\", index_col=0)\n        tm.assert_frame_equal(frame, recons)\n        recons = pd.read_excel(reader, \"test2\", index_col=0)\n        tm.assert_frame_equal(tsframe, recons)\n        assert 2 == len(reader.sheet_names)\n        assert \"test1\" == reader.sheet_names[0]\n        assert \"test2\" == reader.sheet_names[1]",
        "begin_line": 477,
        "end_line": 498,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_colaliases#500",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_colaliases(self, frame, path)",
        "snippet": "    def test_colaliases(self, frame, path):\n        frame = frame.copy()\n        frame[\"A\"][:5] = np.nan\n\n        frame.to_excel(path, \"test1\")\n        frame.to_excel(path, \"test1\", columns=[\"A\", \"B\"])\n        frame.to_excel(path, \"test1\", header=False)\n        frame.to_excel(path, \"test1\", index=False)\n\n        # column aliases\n        col_aliases = Index([\"AA\", \"X\", \"Y\", \"Z\"])\n        frame.to_excel(path, \"test1\", header=col_aliases)\n        reader = ExcelFile(path)\n        rs = pd.read_excel(reader, \"test1\", index_col=0)\n        xp = frame.copy()\n        xp.columns = col_aliases\n        tm.assert_frame_equal(xp, rs)",
        "begin_line": 500,
        "end_line": 516,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_roundtrip_indexlabels#518",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_roundtrip_indexlabels(self, merge_cells, frame, path)",
        "snippet": "    def test_roundtrip_indexlabels(self, merge_cells, frame, path):\n        frame = frame.copy()\n        frame[\"A\"][:5] = np.nan\n\n        frame.to_excel(path, \"test1\")\n        frame.to_excel(path, \"test1\", columns=[\"A\", \"B\"])\n        frame.to_excel(path, \"test1\", header=False)\n        frame.to_excel(path, \"test1\", index=False)\n\n        # test index_label\n        df = DataFrame(np.random.randn(10, 2)) >= 0\n        df.to_excel(path, \"test1\", index_label=[\"test\"], merge_cells=merge_cells)\n        reader = ExcelFile(path)\n        recons = pd.read_excel(reader, \"test1\", index_col=0).astype(np.int64)\n        df.index.names = [\"test\"]\n        assert df.index.names == recons.index.names\n\n        df = DataFrame(np.random.randn(10, 2)) >= 0\n        df.to_excel(\n            path,\n            \"test1\",\n            index_label=[\"test\", \"dummy\", \"dummy2\"],\n            merge_cells=merge_cells,\n        )\n        reader = ExcelFile(path)\n        recons = pd.read_excel(reader, \"test1\", index_col=0).astype(np.int64)\n        df.index.names = [\"test\"]\n        assert df.index.names == recons.index.names\n\n        df = DataFrame(np.random.randn(10, 2)) >= 0\n        df.to_excel(path, \"test1\", index_label=\"test\", merge_cells=merge_cells)\n        reader = ExcelFile(path)\n        recons = pd.read_excel(reader, \"test1\", index_col=0).astype(np.int64)\n        df.index.names = [\"test\"]\n        tm.assert_frame_equal(df, recons.astype(bool))\n\n        frame.to_excel(\n            path,\n            \"test1\",\n            columns=[\"A\", \"B\", \"C\", \"D\"],\n            index=False,\n            merge_cells=merge_cells,\n        )\n        # take 'A' and 'B' as indexes (same row as cols 'C', 'D')\n        df = frame.copy()\n        df = df.set_index([\"A\", \"B\"])\n\n        reader = ExcelFile(path)\n        recons = pd.read_excel(reader, \"test1\", index_col=[0, 1])\n        tm.assert_frame_equal(df, recons, check_less_precise=True)",
        "begin_line": 518,
        "end_line": 567,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_excel_roundtrip_indexname#569",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_excel_roundtrip_indexname(self, merge_cells, path)",
        "snippet": "    def test_excel_roundtrip_indexname(self, merge_cells, path):\n        df = DataFrame(np.random.randn(10, 4))\n        df.index.name = \"foo\"\n\n        df.to_excel(path, merge_cells=merge_cells)\n\n        xf = ExcelFile(path)\n        result = pd.read_excel(xf, xf.sheet_names[0], index_col=0)\n\n        tm.assert_frame_equal(result, df)\n        assert result.index.name == \"foo\"",
        "begin_line": 569,
        "end_line": 579,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_excel_roundtrip_datetime#581",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_excel_roundtrip_datetime(self, merge_cells, tsframe, path)",
        "snippet": "    def test_excel_roundtrip_datetime(self, merge_cells, tsframe, path):\n        # datetime.date, not sure what to test here exactly\n        tsf = tsframe.copy()\n\n        tsf.index = [x.date() for x in tsframe.index]\n        tsf.to_excel(path, \"test1\", merge_cells=merge_cells)\n\n        reader = ExcelFile(path)\n        recons = pd.read_excel(reader, \"test1\", index_col=0)\n\n        tm.assert_frame_equal(tsframe, recons)",
        "begin_line": 581,
        "end_line": 591,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_excel_date_datetime_format#593",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_excel_date_datetime_format(self, engine, ext, path)",
        "snippet": "    def test_excel_date_datetime_format(self, engine, ext, path):\n        # see gh-4133\n        #\n        # Excel output format strings\n        df = DataFrame(\n            [\n                [date(2014, 1, 31), date(1999, 9, 24)],\n                [datetime(1998, 5, 26, 23, 33, 4), datetime(2014, 2, 28, 13, 5, 13)],\n            ],\n            index=[\"DATE\", \"DATETIME\"],\n            columns=[\"X\", \"Y\"],\n        )\n        df_expected = DataFrame(\n            [\n                [datetime(2014, 1, 31), datetime(1999, 9, 24)],\n                [datetime(1998, 5, 26, 23, 33, 4), datetime(2014, 2, 28, 13, 5, 13)],\n            ],\n            index=[\"DATE\", \"DATETIME\"],\n            columns=[\"X\", \"Y\"],\n        )\n\n        with tm.ensure_clean(ext) as filename2:\n            writer1 = ExcelWriter(path)\n            writer2 = ExcelWriter(\n                filename2,\n                date_format=\"DD.MM.YYYY\",\n                datetime_format=\"DD.MM.YYYY HH-MM-SS\",\n            )\n\n            df.to_excel(writer1, \"test1\")\n            df.to_excel(writer2, \"test1\")\n\n            writer1.close()\n            writer2.close()\n\n            reader1 = ExcelFile(path)\n            reader2 = ExcelFile(filename2)\n\n            rs1 = pd.read_excel(reader1, \"test1\", index_col=0)\n            rs2 = pd.read_excel(reader2, \"test1\", index_col=0)\n\n            tm.assert_frame_equal(rs1, rs2)\n\n            # Since the reader returns a datetime object for dates,\n            # we need to use df_expected to check the result.\n            tm.assert_frame_equal(rs2, df_expected)",
        "begin_line": 593,
        "end_line": 638,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_interval_no_labels#640",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_interval_no_labels(self, path)",
        "snippet": "    def test_to_excel_interval_no_labels(self, path):\n        # see gh-19242\n        #\n        # Test writing Interval without labels.\n        df = DataFrame(np.random.randint(-10, 10, size=(20, 1)), dtype=np.int64)\n        expected = df.copy()\n\n        df[\"new\"] = pd.cut(df[0], 10)\n        expected[\"new\"] = pd.cut(expected[0], 10).astype(str)\n\n        df.to_excel(path, \"test1\")\n        reader = ExcelFile(path)\n\n        recons = pd.read_excel(reader, \"test1\", index_col=0)\n        tm.assert_frame_equal(expected, recons)",
        "begin_line": 640,
        "end_line": 654,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_interval_labels#656",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_interval_labels(self, path)",
        "snippet": "    def test_to_excel_interval_labels(self, path):\n        # see gh-19242\n        #\n        # Test writing Interval with labels.\n        df = DataFrame(np.random.randint(-10, 10, size=(20, 1)), dtype=np.int64)\n        expected = df.copy()\n        intervals = pd.cut(\n            df[0], 10, labels=[\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"]\n        )\n        df[\"new\"] = intervals\n        expected[\"new\"] = pd.Series(list(intervals))\n\n        df.to_excel(path, \"test1\")\n        reader = ExcelFile(path)\n\n        recons = pd.read_excel(reader, \"test1\", index_col=0)\n        tm.assert_frame_equal(expected, recons)",
        "begin_line": 656,
        "end_line": 672,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_timedelta#674",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_timedelta(self, path)",
        "snippet": "    def test_to_excel_timedelta(self, path):\n        # see gh-19242, gh-9155\n        #\n        # Test writing timedelta to xls.\n        df = DataFrame(\n            np.random.randint(-10, 10, size=(20, 1)), columns=[\"A\"], dtype=np.int64\n        )\n        expected = df.copy()\n\n        df[\"new\"] = df[\"A\"].apply(lambda x: timedelta(seconds=x))\n        expected[\"new\"] = expected[\"A\"].apply(\n            lambda x: timedelta(seconds=x).total_seconds() / float(86400)\n        )\n\n        df.to_excel(path, \"test1\")\n        reader = ExcelFile(path)\n\n        recons = pd.read_excel(reader, \"test1\", index_col=0)\n        tm.assert_frame_equal(expected, recons)",
        "begin_line": 674,
        "end_line": 692,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_periodindex#694",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_periodindex(self, tsframe, path)",
        "snippet": "    def test_to_excel_periodindex(self, tsframe, path):\n        xp = tsframe.resample(\"M\", kind=\"period\").mean()\n\n        xp.to_excel(path, \"sht1\")\n\n        reader = ExcelFile(path)\n        rs = pd.read_excel(reader, \"sht1\", index_col=0)\n        tm.assert_frame_equal(xp, rs.to_period(\"M\"))",
        "begin_line": 694,
        "end_line": 701,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_multiindex#703",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_multiindex(self, merge_cells, frame, path)",
        "snippet": "    def test_to_excel_multiindex(self, merge_cells, frame, path):\n        arrays = np.arange(len(frame.index) * 2).reshape(2, -1)\n        new_index = MultiIndex.from_arrays(arrays, names=[\"first\", \"second\"])\n        frame.index = new_index\n\n        frame.to_excel(path, \"test1\", header=False)\n        frame.to_excel(path, \"test1\", columns=[\"A\", \"B\"])\n\n        # round trip\n        frame.to_excel(path, \"test1\", merge_cells=merge_cells)\n        reader = ExcelFile(path)\n        df = pd.read_excel(reader, \"test1\", index_col=[0, 1])\n        tm.assert_frame_equal(frame, df)",
        "begin_line": 703,
        "end_line": 715,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_multiindex_nan_label#718",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_multiindex_nan_label(self, merge_cells, path)",
        "snippet": "    def test_to_excel_multiindex_nan_label(self, merge_cells, path):\n        df = pd.DataFrame(\n            {\"A\": [None, 2, 3], \"B\": [10, 20, 30], \"C\": np.random.sample(3)}\n        )\n        df = df.set_index([\"A\", \"B\"])\n\n        df.to_excel(path, merge_cells=merge_cells)\n        df1 = pd.read_excel(path, index_col=[0, 1])\n        tm.assert_frame_equal(df, df1)",
        "begin_line": 718,
        "end_line": 726,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_multiindex_cols#731",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_multiindex_cols(self, merge_cells, frame, path)",
        "snippet": "    def test_to_excel_multiindex_cols(self, merge_cells, frame, path):\n        arrays = np.arange(len(frame.index) * 2).reshape(2, -1)\n        new_index = MultiIndex.from_arrays(arrays, names=[\"first\", \"second\"])\n        frame.index = new_index\n\n        new_cols_index = MultiIndex.from_tuples([(40, 1), (40, 2), (50, 1), (50, 2)])\n        frame.columns = new_cols_index\n        header = [0, 1]\n        if not merge_cells:\n            header = 0\n\n        # round trip\n        frame.to_excel(path, \"test1\", merge_cells=merge_cells)\n        reader = ExcelFile(path)\n        df = pd.read_excel(reader, \"test1\", header=header, index_col=[0, 1])\n        if not merge_cells:\n            fm = frame.columns.format(sparsify=False, adjoin=False, names=False)\n            frame.columns = [\".\".join(map(str, q)) for q in zip(*fm)]\n        tm.assert_frame_equal(frame, df)",
        "begin_line": 731,
        "end_line": 749,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_multiindex_dates#751",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_multiindex_dates(self, merge_cells, tsframe, path)",
        "snippet": "    def test_to_excel_multiindex_dates(self, merge_cells, tsframe, path):\n        # try multiindex with dates\n        new_index = [tsframe.index, np.arange(len(tsframe.index))]\n        tsframe.index = MultiIndex.from_arrays(new_index)\n\n        tsframe.index.names = [\"time\", \"foo\"]\n        tsframe.to_excel(path, \"test1\", merge_cells=merge_cells)\n        reader = ExcelFile(path)\n        recons = pd.read_excel(reader, \"test1\", index_col=[0, 1])\n\n        tm.assert_frame_equal(tsframe, recons)\n        assert recons.index.names == (\"time\", \"foo\")",
        "begin_line": 751,
        "end_line": 762,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_multiindex_no_write_index#764",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_multiindex_no_write_index(self, path)",
        "snippet": "    def test_to_excel_multiindex_no_write_index(self, path):\n        # Test writing and re-reading a MI without the index. GH 5616.\n\n        # Initial non-MI frame.\n        frame1 = DataFrame({\"a\": [10, 20], \"b\": [30, 40], \"c\": [50, 60]})\n\n        # Add a MI.\n        frame2 = frame1.copy()\n        multi_index = MultiIndex.from_tuples([(70, 80), (90, 100)])\n        frame2.index = multi_index\n\n        # Write out to Excel without the index.\n        frame2.to_excel(path, \"test1\", index=False)\n\n        # Read it back in.\n        reader = ExcelFile(path)\n        frame3 = pd.read_excel(reader, \"test1\")\n\n        # Test that it is the same as the initial frame.\n        tm.assert_frame_equal(frame1, frame3)",
        "begin_line": 764,
        "end_line": 783,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_float_format#785",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_float_format(self, path)",
        "snippet": "    def test_to_excel_float_format(self, path):\n        df = DataFrame(\n            [[0.123456, 0.234567, 0.567567], [12.32112, 123123.2, 321321.2]],\n            index=[\"A\", \"B\"],\n            columns=[\"X\", \"Y\", \"Z\"],\n        )\n        df.to_excel(path, \"test1\", float_format=\"%.2f\")\n\n        reader = ExcelFile(path)\n        result = pd.read_excel(reader, \"test1\", index_col=0)\n\n        expected = DataFrame(\n            [[0.12, 0.23, 0.57], [12.32, 123123.20, 321321.20]],\n            index=[\"A\", \"B\"],\n            columns=[\"X\", \"Y\", \"Z\"],\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 785,
        "end_line": 801,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_output_encoding#803",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_output_encoding(self, ext)",
        "snippet": "    def test_to_excel_output_encoding(self, ext):\n        # Avoid mixed inferred_type.\n        df = DataFrame(\n            [[\"\\u0192\", \"\\u0193\", \"\\u0194\"], [\"\\u0195\", \"\\u0196\", \"\\u0197\"]],\n            index=[\"A\\u0192\", \"B\"],\n            columns=[\"X\\u0193\", \"Y\", \"Z\"],\n        )\n\n        with tm.ensure_clean(\"__tmp_to_excel_float_format__.\" + ext) as filename:\n            df.to_excel(filename, sheet_name=\"TestSheet\", encoding=\"utf8\")\n            result = pd.read_excel(filename, \"TestSheet\", encoding=\"utf8\", index_col=0)\n            tm.assert_frame_equal(result, df)",
        "begin_line": 803,
        "end_line": 814,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_unicode_filename#816",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_to_excel_unicode_filename(self, ext, path)",
        "snippet": "    def test_to_excel_unicode_filename(self, ext, path):\n        with tm.ensure_clean(\"\\u0192u.\" + ext) as filename:\n            try:\n                f = open(filename, \"wb\")\n            except UnicodeEncodeError:\n                pytest.skip(\"No unicode file names on this system\")\n            else:\n                f.close()\n\n            df = DataFrame(\n                [[0.123456, 0.234567, 0.567567], [12.32112, 123123.2, 321321.2]],\n                index=[\"A\", \"B\"],\n                columns=[\"X\", \"Y\", \"Z\"],\n            )\n            df.to_excel(filename, \"test1\", float_format=\"%.2f\")\n\n            reader = ExcelFile(filename)\n            result = pd.read_excel(reader, \"test1\", index_col=0)\n\n            expected = DataFrame(\n                [[0.12, 0.23, 0.57], [12.32, 123123.20, 321321.20]],\n                index=[\"A\", \"B\"],\n                columns=[\"X\", \"Y\", \"Z\"],\n            )\n            tm.assert_frame_equal(result, expected)",
        "begin_line": 816,
        "end_line": 840,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_excel_010_hemstring#946",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_excel_010_hemstring(self, merge_cells, c_idx_nlevels, r_idx_nlevels, use_headers, path)",
        "snippet": "    def test_excel_010_hemstring(\n        self, merge_cells, c_idx_nlevels, r_idx_nlevels, use_headers, path\n    ):\n        def roundtrip(data, header=True, parser_hdr=0, index=True):\n            data.to_excel(path, header=header, merge_cells=merge_cells, index=index)\n\n            xf = ExcelFile(path)\n            return pd.read_excel(xf, xf.sheet_names[0], header=parser_hdr)\n\n        # Basic test.\n        parser_header = 0 if use_headers else None\n        res = roundtrip(DataFrame([0]), use_headers, parser_header)\n\n        assert res.shape == (1, 2)\n        assert res.iloc[0, 0] is not np.nan\n\n        # More complex tests with multi-index.\n        nrows = 5\n        ncols = 3\n\n        # ensure limited functionality in 0.10\n        # override of gh-2370 until sorted out in 0.11\n\n        df = tm.makeCustomDataframe(\n            nrows, ncols, r_idx_nlevels=r_idx_nlevels, c_idx_nlevels=c_idx_nlevels\n        )\n\n        # This if will be removed once multi-column Excel writing\n        # is implemented. For now fixing gh-9794.\n        if c_idx_nlevels > 1:\n            with pytest.raises(NotImplementedError):\n                roundtrip(df, use_headers, index=False)\n        else:\n            res = roundtrip(df, use_headers)\n\n            if use_headers:\n                assert res.shape == (nrows, ncols + r_idx_nlevels)\n            else:\n                # First row taken as columns.\n                assert res.shape == (nrows - 1, ncols + r_idx_nlevels)\n\n            # No NaNs.\n            for r in range(len(res.index)):\n                for c in range(len(res.columns)):\n                    assert res.iloc[r, c] is not np.nan",
        "begin_line": 946,
        "end_line": 990,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.roundtrip#949",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.roundtrip(data, header=True, parser_hdr=0, index=True)",
        "snippet": "        def roundtrip(data, header=True, parser_hdr=0, index=True):\n            data.to_excel(path, header=header, merge_cells=merge_cells, index=index)\n\n            xf = ExcelFile(path)\n            return pd.read_excel(xf, xf.sheet_names[0], header=parser_hdr)",
        "begin_line": 949,
        "end_line": 953,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_duplicated_columns#992",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_duplicated_columns(self, path)",
        "snippet": "    def test_duplicated_columns(self, path):\n        # see gh-5235\n        df = DataFrame([[1, 2, 3], [1, 2, 3], [1, 2, 3]], columns=[\"A\", \"B\", \"B\"])\n        df.to_excel(path, \"test1\")\n        expected = DataFrame(\n            [[1, 2, 3], [1, 2, 3], [1, 2, 3]], columns=[\"A\", \"B\", \"B.1\"]\n        )\n\n        # By default, we mangle.\n        result = pd.read_excel(path, \"test1\", index_col=0)\n        tm.assert_frame_equal(result, expected)\n\n        # Explicitly, we pass in the parameter.\n        result = pd.read_excel(path, \"test1\", index_col=0, mangle_dupe_cols=True)\n        tm.assert_frame_equal(result, expected)\n\n        # see gh-11007, gh-10970\n        df = DataFrame([[1, 2, 3, 4], [5, 6, 7, 8]], columns=[\"A\", \"B\", \"A\", \"B\"])\n        df.to_excel(path, \"test1\")\n\n        result = pd.read_excel(path, \"test1\", index_col=0)\n        expected = DataFrame(\n            [[1, 2, 3, 4], [5, 6, 7, 8]], columns=[\"A\", \"B\", \"A.1\", \"B.1\"]\n        )\n        tm.assert_frame_equal(result, expected)\n\n        # see gh-10982\n        df.to_excel(path, \"test1\", index=False, header=False)\n        result = pd.read_excel(path, \"test1\", header=None)\n\n        expected = DataFrame([[1, 2, 3, 4], [5, 6, 7, 8]])\n        tm.assert_frame_equal(result, expected)\n\n        msg = \"Setting mangle_dupe_cols=False is not supported yet\"\n        with pytest.raises(ValueError, match=msg):\n            pd.read_excel(path, \"test1\", header=None, mangle_dupe_cols=False)",
        "begin_line": 992,
        "end_line": 1027,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_swapped_columns#1029",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_swapped_columns(self, path)",
        "snippet": "    def test_swapped_columns(self, path):\n        # Test for issue #5427.\n        write_frame = DataFrame({\"A\": [1, 1, 1], \"B\": [2, 2, 2]})\n        write_frame.to_excel(path, \"test1\", columns=[\"B\", \"A\"])\n\n        read_frame = pd.read_excel(path, \"test1\", header=0)\n\n        tm.assert_series_equal(write_frame[\"A\"], read_frame[\"A\"])\n        tm.assert_series_equal(write_frame[\"B\"], read_frame[\"B\"])",
        "begin_line": 1029,
        "end_line": 1037,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_invalid_columns#1039",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_invalid_columns(self, path)",
        "snippet": "    def test_invalid_columns(self, path):\n        # see gh-10982\n        write_frame = DataFrame({\"A\": [1, 1, 1], \"B\": [2, 2, 2]})\n\n        with pytest.raises(KeyError, match=\"Not all names specified\"):\n            write_frame.to_excel(path, \"test1\", columns=[\"B\", \"C\"])\n\n        with pytest.raises(\n            KeyError, match=\"'passes columns are not ALL present dataframe'\"\n        ):\n            write_frame.to_excel(path, \"test1\", columns=[\"C\", \"D\"])",
        "begin_line": 1039,
        "end_line": 1049,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_write_subset_columns#1058",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_write_subset_columns(self, path, to_excel_index, read_excel_index_col)",
        "snippet": "    def test_write_subset_columns(self, path, to_excel_index, read_excel_index_col):\n        # GH 31677\n        write_frame = DataFrame({\"A\": [1, 1, 1], \"B\": [2, 2, 2], \"C\": [3, 3, 3]})\n        write_frame.to_excel(\n            path, \"col_subset_bug\", columns=[\"A\", \"B\"], index=to_excel_index\n        )\n\n        expected = write_frame[[\"A\", \"B\"]]\n        read_frame = pd.read_excel(\n            path, \"col_subset_bug\", index_col=read_excel_index_col\n        )\n\n        tm.assert_frame_equal(expected, read_frame)",
        "begin_line": 1058,
        "end_line": 1070,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_comment_arg#1072",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_comment_arg(self, path)",
        "snippet": "    def test_comment_arg(self, path):\n        # see gh-18735\n        #\n        # Test the comment argument functionality to pd.read_excel.\n\n        # Create file to read in.\n        df = DataFrame({\"A\": [\"one\", \"#one\", \"one\"], \"B\": [\"two\", \"two\", \"#two\"]})\n        df.to_excel(path, \"test_c\")\n\n        # Read file without comment arg.\n        result1 = pd.read_excel(path, \"test_c\", index_col=0)\n\n        result1.iloc[1, 0] = None\n        result1.iloc[1, 1] = None\n        result1.iloc[2, 1] = None\n\n        result2 = pd.read_excel(path, \"test_c\", comment=\"#\", index_col=0)\n        tm.assert_frame_equal(result1, result2)",
        "begin_line": 1072,
        "end_line": 1089,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_comment_default#1091",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_comment_default(self, path)",
        "snippet": "    def test_comment_default(self, path):\n        # Re issue #18735\n        # Test the comment argument default to pd.read_excel\n\n        # Create file to read in\n        df = DataFrame({\"A\": [\"one\", \"#one\", \"one\"], \"B\": [\"two\", \"two\", \"#two\"]})\n        df.to_excel(path, \"test_c\")\n\n        # Read file with default and explicit comment=None\n        result1 = pd.read_excel(path, \"test_c\")\n        result2 = pd.read_excel(path, \"test_c\", comment=None)\n        tm.assert_frame_equal(result1, result2)",
        "begin_line": 1091,
        "end_line": 1102,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_comment_used#1104",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_comment_used(self, path)",
        "snippet": "    def test_comment_used(self, path):\n        # see gh-18735\n        #\n        # Test the comment argument is working as expected when used.\n\n        # Create file to read in.\n        df = DataFrame({\"A\": [\"one\", \"#one\", \"one\"], \"B\": [\"two\", \"two\", \"#two\"]})\n        df.to_excel(path, \"test_c\")\n\n        # Test read_frame_comment against manually produced expected output.\n        expected = DataFrame({\"A\": [\"one\", None, \"one\"], \"B\": [\"two\", None, None]})\n        result = pd.read_excel(path, \"test_c\", comment=\"#\", index_col=0)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1104,
        "end_line": 1116,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_comment_empty_line#1118",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_comment_empty_line(self, path)",
        "snippet": "    def test_comment_empty_line(self, path):\n        # Re issue #18735\n        # Test that pd.read_excel ignores commented lines at the end of file\n\n        df = DataFrame({\"a\": [\"1\", \"#2\"], \"b\": [\"2\", \"3\"]})\n        df.to_excel(path, index=False)\n\n        # Test that all-comment lines at EoF are ignored\n        expected = DataFrame({\"a\": [1], \"b\": [2]})\n        result = pd.read_excel(path, comment=\"#\")\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1118,
        "end_line": 1128,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_datetimes#1130",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_datetimes(self, path)",
        "snippet": "    def test_datetimes(self, path):\n\n        # Test writing and reading datetimes. For issue #9139. (xref #9185)\n        datetimes = [\n            datetime(2013, 1, 13, 1, 2, 3),\n            datetime(2013, 1, 13, 2, 45, 56),\n            datetime(2013, 1, 13, 4, 29, 49),\n            datetime(2013, 1, 13, 6, 13, 42),\n            datetime(2013, 1, 13, 7, 57, 35),\n            datetime(2013, 1, 13, 9, 41, 28),\n            datetime(2013, 1, 13, 11, 25, 21),\n            datetime(2013, 1, 13, 13, 9, 14),\n            datetime(2013, 1, 13, 14, 53, 7),\n            datetime(2013, 1, 13, 16, 37, 0),\n            datetime(2013, 1, 13, 18, 20, 52),\n        ]\n\n        write_frame = DataFrame({\"A\": datetimes})\n        write_frame.to_excel(path, \"Sheet1\")\n        read_frame = pd.read_excel(path, \"Sheet1\", header=0)\n\n        tm.assert_series_equal(write_frame[\"A\"], read_frame[\"A\"])",
        "begin_line": 1130,
        "end_line": 1151,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_bytes_io#1153",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_bytes_io(self, engine)",
        "snippet": "    def test_bytes_io(self, engine):\n        # see gh-7074\n        bio = BytesIO()\n        df = DataFrame(np.random.randn(10, 2))\n\n        # Pass engine explicitly, as there is no file path to infer from.\n        writer = ExcelWriter(bio, engine=engine)\n        df.to_excel(writer)\n        writer.save()\n\n        bio.seek(0)\n        reread_df = pd.read_excel(bio, index_col=0)\n        tm.assert_frame_equal(df, reread_df)",
        "begin_line": 1153,
        "end_line": 1165,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_write_lists_dict#1167",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_write_lists_dict(self, path)",
        "snippet": "    def test_write_lists_dict(self, path):\n        # see gh-8188.\n        df = DataFrame(\n            {\n                \"mixed\": [\"a\", [\"b\", \"c\"], {\"d\": \"e\", \"f\": 2}],\n                \"numeric\": [1, 2, 3.0],\n                \"str\": [\"apple\", \"banana\", \"cherry\"],\n            }\n        )\n        df.to_excel(path, \"Sheet1\")\n        read = pd.read_excel(path, \"Sheet1\", header=0, index_col=0)\n\n        expected = df.copy()\n        expected.mixed = expected.mixed.apply(str)\n        expected.numeric = expected.numeric.astype(\"int64\")\n\n        tm.assert_frame_equal(read, expected)",
        "begin_line": 1167,
        "end_line": 1183,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_true_and_false_value_options#1185",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_true_and_false_value_options(self, path)",
        "snippet": "    def test_true_and_false_value_options(self, path):\n        # see gh-13347\n        df = pd.DataFrame([[\"foo\", \"bar\"]], columns=[\"col1\", \"col2\"])\n        expected = df.replace({\"foo\": True, \"bar\": False})\n\n        df.to_excel(path)\n        read_frame = pd.read_excel(\n            path, true_values=[\"foo\"], false_values=[\"bar\"], index_col=0\n        )\n        tm.assert_frame_equal(read_frame, expected)",
        "begin_line": 1185,
        "end_line": 1194,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_freeze_panes#1196",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_freeze_panes(self, path)",
        "snippet": "    def test_freeze_panes(self, path):\n        # see gh-15160\n        expected = DataFrame([[1, 2], [3, 4]], columns=[\"col1\", \"col2\"])\n        expected.to_excel(path, \"Sheet1\", freeze_panes=(1, 1))\n\n        result = pd.read_excel(path, index_col=0)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1196,
        "end_line": 1202,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_path_path_lib#1204",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_path_path_lib(self, engine, ext)",
        "snippet": "    def test_path_path_lib(self, engine, ext):\n        df = tm.makeDataFrame()\n        writer = partial(df.to_excel, engine=engine)\n\n        reader = partial(pd.read_excel, index_col=0)\n        result = tm.round_trip_pathlib(writer, reader, path=\"foo.{ext}\".format(ext=ext))\n        tm.assert_frame_equal(result, df)",
        "begin_line": 1204,
        "end_line": 1210,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_path_local_path#1212",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_path_local_path(self, engine, ext)",
        "snippet": "    def test_path_local_path(self, engine, ext):\n        df = tm.makeDataFrame()\n        writer = partial(df.to_excel, engine=engine)\n\n        reader = partial(pd.read_excel, index_col=0)\n        result = tm.round_trip_pathlib(writer, reader, path=\"foo.{ext}\".format(ext=ext))\n        tm.assert_frame_equal(result, df)",
        "begin_line": 1212,
        "end_line": 1218,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_merged_cell_custom_objects#1220",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_merged_cell_custom_objects(self, merge_cells, path)",
        "snippet": "    def test_merged_cell_custom_objects(self, merge_cells, path):\n        # see GH-27006\n        mi = MultiIndex.from_tuples(\n            [\n                (pd.Period(\"2018\"), pd.Period(\"2018Q1\")),\n                (pd.Period(\"2018\"), pd.Period(\"2018Q2\")),\n            ]\n        )\n        expected = DataFrame(np.ones((2, 2)), columns=mi)\n        expected.to_excel(path)\n        result = pd.read_excel(path, header=[0, 1], index_col=0, convert_float=False)\n        # need to convert PeriodIndexes to standard Indexes for assert equal\n        expected.columns.set_levels(\n            [[str(i) for i in mi.levels[0]], [str(i) for i in mi.levels[1]]],\n            level=[0, 1],\n            inplace=True,\n        )\n        expected.index = expected.index.astype(np.float64)\n        tm.assert_frame_equal(expected, result)",
        "begin_line": 1220,
        "end_line": 1238,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_raise_when_saving_timezones#1241",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriter",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriter.test_raise_when_saving_timezones(self, dtype, tz_aware_fixture, path)",
        "snippet": "    def test_raise_when_saving_timezones(self, dtype, tz_aware_fixture, path):\n        # GH 27008, GH 7056\n        tz = tz_aware_fixture\n        data = pd.Timestamp(\"2019\", tz=tz)\n        df = DataFrame([data], dtype=dtype)\n        with pytest.raises(ValueError, match=\"Excel does not support\"):\n            df.to_excel(path)\n\n        data = data.to_pydatetime()\n        df = DataFrame([data], dtype=dtype)\n        with pytest.raises(ValueError, match=\"Excel does not support\"):\n            df.to_excel(path)",
        "begin_line": 1241,
        "end_line": 1252,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriterEngineTests.test_ExcelWriter_dispatch#1264",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriterEngineTests",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriterEngineTests.test_ExcelWriter_dispatch(self, klass, ext)",
        "snippet": "    def test_ExcelWriter_dispatch(self, klass, ext):\n        with tm.ensure_clean(ext) as path:\n            writer = ExcelWriter(path)\n            if ext == \".xlsx\" and td.safe_import(\"xlsxwriter\"):\n                # xlsxwriter has preference over openpyxl if both installed\n                assert isinstance(writer, _XlsxWriter)\n            else:\n                assert isinstance(writer, klass)",
        "begin_line": 1264,
        "end_line": 1271,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriterEngineTests.test_ExcelWriter_dispatch_raises#1273",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriterEngineTests",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriterEngineTests.test_ExcelWriter_dispatch_raises(self)",
        "snippet": "    def test_ExcelWriter_dispatch_raises(self):\n        with pytest.raises(ValueError, match=\"No engine\"):\n            ExcelWriter(\"nothing\")",
        "begin_line": 1273,
        "end_line": 1275,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriterEngineTests.test_register_writer#1277",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriterEngineTests",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriterEngineTests.test_register_writer(self)",
        "snippet": "    def test_register_writer(self):\n        # some awkward mocking to test out dispatch and such actually works\n        called_save = []\n        called_write_cells = []\n\n        class DummyClass(ExcelWriter):\n            called_save = False\n            called_write_cells = False\n            supported_extensions = [\"xlsx\", \"xls\"]\n            engine = \"dummy\"\n\n            def save(self):\n                called_save.append(True)\n\n            def write_cells(self, *args, **kwargs):\n                called_write_cells.append(True)\n\n        def check_called(func):\n            func()\n            assert len(called_save) >= 1\n            assert len(called_write_cells) >= 1\n            del called_save[:]\n            del called_write_cells[:]\n\n        with pd.option_context(\"io.excel.xlsx.writer\", \"dummy\"):\n            register_writer(DummyClass)\n            writer = ExcelWriter(\"something.xlsx\")\n            assert isinstance(writer, DummyClass)\n            df = tm.makeCustomDataframe(1, 1)\n            check_called(lambda: df.to_excel(\"something.xlsx\"))\n            check_called(lambda: df.to_excel(\"something.xls\", engine=\"dummy\"))",
        "begin_line": 1277,
        "end_line": 1307,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.DummyClass.test_register_writer#1277",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.DummyClass",
        "signature": "pandas.tests.io.excel.test_writers.DummyClass.test_register_writer(self)",
        "snippet": "    def test_register_writer(self):\n        # some awkward mocking to test out dispatch and such actually works\n        called_save = []\n        called_write_cells = []\n\n        class DummyClass(ExcelWriter):\n            called_save = False\n            called_write_cells = False\n            supported_extensions = [\"xlsx\", \"xls\"]\n            engine = \"dummy\"\n\n            def save(self):\n                called_save.append(True)\n\n            def write_cells(self, *args, **kwargs):\n                called_write_cells.append(True)\n\n        def check_called(func):\n            func()\n            assert len(called_save) >= 1\n            assert len(called_write_cells) >= 1\n            del called_save[:]\n            del called_write_cells[:]\n\n        with pd.option_context(\"io.excel.xlsx.writer\", \"dummy\"):\n            register_writer(DummyClass)\n            writer = ExcelWriter(\"something.xlsx\")\n            assert isinstance(writer, DummyClass)\n            df = tm.makeCustomDataframe(1, 1)\n            check_called(lambda: df.to_excel(\"something.xlsx\"))\n            check_called(lambda: df.to_excel(\"something.xls\", engine=\"dummy\"))",
        "begin_line": 1277,
        "end_line": 1307,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.DummyClass.save#1288",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.DummyClass",
        "signature": "pandas.tests.io.excel.test_writers.DummyClass.save(self)",
        "snippet": "            def save(self):\n                called_save.append(True)",
        "begin_line": 1288,
        "end_line": 1289,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.DummyClass.write_cells#1291",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.DummyClass",
        "signature": "pandas.tests.io.excel.test_writers.DummyClass.write_cells(self, *args, **kwargs)",
        "snippet": "            def write_cells(self, *args, **kwargs):\n                called_write_cells.append(True)",
        "begin_line": 1291,
        "end_line": 1292,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestExcelWriterEngineTests.check_called#1294",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestExcelWriterEngineTests",
        "signature": "pandas.tests.io.excel.test_writers.TestExcelWriterEngineTests.check_called(func)",
        "snippet": "        def check_called(func):\n            func()\n            assert len(called_save) >= 1\n            assert len(called_write_cells) >= 1\n            del called_save[:]\n            del called_write_cells[:]",
        "begin_line": 1294,
        "end_line": 1299,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestFSPath.test_excelfile_fspath#1313",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestFSPath",
        "signature": "pandas.tests.io.excel.test_writers.TestFSPath.test_excelfile_fspath(self)",
        "snippet": "    def test_excelfile_fspath(self):\n        with tm.ensure_clean(\"foo.xlsx\") as path:\n            df = DataFrame({\"A\": [1, 2]})\n            df.to_excel(path)\n            xl = ExcelFile(path)\n            result = os.fspath(xl)\n            assert result == path",
        "begin_line": 1313,
        "end_line": 1319,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.excel.test_writers.TestFSPath.test_excelwriter_fspath#1321",
        "src_path": "pandas/tests/io/excel/test_writers.py",
        "class_name": "pandas.tests.io.excel.test_writers.TestFSPath",
        "signature": "pandas.tests.io.excel.test_writers.TestFSPath.test_excelwriter_fspath(self)",
        "snippet": "    def test_excelwriter_fspath(self):\n        with tm.ensure_clean(\"foo.xlsx\") as path:\n            writer = ExcelWriter(path)\n            assert os.fspath(writer) == str(path)",
        "begin_line": 1321,
        "end_line": 1324,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.conftest.orient#5",
        "src_path": "pandas/tests/io/json/conftest.py",
        "class_name": "pandas.tests.io.json.conftest",
        "signature": "pandas.tests.io.json.conftest.orient(request)",
        "snippet": "def orient(request):\n    \"\"\"\n    Fixture for orients excluding the table format.\n    \"\"\"\n    return request.param",
        "begin_line": 5,
        "end_line": 9,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files._create_sp_series#96",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files._create_sp_series()",
        "snippet": "def _create_sp_series():\n    nan = np.nan\n\n    # nan-based\n    arr = np.arange(15, dtype=np.float64)\n    arr[7:12] = nan\n    arr[-1:] = nan\n\n    bseries = Series(SparseArray(arr, kind=\"block\"))\n    bseries.name = \"bseries\"\n    return bseries",
        "begin_line": 96,
        "end_line": 106,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files._create_sp_tsseries#109",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files._create_sp_tsseries()",
        "snippet": "def _create_sp_tsseries():\n    nan = np.nan\n\n    # nan-based\n    arr = np.arange(15, dtype=np.float64)\n    arr[7:12] = nan\n    arr[-1:] = nan\n\n    date_index = bdate_range(\"1/1/2011\", periods=len(arr))\n    bseries = Series(SparseArray(arr, kind=\"block\"), index=date_index)\n    bseries.name = \"btsseries\"\n    return bseries",
        "begin_line": 109,
        "end_line": 120,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files._create_sp_frame#123",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files._create_sp_frame()",
        "snippet": "def _create_sp_frame():\n    nan = np.nan\n\n    data = {\n        \"A\": [nan, nan, nan, 0, 1, 2, 3, 4, 5, 6],\n        \"B\": [0, 1, 2, nan, nan, nan, 3, 4, 5, 6],\n        \"C\": np.arange(10).astype(np.int64),\n        \"D\": [0, 1, 2, 3, 4, 5, nan, nan, nan, nan],\n    }\n\n    dates = bdate_range(\"1/1/2011\", periods=10)\n    return DataFrame(data, index=dates).apply(SparseArray)",
        "begin_line": 123,
        "end_line": 134,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.create_data#137",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.create_data()",
        "snippet": "def create_data():\n    \"\"\" create the pickle data \"\"\"\n\n    data = {\n        \"A\": [0.0, 1.0, 2.0, 3.0, np.nan],\n        \"B\": [0, 1, 0, 1, 0],\n        \"C\": [\"foo1\", \"foo2\", \"foo3\", \"foo4\", \"foo5\"],\n        \"D\": date_range(\"1/1/2009\", periods=5),\n        \"E\": [0.0, 1, Timestamp(\"20100101\"), \"foo\", 2.0],\n    }\n\n    scalars = dict(timestamp=Timestamp(\"20130101\"), period=Period(\"2012\", \"M\"))\n\n    index = dict(\n        int=Index(np.arange(10)),\n        date=date_range(\"20130101\", periods=10),\n        period=period_range(\"2013-01-01\", freq=\"M\", periods=10),\n        float=Index(np.arange(10, dtype=np.float64)),\n        uint=Index(np.arange(10, dtype=np.uint64)),\n        timedelta=timedelta_range(\"00:00:00\", freq=\"30T\", periods=10),\n    )\n\n    index[\"range\"] = RangeIndex(10)\n\n    if _loose_version >= LooseVersion(\"0.21\"):\n        from pandas import interval_range\n\n        index[\"interval\"] = interval_range(0, periods=10)\n\n    mi = dict(\n        reg2=MultiIndex.from_tuples(\n            tuple(\n                zip(\n                    *[\n                        [\"bar\", \"bar\", \"baz\", \"baz\", \"foo\", \"foo\", \"qux\", \"qux\"],\n                        [\"one\", \"two\", \"one\", \"two\", \"one\", \"two\", \"one\", \"two\"],\n                    ]\n                )\n            ),\n            names=[\"first\", \"second\"],\n        )\n    )\n\n    series = dict(\n        float=Series(data[\"A\"]),\n        int=Series(data[\"B\"]),\n        mixed=Series(data[\"E\"]),\n        ts=Series(\n            np.arange(10).astype(np.int64), index=date_range(\"20130101\", periods=10)\n        ),\n        mi=Series(\n            np.arange(5).astype(np.float64),\n            index=MultiIndex.from_tuples(\n                tuple(zip(*[[1, 1, 2, 2, 2], [3, 4, 3, 4, 5]])), names=[\"one\", \"two\"]\n            ),\n        ),\n        dup=Series(np.arange(5).astype(np.float64), index=[\"A\", \"B\", \"C\", \"D\", \"A\"]),\n        cat=Series(Categorical([\"foo\", \"bar\", \"baz\"])),\n        dt=Series(date_range(\"20130101\", periods=5)),\n        dt_tz=Series(date_range(\"20130101\", periods=5, tz=\"US/Eastern\")),\n        period=Series([Period(\"2000Q1\")] * 5),\n    )\n\n    mixed_dup_df = DataFrame(data)\n    mixed_dup_df.columns = list(\"ABCDA\")\n    frame = dict(\n        float=DataFrame({\"A\": series[\"float\"], \"B\": series[\"float\"] + 1}),\n        int=DataFrame({\"A\": series[\"int\"], \"B\": series[\"int\"] + 1}),\n        mixed=DataFrame({k: data[k] for k in [\"A\", \"B\", \"C\", \"D\"]}),\n        mi=DataFrame(\n            {\"A\": np.arange(5).astype(np.float64), \"B\": np.arange(5).astype(np.int64)},\n            index=MultiIndex.from_tuples(\n                tuple(\n                    zip(\n                        *[\n                            [\"bar\", \"bar\", \"baz\", \"baz\", \"baz\"],\n                            [\"one\", \"two\", \"one\", \"two\", \"three\"],\n                        ]\n                    )\n                ),\n                names=[\"first\", \"second\"],\n            ),\n        ),\n        dup=DataFrame(\n            np.arange(15).reshape(5, 3).astype(np.float64), columns=[\"A\", \"B\", \"A\"]\n        ),\n        cat_onecol=DataFrame({\"A\": Categorical([\"foo\", \"bar\"])}),\n        cat_and_float=DataFrame(\n            {\n                \"A\": Categorical([\"foo\", \"bar\", \"baz\"]),\n                \"B\": np.arange(3).astype(np.int64),\n            }\n        ),\n        mixed_dup=mixed_dup_df,\n        dt_mixed_tzs=DataFrame(\n            {\n                \"A\": Timestamp(\"20130102\", tz=\"US/Eastern\"),\n                \"B\": Timestamp(\"20130603\", tz=\"CET\"),\n            },\n            index=range(5),\n        ),\n        dt_mixed2_tzs=DataFrame(\n            {\n                \"A\": Timestamp(\"20130102\", tz=\"US/Eastern\"),\n                \"B\": Timestamp(\"20130603\", tz=\"CET\"),\n                \"C\": Timestamp(\"20130603\", tz=\"UTC\"),\n            },\n            index=range(5),\n        ),\n    )\n\n    cat = dict(\n        int8=Categorical(list(\"abcdefg\")),\n        int16=Categorical(np.arange(1000)),\n        int32=Categorical(np.arange(10000)),\n    )\n\n    timestamp = dict(\n        normal=Timestamp(\"2011-01-01\"),\n        nat=NaT,\n        tz=Timestamp(\"2011-01-01\", tz=\"US/Eastern\"),\n    )\n\n    timestamp[\"freq\"] = Timestamp(\"2011-01-01\", freq=\"D\")\n    timestamp[\"both\"] = Timestamp(\"2011-01-01\", tz=\"Asia/Tokyo\", freq=\"M\")\n\n    off = {\n        \"DateOffset\": DateOffset(years=1),\n        \"DateOffset_h_ns\": DateOffset(hour=6, nanoseconds=5824),\n        \"BusinessDay\": BusinessDay(offset=timedelta(seconds=9)),\n        \"BusinessHour\": BusinessHour(normalize=True, n=6, end=\"15:14\"),\n        \"CustomBusinessDay\": CustomBusinessDay(weekmask=\"Mon Fri\"),\n        \"SemiMonthBegin\": SemiMonthBegin(day_of_month=9),\n        \"SemiMonthEnd\": SemiMonthEnd(day_of_month=24),\n        \"MonthBegin\": MonthBegin(1),\n        \"MonthEnd\": MonthEnd(1),\n        \"QuarterBegin\": QuarterBegin(1),\n        \"QuarterEnd\": QuarterEnd(1),\n        \"Day\": Day(1),\n        \"YearBegin\": YearBegin(1),\n        \"YearEnd\": YearEnd(1),\n        \"Week\": Week(1),\n        \"Week_Tues\": Week(2, normalize=False, weekday=1),\n        \"WeekOfMonth\": WeekOfMonth(week=3, weekday=4),\n        \"LastWeekOfMonth\": LastWeekOfMonth(n=1, weekday=3),\n        \"FY5253\": FY5253(n=2, weekday=6, startingMonth=7, variation=\"last\"),\n        \"Easter\": Easter(),\n        \"Hour\": Hour(1),\n        \"Minute\": Minute(1),\n    }\n\n    return dict(\n        series=series,\n        frame=frame,\n        index=index,\n        scalars=scalars,\n        mi=mi,\n        sp_series=dict(float=_create_sp_series(), ts=_create_sp_tsseries()),\n        sp_frame=dict(float=_create_sp_frame()),\n        cat=cat,\n        timestamp=timestamp,\n        offsets=off,\n    )",
        "begin_line": 137,
        "end_line": 299,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.create_pickle_data#302",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.create_pickle_data()",
        "snippet": "def create_pickle_data():\n    data = create_data()\n\n    return data",
        "begin_line": 302,
        "end_line": 305,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.platform_name#308",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.platform_name()",
        "snippet": "def platform_name():\n    return \"_\".join(\n        [\n            str(pandas.__version__),\n            str(pl.machine()),\n            str(pl.system().lower()),\n            str(pl.python_version()),\n        ]\n    )",
        "begin_line": 308,
        "end_line": 316,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.write_legacy_pickles#319",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.write_legacy_pickles(output_dir)",
        "snippet": "def write_legacy_pickles(output_dir):\n\n    version = pandas.__version__\n\n    print(\n        \"This script generates a storage file for the current arch, system, \"\n        \"and python version\"\n    )\n    print(\"  pandas version: {0}\".format(version))\n    print(\"  output dir    : {0}\".format(output_dir))\n    print(\"  storage format: pickle\")\n\n    pth = \"{0}.pickle\".format(platform_name())\n\n    fh = open(os.path.join(output_dir, pth), \"wb\")\n    pickle.dump(create_pickle_data(), fh, pickle.HIGHEST_PROTOCOL)\n    fh.close()\n\n    print(\"created pickle file: {pth}\".format(pth=pth))",
        "begin_line": 319,
        "end_line": 337,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.write_legacy_file#340",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.write_legacy_file()",
        "snippet": "def write_legacy_file():\n    # force our cwd to be the first searched\n    sys.path.insert(0, \".\")\n\n    if not (3 <= len(sys.argv) <= 4):\n        exit(\n            \"Specify output directory and storage type: generate_legacy_\"\n            \"storage_files.py <output_dir> <storage_type> \"\n        )\n\n    output_dir = str(sys.argv[1])\n    storage_type = str(sys.argv[2])\n\n    if storage_type == \"pickle\":\n        write_legacy_pickles(output_dir=output_dir)\n    else:\n        exit(\"storage_type must be one of {'pickle'}\")",
        "begin_line": 340,
        "end_line": 356,
        "comment": "",
        "is_bug": false
    }
]