[
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_namespace_accessor#33",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_namespace_accessor(self)",
        "snippet": "    def test_dt_namespace_accessor(self):\n\n        # GH 7207, 11128\n        # test .dt namespace accessor\n\n        ok_for_period = PeriodArray._datetimelike_ops\n        ok_for_period_methods = [\"strftime\", \"to_timestamp\", \"asfreq\"]\n        ok_for_dt = DatetimeIndex._datetimelike_ops\n        ok_for_dt_methods = [\n            \"to_period\",\n            \"to_pydatetime\",\n            \"tz_localize\",\n            \"tz_convert\",\n            \"normalize\",\n            \"strftime\",\n            \"round\",\n            \"floor\",\n            \"ceil\",\n            \"day_name\",\n            \"month_name\",\n        ]\n        ok_for_td = TimedeltaIndex._datetimelike_ops\n        ok_for_td_methods = [\n            \"components\",\n            \"to_pytimedelta\",\n            \"total_seconds\",\n            \"round\",\n            \"floor\",\n            \"ceil\",\n        ]\n\n        def get_expected(s, name):\n            result = getattr(Index(s._values), prop)\n            if isinstance(result, np.ndarray):\n                if is_integer_dtype(result):\n                    result = result.astype(\"int64\")\n            elif not is_list_like(result):\n                return result\n            return Series(result, index=s.index, name=s.name)\n\n        def compare(s, name):\n            a = getattr(s.dt, prop)\n            b = get_expected(s, prop)\n            if not (is_list_like(a) and is_list_like(b)):\n                assert a == b\n            else:\n                tm.assert_series_equal(a, b)\n\n        # datetimeindex\n        cases = [\n            Series(date_range(\"20130101\", periods=5), name=\"xxx\"),\n            Series(date_range(\"20130101\", periods=5, freq=\"s\"), name=\"xxx\"),\n            Series(date_range(\"20130101 00:00:00\", periods=5, freq=\"ms\"), name=\"xxx\"),\n        ]\n        for s in cases:\n            for prop in ok_for_dt:\n                # we test freq below\n                if prop != \"freq\":\n                    compare(s, prop)\n\n            for prop in ok_for_dt_methods:\n                getattr(s.dt, prop)\n\n            result = s.dt.to_pydatetime()\n            assert isinstance(result, np.ndarray)\n            assert result.dtype == object\n\n            result = s.dt.tz_localize(\"US/Eastern\")\n            exp_values = DatetimeIndex(s.values).tz_localize(\"US/Eastern\")\n            expected = Series(exp_values, index=s.index, name=\"xxx\")\n            tm.assert_series_equal(result, expected)\n\n            tz_result = result.dt.tz\n            assert str(tz_result) == \"US/Eastern\"\n            freq_result = s.dt.freq\n            assert freq_result == DatetimeIndex(s.values, freq=\"infer\").freq\n\n            # let's localize, then convert\n            result = s.dt.tz_localize(\"UTC\").dt.tz_convert(\"US/Eastern\")\n            exp_values = (\n                DatetimeIndex(s.values).tz_localize(\"UTC\").tz_convert(\"US/Eastern\")\n            )\n            expected = Series(exp_values, index=s.index, name=\"xxx\")\n            tm.assert_series_equal(result, expected)\n\n        # datetimeindex with tz\n        s = Series(date_range(\"20130101\", periods=5, tz=\"US/Eastern\"), name=\"xxx\")\n        for prop in ok_for_dt:\n\n            # we test freq below\n            if prop != \"freq\":\n                compare(s, prop)\n\n        for prop in ok_for_dt_methods:\n            getattr(s.dt, prop)\n\n        result = s.dt.to_pydatetime()\n        assert isinstance(result, np.ndarray)\n        assert result.dtype == object\n\n        result = s.dt.tz_convert(\"CET\")\n        expected = Series(s._values.tz_convert(\"CET\"), index=s.index, name=\"xxx\")\n        tm.assert_series_equal(result, expected)\n\n        tz_result = result.dt.tz\n        assert str(tz_result) == \"CET\"\n        freq_result = s.dt.freq\n        assert freq_result == DatetimeIndex(s.values, freq=\"infer\").freq\n\n        # timedelta index\n        cases = [\n            Series(\n                timedelta_range(\"1 day\", periods=5), index=list(\"abcde\"), name=\"xxx\"\n            ),\n            Series(timedelta_range(\"1 day 01:23:45\", periods=5, freq=\"s\"), name=\"xxx\"),\n            Series(\n                timedelta_range(\"2 days 01:23:45.012345\", periods=5, freq=\"ms\"),\n                name=\"xxx\",\n            ),\n        ]\n        for s in cases:\n            for prop in ok_for_td:\n                # we test freq below\n                if prop != \"freq\":\n                    compare(s, prop)\n\n            for prop in ok_for_td_methods:\n                getattr(s.dt, prop)\n\n            result = s.dt.components\n            assert isinstance(result, DataFrame)\n            tm.assert_index_equal(result.index, s.index)\n\n            result = s.dt.to_pytimedelta()\n            assert isinstance(result, np.ndarray)\n            assert result.dtype == object\n\n            result = s.dt.total_seconds()\n            assert isinstance(result, pd.Series)\n            assert result.dtype == \"float64\"\n\n            freq_result = s.dt.freq\n            assert freq_result == TimedeltaIndex(s.values, freq=\"infer\").freq\n\n        # both\n        index = date_range(\"20130101\", periods=3, freq=\"D\")\n        s = Series(date_range(\"20140204\", periods=3, freq=\"s\"), index=index, name=\"xxx\")\n        exp = Series(\n            np.array([2014, 2014, 2014], dtype=\"int64\"), index=index, name=\"xxx\"\n        )\n        tm.assert_series_equal(s.dt.year, exp)\n\n        exp = Series(np.array([2, 2, 2], dtype=\"int64\"), index=index, name=\"xxx\")\n        tm.assert_series_equal(s.dt.month, exp)\n\n        exp = Series(np.array([0, 1, 2], dtype=\"int64\"), index=index, name=\"xxx\")\n        tm.assert_series_equal(s.dt.second, exp)\n\n        exp = pd.Series([s[0]] * 3, index=index, name=\"xxx\")\n        tm.assert_series_equal(s.dt.normalize(), exp)\n\n        # periodindex\n        cases = [Series(period_range(\"20130101\", periods=5, freq=\"D\"), name=\"xxx\")]\n        for s in cases:\n            for prop in ok_for_period:\n                # we test freq below\n                if prop != \"freq\":\n                    compare(s, prop)\n\n            for prop in ok_for_period_methods:\n                getattr(s.dt, prop)\n\n            freq_result = s.dt.freq\n            assert freq_result == PeriodIndex(s.values).freq\n\n        # test limited display api\n        def get_dir(s):\n            results = [r for r in s.dt.__dir__() if not r.startswith(\"_\")]\n            return list(sorted(set(results)))\n\n        s = Series(date_range(\"20130101\", periods=5, freq=\"D\"), name=\"xxx\")\n        results = get_dir(s)\n        tm.assert_almost_equal(\n            results, list(sorted(set(ok_for_dt + ok_for_dt_methods)))\n        )\n\n        s = Series(\n            period_range(\"20130101\", periods=5, freq=\"D\", name=\"xxx\").astype(object)\n        )\n        results = get_dir(s)\n        tm.assert_almost_equal(\n            results, list(sorted(set(ok_for_period + ok_for_period_methods)))\n        )\n\n        # 11295\n        # ambiguous time error on the conversions\n        s = Series(pd.date_range(\"2015-01-01\", \"2016-01-01\", freq=\"T\"), name=\"xxx\")\n        s = s.dt.tz_localize(\"UTC\").dt.tz_convert(\"America/Chicago\")\n        results = get_dir(s)\n        tm.assert_almost_equal(\n            results, list(sorted(set(ok_for_dt + ok_for_dt_methods)))\n        )\n        exp_values = pd.date_range(\n            \"2015-01-01\", \"2016-01-01\", freq=\"T\", tz=\"UTC\"\n        ).tz_convert(\"America/Chicago\")\n        expected = Series(exp_values, name=\"xxx\")\n        tm.assert_series_equal(s, expected)\n\n        # no setting allowed\n        s = Series(date_range(\"20130101\", periods=5, freq=\"D\"), name=\"xxx\")\n        with pytest.raises(ValueError, match=\"modifications\"):\n            s.dt.hour = 5\n\n        # trying to set a copy\n        with pd.option_context(\"chained_assignment\", \"raise\"):\n            with pytest.raises(com.SettingWithCopyError):\n                s.dt.hour[0] = 5",
        "begin_line": 33,
        "end_line": 249,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.get_expected#64",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.get_expected(s, name)",
        "snippet": "        def get_expected(s, name):\n            result = getattr(Index(s._values), prop)\n            if isinstance(result, np.ndarray):\n                if is_integer_dtype(result):\n                    result = result.astype(\"int64\")\n            elif not is_list_like(result):\n                return result\n            return Series(result, index=s.index, name=s.name)",
        "begin_line": 64,
        "end_line": 71,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.compare#73",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.compare(s, name)",
        "snippet": "        def compare(s, name):\n            a = getattr(s.dt, prop)\n            b = get_expected(s, prop)\n            if not (is_list_like(a) and is_list_like(b)):\n                assert a == b\n            else:\n                tm.assert_series_equal(a, b)",
        "begin_line": 73,
        "end_line": 79,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.get_dir#209",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.get_dir(s)",
        "snippet": "        def get_dir(s):\n            results = [r for r in s.dt.__dir__() if not r.startswith(\"_\")]\n            return list(sorted(set(results)))",
        "begin_line": 209,
        "end_line": 211,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_round#259",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_round(self, method, dates)",
        "snippet": "    def test_dt_round(self, method, dates):\n        # round\n        s = Series(\n            pd.to_datetime(\n                [\"2012-01-01 13:00:00\", \"2012-01-01 12:01:00\", \"2012-01-01 08:00:00\"]\n            ),\n            name=\"xxx\",\n        )\n        result = getattr(s.dt, method)(\"D\")\n        expected = Series(pd.to_datetime(dates), name=\"xxx\")\n        tm.assert_series_equal(result, expected)",
        "begin_line": 259,
        "end_line": 269,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_round_tz#271",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_round_tz(self)",
        "snippet": "    def test_dt_round_tz(self):\n        s = Series(\n            pd.to_datetime(\n                [\"2012-01-01 13:00:00\", \"2012-01-01 12:01:00\", \"2012-01-01 08:00:00\"]\n            ),\n            name=\"xxx\",\n        )\n        result = s.dt.tz_localize(\"UTC\").dt.tz_convert(\"US/Eastern\").dt.round(\"D\")\n\n        exp_values = pd.to_datetime(\n            [\"2012-01-01\", \"2012-01-01\", \"2012-01-01\"]\n        ).tz_localize(\"US/Eastern\")\n        expected = Series(exp_values, name=\"xxx\")\n        tm.assert_series_equal(result, expected)",
        "begin_line": 271,
        "end_line": 284,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_round_tz_ambiguous#287",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_round_tz_ambiguous(self, method)",
        "snippet": "    def test_dt_round_tz_ambiguous(self, method):\n        # GH 18946 round near \"fall back\" DST\n        df1 = pd.DataFrame(\n            [\n                pd.to_datetime(\"2017-10-29 02:00:00+02:00\", utc=True),\n                pd.to_datetime(\"2017-10-29 02:00:00+01:00\", utc=True),\n                pd.to_datetime(\"2017-10-29 03:00:00+01:00\", utc=True),\n            ],\n            columns=[\"date\"],\n        )\n        df1[\"date\"] = df1[\"date\"].dt.tz_convert(\"Europe/Madrid\")\n        # infer\n        result = getattr(df1.date.dt, method)(\"H\", ambiguous=\"infer\")\n        expected = df1[\"date\"]\n        tm.assert_series_equal(result, expected)\n\n        # bool-array\n        result = getattr(df1.date.dt, method)(\"H\", ambiguous=[True, False, False])\n        tm.assert_series_equal(result, expected)\n\n        # NaT\n        result = getattr(df1.date.dt, method)(\"H\", ambiguous=\"NaT\")\n        expected = df1[\"date\"].copy()\n        expected.iloc[0:2] = pd.NaT\n        tm.assert_series_equal(result, expected)\n\n        # raise\n        with pytest.raises(pytz.AmbiguousTimeError):\n            getattr(df1.date.dt, method)(\"H\", ambiguous=\"raise\")",
        "begin_line": 287,
        "end_line": 315,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_round_tz_nonexistent#325",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_round_tz_nonexistent(self, method, ts_str, freq)",
        "snippet": "    def test_dt_round_tz_nonexistent(self, method, ts_str, freq):\n        # GH 23324 round near \"spring forward\" DST\n        s = Series([pd.Timestamp(ts_str, tz=\"America/Chicago\")])\n        result = getattr(s.dt, method)(freq, nonexistent=\"shift_forward\")\n        expected = Series([pd.Timestamp(\"2018-03-11 03:00:00\", tz=\"America/Chicago\")])\n        tm.assert_series_equal(result, expected)\n\n        result = getattr(s.dt, method)(freq, nonexistent=\"NaT\")\n        expected = Series([pd.NaT]).dt.tz_localize(result.dt.tz)\n        tm.assert_series_equal(result, expected)\n\n        with pytest.raises(pytz.NonExistentTimeError, match=\"2018-03-11 02:00:00\"):\n            getattr(s.dt, method)(freq, nonexistent=\"raise\")",
        "begin_line": 325,
        "end_line": 337,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_namespace_accessor_categorical#339",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_namespace_accessor_categorical(self)",
        "snippet": "    def test_dt_namespace_accessor_categorical(self):\n        # GH 19468\n        dti = DatetimeIndex([\"20171111\", \"20181212\"]).repeat(2)\n        s = Series(pd.Categorical(dti), name=\"foo\")\n        result = s.dt.year\n        expected = Series([2017, 2017, 2018, 2018], name=\"foo\")\n        tm.assert_series_equal(result, expected)",
        "begin_line": 339,
        "end_line": 345,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_tz_localize_categorical#347",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_tz_localize_categorical(self, tz_aware_fixture)",
        "snippet": "    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 347,
        "end_line": 356,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_tz_convert_categorical#358",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_tz_convert_categorical(self, tz_aware_fixture)",
        "snippet": "    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 358,
        "end_line": 367,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_other_accessors_categorical#370",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_other_accessors_categorical(self, accessor)",
        "snippet": "    def test_dt_other_accessors_categorical(self, accessor):\n        # GH 27952\n        datetimes = pd.Series(\n            [\"2018-01-01\", \"2018-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = getattr(categorical.dt, accessor)\n        expected = getattr(datetimes.dt, accessor)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 370,
        "end_line": 378,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_accessor_no_new_attributes#380",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_accessor_no_new_attributes(self)",
        "snippet": "    def test_dt_accessor_no_new_attributes(self):\n        # https://github.com/pandas-dev/pandas/issues/10673\n        s = Series(date_range(\"20130101\", periods=5, freq=\"D\"))\n        with pytest.raises(AttributeError, match=\"You cannot add any new attribute\"):\n            s.dt.xlabel = \"a\"",
        "begin_line": 380,
        "end_line": 384,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_accessor_datetime_name_accessors#389",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_accessor_datetime_name_accessors(self, time_locale)",
        "snippet": "    def test_dt_accessor_datetime_name_accessors(self, time_locale):\n        # Test Monday -> Sunday and January -> December, in that sequence\n        if time_locale is None:\n            # If the time_locale is None, day-name and month_name should\n            # return the english attributes\n            expected_days = [\n                \"Monday\",\n                \"Tuesday\",\n                \"Wednesday\",\n                \"Thursday\",\n                \"Friday\",\n                \"Saturday\",\n                \"Sunday\",\n            ]\n            expected_months = [\n                \"January\",\n                \"February\",\n                \"March\",\n                \"April\",\n                \"May\",\n                \"June\",\n                \"July\",\n                \"August\",\n                \"September\",\n                \"October\",\n                \"November\",\n                \"December\",\n            ]\n        else:\n            with tm.set_locale(time_locale, locale.LC_TIME):\n                expected_days = calendar.day_name[:]\n                expected_months = calendar.month_name[1:]\n\n        s = Series(date_range(freq=\"D\", start=datetime(1998, 1, 1), periods=365))\n        english_days = [\n            \"Monday\",\n            \"Tuesday\",\n            \"Wednesday\",\n            \"Thursday\",\n            \"Friday\",\n            \"Saturday\",\n            \"Sunday\",\n        ]\n        for day, name, eng_name in zip(range(4, 11), expected_days, english_days):\n            name = name.capitalize()\n            assert s.dt.weekday_name[day] == eng_name\n            assert s.dt.day_name(locale=time_locale)[day] == name\n        s = s.append(Series([pd.NaT]))\n        assert np.isnan(s.dt.day_name(locale=time_locale).iloc[-1])\n\n        s = Series(date_range(freq=\"M\", start=\"2012\", end=\"2013\"))\n        result = s.dt.month_name(locale=time_locale)\n        expected = Series([month.capitalize() for month in expected_months])\n\n        # work around https://github.com/pandas-dev/pandas/issues/22342\n        result = result.str.normalize(\"NFD\")\n        expected = expected.str.normalize(\"NFD\")\n\n        tm.assert_series_equal(result, expected)\n\n        for s_date, expected in zip(s, expected_months):\n            result = s_date.month_name(locale=time_locale)\n            expected = expected.capitalize()\n\n            result = unicodedata.normalize(\"NFD\", result)\n            expected = unicodedata.normalize(\"NFD\", expected)\n\n            assert result == expected\n\n        s = s.append(Series([pd.NaT]))\n        assert np.isnan(s.dt.month_name(locale=time_locale).iloc[-1])",
        "begin_line": 389,
        "end_line": 459,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_strftime#461",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_strftime(self)",
        "snippet": "    def test_strftime(self):\n        # GH 10086\n        s = Series(date_range(\"20130101\", periods=5))\n        result = s.dt.strftime(\"%Y/%m/%d\")\n        expected = Series(\n            [\"2013/01/01\", \"2013/01/02\", \"2013/01/03\", \"2013/01/04\", \"2013/01/05\"]\n        )\n        tm.assert_series_equal(result, expected)\n\n        s = Series(date_range(\"2015-02-03 11:22:33.4567\", periods=5))\n        result = s.dt.strftime(\"%Y/%m/%d %H-%M-%S\")\n        expected = Series(\n            [\n                \"2015/02/03 11-22-33\",\n                \"2015/02/04 11-22-33\",\n                \"2015/02/05 11-22-33\",\n                \"2015/02/06 11-22-33\",\n                \"2015/02/07 11-22-33\",\n            ]\n        )\n        tm.assert_series_equal(result, expected)\n\n        s = Series(period_range(\"20130101\", periods=5))\n        result = s.dt.strftime(\"%Y/%m/%d\")\n        expected = Series(\n            [\"2013/01/01\", \"2013/01/02\", \"2013/01/03\", \"2013/01/04\", \"2013/01/05\"]\n        )\n        tm.assert_series_equal(result, expected)\n\n        s = Series(period_range(\"2015-02-03 11:22:33.4567\", periods=5, freq=\"s\"))\n        result = s.dt.strftime(\"%Y/%m/%d %H-%M-%S\")\n        expected = Series(\n            [\n                \"2015/02/03 11-22-33\",\n                \"2015/02/03 11-22-34\",\n                \"2015/02/03 11-22-35\",\n                \"2015/02/03 11-22-36\",\n                \"2015/02/03 11-22-37\",\n            ]\n        )\n        tm.assert_series_equal(result, expected)\n\n        s = Series(date_range(\"20130101\", periods=5))\n        s.iloc[0] = pd.NaT\n        result = s.dt.strftime(\"%Y/%m/%d\")\n        expected = Series(\n            [\"NaT\", \"2013/01/02\", \"2013/01/03\", \"2013/01/04\", \"2013/01/05\"]\n        )\n        tm.assert_series_equal(result, expected)\n\n        datetime_index = date_range(\"20150301\", periods=5)\n        result = datetime_index.strftime(\"%Y/%m/%d\")\n\n        expected = Index(\n            [\"2015/03/01\", \"2015/03/02\", \"2015/03/03\", \"2015/03/04\", \"2015/03/05\"],\n            dtype=np.object_,\n        )\n        # dtype may be S10 or U10 depending on python version\n        tm.assert_index_equal(result, expected)\n\n        period_index = period_range(\"20150301\", periods=5)\n        result = period_index.strftime(\"%Y/%m/%d\")\n        expected = Index(\n            [\"2015/03/01\", \"2015/03/02\", \"2015/03/03\", \"2015/03/04\", \"2015/03/05\"],\n            dtype=\"=U10\",\n        )\n        tm.assert_index_equal(result, expected)\n\n        s = Series([datetime(2013, 1, 1, 2, 32, 59), datetime(2013, 1, 2, 14, 32, 1)])\n        result = s.dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n        expected = Series([\"2013-01-01 02:32:59\", \"2013-01-02 14:32:01\"])\n        tm.assert_series_equal(result, expected)\n\n        s = Series(period_range(\"20130101\", periods=4, freq=\"H\"))\n        result = s.dt.strftime(\"%Y/%m/%d %H:%M:%S\")\n        expected = Series(\n            [\n                \"2013/01/01 00:00:00\",\n                \"2013/01/01 01:00:00\",\n                \"2013/01/01 02:00:00\",\n                \"2013/01/01 03:00:00\",\n            ]\n        )\n\n        s = Series(period_range(\"20130101\", periods=4, freq=\"L\"))\n        result = s.dt.strftime(\"%Y/%m/%d %H:%M:%S.%l\")\n        expected = Series(\n            [\n                \"2013/01/01 00:00:00.000\",\n                \"2013/01/01 00:00:00.001\",\n                \"2013/01/01 00:00:00.002\",\n                \"2013/01/01 00:00:00.003\",\n            ]\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 461,
        "end_line": 555,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_valid_dt_with_missing_values#557",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_valid_dt_with_missing_values(self)",
        "snippet": "    def test_valid_dt_with_missing_values(self):\n\n        from datetime import date, time\n\n        # GH 8689\n        s = Series(date_range(\"20130101\", periods=5, freq=\"D\"))\n        s.iloc[2] = pd.NaT\n\n        for attr in [\"microsecond\", \"nanosecond\", \"second\", \"minute\", \"hour\", \"day\"]:\n            expected = getattr(s.dt, attr).copy()\n            expected.iloc[2] = np.nan\n            result = getattr(s.dt, attr)\n            tm.assert_series_equal(result, expected)\n\n        result = s.dt.date\n        expected = Series(\n            [\n                date(2013, 1, 1),\n                date(2013, 1, 2),\n                np.nan,\n                date(2013, 1, 4),\n                date(2013, 1, 5),\n            ],\n            dtype=\"object\",\n        )\n        tm.assert_series_equal(result, expected)\n\n        result = s.dt.time\n        expected = Series([time(0), time(0), np.nan, time(0), time(0)], dtype=\"object\")\n        tm.assert_series_equal(result, expected)",
        "begin_line": 557,
        "end_line": 586,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_accessor_api#588",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_accessor_api(self)",
        "snippet": "    def test_dt_accessor_api(self):\n        # GH 9322\n        from pandas.core.indexes.accessors import (\n            CombinedDatetimelikeProperties,\n            DatetimeProperties,\n        )\n\n        assert Series.dt is CombinedDatetimelikeProperties\n\n        s = Series(date_range(\"2000-01-01\", periods=3))\n        assert isinstance(s.dt, DatetimeProperties)",
        "begin_line": 588,
        "end_line": 598,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_accessor_invalid#603",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_accessor_invalid(self, ser)",
        "snippet": "    def test_dt_accessor_invalid(self, ser):\n        # GH#9322 check that series with incorrect dtypes don't have attr\n        with pytest.raises(AttributeError, match=\"only use .dt accessor\"):\n            ser.dt\n        assert not hasattr(ser, \"dt\")",
        "begin_line": 603,
        "end_line": 607,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_accessor_updates_on_inplace#609",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_accessor_updates_on_inplace(self)",
        "snippet": "    def test_dt_accessor_updates_on_inplace(self):\n        s = Series(pd.date_range(\"2018-01-01\", periods=10))\n        s[2] = None\n        s.fillna(pd.Timestamp(\"2018-01-01\"), inplace=True)\n        result = s.dt.date\n        assert result[0] == result[2]",
        "begin_line": 609,
        "end_line": 614,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_between#616",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_between(self)",
        "snippet": "    def test_between(self):\n        s = Series(bdate_range(\"1/1/2000\", periods=20).astype(object))\n        s[::2] = np.nan\n\n        result = s[s.between(s[3], s[17])]\n        expected = s[3:18].dropna()\n        tm.assert_series_equal(result, expected)\n\n        result = s[s.between(s[3], s[17], inclusive=False)]\n        expected = s[5:16].dropna()\n        tm.assert_series_equal(result, expected)",
        "begin_line": 616,
        "end_line": 626,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_date_tz#628",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_date_tz(self)",
        "snippet": "    def test_date_tz(self):\n        # GH11757\n        rng = pd.DatetimeIndex(\n            [\"2014-04-04 23:56\", \"2014-07-18 21:24\", \"2015-11-22 22:14\"],\n            tz=\"US/Eastern\",\n        )\n        s = Series(rng)\n        expected = Series([date(2014, 4, 4), date(2014, 7, 18), date(2015, 11, 22)])\n        tm.assert_series_equal(s.dt.date, expected)\n        tm.assert_series_equal(s.apply(lambda x: x.date()), expected)",
        "begin_line": 628,
        "end_line": 637,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_datetime_understood#639",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_datetime_understood(self)",
        "snippet": "    def test_datetime_understood(self):\n        # Ensures it doesn't fail to create the right series\n        # reported in issue#16726\n        series = pd.Series(pd.date_range(\"2012-01-01\", periods=3))\n        offset = pd.offsets.DateOffset(days=6)\n        result = series - offset\n        expected = pd.Series(pd.to_datetime([\"2011-12-26\", \"2011-12-27\", \"2011-12-28\"]))\n        tm.assert_series_equal(result, expected)",
        "begin_line": 639,
        "end_line": 646,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_timetz_accessor#648",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_dt_timetz_accessor(self, tz_naive_fixture)",
        "snippet": "    def test_dt_timetz_accessor(self, tz_naive_fixture):\n        # GH21358\n        tz = maybe_get_tz(tz_naive_fixture)\n\n        dtindex = pd.DatetimeIndex(\n            [\"2014-04-04 23:56\", \"2014-07-18 21:24\", \"2015-11-22 22:14\"], tz=tz\n        )\n        s = Series(dtindex)\n        expected = Series(\n            [time(23, 56, tzinfo=tz), time(21, 24, tzinfo=tz), time(22, 14, tzinfo=tz)]\n        )\n        result = s.dt.timetz\n        tm.assert_series_equal(result, expected)",
        "begin_line": 648,
        "end_line": 660,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_setitem_with_string_index#662",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_setitem_with_string_index(self)",
        "snippet": "    def test_setitem_with_string_index(self):\n        # GH 23451\n        x = pd.Series([1, 2, 3], index=[\"Date\", \"b\", \"other\"])\n        x[\"Date\"] = date.today()\n        assert x.Date == date.today()\n        assert x[\"Date\"] == date.today()",
        "begin_line": 662,
        "end_line": 667,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_setitem_with_different_tz#669",
        "src_path": "pandas/tests/series/test_datetime_values.py",
        "class_name": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues",
        "signature": "pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues.test_setitem_with_different_tz(self)",
        "snippet": "    def test_setitem_with_different_tz(self):\n        # GH#24024\n        ser = pd.Series(pd.date_range(\"2000\", periods=2, tz=\"US/Central\"))\n        ser[0] = pd.Timestamp(\"2000\", tz=\"US/Eastern\")\n        expected = pd.Series(\n            [\n                pd.Timestamp(\"2000-01-01 00:00:00-05:00\", tz=\"US/Eastern\"),\n                pd.Timestamp(\"2000-01-02 00:00:00-06:00\", tz=\"US/Central\"),\n            ],\n            dtype=object,\n        )\n        tm.assert_series_equal(ser, expected)",
        "begin_line": 669,
        "end_line": 680,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.conftest.datetime_series#7",
        "src_path": "pandas/tests/series/conftest.py",
        "class_name": "pandas.tests.series.conftest",
        "signature": "pandas.tests.series.conftest.datetime_series()",
        "snippet": "def datetime_series():\n    \"\"\"\n    Fixture for Series of floats with DatetimeIndex\n    \"\"\"\n    s = tm.makeTimeSeries()\n    s.name = \"ts\"\n    return s",
        "begin_line": 7,
        "end_line": 13,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.conftest.string_series#17",
        "src_path": "pandas/tests/series/conftest.py",
        "class_name": "pandas.tests.series.conftest",
        "signature": "pandas.tests.series.conftest.string_series()",
        "snippet": "def string_series():\n    \"\"\"\n    Fixture for Series of floats with Index of unique strings\n    \"\"\"\n    s = tm.makeStringSeries()\n    s.name = \"series\"\n    return s",
        "begin_line": 17,
        "end_line": 23,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.series.conftest.object_series#27",
        "src_path": "pandas/tests/series/conftest.py",
        "class_name": "pandas.tests.series.conftest",
        "signature": "pandas.tests.series.conftest.object_series()",
        "snippet": "def object_series():\n    \"\"\"\n    Fixture for Series of dtype object with Index of unique strings\n    \"\"\"\n    s = tm.makeObjectSeries()\n    s.name = \"objects\"\n    return s",
        "begin_line": 27,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    }
]