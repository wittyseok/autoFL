[
    {
        "name": "pandas.tests.frame.conftest.close_open_fixture#11",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.close_open_fixture(request)",
        "snippet": "def close_open_fixture(request):\n    return request.param",
        "begin_line": 11,
        "end_line": 12,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.float_frame_with_na#16",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.float_frame_with_na()",
        "snippet": "def float_frame_with_na():\n    \"\"\"\n    Fixture for DataFrame of floats with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']; some entries are missing\n\n                       A         B         C         D\n    ABwBzA0ljw -1.128865 -0.897161  0.046603  0.274997\n    DJiRzmbyQF  0.728869  0.233502  0.722431 -0.890872\n    neMgPD5UBF  0.486072 -1.027393 -0.031553  1.449522\n    0yWA4n8VeX -1.937191 -1.142531  0.805215 -0.462018\n    3slYUbbqU1  0.153260  1.164691  1.489795 -0.545826\n    soujjZ0A08       NaN       NaN       NaN       NaN\n    7W6NLGsjB9       NaN       NaN       NaN       NaN\n    ...              ...       ...       ...       ...\n    uhfeaNkCR1 -0.231210 -0.340472  0.244717 -0.901590\n    n6p7GYuBIV -0.419052  1.922721 -0.125361 -0.727717\n    ZhzAeY6p1y  1.234374 -1.425359 -0.827038 -0.633189\n    uWdPsORyUh  0.046738 -0.980445 -1.102965  0.605503\n    3DJA6aN590 -0.091018 -1.684734 -1.100900  0.215947\n    2GBPAzdbMk -2.883405 -1.021071  1.209877  1.633083\n    sHadBoyVHw -2.223032 -0.326384  0.258931  0.245517\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    # set some NAs\n    df.iloc[5:10] = np.nan\n    df.iloc[15:20, -2:] = np.nan\n    return df",
        "begin_line": 16,
        "end_line": 45,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.bool_frame_with_na#49",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.bool_frame_with_na()",
        "snippet": "def bool_frame_with_na():\n    \"\"\"\n    Fixture for DataFrame of booleans with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']; some entries are missing\n\n                    A      B      C      D\n    zBZxY2IDGd  False  False  False  False\n    IhBWBMWllt  False   True   True   True\n    ctjdvZSR6R   True  False   True   True\n    AVTujptmxb  False   True  False   True\n    G9lrImrSWq  False  False  False   True\n    sFFwdIUfz2    NaN    NaN    NaN    NaN\n    s15ptEJnRb    NaN    NaN    NaN    NaN\n    ...           ...    ...    ...    ...\n    UW41KkDyZ4   True   True  False  False\n    l9l6XkOdqV   True  False  False  False\n    X2MeZfzDYA  False   True  False  False\n    xWkIKU7vfX  False   True  False   True\n    QOhL6VmpGU  False  False  False   True\n    22PwkRJdat  False   True  False  False\n    kfboQ3VeIK   True  False   True  False\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData()) > 0\n    df = df.astype(object)\n    # set some NAs\n    df.iloc[5:10] = np.nan\n    df.iloc[15:20, -2:] = np.nan\n    return df",
        "begin_line": 49,
        "end_line": 79,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.int_frame#83",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.int_frame()",
        "snippet": "def int_frame():\n    \"\"\"\n    Fixture for DataFrame of ints with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']\n\n                A  B  C  D\n    vpBeWjM651  1  0  1  0\n    5JyxmrP1En -1  0  0  0\n    qEDaoD49U2 -1  1  0  0\n    m66TkTfsFe  0  0  0  0\n    EHPaNzEUFm -1  0 -1  0\n    fpRJCevQhi  2  0  0  0\n    OlQvnmfi3Q  0  0 -2  0\n    ...        .. .. .. ..\n    uB1FPlz4uP  0  0  0  1\n    EcSe6yNzCU  0  0 -1  0\n    L50VudaiI8 -1  1 -2  0\n    y3bpw4nwIp  0 -1  0  0\n    H0RdLLwrCT  1  1  0  0\n    rY82K0vMwm  0  0  0  0\n    1OPIUjnkjk  2  0  0  0\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame({k: v.astype(int) for k, v in tm.getSeriesData().items()})\n    # force these all to int64 to avoid platform testing issues\n    return DataFrame({c: s for c, s in df.items()}, dtype=np.int64)",
        "begin_line": 83,
        "end_line": 110,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.datetime_frame#114",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.datetime_frame()",
        "snippet": "def datetime_frame():\n    \"\"\"\n    Fixture for DataFrame of floats with DatetimeIndex\n\n    Columns are ['A', 'B', 'C', 'D']\n\n                       A         B         C         D\n    2000-01-03 -1.122153  0.468535  0.122226  1.693711\n    2000-01-04  0.189378  0.486100  0.007864 -1.216052\n    2000-01-05  0.041401 -0.835752 -0.035279 -0.414357\n    2000-01-06  0.430050  0.894352  0.090719  0.036939\n    2000-01-07 -0.620982 -0.668211 -0.706153  1.466335\n    2000-01-10 -0.752633  0.328434 -0.815325  0.699674\n    2000-01-11 -2.236969  0.615737 -0.829076 -1.196106\n    ...              ...       ...       ...       ...\n    2000-02-03  1.642618 -0.579288  0.046005  1.385249\n    2000-02-04 -0.544873 -1.160962 -0.284071 -1.418351\n    2000-02-07 -2.656149 -0.601387  1.410148  0.444150\n    2000-02-08 -1.201881 -1.289040  0.772992 -1.445300\n    2000-02-09  1.377373  0.398619  1.008453 -0.928207\n    2000-02-10  0.473194 -0.636677  0.984058  0.511519\n    2000-02-11 -0.965556  0.408313 -1.312844 -0.381948\n\n    [30 rows x 4 columns]\n    \"\"\"\n    return DataFrame(tm.getTimeSeriesData())",
        "begin_line": 114,
        "end_line": 139,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.float_string_frame#143",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.float_string_frame()",
        "snippet": "def float_string_frame():\n    \"\"\"\n    Fixture for DataFrame of floats and strings with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D', 'foo'].\n\n                       A         B         C         D  foo\n    w3orJvq07g -1.594062 -1.084273 -1.252457  0.356460  bar\n    PeukuVdmz2  0.109855 -0.955086 -0.809485  0.409747  bar\n    ahp2KvwiM8 -1.533729 -0.142519 -0.154666  1.302623  bar\n    3WSJ7BUCGd  2.484964  0.213829  0.034778 -2.327831  bar\n    khdAmufk0U -0.193480 -0.743518 -0.077987  0.153646  bar\n    LE2DZiFlrE -0.193566 -1.343194 -0.107321  0.959978  bar\n    HJXSJhVn7b  0.142590  1.257603 -0.659409 -0.223844  bar\n    ...              ...       ...       ...       ...  ...\n    9a1Vypttgw -1.316394  1.601354  0.173596  1.213196  bar\n    h5d1gVFbEy  0.609475  1.106738 -0.155271  0.294630  bar\n    mK9LsTQG92  1.303613  0.857040 -1.019153  0.369468  bar\n    oOLksd9gKH  0.558219 -0.134491 -0.289869 -0.951033  bar\n    9jgoOjKyHg  0.058270 -0.496110 -0.413212 -0.852659  bar\n    jZLDHclHAO  0.096298  1.267510  0.549206 -0.005235  bar\n    lR0nxDp1C2 -2.119350 -0.794384  0.544118  0.145849  bar\n\n    [30 rows x 5 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    df[\"foo\"] = \"bar\"\n    return df",
        "begin_line": 143,
        "end_line": 170,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_float_frame#174",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_float_frame()",
        "snippet": "def mixed_float_frame():\n    \"\"\"\n    Fixture for DataFrame of different float types with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D'].\n\n                       A         B         C         D\n    GI7bbDaEZe -0.237908 -0.246225 -0.468506  0.752993\n    KGp9mFepzA -1.140809 -0.644046 -1.225586  0.801588\n    VeVYLAb1l2 -1.154013 -1.677615  0.690430 -0.003731\n    kmPME4WKhO  0.979578  0.998274 -0.776367  0.897607\n    CPyopdXTiz  0.048119 -0.257174  0.836426  0.111266\n    0kJZQndAj0  0.274357 -0.281135 -0.344238  0.834541\n    tqdwQsaHG8 -0.979716 -0.519897  0.582031  0.144710\n    ...              ...       ...       ...       ...\n    7FhZTWILQj -2.906357  1.261039 -0.780273 -0.537237\n    4pUDPM4eGq -2.042512 -0.464382 -0.382080  1.132612\n    B8dUgUzwTi -1.506637 -0.364435  1.087891  0.297653\n    hErlVYjVv9  1.477453 -0.495515 -0.713867  1.438427\n    1BKN3o7YLs  0.127535 -0.349812 -0.881836  0.489827\n    9S4Ekn7zga  1.445518 -2.095149  0.031982  0.373204\n    xN1dNn6OV6  1.425017 -0.983995 -0.363281 -0.224502\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    df.A = df.A.astype(\"float32\")\n    df.B = df.B.astype(\"float32\")\n    df.C = df.C.astype(\"float16\")\n    df.D = df.D.astype(\"float64\")\n    return df",
        "begin_line": 174,
        "end_line": 204,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_int_frame#208",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_int_frame()",
        "snippet": "def mixed_int_frame():\n    \"\"\"\n    Fixture for DataFrame of different int types with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D'].\n\n                A  B    C    D\n    mUrCZ67juP  0  1    2    2\n    rw99ACYaKS  0  1    0    0\n    7QsEcpaaVU  0  1    1    1\n    xkrimI2pcE  0  1    0    0\n    dz01SuzoS8  0  1  255  255\n    ccQkqOHX75 -1  1    0    0\n    DN0iXaoDLd  0  1    0    0\n    ...        .. ..  ...  ...\n    Dfb141wAaQ  1  1  254  254\n    IPD8eQOVu5  0  1    0    0\n    CcaKulsCmv  0  1    0    0\n    rIBa8gu7E5  0  1    0    0\n    RP6peZmh5o  0  1    1    1\n    NMb9pipQWQ  0  1    0    0\n    PqgbJEzjib  0  1    3    3\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame({k: v.astype(int) for k, v in tm.getSeriesData().items()})\n    df.A = df.A.astype(\"int32\")\n    df.B = np.ones(len(df.B), dtype=\"uint64\")\n    df.C = df.C.astype(\"uint8\")\n    df.D = df.C.astype(\"int64\")\n    return df",
        "begin_line": 208,
        "end_line": 238,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_type_frame#242",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_type_frame()",
        "snippet": "def mixed_type_frame():\n    \"\"\"\n    Fixture for DataFrame of float/int/string columns with RangeIndex\n    Columns are ['a', 'b', 'c', 'float32', 'int32'].\n    \"\"\"\n    return DataFrame(\n        {\n            \"a\": 1.0,\n            \"b\": 2,\n            \"c\": \"foo\",\n            \"float32\": np.array([1.0] * 10, dtype=\"float32\"),\n            \"int32\": np.array([1] * 10, dtype=\"int32\"),\n        },\n        index=np.arange(10),\n    )",
        "begin_line": 242,
        "end_line": 256,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.timezone_frame#260",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.timezone_frame()",
        "snippet": "def timezone_frame():\n    \"\"\"\n    Fixture for DataFrame of date_range Series with different time zones\n\n    Columns are ['A', 'B', 'C']; some entries are missing\n\n               A                         B                         C\n    0 2013-01-01 2013-01-01 00:00:00-05:00 2013-01-01 00:00:00+01:00\n    1 2013-01-02                       NaT                       NaT\n    2 2013-01-03 2013-01-03 00:00:00-05:00 2013-01-03 00:00:00+01:00\n    \"\"\"\n    df = DataFrame(\n        {\n            \"A\": date_range(\"20130101\", periods=3),\n            \"B\": date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n            \"C\": date_range(\"20130101\", periods=3, tz=\"CET\"),\n        }\n    )\n    df.iloc[1, 1] = NaT\n    df.iloc[1, 2] = NaT\n    return df",
        "begin_line": 260,
        "end_line": 280,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.uint64_frame#284",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.uint64_frame()",
        "snippet": "def uint64_frame():\n    \"\"\"\n    Fixture for DataFrame with uint64 values\n\n    Columns are ['A', 'B']\n    \"\"\"\n    return DataFrame(\n        {\"A\": np.arange(3), \"B\": [2 ** 63, 2 ** 63 + 5, 2 ** 63 + 10]}, dtype=np.uint64\n    )",
        "begin_line": 284,
        "end_line": 292,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.simple_frame#296",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.simple_frame()",
        "snippet": "def simple_frame():\n    \"\"\"\n    Fixture for simple 3x3 DataFrame\n\n    Columns are ['one', 'two', 'three'], index is ['a', 'b', 'c'].\n\n       one  two  three\n    a  1.0  2.0    3.0\n    b  4.0  5.0    6.0\n    c  7.0  8.0    9.0\n    \"\"\"\n    arr = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])\n\n    return DataFrame(arr, columns=[\"one\", \"two\", \"three\"], index=[\"a\", \"b\", \"c\"])",
        "begin_line": 296,
        "end_line": 309,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.frame_of_index_cols#313",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.frame_of_index_cols()",
        "snippet": "def frame_of_index_cols():\n    \"\"\"\n    Fixture for DataFrame of columns that can be used for indexing\n\n    Columns are ['A', 'B', 'C', 'D', 'E', ('tuple', 'as', 'label')];\n    'A' & 'B' contain duplicates (but are jointly unique), the rest are unique.\n\n         A      B  C         D         E  (tuple, as, label)\n    0  foo    one  a  0.608477 -0.012500           -1.664297\n    1  foo    two  b -0.633460  0.249614           -0.364411\n    2  foo  three  c  0.615256  2.154968           -0.834666\n    3  bar    one  d  0.234246  1.085675            0.718445\n    4  bar    two  e  0.533841 -0.005702           -3.533912\n    \"\"\"\n    df = DataFrame(\n        {\n            \"A\": [\"foo\", \"foo\", \"foo\", \"bar\", \"bar\"],\n            \"B\": [\"one\", \"two\", \"three\", \"one\", \"two\"],\n            \"C\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n            \"D\": np.random.randn(5),\n            \"E\": np.random.randn(5),\n            (\"tuple\", \"as\", \"label\"): np.random.randn(5),\n        }\n    )\n    return df",
        "begin_line": 313,
        "end_line": 337,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common._check_mixed_float#1",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common",
        "signature": "pandas.tests.frame.common._check_mixed_float(df, dtype=None)",
        "snippet": "def _check_mixed_float(df, dtype=None):\n    # float16 are most likely to be upcasted to float32\n    dtypes = dict(A=\"float32\", B=\"float32\", C=\"float16\", D=\"float64\")\n    if isinstance(dtype, str):\n        dtypes = {k: dtype for k, v in dtypes.items()}\n    elif isinstance(dtype, dict):\n        dtypes.update(dtype)\n    if dtypes.get(\"A\"):\n        assert df.dtypes[\"A\"] == dtypes[\"A\"]\n    if dtypes.get(\"B\"):\n        assert df.dtypes[\"B\"] == dtypes[\"B\"]\n    if dtypes.get(\"C\"):\n        assert df.dtypes[\"C\"] == dtypes[\"C\"]\n    if dtypes.get(\"D\"):\n        assert df.dtypes[\"D\"] == dtypes[\"D\"]",
        "begin_line": 1,
        "end_line": 15,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common._check_mixed_int#18",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common",
        "signature": "pandas.tests.frame.common._check_mixed_int(df, dtype=None)",
        "snippet": "def _check_mixed_int(df, dtype=None):\n    dtypes = dict(A=\"int32\", B=\"uint64\", C=\"uint8\", D=\"int64\")\n    if isinstance(dtype, str):\n        dtypes = {k: dtype for k, v in dtypes.items()}\n    elif isinstance(dtype, dict):\n        dtypes.update(dtype)\n    if dtypes.get(\"A\"):\n        assert df.dtypes[\"A\"] == dtypes[\"A\"]\n    if dtypes.get(\"B\"):\n        assert df.dtypes[\"B\"] == dtypes[\"B\"]\n    if dtypes.get(\"C\"):\n        assert df.dtypes[\"C\"] == dtypes[\"C\"]\n    if dtypes.get(\"D\"):\n        assert df.dtypes[\"D\"] == dtypes[\"D\"]",
        "begin_line": 18,
        "end_line": 31,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_pivot#13",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_pivot(self)",
        "snippet": "    def test_pivot(self):\n        data = {\n            \"index\": [\"A\", \"B\", \"C\", \"C\", \"B\", \"A\"],\n            \"columns\": [\"One\", \"One\", \"One\", \"Two\", \"Two\", \"Two\"],\n            \"values\": [1.0, 2.0, 3.0, 3.0, 2.0, 1.0],\n        }\n\n        frame = DataFrame(data)\n        pivoted = frame.pivot(index=\"index\", columns=\"columns\", values=\"values\")\n\n        expected = DataFrame(\n            {\n                \"One\": {\"A\": 1.0, \"B\": 2.0, \"C\": 3.0},\n                \"Two\": {\"A\": 1.0, \"B\": 2.0, \"C\": 3.0},\n            }\n        )\n\n        expected.index.name, expected.columns.name = \"index\", \"columns\"\n        tm.assert_frame_equal(pivoted, expected)\n\n        # name tracking\n        assert pivoted.index.name == \"index\"\n        assert pivoted.columns.name == \"columns\"\n\n        # don't specify values\n        pivoted = frame.pivot(index=\"index\", columns=\"columns\")\n        assert pivoted.index.name == \"index\"\n        assert pivoted.columns.names == (None, \"columns\")",
        "begin_line": 13,
        "end_line": 40,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_pivot_duplicates#42",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_pivot_duplicates(self)",
        "snippet": "    def test_pivot_duplicates(self):\n        data = DataFrame(\n            {\n                \"a\": [\"bar\", \"bar\", \"foo\", \"foo\", \"foo\"],\n                \"b\": [\"one\", \"two\", \"one\", \"one\", \"two\"],\n                \"c\": [1.0, 2.0, 3.0, 3.0, 4.0],\n            }\n        )\n        with pytest.raises(ValueError, match=\"duplicate entries\"):\n            data.pivot(\"a\", \"b\", \"c\")",
        "begin_line": 42,
        "end_line": 51,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_pivot_empty#53",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_pivot_empty(self)",
        "snippet": "    def test_pivot_empty(self):\n        df = DataFrame(columns=[\"a\", \"b\", \"c\"])\n        result = df.pivot(\"a\", \"b\", \"c\")\n        expected = DataFrame()\n        tm.assert_frame_equal(result, expected, check_names=False)",
        "begin_line": 53,
        "end_line": 57,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_pivot_integer_bug#59",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_pivot_integer_bug(self)",
        "snippet": "    def test_pivot_integer_bug(self):\n        df = DataFrame(data=[(\"A\", \"1\", \"A1\"), (\"B\", \"2\", \"B2\")])\n\n        result = df.pivot(index=1, columns=0, values=2)\n        repr(result)\n        tm.assert_index_equal(result.columns, Index([\"A\", \"B\"], name=0))",
        "begin_line": 59,
        "end_line": 64,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_pivot_index_none#66",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_pivot_index_none(self)",
        "snippet": "    def test_pivot_index_none(self):\n        # gh-3962\n        data = {\n            \"index\": [\"A\", \"B\", \"C\", \"C\", \"B\", \"A\"],\n            \"columns\": [\"One\", \"One\", \"One\", \"Two\", \"Two\", \"Two\"],\n            \"values\": [1.0, 2.0, 3.0, 3.0, 2.0, 1.0],\n        }\n\n        frame = DataFrame(data).set_index(\"index\")\n        result = frame.pivot(columns=\"columns\", values=\"values\")\n        expected = DataFrame(\n            {\n                \"One\": {\"A\": 1.0, \"B\": 2.0, \"C\": 3.0},\n                \"Two\": {\"A\": 1.0, \"B\": 2.0, \"C\": 3.0},\n            }\n        )\n\n        expected.index.name, expected.columns.name = \"index\", \"columns\"\n        tm.assert_frame_equal(result, expected)\n\n        # omit values\n        result = frame.pivot(columns=\"columns\")\n\n        expected.columns = pd.MultiIndex.from_tuples(\n            [(\"values\", \"One\"), (\"values\", \"Two\")], names=[None, \"columns\"]\n        )\n        expected.index.name = \"index\"\n        tm.assert_frame_equal(result, expected, check_names=False)\n        assert result.index.name == \"index\"\n        assert result.columns.names == (None, \"columns\")\n        expected.columns = expected.columns.droplevel(0)\n        result = frame.pivot(columns=\"columns\", values=\"values\")\n\n        expected.columns.name = \"columns\"\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 66,
        "end_line": 100,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_unstack#102",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_unstack(self, float_frame)",
        "snippet": "    def test_stack_unstack(self, float_frame):\n        df = float_frame.copy()\n        df[:] = np.arange(np.prod(df.shape)).reshape(df.shape)\n\n        stacked = df.stack()\n        stacked_df = DataFrame({\"foo\": stacked, \"bar\": stacked})\n\n        unstacked = stacked.unstack()\n        unstacked_df = stacked_df.unstack()\n\n        tm.assert_frame_equal(unstacked, df)\n        tm.assert_frame_equal(unstacked_df[\"bar\"], df)\n\n        unstacked_cols = stacked.unstack(0)\n        unstacked_cols_df = stacked_df.unstack(0)\n        tm.assert_frame_equal(unstacked_cols.T, df)\n        tm.assert_frame_equal(unstacked_cols_df[\"bar\"].T, df)",
        "begin_line": 102,
        "end_line": 118,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_mixed_level#120",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_mixed_level(self)",
        "snippet": "    def test_stack_mixed_level(self):\n        # GH 18310\n        levels = [range(3), [3, \"a\", \"b\"], [1, 2]]\n\n        # flat columns:\n        df = DataFrame(1, index=levels[0], columns=levels[1])\n        result = df.stack()\n        expected = Series(1, index=MultiIndex.from_product(levels[:2]))\n        tm.assert_series_equal(result, expected)\n\n        # MultiIndex columns:\n        df = DataFrame(1, index=levels[0], columns=MultiIndex.from_product(levels[1:]))\n        result = df.stack(1)\n        expected = DataFrame(\n            1, index=MultiIndex.from_product([levels[0], levels[2]]), columns=levels[1]\n        )\n        tm.assert_frame_equal(result, expected)\n\n        # as above, but used labels in level are actually of homogeneous type\n        result = df[[\"a\", \"b\"]].stack(1)\n        expected = expected[[\"a\", \"b\"]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 120,
        "end_line": 141,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_fill#143",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_fill(self)",
        "snippet": "    def test_unstack_fill(self):\n\n        # GH #9746: fill_value keyword argument for Series\n        # and DataFrame unstack\n\n        # From a series\n        data = Series([1, 2, 4, 5], dtype=np.int16)\n        data.index = MultiIndex.from_tuples(\n            [(\"x\", \"a\"), (\"x\", \"b\"), (\"y\", \"b\"), (\"z\", \"a\")]\n        )\n\n        result = data.unstack(fill_value=-1)\n        expected = DataFrame(\n            {\"a\": [1, -1, 5], \"b\": [2, 4, -1]}, index=[\"x\", \"y\", \"z\"], dtype=np.int16\n        )\n        tm.assert_frame_equal(result, expected)\n\n        # From a series with incorrect data type for fill_value\n        result = data.unstack(fill_value=0.5)\n        expected = DataFrame(\n            {\"a\": [1, 0.5, 5], \"b\": [2, 4, 0.5]}, index=[\"x\", \"y\", \"z\"], dtype=np.float\n        )\n        tm.assert_frame_equal(result, expected)\n\n        # GH #13971: fill_value when unstacking multiple levels:\n        df = DataFrame(\n            {\"x\": [\"a\", \"a\", \"b\"], \"y\": [\"j\", \"k\", \"j\"], \"z\": [0, 1, 2], \"w\": [0, 1, 2]}\n        ).set_index([\"x\", \"y\", \"z\"])\n        unstacked = df.unstack([\"x\", \"y\"], fill_value=0)\n        key = (\"w\", \"b\", \"j\")\n        expected = unstacked[key]\n        result = pd.Series([0, 0, 2], index=unstacked.index, name=key)\n        tm.assert_series_equal(result, expected)\n\n        stacked = unstacked.stack([\"x\", \"y\"])\n        stacked.index = stacked.index.reorder_levels(df.index.names)\n        # Workaround for GH #17886 (unnecessarily casts to float):\n        stacked = stacked.astype(np.int64)\n        result = stacked.loc[df.index]\n        tm.assert_frame_equal(result, df)\n\n        # From a series\n        s = df[\"w\"]\n        result = s.unstack([\"x\", \"y\"], fill_value=0)\n        expected = unstacked[\"w\"]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 143,
        "end_line": 188,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_fill_frame#190",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_fill_frame(self)",
        "snippet": "    def test_unstack_fill_frame(self):\n\n        # From a dataframe\n        rows = [[1, 2], [3, 4], [5, 6], [7, 8]]\n        df = DataFrame(rows, columns=list(\"AB\"), dtype=np.int32)\n        df.index = MultiIndex.from_tuples(\n            [(\"x\", \"a\"), (\"x\", \"b\"), (\"y\", \"b\"), (\"z\", \"a\")]\n        )\n\n        result = df.unstack(fill_value=-1)\n\n        rows = [[1, 3, 2, 4], [-1, 5, -1, 6], [7, -1, 8, -1]]\n        expected = DataFrame(rows, index=list(\"xyz\"), dtype=np.int32)\n        expected.columns = MultiIndex.from_tuples(\n            [(\"A\", \"a\"), (\"A\", \"b\"), (\"B\", \"a\"), (\"B\", \"b\")]\n        )\n        tm.assert_frame_equal(result, expected)\n\n        # From a mixed type dataframe\n        df[\"A\"] = df[\"A\"].astype(np.int16)\n        df[\"B\"] = df[\"B\"].astype(np.float64)\n\n        result = df.unstack(fill_value=-1)\n        expected[\"A\"] = expected[\"A\"].astype(np.int16)\n        expected[\"B\"] = expected[\"B\"].astype(np.float64)\n        tm.assert_frame_equal(result, expected)\n\n        # From a dataframe with incorrect data type for fill_value\n        result = df.unstack(fill_value=0.5)\n\n        rows = [[1, 3, 2, 4], [0.5, 5, 0.5, 6], [7, 0.5, 8, 0.5]]\n        expected = DataFrame(rows, index=list(\"xyz\"), dtype=np.float)\n        expected.columns = MultiIndex.from_tuples(\n            [(\"A\", \"a\"), (\"A\", \"b\"), (\"B\", \"a\"), (\"B\", \"b\")]\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 190,
        "end_line": 225,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_fill_frame_datetime#227",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_fill_frame_datetime(self)",
        "snippet": "    def test_unstack_fill_frame_datetime(self):\n\n        # Test unstacking with date times\n        dv = pd.date_range(\"2012-01-01\", periods=4).values\n        data = Series(dv)\n        data.index = MultiIndex.from_tuples(\n            [(\"x\", \"a\"), (\"x\", \"b\"), (\"y\", \"b\"), (\"z\", \"a\")]\n        )\n\n        result = data.unstack()\n        expected = DataFrame(\n            {\"a\": [dv[0], pd.NaT, dv[3]], \"b\": [dv[1], dv[2], pd.NaT]},\n            index=[\"x\", \"y\", \"z\"],\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = data.unstack(fill_value=dv[0])\n        expected = DataFrame(\n            {\"a\": [dv[0], dv[0], dv[3]], \"b\": [dv[1], dv[2], dv[0]]},\n            index=[\"x\", \"y\", \"z\"],\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 227,
        "end_line": 248,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_fill_frame_timedelta#250",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_fill_frame_timedelta(self)",
        "snippet": "    def test_unstack_fill_frame_timedelta(self):\n\n        # Test unstacking with time deltas\n        td = [Timedelta(days=i) for i in range(4)]\n        data = Series(td)\n        data.index = MultiIndex.from_tuples(\n            [(\"x\", \"a\"), (\"x\", \"b\"), (\"y\", \"b\"), (\"z\", \"a\")]\n        )\n\n        result = data.unstack()\n        expected = DataFrame(\n            {\"a\": [td[0], pd.NaT, td[3]], \"b\": [td[1], td[2], pd.NaT]},\n            index=[\"x\", \"y\", \"z\"],\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = data.unstack(fill_value=td[1])\n        expected = DataFrame(\n            {\"a\": [td[0], td[1], td[3]], \"b\": [td[1], td[2], td[1]]},\n            index=[\"x\", \"y\", \"z\"],\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 250,
        "end_line": 271,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_fill_frame_period#273",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_fill_frame_period(self)",
        "snippet": "    def test_unstack_fill_frame_period(self):\n\n        # Test unstacking with period\n        periods = [\n            Period(\"2012-01\"),\n            Period(\"2012-02\"),\n            Period(\"2012-03\"),\n            Period(\"2012-04\"),\n        ]\n        data = Series(periods)\n        data.index = MultiIndex.from_tuples(\n            [(\"x\", \"a\"), (\"x\", \"b\"), (\"y\", \"b\"), (\"z\", \"a\")]\n        )\n\n        result = data.unstack()\n        expected = DataFrame(\n            {\"a\": [periods[0], None, periods[3]], \"b\": [periods[1], periods[2], None]},\n            index=[\"x\", \"y\", \"z\"],\n        )\n        tm.assert_frame_equal(result, expected)\n\n        result = data.unstack(fill_value=periods[1])\n        expected = DataFrame(\n            {\n                \"a\": [periods[0], periods[1], periods[3]],\n                \"b\": [periods[1], periods[2], periods[1]],\n            },\n            index=[\"x\", \"y\", \"z\"],\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 273,
        "end_line": 302,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_fill_frame_categorical#304",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_fill_frame_categorical(self)",
        "snippet": "    def test_unstack_fill_frame_categorical(self):\n\n        # Test unstacking with categorical\n        data = pd.Series([\"a\", \"b\", \"c\", \"a\"], dtype=\"category\")\n        data.index = pd.MultiIndex.from_tuples(\n            [(\"x\", \"a\"), (\"x\", \"b\"), (\"y\", \"b\"), (\"z\", \"a\")]\n        )\n\n        # By default missing values will be NaN\n        result = data.unstack()\n        expected = DataFrame(\n            {\n                \"a\": pd.Categorical(list(\"axa\"), categories=list(\"abc\")),\n                \"b\": pd.Categorical(list(\"bcx\"), categories=list(\"abc\")),\n            },\n            index=list(\"xyz\"),\n        )\n        tm.assert_frame_equal(result, expected)\n\n        # Fill with non-category results in a TypeError\n        msg = r\"'fill_value' \\('d'\\) is not in\"\n        with pytest.raises(TypeError, match=msg):\n            data.unstack(fill_value=\"d\")\n\n        # Fill with category value replaces missing values as expected\n        result = data.unstack(fill_value=\"c\")\n        expected = DataFrame(\n            {\n                \"a\": pd.Categorical(list(\"aca\"), categories=list(\"abc\")),\n                \"b\": pd.Categorical(list(\"bcc\"), categories=list(\"abc\")),\n            },\n            index=list(\"xyz\"),\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 304,
        "end_line": 337,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_tuplename_in_multiindex#339",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_tuplename_in_multiindex(self)",
        "snippet": "    def test_unstack_tuplename_in_multiindex(self):\n        # GH 19966\n        idx = pd.MultiIndex.from_product(\n            [[\"a\", \"b\", \"c\"], [1, 2, 3]], names=[(\"A\", \"a\"), (\"B\", \"b\")]\n        )\n        df = pd.DataFrame({\"d\": [1] * 9, \"e\": [2] * 9}, index=idx)\n        result = df.unstack((\"A\", \"a\"))\n\n        expected = pd.DataFrame(\n            [[1, 1, 1, 2, 2, 2], [1, 1, 1, 2, 2, 2], [1, 1, 1, 2, 2, 2]],\n            columns=pd.MultiIndex.from_tuples(\n                [\n                    (\"d\", \"a\"),\n                    (\"d\", \"b\"),\n                    (\"d\", \"c\"),\n                    (\"e\", \"a\"),\n                    (\"e\", \"b\"),\n                    (\"e\", \"c\"),\n                ],\n                names=[None, (\"A\", \"a\")],\n            ),\n            index=pd.Index([1, 2, 3], name=(\"B\", \"b\")),\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 339,
        "end_line": 362,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_mixed_type_name_in_multiindex#398",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_mixed_type_name_in_multiindex(self, unstack_idx, expected_values, expected_index, expected_columns)",
        "snippet": "    def test_unstack_mixed_type_name_in_multiindex(\n        self, unstack_idx, expected_values, expected_index, expected_columns\n    ):\n        # GH 19966\n        idx = pd.MultiIndex.from_product(\n            [[\"a\", \"b\"], [1, 2], [3, 4]], names=[(\"A\", \"a\"), \"B\", \"C\"]\n        )\n        df = pd.DataFrame({\"d\": [1] * 8, \"e\": [2] * 8}, index=idx)\n        result = df.unstack(unstack_idx)\n\n        expected = pd.DataFrame(\n            expected_values, columns=expected_columns, index=expected_index,\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 398,
        "end_line": 411,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_preserve_dtypes#413",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_preserve_dtypes(self)",
        "snippet": "    def test_unstack_preserve_dtypes(self):\n        # Checks fix for #11847\n        df = pd.DataFrame(\n            dict(\n                state=[\"IL\", \"MI\", \"NC\"],\n                index=[\"a\", \"b\", \"c\"],\n                some_categories=pd.Series([\"a\", \"b\", \"c\"]).astype(\"category\"),\n                A=np.random.rand(3),\n                B=1,\n                C=\"foo\",\n                D=pd.Timestamp(\"20010102\"),\n                E=pd.Series([1.0, 50.0, 100.0]).astype(\"float32\"),\n                F=pd.Series([3.0, 4.0, 5.0]).astype(\"float64\"),\n                G=False,\n                H=pd.Series([1, 200, 923442], dtype=\"int8\"),\n            )\n        )\n\n        def unstack_and_compare(df, column_name):\n            unstacked1 = df.unstack([column_name])\n            unstacked2 = df.unstack(column_name)\n            tm.assert_frame_equal(unstacked1, unstacked2)\n\n        df1 = df.set_index([\"state\", \"index\"])\n        unstack_and_compare(df1, \"index\")\n\n        df1 = df.set_index([\"state\", \"some_categories\"])\n        unstack_and_compare(df1, \"some_categories\")\n\n        df1 = df.set_index([\"F\", \"C\"])\n        unstack_and_compare(df1, \"F\")\n\n        df1 = df.set_index([\"G\", \"B\", \"state\"])\n        unstack_and_compare(df1, \"B\")\n\n        df1 = df.set_index([\"E\", \"A\"])\n        unstack_and_compare(df1, \"E\")\n\n        df1 = df.set_index([\"state\", \"index\"])\n        s = df1[\"A\"]\n        unstack_and_compare(s, \"index\")",
        "begin_line": 413,
        "end_line": 453,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.unstack_and_compare#431",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.unstack_and_compare(df, column_name)",
        "snippet": "        def unstack_and_compare(df, column_name):\n            unstacked1 = df.unstack([column_name])\n            unstacked2 = df.unstack(column_name)\n            tm.assert_frame_equal(unstacked1, unstacked2)",
        "begin_line": 431,
        "end_line": 434,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_ints#455",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_ints(self)",
        "snippet": "    def test_stack_ints(self):\n        columns = MultiIndex.from_tuples(list(itertools.product(range(3), repeat=3)))\n        df = DataFrame(np.random.randn(30, 27), columns=columns)\n\n        tm.assert_frame_equal(df.stack(level=[1, 2]), df.stack(level=1).stack(level=1))\n        tm.assert_frame_equal(\n            df.stack(level=[-2, -1]), df.stack(level=1).stack(level=1)\n        )\n\n        df_named = df.copy()\n        df_named.columns.set_names(range(3), inplace=True)\n\n        tm.assert_frame_equal(\n            df_named.stack(level=[1, 2]), df_named.stack(level=1).stack(level=1)\n        )",
        "begin_line": 455,
        "end_line": 469,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_mixed_levels#471",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_mixed_levels(self)",
        "snippet": "    def test_stack_mixed_levels(self):\n        columns = MultiIndex.from_tuples(\n            [\n                (\"A\", \"cat\", \"long\"),\n                (\"B\", \"cat\", \"long\"),\n                (\"A\", \"dog\", \"short\"),\n                (\"B\", \"dog\", \"short\"),\n            ],\n            names=[\"exp\", \"animal\", \"hair_length\"],\n        )\n        df = DataFrame(np.random.randn(4, 4), columns=columns)\n\n        animal_hair_stacked = df.stack(level=[\"animal\", \"hair_length\"])\n        exp_hair_stacked = df.stack(level=[\"exp\", \"hair_length\"])\n\n        # GH #8584: Need to check that stacking works when a number\n        # is passed that is both a level name and in the range of\n        # the level numbers\n        df2 = df.copy()\n        df2.columns.names = [\"exp\", \"animal\", 1]\n        tm.assert_frame_equal(\n            df2.stack(level=[\"animal\", 1]), animal_hair_stacked, check_names=False\n        )\n        tm.assert_frame_equal(\n            df2.stack(level=[\"exp\", 1]), exp_hair_stacked, check_names=False\n        )\n\n        # When mixed types are passed and the ints are not level\n        # names, raise\n        msg = (\n            \"level should contain all level names or all level numbers, not \"\n            \"a mixture of the two\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            df2.stack(level=[\"animal\", 0])\n\n        # GH #8584: Having 0 in the level names could raise a\n        # strange error about lexsort depth\n        df3 = df.copy()\n        df3.columns.names = [\"exp\", \"animal\", 0]\n        tm.assert_frame_equal(\n            df3.stack(level=[\"animal\", 0]), animal_hair_stacked, check_names=False\n        )",
        "begin_line": 471,
        "end_line": 513,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_int_level_names#515",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_int_level_names(self)",
        "snippet": "    def test_stack_int_level_names(self):\n        columns = MultiIndex.from_tuples(\n            [\n                (\"A\", \"cat\", \"long\"),\n                (\"B\", \"cat\", \"long\"),\n                (\"A\", \"dog\", \"short\"),\n                (\"B\", \"dog\", \"short\"),\n            ],\n            names=[\"exp\", \"animal\", \"hair_length\"],\n        )\n        df = DataFrame(np.random.randn(4, 4), columns=columns)\n\n        exp_animal_stacked = df.stack(level=[\"exp\", \"animal\"])\n        animal_hair_stacked = df.stack(level=[\"animal\", \"hair_length\"])\n        exp_hair_stacked = df.stack(level=[\"exp\", \"hair_length\"])\n\n        df2 = df.copy()\n        df2.columns.names = [0, 1, 2]\n        tm.assert_frame_equal(\n            df2.stack(level=[1, 2]), animal_hair_stacked, check_names=False\n        )\n        tm.assert_frame_equal(\n            df2.stack(level=[0, 1]), exp_animal_stacked, check_names=False\n        )\n        tm.assert_frame_equal(\n            df2.stack(level=[0, 2]), exp_hair_stacked, check_names=False\n        )\n\n        # Out-of-order int column names\n        df3 = df.copy()\n        df3.columns.names = [2, 0, 1]\n        tm.assert_frame_equal(\n            df3.stack(level=[0, 1]), animal_hair_stacked, check_names=False\n        )\n        tm.assert_frame_equal(\n            df3.stack(level=[2, 0]), exp_animal_stacked, check_names=False\n        )\n        tm.assert_frame_equal(\n            df3.stack(level=[2, 1]), exp_hair_stacked, check_names=False\n        )",
        "begin_line": 515,
        "end_line": 554,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_bool#556",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_bool(self)",
        "snippet": "    def test_unstack_bool(self):\n        df = DataFrame(\n            [False, False],\n            index=MultiIndex.from_arrays([[\"a\", \"b\"], [\"c\", \"l\"]]),\n            columns=[\"col\"],\n        )\n        rs = df.unstack()\n        xp = DataFrame(\n            np.array([[False, np.nan], [np.nan, False]], dtype=object),\n            index=[\"a\", \"b\"],\n            columns=MultiIndex.from_arrays([[\"col\", \"col\"], [\"c\", \"l\"]]),\n        )\n        tm.assert_frame_equal(rs, xp)",
        "begin_line": 556,
        "end_line": 568,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_level_binding#570",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_level_binding(self)",
        "snippet": "    def test_unstack_level_binding(self):\n        # GH9856\n        mi = pd.MultiIndex(\n            levels=[[\"foo\", \"bar\"], [\"one\", \"two\"], [\"a\", \"b\"]],\n            codes=[[0, 0, 1, 1], [0, 1, 0, 1], [1, 0, 1, 0]],\n            names=[\"first\", \"second\", \"third\"],\n        )\n        s = pd.Series(0, index=mi)\n        result = s.unstack([1, 2]).stack(0)\n\n        expected_mi = pd.MultiIndex(\n            levels=[[\"foo\", \"bar\"], [\"one\", \"two\"]],\n            codes=[[0, 0, 1, 1], [0, 1, 0, 1]],\n            names=[\"first\", \"second\"],\n        )\n\n        expected = pd.DataFrame(\n            np.array(\n                [[np.nan, 0], [0, np.nan], [np.nan, 0], [0, np.nan]], dtype=np.float64\n            ),\n            index=expected_mi,\n            columns=pd.Index([\"a\", \"b\"], name=\"third\"),\n        )\n\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 570,
        "end_line": 594,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_to_series#596",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_to_series(self, float_frame)",
        "snippet": "    def test_unstack_to_series(self, float_frame):\n        # check reversibility\n        data = float_frame.unstack()\n\n        assert isinstance(data, Series)\n        undo = data.unstack().T\n        tm.assert_frame_equal(undo, float_frame)\n\n        # check NA handling\n        data = DataFrame({\"x\": [1, 2, np.NaN], \"y\": [3.0, 4, np.NaN]})\n        data.index = Index([\"a\", \"b\", \"c\"])\n        result = data.unstack()\n\n        midx = MultiIndex(\n            levels=[[\"x\", \"y\"], [\"a\", \"b\", \"c\"]],\n            codes=[[0, 0, 0, 1, 1, 1], [0, 1, 2, 0, 1, 2]],\n        )\n        expected = Series([1, 2, np.NaN, 3, 4, np.NaN], index=midx)\n\n        tm.assert_series_equal(result, expected)\n\n        # check composability of unstack\n        old_data = data.copy()\n        for _ in range(4):\n            data = data.unstack()\n        tm.assert_frame_equal(old_data, data)",
        "begin_line": 596,
        "end_line": 621,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_dtypes#623",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_dtypes(self)",
        "snippet": "    def test_unstack_dtypes(self):\n\n        # GH 2929\n        rows = [[1, 1, 3, 4], [1, 2, 3, 4], [2, 1, 3, 4], [2, 2, 3, 4]]\n\n        df = DataFrame(rows, columns=list(\"ABCD\"))\n        result = df.dtypes\n        expected = Series([np.dtype(\"int64\")] * 4, index=list(\"ABCD\"))\n        tm.assert_series_equal(result, expected)\n\n        # single dtype\n        df2 = df.set_index([\"A\", \"B\"])\n        df3 = df2.unstack(\"B\")\n        result = df3.dtypes\n        expected = Series(\n            [np.dtype(\"int64\")] * 4,\n            index=pd.MultiIndex.from_arrays(\n                [[\"C\", \"C\", \"D\", \"D\"], [1, 2, 1, 2]], names=(None, \"B\")\n            ),\n        )\n        tm.assert_series_equal(result, expected)\n\n        # mixed\n        df2 = df.set_index([\"A\", \"B\"])\n        df2[\"C\"] = 3.0\n        df3 = df2.unstack(\"B\")\n        result = df3.dtypes\n        expected = Series(\n            [np.dtype(\"float64\")] * 2 + [np.dtype(\"int64\")] * 2,\n            index=pd.MultiIndex.from_arrays(\n                [[\"C\", \"C\", \"D\", \"D\"], [1, 2, 1, 2]], names=(None, \"B\")\n            ),\n        )\n        tm.assert_series_equal(result, expected)\n        df2[\"D\"] = \"foo\"\n        df3 = df2.unstack(\"B\")\n        result = df3.dtypes\n        expected = Series(\n            [np.dtype(\"float64\")] * 2 + [np.dtype(\"object\")] * 2,\n            index=pd.MultiIndex.from_arrays(\n                [[\"C\", \"C\", \"D\", \"D\"], [1, 2, 1, 2]], names=(None, \"B\")\n            ),\n        )\n        tm.assert_series_equal(result, expected)\n\n        # GH7405\n        for c, d in (\n            (np.zeros(5), np.zeros(5)),\n            (np.arange(5, dtype=\"f8\"), np.arange(5, 10, dtype=\"f8\")),\n        ):\n\n            df = DataFrame(\n                {\n                    \"A\": [\"a\"] * 5,\n                    \"C\": c,\n                    \"D\": d,\n                    \"B\": pd.date_range(\"2012-01-01\", periods=5),\n                }\n            )\n\n            right = df.iloc[:3].copy(deep=True)\n\n            df = df.set_index([\"A\", \"B\"])\n            df[\"D\"] = df[\"D\"].astype(\"int64\")\n\n            left = df.iloc[:3].unstack(0)\n            right = right.set_index([\"A\", \"B\"]).unstack(0)\n            right[(\"D\", \"a\")] = right[(\"D\", \"a\")].astype(\"int64\")\n\n            assert left.shape == (3, 2)\n            tm.assert_frame_equal(left, right)",
        "begin_line": 623,
        "end_line": 693,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_non_unique_index_names#695",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_non_unique_index_names(self)",
        "snippet": "    def test_unstack_non_unique_index_names(self):\n        idx = MultiIndex.from_tuples([(\"a\", \"b\"), (\"c\", \"d\")], names=[\"c1\", \"c1\"])\n        df = DataFrame([1, 2], index=idx)\n        msg = \"The name c1 occurs multiple times, use a level number\"\n        with pytest.raises(ValueError, match=msg):\n            df.unstack(\"c1\")\n\n        with pytest.raises(ValueError, match=msg):\n            df.T.stack(\"c1\")",
        "begin_line": 695,
        "end_line": 703,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_unused_levels#705",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_unused_levels(self)",
        "snippet": "    def test_unstack_unused_levels(self):\n        # GH 17845: unused codes in index make unstack() cast int to float\n        idx = pd.MultiIndex.from_product([[\"a\"], [\"A\", \"B\", \"C\", \"D\"]])[:-1]\n        df = pd.DataFrame([[1, 0]] * 3, index=idx)\n\n        result = df.unstack()\n        exp_col = pd.MultiIndex.from_product([[0, 1], [\"A\", \"B\", \"C\"]])\n        expected = pd.DataFrame([[1, 1, 1, 0, 0, 0]], index=[\"a\"], columns=exp_col)\n        tm.assert_frame_equal(result, expected)\n        assert (result.columns.levels[1] == idx.levels[1]).all()\n\n        # Unused items on both levels\n        levels = [[0, 1, 7], [0, 1, 2, 3]]\n        codes = [[0, 0, 1, 1], [0, 2, 0, 2]]\n        idx = pd.MultiIndex(levels, codes)\n        block = np.arange(4).reshape(2, 2)\n        df = pd.DataFrame(np.concatenate([block, block + 4]), index=idx)\n        result = df.unstack()\n        expected = pd.DataFrame(\n            np.concatenate([block * 2, block * 2 + 1], axis=1), columns=idx\n        )\n        tm.assert_frame_equal(result, expected)\n        assert (result.columns.levels[1] == idx.levels[1]).all()\n\n        # With mixed dtype and NaN\n        levels = [[\"a\", 2, \"c\"], [1, 3, 5, 7]]\n        codes = [[0, -1, 1, 1], [0, 2, -1, 2]]\n        idx = pd.MultiIndex(levels, codes)\n        data = np.arange(8)\n        df = pd.DataFrame(data.reshape(4, 2), index=idx)\n\n        cases = (\n            (0, [13, 16, 6, 9, 2, 5, 8, 11], [np.nan, \"a\", 2], [np.nan, 5, 1]),\n            (1, [8, 11, 1, 4, 12, 15, 13, 16], [np.nan, 5, 1], [np.nan, \"a\", 2]),\n        )\n        for level, idces, col_level, idx_level in cases:\n            result = df.unstack(level=level)\n            exp_data = np.zeros(18) * np.nan\n            exp_data[idces] = data\n            cols = pd.MultiIndex.from_product([[0, 1], col_level])\n            expected = pd.DataFrame(\n                exp_data.reshape(3, 6), index=idx_level, columns=cols\n            )\n            tm.assert_frame_equal(result, expected)",
        "begin_line": 705,
        "end_line": 748,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_unused_level#751",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_unused_level(self, cols)",
        "snippet": "    def test_unstack_unused_level(self, cols):\n        # GH 18562 : unused codes on the unstacked level\n        df = pd.DataFrame(\n            [[2010, \"a\", \"I\"], [2011, \"b\", \"II\"]], columns=[\"A\", \"B\", \"C\"]\n        )\n\n        ind = df.set_index([\"A\", \"B\", \"C\"], drop=False)\n        selection = ind.loc[(slice(None), slice(None), \"I\"), cols]\n        result = selection.unstack()\n\n        expected = ind.iloc[[0]][cols]\n        expected.columns = MultiIndex.from_product(\n            [expected.columns, [\"I\"]], names=[None, \"C\"]\n        )\n        expected.index = expected.index.droplevel(\"C\")\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 751,
        "end_line": 766,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_long_index#768",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_long_index(self)",
        "snippet": "    def test_unstack_long_index(self):\n        # PH 32624: Error when using a lot of indices to unstack.\n        # The error occurred only, if a lot of indices are used.\n        df = pd.DataFrame(\n            [[1]],\n            columns=pd.MultiIndex.from_tuples([[0]], names=[\"c1\"]),\n            index=pd.MultiIndex.from_tuples(\n                [[0, 0, 1, 0, 0, 0, 1]],\n                names=[\"i1\", \"i2\", \"i3\", \"i4\", \"i5\", \"i6\", \"i7\"],\n            ),\n        )\n        result = df.unstack([\"i2\", \"i3\", \"i4\", \"i5\", \"i6\", \"i7\"])\n        expected = pd.DataFrame(\n            [[1]],\n            columns=pd.MultiIndex.from_tuples(\n                [[0, 0, 1, 0, 0, 0, 1]],\n                names=[\"c1\", \"i2\", \"i3\", \"i4\", \"i5\", \"i6\", \"i7\"],\n            ),\n            index=pd.Index([0], name=\"i1\"),\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 768,
        "end_line": 788,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_multi_level_cols#790",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_multi_level_cols(self)",
        "snippet": "    def test_unstack_multi_level_cols(self):\n        # PH 24729: Unstack a df with multi level columns\n        df = pd.DataFrame(\n            [[0.0, 0.0], [0.0, 0.0]],\n            columns=pd.MultiIndex.from_tuples(\n                [[\"B\", \"C\"], [\"B\", \"D\"]], names=[\"c1\", \"c2\"]\n            ),\n            index=pd.MultiIndex.from_tuples(\n                [[10, 20, 30], [10, 20, 40]], names=[\"i1\", \"i2\", \"i3\"],\n            ),\n        )\n        assert df.unstack([\"i2\", \"i1\"]).columns.names[-2:] == [\"i2\", \"i1\"]",
        "begin_line": 790,
        "end_line": 801,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_multi_level_rows_and_cols#803",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_multi_level_rows_and_cols(self)",
        "snippet": "    def test_unstack_multi_level_rows_and_cols(self):\n        # PH 28306: Unstack df with multi level cols and rows\n        df = pd.DataFrame(\n            [[1, 2], [3, 4], [-1, -2], [-3, -4]],\n            columns=pd.MultiIndex.from_tuples([[\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"]]),\n            index=pd.MultiIndex.from_tuples(\n                [\n                    [\"m1\", \"P3\", 222],\n                    [\"m1\", \"A5\", 111],\n                    [\"m2\", \"P3\", 222],\n                    [\"m2\", \"A5\", 111],\n                ],\n                names=[\"i1\", \"i2\", \"i3\"],\n            ),\n        )\n        result = df.unstack([\"i3\", \"i2\"])\n        expected = df.unstack([\"i3\"]).unstack([\"i2\"])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 803,
        "end_line": 820,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_nan_index#822",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_nan_index(self)",
        "snippet": "    def test_unstack_nan_index(self):  # GH7466\n        def cast(val):\n            val_str = \"\" if val != val else val\n            return f\"{val_str:1}\"\n\n        def verify(df):\n            mk_list = lambda a: list(a) if isinstance(a, tuple) else [a]\n            rows, cols = df.notna().values.nonzero()\n            for i, j in zip(rows, cols):\n                left = sorted(df.iloc[i, j].split(\".\"))\n                right = mk_list(df.index[i]) + mk_list(df.columns[j])\n                right = sorted(map(cast, right))\n                assert left == right\n\n        df = DataFrame(\n            {\n                \"jim\": [\"a\", \"b\", np.nan, \"d\"],\n                \"joe\": [\"w\", \"x\", \"y\", \"z\"],\n                \"jolie\": [\"a.w\", \"b.x\", \" .y\", \"d.z\"],\n            }\n        )\n\n        left = df.set_index([\"jim\", \"joe\"]).unstack()[\"jolie\"]\n        right = df.set_index([\"joe\", \"jim\"]).unstack()[\"jolie\"].T\n        tm.assert_frame_equal(left, right)\n\n        for idx in itertools.permutations(df.columns[:2]):\n            mi = df.set_index(list(idx))\n            for lev in range(2):\n                udf = mi.unstack(level=lev)\n                assert udf.notna().values.sum() == len(df)\n                verify(udf[\"jolie\"])\n\n        df = DataFrame(\n            {\n                \"1st\": [\"d\"] * 3\n                + [np.nan] * 5\n                + [\"a\"] * 2\n                + [\"c\"] * 3\n                + [\"e\"] * 2\n                + [\"b\"] * 5,\n                \"2nd\": [\"y\"] * 2\n                + [\"w\"] * 3\n                + [np.nan] * 3\n                + [\"z\"] * 4\n                + [np.nan] * 3\n                + [\"x\"] * 3\n                + [np.nan] * 2,\n                \"3rd\": [\n                    67,\n                    39,\n                    53,\n                    72,\n                    57,\n                    80,\n                    31,\n                    18,\n                    11,\n                    30,\n                    59,\n                    50,\n                    62,\n                    59,\n                    76,\n                    52,\n                    14,\n                    53,\n                    60,\n                    51,\n                ],\n            }\n        )\n\n        df[\"4th\"], df[\"5th\"] = (\n            df.apply(lambda r: \".\".join(map(cast, r)), axis=1),\n            df.apply(lambda r: \".\".join(map(cast, r.iloc[::-1])), axis=1),\n        )\n\n        for idx in itertools.permutations([\"1st\", \"2nd\", \"3rd\"]):\n            mi = df.set_index(list(idx))\n            for lev in range(3):\n                udf = mi.unstack(level=lev)\n                assert udf.notna().values.sum() == 2 * len(df)\n                for col in [\"4th\", \"5th\"]:\n                    verify(udf[col])\n\n        # GH7403\n        df = pd.DataFrame({\"A\": list(\"aaaabbbb\"), \"B\": range(8), \"C\": range(8)})\n        df.iloc[3, 1] = np.NaN\n        left = df.set_index([\"A\", \"B\"]).unstack(0)\n\n        vals = [\n            [3, 0, 1, 2, np.nan, np.nan, np.nan, np.nan],\n            [np.nan, np.nan, np.nan, np.nan, 4, 5, 6, 7],\n        ]\n        vals = list(map(list, zip(*vals)))\n        idx = Index([np.nan, 0, 1, 2, 4, 5, 6, 7], name=\"B\")\n        cols = MultiIndex(\n            levels=[[\"C\"], [\"a\", \"b\"]], codes=[[0, 0], [0, 1]], names=[None, \"A\"]\n        )\n\n        right = DataFrame(vals, columns=cols, index=idx)\n        tm.assert_frame_equal(left, right)\n\n        df = DataFrame({\"A\": list(\"aaaabbbb\"), \"B\": list(range(4)) * 2, \"C\": range(8)})\n        df.iloc[2, 1] = np.NaN\n        left = df.set_index([\"A\", \"B\"]).unstack(0)\n\n        vals = [[2, np.nan], [0, 4], [1, 5], [np.nan, 6], [3, 7]]\n        cols = MultiIndex(\n            levels=[[\"C\"], [\"a\", \"b\"]], codes=[[0, 0], [0, 1]], names=[None, \"A\"]\n        )\n        idx = Index([np.nan, 0, 1, 2, 3], name=\"B\")\n        right = DataFrame(vals, columns=cols, index=idx)\n        tm.assert_frame_equal(left, right)\n\n        df = pd.DataFrame(\n            {\"A\": list(\"aaaabbbb\"), \"B\": list(range(4)) * 2, \"C\": range(8)}\n        )\n        df.iloc[3, 1] = np.NaN\n        left = df.set_index([\"A\", \"B\"]).unstack(0)\n\n        vals = [[3, np.nan], [0, 4], [1, 5], [2, 6], [np.nan, 7]]\n        cols = MultiIndex(\n            levels=[[\"C\"], [\"a\", \"b\"]], codes=[[0, 0], [0, 1]], names=[None, \"A\"]\n        )\n        idx = Index([np.nan, 0, 1, 2, 3], name=\"B\")\n        right = DataFrame(vals, columns=cols, index=idx)\n        tm.assert_frame_equal(left, right)\n\n        # GH7401\n        df = pd.DataFrame(\n            {\n                \"A\": list(\"aaaaabbbbb\"),\n                \"B\": (date_range(\"2012-01-01\", periods=5).tolist() * 2),\n                \"C\": np.arange(10),\n            }\n        )\n\n        df.iloc[3, 1] = np.NaN\n        left = df.set_index([\"A\", \"B\"]).unstack()\n\n        vals = np.array([[3, 0, 1, 2, np.nan, 4], [np.nan, 5, 6, 7, 8, 9]])\n        idx = Index([\"a\", \"b\"], name=\"A\")\n        cols = MultiIndex(\n            levels=[[\"C\"], date_range(\"2012-01-01\", periods=5)],\n            codes=[[0, 0, 0, 0, 0, 0], [-1, 0, 1, 2, 3, 4]],\n            names=[None, \"B\"],\n        )\n\n        right = DataFrame(vals, columns=cols, index=idx)\n        tm.assert_frame_equal(left, right)\n\n        # GH4862\n        vals = [\n            [\"Hg\", np.nan, np.nan, 680585148],\n            [\"U\", 0.0, np.nan, 680585148],\n            [\"Pb\", 7.07e-06, np.nan, 680585148],\n            [\"Sn\", 2.3614e-05, 0.0133, 680607017],\n            [\"Ag\", 0.0, 0.0133, 680607017],\n            [\"Hg\", -0.00015, 0.0133, 680607017],\n        ]\n        df = DataFrame(\n            vals,\n            columns=[\"agent\", \"change\", \"dosage\", \"s_id\"],\n            index=[17263, 17264, 17265, 17266, 17267, 17268],\n        )\n\n        left = df.copy().set_index([\"s_id\", \"dosage\", \"agent\"]).unstack()\n\n        vals = [\n            [np.nan, np.nan, 7.07e-06, np.nan, 0.0],\n            [0.0, -0.00015, np.nan, 2.3614e-05, np.nan],\n        ]\n\n        idx = MultiIndex(\n            levels=[[680585148, 680607017], [0.0133]],\n            codes=[[0, 1], [-1, 0]],\n            names=[\"s_id\", \"dosage\"],\n        )\n\n        cols = MultiIndex(\n            levels=[[\"change\"], [\"Ag\", \"Hg\", \"Pb\", \"Sn\", \"U\"]],\n            codes=[[0, 0, 0, 0, 0], [0, 1, 2, 3, 4]],\n            names=[None, \"agent\"],\n        )\n\n        right = DataFrame(vals, columns=cols, index=idx)\n        tm.assert_frame_equal(left, right)\n\n        left = df.loc[17264:].copy().set_index([\"s_id\", \"dosage\", \"agent\"])\n        tm.assert_frame_equal(left.unstack(), right)\n\n        # GH9497 - multiple unstack with nulls\n        df = DataFrame(\n            {\n                \"1st\": [1, 2, 1, 2, 1, 2],\n                \"2nd\": pd.date_range(\"2014-02-01\", periods=6, freq=\"D\"),\n                \"jim\": 100 + np.arange(6),\n                \"joe\": (np.random.randn(6) * 10).round(2),\n            }\n        )\n\n        df[\"3rd\"] = df[\"2nd\"] - pd.Timestamp(\"2014-02-02\")\n        df.loc[1, \"2nd\"] = df.loc[3, \"2nd\"] = np.nan\n        df.loc[1, \"3rd\"] = df.loc[4, \"3rd\"] = np.nan\n\n        left = df.set_index([\"1st\", \"2nd\", \"3rd\"]).unstack([\"2nd\", \"3rd\"])\n        assert left.notna().values.sum() == 2 * len(df)\n\n        for col in [\"jim\", \"joe\"]:\n            for _, r in df.iterrows():\n                key = r[\"1st\"], (col, r[\"2nd\"], r[\"3rd\"])\n                assert r[col] == left.loc[key]",
        "begin_line": 822,
        "end_line": 1035,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.cast#823",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.cast(val)",
        "snippet": "        def cast(val):\n            val_str = \"\" if val != val else val\n            return f\"{val_str:1}\"",
        "begin_line": 823,
        "end_line": 825,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.verify#827",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.verify(df)",
        "snippet": "        def verify(df):\n            mk_list = lambda a: list(a) if isinstance(a, tuple) else [a]\n            rows, cols = df.notna().values.nonzero()\n            for i, j in zip(rows, cols):\n                left = sorted(df.iloc[i, j].split(\".\"))\n                right = mk_list(df.index[i]) + mk_list(df.columns[j])\n                right = sorted(map(cast, right))\n                assert left == right",
        "begin_line": 827,
        "end_line": 834,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_datetime_column_multiIndex#1037",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_datetime_column_multiIndex(self)",
        "snippet": "    def test_stack_datetime_column_multiIndex(self):\n        # GH 8039\n        t = datetime(2014, 1, 1)\n        df = DataFrame([1, 2, 3, 4], columns=MultiIndex.from_tuples([(t, \"A\", \"B\")]))\n        result = df.stack()\n\n        eidx = MultiIndex.from_product([(0, 1, 2, 3), (\"B\",)])\n        ecols = MultiIndex.from_tuples([(t, \"A\")])\n        expected = DataFrame([1, 2, 3, 4], index=eidx, columns=ecols)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1037,
        "end_line": 1046,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_partial_multiIndex#1048",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_partial_multiIndex(self)",
        "snippet": "    def test_stack_partial_multiIndex(self):\n        # GH 8844\n        def _test_stack_with_multiindex(multiindex):\n            df = DataFrame(\n                np.arange(3 * len(multiindex)).reshape(3, len(multiindex)),\n                columns=multiindex,\n            )\n            for level in (-1, 0, 1, [0, 1], [1, 0]):\n                result = df.stack(level=level, dropna=False)\n\n                if isinstance(level, int):\n                    # Stacking a single level should not make any all-NaN rows,\n                    # so df.stack(level=level, dropna=False) should be the same\n                    # as df.stack(level=level, dropna=True).\n                    expected = df.stack(level=level, dropna=True)\n                    if isinstance(expected, Series):\n                        tm.assert_series_equal(result, expected)\n                    else:\n                        tm.assert_frame_equal(result, expected)\n\n                df.columns = MultiIndex.from_tuples(\n                    df.columns.to_numpy(), names=df.columns.names\n                )\n                expected = df.stack(level=level, dropna=False)\n                if isinstance(expected, Series):\n                    tm.assert_series_equal(result, expected)\n                else:\n                    tm.assert_frame_equal(result, expected)\n\n        full_multiindex = MultiIndex.from_tuples(\n            [(\"B\", \"x\"), (\"B\", \"z\"), (\"A\", \"y\"), (\"C\", \"x\"), (\"C\", \"u\")],\n            names=[\"Upper\", \"Lower\"],\n        )\n        for multiindex_columns in (\n            [0, 1, 2, 3, 4],\n            [0, 1, 2, 3],\n            [0, 1, 2, 4],\n            [0, 1, 2],\n            [1, 2, 3],\n            [2, 3, 4],\n            [0, 1],\n            [0, 2],\n            [0, 3],\n            [0],\n            [2],\n            [4],\n        ):\n            _test_stack_with_multiindex(full_multiindex[multiindex_columns])\n            if len(multiindex_columns) > 1:\n                multiindex_columns.reverse()\n                _test_stack_with_multiindex(full_multiindex[multiindex_columns])\n\n        df = DataFrame(np.arange(6).reshape(2, 3), columns=full_multiindex[[0, 1, 3]])\n        result = df.stack(dropna=False)\n        expected = DataFrame(\n            [[0, 2], [1, np.nan], [3, 5], [4, np.nan]],\n            index=MultiIndex(\n                levels=[[0, 1], [\"u\", \"x\", \"y\", \"z\"]],\n                codes=[[0, 0, 1, 1], [1, 3, 1, 3]],\n                names=[None, \"Lower\"],\n            ),\n            columns=Index([\"B\", \"C\"], name=\"Upper\"),\n            dtype=df.dtypes[0],\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1048,
        "end_line": 1112,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape._test_stack_with_multiindex#1050",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape._test_stack_with_multiindex(multiindex)",
        "snippet": "        def _test_stack_with_multiindex(multiindex):\n            df = DataFrame(\n                np.arange(3 * len(multiindex)).reshape(3, len(multiindex)),\n                columns=multiindex,\n            )\n            for level in (-1, 0, 1, [0, 1], [1, 0]):\n                result = df.stack(level=level, dropna=False)\n\n                if isinstance(level, int):\n                    # Stacking a single level should not make any all-NaN rows,\n                    # so df.stack(level=level, dropna=False) should be the same\n                    # as df.stack(level=level, dropna=True).\n                    expected = df.stack(level=level, dropna=True)\n                    if isinstance(expected, Series):\n                        tm.assert_series_equal(result, expected)\n                    else:\n                        tm.assert_frame_equal(result, expected)\n\n                df.columns = MultiIndex.from_tuples(\n                    df.columns.to_numpy(), names=df.columns.names\n                )\n                expected = df.stack(level=level, dropna=False)\n                if isinstance(expected, Series):\n                    tm.assert_series_equal(result, expected)\n                else:\n                    tm.assert_frame_equal(result, expected)",
        "begin_line": 1050,
        "end_line": 1075,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_preserve_categorical_dtype#1116",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_preserve_categorical_dtype(self, ordered, labels)",
        "snippet": "    def test_stack_preserve_categorical_dtype(self, ordered, labels):\n        # GH13854\n        cidx = pd.CategoricalIndex(labels, categories=list(\"xyz\"), ordered=ordered)\n        df = DataFrame([[10, 11, 12]], columns=cidx)\n        result = df.stack()\n\n        # `MultiIndex.from_product` preserves categorical dtype -\n        # it's tested elsewhere.\n        midx = pd.MultiIndex.from_product([df.index, cidx])\n        expected = Series([10, 11, 12], index=midx)\n\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1116,
        "end_line": 1127,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_preserve_categorical_dtype_values#1129",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_preserve_categorical_dtype_values(self)",
        "snippet": "    def test_stack_preserve_categorical_dtype_values(self):\n        # GH-23077\n        cat = pd.Categorical([\"a\", \"a\", \"b\", \"c\"])\n        df = pd.DataFrame({\"A\": cat, \"B\": cat})\n        result = df.stack()\n        index = pd.MultiIndex.from_product([[0, 1, 2, 3], [\"A\", \"B\"]])\n        expected = pd.Series(\n            pd.Categorical([\"a\", \"a\", \"a\", \"a\", \"b\", \"b\", \"c\", \"c\"]), index=index\n        )\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1129,
        "end_line": 1138,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_multi_columns_non_unique_index#1148",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_stack_multi_columns_non_unique_index(self, index, columns)",
        "snippet": "    def test_stack_multi_columns_non_unique_index(self, index, columns):\n        # GH-28301\n        df = pd.DataFrame(index=index, columns=columns).fillna(1)\n        stacked = df.stack()\n        new_index = pd.MultiIndex.from_tuples(stacked.index.to_numpy())\n        expected = pd.DataFrame(\n            stacked.to_numpy(), index=new_index, columns=stacked.columns\n        )\n        tm.assert_frame_equal(stacked, expected)\n        stacked_codes = np.asarray(stacked.index.codes)\n        expected_codes = np.asarray(new_index.codes)\n        tm.assert_numpy_array_equal(stacked_codes, expected_codes)",
        "begin_line": 1148,
        "end_line": 1159,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_mixed_extension_types#1162",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_mixed_extension_types(self, level)",
        "snippet": "    def test_unstack_mixed_extension_types(self, level):\n        index = pd.MultiIndex.from_tuples(\n            [(\"A\", 0), (\"A\", 1), (\"B\", 1)], names=[\"a\", \"b\"]\n        )\n        df = pd.DataFrame(\n            {\n                \"A\": pd.core.arrays.integer_array([0, 1, None]),\n                \"B\": pd.Categorical([\"a\", \"a\", \"b\"]),\n            },\n            index=index,\n        )\n\n        result = df.unstack(level=level)\n        expected = df.astype(object).unstack(level=level)\n\n        expected_dtypes = pd.Series(\n            [df.A.dtype] * 2 + [df.B.dtype] * 2, index=result.columns\n        )\n        tm.assert_series_equal(result.dtypes, expected_dtypes)\n        tm.assert_frame_equal(result.astype(object), expected)",
        "begin_line": 1162,
        "end_line": 1181,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_swaplevel_sortlevel#1184",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape.TestDataFrameReshape",
        "signature": "pandas.tests.frame.test_reshape.TestDataFrameReshape.test_unstack_swaplevel_sortlevel(self, level)",
        "snippet": "    def test_unstack_swaplevel_sortlevel(self, level):\n        # GH 20994\n        mi = pd.MultiIndex.from_product([[0], [\"d\", \"c\"]], names=[\"bar\", \"baz\"])\n        df = pd.DataFrame([[0, 2], [1, 3]], index=mi, columns=[\"B\", \"A\"])\n        df.columns.name = \"foo\"\n\n        expected = pd.DataFrame(\n            [[3, 1, 2, 0]],\n            columns=pd.MultiIndex.from_tuples(\n                [(\"c\", \"A\"), (\"c\", \"B\"), (\"d\", \"A\"), (\"d\", \"B\")], names=[\"baz\", \"foo\"]\n            ),\n        )\n        expected.index.name = \"bar\"\n\n        result = df.unstack().swaplevel(axis=1).sort_index(axis=1, level=level)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1184,
        "end_line": 1199,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.test_unstack_fill_frame_object#1202",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape",
        "signature": "pandas.tests.frame.test_reshape.test_unstack_fill_frame_object()",
        "snippet": "def test_unstack_fill_frame_object():\n    # GH12815 Test unstacking with object.\n    data = pd.Series([\"a\", \"b\", \"c\", \"a\"], dtype=\"object\")\n    data.index = pd.MultiIndex.from_tuples(\n        [(\"x\", \"a\"), (\"x\", \"b\"), (\"y\", \"b\"), (\"z\", \"a\")]\n    )\n\n    # By default missing values will be NaN\n    result = data.unstack()\n    expected = pd.DataFrame(\n        {\"a\": [\"a\", np.nan, \"a\"], \"b\": [\"b\", \"c\", np.nan]}, index=list(\"xyz\")\n    )\n    tm.assert_frame_equal(result, expected)\n\n    # Fill with any value replaces missing values as expected\n    result = data.unstack(fill_value=\"d\")\n    expected = pd.DataFrame(\n        {\"a\": [\"a\", \"d\", \"a\"], \"b\": [\"b\", \"c\", \"d\"]}, index=list(\"xyz\")\n    )\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 1202,
        "end_line": 1221,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.test_unstack_timezone_aware_values#1224",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape",
        "signature": "pandas.tests.frame.test_reshape.test_unstack_timezone_aware_values()",
        "snippet": "def test_unstack_timezone_aware_values():\n    # GH 18338\n    df = pd.DataFrame(\n        {\n            \"timestamp\": [pd.Timestamp(\"2017-08-27 01:00:00.709949+0000\", tz=\"UTC\")],\n            \"a\": [\"a\"],\n            \"b\": [\"b\"],\n            \"c\": [\"c\"],\n        },\n        columns=[\"timestamp\", \"a\", \"b\", \"c\"],\n    )\n    result = df.set_index([\"a\", \"b\"]).unstack()\n    expected = pd.DataFrame(\n        [[pd.Timestamp(\"2017-08-27 01:00:00.709949+0000\", tz=\"UTC\"), \"c\"]],\n        index=pd.Index([\"a\"], name=\"a\"),\n        columns=pd.MultiIndex(\n            levels=[[\"timestamp\", \"c\"], [\"b\"]],\n            codes=[[0, 1], [0, 0]],\n            names=[None, \"b\"],\n        ),\n    )\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 1224,
        "end_line": 1245,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.test_stack_timezone_aware_values#1248",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape",
        "signature": "pandas.tests.frame.test_reshape.test_stack_timezone_aware_values()",
        "snippet": "def test_stack_timezone_aware_values():\n    # GH 19420\n    ts = pd.date_range(\n        freq=\"D\", start=\"20180101\", end=\"20180103\", tz=\"America/New_York\"\n    )\n    df = pd.DataFrame({\"A\": ts}, index=[\"a\", \"b\", \"c\"])\n    result = df.stack()\n    expected = pd.Series(\n        ts,\n        index=pd.MultiIndex(\n            levels=[[\"a\", \"b\", \"c\"], [\"A\"]], codes=[[0, 1, 2], [0, 0, 0]]\n        ),\n    )\n    tm.assert_series_equal(result, expected)",
        "begin_line": 1248,
        "end_line": 1261,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_reshape.test_unstacking_multi_index_df#1264",
        "src_path": "pandas/tests/frame/test_reshape.py",
        "class_name": "pandas.tests.frame.test_reshape",
        "signature": "pandas.tests.frame.test_reshape.test_unstacking_multi_index_df()",
        "snippet": "def test_unstacking_multi_index_df():\n    # see gh-30740\n    df = DataFrame(\n        {\n            \"name\": [\"Alice\", \"Bob\"],\n            \"score\": [9.5, 8],\n            \"employed\": [False, True],\n            \"kids\": [0, 0],\n            \"gender\": [\"female\", \"male\"],\n        }\n    )\n    df = df.set_index([\"name\", \"employed\", \"kids\", \"gender\"])\n    df = df.unstack([\"gender\"], fill_value=0)\n    expected = df.unstack(\"employed\", fill_value=0).unstack(\"kids\", fill_value=0)\n    result = df.unstack([\"employed\", \"kids\"], fill_value=0)\n    expected = DataFrame(\n        [[9.5, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 8.0]],\n        index=Index([\"Alice\", \"Bob\"], name=\"name\"),\n        columns=MultiIndex.from_tuples(\n            [\n                (\"score\", \"female\", False, 0),\n                (\"score\", \"female\", True, 0),\n                (\"score\", \"male\", False, 0),\n                (\"score\", \"male\", True, 0),\n            ],\n            names=[None, \"gender\", \"employed\", \"kids\"],\n        ),\n    )\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 1264,
        "end_line": 1292,
        "comment": "",
        "is_bug": false
    }
]