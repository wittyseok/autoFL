[
    {
        "name": "luigi.date_interval.DateInterval.__init__#60",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__init__(self, date_a, date_b)",
        "snippet": "    def __init__(self, date_a, date_b):\n        self.date_a = date_a\n        self.date_b = date_b",
        "begin_line": 60,
        "end_line": 62,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0025974025974025974,
            "pseudo_dstar_susp": 0.0021141649048625794,
            "pseudo_tarantula_susp": 0.004545454545454545,
            "pseudo_op2_susp": 0.0021141649048625794,
            "pseudo_barinel_susp": 0.004545454545454545
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.dates#64",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.dates(self)",
        "snippet": "    def dates(self):\n        ''' Returns a list of dates in this date interval.'''\n        dates = []\n        d = self.date_a\n        while d < self.date_b:\n            dates.append(d)\n            d += datetime.timedelta(1)\n\n        return dates",
        "begin_line": 64,
        "end_line": 72,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005827505827505828,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__str__#80",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__str__(self)",
        "snippet": "    def __str__(self):\n        return self.to_string()",
        "begin_line": 80,
        "end_line": 81,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__repr__#83",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return self.to_string()",
        "begin_line": 83,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.prev#86",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.prev(self)",
        "snippet": "    def prev(self):\n        ''' Returns the preceding corresponding date interval (eg. May -> April).'''\n        return self.from_date(self.date_a - datetime.timedelta(1))",
        "begin_line": 86,
        "end_line": 88,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.next#90",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.next(self)",
        "snippet": "    def next(self):\n        ''' Returns the subsequent corresponding date interval (eg. 2014 -> 2015).'''\n        return self.from_date(self.date_b)",
        "begin_line": 90,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000630119722747322,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.from_date#98",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.from_date(cls, d)",
        "snippet": "    def from_date(cls, d):\n        ''' Abstract class method.\n\n        For instance, ``Month.from_date(datetime.date(2012, 6, 6))`` returns a ``Month(2012, 6)``.'''\n        raise NotImplementedError",
        "begin_line": 98,
        "end_line": 102,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__hash__#118",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__hash__(self)",
        "snippet": "    def __hash__(self):\n        return hash(repr(self))",
        "begin_line": 118,
        "end_line": 119,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005361930294906167,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__lt__#127",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__lt__(self, other)",
        "snippet": "    def __lt__(self, other):\n        if not isinstance(self, type(other)):\n            raise TypeError('Date interval type mismatch')\n        return (self.date_a, self.date_b) < (other.date_a, other.date_b)",
        "begin_line": 127,
        "end_line": 130,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__le__#132",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__le__(self, other)",
        "snippet": "    def __le__(self, other):\n        if not isinstance(self, type(other)):\n            raise TypeError('Date interval type mismatch')\n        return (self.date_a, self.date_b) <= (other.date_a, other.date_b)",
        "begin_line": 132,
        "end_line": 135,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__gt__#137",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__gt__(self, other)",
        "snippet": "    def __gt__(self, other):\n        if not isinstance(self, type(other)):\n            raise TypeError('Date interval type mismatch')\n        return (self.date_a, self.date_b) > (other.date_a, other.date_b)",
        "begin_line": 137,
        "end_line": 140,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.DateInterval.__eq__#147",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.DateInterval",
        "signature": "luigi.date_interval.DateInterval.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        if not isinstance(other, DateInterval):\n            return False\n        if not isinstance(self, type(other)):\n            raise TypeError('Date interval type mismatch')\n        else:\n            return (self.date_a, self.date_b) == (other.date_a, other.date_b)",
        "begin_line": 147,
        "end_line": 153,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005534034311012728,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.Date.__init__#163",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Date",
        "signature": "luigi.date_interval.Date.__init__(self, y, m, d)",
        "snippet": "    def __init__(self, y, m, d):\n        a = datetime.date(y, m, d)\n        b = datetime.date(y, m, d) + datetime.timedelta(1)\n        super(Date, self).__init__(a, b)",
        "begin_line": 163,
        "end_line": 166,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.Week.__init__#187",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Week",
        "signature": "luigi.date_interval.Week.__init__(self, y, w)",
        "snippet": "    def __init__(self, y, w):\n        ''' Python datetime does not have a method to convert from ISO weeks, so the constructor uses some stupid brute force'''\n        for d in xrange(-10, 370):\n            date = datetime.date(y, 1, 1) + datetime.timedelta(d)\n            if date.isocalendar() == (y, w, 1):\n                date_a = date\n                break\n        else:\n            raise ValueError('Invalid week')\n        date_b = date_a + datetime.timedelta(7)\n        super(Week, self).__init__(date_a, date_b)",
        "begin_line": 187,
        "end_line": 197,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.Week.to_string#199",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Week",
        "signature": "luigi.date_interval.Week.to_string(self)",
        "snippet": "    def to_string(self):\n        return '%d-W%02d' % self.date_a.isocalendar()[:2]",
        "begin_line": 199,
        "end_line": 200,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.Week.from_date#203",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Week",
        "signature": "luigi.date_interval.Week.from_date(cls, d)",
        "snippet": "    def from_date(cls, d):\n        return Week(*d.isocalendar()[:2])",
        "begin_line": 203,
        "end_line": 204,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.Week.parse#207",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Week",
        "signature": "luigi.date_interval.Week.parse(cls, s)",
        "snippet": "    def parse(cls, s):\n        if re.match(r'\\d\\d\\d\\d\\-W\\d\\d$', s):\n            y, w = map(int, s.split('-W'))\n            return Week(y, w)",
        "begin_line": 207,
        "end_line": 210,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.Month.__init__#215",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Month",
        "signature": "luigi.date_interval.Month.__init__(self, y, m)",
        "snippet": "    def __init__(self, y, m):\n        date_a = datetime.date(y, m, 1)\n        date_b = datetime.date(y + m // 12, 1 + m % 12, 1)\n        super(Month, self).__init__(date_a, date_b)",
        "begin_line": 215,
        "end_line": 218,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.018518518518518517,
            "pseudo_dstar_susp": 0.0033222591362126247,
            "pseudo_tarantula_susp": 0.013888888888888888,
            "pseudo_op2_susp": 0.0033222591362126247,
            "pseudo_barinel_susp": 0.013888888888888888
        }
    },
    {
        "name": "luigi.date_interval.Month.to_string#220",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Month",
        "signature": "luigi.date_interval.Month.to_string(self)",
        "snippet": "    def to_string(self):\n        return self.date_a.strftime('%Y-%m')",
        "begin_line": 220,
        "end_line": 221,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.Month.from_date#224",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Month",
        "signature": "luigi.date_interval.Month.from_date(cls, d)",
        "snippet": "    def from_date(cls, d):\n        return Month(d.year, d.month)",
        "begin_line": 224,
        "end_line": 225,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.Year.__init__#236",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Year",
        "signature": "luigi.date_interval.Year.__init__(self, y)",
        "snippet": "    def __init__(self, y):\n        date_a = datetime.date(y, 1, 1)\n        date_b = datetime.date(y + 1, 1, 1)\n        super(Year, self).__init__(date_a, date_b)",
        "begin_line": 236,
        "end_line": 239,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.Year.to_string#241",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Year",
        "signature": "luigi.date_interval.Year.to_string(self)",
        "snippet": "    def to_string(self):\n        return self.date_a.strftime('%Y')",
        "begin_line": 241,
        "end_line": 242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.Year.from_date#245",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Year",
        "signature": "luigi.date_interval.Year.from_date(cls, d)",
        "snippet": "    def from_date(cls, d):\n        return Year(d.year)",
        "begin_line": 245,
        "end_line": 246,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.Year.parse#249",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Year",
        "signature": "luigi.date_interval.Year.parse(cls, s)",
        "snippet": "    def parse(cls, s):\n        if re.match(r'\\d\\d\\d\\d$', s):\n            return Year(int(s))",
        "begin_line": 249,
        "end_line": 251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005186721991701245,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.date_interval.Custom.parse#266",
        "src_path": "luigi/date_interval.py",
        "class_name": "luigi.date_interval.Custom",
        "signature": "luigi.date_interval.Custom.parse(cls, s)",
        "snippet": "    def parse(cls, s):\n        if re.match(r'\\d\\d\\d\\d\\-\\d\\d\\-\\d\\d\\-\\d\\d\\d\\d\\-\\d\\d\\-\\d\\d$', s):\n            x = list(map(int, s.split('-')))\n            date_a = datetime.date(*x[:3])\n            date_b = datetime.date(*x[3:])\n            return Custom(date_a, date_b)",
        "begin_line": 266,
        "end_line": 271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.get_all_data#40",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.get_all_data(self)",
        "snippet": "    def get_all_data(self):\n        # This starts a server in the background, so we don't want to do it in the global scope\n        if MockFileSystem._data is None:\n            MockFileSystem._data = multiprocessing.Manager().dict()\n        return MockFileSystem._data",
        "begin_line": 40,
        "end_line": 44,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006031363088057901,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.get_data#46",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.get_data(self, fn)",
        "snippet": "    def get_data(self, fn):\n        return self.get_all_data()[fn]",
        "begin_line": 46,
        "end_line": 47,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005827505827505828,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.exists#49",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.exists(self, path)",
        "snippet": "    def exists(self, path):\n        return MockTarget(path).exists()",
        "begin_line": 49,
        "end_line": 50,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.remove#52",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.remove(self, path, recursive=True, skip_trash=True)",
        "snippet": "    def remove(self, path, recursive=True, skip_trash=True):\n        \"\"\"\n        Removes the given mockfile. skip_trash doesn't have any meaning.\n        \"\"\"\n        if recursive:\n            to_delete = []\n            for s in self.get_all_data().keys():\n                if s.startswith(path):\n                    to_delete.append(s)\n            for s in to_delete:\n                self.get_all_data().pop(s)\n        else:\n            self.get_all_data().pop(path)",
        "begin_line": 52,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.MockFileSystem.clear#82",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFileSystem",
        "signature": "luigi.mock.MockFileSystem.clear(self)",
        "snippet": "    def clear(self):\n        self.get_all_data().clear()",
        "begin_line": 82,
        "end_line": 83,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00045433893684688776,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.MockTarget.__init__#89",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockTarget",
        "signature": "luigi.mock.MockTarget.__init__(self, fn, is_tmp=None, mirror_on_stderr=False, format=None)",
        "snippet": "    def __init__(self, fn, is_tmp=None, mirror_on_stderr=False, format=None):\n        self._mirror_on_stderr = mirror_on_stderr\n        self._fn = fn\n        if format is None:\n            format = get_default_format()\n\n        # Allow to write unicode in file for retrocompatibility\n        if six.PY2:\n            format = format >> MixedUnicodeBytes\n\n        self.format = format",
        "begin_line": 89,
        "end_line": 99,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005534034311012728,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.MockTarget.exists#101",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockTarget",
        "signature": "luigi.mock.MockTarget.exists(self)",
        "snippet": "    def exists(self,):\n        return self._fn in self.fs.get_all_data()",
        "begin_line": 101,
        "end_line": 102,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.MockTarget.path#111",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockTarget",
        "signature": "luigi.mock.MockTarget.path(self)",
        "snippet": "    def path(self):\n        return self._fn",
        "begin_line": 111,
        "end_line": 112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005659309564233164,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.MockTarget.open#114",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockTarget",
        "signature": "luigi.mock.MockTarget.open(self, mode)",
        "snippet": "    def open(self, mode):\n        fn = self._fn\n        mock_target = self\n\n        class Buffer(BytesIO):\n            # Just to be able to do writing + reading from the same buffer\n\n            _write_line = True\n\n            def set_wrapper(self, wrapper):\n                self.wrapper = wrapper\n\n            def write(self, data):\n                if six.PY3:\n                    stderrbytes = sys.stderr.buffer\n                else:\n                    stderrbytes = sys.stderr\n\n                if mock_target._mirror_on_stderr:\n                    if self._write_line:\n                        sys.stderr.write(fn + \": \")\n                    stderrbytes.write(data)\n                    if (data[-1]) == '\\n':\n                        self._write_line = True\n                    else:\n                        self._write_line = False\n                super(Buffer, self).write(data)\n\n            def close(self):\n                if mode == 'w':\n                    try:\n                        mock_target.wrapper.flush()\n                    except AttributeError:\n                        pass\n                    mock_target.fs.get_all_data()[fn] = self.getvalue()\n                super(Buffer, self).close()\n\n            def __exit__(self, exc_type, exc_val, exc_tb):\n                if not exc_type:\n                    self.close()\n\n            def __enter__(self):\n                return self\n\n            def readable(self):\n                return mode == 'r'\n\n            def writeable(self):\n                return mode == 'w'\n\n            def seekable(self):\n                return False\n\n        if mode == 'w':\n            wrapper = self.format.pipe_writer(Buffer())\n            wrapper.set_wrapper(wrapper)\n            return wrapper\n        else:\n            return self.format.pipe_reader(Buffer(self.fs.get_all_data()[fn]))",
        "begin_line": 114,
        "end_line": 172,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004399472063352398,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.Buffer.open#114",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.open(self, mode)",
        "snippet": "    def open(self, mode):\n        fn = self._fn\n        mock_target = self\n\n        class Buffer(BytesIO):\n            # Just to be able to do writing + reading from the same buffer\n\n            _write_line = True\n\n            def set_wrapper(self, wrapper):\n                self.wrapper = wrapper\n\n            def write(self, data):\n                if six.PY3:\n                    stderrbytes = sys.stderr.buffer\n                else:\n                    stderrbytes = sys.stderr\n\n                if mock_target._mirror_on_stderr:\n                    if self._write_line:\n                        sys.stderr.write(fn + \": \")\n                    stderrbytes.write(data)\n                    if (data[-1]) == '\\n':\n                        self._write_line = True\n                    else:\n                        self._write_line = False\n                super(Buffer, self).write(data)\n\n            def close(self):\n                if mode == 'w':\n                    try:\n                        mock_target.wrapper.flush()\n                    except AttributeError:\n                        pass\n                    mock_target.fs.get_all_data()[fn] = self.getvalue()\n                super(Buffer, self).close()\n\n            def __exit__(self, exc_type, exc_val, exc_tb):\n                if not exc_type:\n                    self.close()\n\n            def __enter__(self):\n                return self\n\n            def readable(self):\n                return mode == 'r'\n\n            def writeable(self):\n                return mode == 'w'\n\n            def seekable(self):\n                return False\n\n        if mode == 'w':\n            wrapper = self.format.pipe_writer(Buffer())\n            wrapper.set_wrapper(wrapper)\n            return wrapper\n        else:\n            return self.format.pipe_reader(Buffer(self.fs.get_all_data()[fn]))",
        "begin_line": 114,
        "end_line": 172,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00040816326530612246,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.Buffer.set_wrapper#123",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.set_wrapper(self, wrapper)",
        "snippet": "            def set_wrapper(self, wrapper):\n                self.wrapper = wrapper",
        "begin_line": 123,
        "end_line": 124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004268032437046522,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.Buffer.write#126",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.write(self, data)",
        "snippet": "            def write(self, data):\n                if six.PY3:\n                    stderrbytes = sys.stderr.buffer\n                else:\n                    stderrbytes = sys.stderr\n\n                if mock_target._mirror_on_stderr:\n                    if self._write_line:\n                        sys.stderr.write(fn + \": \")\n                    stderrbytes.write(data)\n                    if (data[-1]) == '\\n':\n                        self._write_line = True\n                    else:\n                        self._write_line = False\n                super(Buffer, self).write(data)",
        "begin_line": 126,
        "end_line": 140,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.Buffer.close#142",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.close(self)",
        "snippet": "            def close(self):\n                if mode == 'w':\n                    try:\n                        mock_target.wrapper.flush()\n                    except AttributeError:\n                        pass\n                    mock_target.fs.get_all_data()[fn] = self.getvalue()\n                super(Buffer, self).close()",
        "begin_line": 142,
        "end_line": 149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00042158516020236085,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.Buffer.__exit__#151",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.__exit__(self, exc_type, exc_val, exc_tb)",
        "snippet": "            def __exit__(self, exc_type, exc_val, exc_tb):\n                if not exc_type:\n                    self.close()",
        "begin_line": 151,
        "end_line": 153,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004268032437046522,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.Buffer.__enter__#155",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.__enter__(self)",
        "snippet": "            def __enter__(self):\n                return self",
        "begin_line": 155,
        "end_line": 156,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00043535045711797995,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.Buffer.readable#158",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.readable(self)",
        "snippet": "            def readable(self):\n                return mode == 'r'",
        "begin_line": 158,
        "end_line": 159,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00042158516020236085,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.Buffer.writeable#161",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.writeable(self)",
        "snippet": "            def writeable(self):\n                return mode == 'w'",
        "begin_line": 161,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00041135335252982314,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.Buffer.seekable#164",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.Buffer",
        "signature": "luigi.mock.Buffer.seekable(self)",
        "snippet": "            def seekable(self):\n                return False",
        "begin_line": 164,
        "end_line": 165,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00040112314480545525,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.mock.MockFile.__init__#176",
        "src_path": "luigi/mock.py",
        "class_name": "luigi.mock.MockFile",
        "signature": "luigi.mock.MockFile.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        warnings.warn(\"MockFile has been renamed MockTarget\", DeprecationWarning, stacklevel=2)\n        super(MockFile, self).__init__(*args, **kwargs)",
        "begin_line": 176,
        "end_line": 178,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00042158516020236085,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkRunContext.__init__#48",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkRunContext",
        "signature": "luigi.contrib.spark.SparkRunContext.__init__(self, proc)",
        "snippet": "    def __init__(self, proc):\n        self.proc = proc",
        "begin_line": 48,
        "end_line": 49,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000501002004008016,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkRunContext.__enter__#51",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkRunContext",
        "signature": "luigi.contrib.spark.SparkRunContext.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self.__old_signal = signal.getsignal(signal.SIGTERM)\n        signal.signal(signal.SIGTERM, self.kill_job)\n        return self",
        "begin_line": 51,
        "end_line": 54,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005186721991701245,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkRunContext.__exit__#56",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkRunContext",
        "signature": "luigi.contrib.spark.SparkRunContext.__exit__(self, exc_type, exc_val, exc_tb)",
        "snippet": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is KeyboardInterrupt:\n            self.kill_job()\n        signal.signal(signal.SIGTERM, self.__old_signal)",
        "begin_line": 56,
        "end_line": 59,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkRunContext.kill_job#61",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkRunContext",
        "signature": "luigi.contrib.spark.SparkRunContext.kill_job(self, captured_signal=None, stack_frame=None)",
        "snippet": "    def kill_job(self, captured_signal=None, stack_frame=None):\n        self.proc.kill()\n        if captured_signal is not None:\n            # adding 128 gives the exit code corresponding to a signal\n            sys.exit(128 + captured_signal)",
        "begin_line": 61,
        "end_line": 65,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkJobError.__init__#70",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkJobError",
        "signature": "luigi.contrib.spark.SparkJobError.__init__(self, message, out=None, err=None)",
        "snippet": "    def __init__(self, message, out=None, err=None):\n        super(SparkJobError, self).__init__(message, out, err)\n        self.message = message\n        self.out = out\n        self.err = err",
        "begin_line": 70,
        "end_line": 74,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkJobError.__str__#76",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkJobError",
        "signature": "luigi.contrib.spark.SparkJobError.__str__(self)",
        "snippet": "    def __str__(self):\n        info = self.message\n        if self.out:\n            info += \"\\nSTDOUT: \" + str(self.out)\n        if self.err:\n            info += \"\\nSTDERR: \" + str(self.err)\n        return info",
        "begin_line": 76,
        "end_line": 82,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.spark_submit#109",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.spark_submit(self)",
        "snippet": "    def spark_submit(self):\n        return configuration.get_config().get('spark', 'spark-submit', 'spark-submit')",
        "begin_line": 109,
        "end_line": 110,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004655493482309125,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.master#113",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.master(self)",
        "snippet": "    def master(self):\n        return configuration.get_config().get(\"spark\", \"master\", None)",
        "begin_line": 113,
        "end_line": 114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005659309564233164,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.deploy_mode#117",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.deploy_mode(self)",
        "snippet": "    def deploy_mode(self):\n        return configuration.get_config().get(\"spark\", \"deploy-mode\", None)",
        "begin_line": 117,
        "end_line": 118,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006031363088057901,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.jars#121",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.jars(self)",
        "snippet": "    def jars(self):\n        return self._list_config(configuration.get_config().get(\"spark\", \"jars\", None))",
        "begin_line": 121,
        "end_line": 122,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.packages#125",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.packages(self)",
        "snippet": "    def packages(self):\n        return self._list_config(configuration.get_config().get(\"spark\", \"packages\", None))",
        "begin_line": 125,
        "end_line": 126,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005361930294906167,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.py_files#129",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.py_files(self)",
        "snippet": "    def py_files(self):\n        return self._list_config(configuration.get_config().get(\"spark\", \"py-files\", None))",
        "begin_line": 129,
        "end_line": 130,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005827505827505828,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.files#133",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.files(self)",
        "snippet": "    def files(self):\n        return self._list_config(configuration.get_config().get(\"spark\", \"files\", None))",
        "begin_line": 133,
        "end_line": 134,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005827505827505828,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.conf#137",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.conf(self)",
        "snippet": "    def conf(self):\n        return self._dict_config(configuration.get_config().get(\"spark\", \"conf\", None))",
        "begin_line": 137,
        "end_line": 138,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005827505827505828,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.properties_file#141",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.properties_file(self)",
        "snippet": "    def properties_file(self):\n        return configuration.get_config().get(\"spark\", \"properties-file\", None)",
        "begin_line": 141,
        "end_line": 142,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005659309564233164,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.driver_memory#145",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.driver_memory(self)",
        "snippet": "    def driver_memory(self):\n        return configuration.get_config().get(\"spark\", \"driver-memory\", None)",
        "begin_line": 145,
        "end_line": 146,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005659309564233164,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.driver_java_options#149",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.driver_java_options(self)",
        "snippet": "    def driver_java_options(self):\n        return configuration.get_config().get(\"spark\", \"driver-java-options\", None)",
        "begin_line": 149,
        "end_line": 150,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005361930294906167,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.driver_library_path#153",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.driver_library_path(self)",
        "snippet": "    def driver_library_path(self):\n        return configuration.get_config().get(\"spark\", \"driver-library-path\", None)",
        "begin_line": 153,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005659309564233164,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.driver_class_path#157",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.driver_class_path(self)",
        "snippet": "    def driver_class_path(self):\n        return configuration.get_config().get(\"spark\", \"driver-class-path\", None)",
        "begin_line": 157,
        "end_line": 158,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005659309564233164,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.executor_memory#161",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.executor_memory(self)",
        "snippet": "    def executor_memory(self):\n        return configuration.get_config().get(\"spark\", \"executor-memory\", None)",
        "begin_line": 161,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005361930294906167,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.driver_cores#165",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.driver_cores(self)",
        "snippet": "    def driver_cores(self):\n        return configuration.get_config().get(\"spark\", \"driver-cores\", None)",
        "begin_line": 165,
        "end_line": 166,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005659309564233164,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.supervise#169",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.supervise(self)",
        "snippet": "    def supervise(self):\n        return bool(configuration.get_config().get(\"spark\", \"supervise\", False))",
        "begin_line": 169,
        "end_line": 170,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005659309564233164,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.executor_cores#177",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.executor_cores(self)",
        "snippet": "    def executor_cores(self):\n        return configuration.get_config().get(\"spark\", \"executor-cores\", None)",
        "begin_line": 177,
        "end_line": 178,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005361930294906167,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.spark_command#203",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.spark_command(self)",
        "snippet": "    def spark_command(self):\n        command = [self.spark_submit]\n        command += self._text_arg('--master', self.master)\n        command += self._text_arg('--deploy-mode', self.deploy_mode)\n        command += self._text_arg('--name', self.name)\n        command += self._text_arg('--class', self.entry_class)\n        command += self._list_arg('--jars', self.jars)\n        command += self._list_arg('--packages', self.packages)\n        command += self._list_arg('--py-files', self.py_files)\n        command += self._list_arg('--files', self.files)\n        command += self._list_arg('--archives', self.archives)\n        command += self._dict_arg('--conf', self.conf)\n        command += self._text_arg('--properties-file', self.properties_file)\n        command += self._text_arg('--driver-memory', self.driver_memory)\n        command += self._text_arg('--driver-java-options', self.driver_java_options)\n        command += self._text_arg('--driver-library-path', self.driver_library_path)\n        command += self._text_arg('--driver-class-path', self.driver_class_path)\n        command += self._text_arg('--executor-memory', self.executor_memory)\n        command += self._text_arg('--driver-cores', self.driver_cores)\n        command += self._flag_arg('--supervise', self.supervise)\n        command += self._text_arg('--total-executor-cores', self.total_executor_cores)\n        command += self._text_arg('--executor-cores', self.executor_cores)\n        command += self._text_arg('--queue', self.queue)\n        command += self._text_arg('--num-executors', self.num_executors)\n        return command",
        "begin_line": 203,
        "end_line": 227,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005361930294906167,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.app_command#229",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.app_command(self)",
        "snippet": "    def app_command(self):\n        if not self.app:\n            raise NotImplementedError(\"subclass should define an app (.jar or .py file)\")\n        return [self.app] + self.app_options()",
        "begin_line": 229,
        "end_line": 232,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000501002004008016,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask.run#234",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask.run(self)",
        "snippet": "    def run(self):\n        args = list(map(str, self.spark_command() + self.app_command()))\n        logger.info('Running: %s', repr(args))\n        tmp_stdout, tmp_stderr = tempfile.TemporaryFile(), tempfile.TemporaryFile()\n        proc = subprocess.Popen(args, stdout=tmp_stdout, stderr=tmp_stderr,\n                                env=self.get_environment(), close_fds=True,\n                                universal_newlines=True)\n        try:\n            with SparkRunContext(proc):\n                proc.wait()\n            tmp_stdout.seek(0)\n            stdout = \"\".join(map(lambda s: s.decode('utf-8'), tmp_stdout.readlines()))\n            logger.info(\"Spark job stdout:\\n{0}\".format(stdout))\n            if proc.returncode != 0:\n                tmp_stderr.seek(0)\n                stderr = \"\".join(map(lambda s: s.decode('utf-8'), tmp_stderr.readlines()))\n                raise SparkJobError('Spark job failed {0}'.format(repr(args)), out=stdout, err=stderr)\n        finally:\n            tmp_stderr.close()\n            tmp_stdout.close()",
        "begin_line": 234,
        "end_line": 253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask._list_config#255",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask._list_config(self, config)",
        "snippet": "    def _list_config(self, config):\n        if config and isinstance(config, six.string_types):\n            return list(map(lambda x: x.strip(), config.split(',')))",
        "begin_line": 255,
        "end_line": 257,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask._dict_config#259",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask._dict_config(self, config)",
        "snippet": "    def _dict_config(self, config):\n        if config and isinstance(config, six.string_types):\n            return dict(map(lambda i: i.split('='), config.split('|')))",
        "begin_line": 259,
        "end_line": 261,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask._text_arg#263",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask._text_arg(self, name, value)",
        "snippet": "    def _text_arg(self, name, value):\n        if value:\n            return [name, value]\n        return []",
        "begin_line": 263,
        "end_line": 266,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005534034311012728,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask._list_arg#268",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask._list_arg(self, name, value)",
        "snippet": "    def _list_arg(self, name, value):\n        if value and isinstance(value, (list, tuple)):\n            return [name, ','.join(value)]\n        return []",
        "begin_line": 268,
        "end_line": 271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask._dict_arg#273",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask._dict_arg(self, name, value)",
        "snippet": "    def _dict_arg(self, name, value):\n        command = []\n        if value and isinstance(value, dict):\n            for prop, value in value.items():\n                command += [name, '{0}={1}'.format(prop, value)]\n        return command",
        "begin_line": 273,
        "end_line": 278,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkSubmitTask._flag_arg#280",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkSubmitTask",
        "signature": "luigi.contrib.spark.SparkSubmitTask._flag_arg(self, name, value)",
        "snippet": "    def _flag_arg(self, name, value):\n        if value:\n            return [name]\n        return []",
        "begin_line": 280,
        "end_line": 283,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.name#303",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.name(self)",
        "snippet": "    def name(self):\n        return self.__class__.__name__",
        "begin_line": 303,
        "end_line": 304,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.py_packages#307",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.py_packages(self)",
        "snippet": "    def py_packages(self):\n        packages = configuration.get_config().get('spark', 'py-packages', None)\n        if packages:\n            return map(lambda s: s.strip(), packages.split(','))",
        "begin_line": 307,
        "end_line": 310,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.setup#312",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.setup(self, conf)",
        "snippet": "    def setup(self, conf):\n        \"\"\"\n        Called by the pyspark_runner with a SparkConf instance that will be used to instantiate the SparkContext\n\n        :param conf: SparkConf\n        \"\"\"",
        "begin_line": 312,
        "end_line": 317,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.setup_remote#319",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.setup_remote(self, sc)",
        "snippet": "    def setup_remote(self, sc):\n        self._setup_packages(sc)",
        "begin_line": 319,
        "end_line": 320,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.app_command#331",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.app_command(self)",
        "snippet": "    def app_command(self):\n        return [self.app, self.run_pickle] + self.app_options()",
        "begin_line": 331,
        "end_line": 332,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask.run#334",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask.run(self)",
        "snippet": "    def run(self):\n        self.run_path = tempfile.mkdtemp(prefix=self.name)\n        self.run_pickle = os.path.join(self.run_path, '.'.join([self.name.replace(' ', '_'), 'pickle']))\n        with open(self.run_pickle, 'wb') as fd:\n            self._dump(fd)\n        try:\n            super(PySparkTask, self).run()\n        finally:\n            shutil.rmtree(self.run_path)",
        "begin_line": 334,
        "end_line": 342,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask._dump#344",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask._dump(self, fd)",
        "snippet": "    def _dump(self, fd):\n        if self.__module__ == '__main__':\n            d = pickle.dumps(self)\n            module_name = os.path.basename(sys.argv[0]).rsplit('.', 1)[0]\n            d = d.replace(b'(c__main__', \"(c\" + module_name)\n            fd.write(d)\n        else:\n            pickle.dump(self, fd)",
        "begin_line": 344,
        "end_line": 351,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.PySparkTask._setup_packages#353",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySparkTask",
        "signature": "luigi.contrib.spark.PySparkTask._setup_packages(self, sc)",
        "snippet": "    def _setup_packages(self, sc):\n        \"\"\"\n        This method compresses and uploads packages to the cluster\n\n        \"\"\"\n        packages = self.py_packages\n        if not packages:\n            return\n        for package in packages:\n            mod = importlib.import_module(package)\n            try:\n                mod_path = mod.__path__[0]\n            except AttributeError:\n                mod_path = mod.__file__\n            tar_path = os.path.join(self.run_path, package + '.tar.gz')\n            tar = tarfile.open(tar_path, \"w:gz\")\n            tar.add(mod_path, os.path.basename(mod_path))\n            tar.close()\n            sc.addPyFile(tar_path)",
        "begin_line": 353,
        "end_line": 371,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkJob.job_args#412",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkJob",
        "signature": "luigi.contrib.spark.SparkJob.job_args(self)",
        "snippet": "    def job_args(self):\n        return []",
        "begin_line": 412,
        "end_line": 413,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkJob.run#418",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkJob",
        "signature": "luigi.contrib.spark.SparkJob.run(self)",
        "snippet": "    def run(self):\n        warnings.warn(\"The use of SparkJob is deprecated. Please use SparkSubmitTask or PySparkTask.\", stacklevel=2)\n        original_output_path = self.output().path\n        path_no_slash = original_output_path[:-2] if original_output_path.endswith('/*') else original_output_path\n        path_no_slash = original_output_path[:-1] if original_output_path[-1] == '/' else path_no_slash\n        tmp_output = luigi.contrib.hdfs.HdfsTarget(path_no_slash + '-luigi-tmp-%09d' % random.randrange(0, 1e10))\n\n        args = ['org.apache.spark.deploy.yarn.Client']\n        args += ['--jar', self.jar()]\n        args += ['--class', self.job_class()]\n\n        for a in self.job_args():\n            if a == self.output().path:\n                # pass temporary output path to job args\n                logger.info('Using temp path: %s for path %s', tmp_output.path, original_output_path)\n                args += ['--args', tmp_output.path]\n            else:\n                args += ['--args', str(a)]\n\n        if self.spark_workers is not None:\n            args += ['--num-workers', self.spark_workers]\n\n        if self.spark_master_memory is not None:\n            args += ['--master-memory', self.spark_master_memory]\n\n        if self.spark_worker_memory is not None:\n            args += ['--worker-memory', self.spark_worker_memory]\n\n        queue = self.queue\n        if queue is not None:\n            args += ['--queue', queue]\n\n        env = os.environ.copy()\n        env['SPARK_JAR'] = configuration.get_config().get('spark', 'spark-jar')\n        env['HADOOP_CONF_DIR'] = configuration.get_config().get('spark', 'hadoop-conf-dir')\n        env['MASTER'] = 'yarn-client'\n        spark_class = configuration.get_config().get('spark', 'spark-class')\n\n        temp_stderr = tempfile.TemporaryFile()\n        logger.info('Running: %s %s', spark_class, ' '.join(args))\n        proc = subprocess.Popen([spark_class] + args, stdout=subprocess.PIPE,\n                                stderr=temp_stderr, env=env, close_fds=True)\n\n        return_code, final_state, app_id = self.track_progress(proc)\n        if return_code == 0 and final_state != 'FAILED':\n            tmp_output.move(path_no_slash)\n        elif final_state == 'FAILED':\n            raise SparkJobError('Spark job failed: see yarn logs for %s' % app_id)\n        else:\n            temp_stderr.seek(0)\n            errors = \"\".join((x.decode('utf8') for x in temp_stderr.readlines()))\n            logger.error(errors)\n            raise SparkJobError('Spark job failed', err=errors)",
        "begin_line": 418,
        "end_line": 470,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.SparkJob.track_progress#472",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.SparkJob",
        "signature": "luigi.contrib.spark.SparkJob.track_progress(self, proc)",
        "snippet": "    def track_progress(self, proc):\n        # The Spark client currently outputs a multiline status to stdout every second\n        # while the application is running.  This instead captures status data and updates\n        # a single line of output until the application finishes.\n        app_id = None\n        app_status = 'N/A'\n        url = 'N/A'\n        final_state = None\n        start = time.time()\n        with SparkRunContext(proc) as context:\n            while proc.poll() is None:\n                s = proc.stdout.readline().decode('utf8')\n                app_id_s = re.compile('application identifier: (\\w+)').search(s)\n                if app_id_s:\n                    app_id = app_id_s.group(1)\n                    context.app_id = app_id\n                app_status_s = re.compile('yarnAppState: (\\w+)').search(s)\n                if app_status_s:\n                    app_status = app_status_s.group(1)\n                url_s = re.compile('appTrackingUrl: (.+)').search(s)\n                if url_s:\n                    url = url_s.group(1)\n                final_state_s = re.compile('distributedFinalState: (\\w+)').search(s)\n                if final_state_s:\n                    final_state = final_state_s.group(1)\n                if not app_id:\n                    logger.info(s.strip())\n                else:\n                    elapsed_mins, elapsed_secs = divmod(datetime.timedelta(seconds=time.time() - start).seconds, 60)\n                    status = '[%0d:%02d] Status: %s Tracking: %s' % (elapsed_mins, elapsed_secs, app_status, url)\n                    sys.stdout.write(\"\\r\\x1b[K\" + status)\n                    sys.stdout.flush()\n        logger.info(proc.communicate()[0])\n        return proc.returncode, final_state, app_id",
        "begin_line": 472,
        "end_line": 505,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.Spark1xBackwardCompat.master#515",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.Spark1xBackwardCompat",
        "signature": "luigi.contrib.spark.Spark1xBackwardCompat.master(self)",
        "snippet": "    def master(self):\n        return configuration.get_config().get(\"spark\", \"master\", \"yarn-client\")",
        "begin_line": 515,
        "end_line": 516,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.Spark1xBackwardCompat.spark_options#521",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.Spark1xBackwardCompat",
        "signature": "luigi.contrib.spark.Spark1xBackwardCompat.spark_options(self)",
        "snippet": "    def spark_options(self):\n        return []",
        "begin_line": 521,
        "end_line": 522,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.Spark1xBackwardCompat.dependency_jars#524",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.Spark1xBackwardCompat",
        "signature": "luigi.contrib.spark.Spark1xBackwardCompat.dependency_jars(self)",
        "snippet": "    def dependency_jars(self):\n        return []",
        "begin_line": 524,
        "end_line": 525,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.Spark1xBackwardCompat.job_args#527",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.Spark1xBackwardCompat",
        "signature": "luigi.contrib.spark.Spark1xBackwardCompat.job_args(self)",
        "snippet": "    def job_args(self):\n        return []",
        "begin_line": 527,
        "end_line": 528,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.Spark1xBackwardCompat.jars#532",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.Spark1xBackwardCompat",
        "signature": "luigi.contrib.spark.Spark1xBackwardCompat.jars(self)",
        "snippet": "    def jars(self):\n        return self.dependency_jars()",
        "begin_line": 532,
        "end_line": 533,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.Spark1xBackwardCompat.app_options#535",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.Spark1xBackwardCompat",
        "signature": "luigi.contrib.spark.Spark1xBackwardCompat.app_options(self)",
        "snippet": "    def app_options(self):\n        return self.job_args()",
        "begin_line": 535,
        "end_line": 536,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.Spark1xBackwardCompat.spark_command#538",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.Spark1xBackwardCompat",
        "signature": "luigi.contrib.spark.Spark1xBackwardCompat.spark_command(self)",
        "snippet": "    def spark_command(self):\n        return super(Spark1xBackwardCompat, self).spark_command() + self.spark_options()",
        "begin_line": 538,
        "end_line": 539,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.Spark1xJob.run#564",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.Spark1xJob",
        "signature": "luigi.contrib.spark.Spark1xJob.run(self)",
        "snippet": "    def run(self):\n        warnings.warn(\"The use of Spark1xJob is deprecated. Please use SparkSubmitTask or PySparkTask.\", stacklevel=2)\n        return super(Spark1xJob, self).run()",
        "begin_line": 564,
        "end_line": 566,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.PySpark1xJob.app#583",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySpark1xJob",
        "signature": "luigi.contrib.spark.PySpark1xJob.app(self)",
        "snippet": "    def app(self):\n        return self.program()",
        "begin_line": 583,
        "end_line": 584,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.spark.PySpark1xJob.run#586",
        "src_path": "luigi/contrib/spark.py",
        "class_name": "luigi.contrib.spark.PySpark1xJob",
        "signature": "luigi.contrib.spark.PySpark1xJob.run(self)",
        "snippet": "    def run(self):\n        warnings.warn(\"The use of PySpark1xJob is deprecated. Please use SparkSubmitTask or PySparkTask.\", stacklevel=2)\n        return super(PySpark1xJob, self).run()",
        "begin_line": 586,
        "end_line": 588,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.s3.S3Client.__init__#76",
        "src_path": "luigi/s3.py",
        "class_name": "luigi.s3.S3Client",
        "signature": "luigi.s3.S3Client.__init__(self, aws_access_key_id=None, aws_secret_access_key=None, **kwargs)",
        "snippet": "    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,\n                 **kwargs):\n        options = self._get_s3_config()\n        options.update(kwargs)\n        # Removing key args would break backwards compability\n        if not aws_access_key_id:\n            aws_access_key_id = options.get('aws_access_key_id')\n        if not aws_secret_access_key:\n            aws_secret_access_key = options.get('aws_secret_access_key')\n        for key in ['aws_access_key_id', 'aws_secret_access_key']:\n            if key in options:\n                options.pop(key)\n        self.s3 = boto.connect_s3(aws_access_key_id,\n                                  aws_secret_access_key,\n                                  **options)",
        "begin_line": 76,
        "end_line": 90,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 1.0,
            "pseudo_dstar_susp": 0.043478260869565216,
            "pseudo_tarantula_susp": 0.01818181818181818,
            "pseudo_op2_susp": 0.043478260869565216,
            "pseudo_barinel_susp": 0.01818181818181818
        }
    },
    {
        "name": "luigi.s3.S3Client._get_s3_config#336",
        "src_path": "luigi/s3.py",
        "class_name": "luigi.s3.S3Client",
        "signature": "luigi.s3.S3Client._get_s3_config(self, key=None)",
        "snippet": "    def _get_s3_config(self, key=None):\n        try:\n            config = dict(configuration.get_config().items('s3'))\n        except NoSectionError:\n            return {}\n        # So what ports etc can be read without us having to specify all dtypes\n        for k, v in six.iteritems(config):\n            try:\n                config[k] = int(v)\n            except ValueError:\n                pass\n        if key:\n            return config.get(key)\n        return config",
        "begin_line": 336,
        "end_line": 349,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.16666666666666666,
            "pseudo_dstar_susp": 0.03333333333333333,
            "pseudo_tarantula_susp": 0.038461538461538464,
            "pseudo_op2_susp": 0.03333333333333333,
            "pseudo_barinel_susp": 0.038461538461538464
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory._session#63",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory._session(self, session=None)",
        "snippet": "    def _session(self, session=None):\n        if session:\n            yield session\n        else:\n            session = self.session_factory()\n            try:\n                yield session\n            except:\n                session.rollback()\n                raise\n            else:\n                session.commit()",
        "begin_line": 63,
        "end_line": 74,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00641025641025641,
            "pseudo_dstar_susp": 0.004201680672268907,
            "pseudo_tarantula_susp": 0.0072992700729927005,
            "pseudo_op2_susp": 0.004201680672268907,
            "pseudo_barinel_susp": 0.0072992700729927005
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.__init__#76",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.__init__(self)",
        "snippet": "    def __init__(self):\n        config = configuration.get_config()\n        connection_string = config.get('task_history', 'db_connection')\n        self.engine = sqlalchemy.create_engine(connection_string)\n        self.session_factory = sqlalchemy.orm.sessionmaker(bind=self.engine, expire_on_commit=False)\n        Base.metadata.create_all(self.engine)\n        self.tasks = {}  # task_id -> TaskRecord",
        "begin_line": 76,
        "end_line": 82,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005208333333333333,
            "pseudo_dstar_susp": 0.003861003861003861,
            "pseudo_tarantula_susp": 0.005780346820809248,
            "pseudo_op2_susp": 0.003861003861003861,
            "pseudo_barinel_susp": 0.005780346820809248
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.task_finished#88",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.task_finished(self, task_id, successful)",
        "snippet": "    def task_finished(self, task_id, successful):\n        event_name = DONE if successful else FAILED\n        task = self._get_task(task_id, status=event_name)\n        self._add_task_event(task, TaskEvent(event_name=event_name, ts=datetime.datetime.now()))",
        "begin_line": 88,
        "end_line": 91,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005917159763313609,
            "pseudo_dstar_susp": 0.004081632653061225,
            "pseudo_tarantula_susp": 0.006711409395973154,
            "pseudo_op2_susp": 0.004081632653061225,
            "pseudo_barinel_susp": 0.006711409395973154
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory._get_task#97",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory._get_task(self, task_id, status, host=None)",
        "snippet": "    def _get_task(self, task_id, status, host=None):\n        if task_id in self.tasks:\n            task = self.tasks[task_id]\n            task.status = status\n            if host:\n                task.host = host\n        else:\n            task = self.tasks[task_id] = task_history.Task(task_id, status, host)\n        return task",
        "begin_line": 97,
        "end_line": 105,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005208333333333333,
            "pseudo_dstar_susp": 0.003861003861003861,
            "pseudo_tarantula_susp": 0.005780346820809248,
            "pseudo_op2_susp": 0.003861003861003861,
            "pseudo_barinel_susp": 0.005780346820809248
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory._find_or_create_task#111",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory._find_or_create_task(self, task)",
        "snippet": "    def _find_or_create_task(self, task):\n        with self._session() as session:\n            if task.record_id is not None:\n                logger.debug(\"Finding task with record_id [%d]\", task.record_id)\n                task_record = session.query(TaskRecord).get(task.record_id)\n                if not task_record:\n                    raise Exception(\"Task with record_id, but no matching Task record!\")\n                yield (task_record, session)\n            else:\n                task_record = TaskRecord(name=task.task_family, host=task.host)\n                for (k, v) in six.iteritems(task.parameters):\n                    task_record.parameters[k] = TaskParameter(name=k, value=v)\n                session.add(task_record)\n                yield (task_record, session)\n            if task.host:\n                task_record.host = task.host\n        task.record_id = task_record.id",
        "begin_line": 111,
        "end_line": 127,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.007751937984496124,
            "pseudo_dstar_susp": 0.004424778761061947,
            "pseudo_tarantula_susp": 0.009523809523809525,
            "pseudo_op2_susp": 0.004424778761061947,
            "pseudo_barinel_susp": 0.009523809523809525
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.find_all_by_parameters#129",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.find_all_by_parameters(self, task_name, session=None, **task_params)",
        "snippet": "    def find_all_by_parameters(self, task_name, session=None, **task_params):\n        \"\"\"\n        Find tasks with the given task_name and the same parameters as the kwargs.\n        \"\"\"\n        with self._session(session) as session:\n            tasks = session.query(TaskRecord).join(TaskEvent).filter(TaskRecord.name == task_name).order_by(TaskEvent.ts).all()\n            for task in tasks:\n                if all(k in task.parameters and v == str(task.parameters[k].value) for (k, v) in six.iteritems(task_params)):\n                    yield task",
        "begin_line": 129,
        "end_line": 137,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009259259259259259,
            "pseudo_dstar_susp": 0.007751937984496124,
            "pseudo_tarantula_susp": 0.009259259259259259,
            "pseudo_op2_susp": 0.007751937984496124,
            "pseudo_barinel_susp": 0.009259259259259259
        }
    },
    {
        "name": "luigi.db_task_history.DbTaskHistory.find_all_by_name#139",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.DbTaskHistory",
        "signature": "luigi.db_task_history.DbTaskHistory.find_all_by_name(self, task_name, session=None)",
        "snippet": "    def find_all_by_name(self, task_name, session=None):\n        \"\"\"\n        Find all tasks with the given task_name.\n        \"\"\"\n        return self.find_all_by_parameters(task_name, session)",
        "begin_line": 139,
        "end_line": 143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008620689655172414,
            "pseudo_dstar_susp": 0.0044444444444444444,
            "pseudo_tarantula_susp": 0.01020408163265306,
            "pseudo_op2_susp": 0.0044444444444444444,
            "pseudo_barinel_susp": 0.01020408163265306
        }
    },
    {
        "name": "luigi.db_task_history.TaskEvent.__repr__#203",
        "src_path": "luigi/db_task_history.py",
        "class_name": "luigi.db_task_history.TaskEvent",
        "signature": "luigi.db_task_history.TaskEvent.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return \"TaskEvent(task_id=%s, event_name=%s, ts=%s\" % (self.task_id, self.event_name, self.ts)",
        "begin_line": 203,
        "end_line": 204,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.rpc.RPCError.__init__#40",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RPCError",
        "signature": "luigi.rpc.RPCError.__init__(self, message, sub_exception=None)",
        "snippet": "    def __init__(self, message, sub_exception=None):\n        super(RPCError, self).__init__(message)\n        self.sub_exception = sub_exception",
        "begin_line": 40,
        "end_line": 42,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.__init__#50",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.__init__(self, host='localhost', port=8082, connect_timeout=None, url_prefix='')",
        "snippet": "    def __init__(self, host='localhost', port=8082, connect_timeout=None, url_prefix=''):\n        self._host = host\n        self._port = port\n        self._url_prefix = url_prefix\n\n        config = configuration.get_config()\n\n        if connect_timeout is None:\n            connect_timeout = config.getfloat('core', 'rpc-connect-timeout', 10.0)\n        self._connect_timeout = connect_timeout",
        "begin_line": 50,
        "end_line": 59,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004051863857374392,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler._fetch#64",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler._fetch(self, url, body, log_exceptions=True, attempts=3)",
        "snippet": "    def _fetch(self, url, body, log_exceptions=True, attempts=3):\n\n        full_url = 'http://{host}:{port:d}{prefix}{url}'.format(\n            host=self._host,\n            port=self._port,\n            prefix=self._url_prefix,\n            url=url)\n        last_exception = None\n        attempt = 0\n        while attempt < attempts:\n            attempt += 1\n            if last_exception:\n                logger.info(\"Retrying...\")\n                self._wait()  # wait for a bit and retry\n            try:\n                response = urlopen(full_url, body, self._connect_timeout)\n                break\n            except (URLError, socket.timeout) as e:\n                last_exception = e\n                if log_exceptions:\n                    logger.exception(\"Failed connecting to remote scheduler %r\", self._host)\n                continue\n        else:\n            raise RPCError(\n                \"Errors (%d attempts) when connecting to remote scheduler %r\" %\n                (attempts, self._host),\n                last_exception\n            )\n        return response.read().decode('utf-8')",
        "begin_line": 64,
        "end_line": 92,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler._request#94",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler._request(self, url, data, log_exceptions=True, attempts=3)",
        "snippet": "    def _request(self, url, data, log_exceptions=True, attempts=3):\n        data = {'data': json.dumps(data)}\n        body = urlencode(data).encode('utf-8')\n\n        page = self._fetch(url, body, log_exceptions, attempts)\n        result = json.loads(page)\n        return result[\"response\"]",
        "begin_line": 94,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005091649694501018,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.ping#102",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.ping(self, worker)",
        "snippet": "    def ping(self, worker):\n        # just one attemtps, keep-alive thread will keep trying anyway\n        self._request('/api/ping', {'worker': worker}, attempts=1)",
        "begin_line": 102,
        "end_line": 104,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005186721991701245,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.add_task#106",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.add_task(self, worker, task_id, status=PENDING, runnable=True, deps=None, new_deps=None, expl=None, resources=None, priority=0, family='', module=None, params=None, assistant=False)",
        "snippet": "    def add_task(self, worker, task_id, status=PENDING, runnable=True,\n                 deps=None, new_deps=None, expl=None, resources=None, priority=0,\n                 family='', module=None, params=None, assistant=False):\n        self._request('/api/add_task', {\n            'task_id': task_id,\n            'worker': worker,\n            'status': status,\n            'runnable': runnable,\n            'deps': deps,\n            'new_deps': new_deps,\n            'expl': expl,\n            'resources': resources,\n            'priority': priority,\n            'family': family,\n            'module': module,\n            'params': params,\n            'assistant': assistant,\n        })",
        "begin_line": 106,
        "end_line": 123,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.get_work#125",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.get_work(self, worker, host=None, assistant=False)",
        "snippet": "    def get_work(self, worker, host=None, assistant=False):\n        return self._request(\n            '/api/get_work',\n            {'worker': worker, 'host': host, 'assistant': assistant},\n            log_exceptions=False,\n            attempts=1)",
        "begin_line": 125,
        "end_line": 130,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.task_list#141",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.task_list(self, status, upstream_status, search=None)",
        "snippet": "    def task_list(self, status, upstream_status, search=None):\n        return self._request('/api/task_list', {\n            'search': search,\n            'status': status,\n            'upstream_status': upstream_status,\n        })",
        "begin_line": 141,
        "end_line": 146,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00046882325363338024,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.add_worker#157",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.add_worker(self, worker, info)",
        "snippet": "    def add_worker(self, worker, info):\n        return self._request('/api/add_worker', {'worker': worker, 'info': info})",
        "begin_line": 157,
        "end_line": 158,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005659309564233164,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.rpc.RemoteScheduler.update_resources#160",
        "src_path": "luigi/rpc.py",
        "class_name": "luigi.rpc.RemoteScheduler",
        "signature": "luigi.rpc.RemoteScheduler.update_resources(self, **resources)",
        "snippet": "    def update_resources(self, **resources):\n        return self._request('/api/update_resources', resources)",
        "begin_line": 160,
        "end_line": 161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004411116012351125,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task_history.Task.__init__#37",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.Task",
        "signature": "luigi.task_history.Task.__init__(self, task_id, status, host=None)",
        "snippet": "    def __init__(self, task_id, status, host=None):\n        self.task_family, self.parameters = task.id_to_name_and_params(task_id)\n        self.status = status\n        self.record_id = None\n        self.host = host",
        "begin_line": 37,
        "end_line": 41,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.017241379310344827,
            "pseudo_dstar_susp": 0.008,
            "pseudo_tarantula_susp": 0.009708737864077669,
            "pseudo_op2_susp": 0.008,
            "pseudo_barinel_susp": 0.009708737864077669
        }
    },
    {
        "name": "luigi.task_history.NopHistory.task_scheduled#67",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.NopHistory",
        "signature": "luigi.task_history.NopHistory.task_scheduled(self, task_id)",
        "snippet": "    def task_scheduled(self, task_id):\n        pass",
        "begin_line": 67,
        "end_line": 68,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0003757985719654265,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task_history.NopHistory.task_finished#70",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.NopHistory",
        "signature": "luigi.task_history.NopHistory.task_finished(self, task_id, successful)",
        "snippet": "    def task_finished(self, task_id, successful):\n        pass",
        "begin_line": 70,
        "end_line": 71,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019723865877712033,
            "pseudo_dstar_susp": 0.0026109660574412533,
            "pseudo_tarantula_susp": 0.0019083969465648854,
            "pseudo_op2_susp": 0.0026109660574412533,
            "pseudo_barinel_susp": 0.0019083969465648854
        }
    },
    {
        "name": "luigi.task_history.NopHistory.task_started#73",
        "src_path": "luigi/task_history.py",
        "class_name": "luigi.task_history.NopHistory",
        "signature": "luigi.task_history.NopHistory.task_started(self, task_id, worker_host)",
        "snippet": "    def task_started(self, task_id, worker_host):\n        pass",
        "begin_line": 73,
        "end_line": 74,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0003755163349605708,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.lock.getpcmd#30",
        "src_path": "luigi/lock.py",
        "class_name": "luigi.lock",
        "signature": "luigi.lock.getpcmd(pid)",
        "snippet": "def getpcmd(pid):\n    \"\"\"\n    Returns command of process.\n\n    :param pid:\n    \"\"\"\n    cmd = 'ps -p %s -o command=' % (pid,)\n    with os.popen(cmd, 'r') as p:\n        return p.readline().strip()",
        "begin_line": 30,
        "end_line": 38,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006031363088057901,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.lock.get_info#41",
        "src_path": "luigi/lock.py",
        "class_name": "luigi.lock",
        "signature": "luigi.lock.get_info(pid_dir, my_pid=None)",
        "snippet": "def get_info(pid_dir, my_pid=None):\n    # Check the name and pid of this process\n    if my_pid is None:\n        my_pid = os.getpid()\n\n    my_cmd = getpcmd(my_pid)\n\n    if six.PY3:\n        cmd_hash = my_cmd.encode('utf8')\n    else:\n        cmd_hash = my_cmd\n\n    pid_file = os.path.join(pid_dir, hashlib.md5(cmd_hash).hexdigest()) + '.pid'\n\n    return my_pid, my_cmd, pid_file",
        "begin_line": 41,
        "end_line": 55,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000630119722747322,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.lock.acquire_for#58",
        "src_path": "luigi/lock.py",
        "class_name": "luigi.lock",
        "signature": "luigi.lock.acquire_for(pid_dir, num_available=1)",
        "snippet": "def acquire_for(pid_dir, num_available=1):\n    \"\"\"\n    Makes sure the process is only run once at the same time with the same name.\n\n    Notice that we since we check the process name, different parameters to the same\n    command can spawn multiple processes at the same time, i.e. running\n    \"/usr/bin/my_process\" does not prevent anyone from launching\n    \"/usr/bin/my_process --foo bar\".\n    \"\"\"\n\n    my_pid, my_cmd, pid_file = get_info(pid_dir)\n\n    # Check if there is a pid file corresponding to this name\n    if not os.path.exists(pid_dir):\n        os.mkdir(pid_dir)\n        os.chmod(pid_dir, 0o777)\n\n    pids = set()\n    pid_cmds = {}\n    if os.path.exists(pid_file):\n        # There is such a file - read the pid and look up its process name\n        pids.update(filter(None, map(str.strip, open(pid_file))))\n        pid_cmds = dict((pid, getpcmd(pid)) for pid in pids)\n        matching_pids = list(filter(lambda pid: pid_cmds[pid] == my_cmd, pids))\n\n        if len(matching_pids) >= num_available:\n            # We are already running under a different pid\n            print('Pid(s)', ', '.join(matching_pids), 'already running')\n            return False\n        else:\n            # The pid belongs to something else, we could\n            pass\n    pid_cmds[str(my_pid)] = my_cmd\n\n    # Write pids\n    pids.add(str(my_pid))\n    with open(pid_file, 'w') as f:\n        f.writelines('%s\\n' % (pid, ) for pid in filter(pid_cmds.__getitem__, pids))\n\n    # Make the file writable by all\n    if os.name == 'nt':\n        pass\n    else:\n        s = os.stat(pid_file)\n        if os.getuid() == s.st_uid:\n            os.chmod(pid_file, s.st_mode | 0o777)\n\n    return True",
        "begin_line": 58,
        "end_line": 105,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.worker.TaskProcess.__init__#75",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskProcess",
        "signature": "luigi.worker.TaskProcess.__init__(self, task, worker_id, result_queue, random_seed=False, worker_timeout=0)",
        "snippet": "    def __init__(self, task, worker_id, result_queue, random_seed=False, worker_timeout=0):\n        super(TaskProcess, self).__init__()\n        self.task = task\n        self.worker_id = worker_id\n        self.result_queue = result_queue\n        self.random_seed = random_seed\n        if task.worker_timeout is not None:\n            worker_timeout = task.worker_timeout\n        self.timeout_time = time.time() + worker_timeout if worker_timeout else None",
        "begin_line": 75,
        "end_line": 83,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004775549188156638,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.worker.TaskProcess._run_get_new_deps#85",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskProcess",
        "signature": "luigi.worker.TaskProcess._run_get_new_deps(self)",
        "snippet": "    def _run_get_new_deps(self):\n        task_gen = self.task.run()\n        if not isinstance(task_gen, types.GeneratorType):\n            return None\n\n        next_send = None\n        while True:\n            try:\n                if next_send is None:\n                    requires = six.next(task_gen)\n                else:\n                    requires = task_gen.send(next_send)\n            except StopIteration:\n                return None\n\n            new_req = flatten(requires)\n            new_deps = [(t.task_module, t.task_family, t.to_str_params())\n                        for t in new_req]\n            if all(t.complete() for t in new_req):\n                next_send = getpaths(requires)\n            else:\n                return new_deps",
        "begin_line": 85,
        "end_line": 106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00048216007714561236,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.worker.TaskProcess.run#108",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.TaskProcess",
        "signature": "luigi.worker.TaskProcess.run(self)",
        "snippet": "    def run(self):\n        logger.info('[pid %s] Worker %s running   %s', os.getpid(), self.worker_id, self.task.task_id)\n\n        if self.random_seed:\n            # Need to have different random seeds if running in separate processes\n            random.seed((os.getpid(), time.time()))\n\n        status = FAILED\n        error_message = ''\n        missing = []\n        new_deps = []\n        try:\n            # Verify that all the tasks are fulfilled!\n            missing = [dep.task_id for dep in self.task.deps() if not dep.complete()]\n            if missing:\n                deps = 'dependency' if len(missing) == 1 else 'dependencies'\n                raise RuntimeError('Unfulfilled %s at run time: %s' % (deps, ', '.join(missing)))\n            self.task.trigger_event(Event.START, self.task)\n            t0 = time.time()\n            status = None\n\n            if self.task.run == NotImplemented:\n                # External task\n                # TODO(erikbern): We should check for task completeness after non-external tasks too!\n                # This will resolve #814 and make things a lot more consistent\n                status = DONE if self.task.complete() else FAILED\n            else:\n                new_deps = self._run_get_new_deps()\n                status = DONE if not new_deps else SUSPENDED\n\n            if status == SUSPENDED:\n                logger.info(\n                    '[pid %s] Worker %s new requirements      %s',\n                    os.getpid(), self.worker_id, self.task.task_id)\n\n            elif status == DONE:\n                self.task.trigger_event(\n                    Event.PROCESSING_TIME, self.task, time.time() - t0)\n                error_message = json.dumps(self.task.on_success())\n                logger.info('[pid %s] Worker %s done      %s', os.getpid(),\n                            self.worker_id, self.task.task_id)\n                self.task.trigger_event(Event.SUCCESS, self.task)\n\n        except KeyboardInterrupt:\n            raise\n        except BaseException as ex:\n            status = FAILED\n            logger.exception(\"[pid %s] Worker %s failed    %s\", os.getpid(), self.worker_id, self.task)\n            error_message = notifications.wrap_traceback(self.task.on_failure(ex))\n            self.task.trigger_event(Event.FAILURE, self.task, ex)\n            subject = \"Luigi: %s FAILED\" % self.task\n            notifications.send_error_email(subject, error_message)\n        finally:\n            self.result_queue.put(\n                (self.task.task_id, status, error_message, missing, new_deps))",
        "begin_line": 108,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.worker.SingleProcessPool.apply_async#172",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.SingleProcessPool",
        "signature": "luigi.worker.SingleProcessPool.apply_async(self, function, args)",
        "snippet": "    def apply_async(self, function, args):\n        return function(*args)",
        "begin_line": 172,
        "end_line": 173,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.worker.SingleProcessPool.close#175",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.SingleProcessPool",
        "signature": "luigi.worker.SingleProcessPool.close(self)",
        "snippet": "    def close(self):\n        pass",
        "begin_line": 175,
        "end_line": 176,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.worker.SingleProcessPool.join#178",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.SingleProcessPool",
        "signature": "luigi.worker.SingleProcessPool.join(self)",
        "snippet": "    def join(self):\n        pass",
        "begin_line": 178,
        "end_line": 179,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.worker.AsyncCompletionException.__init__#196",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.AsyncCompletionException",
        "signature": "luigi.worker.AsyncCompletionException.__init__(self, trace)",
        "snippet": "    def __init__(self, trace):\n        self.trace = trace",
        "begin_line": 196,
        "end_line": 197,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.worker.check_complete#209",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker",
        "signature": "luigi.worker.check_complete(task, out_queue)",
        "snippet": "def check_complete(task, out_queue):\n    \"\"\"\n    Checks if task is complete, puts the result to out_queue.\n    \"\"\"\n    logger.debug(\"Checking if %s is complete\", task)\n    try:\n        is_complete = task.complete()\n    except BaseException:\n        is_complete = TracebackWrapper(traceback.format_exc())\n    out_queue.put((task, is_complete))",
        "begin_line": 209,
        "end_line": 218,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017482517482517483,
            "pseudo_dstar_susp": 0.0017482517482517483,
            "pseudo_tarantula_susp": 0.0017953321364452424,
            "pseudo_op2_susp": 0.0017482517482517483,
            "pseudo_barinel_susp": 0.0017953321364452424
        }
    },
    {
        "name": "luigi.worker.KeepAliveThread.__init__#251",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.KeepAliveThread",
        "signature": "luigi.worker.KeepAliveThread.__init__(self, scheduler, worker_id, ping_interval)",
        "snippet": "    def __init__(self, scheduler, worker_id, ping_interval):\n        super(KeepAliveThread, self).__init__()\n        self._should_stop = threading.Event()\n        self._scheduler = scheduler\n        self._worker_id = worker_id\n        self._ping_interval = ping_interval",
        "begin_line": 251,
        "end_line": 256,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0028169014084507044,
            "pseudo_dstar_susp": 0.0049261083743842365,
            "pseudo_tarantula_susp": 0.002976190476190476,
            "pseudo_op2_susp": 0.0049261083743842365,
            "pseudo_barinel_susp": 0.002976190476190476
        }
    },
    {
        "name": "luigi.worker.KeepAliveThread.stop#258",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.KeepAliveThread",
        "signature": "luigi.worker.KeepAliveThread.stop(self)",
        "snippet": "    def stop(self):\n        self._should_stop.set()",
        "begin_line": 258,
        "end_line": 259,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0023584905660377358,
            "pseudo_dstar_susp": 0.002028397565922921,
            "pseudo_tarantula_susp": 0.0037313432835820895,
            "pseudo_op2_susp": 0.002028397565922921,
            "pseudo_barinel_susp": 0.0037313432835820895
        }
    },
    {
        "name": "luigi.worker.KeepAliveThread.run#261",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.KeepAliveThread",
        "signature": "luigi.worker.KeepAliveThread.run(self)",
        "snippet": "    def run(self):\n        while True:\n            self._should_stop.wait(self._ping_interval)\n            if self._should_stop.is_set():\n                logger.info(\"Worker %s was stopped. Shutting down Keep-Alive thread\" % self._worker_id)\n                break\n            with fork_lock:\n                try:\n                    self._scheduler.ping(worker=self._worker_id)\n                except:  # httplib.BadStatusLine:\n                    logger.warning('Failed pinging scheduler')",
        "begin_line": 261,
        "end_line": 271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.05263157894736842,
            "pseudo_dstar_susp": 0.09090909090909091,
            "pseudo_tarantula_susp": 0.013333333333333334,
            "pseudo_op2_susp": 0.07142857142857142,
            "pseudo_barinel_susp": 0.013333333333333334
        }
    },
    {
        "name": "luigi.worker.Worker.__init__#284",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.__init__(self, scheduler=None, worker_id=None, worker_processes=1, assistant=False, **kwargs)",
        "snippet": "    def __init__(self, scheduler=None, worker_id=None, worker_processes=1, assistant=False, **kwargs):\n        if scheduler is None:\n            scheduler = CentralPlannerScheduler()\n\n        self.worker_processes = int(worker_processes)\n        self._worker_info = self._generate_worker_info()\n\n        if not worker_id:\n            worker_id = 'Worker(%s)' % ', '.join(['%s=%s' % (k, v) for k, v in self._worker_info])\n\n        self._config = worker(**kwargs)\n\n        self._id = worker_id\n        self._scheduler = scheduler\n        self._assistant = assistant\n\n        self.host = socket.gethostname()\n        self._scheduled_tasks = {}\n        self._suspended_tasks = {}\n\n        self._first_task = None\n\n        self.add_succeeded = True\n        self.run_succeeded = True\n        self.unfulfilled_counts = collections.defaultdict(int)\n\n        self._keep_alive_thread = KeepAliveThread(self._scheduler, self._id, self._config.ping_interval)\n        self._keep_alive_thread.daemon = True\n        self._keep_alive_thread.start()\n\n        # Keep info about what tasks are running (could be in other processes)\n        self._task_result_queue = multiprocessing.Queue()\n        self._running_tasks = {}",
        "begin_line": 284,
        "end_line": 316,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.021739130434782608,
            "pseudo_dstar_susp": 0.005,
            "pseudo_tarantula_susp": 0.014925373134328358,
            "pseudo_op2_susp": 0.005,
            "pseudo_barinel_susp": 0.014925373134328358
        }
    },
    {
        "name": "luigi.worker.Worker.stop#318",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.stop(self)",
        "snippet": "    def stop(self):\n        \"\"\"\n        Stop the KeepAliveThread associated with this Worker.\n\n        This should be called whenever you are done with a worker instance to clean up.\n\n        Warning: this should _only_ be performed if you are sure this worker\n        is not performing any work or will perform any work after this has been called\n\n        TODO: also kill all currently running tasks\n\n        TODO (maybe): Worker should be/have a context manager to enforce calling this\n            whenever you stop using a Worker instance\n        \"\"\"\n        self._keep_alive_thread.stop()\n        self._keep_alive_thread.join()",
        "begin_line": 318,
        "end_line": 333,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0023584905660377358,
            "pseudo_dstar_susp": 0.002028397565922921,
            "pseudo_tarantula_susp": 0.0037313432835820895,
            "pseudo_op2_susp": 0.002028397565922921,
            "pseudo_barinel_susp": 0.0037313432835820895
        }
    },
    {
        "name": "luigi.worker.Worker._generate_worker_info#335",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._generate_worker_info(self)",
        "snippet": "    def _generate_worker_info(self):\n        # Generate as much info as possible about the worker\n        # Some of these calls might not be available on all OS's\n        args = [('salt', '%09d' % random.randrange(0, 999999999)),\n                ('workers', self.worker_processes)]\n        try:\n            args += [('host', socket.gethostname())]\n        except BaseException:\n            pass\n        try:\n            args += [('username', getpass.getuser())]\n        except BaseException:\n            pass\n        try:\n            args += [('pid', os.getpid())]\n        except BaseException:\n            pass\n        try:\n            sudo_user = os.getenv(\"SUDO_USER\")\n            if sudo_user:\n                args.append(('sudo_user', sudo_user))\n        except BaseException:\n            pass\n        return args",
        "begin_line": 335,
        "end_line": 358,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008130081300813009,
            "pseudo_dstar_susp": 0.005681818181818182,
            "pseudo_tarantula_susp": 0.008547008547008548,
            "pseudo_op2_susp": 0.005681818181818182,
            "pseudo_barinel_susp": 0.008547008547008548
        }
    },
    {
        "name": "luigi.worker.Worker._validate_task#360",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._validate_task(self, task)",
        "snippet": "    def _validate_task(self, task):\n        if not isinstance(task, Task):\n            raise TaskException('Can not schedule non-task %s' % task)\n\n        if not task.initialized():\n            # we can't get the repr of it since it's not initialized...\n            raise TaskException('Task of class %s not initialized. Did you override __init__ and forget to call super(...).__init__?' % task.__class__.__name__)",
        "begin_line": 360,
        "end_line": 366,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.worker.Worker._log_complete_error#368",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._log_complete_error(self, task, tb)",
        "snippet": "    def _log_complete_error(self, task, tb):\n        log_msg = \"Will not schedule {task} or any dependencies due to error in complete() method:\\n{tb}\".format(task=task, tb=tb)\n        logger.warning(log_msg)",
        "begin_line": 368,
        "end_line": 370,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.worker.Worker._log_unexpected_error#372",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._log_unexpected_error(self, task)",
        "snippet": "    def _log_unexpected_error(self, task):\n        logger.exception(\"Luigi unexpected framework error while scheduling %s\", task)  # needs to be called from within except clause",
        "begin_line": 372,
        "end_line": 373,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000630119722747322,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.worker.Worker._email_complete_error#375",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._email_complete_error(self, task, formatted_traceback)",
        "snippet": "    def _email_complete_error(self, task, formatted_traceback):\n        # like logger.exception but with WARNING level\n        formatted_traceback = notifications.wrap_traceback(formatted_traceback)\n        subject = \"Luigi: {task} failed scheduling. Host: {host}\".format(task=task, host=self.host)\n        message = \"Will not schedule {task} or any dependencies due to error in complete() method:\\n{traceback}\".format(task=task, traceback=formatted_traceback)\n        notifications.send_error_email(subject, message)",
        "begin_line": 375,
        "end_line": 380,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.worker.Worker._email_unexpected_error#382",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._email_unexpected_error(self, task, formatted_traceback)",
        "snippet": "    def _email_unexpected_error(self, task, formatted_traceback):\n        formatted_traceback = notifications.wrap_traceback(formatted_traceback)\n        subject = \"Luigi: Framework error while scheduling {task}. Host: {host}\".format(task=task, host=self.host)\n        message = \"Luigi framework error:\\n{traceback}\".format(traceback=formatted_traceback)\n        notifications.send_error_email(subject, message)",
        "begin_line": 382,
        "end_line": 386,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.worker.Worker.add#388",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.add(self, task, multiprocess=False)",
        "snippet": "    def add(self, task, multiprocess=False):\n        \"\"\"\n        Add a Task for the worker to check and possibly schedule and run.\n\n        Returns True if task and its dependencies were successfully scheduled or completed before.\n        \"\"\"\n        if self._first_task is None and hasattr(task, 'task_id'):\n            self._first_task = task.task_id\n        self.add_succeeded = True\n        if multiprocess:\n            queue = multiprocessing.Manager().Queue()\n            pool = multiprocessing.Pool()\n        else:\n            queue = DequeQueue()\n            pool = SingleProcessPool()\n        self._validate_task(task)\n        pool.apply_async(check_complete, [task, queue])\n\n        # we track queue size ourselves because len(queue) won't work for multiprocessing\n        queue_size = 1\n        try:\n            seen = set([task.task_id])\n            while queue_size:\n                current = queue.get()\n                queue_size -= 1\n                item, is_complete = current\n                for next in self._add(item, is_complete):\n                    if next.task_id not in seen:\n                        self._validate_task(next)\n                        seen.add(next.task_id)\n                        pool.apply_async(check_complete, [next, queue])\n                        queue_size += 1\n        except (KeyboardInterrupt, TaskException):\n            raise\n        except Exception as ex:\n            self.add_succeeded = False\n            formatted_traceback = traceback.format_exc()\n            self._log_unexpected_error(task)\n            task.trigger_event(Event.BROKEN_TASK, task, ex)\n            self._email_unexpected_error(task, formatted_traceback)\n        finally:\n            pool.close()\n            pool.join()\n        return self.add_succeeded",
        "begin_line": 388,
        "end_line": 431,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002257336343115124,
            "pseudo_dstar_susp": 0.001968503937007874,
            "pseudo_tarantula_susp": 0.003424657534246575,
            "pseudo_op2_susp": 0.001968503937007874,
            "pseudo_barinel_susp": 0.003424657534246575
        }
    },
    {
        "name": "luigi.worker.Worker._add#433",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._add(self, task, is_complete)",
        "snippet": "    def _add(self, task, is_complete):\n        if self._config.task_limit is not None and len(self._scheduled_tasks) >= self._config.task_limit:\n            logger.warning('Will not schedule %s or any dependencies due to exceeded task-limit of %d', task, self._config.task_limit)\n            return\n\n        formatted_traceback = None\n        try:\n            self._check_complete_value(is_complete)\n        except KeyboardInterrupt:\n            raise\n        except AsyncCompletionException as ex:\n            formatted_traceback = ex.trace\n        except BaseException:\n            formatted_traceback = traceback.format_exc()\n\n        if formatted_traceback is not None:\n            self.add_succeeded = False\n            self._log_complete_error(task, formatted_traceback)\n            task.trigger_event(Event.DEPENDENCY_MISSING, task)\n            self._email_complete_error(task, formatted_traceback)\n            # abort, i.e. don't schedule any subtasks of a task with\n            # failing complete()-method since we don't know if the task\n            # is complete and subtasks might not be desirable to run if\n            # they have already ran before\n            return\n\n        if is_complete:\n            deps = None\n            status = DONE\n            runnable = False\n\n            task.trigger_event(Event.DEPENDENCY_PRESENT, task)\n        elif task.run == NotImplemented:\n            deps = None\n            status = PENDING\n            runnable = worker().retry_external_tasks\n\n            task.trigger_event(Event.DEPENDENCY_MISSING, task)\n            logger.warning('Data for %s does not exist (yet?). The task is an external data depedency, so it can not be run from this luigi process.', task.task_id)\n\n        else:\n            deps = task.deps()\n            status = PENDING\n            runnable = True\n\n        if task.disabled:\n            status = DISABLED\n\n        if deps:\n            for d in deps:\n                self._validate_dependency(d)\n                task.trigger_event(Event.DEPENDENCY_DISCOVERED, task, d)\n                yield d  # return additional tasks to add\n\n            deps = [d.task_id for d in deps]\n\n        self._scheduled_tasks[task.task_id] = task\n        self._scheduler.add_task(worker=self._id, task_id=task.task_id, status=status,\n                                 deps=deps, runnable=runnable, priority=task.priority,\n                                 resources=task.process_resources(),\n                                 params=task.to_str_params(),\n                                 family=task.task_family,\n                                 module=task.task_module)\n\n        logger.info('Scheduled %s (%s)', task.task_id, status)",
        "begin_line": 433,
        "end_line": 497,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022988505747126436,
            "pseudo_dstar_susp": 0.0019880715705765406,
            "pseudo_tarantula_susp": 0.0035460992907801418,
            "pseudo_op2_susp": 0.0019880715705765406,
            "pseudo_barinel_susp": 0.0035460992907801418
        }
    },
    {
        "name": "luigi.worker.Worker._validate_dependency#499",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._validate_dependency(self, dependency)",
        "snippet": "    def _validate_dependency(self, dependency):\n        if isinstance(dependency, Target):\n            raise Exception('requires() can not return Target objects. Wrap it in an ExternalTask class')\n        elif not isinstance(dependency, Task):\n            raise Exception('requires() must return Task objects')",
        "begin_line": 499,
        "end_line": 503,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004725897920604915,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.worker.Worker._check_complete_value#505",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._check_complete_value(self, is_complete)",
        "snippet": "    def _check_complete_value(self, is_complete):\n        if is_complete not in (True, False):\n            if isinstance(is_complete, TracebackWrapper):\n                raise AsyncCompletionException(is_complete.trace)\n            raise Exception(\"Return value of Task.complete() must be boolean (was %r)\" % is_complete)",
        "begin_line": 505,
        "end_line": 509,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002336448598130841,
            "pseudo_dstar_susp": 0.002012072434607646,
            "pseudo_tarantula_susp": 0.003676470588235294,
            "pseudo_op2_susp": 0.002012072434607646,
            "pseudo_barinel_susp": 0.003676470588235294
        }
    },
    {
        "name": "luigi.worker.Worker._add_worker#511",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._add_worker(self)",
        "snippet": "    def _add_worker(self):\n        self._worker_info.append(('first_task', self._first_task))\n        self._scheduler.add_worker(self._id, self._worker_info)",
        "begin_line": 511,
        "end_line": 513,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002008032128514056,
            "pseudo_dstar_susp": 0.0018832391713747645,
            "pseudo_tarantula_susp": 0.002242152466367713,
            "pseudo_op2_susp": 0.0018832391713747645,
            "pseudo_barinel_susp": 0.002242152466367713
        }
    },
    {
        "name": "luigi.worker.Worker._log_remote_tasks#515",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._log_remote_tasks(self, running_tasks, n_pending_tasks, n_unique_pending)",
        "snippet": "    def _log_remote_tasks(self, running_tasks, n_pending_tasks, n_unique_pending):\n        logger.info(\"Done\")\n        logger.info(\"There are no more tasks to run at this time\")\n        if running_tasks:\n            for r in running_tasks:\n                logger.info('%s is currently run by worker %s', r['task_id'], r['worker'])\n        elif n_pending_tasks:\n            logger.info(\"There are %s pending tasks possibly being run by other workers\", n_pending_tasks)\n            if n_unique_pending:\n                logger.info(\"There are %i pending tasks unique to this worker\", n_unique_pending)",
        "begin_line": 515,
        "end_line": 524,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001736111111111111,
            "pseudo_dstar_susp": 0.001736111111111111,
            "pseudo_tarantula_susp": 0.0017761989342806395,
            "pseudo_op2_susp": 0.001736111111111111,
            "pseudo_barinel_susp": 0.0017761989342806395
        }
    },
    {
        "name": "luigi.worker.Worker._get_work#526",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._get_work(self)",
        "snippet": "    def _get_work(self):\n        logger.debug(\"Asking scheduler for work...\")\n        r = self._scheduler.get_work(worker=self._id, host=self.host, assistant=self._assistant)\n        n_pending_tasks = r['n_pending_tasks']\n        task_id = r['task_id']\n        running_tasks = r['running_tasks']\n        n_unique_pending = r['n_unique_pending']\n\n        if task_id is not None and task_id not in self._scheduled_tasks:\n            logger.info('Did not schedule %s, will load it dynamically', task_id)\n\n            try:\n                # TODO: we should obtain the module name from the server!\n                self._scheduled_tasks[task_id] = \\\n                    load_task(module=r.get('task_module'),\n                              task_name=r['task_family'],\n                              params_str=r['task_params'])\n            except TaskClassException as ex:\n                msg = 'Cannot find task for %s' % task_id\n                logger.exception(msg)\n                subject = 'Luigi: %s' % msg\n                error_message = notifications.wrap_traceback(ex)\n                notifications.send_error_email(subject, error_message)\n                self._scheduler.add_task(worker=self._id, task_id=task_id, status=FAILED, runnable=False,\n                                         assistant=self._assistant)\n                task_id = None\n                self.run_succeeded = False\n\n        return task_id, running_tasks, n_pending_tasks, n_unique_pending",
        "begin_line": 526,
        "end_line": 554,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022988505747126436,
            "pseudo_dstar_susp": 0.0019880715705765406,
            "pseudo_tarantula_susp": 0.0035460992907801418,
            "pseudo_op2_susp": 0.0019880715705765406,
            "pseudo_barinel_susp": 0.0035460992907801418
        }
    },
    {
        "name": "luigi.worker.Worker._run_task#556",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._run_task(self, task_id)",
        "snippet": "    def _run_task(self, task_id):\n        task = self._scheduled_tasks[task_id]\n\n        p = TaskProcess(task, self._id, self._task_result_queue,\n                        random_seed=bool(self.worker_processes > 1),\n                        worker_timeout=self._config.timeout)\n\n        self._running_tasks[task_id] = p\n\n        if self.worker_processes > 1:\n            with fork_lock:\n                p.start()\n        else:\n            # Run in the same process\n            p.run()",
        "begin_line": 556,
        "end_line": 570,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.worker.Worker._purge_children#572",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._purge_children(self)",
        "snippet": "    def _purge_children(self):\n        \"\"\"\n        Find dead children and put a response on the result queue.\n\n        :return:\n        \"\"\"\n        for task_id, p in six.iteritems(self._running_tasks):\n            if not p.is_alive() and p.exitcode:\n                error_msg = 'Worker task %s died unexpectedly with exit code %s' % (task_id, p.exitcode)\n            elif p.timeout_time is not None and time.time() > float(p.timeout_time) and p.is_alive():\n                p.terminate()\n                error_msg = 'Worker task %s timed out and was terminated.' % task_id\n            else:\n                continue\n\n            logger.info(error_msg)\n            self._task_result_queue.put((task_id, FAILED, error_msg, [], []))",
        "begin_line": 572,
        "end_line": 588,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.worker.Worker._handle_next_task#590",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._handle_next_task(self)",
        "snippet": "    def _handle_next_task(self):\n        \"\"\"\n        We have to catch three ways a task can be \"done\":\n\n        1. normal execution: the task runs/fails and puts a result back on the queue,\n        2. new dependencies: the task yielded new deps that were not complete and\n           will be rescheduled and dependencies added,\n        3. child process dies: we need to catch this separately.\n        \"\"\"\n        while True:\n            self._purge_children()  # Deal with subprocess failures\n\n            try:\n                task_id, status, error_message, missing, new_requirements = (\n                    self._task_result_queue.get(\n                        timeout=float(self._config.wait_interval)))\n            except Queue.Empty:\n                return\n\n            task = self._scheduled_tasks[task_id]\n            if not task or task_id not in self._running_tasks:\n                continue\n                # Not a running task. Probably already removed.\n                # Maybe it yielded something?\n            new_deps = []\n            if new_requirements:\n                new_req = [load_task(module, name, params)\n                           for module, name, params in new_requirements]\n                for t in new_req:\n                    self.add(t)\n                new_deps = [t.task_id for t in new_req]\n\n            self._scheduler.add_task(worker=self._id,\n                                     task_id=task_id,\n                                     status=status,\n                                     expl=error_message,\n                                     resources=task.process_resources(),\n                                     runnable=None,\n                                     params=task.to_str_params(),\n                                     family=task.task_family,\n                                     module=task.task_module,\n                                     new_deps=new_deps,\n                                     assistant=self._assistant)\n\n            if status == RUNNING:\n                continue\n            self._running_tasks.pop(task_id)\n\n            # re-add task to reschedule missing dependencies\n            if missing:\n                reschedule = True\n\n                # keep out of infinite loops by not rescheduling too many times\n                for task_id in missing:\n                    self.unfulfilled_counts[task_id] += 1\n                    if (self.unfulfilled_counts[task_id] >\n                            self._config.max_reschedules):\n                        reschedule = False\n                if reschedule:\n                    self.add(task)\n\n            self.run_succeeded &= status in (DONE, SUSPENDED)\n            return",
        "begin_line": 590,
        "end_line": 652,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.worker.Worker._sleeper#654",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._sleeper(self)",
        "snippet": "    def _sleeper(self):\n        # TODO is exponential backoff necessary?\n        while True:\n            wait_interval = self._config.wait_interval + random.randint(1, 5)\n            logger.debug('Sleeping for %d seconds', wait_interval)\n            time.sleep(wait_interval)\n            yield",
        "begin_line": 654,
        "end_line": 660,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0045871559633027525,
            "pseudo_dstar_susp": 0.0021691973969631237,
            "pseudo_tarantula_susp": 0.010869565217391304,
            "pseudo_op2_susp": 0.0021691973969631237,
            "pseudo_barinel_susp": 0.010869565217391304
        }
    },
    {
        "name": "luigi.worker.Worker._keep_alive#662",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker._keep_alive(self, n_pending_tasks, n_unique_pending)",
        "snippet": "    def _keep_alive(self, n_pending_tasks, n_unique_pending):\n        \"\"\"\n        Returns true if a worker should stay alive given.\n\n        If worker-keep-alive is not set, this will always return false.\n        For an assistant, it will always return the value of worker-keep-alive.\n        Otherwise, it will return true for nonzero n_pending_tasks.\n\n        If worker-count-uniques is true, it will also\n        require that one of the tasks is unique to this worker.\n        \"\"\"\n        if not self._config.keep_alive:\n            return False\n        elif self._assistant:\n            return True\n        else:\n            return n_pending_tasks and (n_unique_pending or not self._config.count_uniques)",
        "begin_line": 662,
        "end_line": 678,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022988505747126436,
            "pseudo_dstar_susp": 0.0019880715705765406,
            "pseudo_tarantula_susp": 0.0035460992907801418,
            "pseudo_op2_susp": 0.0019880715705765406,
            "pseudo_barinel_susp": 0.0035460992907801418
        }
    },
    {
        "name": "luigi.worker.Worker.run#680",
        "src_path": "luigi/worker.py",
        "class_name": "luigi.worker.Worker",
        "signature": "luigi.worker.Worker.run(self)",
        "snippet": "    def run(self):\n        \"\"\"\n        Returns True if all scheduled tasks were executed successfully.\n        \"\"\"\n        logger.info('Running Worker with %d processes', self.worker_processes)\n\n        sleeper = self._sleeper()\n        self.run_succeeded = True\n\n        self._add_worker()\n\n        while True:\n            while len(self._running_tasks) >= self.worker_processes:\n                logger.debug('%d running tasks, waiting for next task to finish', len(self._running_tasks))\n                self._handle_next_task()\n\n            task_id, running_tasks, n_pending_tasks, n_unique_pending = self._get_work()\n\n            if task_id is None:\n                self._log_remote_tasks(running_tasks, n_pending_tasks, n_unique_pending)\n                if len(self._running_tasks) == 0:\n                    if self._keep_alive(n_pending_tasks, n_unique_pending):\n                        six.next(sleeper)\n                        continue\n                    else:\n                        break\n                else:\n                    self._handle_next_task()\n                    continue\n\n            # task_id is not None:\n            logger.debug(\"Pending tasks: %s\", n_pending_tasks)\n            self._run_task(task_id)\n\n        while len(self._running_tasks):\n            logger.debug('Shut down Worker, %d more tasks to go', len(self._running_tasks))\n            self._handle_next_task()\n\n        return self.run_succeeded",
        "begin_line": 680,
        "end_line": 718,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022988505747126436,
            "pseudo_dstar_susp": 0.0019880715705765406,
            "pseudo_tarantula_susp": 0.0035460992907801418,
            "pseudo_op2_susp": 0.0019880715705765406,
            "pseudo_barinel_susp": 0.0035460992907801418
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_scalding_core#104",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_scalding_core(self)",
        "snippet": "    def get_scalding_core(self):\n        lib_dir = os.path.join(self.scalding_home, 'lib')\n        for j in os.listdir(lib_dir):\n            if j.startswith('scalding-core-'):\n                p = os.path.join(lib_dir, j)\n                logger.debug('Found scalding-core: %s', p)\n                return p\n        raise luigi.contrib.hadoop.HadoopJobError('Could not find scalding-core.')",
        "begin_line": 104,
        "end_line": 111,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_provided_jars#113",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_provided_jars(self)",
        "snippet": "    def get_provided_jars(self):\n        return self._get_jars(self.provided_dir)",
        "begin_line": 113,
        "end_line": 114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.get_build_dir#123",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.get_build_dir(self, source)",
        "snippet": "    def get_build_dir(self, source):\n        build_dir = os.path.join(self.tmp_dir.path, 'build')\n        return build_dir",
        "begin_line": 123,
        "end_line": 125,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobRunner.run_job#196",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobRunner",
        "signature": "luigi.contrib.scalding.ScaldingJobRunner.run_job(self, job)",
        "snippet": "    def run_job(self, job):\n        job_jar = self.build_job_jar(job)\n        jars = [job_jar] + self.get_libjars() + job.extra_jars()\n        scalding_core = self.get_scalding_core()\n        libjars = ','.join(filter(None, jars))\n        arglist = luigi.contrib.hdfs.load_hadoop_cmd() + ['jar', scalding_core, '-libjars', libjars]\n        arglist += ['-D%s' % c for c in job.jobconfs()]\n\n        job_class = job.job_class() or self.get_job_class(job.source())\n        arglist += [job_class, '--hdfs']\n\n        # scalding does not parse argument with '=' properly\n        arglist += ['--name', job.task_id.replace('=', ':')]\n\n        (tmp_files, job_args) = luigi.contrib.hadoop_jar.fix_paths(job)\n        arglist += job_args\n\n        env = os.environ.copy()\n        jars.append(scalding_core)\n        hadoop_cp = ':'.join(filter(None, jars))\n        env['HADOOP_CLASSPATH'] = hadoop_cp\n        logger.info(\"Submitting Hadoop job: HADOOP_CLASSPATH=%s %s\",\n                    hadoop_cp, ' '.join(arglist))\n        luigi.contrib.hadoop.run_and_track_hadoop_job(arglist, env=env)\n\n        for a, b in tmp_files:\n            a.move(b)",
        "begin_line": 196,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobTask.job_class#270",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobTask",
        "signature": "luigi.contrib.scalding.ScaldingJobTask.job_class(self)",
        "snippet": "    def job_class(self):\n        \"\"\"\n        optional main job class for this Scalding Job.\n        \"\"\"\n        return None",
        "begin_line": 270,
        "end_line": 274,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobTask.job_runner#276",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobTask",
        "signature": "luigi.contrib.scalding.ScaldingJobTask.job_runner(self)",
        "snippet": "    def job_runner(self):\n        return ScaldingJobRunner()",
        "begin_line": 276,
        "end_line": 277,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.scalding.ScaldingJobTask.args#295",
        "src_path": "luigi/contrib/scalding.py",
        "class_name": "luigi.contrib.scalding.ScaldingJobTask",
        "signature": "luigi.contrib.scalding.ScaldingJobTask.args(self)",
        "snippet": "    def args(self):\n        \"\"\"\n        Returns an array of args to pass to the job.\n        \"\"\"\n        arglist = []\n        for k, v in six.iteritems(self.requires_hadoop()):\n            arglist.append('--' + k)\n            arglist.extend([t.output().path for t in flatten(v)])\n        arglist.extend(['--output', self.output()])\n        arglist.extend(self.job_args())\n        return arglist",
        "begin_line": 295,
        "end_line": 305,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.server.RPCHandler.initialize#68",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server.RPCHandler",
        "signature": "luigi.server.RPCHandler.initialize(self, scheduler)",
        "snippet": "    def initialize(self, scheduler):\n        self._scheduler = scheduler",
        "begin_line": 68,
        "end_line": 69,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00041476565740356696,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.server.RPCHandler.get#71",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server.RPCHandler",
        "signature": "luigi.server.RPCHandler.get(self, method)",
        "snippet": "    def get(self, method):\n        payload = self.get_argument('data', default=\"{}\")\n        arguments = json.loads(payload)\n\n        # TODO: we should probably denote all methods on the scheduler that are \"API-level\"\n        # versus internal methods. Right now you can do a REST method call to any method\n        # defined on the scheduler, which is pretty bad from a security point of view.\n\n        if hasattr(self._scheduler, method):\n            result = getattr(self._scheduler, method)(**arguments)\n            self.write({\"response\": result})  # wrap all json response in a dictionary\n        else:\n            self.send_error(404)",
        "begin_line": 71,
        "end_line": 83,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005827505827505828,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.server.from_utc#149",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server",
        "signature": "luigi.server.from_utc(utcTime, fmt=None)",
        "snippet": "def from_utc(utcTime, fmt=None):\n    \"\"\"convert UTC time string to time.struct_time: change datetime.datetime to time, return time.struct_time type\"\"\"\n    if fmt is None:\n        try_formats = [\"%Y-%m-%d %H:%M:%S.%f\", \"%Y-%m-%d %H:%M:%S\"]\n    else:\n        try_formats = [fmt]\n\n    for fmt in try_formats:\n        try:\n            time_struct = datetime.datetime.strptime(utcTime, fmt)\n        except ValueError:\n            pass\n        else:\n            date = int(time.mktime(time_struct.timetuple()))\n            return date\n    else:\n        raise ValueError(\"No UTC format matches {}\".format(utcTime))",
        "begin_line": 149,
        "end_line": 165,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.server.RootPathHandler.get#216",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server.RootPathHandler",
        "signature": "luigi.server.RootPathHandler.get(self)",
        "snippet": "    def get(self):\n        visualization_graph = self._scheduler._config.visualization_graph\n        if visualization_graph == \"d3\":\n            self.redirect(\"/static/visualiser/index.d3.html\")\n        elif visualization_graph == \"svg\":\n            self.redirect(\"/static/visualiser/index.html\")\n        else:\n            self.redirect(\"/static/visualiser/index.html\")",
        "begin_line": 216,
        "end_line": 223,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.server.app#226",
        "src_path": "luigi/server.py",
        "class_name": "luigi.server",
        "signature": "luigi.server.app(scheduler)",
        "snippet": "def app(scheduler):\n    settings = {\"static_path\": os.path.join(os.path.dirname(__file__), \"static\"), \"unescape\": tornado.escape.xhtml_unescape}\n    handlers = [\n        (r'/api/(.*)', RPCHandler, {\"scheduler\": scheduler}),\n        (r'/static/(.*)', StaticFileHandler),\n        (r'/', RootPathHandler, {'scheduler': scheduler}),\n        (r'/tasklist', AllRunHandler, {'scheduler': scheduler}),\n        (r'/tasklist/(.*?)', SelectedRunHandler, {'scheduler': scheduler}),\n        (r'/history', RecentRunHandler, {'scheduler': scheduler}),\n        (r'/history/by_name/(.*?)', ByNameHandler, {'scheduler': scheduler}),\n        (r'/history/by_id/(.*?)', ByIdHandler, {'scheduler': scheduler}),\n        (r'/history/by_params/(.*?)', ByParamsHandler, {'scheduler': scheduler})\n    ]\n    api_app = tornado.web.Application(handlers, **settings)\n    return api_app",
        "begin_line": 226,
        "end_line": 240,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.fix_paths#31",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar",
        "signature": "luigi.contrib.hadoop_jar.fix_paths(job)",
        "snippet": "def fix_paths(job):\n    \"\"\"\n    Coerce input arguments to use temporary files when used for output.\n\n    Return a list of temporary file pairs (tmpfile, destination path) and\n    a list of arguments.\n\n    Converts each HdfsTarget to a string for the path.\n    \"\"\"\n    tmp_files = []\n    args = []\n    for x in job.args():\n        if isinstance(x, luigi.contrib.hdfs.HdfsTarget):  # input/output\n            if x.exists() or not job.atomic_output():  # input\n                args.append(x.path)\n            else:  # output\n                x_path_no_slash = x.path[:-1] if x.path[-1] == '/' else x.path\n                y = luigi.contrib.hdfs.HdfsTarget(x_path_no_slash + '-luigi-tmp-%09d' % random.randrange(0, 1e10))\n                tmp_files.append((y, x_path_no_slash))\n                logger.info('Using temp path: %s for path %s', y.path, x.path)\n                args.append(y.path)\n        else:\n            args.append(str(x))\n\n    return (tmp_files, args)",
        "begin_line": 31,
        "end_line": 55,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobRunner.__init__#67",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobRunner",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobRunner.__init__(self)",
        "snippet": "    def __init__(self):\n        pass",
        "begin_line": 67,
        "end_line": 68,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000630119722747322,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobRunner.run_job#70",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobRunner",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobRunner.run_job(self, job)",
        "snippet": "    def run_job(self, job):\n        ssh_config = job.ssh()\n        if ssh_config:\n            host = ssh_config.get(\"host\", None)\n            key_file = ssh_config.get(\"key_file\", None)\n            username = ssh_config.get(\"username\", None)\n            if not host or not key_file or not username or not job.jar():\n                raise HadoopJarJobError(\"missing some config for HadoopRemoteJarJobRunner\")\n            arglist = ['ssh', '-i', key_file,\n                       '-o', 'BatchMode=yes']  # no password prompts etc\n            if ssh_config.get(\"no_host_key_check\", False):\n                arglist += ['-o', 'UserKnownHostsFile=/dev/null',\n                            '-o', 'StrictHostKeyChecking=no']\n            arglist.append('{}@{}'.format(username, host))\n        else:\n            arglist = []\n            if not job.jar():\n                raise HadoopJarJobError(\"Jar not defined\")\n            if not os.path.exists(job.jar()):\n                logger.error(\"Can't find jar: %s, full path %s\", job.jar(), os.path.abspath(job.jar()))\n                raise HadoopJarJobError(\"job jar does not exist\")\n\n        # TODO(jcrobak): libjars, files, etc. Can refactor out of\n        # hadoop.HadoopJobRunner\n        hadoop_arglist = luigi.contrib.hdfs.load_hadoop_cmd() + ['jar', job.jar()]\n        if job.main():\n            hadoop_arglist.append(job.main())\n\n        jobconfs = job.jobconfs()\n\n        for jc in jobconfs:\n            hadoop_arglist += ['-D' + jc]\n\n        (tmp_files, job_args) = fix_paths(job)\n\n        hadoop_arglist += job_args\n        arglist.extend(hadoop_arglist)\n\n        luigi.contrib.hadoop.run_and_track_hadoop_job(arglist)\n\n        for a, b in tmp_files:\n            a.move(b)",
        "begin_line": 70,
        "end_line": 111,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobTask.jar#119",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobTask",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobTask.jar(self)",
        "snippet": "    def jar(self):\n        \"\"\"\n        Path to the jar for this Hadoop Job.\n        \"\"\"\n        return None",
        "begin_line": 119,
        "end_line": 123,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobTask.main#125",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobTask",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobTask.main(self)",
        "snippet": "    def main(self):\n        \"\"\"\n        optional main method for this Hadoop Job.\n        \"\"\"\n        return None",
        "begin_line": 125,
        "end_line": 129,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobTask.job_runner#131",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobTask",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobTask.job_runner(self)",
        "snippet": "    def job_runner(self):\n        # We recommend that you define a subclass, override this method and set up your own config\n        return HadoopJarJobRunner()",
        "begin_line": 131,
        "end_line": 133,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000630119722747322,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobTask.ssh#142",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobTask",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobTask.ssh(self)",
        "snippet": "    def ssh(self):\n        \"\"\"\n        Set this to run hadoop command remotely via ssh. It needs to be a dict that looks like\n        {\"host\": \"myhost\", \"key_file\": None, \"username\": None, [\"no_host_key_check\": False]}\n        \"\"\"\n        return None",
        "begin_line": 142,
        "end_line": 147,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hadoop_jar.HadoopJarJobTask.args#149",
        "src_path": "luigi/contrib/hadoop_jar.py",
        "class_name": "luigi.contrib.hadoop_jar.HadoopJarJobTask",
        "signature": "luigi.contrib.hadoop_jar.HadoopJarJobTask.args(self)",
        "snippet": "    def args(self):\n        \"\"\"\n        Returns an array of args to pass to the job (after hadoop jar <jar> <main>).\n        \"\"\"\n        return []",
        "begin_line": 149,
        "end_line": 153,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.webhdfs.WebHdfsClient.__init__#122",
        "src_path": "luigi/contrib/webhdfs.py",
        "class_name": "luigi.contrib.webhdfs.WebHdfsClient",
        "signature": "luigi.contrib.webhdfs.WebHdfsClient.__init__(self, host=None, port=None, user=None)",
        "snippet": "    def __init__(self, host=None, port=None, user=None):\n        host = self.get_config('namenode_host') if host is None else host\n        port = self.get_config('namenode_port') if port is None else port\n        user = self.get_config('user') if user is None else os.environ['USER']\n\n        url = 'http://' + host + ':' + port\n        self.webhdfs = webhdfs.InsecureClient(url=url, user=user)",
        "begin_line": 122,
        "end_line": 128,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.024390243902439025,
            "pseudo_dstar_susp": 0.005952380952380952,
            "pseudo_tarantula_susp": 0.038461538461538464,
            "pseudo_op2_susp": 0.005952380952380952,
            "pseudo_barinel_susp": 0.038461538461538464
        }
    },
    {
        "name": "luigi.contrib.webhdfs.WebHdfsClient.get_config#130",
        "src_path": "luigi/contrib/webhdfs.py",
        "class_name": "luigi.contrib.webhdfs.WebHdfsClient",
        "signature": "luigi.contrib.webhdfs.WebHdfsClient.get_config(self, key)",
        "snippet": "    def get_config(self, key):\n        config = configuration.get_config()\n        try:\n            return config.get('hdfs', key)\n        except:\n            raise RuntimeError(\"You must specify %s in the [hdfs] section of \"\n                               \"the luigi.cfg file\" % key)",
        "begin_line": 130,
        "end_line": 136,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.024390243902439025,
            "pseudo_dstar_susp": 0.005952380952380952,
            "pseudo_tarantula_susp": 0.038461538461538464,
            "pseudo_op2_susp": 0.005952380952380952,
            "pseudo_barinel_susp": 0.038461538461538464
        }
    },
    {
        "name": "luigi.task.id_to_name_and_params#61",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task.id_to_name_and_params(task_id)",
        "snippet": "def id_to_name_and_params(task_id):\n    # DEPRECATED\n    import luigi.tools.parse_task\n    return luigi.tools.parse_task.id_to_name_and_params(task_id)",
        "begin_line": 61,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.019230769230769232,
            "pseudo_dstar_susp": 0.012048192771084338,
            "pseudo_tarantula_susp": 0.007518796992481203,
            "pseudo_op2_susp": 0.012048192771084338,
            "pseudo_barinel_susp": 0.007751937984496124
        }
    },
    {
        "name": "luigi.task.Task.wrapped#142",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.wrapped(callback)",
        "snippet": "        def wrapped(callback):\n            cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n            return callback",
        "begin_line": 142,
        "end_line": 144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00046882325363338024,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task.Task.event_handler#138",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.event_handler(cls, event)",
        "snippet": "    def event_handler(cls, event):\n        \"\"\"\n        Decorator for adding event handlers.\n        \"\"\"\n        def wrapped(callback):\n            cls._event_callbacks.setdefault(cls, {}).setdefault(event, set()).add(callback)\n            return callback\n        return wrapped",
        "begin_line": 138,
        "end_line": 145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00043535045711797995,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task.Task.trigger_event#147",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.trigger_event(self, event, *args, **kwargs)",
        "snippet": "    def trigger_event(self, event, *args, **kwargs):\n        \"\"\"\n        Trigger that calls all of the specified events associated with this class.\n        \"\"\"\n        for event_class, event_callbacks in six.iteritems(self._event_callbacks):\n            if not isinstance(self, event_class):\n                continue\n            for callback in event_callbacks.get(event, []):\n                try:\n                    # callbacks are protected\n                    callback(*args, **kwargs)\n                except KeyboardInterrupt:\n                    return\n                except BaseException:\n                    logger.exception(\"Error in event callback for %r\", event)",
        "begin_line": 147,
        "end_line": 161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022026431718061676,
            "pseudo_dstar_susp": 0.003401360544217687,
            "pseudo_tarantula_susp": 0.00202020202020202,
            "pseudo_op2_susp": 0.003401360544217687,
            "pseudo_barinel_susp": 0.00202020202020202
        }
    },
    {
        "name": "luigi.task.Task.task_module#164",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.task_module(self)",
        "snippet": "    def task_module(self):\n        ''' Returns what Python module to import to get access to this class. '''\n        # TODO(erikbern): we should think about a language-agnostic mechanism\n        return self.__class__.__module__",
        "begin_line": 164,
        "end_line": 167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00186219739292365,
            "pseudo_dstar_susp": 0.0024752475247524753,
            "pseudo_tarantula_susp": 0.0016750418760469012,
            "pseudo_op2_susp": 0.0024752475247524753,
            "pseudo_barinel_susp": 0.0016750418760469012
        }
    },
    {
        "name": "luigi.task.Task.task_family#170",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.task_family(self)",
        "snippet": "    def task_family(self):\n        \"\"\"\n        Convenience method since a property on the metaclass isn't directly accessible through the class instances.\n        \"\"\"\n        return self.__class__.task_family",
        "begin_line": 170,
        "end_line": 174,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004524886877828055,
            "pseudo_dstar_susp": 0.018518518518518517,
            "pseudo_tarantula_susp": 0.002207505518763797,
            "pseudo_op2_susp": 0.018867924528301886,
            "pseudo_barinel_susp": 0.002207505518763797
        }
    },
    {
        "name": "luigi.task.Task.get_params#177",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.get_params(cls)",
        "snippet": "    def get_params(cls):\n        \"\"\"\n        Returns all of the Parameters for this Task.\n        \"\"\"\n        # We want to do this here and not at class instantiation, or else there is no room to extend classes dynamically\n        params = []\n        for param_name in dir(cls):\n            param_obj = getattr(cls, param_name)\n            if not isinstance(param_obj, Parameter):\n                continue\n\n            params.append((param_name, param_obj))\n\n        # The order the parameters are created matters. See Parameter class\n        params.sort(key=lambda t: t[1].counter)\n        return params",
        "begin_line": 177,
        "end_line": 192,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005714285714285714,
            "pseudo_dstar_susp": 0.02702702702702703,
            "pseudo_tarantula_susp": 0.002352941176470588,
            "pseudo_op2_susp": 0.02702702702702703,
            "pseudo_barinel_susp": 0.002352941176470588
        }
    },
    {
        "name": "luigi.task.Task.get_param_values#195",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.get_param_values(cls, params, args, kwargs)",
        "snippet": "    def get_param_values(cls, params, args, kwargs):\n        \"\"\"\n        Get the values of the parameters from the args and kwargs.\n\n        :param params: list of (param_name, Parameter).\n        :param args: positional arguments\n        :param kwargs: keyword arguments.\n        :returns: list of `(name, value)` tuples, one for each parameter.\n        \"\"\"\n        result = {}\n\n        params_dict = dict(params)\n\n        task_name = cls.task_family\n\n        # In case any exceptions are thrown, create a helpful description of how the Task was invoked\n        # TODO: should we detect non-reprable arguments? These will lead to mysterious errors\n        exc_desc = '%s[args=%s, kwargs=%s]' % (task_name, args, kwargs)\n\n        # Fill in the positional arguments\n        positional_params = [(n, p) for n, p in params if p.positional]\n        for i, arg in enumerate(args):\n            if i >= len(positional_params):\n                raise parameter.UnknownParameterException('%s: takes at most %d parameters (%d given)' % (exc_desc, len(positional_params), len(args)))\n            param_name, param_obj = positional_params[i]\n            result[param_name] = arg\n\n        # Then the optional arguments\n        for param_name, arg in six.iteritems(kwargs):\n            if param_name in result:\n                raise parameter.DuplicateParameterException('%s: parameter %s was already set as a positional parameter' % (exc_desc, param_name))\n            if param_name not in params_dict:\n                raise parameter.UnknownParameterException('%s: unknown parameter %s' % (exc_desc, param_name))\n            result[param_name] = arg\n\n        # Then use the defaults for anything not filled in\n        for param_name, param_obj in params:\n            if param_name not in result:\n                if not param_obj.has_task_value(task_name, param_name):\n                    raise parameter.MissingParameterException(\"%s: requires the '%s' parameter to be set\" % (exc_desc, param_name))\n                result[param_name] = param_obj.task_value(task_name, param_name)\n\n        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x\n        # Sort it by the correct order and make a list\n        return [(param_name, list_to_tuple(result[param_name])) for param_name, param_obj in params]",
        "begin_line": 195,
        "end_line": 244,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005076142131979695,
            "pseudo_dstar_susp": 0.023809523809523808,
            "pseudo_tarantula_susp": 0.0022727272727272726,
            "pseudo_op2_susp": 0.023809523809523808,
            "pseudo_barinel_susp": 0.0022727272727272726
        }
    },
    {
        "name": "luigi.task.Task.list_to_tuple#237",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.list_to_tuple(x)",
        "snippet": "        def list_to_tuple(x):\n            \"\"\" Make tuples out of lists and sets to allow hashing \"\"\"\n            if isinstance(x, list) or isinstance(x, set):\n                return tuple(x)\n            else:\n                return x",
        "begin_line": 237,
        "end_line": 242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004219409282700422,
            "pseudo_dstar_susp": 0.017857142857142856,
            "pseudo_tarantula_susp": 0.002188183807439825,
            "pseudo_op2_susp": 0.01818181818181818,
            "pseudo_barinel_susp": 0.002188183807439825
        }
    },
    {
        "name": "luigi.task.Task.__init__#246",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Constructor to resolve values for all Parameters.\n\n        For example, the Task:\n\n        .. code-block:: python\n\n            class MyTask(luigi.Task):\n                count = luigi.IntParameter()\n\n        can be instantiated as ``MyTask(count=10)``.\n        \"\"\"\n        params = self.get_params()\n        param_values = self.get_param_values(params, args, kwargs)\n\n        # Set all values on class instance\n        for key, value in param_values:\n            setattr(self, key, value)\n\n        # Register args and kwargs as an attribute on the class. Might be useful\n        self.param_args = tuple(value for key, value in param_values)\n        self.param_kwargs = dict(param_values)\n\n        # Build up task id\n        task_id_parts = []\n        param_objs = dict(params)\n        for param_name, param_value in param_values:\n            if param_objs[param_name].significant:\n                task_id_parts.append('%s=%s' % (param_name, param_objs[param_name].serialize(param_value)))\n\n        self.task_id = '%s(%s)' % (self.task_family, ', '.join(task_id_parts))\n        self.__hash = hash(self.task_id)",
        "begin_line": 246,
        "end_line": 278,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0196078431372549,
            "pseudo_dstar_susp": 0.0136986301369863,
            "pseudo_tarantula_susp": 0.00980392156862745,
            "pseudo_op2_susp": 0.0136986301369863,
            "pseudo_barinel_susp": 0.00980392156862745
        }
    },
    {
        "name": "luigi.task.Task.initialized#280",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.initialized(self)",
        "snippet": "    def initialized(self):\n        \"\"\"\n        Returns ``True`` if the Task is initialized and ``False`` otherwise.\n        \"\"\"\n        return hasattr(self, 'task_id')",
        "begin_line": 280,
        "end_line": 284,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022988505747126436,
            "pseudo_dstar_susp": 0.0019880715705765406,
            "pseudo_tarantula_susp": 0.0035460992907801418,
            "pseudo_op2_susp": 0.0019880715705765406,
            "pseudo_barinel_susp": 0.0035460992907801418
        }
    },
    {
        "name": "luigi.task.Task.from_str_params#287",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.from_str_params(cls, params_str=None)",
        "snippet": "    def from_str_params(cls, params_str=None):\n        \"\"\"\n        Creates an instance from a str->str hash.\n\n        :param params_str: dict of param name -> value.\n        \"\"\"\n        if params_str is None:\n            params_str = {}\n        kwargs = {}\n        for param_name, param in cls.get_params():\n            value = param.parse_from_input(param_name, params_str[param_name])\n            kwargs[param_name] = value\n\n        return cls(**kwargs)",
        "begin_line": 287,
        "end_line": 300,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.002325581395348837,
            "pseudo_tarantula_susp": 0.038461538461538464,
            "pseudo_op2_susp": 0.002325581395348837,
            "pseudo_barinel_susp": 0.038461538461538464
        }
    },
    {
        "name": "luigi.task.Task.to_str_params#302",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.to_str_params(self)",
        "snippet": "    def to_str_params(self):\n        \"\"\"\n        Convert all parameters to a str->str hash.\n        \"\"\"\n        params_str = {}\n        params = dict(self.get_params())\n        for param_name, param_value in six.iteritems(self.param_kwargs):\n            if params[param_name].significant:\n                params_str[param_name] = params[param_name].serialize(param_value)\n\n        return params_str",
        "begin_line": 302,
        "end_line": 312,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.0035460992907801418,
            "pseudo_dstar_susp": 0.003105590062111801,
            "pseudo_tarantula_susp": 0.004878048780487805,
            "pseudo_op2_susp": 0.003105590062111801,
            "pseudo_barinel_susp": 0.004878048780487805
        }
    },
    {
        "name": "luigi.task.Task.clone#314",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.clone(self, cls=None, **kwargs)",
        "snippet": "    def clone(self, cls=None, **kwargs):\n        \"\"\"\n        Creates a new instance from an existing instance where some of the args have changed.\n\n        There's at least two scenarios where this is useful (see test/clone_test.py):\n\n        * remove a lot of boiler plate when you have recursive dependencies and lots of args\n        * there's task inheritance and some logic is on the base class\n\n        :param cls:\n        :param kwargs:\n        :return:\n        \"\"\"\n        k = self.param_kwargs.copy()\n        k.update(six.iteritems(kwargs))\n\n        if cls is None:\n            cls = self.__class__\n\n        new_k = {}\n        for param_name, param_class in cls.get_params():\n            if param_name in k:\n                new_k[param_name] = k[param_name]\n\n        return cls(**new_k)",
        "begin_line": 314,
        "end_line": 338,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task.Task.__hash__#340",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.__hash__(self)",
        "snippet": "    def __hash__(self):\n        return self.__hash",
        "begin_line": 340,
        "end_line": 341,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task.Task.__repr__#343",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.__repr__(self)",
        "snippet": "    def __repr__(self):\n        return self.task_id",
        "begin_line": 343,
        "end_line": 344,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0023752969121140144,
            "pseudo_dstar_susp": 0.0020325203252032522,
            "pseudo_tarantula_susp": 0.003787878787878788,
            "pseudo_op2_susp": 0.0020325203252032522,
            "pseudo_barinel_susp": 0.003787878787878788
        }
    },
    {
        "name": "luigi.task.Task.__eq__#346",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.__eq__(self, other)",
        "snippet": "    def __eq__(self, other):\n        return self.__class__ == other.__class__ and self.param_args == other.param_args",
        "begin_line": 346,
        "end_line": 347,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task.Task.complete#349",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.complete(self)",
        "snippet": "    def complete(self):\n        \"\"\"\n        If the task has any outputs, return ``True`` if all outputs exists.\n        Otherwise, return ``False``.\n\n        However, you may freely override this method with custom logic.\n        \"\"\"\n        outputs = flatten(self.output())\n        if len(outputs) == 0:\n            warnings.warn(\n                \"Task %r without outputs has no custom complete() method\" % self,\n                stacklevel=2\n            )\n            return False\n\n        return all(map(lambda output: output.exists(), outputs))",
        "begin_line": 349,
        "end_line": 364,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005186721991701245,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task.Task.bulk_complete#367",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.bulk_complete(cls, parameter_tuples)",
        "snippet": "    def bulk_complete(cls, parameter_tuples):\n        \"\"\"\n        Returns those of parameter_tuples for which this Task is complete.\n\n        Override (with an efficient implementation) for efficient scheduling\n        with range tools. Keep the logic consistent with that of complete().\n        \"\"\"\n        raise BulkCompleteNotImplementedError()",
        "begin_line": 367,
        "end_line": 374,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task.Task.output#376",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.output(self)",
        "snippet": "    def output(self):\n        \"\"\"\n        The output that this Task produces.\n\n        The output of the Task determines if the Task needs to be run--the task\n        is considered finished iff the outputs all exist. Subclasses should\n        override this method to return a single :py:class:`Target` or a list of\n        :py:class:`Target` instances.\n\n        Implementation note\n          If running multiple workers, the output must be a resource that is accessible\n          by all workers, such as a DFS or database. Otherwise, workers might compute\n          the same output since they don't see the work done by other workers.\n\n        See :ref:`Task.output`\n        \"\"\"\n        return []  # default impl",
        "begin_line": 376,
        "end_line": 392,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005091649694501018,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task.Task.requires#394",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.requires(self)",
        "snippet": "    def requires(self):\n        \"\"\"\n        The Tasks that this Task depends on.\n\n        A Task will only run if all of the Tasks that it requires are completed.\n        If your Task does not require any other Tasks, then you don't need to\n        override this method. Otherwise, a Subclasses can override this method\n        to return a single Task, a list of Task instances, or a dict whose\n        values are Task instances.\n\n        See :ref:`Task.requires`\n        \"\"\"\n        return []  # default impl",
        "begin_line": 394,
        "end_line": 406,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00048216007714561236,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task.Task._requires#408",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task._requires(self)",
        "snippet": "    def _requires(self):\n        \"\"\"\n        Override in \"template\" tasks which themselves are supposed to be\n        subclassed and thus have their requires() overridden (name preserved to\n        provide consistent end-user experience), yet need to introduce\n        (non-input) dependencies.\n\n        Must return an iterable which among others contains the _requires() of\n        the superclass.\n        \"\"\"\n        return flatten(self.requires())  # base impl",
        "begin_line": 408,
        "end_line": 418,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00046189376443418013,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task.Task.process_resources#420",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.process_resources(self)",
        "snippet": "    def process_resources(self):\n        \"\"\"\n        Override in \"template\" tasks which provide common resource functionality\n        but allow subclasses to specify additional resources while preserving\n        the name for consistent end-user experience.\n        \"\"\"\n        return self.resources  # default impl",
        "begin_line": 420,
        "end_line": 426,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022988505747126436,
            "pseudo_dstar_susp": 0.0019880715705765406,
            "pseudo_tarantula_susp": 0.0035460992907801418,
            "pseudo_op2_susp": 0.0019880715705765406,
            "pseudo_barinel_susp": 0.0035460992907801418
        }
    },
    {
        "name": "luigi.task.Task.input#428",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.input(self)",
        "snippet": "    def input(self):\n        \"\"\"\n        Returns the outputs of the Tasks returned by :py:meth:`requires`\n\n        See :ref:`Task.input`\n\n        :return: a list of :py:class:`Target` objects which are specified as\n                 outputs of all required Tasks.\n        \"\"\"\n        return getpaths(self.requires())",
        "begin_line": 428,
        "end_line": 437,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005659309564233164,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task.Task.deps#439",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.deps(self)",
        "snippet": "    def deps(self):\n        \"\"\"\n        Internal method used by the scheduler.\n\n        Returns the flattened list of requires.\n        \"\"\"\n        # used by scheduler\n        return flatten(self._requires())",
        "begin_line": 439,
        "end_line": 446,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00046189376443418013,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task.Task.run#448",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.run(self)",
        "snippet": "    def run(self):\n        \"\"\"\n        The task run method, to be overridden in a subclass.\n\n        See :ref:`Task.run`\n        \"\"\"\n        pass  # default impl",
        "begin_line": 448,
        "end_line": 454,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task.Task.on_failure#456",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.on_failure(self, exception)",
        "snippet": "    def on_failure(self, exception):\n        \"\"\"\n        Override for custom error handling.\n\n        This method gets called if an exception is raised in :py:meth:`run`.\n        Return value of this method is json encoded and sent to the scheduler as the `expl` argument. Its string representation will be used as the body of the error email sent out if any.\n\n        Default behavior is to return a string representation of the stack trace.\n        \"\"\"\n\n        traceback_string = traceback.format_exc()\n        return \"Runtime error:\\n%s\" % traceback_string",
        "begin_line": 456,
        "end_line": 467,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task.Task.on_success#469",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.Task",
        "signature": "luigi.task.Task.on_success(self)",
        "snippet": "    def on_success(self):\n        \"\"\"\n        Override for doing custom completion handling for a larger class of tasks\n\n        This method gets called when :py:meth:`run` completes without raising any exceptions.\n\n        The returned value is json encoded and sent to the scheduler as the `expl` argument.\n\n        Default behavior is to send an None value\"\"\"\n        pass",
        "begin_line": 469,
        "end_line": 478,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00045433893684688776,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task.WrapperTask.complete#520",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task.WrapperTask",
        "signature": "luigi.task.WrapperTask.complete(self)",
        "snippet": "    def complete(self):\n        return all(r.complete() for r in flatten(self.requires()))",
        "begin_line": 520,
        "end_line": 521,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task.getpaths#534",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task.getpaths(struct)",
        "snippet": "def getpaths(struct):\n    \"\"\"\n    Maps all Tasks in a structured data object to their .output().\n    \"\"\"\n    if isinstance(struct, Task):\n        return struct.output()\n    elif isinstance(struct, dict):\n        r = {}\n        for k, v in six.iteritems(struct):\n            r[k] = getpaths(v)\n        return r\n    else:\n        # Remaining case: assume r is iterable...\n        try:\n            s = list(struct)\n        except TypeError:\n            raise Exception('Cannot map %s to Task/dict/list' % str(struct))\n\n        return [getpaths(r) for r in s]",
        "begin_line": 534,
        "end_line": 552,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task.flatten#555",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task.flatten(struct)",
        "snippet": "def flatten(struct):\n    \"\"\"\n    Creates a flat list of all all items in structured output (dicts, lists, items):\n\n    .. code-block:: python\n\n        >>> sorted(flatten({'a': 'foo', 'b': 'bar'}))\n        ['bar', 'foo']\n        >>> sorted(flatten(['foo', ['bar', 'troll']]))\n        ['bar', 'foo', 'troll']\n        >>> flatten('foo')\n        ['foo']\n        >>> flatten(42)\n        [42]\n    \"\"\"\n    if struct is None:\n        return []\n    flat = []\n    if isinstance(struct, dict):\n        for _, result in six.iteritems(struct):\n            flat += flatten(result)\n        return flat\n    if isinstance(struct, six.string_types):\n        return [struct]\n\n    try:\n        # if iterable\n        iterator = iter(struct)\n    except TypeError:\n        return [struct]\n\n    for result in iterator:\n        flat += flatten(result)\n    return flat",
        "begin_line": 555,
        "end_line": 588,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task.flatten_output#591",
        "src_path": "luigi/task.py",
        "class_name": "luigi.task",
        "signature": "luigi.task.flatten_output(task)",
        "snippet": "def flatten_output(task):\n    \"\"\"\n    Lists all output targets by recursively walking output-less (wrapper) tasks.\n\n    FIXME order consistently.\n    \"\"\"\n    r = flatten(task.output())\n    if not r:\n        for dep in flatten(task.requires()):\n            r += flatten_output(dep)\n    return r",
        "begin_line": 591,
        "end_line": 601,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.target.FileSystemTarget.__init__#173",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.FileSystemTarget",
        "signature": "luigi.target.FileSystemTarget.__init__(self, path)",
        "snippet": "    def __init__(self, path):\n        \"\"\"\n        Initializes a FileSystemTarget instance.\n\n        :param str path: the path associated with this FileSystemTarget.\n        \"\"\"\n        self.path = path",
        "begin_line": 173,
        "end_line": 179,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0003843197540353574,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.target.FileSystemTarget.exists#202",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.FileSystemTarget",
        "signature": "luigi.target.FileSystemTarget.exists(self)",
        "snippet": "    def exists(self):\n        \"\"\"\n        Returns ``True`` if the path for this FileSystemTarget exists; ``False`` otherwise.\n\n        This method is implemented by using :py:meth:`fs`.\n        \"\"\"\n        path = self.path\n        if '*' in path or '?' in path or '[' in path or '{' in path:\n            logger.warning(\"Using wildcards in path %s might lead to processing of an incomplete dataset; \"\n                           \"override exists() to suppress the warning.\", path)\n        return self.fs.exists(path)",
        "begin_line": 202,
        "end_line": 212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004380201489268506,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.target.AtomicLocalFile.__init__#232",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.AtomicLocalFile",
        "signature": "luigi.target.AtomicLocalFile.__init__(self, path)",
        "snippet": "    def __init__(self, path):\n        self.__tmp_path = self.generate_tmp_path(path)\n        self.path = path\n        super(AtomicLocalFile, self).__init__(io.FileIO(self.__tmp_path, 'w'))",
        "begin_line": 232,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004084967320261438,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.target.AtomicLocalFile.close#237",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.AtomicLocalFile",
        "signature": "luigi.target.AtomicLocalFile.close(self)",
        "snippet": "    def close(self):\n        super(AtomicLocalFile, self).close()\n        self.move_to_final_destination()",
        "begin_line": 237,
        "end_line": 239,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004158004158004158,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.target.AtomicLocalFile.__del__#247",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.AtomicLocalFile",
        "signature": "luigi.target.AtomicLocalFile.__del__(self)",
        "snippet": "    def __del__(self):\n        if os.path.exists(self.tmp_path):\n            os.remove(self.tmp_path)",
        "begin_line": 247,
        "end_line": 249,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004775549188156638,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.target.AtomicLocalFile.tmp_path#252",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.AtomicLocalFile",
        "signature": "luigi.target.AtomicLocalFile.tmp_path(self)",
        "snippet": "    def tmp_path(self):\n        return self.__tmp_path",
        "begin_line": 252,
        "end_line": 253,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00040225261464199515,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.target.AtomicLocalFile.__exit__#255",
        "src_path": "luigi/target.py",
        "class_name": "luigi.target.AtomicLocalFile",
        "signature": "luigi.target.AtomicLocalFile.__exit__(self, exc_type, exc, traceback)",
        "snippet": "    def __exit__(self, exc_type, exc, traceback):\n        \" Close/commit the file if there are no exception \"\n        if exc_type:\n            return\n        return super(AtomicLocalFile, self).__exit__(exc_type, exc, traceback)",
        "begin_line": 255,
        "end_line": 259,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.parameter.Parameter.__init__#104",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.__init__(self, default=_no_value, is_list=False, is_boolean=False, is_global=False, significant=True, description=None, config_path=None, positional=True)",
        "snippet": "    def __init__(self, default=_no_value, is_list=False, is_boolean=False, is_global=False, significant=True, description=None,\n                 config_path=None, positional=True):\n        \"\"\"\n        :param default: the default value for this parameter. This should match the type of the\n                        Parameter, i.e. ``datetime.date`` for ``DateParameter`` or ``int`` for\n                        ``IntParameter``. By default, no default is stored and\n                        the value must be specified at runtime.\n        :param bool is_list: specify ``True`` if the parameter should allow a list of values rather\n                             than a single value. Default: ``False``. A list has an implicit default\n                             value of ``[]``.\n        :param bool is_bool: specify ``True`` if the parameter is a bool value. Default:\n                                ``False``. Bool's have an implicit default value of ``False``.\n        :param bool significant: specify ``False`` if the parameter should not be treated as part of\n                                 the unique identifier for a Task. An insignificant Parameter might\n                                 also be used to specify a password or other sensitive information\n                                 that should not be made public via the scheduler. Default:\n                                 ``True``.\n        :param str description: A human-readable string describing the purpose of this Parameter.\n                                For command-line invocations, this will be used as the `help` string\n                                shown to users. Default: ``None``.\n        :param dict config_path: a dictionary with entries ``section`` and ``name``\n                                 specifying a config file entry from which to read the\n                                 default value for this parameter. DEPRECATED.\n                                 Default: ``None``.\n        :param bool positional: If true, you can set the argument as a\n                                positional argument. Generally we recommend ``positional=False``\n                                as positional arguments become very tricky when\n                                you have inheritance and whatnot.\n        \"\"\"\n        # The default default is no default\n        self.__default = default\n        self.__global = _no_value\n\n        self.is_list = is_list\n        self.is_bool = is_boolean and not is_list  # Only BoolParameter should ever use this. TODO(erikbern): should we raise some kind of exception?\n        if is_global:\n            warnings.warn(\"is_global support is removed. Assuming positional=False\",\n                          DeprecationWarning,\n                          stacklevel=2)\n            positional = False\n        self.significant = significant  # Whether different values for this parameter will differentiate otherwise equal tasks\n        self.positional = positional\n\n        self.description = description\n\n        if config_path is not None and ('section' not in config_path or 'name' not in config_path):\n            raise ParameterException('config_path must be a hash containing entries for section and name')\n        self.__config = config_path\n\n        self.counter = Parameter.counter  # We need to keep track of this to get the order right (see Task class)\n        Parameter.counter += 1",
        "begin_line": 104,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002178649237472767,
            "pseudo_dstar_susp": 0.001953125,
            "pseudo_tarantula_susp": 0.003205128205128205,
            "pseudo_op2_susp": 0.001953125,
            "pseudo_barinel_susp": 0.003205128205128205
        }
    },
    {
        "name": "luigi.parameter.Parameter._get_value_from_config#156",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._get_value_from_config(self, section, name)",
        "snippet": "    def _get_value_from_config(self, section, name):\n        \"\"\"Loads the default from the config. Returns _no_value if it doesn't exist\"\"\"\n\n        conf = configuration.get_config()\n\n        try:\n            value = conf.get(section, name)\n        except (NoSectionError, NoOptionError):\n            return _no_value\n\n        if self.is_list:\n            return tuple(self.parse(p.strip()) for p in value.strip().split('\\n'))\n        else:\n            return self.parse(value)",
        "begin_line": 156,
        "end_line": 169,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0045871559633027525,
            "pseudo_dstar_susp": 0.011627906976744186,
            "pseudo_tarantula_susp": 0.0033222591362126247,
            "pseudo_op2_susp": 0.011627906976744186,
            "pseudo_barinel_susp": 0.0033222591362126247
        }
    },
    {
        "name": "luigi.parameter.Parameter._get_value#171",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter._get_value(self, task_name=None, param_name=None)",
        "snippet": "    def _get_value(self, task_name=None, param_name=None):\n        if self.__global != _no_value:\n            return self.__global\n        if task_name and param_name:\n            v = self._get_value_from_config(task_name, param_name)\n            if v != _no_value:\n                return v\n            v = self._get_value_from_config(task_name, param_name.replace('_', '-'))\n            if v != _no_value:\n                warnings.warn(\n                    'The use of the configuration [%s] %s (with dashes) should be avoided. Please use underscores.' %\n                    (task_name, param_name), DeprecationWarning, stacklevel=2)\n                return v\n        if self.__config:\n            v = self._get_value_from_config(self.__config['section'], self.__config['name'])\n            if v != _no_value and task_name and param_name:\n                warnings.warn(\n                    'The use of the configuration [%s] %s is deprecated. Please use [%s] %s' %\n                    (self.__config['section'], self.__config['name'], task_name, param_name),\n                    DeprecationWarning, stacklevel=2)\n            if v != _no_value:\n                return v\n        if self.__default != _no_value:\n            return self.__default\n\n        return _no_value",
        "begin_line": 171,
        "end_line": 196,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0072992700729927005,
            "pseudo_dstar_susp": 0.009345794392523364,
            "pseudo_tarantula_susp": 0.010869565217391304,
            "pseudo_op2_susp": 0.009345794392523364,
            "pseudo_barinel_susp": 0.010869565217391304
        }
    },
    {
        "name": "luigi.parameter.Parameter.has_value#199",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.has_value(self)",
        "snippet": "    def has_value(self):\n        \"\"\"\n        ``True`` if a default was specified or if config_path references a valid entry in the conf.\n\n        Note that \"value\" refers to the Parameter object itself - it can be either\n\n        1. The default value for this parameter\n        2. A value read from the config\n        3. A global value\n\n        Any Task instance can have its own value set that overrides this.\n        \"\"\"\n        return self._get_value() != _no_value",
        "begin_line": 199,
        "end_line": 211,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.parameter.Parameter.has_task_value#230",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.has_task_value(self, task_name, param_name)",
        "snippet": "    def has_task_value(self, task_name, param_name):\n        return self._get_value(task_name, param_name) != _no_value",
        "begin_line": 230,
        "end_line": 231,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035460992907801418,
            "pseudo_dstar_susp": 0.003436426116838488,
            "pseudo_tarantula_susp": 0.004878048780487805,
            "pseudo_op2_susp": 0.003436426116838488,
            "pseudo_barinel_susp": 0.004878048780487805
        }
    },
    {
        "name": "luigi.parameter.Parameter.task_value#233",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.task_value(self, task_name, param_name)",
        "snippet": "    def task_value(self, task_name, param_name):\n        value = self._get_value(task_name, param_name)\n        if value == _no_value:\n            raise MissingParameterException(\"No default specified\")\n        else:\n            return value",
        "begin_line": 233,
        "end_line": 238,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.010526315789473684,
            "pseudo_tarantula_susp": 0.038461538461538464,
            "pseudo_op2_susp": 0.010526315789473684,
            "pseudo_barinel_susp": 0.038461538461538464
        }
    },
    {
        "name": "luigi.parameter.Parameter.reset_global#248",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.reset_global(self)",
        "snippet": "    def reset_global(self):\n        self.__global = _no_value",
        "begin_line": 248,
        "end_line": 249,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019342359767891683,
            "pseudo_dstar_susp": 0.00186219739292365,
            "pseudo_tarantula_susp": 0.002079002079002079,
            "pseudo_op2_susp": 0.00186219739292365,
            "pseudo_barinel_susp": 0.002079002079002079
        }
    },
    {
        "name": "luigi.parameter.Parameter.parse#251",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.parse(self, x)",
        "snippet": "    def parse(self, x):\n        \"\"\"\n        Parse an individual value from the input.\n\n        The default implementation is an identify (it returns ``x``), but subclasses should override\n        this method for specialized parsing. This method is called by :py:meth:`parse_from_input`\n        if ``x`` exists. If this Parameter was specified with ``is_list=True``, then ``parse`` is\n        called once for each item in the list.\n\n        :param str x: the value to parse.\n        :return: the parsed value.\n        \"\"\"\n        return x  # default impl",
        "begin_line": 251,
        "end_line": 263,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004651162790697674,
            "pseudo_dstar_susp": 0.003424657534246575,
            "pseudo_tarantula_susp": 0.006993006993006993,
            "pseudo_op2_susp": 0.003424657534246575,
            "pseudo_barinel_susp": 0.007042253521126761
        }
    },
    {
        "name": "luigi.parameter.Parameter.serialize#265",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.serialize(self, x)",
        "snippet": "    def serialize(self, x):  # opposite of parse\n        \"\"\"\n        Opposite of :py:meth:`parse`.\n\n        Converts the value ``x`` to a string.\n\n        :param x: the value to serialize.\n        \"\"\"\n        if self.is_list:\n            return [str(v) for v in x]\n        return str(x)",
        "begin_line": 265,
        "end_line": 275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.005780346820809248,
            "pseudo_tarantula_susp": 0.010869565217391304,
            "pseudo_op2_susp": 0.005780346820809248,
            "pseudo_barinel_susp": 0.010869565217391304
        }
    },
    {
        "name": "luigi.parameter.Parameter.parse_from_input#277",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.parse_from_input(self, param_name, x, task_name=None)",
        "snippet": "    def parse_from_input(self, param_name, x, task_name=None):\n        \"\"\"\n        Parses the parameter value from input ``x``, handling defaults and is_list.\n\n        :param param_name: the name of the parameter. This is used for the message in\n                           ``MissingParameterException``.\n        :param x: the input value to parse.\n        :raises MissingParameterException: if x is false-y and no default is specified.\n        \"\"\"\n        if not x:\n            if self.has_task_value(param_name=param_name, task_name=task_name):\n                return self.task_value(param_name=param_name, task_name=task_name)\n            elif self.is_bool:\n                return False\n            elif self.is_list:\n                return []\n            else:\n                raise MissingParameterException(\"No value for '%s' (%s) submitted and no default value has been assigned.\" %\n                                                (param_name, \"--\" + param_name.replace('_', '-')))\n        elif self.is_list:\n            return tuple(self.parse(p) for p in x)\n        else:\n            return self.parse(x)",
        "begin_line": 277,
        "end_line": 299,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002570694087403599,
            "pseudo_dstar_susp": 0.0029239766081871343,
            "pseudo_tarantula_susp": 0.004484304932735426,
            "pseudo_op2_susp": 0.0029239766081871343,
            "pseudo_barinel_susp": 0.004484304932735426
        }
    },
    {
        "name": "luigi.parameter.Parameter.parser_dest#307",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.parser_dest(self, param_name, task_name, glob=False, is_without_section=False)",
        "snippet": "    def parser_dest(self, param_name, task_name, glob=False, is_without_section=False):\n        if is_without_section:\n            if glob:\n                return param_name\n            else:\n                return None\n        else:\n            if glob:\n                return task_name + '_' + param_name\n            else:\n                return param_name",
        "begin_line": 307,
        "end_line": 317,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.00390625,
            "pseudo_tarantula_susp": 0.012048192771084338,
            "pseudo_op2_susp": 0.00390625,
            "pseudo_barinel_susp": 0.012048192771084338
        }
    },
    {
        "name": "luigi.parameter.Parameter.add_to_cmdline_parser#319",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.add_to_cmdline_parser(self, parser, param_name, task_name, glob=False, is_without_section=False)",
        "snippet": "    def add_to_cmdline_parser(self, parser, param_name, task_name, glob=False, is_without_section=False):\n        dest = self.parser_dest(param_name, task_name, glob, is_without_section=is_without_section)\n        if not dest:\n            return\n        flag = '--' + dest.replace('_', '-')\n\n        description = []\n        description.append('%s.%s' % (task_name, param_name))\n        if glob:\n            description.append('for all instances of class %s' % task_name)\n        elif self.description:\n            description.append(self.description)\n        if self.has_task_value(param_name=param_name, task_name=task_name):\n            value = self.task_value(param_name=param_name, task_name=task_name)\n            description.append(\" [default: %s]\" % (value,))\n\n        if self.is_list:\n            action = \"append\"\n        elif self.is_bool:\n            action = \"store_true\"\n        else:\n            action = \"store\"\n\n        parser.add_argument(flag,\n                            help=' '.join(description),\n                            action=action,\n                            dest=dest)",
        "begin_line": 319,
        "end_line": 345,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.018518518518518517,
            "pseudo_dstar_susp": 0.005434782608695652,
            "pseudo_tarantula_susp": 0.013888888888888888,
            "pseudo_op2_susp": 0.005434782608695652,
            "pseudo_barinel_susp": 0.013888888888888888
        }
    },
    {
        "name": "luigi.parameter.Parameter.parse_from_args#347",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.parse_from_args(self, param_name, task_name, args, params)",
        "snippet": "    def parse_from_args(self, param_name, task_name, args, params):\n        # Note: modifies arguments\n        dest = self.parser_dest(param_name, task_name, glob=False)\n        if dest is not None:\n            value = getattr(args, dest, None)\n            params[param_name] = self.parse_from_input(param_name, value, task_name=task_name)",
        "begin_line": 347,
        "end_line": 352,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035460992907801418,
            "pseudo_dstar_susp": 0.0021598272138228943,
            "pseudo_tarantula_susp": 0.009009009009009009,
            "pseudo_op2_susp": 0.0021598272138228943,
            "pseudo_barinel_susp": 0.009009009009009009
        }
    },
    {
        "name": "luigi.parameter.Parameter.set_global_from_args#354",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.Parameter",
        "signature": "luigi.parameter.Parameter.set_global_from_args(self, param_name, task_name, args, is_without_section=False)",
        "snippet": "    def set_global_from_args(self, param_name, task_name, args, is_without_section=False):\n        # Note: side effects\n        dest = self.parser_dest(param_name, task_name, glob=True, is_without_section=is_without_section)\n        if dest is not None:\n            value = getattr(args, dest, None)\n            if value:\n                self.set_global(self.parse_from_input(param_name, value, task_name=task_name))\n            else:  # either False (bools) or None (everything else)\n                self.reset_global()",
        "begin_line": 354,
        "end_line": 362,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020242914979757085,
            "pseudo_dstar_susp": 0.001890359168241966,
            "pseudo_tarantula_susp": 0.002325581395348837,
            "pseudo_op2_susp": 0.001890359168241966,
            "pseudo_barinel_susp": 0.002325581395348837
        }
    },
    {
        "name": "luigi.parameter.DateParameterBase.serialize#377",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DateParameterBase",
        "signature": "luigi.parameter.DateParameterBase.serialize(self, dt)",
        "snippet": "    def serialize(self, dt):\n        \"\"\"\n        Converts the date to a string using the :py:attr:`~DateParameterBase.date_format`.\n        \"\"\"\n        if dt is None:\n            return str(dt)\n        return dt.strftime(self.date_format)",
        "begin_line": 377,
        "end_line": 383,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029585798816568047,
            "pseudo_dstar_susp": 0.002145922746781116,
            "pseudo_tarantula_susp": 0.00546448087431694,
            "pseudo_op2_susp": 0.002145922746781116,
            "pseudo_barinel_susp": 0.005434782608695652
        }
    },
    {
        "name": "luigi.parameter.DateParameter.parse#396",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DateParameter",
        "signature": "luigi.parameter.DateParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses a date string formatted as ``YYYY-MM-DD``.\n        \"\"\"\n        return datetime.datetime.strptime(s, self.date_format).date()",
        "begin_line": 396,
        "end_line": 400,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0072992700729927005,
            "pseudo_dstar_susp": 0.002197802197802198,
            "pseudo_tarantula_susp": 0.012048192771084338,
            "pseudo_op2_susp": 0.002197802197802198,
            "pseudo_barinel_susp": 0.012048192771084338
        }
    },
    {
        "name": "luigi.parameter.DateHourParameter.parse#437",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DateHourParameter",
        "signature": "luigi.parameter.DateHourParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses a string to a :py:class:`~datetime.datetime` using the format string ``%Y-%m-%dT%H``.\n        \"\"\"\n        return datetime.datetime.strptime(s, self.date_format)",
        "begin_line": 437,
        "end_line": 441,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005208333333333333,
            "pseudo_dstar_susp": 0.002173913043478261,
            "pseudo_tarantula_susp": 0.011235955056179775,
            "pseudo_op2_susp": 0.002173913043478261,
            "pseudo_barinel_susp": 0.011235955056179775
        }
    },
    {
        "name": "luigi.parameter.DateMinuteParameter.parse#456",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DateMinuteParameter",
        "signature": "luigi.parameter.DateMinuteParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        try:\n            value = datetime.datetime.strptime(s, self.deprecated_date_format)\n            warnings.warn(\n                'Using \"H\" between hours and minutes is deprecated, omit it instead.',\n                DeprecationWarning,\n                stacklevel=2\n            )\n            return value\n        except ValueError:\n            return super(DateMinuteParameter, self).parse(s)",
        "begin_line": 456,
        "end_line": 466,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.parameter.IntParameter.parse#474",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.IntParameter",
        "signature": "luigi.parameter.IntParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses an ``int`` from the string using ``int()``.\n        \"\"\"\n        return int(s)",
        "begin_line": 474,
        "end_line": 478,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.002325581395348837,
            "pseudo_tarantula_susp": 0.038461538461538464,
            "pseudo_op2_susp": 0.002325581395348837,
            "pseudo_barinel_susp": 0.038461538461538464
        }
    },
    {
        "name": "luigi.parameter.FloatParameter.parse#486",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.FloatParameter",
        "signature": "luigi.parameter.FloatParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses a ``float`` from the string using ``float()``.\n        \"\"\"\n        return float(s)",
        "begin_line": 486,
        "end_line": 490,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.002325581395348837,
            "pseudo_tarantula_susp": 0.038461538461538464,
            "pseudo_op2_susp": 0.002325581395348837,
            "pseudo_barinel_susp": 0.038461538461538464
        }
    },
    {
        "name": "luigi.parameter.BoolParameter.__init__#498",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.BoolParameter",
        "signature": "luigi.parameter.BoolParameter.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        \"\"\"\n        This constructor passes along args and kwargs to ctor for :py:class:`Parameter` but\n        specifies ``is_bool=True``.\n        \"\"\"\n        super(BoolParameter, self).__init__(*args, is_bool=True, **kwargs)",
        "begin_line": 498,
        "end_line": 503,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.parameter.BoolParameter.parse#505",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.BoolParameter",
        "signature": "luigi.parameter.BoolParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses a ``bool`` from the string, matching 'true' or 'false' ignoring case.\n        \"\"\"\n        return {'true': True, 'false': False}[str(s).lower()]",
        "begin_line": 505,
        "end_line": 509,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.002976190476190476,
            "pseudo_tarantula_susp": 0.038461538461538464,
            "pseudo_op2_susp": 0.002976190476190476,
            "pseudo_barinel_susp": 0.038461538461538464
        }
    },
    {
        "name": "luigi.parameter.DateIntervalParameter.parse#533",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.DateIntervalParameter",
        "signature": "luigi.parameter.DateIntervalParameter.parse(self, s)",
        "snippet": "    def parse(self, s):\n        \"\"\"\n        Parses a `:py:class:`~luigi.date_interval.DateInterval` from the input.\n\n        see :py:mod:`luigi.date_interval`\n          for details on the parsing of DateIntervals.\n        \"\"\"\n        # TODO: can we use xml.utils.iso8601 or something similar?\n\n        from luigi import date_interval as d\n\n        for cls in [d.Year, d.Month, d.Week, d.Date, d.Custom]:\n            i = cls.parse(s)\n            if i:\n                return i\n        else:\n            raise ValueError('Invalid date interval - could not be parsed')",
        "begin_line": 533,
        "end_line": 549,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter._apply_regex#564",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter._apply_regex(self, regex, input)",
        "snippet": "    def _apply_regex(self, regex, input):\n        from datetime import timedelta\n        import re\n        re_match = re.match(regex, input)\n        if re_match:\n            kwargs = {}\n            has_val = False\n            for k, v in six.iteritems(re_match.groupdict(default=\"0\")):\n                val = int(v)\n                has_val = has_val or val != 0\n                kwargs[k] = val\n            if has_val:\n                return timedelta(**kwargs)",
        "begin_line": 564,
        "end_line": 576,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.002325581395348837,
            "pseudo_tarantula_susp": 0.038461538461538464,
            "pseudo_op2_susp": 0.002325581395348837,
            "pseudo_barinel_susp": 0.038461538461538464
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter._parseIso8601#578",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter._parseIso8601(self, input)",
        "snippet": "    def _parseIso8601(self, input):\n        def field(key):\n            return \"(?P<%s>\\d+)%s\" % (key, key[0].upper())\n\n        def optional_field(key):\n            return \"(%s)?\" % field(key)\n        # A little loose: ISO 8601 does not allow weeks in combination with other fields, but this regex does (as does python timedelta)\n        regex = \"P(%s|%s(T%s)?)\" % (field(\"weeks\"), optional_field(\"days\"), \"\".join([optional_field(key) for key in [\"hours\", \"minutes\", \"seconds\"]]))\n        return self._apply_regex(regex, input)",
        "begin_line": 578,
        "end_line": 586,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.002325581395348837,
            "pseudo_tarantula_susp": 0.038461538461538464,
            "pseudo_op2_susp": 0.002325581395348837,
            "pseudo_barinel_susp": 0.038461538461538464
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter.field#579",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter.field(key)",
        "snippet": "        def field(key):\n            return \"(?P<%s>\\d+)%s\" % (key, key[0].upper())",
        "begin_line": 579,
        "end_line": 580,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.002325581395348837,
            "pseudo_tarantula_susp": 0.038461538461538464,
            "pseudo_op2_susp": 0.002325581395348837,
            "pseudo_barinel_susp": 0.038461538461538464
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter.optional_field#582",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter.optional_field(key)",
        "snippet": "        def optional_field(key):\n            return \"(%s)?\" % field(key)",
        "begin_line": 582,
        "end_line": 583,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.002325581395348837,
            "pseudo_tarantula_susp": 0.038461538461538464,
            "pseudo_op2_susp": 0.002325581395348837,
            "pseudo_barinel_susp": 0.038461538461538464
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter._parseSimple#588",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter._parseSimple(self, input)",
        "snippet": "    def _parseSimple(self, input):\n        keys = [\"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\"]\n        # Give the digits a regex group name from the keys, then look for text with the first letter of the key,\n        # optionally followed by the rest of the word, with final char (the \"s\") optional\n        regex = \"\".join([\"((?P<%s>\\d+) ?%s(%s)?(%s)? ?)?\" % (k, k[0], k[1:-1], k[-1]) for k in keys])\n        return self._apply_regex(regex, input)",
        "begin_line": 588,
        "end_line": 593,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.002325581395348837,
            "pseudo_tarantula_susp": 0.038461538461538464,
            "pseudo_op2_susp": 0.002325581395348837,
            "pseudo_barinel_susp": 0.038461538461538464
        }
    },
    {
        "name": "luigi.parameter.TimeDeltaParameter.parse#595",
        "src_path": "luigi/parameter.py",
        "class_name": "luigi.parameter.TimeDeltaParameter",
        "signature": "luigi.parameter.TimeDeltaParameter.parse(self, input)",
        "snippet": "    def parse(self, input):\n        \"\"\"\n        Parses a time delta from the input.\n\n        See :py:class:`TimeDeltaParameter` for details on supported formats.\n        \"\"\"\n        result = self._parseIso8601(input)\n        if not result:\n            result = self._parseSimple(input)\n        if result:\n            return result\n        else:\n            raise ParameterException(\"Invalid time delta - could not parse %s\" % input)",
        "begin_line": 595,
        "end_line": 607,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.002325581395348837,
            "pseudo_tarantula_susp": 0.038461538461538464,
            "pseudo_op2_susp": 0.002325581395348837,
            "pseudo_barinel_susp": 0.038461538461538464
        }
    },
    {
        "name": "luigi.contrib.hdfs.format.CompatibleHdfsFormat.__init__#115",
        "src_path": "luigi/contrib/hdfs/format.py",
        "class_name": "luigi.contrib.hdfs.format.CompatibleHdfsFormat",
        "signature": "luigi.contrib.hdfs.format.CompatibleHdfsFormat.__init__(self, writer, reader, input=None)",
        "snippet": "    def __init__(self, writer, reader, input=None):\n        if input is not None:\n            self.input = input\n\n        self.reader = reader\n        self.writer = writer",
        "begin_line": 115,
        "end_line": 120,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.FileWrapper.__init__#35",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.FileWrapper",
        "signature": "luigi.format.FileWrapper.__init__(self, file_object)",
        "snippet": "    def __init__(self, file_object):\n        self._subpipe = file_object",
        "begin_line": 35,
        "end_line": 36,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00042936882782310007,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.FileWrapper.__getattr__#38",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.FileWrapper",
        "signature": "luigi.format.FileWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        # forward calls to 'write', 'close' and other methods not defined below\n        return getattr(self._subpipe, name)",
        "begin_line": 38,
        "end_line": 40,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004299226139294927,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.FileWrapper.__exit__#49",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.FileWrapper",
        "signature": "luigi.format.FileWrapper.__exit__(self, *args, **kwargs)",
        "snippet": "    def __exit__(self, *args, **kwargs):\n        return self._subpipe.__exit__(*args, **kwargs)",
        "begin_line": 49,
        "end_line": 50,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004775549188156638,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__init__#58",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__init__(self, command, input_pipe=None)",
        "snippet": "    def __init__(self, command, input_pipe=None):\n        \"\"\"\n        Initializes a InputPipeProcessWrapper instance.\n\n        :param command: a subprocess.Popen instance with stdin=input_pipe and\n                        stdout=subprocess.PIPE.\n                        Alternatively, just its args argument as a convenience.\n        \"\"\"\n        self._command = command\n\n        self._input_pipe = input_pipe\n        self._original_input = True\n\n        if input_pipe is not None:\n            try:\n                input_pipe.fileno()\n            except AttributeError:\n                # subprocess require a fileno to work, if not present we copy to disk first\n                self._original_input = False\n                f = tempfile.NamedTemporaryFile('wb', prefix='luigi-process_tmp', delete=False)\n                self._tmp_file = f.name\n                f.write(input_pipe.read())\n                input_pipe.close()\n                f.close()\n                self._input_pipe = FileWrapper(io.BufferedReader(io.FileIO(self._tmp_file, 'r')))\n\n        self._process = command if isinstance(command, subprocess.Popen) else self.create_subprocess(command)\n        # we want to keep a circular reference to avoid garbage collection\n        # when the object is used in, e.g., pipe.read()\n        self._process._selfref = self",
        "begin_line": 58,
        "end_line": 87,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.create_subprocess#89",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.create_subprocess(self, command)",
        "snippet": "    def create_subprocess(self, command):\n        \"\"\"\n        http://www.chiark.greenend.org.uk/ucgi/~cjwatson/blosxom/2009-07-02-python-sigpipe.html\n        \"\"\"\n\n        def subprocess_setup():\n            # Python installs a SIGPIPE handler by default. This is usually not what\n            # non-Python subprocesses expect.\n            signal.signal(signal.SIGPIPE, signal.SIG_DFL)\n\n        return subprocess.Popen(command,\n                                stdin=self._input_pipe,\n                                stdout=subprocess.PIPE,\n                                preexec_fn=subprocess_setup,\n                                close_fds=True)",
        "begin_line": 89,
        "end_line": 103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.subprocess_setup#94",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.subprocess_setup()",
        "snippet": "        def subprocess_setup():\n            # Python installs a SIGPIPE handler by default. This is usually not what\n            # non-Python subprocesses expect.\n            signal.signal(signal.SIGPIPE, signal.SIG_DFL)",
        "begin_line": 94,
        "end_line": 97,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper._finish#105",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper._finish(self)",
        "snippet": "    def _finish(self):\n        # Need to close this before input_pipe to get all SIGPIPE messages correctly\n        self._process.stdout.close()\n        if not self._original_input and os.path.exists(self._tmp_file):\n            os.remove(self._tmp_file)\n\n        if self._input_pipe is not None:\n            self._input_pipe.close()\n\n        self._process.wait()  # deadlock?\n        if self._process.returncode not in (0, 141, 128 - 141):\n            # 141 == 128 + 13 == 128 + SIGPIPE - normally processes exit with 128 + {reiceived SIG}\n            # 128 - 141 == -13 == -SIGPIPE, sometimes python receives -13 for some subprocesses\n            raise RuntimeError('Error reading from pipe. Subcommand exited with non-zero exit status %s.' % self._process.returncode)",
        "begin_line": 105,
        "end_line": 118,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004514672686230248,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.close#120",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.close(self)",
        "snippet": "    def close(self):\n        self._finish()",
        "begin_line": 120,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004775549188156638,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__del__#123",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__del__(self)",
        "snippet": "    def __del__(self):\n        self._finish()",
        "begin_line": 123,
        "end_line": 124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004940711462450593,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__exit__#140",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__exit__(self, type, value, traceback)",
        "snippet": "    def __exit__(self, type, value, traceback):\n        if type:\n            self._abort()\n        else:\n            self._finish()",
        "begin_line": 140,
        "end_line": 144,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004894762604013706,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__getattr__#146",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        if name == '_process':\n            raise AttributeError(name)\n        try:\n            return getattr(self._process.stdout, name)\n        except AttributeError:\n            return getattr(self._input_pipe, name)",
        "begin_line": 146,
        "end_line": 152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.InputPipeProcessWrapper.__iter__#154",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.InputPipeProcessWrapper",
        "signature": "luigi.format.InputPipeProcessWrapper.__iter__(self)",
        "snippet": "    def __iter__(self):\n        for line in self._process.stdout:\n            yield line\n        self._finish()",
        "begin_line": 154,
        "end_line": 157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.__init__#172",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.__init__(self, command, output_pipe=None)",
        "snippet": "    def __init__(self, command, output_pipe=None):\n        self.closed = False\n        self._command = command\n        self._output_pipe = output_pipe\n        self._process = subprocess.Popen(command,\n                                         stdin=subprocess.PIPE,\n                                         stdout=output_pipe,\n                                         close_fds=True)\n        self._flushcount = 0",
        "begin_line": 172,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004655493482309125,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.write#182",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.write(self, *args, **kwargs)",
        "snippet": "    def write(self, *args, **kwargs):\n        self._process.stdin.write(*args, **kwargs)\n        self._flushcount += 1\n        if self._flushcount == self.WRITES_BEFORE_FLUSH:\n            self._process.stdin.flush()\n            self._flushcount = 0",
        "begin_line": 182,
        "end_line": 187,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004655493482309125,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper._finish#193",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper._finish(self)",
        "snippet": "    def _finish(self):\n        \"\"\"\n        Closes and waits for subprocess to exit.\n        \"\"\"\n        if self._process.returncode is None:\n            self._process.stdin.flush()\n            self._process.stdin.close()\n            self._process.wait()\n            self.closed = True",
        "begin_line": 193,
        "end_line": 201,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004633920296570899,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.__del__#203",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.__del__(self)",
        "snippet": "    def __del__(self):\n        if not self.closed:\n            self.abort()",
        "begin_line": 203,
        "end_line": 205,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004655493482309125,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.__exit__#207",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.__exit__(self, type, value, traceback)",
        "snippet": "    def __exit__(self, type, value, traceback):\n        if type is None:\n            self.close()\n        else:\n            self.abort()",
        "begin_line": 207,
        "end_line": 211,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005534034311012728,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.__enter__#213",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.__enter__(self)",
        "snippet": "    def __enter__(self):\n        return self",
        "begin_line": 213,
        "end_line": 214,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005534034311012728,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.close#216",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.close(self)",
        "snippet": "    def close(self):\n        self._finish()\n        if self._process.returncode == 0:\n            if self._output_pipe is not None:\n                self._output_pipe.close()\n        else:\n            raise RuntimeError('Error when executing command %s' % self._command)",
        "begin_line": 216,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004655493482309125,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.__getattr__#227",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        if name == '_process':\n            raise AttributeError(name)\n        try:\n            return getattr(self._process.stdin, name)\n        except AttributeError:\n            return getattr(self._output_pipe, name)",
        "begin_line": 227,
        "end_line": 233,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00048567265662943174,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.readable#235",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.readable(self)",
        "snippet": "    def readable(self):\n        return False",
        "begin_line": 235,
        "end_line": 236,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005361930294906167,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.OutputPipeProcessWrapper.seekable#241",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.OutputPipeProcessWrapper",
        "signature": "luigi.format.OutputPipeProcessWrapper.seekable(self)",
        "snippet": "    def seekable(self):\n        return False",
        "begin_line": 241,
        "end_line": 242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005361930294906167,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.BaseWrapper.__init__#247",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.BaseWrapper",
        "signature": "luigi.format.BaseWrapper.__init__(self, stream, *args, **kwargs)",
        "snippet": "    def __init__(self, stream, *args, **kwargs):\n        self._stream = stream\n        try:\n            super(BaseWrapper, self).__init__(stream, *args, **kwargs)\n        except TypeError:\n            pass",
        "begin_line": 247,
        "end_line": 252,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.BaseWrapper.__enter__#259",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.BaseWrapper",
        "signature": "luigi.format.BaseWrapper.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self._stream.__enter__()\n        return self",
        "begin_line": 259,
        "end_line": 261,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.BaseWrapper.__exit__#263",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.BaseWrapper",
        "signature": "luigi.format.BaseWrapper.__exit__(self, *args)",
        "snippet": "    def __exit__(self, *args):\n        self._stream.__exit__(*args)",
        "begin_line": 263,
        "end_line": 264,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.NewlineWrapper.__init__#276",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.NewlineWrapper",
        "signature": "luigi.format.NewlineWrapper.__init__(self, stream, newline=None)",
        "snippet": "    def __init__(self, stream, newline=None):\n        if newline is None:\n            self.newline = newline\n        else:\n            self.newline = newline.encode('ascii')\n\n        if self.newline not in (b'', b'\\r\\n', b'\\n', b'\\r', None):\n            raise ValueError(\"newline need to be one of {b'', b'\\r\\n', b'\\n', b'\\r', None}\")\n        super(NewlineWrapper, self).__init__(stream)",
        "begin_line": 276,
        "end_line": 284,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.NewlineWrapper.read#286",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.NewlineWrapper",
        "signature": "luigi.format.NewlineWrapper.read(self, n=-1)",
        "snippet": "    def read(self, n=-1):\n        b = self._stream.read(n)\n\n        if self.newline == b'':\n            return b\n\n        if self.newline is None:\n            newline = b'\\n'\n\n        return re.sub(b'(\\n|\\r\\n|\\r)', newline, b)",
        "begin_line": 286,
        "end_line": 295,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.NewlineWrapper.write#307",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.NewlineWrapper",
        "signature": "luigi.format.NewlineWrapper.write(self, b)",
        "snippet": "    def write(self, b):\n        if self.newline is None or self.newline == '':\n            newline = os.linesep.encode('ascii')\n        else:\n            newline = self.newline\n\n        self._stream.write(re.sub(b'(\\n|\\r\\n|\\r)', newline, b))",
        "begin_line": 307,
        "end_line": 313,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.Format.__rshift__#352",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.Format",
        "signature": "luigi.format.Format.__rshift__(a, b)",
        "snippet": "    def __rshift__(a, b):\n        return ChainFormat(a, b)",
        "begin_line": 352,
        "end_line": 353,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.ChainFormat.__init__#358",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.ChainFormat",
        "signature": "luigi.format.ChainFormat.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        self.args = args\n        try:\n            self.input = args[0].input\n        except AttributeError:\n            pass\n        try:\n            self.output = args[-1].output\n        except AttributeError:\n            pass\n        if not kwargs.get('check_consistency', True):\n            return\n        for x in range(len(args) - 1):\n            try:\n                if args[x].output != args[x + 1].input:\n                    raise TypeError(\n                        'The format chaining is not valid, %s expect %s'\n                        'but %s provide %s' % (\n                            args[x].__class__.__name__,\n                            args[x].input,\n                            args[x + 1].__class__.__name__,\n                            args[x + 1].output,\n                        )\n                    )\n            except AttributeError:\n                pass",
        "begin_line": 358,
        "end_line": 383,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.ChainFormat.pipe_reader#385",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.ChainFormat",
        "signature": "luigi.format.ChainFormat.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        for x in reversed(self.args):\n            input_pipe = x.pipe_reader(input_pipe)\n        return input_pipe",
        "begin_line": 385,
        "end_line": 388,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.ChainFormat.pipe_writer#390",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.ChainFormat",
        "signature": "luigi.format.ChainFormat.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        for x in reversed(self.args):\n            output_pipe = x.pipe_writer(output_pipe)\n        return output_pipe",
        "begin_line": 390,
        "end_line": 393,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.TextWrapper.__exit__#398",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.TextWrapper",
        "signature": "luigi.format.TextWrapper.__exit__(self, *args)",
        "snippet": "    def __exit__(self, *args):\n        # io.TextIOWrapper close the file on __exit__, let the underlying file decide\n        if not self.closed and self.writable():\n            super(TextWrapper, self).flush()\n\n        self._stream.__exit__(*args)",
        "begin_line": 398,
        "end_line": 403,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.TextWrapper.__del__#405",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.TextWrapper",
        "signature": "luigi.format.TextWrapper.__del__(self, *args)",
        "snippet": "    def __del__(self, *args):\n        # io.TextIOWrapper close the file on __del__, let the underlying file decide\n        if not self.closed and self.writable():\n            super(TextWrapper, self).flush()\n\n        try:\n            self._stream.__del__(*args)\n        except AttributeError:\n            pass",
        "begin_line": 405,
        "end_line": 413,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004424778761061947,
            "pseudo_dstar_susp": 0.003215434083601286,
            "pseudo_tarantula_susp": 0.005780346820809248,
            "pseudo_op2_susp": 0.003215434083601286,
            "pseudo_barinel_susp": 0.005780346820809248
        }
    },
    {
        "name": "luigi.format.TextWrapper.__init__#415",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.TextWrapper",
        "signature": "luigi.format.TextWrapper.__init__(self, stream, *args, **kwargs)",
        "snippet": "    def __init__(self, stream, *args, **kwargs):\n        self._stream = stream\n        try:\n            super(TextWrapper, self).__init__(stream, *args, **kwargs)\n        except TypeError:\n            pass",
        "begin_line": 415,
        "end_line": 420,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005361930294906167,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.TextWrapper.__getattr__#422",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.TextWrapper",
        "signature": "luigi.format.TextWrapper.__getattr__(self, name)",
        "snippet": "    def __getattr__(self, name):\n        if name == '_stream':\n            raise AttributeError(name)\n        return getattr(self._stream, name)",
        "begin_line": 422,
        "end_line": 425,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005361930294906167,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.TextWrapper.__enter__#427",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.TextWrapper",
        "signature": "luigi.format.TextWrapper.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self._stream.__enter__()\n        return self",
        "begin_line": 427,
        "end_line": 429,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.NopFormat.pipe_reader#433",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.NopFormat",
        "signature": "luigi.format.NopFormat.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        return input_pipe",
        "begin_line": 433,
        "end_line": 434,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.NopFormat.pipe_writer#436",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.NopFormat",
        "signature": "luigi.format.NopFormat.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        return output_pipe",
        "begin_line": 436,
        "end_line": 437,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.WrappedFormat.__init__#442",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.WrappedFormat",
        "signature": "luigi.format.WrappedFormat.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        self.args = args\n        self.kwargs = kwargs",
        "begin_line": 442,
        "end_line": 444,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.WrappedFormat.pipe_reader#446",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.WrappedFormat",
        "signature": "luigi.format.WrappedFormat.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        return self.wrapper_cls(input_pipe, *self.args, **self.kwargs)",
        "begin_line": 446,
        "end_line": 447,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.WrappedFormat.pipe_writer#449",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.WrappedFormat",
        "signature": "luigi.format.WrappedFormat.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        return self.wrapper_cls(output_pipe, *self.args, **self.kwargs)",
        "begin_line": 449,
        "end_line": 450,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004940711462450593,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.GzipFormat.pipe_reader#481",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.GzipFormat",
        "signature": "luigi.format.GzipFormat.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        return InputPipeProcessWrapper(['gunzip'], input_pipe)",
        "begin_line": 481,
        "end_line": 482,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.GzipFormat.pipe_writer#484",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.GzipFormat",
        "signature": "luigi.format.GzipFormat.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        args = ['gzip']\n        if self.compression_level is not None:\n            args.append('-' + str(int(self.compression_level)))\n        return OutputPipeProcessWrapper(args, output_pipe)",
        "begin_line": 484,
        "end_line": 488,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.Bzip2Format.pipe_reader#496",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.Bzip2Format",
        "signature": "luigi.format.Bzip2Format.pipe_reader(self, input_pipe)",
        "snippet": "    def pipe_reader(self, input_pipe):\n        return InputPipeProcessWrapper(['bzcat'], input_pipe)",
        "begin_line": 496,
        "end_line": 497,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.Bzip2Format.pipe_writer#499",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format.Bzip2Format",
        "signature": "luigi.format.Bzip2Format.pipe_writer(self, output_pipe)",
        "snippet": "    def pipe_writer(self, output_pipe):\n        return OutputPipeProcessWrapper(['bzip2'], output_pipe)",
        "begin_line": 499,
        "end_line": 500,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.format.get_default_format#511",
        "src_path": "luigi/format.py",
        "class_name": "luigi.format",
        "signature": "luigi.format.get_default_format()",
        "snippet": "def get_default_format():\n    if six.PY3:\n        return Text\n    elif os.linesep == '\\n':\n        return Nop\n    else:\n        return SysNewLine",
        "begin_line": 511,
        "end_line": 517,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004775549188156638,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_home#44",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_home(self)",
        "snippet": "    def pig_home(self):\n        return configuration.get_config().get('pig', 'home', '/usr/share/pig')",
        "begin_line": 44,
        "end_line": 45,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_command_path#47",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_command_path(self)",
        "snippet": "    def pig_command_path(self):\n        return os.path.join(self.pig_home(), \"bin/pig\")",
        "begin_line": 47,
        "end_line": 48,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_env_vars#50",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_env_vars(self)",
        "snippet": "    def pig_env_vars(self):\n        \"\"\"\n        Dictionary of environment variables that should be set when running Pig.\n\n        Ex::\n            return { 'PIG_CLASSPATH': '/your/path' }\n        \"\"\"\n        return {}",
        "begin_line": 50,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_properties#59",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_properties(self)",
        "snippet": "    def pig_properties(self):\n        \"\"\"\n        Dictionary of properties that should be set when running Pig.\n\n        Example::\n\n            return { 'pig.additional.jars':'/path/to/your/jar' }\n        \"\"\"\n        return {}",
        "begin_line": 59,
        "end_line": 67,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.pig_parameters#69",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.pig_parameters(self)",
        "snippet": "    def pig_parameters(self):\n        \"\"\"\n        Dictionary of parameters that should be set for the Pig job.\n\n        Example::\n\n            return { 'YOUR_PARAM_NAME':'Your param value' }\n        \"\"\"\n        return {}",
        "begin_line": 69,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask._build_pig_cmd#98",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask._build_pig_cmd(self)",
        "snippet": "    def _build_pig_cmd(self):\n        opts = self.pig_options()\n\n        for k, v in six.iteritems(self.pig_parameters()):\n            opts.append(\"-p\")\n            opts.append(\"%s=%s\" % (k, v))\n\n        if self.pig_properties():\n            with open('pig_property_file', 'w') as prop_file:\n                prop_file.writelines([\"%s=%s%s\" % (k, v, os.linesep) for (k, v) in six.iteritems(self.pig_properties())])\n            opts.append('-propertyFile')\n            opts.append('pig_property_file')\n\n        cmd = [self.pig_command_path()] + opts + [\"-f\", self.pig_script_path()]\n\n        logger.info(' '.join(cmd))\n        return cmd",
        "begin_line": 98,
        "end_line": 114,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.run#116",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.run(self)",
        "snippet": "    def run(self):\n        cmd = self._build_pig_cmd()\n        self.track_and_progress(cmd)",
        "begin_line": 116,
        "end_line": 118,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobTask.track_and_progress#120",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobTask",
        "signature": "luigi.contrib.pig.PigJobTask.track_and_progress(self, cmd)",
        "snippet": "    def track_and_progress(self, cmd):\n        temp_stdout = tempfile.TemporaryFile()\n        env = os.environ.copy()\n        env['PIG_HOME'] = self.pig_home()\n        for k, v in six.iteritems(self.pig_env_vars()):\n            env[k] = v\n\n        proc = subprocess.Popen(cmd, shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)\n        reads = [proc.stderr.fileno(), proc.stdout.fileno()]\n        # tracking the possible problems with this job\n        err_lines = []\n        with PigRunContext():\n            while proc.poll() is None:\n                ret = select.select(reads, [], [])\n                for fd in ret[0]:\n                    if fd == proc.stderr.fileno():\n                        line = proc.stderr.readline().decode('utf8')\n                        err_lines.append(line)\n                    if fd == proc.stdout.fileno():\n                        line = proc.stdout.readline().decode('utf8')\n                        temp_stdout.write(line)\n\n                err_line = line.lower()\n                if err_line.find('More information at:') != -1:\n                    logger.info(err_line.split('more information at: ')[-1].strip())\n                if err_line.find(' - '):\n                    t = err_line.split(' - ')[-1].strip()\n                    if t != \"\":\n                        logger.info(t)\n\n        # Read the rest + stdout\n        err = ''.join(err_lines + [err_line.decode('utf8') for err_line in proc.stderr])\n        if proc.returncode == 0:\n            logger.info(\"Job completed successfully!\")\n        else:\n            logger.error(\"Error when running script:\\n%s\", self.pig_script_path())\n            logger.error(err)\n            raise PigJobError(\"Pig script failed with return value: %s\" % (proc.returncode,), err=err)",
        "begin_line": 120,
        "end_line": 157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.pig.PigRunContext.__init__#161",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigRunContext",
        "signature": "luigi.contrib.pig.PigRunContext.__init__(self)",
        "snippet": "    def __init__(self):\n        self.job_id = None",
        "begin_line": 161,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.pig.PigRunContext.__enter__#164",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigRunContext",
        "signature": "luigi.contrib.pig.PigRunContext.__enter__(self)",
        "snippet": "    def __enter__(self):\n        self.__old_signal = signal.getsignal(signal.SIGTERM)\n        signal.signal(signal.SIGTERM, self.kill_job)\n        return self",
        "begin_line": 164,
        "end_line": 167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.pig.PigRunContext.__exit__#177",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigRunContext",
        "signature": "luigi.contrib.pig.PigRunContext.__exit__(self, exc_type, exc_val, exc_tb)",
        "snippet": "    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is KeyboardInterrupt:\n            self.kill_job()\n        signal.signal(signal.SIGTERM, self.__old_signal)",
        "begin_line": 177,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.pig.PigJobError.__init__#184",
        "src_path": "luigi/contrib/pig.py",
        "class_name": "luigi.contrib.pig.PigJobError",
        "signature": "luigi.contrib.pig.PigJobError.__init__(self, message, out=None, err=None)",
        "snippet": "    def __init__(self, message, out=None, err=None):\n        super(PigJobError, self).__init__(message, out, err)\n        self.message = message\n        self.out = out\n        self.err = err",
        "begin_line": 184,
        "end_line": 188,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.do_truncate_table#113",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.do_truncate_table(self)",
        "snippet": "    def do_truncate_table(self):\n        \"\"\"\n        Return True if table should be truncated before copying new data in.\n        \"\"\"\n        return False",
        "begin_line": 113,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.run#158",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.run(self)",
        "snippet": "    def run(self):\n        \"\"\"\n        If the target table doesn't exist, self.create_table\n        will be called to attempt to create the table.\n        \"\"\"\n        if not (self.table):\n            raise Exception(\"table need to be specified\")\n\n        path = self.s3_load_path()\n        connection = self.output().connect()\n        if not self.does_table_exist(connection):\n            # try creating table\n            logger.info(\"Creating table %s\", self.table)\n            connection.reset()\n            self.create_table(connection)\n        elif self.do_truncate_table():\n            logger.info(\"Truncating table %s\", self.table)\n            self.truncate_table(connection)\n\n        logger.info(\"Inserting file: %s\", path)\n        cursor = connection.cursor()\n        self.init_copy(connection)\n        self.copy(cursor, path)\n        self.output().touch(connection)\n        connection.commit()\n\n        # commit and clean up\n        connection.close()",
        "begin_line": 158,
        "end_line": 185,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.output#201",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.output(self)",
        "snippet": "    def output(self):\n        \"\"\"\n        Returns a RedshiftTarget representing the inserted dataset.\n\n        Normally you don't override this.\n        \"\"\"\n        return RedshiftTarget(\n            host=self.host,\n            database=self.database,\n            user=self.user,\n            password=self.password,\n            table=self.table,\n            update_id=self.update_id())",
        "begin_line": 201,
        "end_line": 213,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.redshift.S3CopyToTable.does_table_exist#215",
        "src_path": "luigi/contrib/redshift.py",
        "class_name": "luigi.contrib.redshift.S3CopyToTable",
        "signature": "luigi.contrib.redshift.S3CopyToTable.does_table_exist(self, connection)",
        "snippet": "    def does_table_exist(self, connection):\n        \"\"\"\n        Determine whether the table already exists.\n        \"\"\"\n\n        if '.' in self.table:\n            query = (\"select 1 as table_exists \"\n                     \"from information_schema.tables \"\n                     \"where table_schema = %s and table_name = %s limit 1\")\n        else:\n            query = (\"select 1 as table_exists \"\n                     \"from pg_table_def \"\n                     \"where tablename = %s limit 1\")\n        cursor = connection.cursor()\n        try:\n            cursor.execute(query, tuple(self.table.split('.')))\n            result = cursor.fetchone()\n            return bool(result)\n        finally:\n            cursor.close()",
        "begin_line": 215,
        "end_line": 234,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandError.__init__#40",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandError",
        "signature": "luigi.contrib.hive.HiveCommandError.__init__(self, message, out=None, err=None)",
        "snippet": "    def __init__(self, message, out=None, err=None):\n        super(HiveCommandError, self).__init__(message, out, err)\n        self.message = message\n        self.out = out\n        self.err = err",
        "begin_line": 40,
        "end_line": 44,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.run_hive#55",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.run_hive(args, check_return_code=True)",
        "snippet": "def run_hive(args, check_return_code=True):\n    \"\"\"\n    Runs the `hive` from the command line, passing in the given args, and\n    returning stdout.\n\n    With the apache release of Hive, so of the table existence checks\n    (which are done using DESCRIBE do not exit with a return code of 0\n    so we need an option to ignore the return code and just return stdout for parsing\n    \"\"\"\n    cmd = [load_hive_cmd()] + args\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    stdout, stderr = p.communicate()\n    if check_return_code and p.returncode != 0:\n        raise HiveCommandError(\"Hive command: {0} failed with error code: {1}\".format(\" \".join(cmd), p.returncode),\n                               stdout, stderr)\n    return stdout",
        "begin_line": 55,
        "end_line": 70,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.run_hive_cmd#73",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.run_hive_cmd(hivecmd, check_return_code=True)",
        "snippet": "def run_hive_cmd(hivecmd, check_return_code=True):\n    \"\"\"\n    Runs the given hive query and returns stdout.\n    \"\"\"\n    return run_hive(['-e', hivecmd], check_return_code)",
        "begin_line": 73,
        "end_line": 77,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.run_hive_script#80",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.run_hive_script(script)",
        "snippet": "def run_hive_script(script):\n    \"\"\"\n    Runs the contents of the given script in hive and returns stdout.\n    \"\"\"\n    if not os.path.isfile(script):\n        raise RuntimeError(\"Hive script: {0} does not exist.\".format(script))\n    return run_hive(['-f', script])",
        "begin_line": 80,
        "end_line": 86,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandClient.table_location#126",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandClient",
        "signature": "luigi.contrib.hive.HiveCommandClient.table_location(self, table, database='default', partition=None)",
        "snippet": "    def table_location(self, table, database='default', partition=None):\n        cmd = \"use {0}; describe formatted {1}\".format(database, table)\n        if partition is not None:\n            cmd += \" PARTITION ({0})\".format(self.partition_spec(partition))\n\n        stdout = run_hive_cmd(cmd)\n\n        for line in stdout.split(\"\\n\"):\n            if \"Location:\" in line:\n                return line.split(\"\\t\")[1]",
        "begin_line": 126,
        "end_line": 135,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandClient.table_exists#137",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandClient",
        "signature": "luigi.contrib.hive.HiveCommandClient.table_exists(self, table, database='default', partition=None)",
        "snippet": "    def table_exists(self, table, database='default', partition=None):\n        if partition is None:\n            stdout = run_hive_cmd('use {0}; show tables like \"{1}\";'.format(database, table))\n\n            return stdout and table.lower() in stdout\n        else:\n            stdout = run_hive_cmd(\"\"\"use %s; show partitions %s partition\n                                (%s)\"\"\" % (database, table, self.partition_spec(partition)))\n\n            if stdout:\n                return True\n            else:\n                return False",
        "begin_line": 137,
        "end_line": 149,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandClient.table_schema#151",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandClient",
        "signature": "luigi.contrib.hive.HiveCommandClient.table_schema(self, table, database='default')",
        "snippet": "    def table_schema(self, table, database='default'):\n        describe = run_hive_cmd(\"use {0}; describe {1}\".format(database, table))\n        if not describe or \"does not exist\" in describe:\n            return None\n        return [tuple([x.strip() for x in line.strip().split(\"\\t\")]) for line in describe.strip().split(\"\\n\")]",
        "begin_line": 151,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.HiveCommandClient.partition_spec#157",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveCommandClient",
        "signature": "luigi.contrib.hive.HiveCommandClient.partition_spec(self, partition)",
        "snippet": "    def partition_spec(self, partition):\n        \"\"\"\n        Turns a dict into the a Hive partition specification string.\n        \"\"\"\n        return ','.join([\"`{0}`='{1}'\".format(k, v) for (k, v) in\n                         sorted(six.iteritems(partition), key=operator.itemgetter(0))])",
        "begin_line": 157,
        "end_line": 162,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.ApacheHiveCommandClient.table_schema#171",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.ApacheHiveCommandClient",
        "signature": "luigi.contrib.hive.ApacheHiveCommandClient.table_schema(self, table, database='default')",
        "snippet": "    def table_schema(self, table, database='default'):\n        describe = run_hive_cmd(\"use {0}; describe {1}\".format(database, table), False)\n        if not describe or \"Table not found\" in describe:\n            return None\n        return [tuple([x.strip() for x in line.strip().split(\"\\t\")]) for line in describe.strip().split(\"\\n\")]",
        "begin_line": 171,
        "end_line": 175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006031363088057901,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.MetastoreClient.table_exists#189",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.MetastoreClient",
        "signature": "luigi.contrib.hive.MetastoreClient.table_exists(self, table, database='default', partition=None)",
        "snippet": "    def table_exists(self, table, database='default', partition=None):\n        with HiveThriftContext() as client:\n            if partition is None:\n                return table in client.get_all_tables(database)\n            else:\n                return partition in self._existing_partitions(table, database, client)",
        "begin_line": 189,
        "end_line": 194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000630119722747322,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.MetastoreClient._existing_partitions#196",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.MetastoreClient",
        "signature": "luigi.contrib.hive.MetastoreClient._existing_partitions(self, table, database, client)",
        "snippet": "    def _existing_partitions(self, table, database, client):\n        def _parse_partition_string(partition_string):\n            partition_def = {}\n            for part in partition_string.split(\"/\"):\n                name, value = part.split(\"=\")\n                partition_def[name] = value\n            return partition_def\n\n        # -1 is max_parts, the # of partition names to return (-1 = unlimited)\n        partition_strings = client.get_partition_names(database, table, -1)\n        return [_parse_partition_string(existing_partition) for existing_partition in partition_strings]",
        "begin_line": 196,
        "end_line": 206,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.MetastoreClient._parse_partition_string#197",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.MetastoreClient",
        "signature": "luigi.contrib.hive.MetastoreClient._parse_partition_string(partition_string)",
        "snippet": "        def _parse_partition_string(partition_string):\n            partition_def = {}\n            for part in partition_string.split(\"/\"):\n                name, value = part.split(\"=\")\n                partition_def[name] = value\n            return partition_def",
        "begin_line": 197,
        "end_line": 202,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.get_default_client#247",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive",
        "signature": "luigi.contrib.hive.get_default_client()",
        "snippet": "def get_default_client():\n    if get_hive_syntax() == \"apache\":\n        return ApacheHiveCommandClient()\n    else:\n        return HiveCommandClient()",
        "begin_line": 247,
        "end_line": 251,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryTask.hiverc#272",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryTask",
        "signature": "luigi.contrib.hive.HiveQueryTask.hiverc(self)",
        "snippet": "    def hiverc(self):\n        \"\"\"\n        Location of an rc file to run before the query\n        if hiverc-location key is specified in luigi.cfg, will default to the value there\n        otherwise returns None.\n\n        Returning a list of rc files will load all of them in order.\n        \"\"\"\n        return luigi.configuration.get_config().get('hive', 'hiverc-location', default=None)",
        "begin_line": 272,
        "end_line": 280,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryTask.hiveconfs#282",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryTask",
        "signature": "luigi.contrib.hive.HiveQueryTask.hiveconfs(self)",
        "snippet": "    def hiveconfs(self):\n        \"\"\"\n        Returns an dict of key=value settings to be passed along\n        to the hive command line via --hiveconf. By default, sets\n        mapred.job.name to task_id and if not None, sets:\n\n        * mapred.reduce.tasks (n_reduce_tasks)\n        * mapred.fairscheduler.pool (pool) or mapred.job.queue.name (pool)\n        * hive.exec.reducers.bytes.per.reducer (bytes_per_reducer)\n        * hive.exec.reducers.max (reducers_max)\n        \"\"\"\n        jcs = {}\n        jcs['mapred.job.name'] = self.task_id\n        if self.n_reduce_tasks is not None:\n            jcs['mapred.reduce.tasks'] = self.n_reduce_tasks\n        if self.pool is not None:\n            # Supporting two schedulers: fair (default) and capacity using the same option\n            scheduler_type = luigi.configuration.get_config().get('hadoop', 'scheduler', 'fair')\n            if scheduler_type == 'fair':\n                jcs['mapred.fairscheduler.pool'] = self.pool\n            elif scheduler_type == 'capacity':\n                jcs['mapred.job.queue.name'] = self.pool\n        if self.bytes_per_reducer is not None:\n            jcs['hive.exec.reducers.bytes.per.reducer'] = self.bytes_per_reducer\n        if self.reducers_max is not None:\n            jcs['hive.exec.reducers.max'] = self.reducers_max\n        return jcs",
        "begin_line": 282,
        "end_line": 308,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryTask.job_runner#310",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryTask",
        "signature": "luigi.contrib.hive.HiveQueryTask.job_runner(self)",
        "snippet": "    def job_runner(self):\n        return HiveQueryRunner()",
        "begin_line": 310,
        "end_line": 311,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryRunner.prepare_outputs#319",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryRunner",
        "signature": "luigi.contrib.hive.HiveQueryRunner.prepare_outputs(self, job)",
        "snippet": "    def prepare_outputs(self, job):\n        \"\"\"\n        Called before job is started.\n\n        If output is a `FileSystemTarget`, create parent directories so the hive command won't fail\n        \"\"\"\n        outputs = flatten(job.output())\n        for o in outputs:\n            if isinstance(o, FileSystemTarget):\n                parent_dir = os.path.dirname(o.path)\n                if parent_dir and not o.fs.exists(parent_dir):\n                    logger.info(\"Creating parent directory %r\", parent_dir)\n                    try:\n                        # there is a possible race condition\n                        # which needs to be handled here\n                        o.fs.mkdir(parent_dir)\n                    except FileAlreadyExists:\n                        pass",
        "begin_line": 319,
        "end_line": 336,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.HiveQueryRunner.run_job#338",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveQueryRunner",
        "signature": "luigi.contrib.hive.HiveQueryRunner.run_job(self, job)",
        "snippet": "    def run_job(self, job):\n        self.prepare_outputs(job)\n        with tempfile.NamedTemporaryFile() as f:\n            query = job.query()\n            if isinstance(query, unicode):\n                query = query.encode('utf8')\n            f.write(query)\n            f.flush()\n            arglist = [load_hive_cmd(), '-f', f.name]\n            hiverc = job.hiverc()\n            if hiverc:\n                if isinstance(hiverc, str):\n                    hiverc = [hiverc]\n                for rcfile in hiverc:\n                    arglist += ['-i', rcfile]\n            if job.hiveconfs():\n                for k, v in six.iteritems(job.hiveconfs()):\n                    arglist += ['--hiveconf', '{0}={1}'.format(k, v)]\n\n            logger.info(arglist)\n            return luigi.contrib.hadoop.run_and_track_hadoop_job(arglist)",
        "begin_line": 338,
        "end_line": 358,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.HiveTableTarget.__init__#366",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveTableTarget",
        "signature": "luigi.contrib.hive.HiveTableTarget.__init__(self, table, database='default', client=None)",
        "snippet": "    def __init__(self, table, database='default', client=None):\n        self.database = database\n        self.table = table\n        self.hive_cmd = load_hive_cmd()\n        if client is None:\n            client = get_default_client()\n        self.client = client",
        "begin_line": 366,
        "end_line": 372,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.HiveTableTarget.exists#374",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HiveTableTarget",
        "signature": "luigi.contrib.hive.HiveTableTarget.exists(self)",
        "snippet": "    def exists(self):\n        logger.debug(\"Checking Hive table '%s.%s' exists\", self.database, self.table)\n        return self.client.table_exists(self.table, self.database)",
        "begin_line": 374,
        "end_line": 376,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hive.HivePartitionTarget.__init__#397",
        "src_path": "luigi/contrib/hive.py",
        "class_name": "luigi.contrib.hive.HivePartitionTarget",
        "signature": "luigi.contrib.hive.HivePartitionTarget.__init__(self, table, partition, database='default', fail_missing_table=True, client=None)",
        "snippet": "    def __init__(self, table, partition, database='default', fail_missing_table=True, client=None):\n        self.database = database\n        self.table = table\n        self.partition = partition\n        if client is None:\n            client = get_default_client()\n        self.client = client\n\n        self.fail_missing_table = fail_missing_table",
        "begin_line": 397,
        "end_line": 405,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.instance#53",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.instance(cls, *args, **kwargs)",
        "snippet": "    def instance(cls, *args, **kwargs):\n        \"\"\" Singleton getter \"\"\"\n        if cls._instance is None:\n            cls._instance = cls(*args, **kwargs)\n            loaded = cls._instance.reload()\n            logging.getLogger('luigi-interface').info('Loaded %r', loaded)\n\n        return cls._instance",
        "begin_line": 53,
        "end_line": 60,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005319148936170213,
            "pseudo_dstar_susp": 0.015873015873015872,
            "pseudo_tarantula_susp": 0.00303951367781155,
            "pseudo_op2_susp": 0.015873015873015872,
            "pseudo_barinel_susp": 0.00303951367781155
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser._get_with_default#66",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser._get_with_default(self, method, section, option, default, expected_type=None, **kwargs)",
        "snippet": "    def _get_with_default(self, method, section, option, default, expected_type=None, **kwargs):\n        \"\"\"\n        Gets the value of the section/option using method.\n\n        Returns default if value is not found.\n\n        Raises an exception if the default value is not None and doesn't match the expected_type.\n        \"\"\"\n        try:\n            return method(self, section, option, **kwargs)\n        except (NoOptionError, NoSectionError):\n            if default is LuigiConfigParser.NO_DEFAULT:\n                raise\n            if expected_type is not None and default is not None and \\\n               not isinstance(default, expected_type):\n                raise\n            return default",
        "begin_line": 66,
        "end_line": 82,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009523809523809525,
            "pseudo_dstar_susp": 0.020833333333333332,
            "pseudo_tarantula_susp": 0.008771929824561403,
            "pseudo_op2_susp": 0.02040816326530612,
            "pseudo_barinel_susp": 0.009009009009009009
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.get#84",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.get(self, section, option, default=NO_DEFAULT, **kwargs)",
        "snippet": "    def get(self, section, option, default=NO_DEFAULT, **kwargs):\n        return self._get_with_default(ConfigParser.get, section, option, default, **kwargs)",
        "begin_line": 84,
        "end_line": 85,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.017857142857142856,
            "pseudo_dstar_susp": 0.013513513513513514,
            "pseudo_tarantula_susp": 0.01,
            "pseudo_op2_susp": 0.013513513513513514,
            "pseudo_barinel_susp": 0.01
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.getboolean#87",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.getboolean(self, section, option, default=NO_DEFAULT)",
        "snippet": "    def getboolean(self, section, option, default=NO_DEFAULT):\n        return self._get_with_default(ConfigParser.getboolean, section, option, default, bool)",
        "begin_line": 87,
        "end_line": 88,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001567398119122257,
            "pseudo_dstar_susp": 0.001567398119122257,
            "pseudo_tarantula_susp": 0.0015772870662460567,
            "pseudo_op2_susp": 0.001567398119122257,
            "pseudo_barinel_susp": 0.0015772870662460567
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.getfloat#93",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.getfloat(self, section, option, default=NO_DEFAULT)",
        "snippet": "    def getfloat(self, section, option, default=NO_DEFAULT):\n        return self._get_with_default(ConfigParser.getfloat, section, option, default, float)",
        "begin_line": 93,
        "end_line": 94,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.getintdict#96",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.getintdict(self, section)",
        "snippet": "    def getintdict(self, section):\n        try:\n            return dict((key, int(value)) for key, value in self.items(section))\n        except NoSectionError:\n            return {}",
        "begin_line": 96,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020161290322580645,
            "pseudo_dstar_susp": 0.002652519893899204,
            "pseudo_tarantula_susp": 0.00196078431372549,
            "pseudo_op2_susp": 0.002652519893899204,
            "pseudo_barinel_susp": 0.00196078431372549
        }
    },
    {
        "name": "luigi.configuration.LuigiConfigParser.set#102",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration.LuigiConfigParser",
        "signature": "luigi.configuration.LuigiConfigParser.set(self, section, option, value=None)",
        "snippet": "    def set(self, section, option, value=None):\n        if not ConfigParser.has_section(self, section):\n            ConfigParser.add_section(self, section)\n\n        return ConfigParser.set(self, section, option, value)",
        "begin_line": 102,
        "end_line": 106,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008264462809917356,
            "pseudo_dstar_susp": 0.011764705882352941,
            "pseudo_tarantula_susp": 0.004694835680751174,
            "pseudo_op2_susp": 0.011764705882352941,
            "pseudo_barinel_susp": 0.004694835680751174
        }
    },
    {
        "name": "luigi.configuration.get_config#109",
        "src_path": "luigi/configuration.py",
        "class_name": "luigi.configuration",
        "signature": "luigi.configuration.get_config()",
        "snippet": "def get_config():\n    \"\"\"\n    Convenience method (for backwards compatibility) for accessing config singleton.\n    \"\"\"\n    return LuigiConfigParser.instance()",
        "begin_line": 109,
        "end_line": 113,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03571428571428571,
            "pseudo_dstar_susp": 1.0,
            "pseudo_tarantula_susp": 0.005649717514124294,
            "pseudo_op2_susp": 1.0,
            "pseudo_barinel_susp": 0.005649717514124294
        }
    },
    {
        "name": "luigi.task_register.Register.__new__#59",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.__new__(metacls, classname, bases, classdict)",
        "snippet": "    def __new__(metacls, classname, bases, classdict):\n        \"\"\"\n        Custom class creation for namespacing.\n\n        Also register all subclasses.\n\n        Set the task namespace to whatever the currently declared namespace is.\n        \"\"\"\n        if \"task_namespace\" not in classdict:\n            classdict[\"task_namespace\"] = metacls._default_namespace\n\n        cls = super(Register, metacls).__new__(metacls, classname, bases, classdict)\n        metacls._reg.append(cls)\n\n        return cls",
        "begin_line": 59,
        "end_line": 73,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002369668246445498,
            "pseudo_dstar_susp": 0.0028653295128939827,
            "pseudo_tarantula_susp": 0.003246753246753247,
            "pseudo_op2_susp": 0.0028653295128939827,
            "pseudo_barinel_susp": 0.003246753246753247
        }
    },
    {
        "name": "luigi.task_register.Register.__call__#75",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.__call__(cls, *args, **kwargs)",
        "snippet": "    def __call__(cls, *args, **kwargs):\n        \"\"\"\n        Custom class instantiation utilizing instance cache.\n\n        If a Task has already been instantiated with the same parameters,\n        the previous instance is returned to reduce number of object instances.\n        \"\"\"\n        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)\n\n        h = cls.__instance_cache\n\n        if h is None:  # disabled\n            return instantiate()\n\n        params = cls.get_params()\n        param_values = cls.get_param_values(params, args, kwargs)\n\n        k = (cls, tuple(param_values))\n\n        try:\n            hash(k)\n        except TypeError:\n            logger.debug(\"Not all parameter values are hashable so instance isn't coming from the cache\")\n            return instantiate()  # unhashable types in parameters\n\n        if k not in h:\n            h[k] = instantiate()\n\n        return h[k]",
        "begin_line": 75,
        "end_line": 104,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006493506493506494,
            "pseudo_dstar_susp": 0.024390243902439025,
            "pseudo_tarantula_susp": 0.0029411764705882353,
            "pseudo_op2_susp": 0.024390243902439025,
            "pseudo_barinel_susp": 0.0029411764705882353
        }
    },
    {
        "name": "luigi.task_register.Register.instantiate#82",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.instantiate()",
        "snippet": "        def instantiate():\n            return super(Register, cls).__call__(*args, **kwargs)",
        "begin_line": 82,
        "end_line": 83,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006329113924050633,
            "pseudo_dstar_susp": 0.02564102564102564,
            "pseudo_tarantula_susp": 0.0024752475247524753,
            "pseudo_op2_susp": 0.02564102564102564,
            "pseudo_barinel_susp": 0.0024752475247524753
        }
    },
    {
        "name": "luigi.task_register.Register.task_family#121",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.task_family(cls)",
        "snippet": "    def task_family(cls):\n        \"\"\"\n        The task family for the given class.\n\n        If ``cls.task_namespace is None`` then it's the name of the class.\n        Otherwise, ``<task_namespace>.`` is prefixed to the class name.\n        \"\"\"\n        if cls.task_namespace is None:\n            return cls.__name__\n        else:\n            return \"%s.%s\" % (cls.task_namespace, cls.__name__)",
        "begin_line": 121,
        "end_line": 131,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004694835680751174,
            "pseudo_dstar_susp": 0.017241379310344827,
            "pseudo_tarantula_susp": 0.0031645569620253164,
            "pseudo_op2_susp": 0.017241379310344827,
            "pseudo_barinel_susp": 0.0031645569620253164
        }
    },
    {
        "name": "luigi.task_register.Register._get_reg#134",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register._get_reg(cls)",
        "snippet": "    def _get_reg(cls):\n        \"\"\"Return all of the registered classes.\n\n        :return:  an ``collections.OrderedDict`` of task_family -> class\n        \"\"\"\n        # We have to do this on-demand in case task names have changed later\n        # We return this in a topologically sorted list of inheritance: this is useful in some cases (#822)\n        reg = OrderedDict()\n        for cls in cls._reg:\n            name = cls.task_family\n\n            if name in reg and reg[name] != cls and \\\n                    reg[name] != cls.AMBIGUOUS_CLASS and \\\n                    not issubclass(cls, reg[name]):\n                # Registering two different classes - this means we can't instantiate them by name\n                # The only exception is if one class is a subclass of the other. In that case, we\n                # instantiate the most-derived class (this fixes some issues with decorator wrappers).\n                reg[name] = cls.AMBIGUOUS_CLASS\n            else:\n                reg[name] = cls\n\n        return reg",
        "begin_line": 134,
        "end_line": 155,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0037174721189591076,
            "pseudo_dstar_susp": 0.00909090909090909,
            "pseudo_tarantula_susp": 0.0040650406504065045,
            "pseudo_op2_susp": 0.00909090909090909,
            "pseudo_barinel_susp": 0.0040650406504065045
        }
    },
    {
        "name": "luigi.task_register.Register._set_reg#158",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register._set_reg(cls, reg)",
        "snippet": "    def _set_reg(cls, reg):\n        \"\"\"The writing complement of _get_reg\n        \"\"\"\n        cls._reg = [task_cls for task_cls in reg.values() if task_cls is not cls.AMBIGUOUS_CLASS]",
        "begin_line": 158,
        "end_line": 161,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0030303030303030303,
            "pseudo_dstar_susp": 0.006622516556291391,
            "pseudo_tarantula_susp": 0.002421307506053269,
            "pseudo_op2_susp": 0.006622516556291391,
            "pseudo_barinel_susp": 0.002421307506053269
        }
    },
    {
        "name": "luigi.task_register.Register.task_names#164",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.task_names(cls)",
        "snippet": "    def task_names(cls):\n        \"\"\"\n        List of task names as strings\n        \"\"\"\n        return sorted(cls._get_reg().keys())",
        "begin_line": 164,
        "end_line": 168,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0029585798816568047,
            "pseudo_dstar_susp": 0.005025125628140704,
            "pseudo_tarantula_susp": 0.0029239766081871343,
            "pseudo_op2_susp": 0.005025125628140704,
            "pseudo_barinel_susp": 0.0029239766081871343
        }
    },
    {
        "name": "luigi.task_register.Register.get_task_cls#178",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.get_task_cls(cls, name)",
        "snippet": "    def get_task_cls(cls, name):\n        \"\"\"\n        Returns an unambiguous class or raises an exception.\n        \"\"\"\n        task_cls = cls._get_reg().get(name)\n        if not task_cls:\n            raise TaskClassNotFoundException(cls._missing_task_msg(name))\n\n        if task_cls == cls.AMBIGUOUS_CLASS:\n            raise TaskClassAmbigiousException('Task %r is ambiguous' % name)\n        return task_cls",
        "begin_line": 178,
        "end_line": 188,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.00558659217877095,
            "pseudo_dstar_susp": 0.015384615384615385,
            "pseudo_tarantula_susp": 0.00546448087431694,
            "pseudo_op2_susp": 0.015384615384615385,
            "pseudo_barinel_susp": 0.005434782608695652
        }
    },
    {
        "name": "luigi.task_register.Register.get_all_params#191",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register.get_all_params(cls)",
        "snippet": "    def get_all_params(cls):\n        \"\"\"\n        Compiles and returns all parameters for all :py:class:`Task`.\n\n        :return: a generator of tuples (TODO: we should make this more elegant)\n        \"\"\"\n        for task_name, task_cls in six.iteritems(cls._get_reg()):\n            if task_cls == cls.AMBIGUOUS_CLASS:\n                continue\n            for param_name, param_obj in task_cls.get_params():\n                yield task_name, (not task_cls.use_cmdline_section), param_name, param_obj",
        "begin_line": 191,
        "end_line": 201,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003787878787878788,
            "pseudo_dstar_susp": 0.0064516129032258064,
            "pseudo_tarantula_susp": 0.0044444444444444444,
            "pseudo_op2_susp": 0.0064516129032258064,
            "pseudo_barinel_susp": 0.0044444444444444444
        }
    },
    {
        "name": "luigi.task_register.Register._editdistance#204",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register._editdistance(a, b)",
        "snippet": "    def _editdistance(a, b):\n        \"\"\" Simple unweighted Levenshtein distance \"\"\"\n        r0 = range(0, len(b) + 1)\n        r1 = [0] * (len(b) + 1)\n\n        for i in range(0, len(a)):\n            r1[0] = i + 1\n\n            for j in range(0, len(b)):\n                c = 0 if a[i] is b[j] else 1\n                r1[j + 1] = min(r1[j] + 1, r0[j + 1] + 1, r0[j] + c)\n\n            r0 = r1[:]\n\n        return r1[len(b)]",
        "begin_line": 204,
        "end_line": 218,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.task_register.Register._missing_task_msg#221",
        "src_path": "luigi/task_register.py",
        "class_name": "luigi.task_register.Register",
        "signature": "luigi.task_register.Register._missing_task_msg(cls, task_name)",
        "snippet": "    def _missing_task_msg(cls, task_name):\n        weighted_tasks = [(Register._editdistance(task_name, task_name_2), task_name_2) for task_name_2 in cls.task_names()]\n        ordered_tasks = sorted(weighted_tasks, key=lambda pair: pair[0])\n        candidates = [task for (dist, task) in ordered_tasks if dist <= 5 and dist < len(task)]\n        if candidates:\n            return \"No task %s. Did you mean:\\n%s\" % (task_name, '\\n'.join(candidates))\n        else:\n            return \"No task %s. Candidates are: %s\" % (task_name, cls.tasks_str())",
        "begin_line": 221,
        "end_line": 228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.mysqldb.MySqlTarget.touch#66",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.MySqlTarget",
        "signature": "luigi.contrib.mysqldb.MySqlTarget.touch(self, connection=None)",
        "snippet": "    def touch(self, connection=None):\n        \"\"\"\n        Mark this update as complete.\n\n        IMPORTANT, If the marker table doesn't exist,\n        the connection transaction will be aborted and the connection reset.\n        Then the marker table will be created.\n        \"\"\"\n        self.create_marker_table()\n\n        if connection is None:\n            connection = self.connect()\n            connection.autocommit = True  # if connection created here, we commit it here\n\n        connection.cursor().execute(\n            \"\"\"INSERT INTO {marker_table} (update_id, target_table)\n               VALUES (%s, %s)\n               ON DUPLICATE KEY UPDATE\n               update_id = VALUES(update_id)\n            \"\"\".format(marker_table=self.marker_table),\n            (self.update_id, self.table)\n        )\n        # make sure update is properly marked\n        assert self.exists(connection)",
        "begin_line": 66,
        "end_line": 89,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.mysqldb.MySqlTarget.exists#91",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.MySqlTarget",
        "signature": "luigi.contrib.mysqldb.MySqlTarget.exists(self, connection=None)",
        "snippet": "    def exists(self, connection=None):\n        if connection is None:\n            connection = self.connect()\n            connection.autocommit = True\n        cursor = connection.cursor()\n        try:\n            cursor.execute(\"\"\"SELECT 1 FROM {marker_table}\n                WHERE update_id = %s\n                LIMIT 1\"\"\".format(marker_table=self.marker_table),\n                           (self.update_id,)\n                           )\n            row = cursor.fetchone()\n        except mysql.connector.Error as e:\n            if e.errno == errorcode.ER_NO_SUCH_TABLE:\n                row = None\n            else:\n                raise\n        return row is not None",
        "begin_line": 91,
        "end_line": 108,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.mysqldb.MySqlTarget.connect#110",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.MySqlTarget",
        "signature": "luigi.contrib.mysqldb.MySqlTarget.connect(self, autocommit=False)",
        "snippet": "    def connect(self, autocommit=False):\n        connection = mysql.connector.connect(user=self.user,\n                                             password=self.password,\n                                             host=self.host,\n                                             port=self.port,\n                                             database=self.database,\n                                             autocommit=autocommit)\n        return connection",
        "begin_line": 110,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.mysqldb.MySqlTarget.create_marker_table#119",
        "src_path": "luigi/contrib/mysqldb.py",
        "class_name": "luigi.contrib.mysqldb.MySqlTarget",
        "signature": "luigi.contrib.mysqldb.MySqlTarget.create_marker_table(self)",
        "snippet": "    def create_marker_table(self):\n        \"\"\"\n        Create marker table if it doesn't exist.\n\n        Using a separate connection since the transaction might have to be reset.\n        \"\"\"\n        connection = self.connect(autocommit=True)\n        cursor = connection.cursor()\n        try:\n            cursor.execute(\n                \"\"\" CREATE TABLE {marker_table} (\n                        id            BIGINT(20)    NOT NULL AUTO_INCREMENT,\n                        update_id     VARCHAR(128)  NOT NULL,\n                        target_table  VARCHAR(128),\n                        inserted      TIMESTAMP DEFAULT NOW(),\n                        PRIMARY KEY (update_id),\n                        KEY id (id)\n                    )\n                \"\"\"\n                .format(marker_table=self.marker_table)\n            )\n        except mysql.connector.Error as e:\n            if e.errno == errorcode.ER_TABLE_EXISTS_ERROR:\n                pass\n            else:\n                raise\n        connection.close()",
        "begin_line": 119,
        "end_line": 145,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask._get_pool#624",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask._get_pool(self)",
        "snippet": "    def _get_pool(self):\n        \"\"\" Protected method \"\"\"\n        if self.pool:\n            return self.pool\n        if hadoop().pool:\n            return hadoop().pool",
        "begin_line": 624,
        "end_line": 629,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.jobconfs#635",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.jobconfs(self)",
        "snippet": "    def jobconfs(self):\n        jcs = []\n        jcs.append('mapred.job.name=%s' % self.task_id)\n        if self.mr_priority != NotImplemented:\n            jcs.append('mapred.job.priority=%s' % self.mr_priority())\n        pool = self._get_pool()\n        if pool is not None:\n            # Supporting two schedulers: fair (default) and capacity using the same option\n            scheduler_type = configuration.get_config().get('hadoop', 'scheduler', 'fair')\n            if scheduler_type == 'fair':\n                jcs.append('mapred.fairscheduler.pool=%s' % pool)\n            elif scheduler_type == 'capacity':\n                jcs.append('mapred.job.queue.name=%s' % pool)\n        return jcs",
        "begin_line": 635,
        "end_line": 648,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.init_local#650",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.init_local(self)",
        "snippet": "    def init_local(self):\n        \"\"\"\n        Implement any work to setup any internal datastructure etc here.\n\n        You can add extra input using the requires_local/input_local methods.\n\n        Anything you set on the object will be pickled and available on the Hadoop nodes.\n        \"\"\"\n        pass",
        "begin_line": 650,
        "end_line": 658,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.run#663",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.run(self)",
        "snippet": "    def run(self):\n        self.init_local()\n        self.job_runner().run_job(self)",
        "begin_line": 663,
        "end_line": 665,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.requires_local#667",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.requires_local(self)",
        "snippet": "    def requires_local(self):\n        \"\"\"\n        Default impl - override this method if you need any local input to be accessible in init().\n        \"\"\"\n        return []",
        "begin_line": 667,
        "end_line": 671,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.requires_hadoop#673",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.requires_hadoop(self)",
        "snippet": "    def requires_hadoop(self):\n        return self.requires()  # default impl",
        "begin_line": 673,
        "end_line": 674,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hadoop.BaseHadoopJobTask.deps#682",
        "src_path": "luigi/contrib/hadoop.py",
        "class_name": "luigi.contrib.hadoop.BaseHadoopJobTask",
        "signature": "luigi.contrib.hadoop.BaseHadoopJobTask.deps(self)",
        "snippet": "    def deps(self):\n        # Overrides the default implementation\n        return luigi.task.flatten(self.requires_hadoop()) + luigi.task.flatten(self.requires_local())",
        "begin_line": 682,
        "end_line": 684,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.__init__#166",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.__init__(self, connection_string, target_table, update_id, echo=False, connect_args={})",
        "snippet": "    def __init__(self, connection_string, target_table, update_id, echo=False, connect_args={}):\n        \"\"\"\n        Constructor for the SQLAlchemyTarget.\n\n        :param connection_string: SQLAlchemy connection string\n        :type connection_string: str\n        :param target_table: The table name for the data\n        :type target_table: str\n        :param update_id: An identifier for this data set\n        :type update_id: str\n        :param echo: Flag to setup SQLAlchemy logging\n        :type echo: bool\n        :param connect_args: A dictionary of connection arguments\n        :type connect_args: dict\n        :return:\n        \"\"\"\n        self.target_table = target_table\n        self.update_id = update_id\n        self.connection_string = connection_string\n        self.echo = echo\n        self.connect_args = connect_args\n        self.marker_table_bound = None",
        "begin_line": 166,
        "end_line": 187,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00043308791684711995,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.engine#190",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.engine(self)",
        "snippet": "    def engine(self):\n        \"\"\"\n        Return an engine instance, creating it if it doesn't exist.\n\n        Recreate the engine connection if it wasn't originally created\n        by the current process.\n        \"\"\"\n        pid = os.getpid()\n        conn = SQLAlchemyTarget._engine_dict.get(self.connection_string)\n        if not conn or conn.pid != pid:\n            # create and reset connection\n            engine = sqlalchemy.create_engine(\n                self.connection_string,\n                connect_args=self.connect_args,\n                echo=self.echo\n            )\n            SQLAlchemyTarget._engine_dict[self.connection_string] = self.Connection(engine, pid)\n        return SQLAlchemyTarget._engine_dict[self.connection_string].engine",
        "begin_line": 190,
        "end_line": 207,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004514672686230248,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.touch#209",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.touch(self)",
        "snippet": "    def touch(self):\n        \"\"\"\n        Mark this update as complete.\n        \"\"\"\n        if self.marker_table_bound is None:\n            self.create_marker_table()\n\n        table = self.marker_table_bound\n        id_exists = self.exists()\n        with self.engine.begin() as conn:\n            if not id_exists:\n                ins = table.insert().values(update_id=self.update_id, target_table=self.target_table,\n                                            inserted=datetime.datetime.now())\n            else:\n                ins = table.update().where(sqlalchemy.and_(table.c.update_id == self.update_id,\n                                                           table.c.target_table == self.target_table)).\\\n                    values(update_id=self.update_id, target_table=self.target_table,\n                           inserted=datetime.datetime.now())\n            conn.execute(ins)\n        assert self.exists()",
        "begin_line": 209,
        "end_line": 228,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000501002004008016,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.exists#230",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.exists(self)",
        "snippet": "    def exists(self):\n        row = None\n        if self.marker_table_bound is None:\n            self.create_marker_table()\n        with self.engine.begin() as conn:\n            table = self.marker_table_bound\n            s = sqlalchemy.select([table]).where(sqlalchemy.and_(table.c.update_id == self.update_id,\n                                                                 table.c.target_table == self.target_table)).limit(1)\n            row = conn.execute(s).fetchone()\n        return row is not None",
        "begin_line": 230,
        "end_line": 239,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00045829514207149406,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.sqla.SQLAlchemyTarget.create_marker_table#241",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.SQLAlchemyTarget",
        "signature": "luigi.contrib.sqla.SQLAlchemyTarget.create_marker_table(self)",
        "snippet": "    def create_marker_table(self):\n        \"\"\"\n        Create marker table if it doesn't exist.\n\n        Using a separate connection since the transaction might have to be reset.\n        \"\"\"\n        if self.marker_table is None:\n            self.marker_table = luigi.configuration.get_config().get('sqlalchemy', 'marker-table', 'table_updates')\n\n        engine = self.engine\n\n        with engine.begin() as con:\n            metadata = sqlalchemy.MetaData()\n            if not con.dialect.has_table(con, self.marker_table):\n                self.marker_table_bound = sqlalchemy.Table(\n                    self.marker_table, metadata,\n                    sqlalchemy.Column(\"update_id\", sqlalchemy.String(128), primary_key=True),\n                    sqlalchemy.Column(\"target_table\", sqlalchemy.String(128)),\n                    sqlalchemy.Column(\"inserted\", sqlalchemy.DateTime, default=datetime.datetime.now()))\n                metadata.create_all(engine)\n            else:\n                metadata.reflect(bind=engine)\n                self.marker_table_bound = metadata.tables[self.marker_table]",
        "begin_line": 241,
        "end_line": 263,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004940711462450593,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.create_table#308",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.create_table(self, engine)",
        "snippet": "    def create_table(self, engine):\n        \"\"\"\n        Override to provide code for creating the target table.\n\n        By default it will be created using types specified in columns.\n        If the table exists, then it binds to the existing table.\n\n        If overridden, use the provided connection object for setting up the table in order to\n        create the table and insert data using the same transaction.\n        :param engine: The sqlalchemy engine instance\n        :type engine: object\n        \"\"\"\n        def construct_sqla_columns(columns):\n            retval = [sqlalchemy.Column(*c[0], **c[1]) for c in columns]\n            return retval\n\n        needs_setup = (len(self.columns) == 0) or (False in [len(c) == 2 for c in self.columns]) if not self.reflect else False\n        if needs_setup:\n            # only names of columns specified, no types\n            raise NotImplementedError(\"create_table() not implemented for %r and columns types not specified\" % self.table)\n        else:\n            # if columns is specified as (name, type) tuples\n            with engine.begin() as con:\n                metadata = sqlalchemy.MetaData()\n                try:\n                    if not con.dialect.has_table(con, self.table):\n                        sqla_columns = construct_sqla_columns(self.columns)\n                        self.table_bound = sqlalchemy.Table(self.table, metadata, *sqla_columns)\n                        metadata.create_all(engine)\n                    else:\n                        metadata.reflect(bind=engine)\n                        self.table_bound = metadata.tables[self.table]\n                except Exception as e:\n                    self._logger.exception(self.table + str(e))",
        "begin_line": 308,
        "end_line": 341,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.construct_sqla_columns#320",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.construct_sqla_columns(columns)",
        "snippet": "        def construct_sqla_columns(columns):\n            retval = [sqlalchemy.Column(*c[0], **c[1]) for c in columns]\n            return retval",
        "begin_line": 320,
        "end_line": 322,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.update_id#343",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.update_id(self)",
        "snippet": "    def update_id(self):\n        \"\"\"\n        This update id will be a unique identifier for this insert on this table.\n        \"\"\"\n        return self.task_id",
        "begin_line": 343,
        "end_line": 347,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.output#349",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.output(self)",
        "snippet": "    def output(self):\n        return SQLAlchemyTarget(\n            connection_string=self.connection_string,\n            target_table=self.table,\n            update_id=self.update_id(),\n            connect_args=self.connect_args,\n            echo=self.echo)",
        "begin_line": 349,
        "end_line": 355,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.rows#357",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.rows(self)",
        "snippet": "    def rows(self):\n        \"\"\"\n        Return/yield tuples or lists corresponding to each row to be inserted.\n\n        This method can be overridden for custom file types or formats.\n        \"\"\"\n        with self.input().open('r') as fobj:\n            for line in fobj:\n                yield line.strip(\"\\n\").split(self.column_separator)",
        "begin_line": 357,
        "end_line": 365,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.run#367",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.run(self)",
        "snippet": "    def run(self):\n        self._logger.info(\"Running task copy to table for update id %s for table %s\" % (self.update_id(), self.table))\n        output = self.output()\n        engine = output.engine\n        self.create_table(engine)\n        with engine.begin() as conn:\n            rows = iter(self.rows())\n            ins_rows = [dict(zip((\"_\" + c.key for c in self.table_bound.c), row))\n                        for row in itertools.islice(rows, self.chunk_size)]\n            while ins_rows:\n                self.copy(conn, ins_rows, self.table_bound)\n                ins_rows = [dict(zip((\"_\" + c.key for c in self.table_bound.c), row))\n                            for row in itertools.islice(rows, self.chunk_size)]\n                self._logger.info(\"Finished inserting %d rows into SQLAlchemy target\" % len(ins_rows))\n        output.touch()\n        self._logger.info(\"Finished inserting rows into SQLAlchemy target\")",
        "begin_line": 367,
        "end_line": 382,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.sqla.CopyToTable.copy#384",
        "src_path": "luigi/contrib/sqla.py",
        "class_name": "luigi.contrib.sqla.CopyToTable",
        "signature": "luigi.contrib.sqla.CopyToTable.copy(self, conn, ins_rows, table_bound)",
        "snippet": "    def copy(self, conn, ins_rows, table_bound):\n        \"\"\"\n        This method does the actual insertion of the rows of data given by ins_rows into the\n        database. A task that needs row updates instead of insertions should overload this method.\n        :param conn: The sqlalchemy connection object\n        :param ins_rows: The dictionary of rows with the keys in the format _<column_name>. For example\n        if you have a table with a column name \"property\", then the key in the dictionary\n        would be \"_property\". This format is consistent with the bindparam usage in sqlalchemy.\n        :param table_bound: The object referring to the table\n        :return:\n        \"\"\"\n        bound_cols = dict((c, sqlalchemy.bindparam(\"_\" + c.key)) for c in table_bound.columns)\n        ins = table_bound.insert().values(bound_cols)\n        conn.execute(ins, ins_rows)",
        "begin_line": 384,
        "end_line": 397,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.target.CascadingClient.__init__#45",
        "src_path": "luigi/contrib/target.py",
        "class_name": "luigi.contrib.target.CascadingClient",
        "signature": "luigi.contrib.target.CascadingClient.__init__(self, clients, method_names=None)",
        "snippet": "    def __init__(self, clients, method_names=None):\n        self.clients = clients\n        if method_names is None:\n            method_names = self.ALL_METHOD_NAMES\n\n        for method_name in method_names:\n            new_method = self._make_method(method_name)\n            real_method = six.create_bound_method(new_method, self)\n            setattr(self, method_name, real_method)",
        "begin_line": 45,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000630119722747322,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.target.CascadingClient.new_method#57",
        "src_path": "luigi/contrib/target.py",
        "class_name": "luigi.contrib.target.CascadingClient",
        "signature": "luigi.contrib.target.CascadingClient.new_method(self, *args, **kwargs)",
        "snippet": "        def new_method(self, *args, **kwargs):\n            return self._chained_call(method_name, *args, **kwargs)",
        "begin_line": 57,
        "end_line": 58,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006031363088057901,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.target.CascadingClient._make_method#56",
        "src_path": "luigi/contrib/target.py",
        "class_name": "luigi.contrib.target.CascadingClient",
        "signature": "luigi.contrib.target.CascadingClient._make_method(cls, method_name)",
        "snippet": "    def _make_method(cls, method_name):\n        def new_method(self, *args, **kwargs):\n            return self._chained_call(method_name, *args, **kwargs)\n        return new_method",
        "begin_line": 56,
        "end_line": 59,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006031363088057901,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.target.CascadingClient._chained_call#61",
        "src_path": "luigi/contrib/target.py",
        "class_name": "luigi.contrib.target.CascadingClient",
        "signature": "luigi.contrib.target.CascadingClient._chained_call(self, method_name, *args, **kwargs)",
        "snippet": "    def _chained_call(self, method_name, *args, **kwargs):\n        for i in range(len(self.clients)):\n            client = self.clients[i]\n            try:\n                result = getattr(client, method_name)(*args, **kwargs)\n                return result\n            except luigi.target.FileSystemException:\n                # For exceptions that are semantical, we must throw along\n                raise\n            except BaseException:\n                is_last_iteration = (i + 1) >= len(self.clients)\n                if is_last_iteration:\n                    raise\n                else:\n                    logger.warning('The %s failed to %s, using fallback class %s',\n                                   client.__class__.__name__, method_name, self.clients[i + 1].__class__.__name__)",
        "begin_line": 61,
        "end_line": 76,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.fix_time#107",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler",
        "signature": "luigi.scheduler.fix_time(x)",
        "snippet": "def fix_time(x):\n    # Backwards compatibility for a fix in Dec 2014. Prior to the fix, pickled state might store datetime objects\n    # Let's remove this function soon\n    if isinstance(x, datetime.datetime):\n        return time.mktime(x.timetuple())\n    else:\n        return x",
        "begin_line": 107,
        "end_line": 113,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00048216007714561236,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.Failures.__init__#124",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Failures",
        "signature": "luigi.scheduler.Failures.__init__(self, window)",
        "snippet": "    def __init__(self, window):\n        \"\"\"\n        Initialize with the given window.\n\n        :param window: how long to track failures for, as a float (number of seconds).\n        \"\"\"\n        self.window = window\n        self.failures = collections.deque()\n        self.first_failure_time = None",
        "begin_line": 124,
        "end_line": 132,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.001524390243902439,
            "pseudo_dstar_susp": 0.001524390243902439,
            "pseudo_tarantula_susp": 0.0015267175572519084,
            "pseudo_op2_susp": 0.001524390243902439,
            "pseudo_barinel_susp": 0.0015267175572519084
        }
    },
    {
        "name": "luigi.scheduler.Failures.add_failure#134",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Failures",
        "signature": "luigi.scheduler.Failures.add_failure(self)",
        "snippet": "    def add_failure(self):\n        \"\"\"\n        Add a failure event with the current timestamp.\n        \"\"\"\n        failure_time = time.time()\n\n        if not self.first_failure_time:\n            self.first_failure_time = failure_time\n\n        self.failures.append(failure_time)",
        "begin_line": 134,
        "end_line": 143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004725897920604915,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.Failures.num_failures#145",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Failures",
        "signature": "luigi.scheduler.Failures.num_failures(self)",
        "snippet": "    def num_failures(self):\n        \"\"\"\n        Return the number of failures in the window.\n        \"\"\"\n        min_time = time.time() - self.window\n\n        while self.failures and fix_time(self.failures[0]) < min_time:\n            self.failures.popleft()\n\n        return len(self.failures)",
        "begin_line": 145,
        "end_line": 154,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00048216007714561236,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.Failures.clear#156",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Failures",
        "signature": "luigi.scheduler.Failures.clear(self)",
        "snippet": "    def clear(self):\n        \"\"\"\n        Clear the failure queue.\n        \"\"\"\n        self.failures.clear()",
        "begin_line": 156,
        "end_line": 160,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00048216007714561236,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler._get_default#163",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler",
        "signature": "luigi.scheduler._get_default(x, default)",
        "snippet": "def _get_default(x, default):\n    if x is not None:\n        return x\n    else:\n        return default",
        "begin_line": 163,
        "end_line": 167,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002,
            "pseudo_dstar_susp": 0.003355704697986577,
            "pseudo_tarantula_susp": 0.0019120458891013384,
            "pseudo_op2_susp": 0.003355704697986577,
            "pseudo_barinel_susp": 0.0019120458891013384
        }
    },
    {
        "name": "luigi.scheduler.Task.__init__#172",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.__init__(self, task_id, status, deps, resources=None, priority=0, family='', module=None, params=None, disable_failures=None, disable_window=None, disable_hard_timeout=None)",
        "snippet": "    def __init__(self, task_id, status, deps, resources=None, priority=0, family='', module=None,\n                 params=None, disable_failures=None, disable_window=None, disable_hard_timeout=None):\n        self.id = task_id\n        self.stakeholders = set()  # workers ids that are somehow related to this task (i.e. don't prune while any of these workers are still active)\n        self.workers = set()  # workers ids that can perform task - task is 'BROKEN' if none of these workers are active\n        if deps is None:\n            self.deps = set()\n        else:\n            self.deps = set(deps)\n        self.status = status  # PENDING, RUNNING, FAILED or DONE\n        self.time = time.time()  # Timestamp when task was first added\n        self.retry = None\n        self.remove = None\n        self.worker_running = None  # the worker id that is currently running the task or None\n        self.time_running = None  # Timestamp when picked up by worker\n        self.expl = None\n        self.priority = priority\n        self.resources = _get_default(resources, {})\n        self.family = family\n        self.module = module\n        self.params = _get_default(params, {})\n        self.disable_failures = disable_failures\n        self.disable_hard_timeout = disable_hard_timeout\n        self.failures = Failures(disable_window)\n        self.scheduler_disable_time = None",
        "begin_line": 172,
        "end_line": 196,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020920502092050207,
            "pseudo_dstar_susp": 0.004545454545454545,
            "pseudo_tarantula_susp": 0.0017761989342806395,
            "pseudo_op2_susp": 0.004545454545454545,
            "pseudo_barinel_susp": 0.0017761989342806395
        }
    },
    {
        "name": "luigi.scheduler.Task.add_failure#201",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.add_failure(self)",
        "snippet": "    def add_failure(self):\n        self.failures.add_failure()",
        "begin_line": 201,
        "end_line": 202,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00043878894251864854,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.Task.has_excessive_failures#204",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.has_excessive_failures(self)",
        "snippet": "    def has_excessive_failures(self):\n\n        excessive_failures = False\n\n        if (self.failures.first_failure_time is not None and\n                self.disable_hard_timeout):\n            if (time.time() >= self.failures.first_failure_time +\n                    self.disable_hard_timeout):\n                excessive_failures = True\n\n        if self.failures.num_failures() >= self.disable_failures:\n            excessive_failures = True\n\n        return excessive_failures",
        "begin_line": 204,
        "end_line": 217,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004426737494466578,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.Task.can_disable#219",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Task",
        "signature": "luigi.scheduler.Task.can_disable(self)",
        "snippet": "    def can_disable(self):\n        return (self.disable_failures is not None or\n                self.disable_hard_timeout is not None)",
        "begin_line": 219,
        "end_line": 221,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004399472063352398,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.Worker.__init__#229",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.__init__(self, worker_id, last_active=None)",
        "snippet": "    def __init__(self, worker_id, last_active=None):\n        self.id = worker_id\n        self.reference = None  # reference to the worker in the real world. (Currently a dict containing just the host)\n        self.last_active = last_active or time.time()  # seconds since epoch\n        self.started = time.time()  # seconds since epoch\n        self.tasks = set()  # task objects\n        self.info = {}",
        "begin_line": 229,
        "end_line": 235,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.06666666666666667,
            "pseudo_dstar_susp": 0.3333333333333333,
            "pseudo_tarantula_susp": 0.014705882352941176,
            "pseudo_op2_susp": 0.3333333333333333,
            "pseudo_barinel_susp": 0.014925373134328358
        }
    },
    {
        "name": "luigi.scheduler.Worker.add_info#237",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.add_info(self, info)",
        "snippet": "    def add_info(self, info):\n        self.info.update(info)",
        "begin_line": 237,
        "end_line": 238,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018552875695732839,
            "pseudo_dstar_susp": 0.0024630541871921183,
            "pseudo_tarantula_susp": 0.0015723270440251573,
            "pseudo_op2_susp": 0.0024630541871921183,
            "pseudo_barinel_susp": 0.0015723270440251573
        }
    },
    {
        "name": "luigi.scheduler.Worker.update#240",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.update(self, worker_reference)",
        "snippet": "    def update(self, worker_reference):\n        if worker_reference:\n            self.reference = worker_reference\n        self.last_active = time.time()",
        "begin_line": 240,
        "end_line": 243,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03333333333333333,
            "pseudo_dstar_susp": 0.2,
            "pseudo_tarantula_susp": 0.0064516129032258064,
            "pseudo_op2_susp": 0.2,
            "pseudo_barinel_susp": 0.0064516129032258064
        }
    },
    {
        "name": "luigi.scheduler.Worker.prune#245",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.prune(self, config)",
        "snippet": "    def prune(self, config):\n        # Delete workers that haven't said anything for a while (probably killed)\n        if self.last_active + config.worker_disconnect_delay < time.time():\n            return True",
        "begin_line": 245,
        "end_line": 248,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002004008016032064,
            "pseudo_dstar_susp": 0.0026455026455026454,
            "pseudo_tarantula_susp": 0.001953125,
            "pseudo_op2_susp": 0.0026455026455026454,
            "pseudo_barinel_susp": 0.001953125
        }
    },
    {
        "name": "luigi.scheduler.Worker.get_pending_tasks#250",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.get_pending_tasks(self, state)",
        "snippet": "    def get_pending_tasks(self, state):\n        \"\"\"\n        Get PENDING (and RUNNING) tasks for this worker.\n\n        You have to pass in the state for optimization reasons.\n        \"\"\"\n        if len(self.tasks) < state.num_pending_tasks():\n            return six.moves.filter(lambda task: task.status in [PENDING, RUNNING],\n                                    self.tasks)\n        else:\n            return state.get_pending_tasks()",
        "begin_line": 250,
        "end_line": 260,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0020964360587002098,
            "pseudo_dstar_susp": 0.003389830508474576,
            "pseudo_tarantula_susp": 0.0019569471624266144,
            "pseudo_op2_susp": 0.003389830508474576,
            "pseudo_barinel_susp": 0.0019569471624266144
        }
    },
    {
        "name": "luigi.scheduler.Worker.is_trivial_worker#262",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.is_trivial_worker(self, state)",
        "snippet": "    def is_trivial_worker(self, state):\n        \"\"\"\n        If it's not an assistant having only tasks that are without\n        requirements.\n\n        We have to pass the state parameter for optimization reasons.\n        \"\"\"\n        if self.assistant:\n            return False\n        return all(not task.resources for task in self.get_pending_tasks(state))",
        "begin_line": 262,
        "end_line": 271,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024691358024691358,
            "pseudo_dstar_susp": 0.002079002079002079,
            "pseudo_tarantula_susp": 0.00411522633744856,
            "pseudo_op2_susp": 0.002079002079002079,
            "pseudo_barinel_susp": 0.00411522633744856
        }
    },
    {
        "name": "luigi.scheduler.Worker.assistant#274",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.assistant(self)",
        "snippet": "    def assistant(self):\n        return self.info.get('assistant', False)",
        "begin_line": 274,
        "end_line": 275,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004106776180698152,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.Worker.__str__#277",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.Worker",
        "signature": "luigi.scheduler.Worker.__str__(self)",
        "snippet": "    def __str__(self):\n        return self.id",
        "begin_line": 277,
        "end_line": 278,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.__init__#290",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.__init__(self, state_path)",
        "snippet": "    def __init__(self, state_path):\n        self._state_path = state_path\n        self._tasks = {}  # map from id to a Task object\n        self._status_tasks = collections.defaultdict(dict)\n        self._active_workers = {}  # map from id to a Worker object",
        "begin_line": 290,
        "end_line": 294,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003355704697986577,
            "pseudo_dstar_susp": 0.003076923076923077,
            "pseudo_tarantula_susp": 0.004651162790697674,
            "pseudo_op2_susp": 0.003076923076923077,
            "pseudo_barinel_susp": 0.004651162790697674
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.dump#296",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.dump(self)",
        "snippet": "    def dump(self):\n        state = (self._tasks, self._active_workers)\n        try:\n            with open(self._state_path, 'wb') as fobj:\n                pickle.dump(state, fobj)\n        except IOError:\n            logger.warning(\"Failed saving scheduler state\", exc_info=1)\n        else:\n            logger.info(\"Saved state in %s\", self._state_path)",
        "begin_line": 296,
        "end_line": 304,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.load#307",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.load(self)",
        "snippet": "    def load(self):\n        if os.path.exists(self._state_path):\n            logger.info(\"Attempting to load state from %s\", self._state_path)\n            try:\n                with open(self._state_path, 'rb') as fobj:\n                    state = pickle.load(fobj)\n            except BaseException:\n                logger.exception(\"Error when loading state. Starting from clean slate.\")\n                return\n\n            self._tasks, self._active_workers = state\n            self._status_tasks = collections.defaultdict(dict)\n            for task in six.itervalues(self._tasks):\n                self._status_tasks[task.status][task.id] = task\n\n            # Convert from old format\n            # TODO: this is really ugly, we need something more future-proof\n            # Every time we add an attribute to the Worker class, this code needs to be updated\n            for k, v in six.iteritems(self._active_workers):\n                if isinstance(v, float):\n                    self._active_workers[k] = Worker(worker_id=k, last_active=v)\n\n            if any(not hasattr(w, 'tasks') for k, w in six.iteritems(self._active_workers)):\n                # If you load from an old format where Workers don't contain tasks.\n                for k, worker in six.iteritems(self._active_workers):\n                    worker.tasks = set()\n                for task in six.itervalues(self._tasks):\n                    for worker_id in task.workers:\n                        self._active_workers[worker_id].tasks.add(task)\n        else:\n            logger.info(\"No prior state file exists at %s. Starting with clean slate\", self._state_path)",
        "begin_line": 307,
        "end_line": 337,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_active_tasks#339",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_active_tasks(self, status=None)",
        "snippet": "    def get_active_tasks(self, status=None):\n        if status:\n            for task in six.itervalues(self._status_tasks[status]):\n                yield task\n        else:\n            for task in six.itervalues(self._tasks):\n                yield task",
        "begin_line": 339,
        "end_line": 345,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002531645569620253,
            "pseudo_dstar_susp": 0.0021008403361344537,
            "pseudo_tarantula_susp": 0.004424778761061947,
            "pseudo_op2_susp": 0.0021008403361344537,
            "pseudo_barinel_susp": 0.004424778761061947
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_pending_tasks#350",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_pending_tasks(self)",
        "snippet": "    def get_pending_tasks(self):\n        return itertools.chain.from_iterable(six.itervalues(self._status_tasks[status])\n                                             for status in [PENDING, RUNNING])",
        "begin_line": 350,
        "end_line": 352,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002336448598130841,
            "pseudo_dstar_susp": 0.002012072434607646,
            "pseudo_tarantula_susp": 0.003676470588235294,
            "pseudo_op2_susp": 0.002012072434607646,
            "pseudo_barinel_susp": 0.003676470588235294
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.num_pending_tasks#354",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.num_pending_tasks(self)",
        "snippet": "    def num_pending_tasks(self):\n        \"\"\"\n        Return how many tasks are PENDING + RUNNING. O(1).\n        \"\"\"\n        return len(self._status_tasks[PENDING]) + len(self._status_tasks[RUNNING])",
        "begin_line": 354,
        "end_line": 358,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024691358024691358,
            "pseudo_dstar_susp": 0.002079002079002079,
            "pseudo_tarantula_susp": 0.00411522633744856,
            "pseudo_op2_susp": 0.002079002079002079,
            "pseudo_barinel_susp": 0.00411522633744856
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_task#360",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_task(self, task_id, default=None, setdefault=None)",
        "snippet": "    def get_task(self, task_id, default=None, setdefault=None):\n        if setdefault:\n            task = self._tasks.setdefault(task_id, setdefault)\n            self._status_tasks[task.status][task.id] = task\n            return task\n        else:\n            return self._tasks.get(task_id, default)",
        "begin_line": 360,
        "end_line": 366,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002506265664160401,
            "pseudo_dstar_susp": 0.0020920502092050207,
            "pseudo_tarantula_susp": 0.0041841004184100415,
            "pseudo_op2_susp": 0.0020920502092050207,
            "pseudo_barinel_susp": 0.0041841004184100415
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.has_task#368",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.has_task(self, task_id)",
        "snippet": "    def has_task(self, task_id):\n        return task_id in self._tasks",
        "begin_line": 368,
        "end_line": 369,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004514672686230248,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.re_enable#371",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.re_enable(self, task, config=None)",
        "snippet": "    def re_enable(self, task, config=None):\n        task.scheduler_disable_time = None\n        task.failures.clear()\n        if config:\n            self.set_status(task, FAILED, config)\n            task.failures.clear()",
        "begin_line": 371,
        "end_line": 376,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005361930294906167,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.set_status#378",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.set_status(self, task, new_status, config=None)",
        "snippet": "    def set_status(self, task, new_status, config=None):\n        if new_status == FAILED:\n            assert config is not None\n\n        # not sure why we have SUSPENDED, as it can never be set\n        if new_status == SUSPENDED:\n            new_status = PENDING\n\n        if new_status == DISABLED and task.status == RUNNING:\n            return\n\n        if task.status == DISABLED:\n            if new_status == DONE:\n                self.re_enable(task)\n\n            # don't allow workers to override a scheduler disable\n            elif task.scheduler_disable_time is not None:\n                return\n\n        if new_status == FAILED and task.can_disable():\n            task.add_failure()\n            if task.has_excessive_failures():\n                task.scheduler_disable_time = time.time()\n                new_status = DISABLED\n                notifications.send_error_email(\n                    'Luigi Scheduler: DISABLED {task} due to excessive failures'.format(task=task.id),\n                    '{task} failed {failures} times in the last {window} seconds, so it is being '\n                    'disabled for {persist} seconds'.format(\n                        failures=config.disable_failures,\n                        task=task.id,\n                        window=config.disable_window,\n                        persist=config.disable_persist,\n                    ))\n        elif new_status == DISABLED:\n            task.scheduler_disable_time = None\n\n        self._status_tasks[task.status].pop(task.id)\n        self._status_tasks[new_status][task.id] = task\n        task.status = new_status",
        "begin_line": 378,
        "end_line": 416,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002336448598130841,
            "pseudo_dstar_susp": 0.002012072434607646,
            "pseudo_tarantula_susp": 0.003676470588235294,
            "pseudo_op2_susp": 0.002012072434607646,
            "pseudo_barinel_susp": 0.003676470588235294
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.prune#418",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.prune(self, task, config, assistants)",
        "snippet": "    def prune(self, task, config, assistants):\n        remove = False\n\n        # Mark tasks with no remaining active stakeholders for deletion\n        if not task.stakeholders:\n            if task.remove is None:\n                logger.info(\"Task %r has stakeholders %r but none remain connected -> will remove \"\n                            \"task in %s seconds\", task.id, task.stakeholders, config.remove_delay)\n                task.remove = time.time() + config.remove_delay\n\n        # If a running worker disconnects, tag all its jobs as FAILED and subject it to the same retry logic\n        if task.status == RUNNING and task.worker_running and task.worker_running not in task.stakeholders | assistants:\n            logger.info(\"Task %r is marked as running by disconnected worker %r -> marking as \"\n                        \"FAILED with retry delay of %rs\", task.id, task.worker_running,\n                        config.retry_delay)\n            task.worker_running = None\n            self.set_status(task, FAILED, config)\n            task.retry = time.time() + config.retry_delay\n\n        # Re-enable task after the disable time expires\n        if task.status == DISABLED and task.scheduler_disable_time:\n            if time.time() - fix_time(task.scheduler_disable_time) > config.disable_persist:\n                self.re_enable(task, config)\n\n        # Remove tasks that have no stakeholders\n        if task.remove and time.time() > task.remove:\n            logger.info(\"Removing task %r (no connected stakeholders)\", task.id)\n            remove = True\n\n        # Reset FAILED tasks to PENDING if max timeout is reached, and retry delay is >= 0\n        if task.status == FAILED and config.retry_delay >= 0 and task.retry < time.time():\n            self.set_status(task, PENDING, config)\n\n        return remove",
        "begin_line": 418,
        "end_line": 451,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003355704697986577,
            "pseudo_dstar_susp": 0.0021551724137931034,
            "pseudo_tarantula_susp": 0.007407407407407408,
            "pseudo_op2_susp": 0.0021551724137931034,
            "pseudo_barinel_susp": 0.0072992700729927005
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.inactivate_tasks#453",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.inactivate_tasks(self, delete_tasks)",
        "snippet": "    def inactivate_tasks(self, delete_tasks):\n        # The terminology is a bit confusing: we used to \"delete\" tasks when they became inactive,\n        # but with a pluggable state storage, you might very well want to keep some history of\n        # older tasks as well. That's why we call it \"inactivate\" (as in the verb)\n        for task in delete_tasks:\n            task_obj = self._tasks.pop(task)\n            self._status_tasks[task_obj.status].pop(task)",
        "begin_line": 453,
        "end_line": 459,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002386634844868735,
            "pseudo_dstar_susp": 0.0020408163265306124,
            "pseudo_tarantula_susp": 0.0038461538461538464,
            "pseudo_op2_susp": 0.0020408163265306124,
            "pseudo_barinel_susp": 0.0038461538461538464
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_active_workers#461",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_active_workers(self, last_active_lt=None)",
        "snippet": "    def get_active_workers(self, last_active_lt=None):\n        for worker in six.itervalues(self._active_workers):\n            if last_active_lt is not None and worker.last_active >= last_active_lt:\n                continue\n            yield worker",
        "begin_line": 461,
        "end_line": 465,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002421307506053269,
            "pseudo_dstar_susp": 0.00205761316872428,
            "pseudo_tarantula_susp": 0.00398406374501992,
            "pseudo_op2_susp": 0.00205761316872428,
            "pseudo_barinel_susp": 0.004
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_assistants#467",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_assistants(self, last_active_lt=None)",
        "snippet": "    def get_assistants(self, last_active_lt=None):\n        return filter(lambda w: w.assistant, self.get_active_workers(last_active_lt))",
        "begin_line": 467,
        "end_line": 468,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024691358024691358,
            "pseudo_dstar_susp": 0.002079002079002079,
            "pseudo_tarantula_susp": 0.00411522633744856,
            "pseudo_op2_susp": 0.002079002079002079,
            "pseudo_barinel_susp": 0.00411522633744856
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_worker_ids#470",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_worker_ids(self)",
        "snippet": "    def get_worker_ids(self):\n        return self._active_workers.keys()  # only used for unit tests",
        "begin_line": 470,
        "end_line": 471,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_worker#473",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_worker(self, worker_id)",
        "snippet": "    def get_worker(self, worker_id):\n        return self._active_workers.setdefault(worker_id, Worker(worker_id))",
        "begin_line": 473,
        "end_line": 474,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.03225806451612903,
            "pseudo_dstar_susp": 0.07142857142857142,
            "pseudo_tarantula_susp": 0.009433962264150943,
            "pseudo_op2_susp": 0.07692307692307693,
            "pseudo_barinel_susp": 0.009433962264150943
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.inactivate_workers#476",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.inactivate_workers(self, delete_workers)",
        "snippet": "    def inactivate_workers(self, delete_workers):\n        # Mark workers as inactive\n        for worker in delete_workers:\n            self._active_workers.pop(worker)\n\n        # remove workers from tasks\n        for task in self.get_active_tasks():\n            task.stakeholders.difference_update(delete_workers)\n            task.workers.difference_update(delete_workers)",
        "begin_line": 476,
        "end_line": 484,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002421307506053269,
            "pseudo_dstar_susp": 0.00205761316872428,
            "pseudo_tarantula_susp": 0.00398406374501992,
            "pseudo_op2_susp": 0.00205761316872428,
            "pseudo_barinel_susp": 0.004
        }
    },
    {
        "name": "luigi.scheduler.SimpleTaskState.get_necessary_tasks#486",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.SimpleTaskState",
        "signature": "luigi.scheduler.SimpleTaskState.get_necessary_tasks(self)",
        "snippet": "    def get_necessary_tasks(self):\n        necessary_tasks = set()\n        for task in self.get_active_tasks():\n            if task.status not in (DONE, DISABLED) or \\\n                    getattr(task, 'scheduler_disable_time', None) is not None:\n                necessary_tasks.update(task.deps)\n                necessary_tasks.add(task.id)\n        return necessary_tasks",
        "begin_line": 486,
        "end_line": 493,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.__init__#503",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.__init__(self, config=None, resources=None, task_history_impl=None, **kwargs)",
        "snippet": "    def __init__(self, config=None, resources=None, task_history_impl=None, **kwargs):\n        \"\"\"\n        Keyword Arguments:\n        :param config: an object of class \"scheduler\" or None (in which the global instance will be used)\n        :param resources: a dict of str->int constraints\n        :param task_history_override: ignore config and use this object as the task history\n        \"\"\"\n        self._config = config or scheduler(**kwargs)\n        self._state = SimpleTaskState(self._config.state_path)\n\n        if task_history_impl:\n            self._task_history = task_history_impl\n        elif self._config.record_task_history:\n            from luigi import db_task_history  # Needs sqlalchemy, thus imported here\n            self._task_history = db_task_history.DbTaskHistory()\n        else:\n            self._task_history = history.NopHistory()\n        self._resources = resources or configuration.get_config().getintdict('resources')  # TODO: Can we make this a Parameter?\n        self._make_task = functools.partial(\n            Task, disable_failures=self._config.disable_failures,\n            disable_hard_timeout=self._config.disable_hard_timeout,\n            disable_window=self._config.disable_window)",
        "begin_line": 503,
        "end_line": 524,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003289473684210526,
            "pseudo_dstar_susp": 0.003067484662576687,
            "pseudo_tarantula_susp": 0.0045871559633027525,
            "pseudo_op2_susp": 0.003067484662576687,
            "pseudo_barinel_susp": 0.0045871559633027525
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.prune#532",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.prune(self)",
        "snippet": "    def prune(self):\n        logger.info(\"Starting pruning of task graph\")\n        remove_workers = []\n        for worker in self._state.get_active_workers():\n            if worker.prune(self._config):\n                logger.info(\"Worker %s timed out (no contact for >=%ss)\", worker, self._config.worker_disconnect_delay)\n                remove_workers.append(worker.id)\n\n        self._state.inactivate_workers(remove_workers)\n\n        assistant_ids = set(w.id for w in self._state.get_assistants())\n        remove_tasks = []\n\n        if assistant_ids:\n            necessary_tasks = self._state.get_necessary_tasks()\n        else:\n            necessary_tasks = ()\n\n        for task in self._state.get_active_tasks():\n            if task.id not in necessary_tasks and self._state.prune(task, self._config, assistant_ids):\n                remove_tasks.append(task.id)\n\n        self._state.inactivate_tasks(remove_tasks)\n\n        logger.info(\"Done pruning task graph\")",
        "begin_line": 532,
        "end_line": 556,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0024691358024691358,
            "pseudo_dstar_susp": 0.002079002079002079,
            "pseudo_tarantula_susp": 0.00411522633744856,
            "pseudo_op2_susp": 0.002079002079002079,
            "pseudo_barinel_susp": 0.00411522633744856
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.update#558",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.update(self, worker_id, worker_reference=None)",
        "snippet": "    def update(self, worker_id, worker_reference=None):\n        \"\"\"\n        Keep track of whenever the worker was last active.\n        \"\"\"\n        worker = self._state.get_worker(worker_id)\n        worker.update(worker_reference)",
        "begin_line": 558,
        "end_line": 563,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.038461538461538464,
            "pseudo_dstar_susp": 0.08333333333333333,
            "pseudo_tarantula_susp": 0.009433962264150943,
            "pseudo_op2_susp": 0.09090909090909091,
            "pseudo_barinel_susp": 0.009433962264150943
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._update_priority#565",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._update_priority(self, task, prio, worker)",
        "snippet": "    def _update_priority(self, task, prio, worker):\n        \"\"\"\n        Update priority of the given task.\n\n        Priority can only be increased.\n        If the task doesn't exist, a placeholder task is created to preserve priority when the task is later scheduled.\n        \"\"\"\n        task.priority = prio = max(prio, task.priority)\n        for dep in task.deps or []:\n            t = self._state.get_task(dep)\n            if t is not None and prio > t.priority:\n                self._update_priority(t, prio, worker)",
        "begin_line": 565,
        "end_line": 576,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0022988505747126436,
            "pseudo_dstar_susp": 0.0019880715705765406,
            "pseudo_tarantula_susp": 0.0035460992907801418,
            "pseudo_op2_susp": 0.0019880715705765406,
            "pseudo_barinel_susp": 0.0035460992907801418
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.add_task#578",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.add_task(self, task_id=None, status=PENDING, runnable=True, deps=None, new_deps=None, expl=None, resources=None, priority=0, family='', module=None, params=None, assistant=False, **kwargs)",
        "snippet": "    def add_task(self, task_id=None, status=PENDING, runnable=True,\n                 deps=None, new_deps=None, expl=None, resources=None,\n                 priority=0, family='', module=None, params=None,\n                 assistant=False, **kwargs):\n        \"\"\"\n        * add task identified by task_id if it doesn't exist\n        * if deps is not None, update dependency list\n        * update status of task\n        * add additional workers/stakeholders\n        * update priority when needed\n        \"\"\"\n        worker_id = kwargs['worker']\n        self.update(worker_id)\n\n        task = self._state.get_task(task_id, setdefault=self._make_task(\n            task_id=task_id, status=PENDING, deps=deps, resources=resources,\n            priority=priority, family=family, module=module, params=params))\n\n        # for setting priority, we'll sometimes create tasks with unset family and params\n        if not task.family:\n            task.family = family\n        if not getattr(task, 'module', None):\n            task.module = module\n        if not task.params:\n            task.params = _get_default(params, {})\n\n        if task.remove is not None:\n            task.remove = None  # unmark task for removal so it isn't removed after being added\n\n        if not (task.status == RUNNING and status == PENDING):\n            # don't allow re-scheduling of task while it is running, it must either fail or succeed first\n            if status == PENDING or status != task.status:\n                # Update the DB only if there was a acctual change, to prevent noise.\n                # We also check for status == PENDING b/c that's the default value\n                # (so checking for status != task.status woule lie)\n                self._update_task_history(task_id, status)\n            self._state.set_status(task, PENDING if status == SUSPENDED else status, self._config)\n            if status == FAILED:\n                task.retry = time.time() + self._config.retry_delay\n\n        if deps is not None:\n            task.deps = set(deps)\n\n        if new_deps is not None:\n            task.deps.update(new_deps)\n\n        if resources is not None:\n            task.resources = resources\n\n        if not assistant:\n            task.stakeholders.add(worker_id)\n\n            # Task dependencies might not exist yet. Let's create dummy tasks for them for now.\n            # Otherwise the task dependencies might end up being pruned if scheduling takes a long time\n            for dep in task.deps or []:\n                t = self._state.get_task(dep, setdefault=self._make_task(task_id=dep, status=UNKNOWN, deps=None, priority=priority))\n                t.stakeholders.add(worker_id)\n\n        self._update_priority(task, priority, worker_id)\n\n        if runnable:\n            task.workers.add(worker_id)\n            self._state.get_worker(worker_id).tasks.add(task)\n\n        if expl is not None:\n            task.expl = expl",
        "begin_line": 578,
        "end_line": 643,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002336448598130841,
            "pseudo_dstar_susp": 0.002012072434607646,
            "pseudo_tarantula_susp": 0.003676470588235294,
            "pseudo_op2_susp": 0.002012072434607646,
            "pseudo_barinel_susp": 0.003676470588235294
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.add_worker#645",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.add_worker(self, worker, info, **kwargs)",
        "snippet": "    def add_worker(self, worker, info, **kwargs):\n        self._state.get_worker(worker).add_info(info)",
        "begin_line": 645,
        "end_line": 646,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002257336343115124,
            "pseudo_dstar_susp": 0.001968503937007874,
            "pseudo_tarantula_susp": 0.003424657534246575,
            "pseudo_op2_susp": 0.001968503937007874,
            "pseudo_barinel_susp": 0.003424657534246575
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.update_resources#648",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.update_resources(self, **resources)",
        "snippet": "    def update_resources(self, **resources):\n        if self._resources is None:\n            self._resources = {}\n        self._resources.update(resources)",
        "begin_line": 648,
        "end_line": 651,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._has_resources#653",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._has_resources(self, needed_resources, used_resources)",
        "snippet": "    def _has_resources(self, needed_resources, used_resources):\n        if needed_resources is None:\n            return True\n\n        available_resources = self._resources or {}\n        for resource, amount in six.iteritems(needed_resources):\n            if amount + used_resources[resource] > available_resources.get(resource, 1):\n                return False\n        return True",
        "begin_line": 653,
        "end_line": 661,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004496402877697842,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._used_resources#663",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._used_resources(self)",
        "snippet": "    def _used_resources(self):\n        used_resources = collections.defaultdict(int)\n        if self._resources is not None:\n            for task in self._state.get_active_tasks():\n                if task.status == RUNNING and task.resources:\n                    for resource, amount in six.iteritems(task.resources):\n                        used_resources[resource] += amount\n        return used_resources",
        "begin_line": 663,
        "end_line": 670,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._rank#672",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._rank(self, task)",
        "snippet": "    def _rank(self, task):\n        \"\"\"\n        Return worker's rank function for task scheduling.\n\n        :return:\n        \"\"\"\n\n        return task.priority, -task.time",
        "begin_line": 672,
        "end_line": 679,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00044863167339614175,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._schedulable#681",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._schedulable(self, task)",
        "snippet": "    def _schedulable(self, task):\n        if task.status != PENDING:\n            return False\n        for dep in task.deps:\n            dep_task = self._state.get_task(dep, default=None)\n            if dep_task is None or dep_task.status != DONE:\n                return False\n        return True",
        "begin_line": 681,
        "end_line": 688,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00044863167339614175,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.get_work#690",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.get_work(self, host=None, assistant=False, **kwargs)",
        "snippet": "    def get_work(self, host=None, assistant=False, **kwargs):\n        # TODO: remove any expired nodes\n\n        # Algo: iterate over all nodes, find the highest priority node no dependencies and available\n        # resources.\n\n        # Resource checking looks both at currently available resources and at which resources would\n        # be available if all running tasks died and we rescheduled all workers greedily. We do both\n        # checks in order to prevent a worker with many low-priority tasks from starving other\n        # workers with higher priority tasks that share the same resources.\n\n        # TODO: remove tasks that can't be done, figure out if the worker has absolutely\n        # nothing it can wait for\n\n        if self._config.prune_on_get_work:\n            self.prune()\n\n        worker_id = kwargs['worker']\n        # Return remaining tasks that have no FAILED descendants\n        self.update(worker_id, {'host': host})\n        if assistant:\n            self.add_worker(worker_id, [('assistant', assistant)])\n        best_task = None\n        locally_pending_tasks = 0\n        running_tasks = []\n        upstream_table = {}\n\n        greedy_resources = collections.defaultdict(int)\n        n_unique_pending = 0\n\n        worker = self._state.get_worker(worker_id)\n        if worker.is_trivial_worker(self._state):\n            relevant_tasks = worker.get_pending_tasks(self._state)\n            used_resources = collections.defaultdict(int)\n            greedy_workers = dict()  # If there's no resources, then they can grab any task\n        else:\n            relevant_tasks = self._state.get_pending_tasks()\n            used_resources = self._used_resources()\n            greedy_workers = dict((worker.id, worker.info.get('workers', 1))\n                                  for worker in self._state.get_active_workers())\n        tasks = list(relevant_tasks)\n        tasks.sort(key=self._rank, reverse=True)\n\n        for task in tasks:\n            upstream_status = self._upstream_status(task.id, upstream_table)\n            in_workers = (assistant and task.workers) or worker_id in task.workers\n            if task.status == RUNNING and in_workers:\n                # Return a list of currently running tasks to the client,\n                # makes it easier to troubleshoot\n                other_worker = self._state.get_worker(task.worker_running)\n                more_info = {'task_id': task.id, 'worker': str(other_worker)}\n                if other_worker is not None:\n                    more_info.update(other_worker.info)\n                    running_tasks.append(more_info)\n\n            if task.status == PENDING and in_workers and upstream_status != UPSTREAM_DISABLED:\n                locally_pending_tasks += 1\n                if len(task.workers) == 1 and not assistant:\n                    n_unique_pending += 1\n\n            if best_task:\n                continue\n\n            if task.status == RUNNING and (task.worker_running in greedy_workers):\n                greedy_workers[task.worker_running] -= 1\n                for resource, amount in six.iteritems((task.resources or {})):\n                    greedy_resources[resource] += amount\n\n            if self._schedulable(task) and self._has_resources(task.resources, greedy_resources):\n                if in_workers and self._has_resources(task.resources, used_resources):\n                    best_task = task\n                else:\n                    workers = itertools.chain(task.workers, [worker_id]) if assistant else task.workers\n                    for task_worker in workers:\n                        if greedy_workers.get(task_worker, 0) > 0:\n                            # use up a worker\n                            greedy_workers[task_worker] -= 1\n\n                            # keep track of the resources used in greedy scheduling\n                            for resource, amount in six.iteritems((task.resources or {})):\n                                greedy_resources[resource] += amount\n\n                            break\n\n        reply = {'n_pending_tasks': locally_pending_tasks,\n                 'running_tasks': running_tasks,\n                 'task_id': None,\n                 'n_unique_pending': n_unique_pending}\n\n        if best_task:\n            self._state.set_status(best_task, RUNNING, self._config)\n            best_task.worker_running = worker_id\n            best_task.time_running = time.time()\n            self._update_task_history(best_task.id, RUNNING, host=host)\n\n            reply['task_id'] = best_task.id\n            reply['task_family'] = best_task.family\n            reply['task_module'] = getattr(best_task, 'module', None)\n            reply['task_params'] = best_task.params\n\n        return reply",
        "begin_line": 690,
        "end_line": 790,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002257336343115124,
            "pseudo_dstar_susp": 0.001968503937007874,
            "pseudo_tarantula_susp": 0.003424657534246575,
            "pseudo_op2_susp": 0.001968503937007874,
            "pseudo_barinel_susp": 0.003424657534246575
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.ping#792",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.ping(self, **kwargs)",
        "snippet": "    def ping(self, **kwargs):\n        worker_id = kwargs['worker']\n        self.update(worker_id)",
        "begin_line": 792,
        "end_line": 794,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.041666666666666664,
            "pseudo_dstar_susp": 0.14285714285714285,
            "pseudo_tarantula_susp": 0.010416666666666666,
            "pseudo_op2_susp": 0.1111111111111111,
            "pseudo_barinel_susp": 0.010416666666666666
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._upstream_status#796",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._upstream_status(self, task_id, upstream_status_table)",
        "snippet": "    def _upstream_status(self, task_id, upstream_status_table):\n        if task_id in upstream_status_table:\n            return upstream_status_table[task_id]\n        elif self._state.has_task(task_id):\n            task_stack = [task_id]\n\n            while task_stack:\n                dep_id = task_stack.pop()\n                if self._state.has_task(dep_id):\n                    dep = self._state.get_task(dep_id)\n                    if dep.status == DONE:\n                        continue\n                    if dep_id not in upstream_status_table:\n                        if dep.status == PENDING and dep.deps:\n                            task_stack = task_stack + [dep_id] + list(dep.deps)\n                            upstream_status_table[dep_id] = ''  # will be updated postorder\n                        else:\n                            dep_status = STATUS_TO_UPSTREAM_MAP.get(dep.status, '')\n                            upstream_status_table[dep_id] = dep_status\n                    elif upstream_status_table[dep_id] == '' and dep.deps:\n                        # This is the postorder update step when we set the\n                        # status based on the previously calculated child elements\n                        upstream_status = [upstream_status_table.get(task_id, '') for task_id in dep.deps]\n                        upstream_status.append('')  # to handle empty list\n                        status = max(upstream_status, key=UPSTREAM_SEVERITY_KEY)\n                        upstream_status_table[dep_id] = status\n            return upstream_status_table[dep_id]",
        "begin_line": 796,
        "end_line": 822,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00046882325363338024,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._serialize_task#824",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._serialize_task(self, task_id, include_deps=True)",
        "snippet": "    def _serialize_task(self, task_id, include_deps=True):\n        task = self._state.get_task(task_id)\n        ret = {\n            'status': task.status,\n            'workers': list(task.workers),\n            'worker_running': task.worker_running,\n            'time_running': getattr(task, \"time_running\", None),\n            'start_time': task.time,\n            'params': task.params,\n            'name': task.family,\n            'priority': task.priority,\n            'resources': task.resources,\n        }\n        if task.status == DISABLED:\n            ret['re_enable_able'] = task.scheduler_disable_time is not None\n        if include_deps:\n            ret['deps'] = list(task.deps)\n        return ret",
        "begin_line": 824,
        "end_line": 841,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.graph#843",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.graph(self, **kwargs)",
        "snippet": "    def graph(self, **kwargs):\n        self.prune()\n        serialized = {}\n        for task in self._state.get_active_tasks():\n            serialized[task.id] = self._serialize_task(task.id)\n        return serialized",
        "begin_line": 843,
        "end_line": 848,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._recurse_deps#850",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._recurse_deps(self, task_id, serialized)",
        "snippet": "    def _recurse_deps(self, task_id, serialized):\n        if task_id not in serialized:\n            task = self._state.get_task(task_id)\n            if task is None or not task.family:\n                logger.warn('Missing task for id [%s]', task_id)\n\n                # try to infer family and params from task_id\n                try:\n                    family, _, param_str = task_id.rstrip(')').partition('(')\n                    params = dict(param.split('=') for param in param_str.split(', '))\n                except BaseException:\n                    family, params = '', {}\n                serialized[task_id] = {\n                    'deps': [],\n                    'status': UNKNOWN,\n                    'workers': [],\n                    'start_time': UNKNOWN,\n                    'params': params,\n                    'name': family,\n                    'priority': 0,\n                }\n            else:\n                serialized[task_id] = self._serialize_task(task_id)\n                for dep in task.deps:\n                    self._recurse_deps(dep, serialized)",
        "begin_line": 850,
        "end_line": 874,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.dep_graph#876",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.dep_graph(self, task_id, **kwargs)",
        "snippet": "    def dep_graph(self, task_id, **kwargs):\n        self.prune()\n        serialized = {}\n        if self._state.has_task(task_id):\n            self._recurse_deps(task_id, serialized)\n        return serialized",
        "begin_line": 876,
        "end_line": 881,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.task_list#883",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.task_list(self, status, upstream_status, limit=True, search=None, **kwargs)",
        "snippet": "    def task_list(self, status, upstream_status, limit=True, search=None, **kwargs):\n        \"\"\"\n        Query for a subset of tasks by status.\n        \"\"\"\n        self.prune()\n        result = {}\n        upstream_status_table = {}  # used to memoize upstream status\n        if search is None:\n            filter_func = lambda _: True\n        else:\n            terms = search.split()\n            filter_func = lambda t: all(term in t.id for term in terms)\n        for task in filter(filter_func, self._state.get_active_tasks(status)):\n            if (task.status != PENDING or not upstream_status or\n                    upstream_status == self._upstream_status(task.id, upstream_status_table)):\n                serialized = self._serialize_task(task.id, False)\n                result[task.id] = serialized\n        if limit and len(result) > self._config.max_shown_tasks:\n            return {'num_tasks': len(result)}\n        return result",
        "begin_line": 883,
        "end_line": 902,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.worker_list#904",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.worker_list(self, include_running=True, **kwargs)",
        "snippet": "    def worker_list(self, include_running=True, **kwargs):\n        self.prune()\n        workers = [\n            dict(\n                name=worker.id,\n                last_active=worker.last_active,\n                started=getattr(worker, 'started', None),\n                **worker.info\n            ) for worker in self._state.get_active_workers()]\n        workers.sort(key=lambda worker: worker['started'], reverse=True)\n        if include_running:\n            running = collections.defaultdict(dict)\n            num_pending = collections.defaultdict(int)\n            num_uniques = collections.defaultdict(int)\n            for task in self._state.get_pending_tasks():\n                if task.status == RUNNING and task.worker_running:\n                    running[task.worker_running][task.id] = self._serialize_task(task.id, False)\n                elif task.status == PENDING:\n                    for worker in task.workers:\n                        num_pending[worker] += 1\n                    if len(task.workers) == 1:\n                        num_uniques[list(task.workers)[0]] += 1\n            for worker in workers:\n                tasks = running[worker['name']]\n                worker['num_running'] = len(tasks)\n                worker['num_pending'] = num_pending[worker['name']]\n                worker['num_uniques'] = num_uniques[worker['name']]\n                worker['running'] = tasks\n        return workers",
        "begin_line": 904,
        "end_line": 932,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.inverse_dep_graph#934",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.inverse_dep_graph(self, task_id, **kwargs)",
        "snippet": "    def inverse_dep_graph(self, task_id, **kwargs):\n        self.prune()\n        serialized = {}\n        if self._state.has_task(task_id):\n            self._traverse_inverse_deps(task_id, serialized)\n        return serialized",
        "begin_line": 934,
        "end_line": 939,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._traverse_inverse_deps#941",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._traverse_inverse_deps(self, task_id, serialized)",
        "snippet": "    def _traverse_inverse_deps(self, task_id, serialized):\n        stack = [task_id]\n        serialized[task_id] = self._serialize_task(task_id)\n        while len(stack) > 0:\n            curr_id = stack.pop()\n            for task in self._state.get_active_tasks():\n                if curr_id in task.deps:\n                    serialized[curr_id][\"deps\"].append(task.id)\n                    if task.id not in serialized:\n                        serialized[task.id] = self._serialize_task(task.id)\n                        serialized[task.id][\"deps\"] = []\n                        stack.append(task.id)",
        "begin_line": 941,
        "end_line": 952,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.task_search#954",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.task_search(self, task_str, **kwargs)",
        "snippet": "    def task_search(self, task_str, **kwargs):\n        \"\"\"\n        Query for a subset of tasks by task_id.\n\n        :param task_str:\n        :return:\n        \"\"\"\n        self.prune()\n        result = collections.defaultdict(dict)\n        for task in self._state.get_active_tasks():\n            if task.id.find(task_str) != -1:\n                serialized = self._serialize_task(task.id, False)\n                result[task.status][task.id] = serialized\n        return result",
        "begin_line": 954,
        "end_line": 967,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.re_enable_task#969",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.re_enable_task(self, task_id)",
        "snippet": "    def re_enable_task(self, task_id):\n        serialized = {}\n        task = self._state.get_task(task_id)\n        if task and task.status == DISABLED and task.scheduler_disable_time:\n            self._state.re_enable(task, self._config)\n            serialized = self._serialize_task(task_id)\n        return serialized",
        "begin_line": 969,
        "end_line": 975,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler.fetch_error#977",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler.fetch_error(self, task_id, **kwargs)",
        "snippet": "    def fetch_error(self, task_id, **kwargs):\n        if self._state.has_task(task_id):\n            return {\"taskId\": task_id, \"error\": self._state.get_task(task_id).expl}\n        else:\n            return {\"taskId\": task_id, \"error\": \"\"}",
        "begin_line": 977,
        "end_line": 981,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.scheduler.CentralPlannerScheduler._update_task_history#983",
        "src_path": "luigi/scheduler.py",
        "class_name": "luigi.scheduler.CentralPlannerScheduler",
        "signature": "luigi.scheduler.CentralPlannerScheduler._update_task_history(self, task_id, status, host=None)",
        "snippet": "    def _update_task_history(self, task_id, status, host=None):\n        try:\n            if status == DONE or status == FAILED:\n                successful = (status == DONE)\n                self._task_history.task_finished(task_id, successful)\n            elif status == PENDING:\n                self._task_history.task_scheduled(task_id)\n            elif status == RUNNING:\n                self._task_history.task_started(task_id, host)\n        except BaseException:\n            logger.warning(\"Error saving Task history\", exc_info=True)",
        "begin_line": 983,
        "end_line": 993,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002257336343115124,
            "pseudo_dstar_susp": 0.001968503937007874,
            "pseudo_tarantula_susp": 0.003424657534246575,
            "pseudo_op2_susp": 0.001968503937007874,
            "pseudo_barinel_susp": 0.003424657534246575
        }
    },
    {
        "name": "luigi.tools.range.RangeBase.of_cls#106",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase.of_cls(self)",
        "snippet": "    def of_cls(self):\n        if isinstance(self.of, six.string_types):\n            warnings.warn('When using Range programatically, dont pass \"of\" param as string!')\n            return Register.get_task_cls(self.of)\n        return self.of",
        "begin_line": 106,
        "end_line": 110,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004940711462450593,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range.RangeBase._format_range#162",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase._format_range(self, datetimes)",
        "snippet": "    def _format_range(self, datetimes):\n        param_first = self._format_datetime(datetimes[0])\n        param_last = self._format_datetime(datetimes[-1])\n        return '[%s, %s]' % (param_first, param_last)",
        "begin_line": 162,
        "end_line": 165,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004440497335701599,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range.RangeBase.requires#167",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeBase",
        "signature": "luigi.tools.range.RangeBase.requires(self)",
        "snippet": "    def requires(self):\n        # cache because we anticipate a fair amount of computation\n        if hasattr(self, '_cached_requires'):\n            return self._cached_requires\n\n        if not self.start and not self.stop:\n            raise ParameterException(\"At least one of start and stop needs to be specified\")\n        if not self.start and not self.reverse:\n            raise ParameterException(\"Either start needs to be specified or reverse needs to be True\")\n        if self.start and self.stop and self.start > self.stop:\n            raise ParameterException(\"Can't have start > stop\")\n        # TODO check overridden complete() and exists()\n\n        now = datetime.utcfromtimestamp(time.time() if self.now is None else self.now)\n\n        moving_start = self.moving_start(now)\n        finite_start = moving_start if self.start is None else max(self.parameter_to_datetime(self.start), moving_start)\n        moving_stop = self.moving_stop(now)\n        finite_stop = moving_stop if self.stop is None else min(self.parameter_to_datetime(self.stop), moving_stop)\n\n        datetimes = self.finite_datetimes(finite_start, finite_stop) if finite_start <= finite_stop else []\n\n        task_cls = self.of_cls\n        if datetimes:\n            logger.debug('Actually checking if range %s of %s is complete',\n                         self._format_range(datetimes), self.of_cls.task_family)\n            missing_datetimes = sorted(self.missing_datetimes(task_cls, datetimes))\n            logger.debug('Range %s lacked %d of expected %d %s instances',\n                         self._format_range(datetimes), len(missing_datetimes), len(datetimes), self.of_cls.task_family)\n        else:\n            missing_datetimes = []\n            logger.debug('Empty range. No %s instances expected', self.of_cls.task_family)\n\n        self._emit_metrics(missing_datetimes, finite_start, finite_stop)\n\n        if self.reverse:\n            required_datetimes = missing_datetimes[-self.task_limit:]\n        else:\n            required_datetimes = missing_datetimes[:self.task_limit]\n        if required_datetimes:\n            logger.debug('Requiring %d missing %s instances in range %s',\n                         len(required_datetimes), self.of_cls.task_family, self._format_range(required_datetimes))\n        if self.reverse:\n            required_datetimes.reverse()  # TODO priorities, so that within the batch tasks are ordered too\n\n        self._cached_requires = [task_cls(self.datetime_to_parameter(d)) for d in required_datetimes]\n        return self._cached_requires",
        "begin_line": 167,
        "end_line": 213,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005534034311012728,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range.RangeDailyBase.datetime_to_parameter#245",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDailyBase",
        "signature": "luigi.tools.range.RangeDailyBase.datetime_to_parameter(self, dt)",
        "snippet": "    def datetime_to_parameter(self, dt):\n        return dt.date()",
        "begin_line": 245,
        "end_line": 246,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005361930294906167,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range.RangeDailyBase.parameter_to_datetime#248",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDailyBase",
        "signature": "luigi.tools.range.RangeDailyBase.parameter_to_datetime(self, p)",
        "snippet": "    def parameter_to_datetime(self, p):\n        return datetime(p.year, p.month, p.day)",
        "begin_line": 248,
        "end_line": 249,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005827505827505828,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range.RangeDailyBase.finite_datetimes#257",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDailyBase",
        "signature": "luigi.tools.range.RangeDailyBase.finite_datetimes(self, finite_start, finite_stop)",
        "snippet": "    def finite_datetimes(self, finite_start, finite_stop):\n        \"\"\"\n        Simply returns the points in time that correspond to turn of day.\n        \"\"\"\n        date_start = datetime(finite_start.year, finite_start.month, finite_start.day)\n        dates = []\n        for i in itertools.count():\n            t = date_start + timedelta(days=i)\n            if t >= finite_stop:\n                return dates\n            if t >= finite_start:\n                dates.append(t)",
        "begin_line": 257,
        "end_line": 268,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006031363088057901,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.datetime_to_parameter#289",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.datetime_to_parameter(self, dt)",
        "snippet": "    def datetime_to_parameter(self, dt):\n        return dt",
        "begin_line": 289,
        "end_line": 290,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.parameter_to_datetime#292",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.parameter_to_datetime(self, p)",
        "snippet": "    def parameter_to_datetime(self, p):\n        return p",
        "begin_line": 292,
        "end_line": 293,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.moving_start#295",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.moving_start(self, now)",
        "snippet": "    def moving_start(self, now):\n        return now - timedelta(hours=self.hours_back)",
        "begin_line": 295,
        "end_line": 296,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.moving_stop#298",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.moving_stop(self, now)",
        "snippet": "    def moving_stop(self, now):\n        return now + timedelta(hours=self.hours_forward)",
        "begin_line": 298,
        "end_line": 299,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005659309564233164,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase.finite_datetimes#301",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase.finite_datetimes(self, finite_start, finite_stop)",
        "snippet": "    def finite_datetimes(self, finite_start, finite_stop):\n        \"\"\"\n        Simply returns the points in time that correspond to whole hours.\n        \"\"\"\n        datehour_start = datetime(finite_start.year, finite_start.month, finite_start.day, finite_start.hour)\n        datehours = []\n        for i in itertools.count():\n            t = datehour_start + timedelta(hours=i)\n            if t >= finite_stop:\n                return datehours\n            if t >= finite_start:\n                datehours.append(t)",
        "begin_line": 301,
        "end_line": 312,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range.RangeHourlyBase._format_datetime#314",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourlyBase",
        "signature": "luigi.tools.range.RangeHourlyBase._format_datetime(self, dt)",
        "snippet": "    def _format_datetime(self, dt):\n        return luigi.DateHourParameter().serialize(dt)",
        "begin_line": 314,
        "end_line": 315,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range._constrain_glob#318",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range._constrain_glob(glob, paths, limit=5)",
        "snippet": "def _constrain_glob(glob, paths, limit=5):\n    \"\"\"\n    Tweaks glob into a list of more specific globs that together still cover paths and not too much extra.\n\n    Saves us minutes long listings for long dataset histories.\n\n    Specifically, in this implementation the leftmost occurrences of \"[0-9]\"\n    give rise to a few separate globs that each specialize the expression to\n    digits that actually occur in paths.\n    \"\"\"\n\n    def digit_set_wildcard(chars):\n        \"\"\"\n        Makes a wildcard expression for the set, a bit readable, e.g. [1-5].\n        \"\"\"\n        chars = sorted(chars)\n        if len(chars) > 1 and ord(chars[-1]) - ord(chars[0]) == len(chars) - 1:\n            return '[%s-%s]' % (chars[0], chars[-1])\n        else:\n            return '[%s]' % ''.join(chars)\n\n    current = {glob: paths}\n    while True:\n        pos = list(current.keys())[0].find('[0-9]')\n        if pos == -1:\n            # no wildcard expressions left to specialize in the glob\n            return list(current.keys())\n        char_sets = {}\n        for g, p in six.iteritems(current):\n            char_sets[g] = sorted(set(path[pos] for path in p))\n        if sum(len(s) for s in char_sets.values()) > limit:\n            return [g.replace('[0-9]', digit_set_wildcard(char_sets[g]), 1) for g in current]\n        for g, s in six.iteritems(char_sets):\n            for c in s:\n                new_glob = g.replace('[0-9]', c, 1)\n                new_paths = list(filter(lambda p: p[pos] == c, current[g]))\n                current[new_glob] = new_paths\n            del current[g]",
        "begin_line": 318,
        "end_line": 355,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range.digit_set_wildcard#329",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range.digit_set_wildcard(chars)",
        "snippet": "    def digit_set_wildcard(chars):\n        \"\"\"\n        Makes a wildcard expression for the set, a bit readable, e.g. [1-5].\n        \"\"\"\n        chars = sorted(chars)\n        if len(chars) > 1 and ord(chars[-1]) - ord(chars[0]) == len(chars) - 1:\n            return '[%s-%s]' % (chars[0], chars[-1])\n        else:\n            return '[%s]' % ''.join(chars)",
        "begin_line": 329,
        "end_line": 337,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range.most_common#358",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range.most_common(items)",
        "snippet": "def most_common(items):\n    \"\"\"\n    Wanted functionality from Counters (new in Python 2.7).\n    \"\"\"\n    counts = {}\n    for i in items:\n        counts.setdefault(i, 0)\n        counts[i] += 1\n    return max(six.iteritems(counts), key=operator.itemgetter(1))",
        "begin_line": 358,
        "end_line": 366,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range._get_per_location_glob#369",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range._get_per_location_glob(tasks, outputs, regexes)",
        "snippet": "def _get_per_location_glob(tasks, outputs, regexes):\n    \"\"\"\n    Builds a glob listing existing output paths.\n\n    Esoteric reverse engineering, but worth it given that (compared to an\n    equivalent contiguousness guarantee by naive complete() checks)\n    requests to the filesystem are cut by orders of magnitude, and users\n    don't even have to retrofit existing tasks anyhow.\n    \"\"\"\n    paths = [o.path for o in outputs]\n    matches = [r.search(p) for r, p in zip(regexes, paths)]  # naive, because some matches could be confused by numbers earlier in path, e.g. /foo/fifa2000k/bar/2000-12-31/00\n\n    for m, p, t in zip(matches, paths, tasks):\n        if m is None:\n            raise NotImplementedError(\"Couldn't deduce datehour representation in output path %r of task %s\" % (p, t))\n\n    n_groups = len(matches[0].groups())\n    positions = [most_common((m.start(i), m.end(i)) for m in matches)[0] for i in range(1, n_groups + 1)]  # the most common position of every group is likely to be conclusive hit or miss\n\n    glob = list(paths[0])  # FIXME sanity check that it's the same for all paths\n    for start, end in positions:\n        glob = glob[:start] + ['[0-9]'] * (end - start) + glob[end:]\n    return ''.join(glob).rsplit('/', 1)[0]  # chop off the last path item (wouldn't need to if `hadoop fs -ls -d` equivalent were available)",
        "begin_line": 369,
        "end_line": 391,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range._get_filesystems_and_globs#394",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range._get_filesystems_and_globs(datetime_to_task, datetime_to_re)",
        "snippet": "def _get_filesystems_and_globs(datetime_to_task, datetime_to_re):\n    \"\"\"\n    Yields a (filesystem, glob) tuple per every output location of task.\n\n    The task can have one or several FileSystemTarget outputs.\n\n    For convenience, the task can be a luigi.WrapperTask,\n    in which case outputs of all its dependencies are considered.\n    \"\"\"\n    # probe some scattered datetimes unlikely to all occur in paths, other than by being sincere datetime parameter's representations\n    # TODO limit to [self.start, self.stop) so messages are less confusing? Done trivially it can kill correctness\n    sample_datetimes = [datetime(y, m, d, h) for y in range(2000, 2050, 10) for m in range(1, 4) for d in range(5, 8) for h in range(21, 24)]\n    regexes = [re.compile(datetime_to_re(d)) for d in sample_datetimes]\n    sample_tasks = [datetime_to_task(d) for d in sample_datetimes]\n    sample_outputs = [flatten_output(t) for t in sample_tasks]\n\n    for o, t in zip(sample_outputs, sample_tasks):\n        if len(o) != len(sample_outputs[0]):\n            raise NotImplementedError(\"Outputs must be consistent over time, sorry; was %r for %r and %r for %r\" % (o, t, sample_outputs[0], sample_tasks[0]))\n            # TODO fall back on requiring last couple of days? to avoid astonishing blocking when changes like that are deployed\n            # erm, actually it's not hard to test entire hours_back..hours_forward and split into consistent subranges FIXME?\n        for target in o:\n            if not isinstance(target, FileSystemTarget):\n                raise NotImplementedError(\"Output targets must be instances of FileSystemTarget; was %r for %r\" % (target, t))\n\n    for o in zip(*sample_outputs):  # transposed, so here we're iterating over logical outputs, not datetimes\n        glob = _get_per_location_glob(sample_tasks, o, regexes)\n        yield o[0].fs, glob",
        "begin_line": 394,
        "end_line": 421,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range._list_existing#424",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range._list_existing(filesystem, glob, paths)",
        "snippet": "def _list_existing(filesystem, glob, paths):\n    \"\"\"\n    Get all the paths that do in fact exist. Returns a set of all existing paths.\n\n    Takes a luigi.target.FileSystem object, a str which represents a glob and\n    a list of strings representing paths.\n    \"\"\"\n    globs = _constrain_glob(glob, paths)\n    time_start = time.time()\n    listing = []\n    for g in sorted(globs):\n        logger.debug('Listing %s', g)\n        if filesystem.exists(g):\n            listing.extend(filesystem.listdir(g))\n    logger.debug('%d %s listings took %f s to return %d items',\n                 len(globs), filesystem.__class__.__name__, time.time() - time_start, len(listing))\n    return set(listing)",
        "begin_line": 424,
        "end_line": 440,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range.infer_bulk_complete_from_fs#443",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range",
        "signature": "luigi.tools.range.infer_bulk_complete_from_fs(datetimes, datetime_to_task, datetime_to_re)",
        "snippet": "def infer_bulk_complete_from_fs(datetimes, datetime_to_task, datetime_to_re):\n    \"\"\"\n    Efficiently determines missing datetimes by filesystem listing.\n\n    The current implementation works for the common case of a task writing\n    output to a FileSystemTarget whose path is built using strftime with format\n    like '...%Y...%m...%d...%H...', without custom complete() or exists().\n\n    (Eventually Luigi could have ranges of completion as first-class citizens.\n    Then this listing business could be factored away/be provided for\n    explicitly in target API or some kind of a history server.)\n    \"\"\"\n    filesystems_and_globs_by_location = _get_filesystems_and_globs(datetime_to_task, datetime_to_re)\n    paths_by_datetime = [[o.path for o in flatten_output(datetime_to_task(d))] for d in datetimes]\n    listing = set()\n    for (f, g), p in zip(filesystems_and_globs_by_location, zip(*paths_by_datetime)):  # transposed, so here we're iterating over logical outputs, not datetimes\n        listing |= _list_existing(f, g, p)\n\n    # quickly learn everything that's missing\n    missing_datetimes = []\n    for d, p in zip(datetimes, paths_by_datetime):\n        if not set(p) <= listing:\n            missing_datetimes.append(d)\n\n    return missing_datetimes",
        "begin_line": 443,
        "end_line": 467,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range.RangeDaily.missing_datetimes#484",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeDaily",
        "signature": "luigi.tools.range.RangeDaily.missing_datetimes(self, task_cls, finite_datetimes)",
        "snippet": "    def missing_datetimes(self, task_cls, finite_datetimes):\n        try:\n            return set(finite_datetimes) - set(map(self.parameter_to_datetime, task_cls.bulk_complete(map(self.datetime_to_parameter, finite_datetimes))))\n        except NotImplementedError:\n            return infer_bulk_complete_from_fs(\n                finite_datetimes,\n                lambda d: task_cls(self.datetime_to_parameter(d)),\n                lambda d: d.strftime('(%Y).*(%m).*(%d)'))",
        "begin_line": 484,
        "end_line": 491,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.range.RangeHourly.missing_datetimes#510",
        "src_path": "luigi/tools/range.py",
        "class_name": "luigi.tools.range.RangeHourly",
        "signature": "luigi.tools.range.RangeHourly.missing_datetimes(self, task_cls, finite_datetimes)",
        "snippet": "    def missing_datetimes(self, task_cls, finite_datetimes):\n        try:\n            return set(finite_datetimes) - set(map(self.parameter_to_datetime, task_cls.bulk_complete(list(map(self.datetime_to_parameter, finite_datetimes)))))\n        except NotImplementedError:\n            return infer_bulk_complete_from_fs(\n                finite_datetimes,\n                lambda d: task_cls(self.datetime_to_parameter(d)),\n                lambda d: d.strftime('(%Y).*(%m).*(%d).*(%H)'))",
        "begin_line": 510,
        "end_line": 517,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.util.common_params#34",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util",
        "signature": "luigi.util.common_params(task_instance, task_cls)",
        "snippet": "def common_params(task_instance, task_cls):\n    \"\"\"\n    Grab all the values in task_instance that are found in task_cls.\n    \"\"\"\n    if not isinstance(task_cls, task.Register):\n        raise TypeError(\"task_cls must be an uninstantiated Task\")\n\n    task_instance_param_names = dict(task_instance.get_params()).keys()\n    task_cls_param_names = dict(task_cls.get_params()).keys()\n    common_param_names = list(set.intersection(set(task_instance_param_names), set(task_cls_param_names)))\n    common_param_vals = [(key, dict(task_cls.get_params())[key]) for key in common_param_names]\n    common_kwargs = dict([(key, task_instance.param_kwargs[key]) for key in common_param_names])\n    vals = dict(task_instance.get_param_values(common_param_vals, [], common_kwargs))\n    return vals",
        "begin_line": 34,
        "end_line": 47,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.util.Wrapped.clone_parent#94",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.Wrapped",
        "signature": "luigi.util.Wrapped.clone_parent(_self, **args)",
        "snippet": "            def clone_parent(_self, **args):\n                return _self.clone(cls=self.task_to_inherit, **args)",
        "begin_line": 94,
        "end_line": 95,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006031363088057901,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.util.Wrapped.requires#116",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.Wrapped",
        "signature": "luigi.util.Wrapped.requires(_self)",
        "snippet": "            def requires(_self):\n                return _self.clone_parent()",
        "begin_line": 116,
        "end_line": 117,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005186721991701245,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.util.Wrapped.run#147",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util.Wrapped",
        "signature": "luigi.util.Wrapped.run(_self)",
        "snippet": "            def run(_self):\n                i, o = _self.input(), _self.output()\n                f = o.open('w')  # TODO: assert that i, o are Target objects and not complex datastructures\n                for line in i.open('r'):\n                    f.write(line)\n                f.close()",
        "begin_line": 147,
        "end_line": 152,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.util.previous#199",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util",
        "signature": "luigi.util.previous(task)",
        "snippet": "def previous(task):\n    \"\"\"\n    Return a previous Task of the same family.\n\n    By default checks if this task family only has one non-global parameter and if\n    it is a DateParameter, DateHourParameter or DateIntervalParameter in which case\n    it returns with the time decremented by 1 (hour, day or interval)\n    \"\"\"\n    params = task.get_params()\n    previous_params = {}\n    previous_date_params = {}\n\n    for param_name, param_obj in params:\n        param_value = getattr(task, param_name)\n\n        if isinstance(param_obj, parameter.DateParameter):\n            previous_date_params[param_name] = param_value - datetime.timedelta(days=1)\n        elif isinstance(param_obj, parameter.DateMinuteParameter):\n            previous_date_params[param_name] = param_value - datetime.timedelta(minutes=1)\n        elif isinstance(param_obj, parameter.DateHourParameter):\n            previous_date_params[param_name] = param_value - datetime.timedelta(hours=1)\n        elif isinstance(param_obj, parameter.DateIntervalParameter):\n            previous_date_params[param_name] = param_value.prev()\n        else:\n            previous_params[param_name] = param_value\n\n    previous_params.update(previous_date_params)\n\n    if len(previous_date_params) == 0:\n        raise NotImplementedError(\"No task parameter - can't determine previous task\")\n    elif len(previous_date_params) > 1:\n        raise NotImplementedError(\"Too many date-related task parameters - can't determine previous task\")\n    else:\n        return task.clone(**previous_params)",
        "begin_line": 199,
        "end_line": 232,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006711409395973154,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.util.get_previous_completed#235",
        "src_path": "luigi/util.py",
        "class_name": "luigi.util",
        "signature": "luigi.util.get_previous_completed(task, max_steps=10)",
        "snippet": "def get_previous_completed(task, max_steps=10):\n    prev = task\n    for _ in xrange(max_steps):\n        prev = previous(prev)\n        logger.debug(\"Checking if %s is complete\", prev.task_id)\n        if prev.complete():\n            return prev\n    return None",
        "begin_line": 235,
        "end_line": 242,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000630119722747322,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.pyspark_runner.PySparkRunner.__init__#41",
        "src_path": "luigi/contrib/pyspark_runner.py",
        "class_name": "luigi.contrib.pyspark_runner.PySparkRunner",
        "signature": "luigi.contrib.pyspark_runner.PySparkRunner.__init__(self, job, *args)",
        "snippet": "    def __init__(self, job, *args):\n        with open(job, \"rb\") as fd:\n            self.job = pickle.load(fd)\n        self.args = args",
        "begin_line": 41,
        "end_line": 44,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.pyspark_runner.PySparkRunner.run#46",
        "src_path": "luigi/contrib/pyspark_runner.py",
        "class_name": "luigi.contrib.pyspark_runner.PySparkRunner",
        "signature": "luigi.contrib.pyspark_runner.PySparkRunner.run(self)",
        "snippet": "    def run(self):\n        from pyspark import SparkContext, SparkConf\n        conf = SparkConf()\n        self.job.setup(conf)\n        with SparkContext(conf=conf) as sc:\n            self.job.setup_remote(sc)\n            self.job.main(sc, *self.args)",
        "begin_line": 46,
        "end_line": 52,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hdfs.config.load_hadoop_cmd#59",
        "src_path": "luigi/contrib/hdfs/config.py",
        "class_name": "luigi.contrib.hdfs.config",
        "signature": "luigi.contrib.hdfs.config.load_hadoop_cmd()",
        "snippet": "def load_hadoop_cmd():\n    return hadoopcli().command.split()",
        "begin_line": 59,
        "end_line": 60,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.hdfs.hadoopcli_clients.create_hadoopcli_client#39",
        "src_path": "luigi/contrib/hdfs/hadoopcli_clients.py",
        "class_name": "luigi.contrib.hdfs.hadoopcli_clients",
        "signature": "luigi.contrib.hdfs.hadoopcli_clients.create_hadoopcli_client()",
        "snippet": "def create_hadoopcli_client():\n    \"\"\"\n    Given that we want one of the hadoop cli clients (unlike snakebite),\n    this one will return the right one.\n    \"\"\"\n    version = hdfs_config.get_configured_hadoop_version()\n    if version == \"cdh4\":\n        return HdfsClient()\n    elif version == \"cdh3\":\n        return HdfsClientCdh3()\n    elif version == \"apache1\":\n        return HdfsClientApache1()\n    else:\n        raise ValueError(\"Error: Unknown version specified in Hadoop version\"\n                         \"configuration parameter\")",
        "begin_line": 39,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext.__init__#56",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext.__init__(self, host, **kwargs)",
        "snippet": "    def __init__(self, host, **kwargs):\n        self.host = host\n        self.username = kwargs.get('username', None)\n        self.key_file = kwargs.get('key_file', None)\n        self.connect_timeout = kwargs.get('connect_timeout', None)\n        self.port = kwargs.get('port', None)\n        self.no_host_key_check = kwargs.get('no_host_key_check', False)\n        self.sshpass = kwargs.get('sshpass', False)\n        self.tty = kwargs.get('tty', False)",
        "begin_line": 56,
        "end_line": 64,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext._host_ref#76",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext._host_ref(self)",
        "snippet": "    def _host_ref(self):\n        if self.username:\n            return \"{0}@{1}\".format(self.username, self.host)\n        else:\n            return self.host",
        "begin_line": 76,
        "end_line": 80,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext._prepare_cmd#82",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext._prepare_cmd(self, cmd)",
        "snippet": "    def _prepare_cmd(self, cmd):\n        connection_cmd = [\"ssh\", self._host_ref(),\n                          \"-S\", \"none\",  # disable ControlMaster since it causes all sorts of weird behaviour with subprocesses...\n                          ]\n        if self.sshpass:\n            connection_cmd = [\"sshpass\", \"-e\"] + connection_cmd\n        else:\n            connection_cmd += [\"-o\", \"BatchMode=yes\"]  # no password prompts etc\n        if self.port:\n            connection_cmd.extend([\"-p\", self.port])\n\n        if self.connect_timeout is not None:\n            connection_cmd += ['-o', 'ConnectTimeout=%d' % self.connect_timeout]\n\n        if self.no_host_key_check:\n            connection_cmd += ['-o', 'UserKnownHostsFile=/dev/null',\n                               '-o', 'StrictHostKeyChecking=no']\n\n        if self.key_file:\n            connection_cmd.extend([\"-i\", self.key_file])\n\n        if self.tty:\n            connection_cmd.append('-t')\n        return connection_cmd + cmd",
        "begin_line": 82,
        "end_line": 105,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext.Popen#107",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext.Popen(self, cmd, **kwargs)",
        "snippet": "    def Popen(self, cmd, **kwargs):\n        \"\"\"\n        Remote Popen.\n        \"\"\"\n        prefixed_cmd = self._prepare_cmd(cmd)\n        return subprocess.Popen(prefixed_cmd, **kwargs)",
        "begin_line": 107,
        "end_line": 112,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.ssh.RemoteContext.check_output#114",
        "src_path": "luigi/contrib/ssh.py",
        "class_name": "luigi.contrib.ssh.RemoteContext",
        "signature": "luigi.contrib.ssh.RemoteContext.check_output(self, cmd)",
        "snippet": "    def check_output(self, cmd):\n        \"\"\"\n        Execute a shell command remotely and return the output.\n\n        Simplified version of Popen when you only want the output as a string and detect any errors.\n        \"\"\"\n        p = self.Popen(cmd, stdout=subprocess.PIPE)\n        output, _ = p.communicate()\n        if p.returncode != 0:\n            raise subprocess.CalledProcessError(p.returncode, cmd, output=output)\n        return output",
        "begin_line": 114,
        "end_line": 124,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "dummy_test_module.not_imported.UnimportedTask.complete#5",
        "src_path": "dummy_test_module/not_imported.py",
        "class_name": "dummy_test_module.not_imported.UnimportedTask",
        "signature": "dummy_test_module.not_imported.UnimportedTask.complete(self)",
        "snippet": "    def complete(self):\n        return False",
        "begin_line": 5,
        "end_line": 6,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.deprecate_kwarg.new_function#42",
        "src_path": "luigi/deprecate_kwarg.py",
        "class_name": "luigi.deprecate_kwarg",
        "signature": "luigi.deprecate_kwarg.new_function(*args, **kwargs)",
        "snippet": "        def new_function(*args, **kwargs):\n            value = kw_value\n            if old_name in kwargs:\n                warnings.warn('Keyword argument {0} is deprecated, use {1}'\n                              .format(old_name, new_name))\n                value = kwargs[old_name]\n            if new_name in kwargs:\n                value = kwargs[new_name]\n                del kwargs[new_name]\n            kwargs[old_name] = value\n            return function(*args, **kwargs)",
        "begin_line": 42,
        "end_line": 52,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0025575447570332483,
            "pseudo_dstar_susp": 0.004608294930875576,
            "pseudo_tarantula_susp": 0.002232142857142857,
            "pseudo_op2_susp": 0.004608294930875576,
            "pseudo_barinel_susp": 0.002232142857142857
        }
    },
    {
        "name": "luigi.interface.setup_interface_logging#38",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.setup_interface_logging(conf_file=None)",
        "snippet": "def setup_interface_logging(conf_file=None):\n    # use a variable in the function object to determine if it has run before\n    if getattr(setup_interface_logging, \"has_run\", False):\n        return\n\n    if conf_file is None:\n        logger = logging.getLogger('luigi-interface')\n        logger.setLevel(logging.DEBUG)\n\n        stream_handler = logging.StreamHandler()\n        stream_handler.setLevel(logging.DEBUG)\n\n        formatter = logging.Formatter('%(levelname)s: %(message)s')\n        stream_handler.setFormatter(formatter)\n\n        logger.addHandler(stream_handler)\n    else:\n        logging.config.fileConfig(conf_file, disable_existing_loggers=False)\n\n    setup_interface_logging.has_run = True",
        "begin_line": 38,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0018248175182481751,
            "pseudo_dstar_susp": 0.0018214936247723133,
            "pseudo_tarantula_susp": 0.0019646365422396855,
            "pseudo_op2_susp": 0.0018214936247723133,
            "pseudo_barinel_susp": 0.0019646365422396855
        }
    },
    {
        "name": "luigi.interface.WorkerSchedulerFactory.create_local_scheduler#110",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface.WorkerSchedulerFactory",
        "signature": "luigi.interface.WorkerSchedulerFactory.create_local_scheduler(self)",
        "snippet": "    def create_local_scheduler(self):\n        return scheduler.CentralPlannerScheduler(prune_on_get_work=True)",
        "begin_line": 110,
        "end_line": 111,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0015527950310559005,
            "pseudo_dstar_susp": 0.0015527950310559005,
            "pseudo_tarantula_susp": 0.001557632398753894,
            "pseudo_op2_susp": 0.0015527950310559005,
            "pseudo_barinel_susp": 0.001557632398753894
        }
    },
    {
        "name": "luigi.interface.WorkerSchedulerFactory.create_worker#116",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface.WorkerSchedulerFactory",
        "signature": "luigi.interface.WorkerSchedulerFactory.create_worker(self, scheduler, worker_processes, assistant=False)",
        "snippet": "    def create_worker(self, scheduler, worker_processes, assistant=False):\n        return worker.Worker(\n            scheduler=scheduler, worker_processes=worker_processes, assistant=assistant)",
        "begin_line": 116,
        "end_line": 118,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0017730496453900709,
            "pseudo_dstar_susp": 0.0017730496453900709,
            "pseudo_tarantula_susp": 0.0018450184501845018,
            "pseudo_op2_susp": 0.0017730496453900709,
            "pseudo_barinel_susp": 0.0018450184501845018
        }
    },
    {
        "name": "luigi.interface.Interface.run#127",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface.Interface",
        "signature": "luigi.interface.Interface.run(tasks, worker_scheduler_factory=None, override_defaults=None)",
        "snippet": "    def run(tasks, worker_scheduler_factory=None, override_defaults=None):\n        \"\"\"\n        :param tasks:\n        :param worker_scheduler_factory:\n        :param override_defaults:\n        :return: True if all tasks and their dependencies were successfully run (or already completed);\n                 False if any error occurred.\n        \"\"\"\n\n        if worker_scheduler_factory is None:\n            worker_scheduler_factory = WorkerSchedulerFactory()\n        if override_defaults is None:\n            override_defaults = {}\n        env_params = core(**override_defaults)\n        # search for logging configuration path first on the command line, then\n        # in the application config file\n        logging_conf = env_params.logging_conf_file\n        if logging_conf is not None and not os.path.exists(logging_conf):\n            raise Exception(\n                \"Error: Unable to locate specified logging configuration file!\"\n            )\n\n        if not configuration.get_config().getboolean(\n                'core', 'no_configure_logging', False):\n            setup_interface_logging(logging_conf)\n\n        if (not env_params.no_lock and\n                not(lock.acquire_for(env_params.lock_pid_dir, env_params.lock_size))):\n            sys.exit(1)\n\n        if env_params.local_scheduler:\n            sch = worker_scheduler_factory.create_local_scheduler()\n        else:\n            sch = worker_scheduler_factory.create_remote_scheduler(\n                host=env_params.scheduler_host,\n                port=env_params.scheduler_port)\n\n        w = worker_scheduler_factory.create_worker(\n            scheduler=sch, worker_processes=env_params.workers, assistant=env_params.assistant)\n\n        success = True\n        for t in tasks:\n            success &= w.add(t, env_params.parallel_scheduling)\n        logger = logging.getLogger('luigi-interface')\n        logger.info('Done scheduling tasks')\n        if env_params.workers != 0:\n            success &= w.run()\n        w.stop()\n        return success",
        "begin_line": 127,
        "end_line": 175,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002242152466367713,
            "pseudo_dstar_susp": 0.0034129692832764505,
            "pseudo_tarantula_susp": 0.002145922746781116,
            "pseudo_op2_susp": 0.0034129692832764505,
            "pseudo_barinel_susp": 0.002145922746781116
        }
    },
    {
        "name": "luigi.interface.add_task_parameters#178",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.add_task_parameters(parser, task_cls)",
        "snippet": "def add_task_parameters(parser, task_cls):\n    for param_name, param in task_cls.get_params():\n        param.add_to_cmdline_parser(parser, param_name, task_cls.task_family, glob=False)",
        "begin_line": 178,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0034965034965034965,
            "pseudo_dstar_susp": 0.006369426751592357,
            "pseudo_tarantula_susp": 0.004784688995215311,
            "pseudo_op2_susp": 0.006369426751592357,
            "pseudo_barinel_susp": 0.004784688995215311
        }
    },
    {
        "name": "luigi.interface.get_global_parameters#183",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.get_global_parameters()",
        "snippet": "def get_global_parameters():\n    seen_params = set()\n    for task_name, is_without_section, param_name, param in Register.get_all_params():\n        if param in seen_params:\n            continue\n        seen_params.add(param)\n        yield task_name, is_without_section, param_name, param",
        "begin_line": 183,
        "end_line": 189,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005,
            "pseudo_dstar_susp": 0.003816793893129771,
            "pseudo_tarantula_susp": 0.008,
            "pseudo_op2_susp": 0.003816793893129771,
            "pseudo_barinel_susp": 0.008
        }
    },
    {
        "name": "luigi.interface.add_global_parameters#192",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.add_global_parameters(parser)",
        "snippet": "def add_global_parameters(parser):\n    for task_name, is_without_section, param_name, param in get_global_parameters():\n        param.add_to_cmdline_parser(parser, param_name, task_name, glob=True, is_without_section=is_without_section)",
        "begin_line": 192,
        "end_line": 194,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008547008547008548,
            "pseudo_dstar_susp": 0.0072992700729927005,
            "pseudo_tarantula_susp": 0.005952380952380952,
            "pseudo_op2_susp": 0.0072992700729927005,
            "pseudo_barinel_susp": 0.005952380952380952
        }
    },
    {
        "name": "luigi.interface.get_task_parameters#197",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.get_task_parameters(task_cls, args)",
        "snippet": "def get_task_parameters(task_cls, args):\n    # Parse a str->str dict to the correct types\n    params = {}\n    for param_name, param in task_cls.get_params():\n        param.parse_from_args(param_name, task_cls.task_family, args, params)\n    return params",
        "begin_line": 197,
        "end_line": 202,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019569471624266144,
            "pseudo_dstar_susp": 0.001869158878504673,
            "pseudo_tarantula_susp": 0.0021008403361344537,
            "pseudo_op2_susp": 0.001869158878504673,
            "pseudo_barinel_susp": 0.0021008403361344537
        }
    },
    {
        "name": "luigi.interface.set_global_parameters#205",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.set_global_parameters(args)",
        "snippet": "def set_global_parameters(args):\n    # Note that this is not side effect free\n    for task_name, is_without_section, param_name, param in get_global_parameters():\n        param.set_global_from_args(param_name, task_name, args, is_without_section=is_without_section)",
        "begin_line": 205,
        "end_line": 208,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0019193857965451055,
            "pseudo_dstar_susp": 0.001851851851851852,
            "pseudo_tarantula_susp": 0.002061855670103093,
            "pseudo_op2_susp": 0.001851851851851852,
            "pseudo_barinel_susp": 0.002061855670103093
        }
    },
    {
        "name": "luigi.interface.ArgParseInterface.parse_task#216",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface.ArgParseInterface",
        "signature": "luigi.interface.ArgParseInterface.parse_task(self, cmdline_args=None)",
        "snippet": "    def parse_task(self, cmdline_args=None):\n        if cmdline_args is None:\n            cmdline_args = sys.argv[1:]\n\n        parser = argparse.ArgumentParser()\n\n        add_global_parameters(parser)\n\n        task_names = Register.task_names()\n\n        # Parse global arguments and pull out the task name.\n        # We used to do this using subparsers+command, but some issues with\n        # argparse across different versions of Python (2.7.9) made it hard.\n        args, unknown = parser.parse_known_args(args=[a for a in cmdline_args if a != '--help'])\n        if len(unknown) == 0:\n            # In case it included a --help argument, run again\n            parser.parse_known_args(args=cmdline_args)\n            raise SystemExit('No task specified')\n\n        task_name = unknown[0]\n        task_cls = Register.get_task_cls(task_name)\n\n        # Add a subparser to parse task-specific arguments\n        subparsers = parser.add_subparsers(dest='command')\n        subparser = subparsers.add_parser(task_name)\n\n        # Add both task and global params here so that we can support both:\n        # test.py --global-param xyz Test --n 42\n        # test.py Test --n 42 --global-param xyz\n        add_global_parameters(subparser)\n        add_task_parameters(subparser, task_cls)\n\n        # Workaround for bug in argparse for Python 2.7.9\n        # See https://mail.python.org/pipermail/python-dev/2015-January/137699.html\n        subargs = parser.parse_args(args=cmdline_args)\n        for key, value in vars(subargs).items():\n            if value:  # Either True (for boolean args) or non-None (everything else)\n                setattr(args, key, value)\n\n        # Notice that this is not side effect free because it might set global params\n        set_global_parameters(args)\n        task_params = get_task_parameters(task_cls, args)\n\n        return [task_cls(**task_params)]",
        "begin_line": 216,
        "end_line": 259,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005050505050505051,
            "pseudo_dstar_susp": 0.005555555555555556,
            "pseudo_tarantula_susp": 0.00510204081632653,
            "pseudo_op2_susp": 0.005555555555555556,
            "pseudo_barinel_susp": 0.00510204081632653
        }
    },
    {
        "name": "luigi.interface.ArgParseInterface.parse#261",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface.ArgParseInterface",
        "signature": "luigi.interface.ArgParseInterface.parse(self, cmdline_args=None)",
        "snippet": "    def parse(self, cmdline_args=None):\n        return self.parse_task(cmdline_args)",
        "begin_line": 261,
        "end_line": 262,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009523809523809525,
            "pseudo_dstar_susp": 0.004464285714285714,
            "pseudo_tarantula_susp": 0.011111111111111112,
            "pseudo_op2_susp": 0.004464285714285714,
            "pseudo_barinel_susp": 0.011235955056179775
        }
    },
    {
        "name": "luigi.interface.DynamicArgParseInterface.parse#278",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface.DynamicArgParseInterface",
        "signature": "luigi.interface.DynamicArgParseInterface.parse(self, cmdline_args=None)",
        "snippet": "    def parse(self, cmdline_args=None):\n        if cmdline_args is None:\n            cmdline_args = sys.argv[1:]\n\n        parser = argparse.ArgumentParser()\n\n        add_global_parameters(parser)\n\n        args, unknown = parser.parse_known_args(args=[a for a in cmdline_args if a != '--help'])\n        module = args.module\n\n        if module:\n            __import__(module)\n\n        return self.parse_task(cmdline_args)",
        "begin_line": 278,
        "end_line": 292,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.002325581395348837,
            "pseudo_tarantula_susp": 0.038461538461538464,
            "pseudo_op2_susp": 0.002325581395348837,
            "pseudo_barinel_susp": 0.038461538461538464
        }
    },
    {
        "name": "luigi.interface.run#295",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.run(cmdline_args=None, main_task_cls=None, worker_scheduler_factory=None, use_dynamic_argparse=False, local_scheduler=False)",
        "snippet": "def run(cmdline_args=None, main_task_cls=None,\n        worker_scheduler_factory=None, use_dynamic_argparse=False, local_scheduler=False):\n    \"\"\"\n    Please dont use. Instead use `luigi` binary.\n\n    Run from cmdline using argparse.\n\n    :param cmdline_args:\n    :param main_task_cls:\n    :param worker_scheduler_factory:\n    :param use_dynamic_argparse:\n    :param local_scheduler:\n    \"\"\"\n    if cmdline_args is None:\n        cmdline_args = sys.argv[1:]\n\n    if use_dynamic_argparse:\n        interface = DynamicArgParseInterface()\n    else:\n        interface = ArgParseInterface()\n    if main_task_cls:\n        cmdline_args.insert(0, main_task_cls.task_family)\n    if local_scheduler:\n        cmdline_args.insert(0, '--local-scheduler')\n    tasks = interface.parse(cmdline_args)\n    return interface.run(tasks, worker_scheduler_factory)",
        "begin_line": 295,
        "end_line": 320,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0072992700729927005,
            "pseudo_dstar_susp": 0.003289473684210526,
            "pseudo_tarantula_susp": 0.010869565217391304,
            "pseudo_op2_susp": 0.003289473684210526,
            "pseudo_barinel_susp": 0.010869565217391304
        }
    },
    {
        "name": "luigi.interface.build#323",
        "src_path": "luigi/interface.py",
        "class_name": "luigi.interface",
        "signature": "luigi.interface.build(tasks, worker_scheduler_factory=None, **env_params)",
        "snippet": "def build(tasks, worker_scheduler_factory=None, **env_params):\n    \"\"\"\n    Run internally, bypassing the cmdline parsing.\n\n    Useful if you have some luigi code that you want to run internally.\n    Example:\n\n    .. code-block:: python\n\n        luigi.build([MyTask1(), MyTask2()], local_scheduler=True)\n\n    One notable difference is that `build` defaults to not using\n    the identical process lock. Otherwise, `build` would only be\n    callable once from each process.\n\n    :param tasks:\n    :param worker_scheduler_factory:\n    :param env_params:\n    :return:\n    \"\"\"\n    if \"no_lock\" not in env_params:\n        env_params[\"no_lock\"] = True\n\n    Interface.run(tasks, worker_scheduler_factory, override_defaults=env_params)",
        "begin_line": 323,
        "end_line": 346,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.file.atomic_file.move_to_final_destination#38",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.atomic_file",
        "signature": "luigi.file.atomic_file.move_to_final_destination(self)",
        "snippet": "    def move_to_final_destination(self):\n        os.rename(self.tmp_path, self.path)",
        "begin_line": 38,
        "end_line": 39,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005827505827505828,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.file.atomic_file.generate_tmp_path#41",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.atomic_file",
        "signature": "luigi.file.atomic_file.generate_tmp_path(self, path)",
        "snippet": "    def generate_tmp_path(self, path):\n        return path + '-luigi-tmp-%09d' % random.randrange(0, 1e10)",
        "begin_line": 41,
        "end_line": 42,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005827505827505828,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.file.LocalFileSystem.exists#52",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalFileSystem",
        "signature": "luigi.file.LocalFileSystem.exists(self, path)",
        "snippet": "    def exists(self, path):\n        return os.path.exists(path)",
        "begin_line": 52,
        "end_line": 53,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004366812227074236,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.file.LocalFileSystem.mkdir#55",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalFileSystem",
        "signature": "luigi.file.LocalFileSystem.mkdir(self, path, parents=True, raise_if_exists=False)",
        "snippet": "    def mkdir(self, path, parents=True, raise_if_exists=False):\n        if self.exists(path):\n            if raise_if_exists:\n                raise FileAlreadyExists()\n            elif not self.isdir(path):\n                raise NotADirectory()\n            else:\n                return\n\n        if parents:\n            os.makedirs(path)\n        else:\n            if not os.path.exists(os.path.dirname(path)):\n                raise MissingParentDirectory()\n            os.mkdir(path)",
        "begin_line": 55,
        "end_line": 69,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.file.LocalFileSystem.isdir#71",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalFileSystem",
        "signature": "luigi.file.LocalFileSystem.isdir(self, path)",
        "snippet": "    def isdir(self, path):\n        return os.path.isdir(path)",
        "begin_line": 71,
        "end_line": 72,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0007251631617113851,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.file.LocalFileSystem.remove#80",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalFileSystem",
        "signature": "luigi.file.LocalFileSystem.remove(self, path, recursive=True)",
        "snippet": "    def remove(self, path, recursive=True):\n        if recursive and self.isdir(path):\n            shutil.rmtree(path)\n        else:\n            os.remove(path)",
        "begin_line": 80,
        "end_line": 84,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.file.LocalTarget.__init__#90",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalTarget",
        "signature": "luigi.file.LocalTarget.__init__(self, path=None, format=None, is_tmp=False)",
        "snippet": "    def __init__(self, path=None, format=None, is_tmp=False):\n        if format is None:\n            format = get_default_format()\n\n        if not path:\n            if not is_tmp:\n                raise Exception('path or is_tmp must be set')\n            path = os.path.join(tempfile.gettempdir(), 'luigi-tmp-%09d' % random.randint(0, 999999999))\n        super(LocalTarget, self).__init__(path)\n        self.format = format\n        self.is_tmp = is_tmp",
        "begin_line": 90,
        "end_line": 100,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0004123711340206186,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.file.LocalTarget.makedirs#102",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalTarget",
        "signature": "luigi.file.LocalTarget.makedirs(self)",
        "snippet": "    def makedirs(self):\n        \"\"\"\n        Create all parent folders if they do not exist.\n        \"\"\"\n        normpath = os.path.normpath(self.path)\n        parentfolder = os.path.dirname(normpath)\n        if parentfolder and not os.path.exists(parentfolder):\n            os.makedirs(parentfolder)",
        "begin_line": 102,
        "end_line": 109,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00040666937779585197,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.file.LocalTarget.open#111",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalTarget",
        "signature": "luigi.file.LocalTarget.open(self, mode='r')",
        "snippet": "    def open(self, mode='r'):\n        if mode == 'w':\n            self.makedirs()\n            return self.format.pipe_writer(atomic_file(self.path))\n\n        elif mode == 'r':\n            fileobj = FileWrapper(io.BufferedReader(io.FileIO(self.path, 'r')))\n            return self.format.pipe_reader(fileobj)\n\n        else:\n            raise Exception('mode must be r/w')",
        "begin_line": 111,
        "end_line": 121,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.00042607584149978694,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.file.LocalTarget.move#123",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalTarget",
        "signature": "luigi.file.LocalTarget.move(self, new_path, raise_if_exists=False)",
        "snippet": "    def move(self, new_path, raise_if_exists=False):\n        if raise_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        d = os.path.dirname(new_path)\n        if d and not os.path.exists(d):\n            self.fs.mkdir(d)\n        os.rename(self.path, new_path)",
        "begin_line": 123,
        "end_line": 129,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005091649694501018,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.file.LocalTarget.remove#134",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalTarget",
        "signature": "luigi.file.LocalTarget.remove(self)",
        "snippet": "    def remove(self):\n        self.fs.remove(self.path)",
        "begin_line": 134,
        "end_line": 135,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.file.LocalTarget.copy#137",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalTarget",
        "signature": "luigi.file.LocalTarget.copy(self, new_path, raise_if_exists=False)",
        "snippet": "    def copy(self, new_path, raise_if_exists=False):\n        if raise_if_exists and os.path.exists(new_path):\n            raise RuntimeError('Destination exists: %s' % new_path)\n        tmp = LocalTarget(new_path + '-luigi-tmp-%09d' % random.randrange(0, 1e10), is_tmp=True)\n        tmp.makedirs()\n        shutil.copy(self.path, tmp.fn)\n        tmp.move(new_path)",
        "begin_line": 137,
        "end_line": 143,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0006031363088057901,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.file.LocalTarget.__del__#149",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.LocalTarget",
        "signature": "luigi.file.LocalTarget.__del__(self)",
        "snippet": "    def __del__(self):\n        if self.is_tmp and self.exists():\n            self.remove()",
        "begin_line": 149,
        "end_line": 151,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0003920031360250882,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.file.File.__init__#155",
        "src_path": "luigi/file.py",
        "class_name": "luigi.file.File",
        "signature": "luigi.file.File.__init__(self, *args, **kwargs)",
        "snippet": "    def __init__(self, *args, **kwargs):\n        warnings.warn(\"File has been renamed LocalTarget\", DeprecationWarning, stacklevel=2)\n        super(File, self).__init__(*args, **kwargs)",
        "begin_line": 155,
        "end_line": 157,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.tools.parse_task.id_to_name_and_params#21",
        "src_path": "luigi/tools/parse_task.py",
        "class_name": "luigi.tools.parse_task",
        "signature": "luigi.tools.parse_task.id_to_name_and_params(task_id)",
        "snippet": "def id_to_name_and_params(task_id):\n    \"\"\"\n    Turn a task_id into a (task_family, {params}) tuple.\n\n    E.g. calling with ``Foo(bar=bar, baz=baz)`` returns ``('Foo', {'bar': 'bar', 'baz': 'baz'})``.\n    \"\"\"\n\n    warnings.warn(\n        'id_to_name_and_params is deprecated (and moved to luigi.tools.parse_task). '\n        'Please don\\'t use task names as a serialization mechanism. Rather, store '\n        'the task family and the parameters as separate strings',\n        DeprecationWarning,\n        stacklevel=2)\n\n    name_chars = pp.alphanums + '_.'\n    # modified version of pp.printables. Removed '[]', '()', ','\n    value_chars = pp.alphanums + '\\'!\"#$%&*+-./:;<=>?@\\\\^_`{|}~'\n    parameter = (\n        (pp.Word(name_chars) +\n         pp.Literal('=').suppress() +\n         ((pp.Literal('(').suppress() | pp.Literal('[').suppress()) +\n          pp.ZeroOrMore(pp.Word(value_chars) +\n                        pp.ZeroOrMore(pp.Literal(',')).suppress()) +\n          (pp.Literal(')').suppress() |\n           pp.Literal(']').suppress()))).setResultsName('list_params',\n                                                        listAllMatches=True) |\n        (pp.Word(name_chars) +\n         pp.Literal('=').suppress() +\n         pp.Word(value_chars)).setResultsName('params', listAllMatches=True))\n\n    parser = (\n        pp.Word(name_chars).setResultsName('task') +\n        pp.Literal('(').suppress() +\n        pp.ZeroOrMore(parameter + (pp.Literal(',')).suppress()) +\n        pp.ZeroOrMore(parameter) +\n        pp.Literal(')').suppress())\n\n    parsed = parser.parseString(task_id).asDict()\n    task_name = parsed['task']\n\n    params = {}\n    if 'params' in parsed:\n        for k, v in parsed['params']:\n            params[k] = v\n    if 'list_params' in parsed:\n        for x in parsed['list_params']:\n            params[x[0]] = x[1:]\n    return task_name, params",
        "begin_line": 21,
        "end_line": 68,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009174311926605505,
            "pseudo_dstar_susp": 0.007692307692307693,
            "pseudo_tarantula_susp": 0.009009009009009009,
            "pseudo_op2_susp": 0.007692307692307693,
            "pseudo_barinel_susp": 0.009009009009009009
        }
    },
    {
        "name": "luigi.contrib.rdbms.CopyToTable.update_id#98",
        "src_path": "luigi/contrib/rdbms.py",
        "class_name": "luigi.contrib.rdbms.CopyToTable",
        "signature": "luigi.contrib.rdbms.CopyToTable.update_id(self)",
        "snippet": "    def update_id(self):\n        \"\"\"\n        This update id will be a unique identifier for this insert on this table.\n        \"\"\"\n        return self.task_id",
        "begin_line": 98,
        "end_line": 102,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.contrib.rdbms.CopyToTable.init_copy#108",
        "src_path": "luigi/contrib/rdbms.py",
        "class_name": "luigi.contrib.rdbms.CopyToTable",
        "signature": "luigi.contrib.rdbms.CopyToTable.init_copy(self, connection)",
        "snippet": "    def init_copy(self, connection):\n        \"\"\"\n        Override to perform custom queries.\n\n        Any code here will be formed in the same transaction as the main copy, just prior to copying data.\n        Example use cases include truncating the table or removing all data older than X in the database\n        to keep a rolling window of data available in the table.\n        \"\"\"\n\n        # TODO: remove this after sufficient time so most people using the\n        # clear_table attribtue will have noticed it doesn't work anymore\n        if hasattr(self, \"clear_table\"):\n            raise Exception(\"The clear_table attribute has been removed. Override init_copy instead!\")",
        "begin_line": 108,
        "end_line": 120,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.six._LazyDescr.__get__#94",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six._LazyDescr",
        "signature": "luigi.six._LazyDescr.__get__(self, obj, tp)",
        "snippet": "    def __get__(self, obj, tp):\n        result = self._resolve()\n        setattr(obj, self.name, result) # Invokes __set__.\n        try:\n            # This is a bit ugly, but it avoids running this again by\n            # removing this descriptor.\n            delattr(obj.__class__, self.name)\n        except AttributeError:\n            pass\n        return result",
        "begin_line": 94,
        "end_line": 103,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.six._SixMetaPathImporter.find_module#185",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six._SixMetaPathImporter",
        "signature": "luigi.six._SixMetaPathImporter.find_module(self, fullname, path=None)",
        "snippet": "    def find_module(self, fullname, path=None):\n        if fullname in self.known_modules:\n            return self\n        return None",
        "begin_line": 185,
        "end_line": 188,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.012195121951219513,
            "pseudo_dstar_susp": 0.002325581395348837,
            "pseudo_tarantula_susp": 0.038461538461538464,
            "pseudo_op2_susp": 0.002325581395348837,
            "pseudo_barinel_susp": 0.038461538461538464
        }
    },
    {
        "name": "luigi.six.itervalues#559",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six",
        "signature": "luigi.six.itervalues(d, **kw)",
        "snippet": "    def itervalues(d, **kw):\n        return iter(d.values(**kw))",
        "begin_line": 559,
        "end_line": 560,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.004081632653061225,
            "pseudo_dstar_susp": 0.0021645021645021645,
            "pseudo_tarantula_susp": 0.01,
            "pseudo_op2_susp": 0.0021645021645021645,
            "pseudo_barinel_susp": 0.01
        }
    },
    {
        "name": "luigi.six.iteritems#562",
        "src_path": "luigi/six.py",
        "class_name": "luigi.six",
        "signature": "luigi.six.iteritems(d, **kw)",
        "snippet": "    def iteritems(d, **kw):\n        return iter(d.items(**kw))",
        "begin_line": 562,
        "end_line": 563,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.017543859649122806,
            "pseudo_dstar_susp": 0.006535947712418301,
            "pseudo_tarantula_susp": 0.010526315789473684,
            "pseudo_op2_susp": 0.006535947712418301,
            "pseudo_barinel_susp": 0.010526315789473684
        }
    },
    {
        "name": "luigi.notifications.email_type#43",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.email_type()",
        "snippet": "def email_type():\n    return configuration.get_config().get('core', 'email-type', 'plain')",
        "begin_line": 43,
        "end_line": 44,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005659309564233164,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.notifications.generate_email#47",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.generate_email(sender, subject, message, recipients, image_png)",
        "snippet": "def generate_email(sender, subject, message, recipients, image_png):\n    import email\n    import email.mime\n    import email.mime.multipart\n    import email.mime.text\n    import email.mime.image\n\n    msg_root = email.mime.multipart.MIMEMultipart('related')\n\n    msg_text = email.mime.text.MIMEText(message, email_type())\n    msg_text.set_charset('utf-8')\n    msg_root.attach(msg_text)\n\n    if image_png:\n        fp = open(image_png, 'rb')\n        msg_image = email.mime.image.MIMEImage(fp.read(), 'png')\n        fp.close()\n        msg_root.attach(msg_image)\n\n    msg_root['Subject'] = subject\n    msg_root['From'] = sender\n    msg_root['To'] = ','.join(recipients)\n\n    return msg_root",
        "begin_line": 47,
        "end_line": 70,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.000846740050804403,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.notifications.send_error_email#160",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications.send_error_email(subject, message)",
        "snippet": "def send_error_email(subject, message):\n    \"\"\"\n    Sends an email to the configured error-email.\n\n    If no error-email is configured, then a message is logged.\n    \"\"\"\n    config = configuration.get_config()\n    receiver = config.get('core', 'error-email', None)\n    if receiver:\n        sender = config.get('core', 'email-sender', DEFAULT_CLIENT_EMAIL)\n        logger.info(\"Sending warning email to %r\", receiver)\n        send_email(\n            subject=subject,\n            message=message,\n            sender=sender,\n            recipients=(receiver,)\n        )\n    else:\n        logger.info(\"Skipping error email. Set `error-email` in the `core` \"\n                    \"section of the luigi config file to receive error \"\n                    \"emails.\")",
        "begin_line": 160,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0005091649694501018,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    },
    {
        "name": "luigi.notifications._prefix#183",
        "src_path": "luigi/notifications.py",
        "class_name": "luigi.notifications",
        "signature": "luigi.notifications._prefix(subject)",
        "snippet": "def _prefix(subject):\n    \"\"\"\n    If the config has a special prefix for emails then this function adds\n    this prefix.\n    \"\"\"\n    config = configuration.get_config()\n    email_prefix = config.get('core', 'email-prefix', None)\n    if email_prefix is not None:\n        subject = \"%s %s\" % (email_prefix, subject)\n    return subject",
        "begin_line": 183,
        "end_line": 192,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0005906674542232723,
            "pseudo_dstar_susp": 0.0005906674542232723,
            "pseudo_tarantula_susp": 0.0005906674542232723,
            "pseudo_op2_susp": 0.0011389521640091116,
            "pseudo_barinel_susp": 0.0005906674542232723
        }
    }
]