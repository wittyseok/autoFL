[
    {
        "name": "pandas.tests.frame.conftest.float_frame_with_na#9",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.float_frame_with_na()",
        "snippet": "def float_frame_with_na():\n    \"\"\"\n    Fixture for DataFrame of floats with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']; some entries are missing\n\n                       A         B         C         D\n    ABwBzA0ljw -1.128865 -0.897161  0.046603  0.274997\n    DJiRzmbyQF  0.728869  0.233502  0.722431 -0.890872\n    neMgPD5UBF  0.486072 -1.027393 -0.031553  1.449522\n    0yWA4n8VeX -1.937191 -1.142531  0.805215 -0.462018\n    3slYUbbqU1  0.153260  1.164691  1.489795 -0.545826\n    soujjZ0A08       NaN       NaN       NaN       NaN\n    7W6NLGsjB9       NaN       NaN       NaN       NaN\n    ...              ...       ...       ...       ...\n    uhfeaNkCR1 -0.231210 -0.340472  0.244717 -0.901590\n    n6p7GYuBIV -0.419052  1.922721 -0.125361 -0.727717\n    ZhzAeY6p1y  1.234374 -1.425359 -0.827038 -0.633189\n    uWdPsORyUh  0.046738 -0.980445 -1.102965  0.605503\n    3DJA6aN590 -0.091018 -1.684734 -1.100900  0.215947\n    2GBPAzdbMk -2.883405 -1.021071  1.209877  1.633083\n    sHadBoyVHw -2.223032 -0.326384  0.258931  0.245517\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    # set some NAs\n    df.loc[5:10] = np.nan\n    df.loc[15:20, -2:] = np.nan\n    return df",
        "begin_line": 9,
        "end_line": 38,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.bool_frame_with_na#42",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.bool_frame_with_na()",
        "snippet": "def bool_frame_with_na():\n    \"\"\"\n    Fixture for DataFrame of booleans with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']; some entries are missing\n\n                    A      B      C      D\n    zBZxY2IDGd  False  False  False  False\n    IhBWBMWllt  False   True   True   True\n    ctjdvZSR6R   True  False   True   True\n    AVTujptmxb  False   True  False   True\n    G9lrImrSWq  False  False  False   True\n    sFFwdIUfz2    NaN    NaN    NaN    NaN\n    s15ptEJnRb    NaN    NaN    NaN    NaN\n    ...           ...    ...    ...    ...\n    UW41KkDyZ4   True   True  False  False\n    l9l6XkOdqV   True  False  False  False\n    X2MeZfzDYA  False   True  False  False\n    xWkIKU7vfX  False   True  False   True\n    QOhL6VmpGU  False  False  False   True\n    22PwkRJdat  False   True  False  False\n    kfboQ3VeIK   True  False   True  False\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData()) > 0\n    df = df.astype(object)\n    # set some NAs\n    df.loc[5:10] = np.nan\n    df.loc[15:20, -2:] = np.nan\n    return df",
        "begin_line": 42,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.int_frame#76",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.int_frame()",
        "snippet": "def int_frame():\n    \"\"\"\n    Fixture for DataFrame of ints with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D']\n\n                A  B  C  D\n    vpBeWjM651  1  0  1  0\n    5JyxmrP1En -1  0  0  0\n    qEDaoD49U2 -1  1  0  0\n    m66TkTfsFe  0  0  0  0\n    EHPaNzEUFm -1  0 -1  0\n    fpRJCevQhi  2  0  0  0\n    OlQvnmfi3Q  0  0 -2  0\n    ...        .. .. .. ..\n    uB1FPlz4uP  0  0  0  1\n    EcSe6yNzCU  0  0 -1  0\n    L50VudaiI8 -1  1 -2  0\n    y3bpw4nwIp  0 -1  0  0\n    H0RdLLwrCT  1  1  0  0\n    rY82K0vMwm  0  0  0  0\n    1OPIUjnkjk  2  0  0  0\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame({k: v.astype(int) for k, v in tm.getSeriesData().items()})\n    # force these all to int64 to avoid platform testing issues\n    return DataFrame({c: s for c, s in df.items()}, dtype=np.int64)",
        "begin_line": 76,
        "end_line": 103,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.datetime_frame#107",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.datetime_frame()",
        "snippet": "def datetime_frame():\n    \"\"\"\n    Fixture for DataFrame of floats with DatetimeIndex\n\n    Columns are ['A', 'B', 'C', 'D']\n\n                       A         B         C         D\n    2000-01-03 -1.122153  0.468535  0.122226  1.693711\n    2000-01-04  0.189378  0.486100  0.007864 -1.216052\n    2000-01-05  0.041401 -0.835752 -0.035279 -0.414357\n    2000-01-06  0.430050  0.894352  0.090719  0.036939\n    2000-01-07 -0.620982 -0.668211 -0.706153  1.466335\n    2000-01-10 -0.752633  0.328434 -0.815325  0.699674\n    2000-01-11 -2.236969  0.615737 -0.829076 -1.196106\n    ...              ...       ...       ...       ...\n    2000-02-03  1.642618 -0.579288  0.046005  1.385249\n    2000-02-04 -0.544873 -1.160962 -0.284071 -1.418351\n    2000-02-07 -2.656149 -0.601387  1.410148  0.444150\n    2000-02-08 -1.201881 -1.289040  0.772992 -1.445300\n    2000-02-09  1.377373  0.398619  1.008453 -0.928207\n    2000-02-10  0.473194 -0.636677  0.984058  0.511519\n    2000-02-11 -0.965556  0.408313 -1.312844 -0.381948\n\n    [30 rows x 4 columns]\n    \"\"\"\n    return DataFrame(tm.getTimeSeriesData())",
        "begin_line": 107,
        "end_line": 132,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.float_string_frame#136",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.float_string_frame()",
        "snippet": "def float_string_frame():\n    \"\"\"\n    Fixture for DataFrame of floats and strings with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D', 'foo'].\n\n                       A         B         C         D  foo\n    w3orJvq07g -1.594062 -1.084273 -1.252457  0.356460  bar\n    PeukuVdmz2  0.109855 -0.955086 -0.809485  0.409747  bar\n    ahp2KvwiM8 -1.533729 -0.142519 -0.154666  1.302623  bar\n    3WSJ7BUCGd  2.484964  0.213829  0.034778 -2.327831  bar\n    khdAmufk0U -0.193480 -0.743518 -0.077987  0.153646  bar\n    LE2DZiFlrE -0.193566 -1.343194 -0.107321  0.959978  bar\n    HJXSJhVn7b  0.142590  1.257603 -0.659409 -0.223844  bar\n    ...              ...       ...       ...       ...  ...\n    9a1Vypttgw -1.316394  1.601354  0.173596  1.213196  bar\n    h5d1gVFbEy  0.609475  1.106738 -0.155271  0.294630  bar\n    mK9LsTQG92  1.303613  0.857040 -1.019153  0.369468  bar\n    oOLksd9gKH  0.558219 -0.134491 -0.289869 -0.951033  bar\n    9jgoOjKyHg  0.058270 -0.496110 -0.413212 -0.852659  bar\n    jZLDHclHAO  0.096298  1.267510  0.549206 -0.005235  bar\n    lR0nxDp1C2 -2.119350 -0.794384  0.544118  0.145849  bar\n\n    [30 rows x 5 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    df[\"foo\"] = \"bar\"\n    return df",
        "begin_line": 136,
        "end_line": 163,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_float_frame#167",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_float_frame()",
        "snippet": "def mixed_float_frame():\n    \"\"\"\n    Fixture for DataFrame of different float types with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D'].\n\n                       A         B         C         D\n    GI7bbDaEZe -0.237908 -0.246225 -0.468506  0.752993\n    KGp9mFepzA -1.140809 -0.644046 -1.225586  0.801588\n    VeVYLAb1l2 -1.154013 -1.677615  0.690430 -0.003731\n    kmPME4WKhO  0.979578  0.998274 -0.776367  0.897607\n    CPyopdXTiz  0.048119 -0.257174  0.836426  0.111266\n    0kJZQndAj0  0.274357 -0.281135 -0.344238  0.834541\n    tqdwQsaHG8 -0.979716 -0.519897  0.582031  0.144710\n    ...              ...       ...       ...       ...\n    7FhZTWILQj -2.906357  1.261039 -0.780273 -0.537237\n    4pUDPM4eGq -2.042512 -0.464382 -0.382080  1.132612\n    B8dUgUzwTi -1.506637 -0.364435  1.087891  0.297653\n    hErlVYjVv9  1.477453 -0.495515 -0.713867  1.438427\n    1BKN3o7YLs  0.127535 -0.349812 -0.881836  0.489827\n    9S4Ekn7zga  1.445518 -2.095149  0.031982  0.373204\n    xN1dNn6OV6  1.425017 -0.983995 -0.363281 -0.224502\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame(tm.getSeriesData())\n    df.A = df.A.astype(\"float32\")\n    df.B = df.B.astype(\"float32\")\n    df.C = df.C.astype(\"float16\")\n    df.D = df.D.astype(\"float64\")\n    return df",
        "begin_line": 167,
        "end_line": 197,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_int_frame#201",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_int_frame()",
        "snippet": "def mixed_int_frame():\n    \"\"\"\n    Fixture for DataFrame of different int types with index of unique strings\n\n    Columns are ['A', 'B', 'C', 'D'].\n\n                A  B    C    D\n    mUrCZ67juP  0  1    2    2\n    rw99ACYaKS  0  1    0    0\n    7QsEcpaaVU  0  1    1    1\n    xkrimI2pcE  0  1    0    0\n    dz01SuzoS8  0  1  255  255\n    ccQkqOHX75 -1  1    0    0\n    DN0iXaoDLd  0  1    0    0\n    ...        .. ..  ...  ...\n    Dfb141wAaQ  1  1  254  254\n    IPD8eQOVu5  0  1    0    0\n    CcaKulsCmv  0  1    0    0\n    rIBa8gu7E5  0  1    0    0\n    RP6peZmh5o  0  1    1    1\n    NMb9pipQWQ  0  1    0    0\n    PqgbJEzjib  0  1    3    3\n\n    [30 rows x 4 columns]\n    \"\"\"\n    df = DataFrame({k: v.astype(int) for k, v in tm.getSeriesData().items()})\n    df.A = df.A.astype(\"int32\")\n    df.B = np.ones(len(df.B), dtype=\"uint64\")\n    df.C = df.C.astype(\"uint8\")\n    df.D = df.C.astype(\"int64\")\n    return df",
        "begin_line": 201,
        "end_line": 231,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.mixed_type_frame#235",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.mixed_type_frame()",
        "snippet": "def mixed_type_frame():\n    \"\"\"\n    Fixture for DataFrame of float/int/string columns with RangeIndex\n    Columns are ['a', 'b', 'c', 'float32', 'int32'].\n    \"\"\"\n    return DataFrame(\n        {\n            \"a\": 1.0,\n            \"b\": 2,\n            \"c\": \"foo\",\n            \"float32\": np.array([1.0] * 10, dtype=\"float32\"),\n            \"int32\": np.array([1] * 10, dtype=\"int32\"),\n        },\n        index=np.arange(10),\n    )",
        "begin_line": 235,
        "end_line": 249,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.timezone_frame#253",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.timezone_frame()",
        "snippet": "def timezone_frame():\n    \"\"\"\n    Fixture for DataFrame of date_range Series with different time zones\n\n    Columns are ['A', 'B', 'C']; some entries are missing\n\n               A                         B                         C\n    0 2013-01-01 2013-01-01 00:00:00-05:00 2013-01-01 00:00:00+01:00\n    1 2013-01-02                       NaT                       NaT\n    2 2013-01-03 2013-01-03 00:00:00-05:00 2013-01-03 00:00:00+01:00\n    \"\"\"\n    df = DataFrame(\n        {\n            \"A\": date_range(\"20130101\", periods=3),\n            \"B\": date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n            \"C\": date_range(\"20130101\", periods=3, tz=\"CET\"),\n        }\n    )\n    df.iloc[1, 1] = NaT\n    df.iloc[1, 2] = NaT\n    return df",
        "begin_line": 253,
        "end_line": 273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.uint64_frame#277",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.uint64_frame()",
        "snippet": "def uint64_frame():\n    \"\"\"\n    Fixture for DataFrame with uint64 values\n\n    Columns are ['A', 'B']\n    \"\"\"\n    return DataFrame(\n        {\"A\": np.arange(3), \"B\": [2 ** 63, 2 ** 63 + 5, 2 ** 63 + 10]}, dtype=np.uint64\n    )",
        "begin_line": 277,
        "end_line": 285,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.simple_frame#289",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.simple_frame()",
        "snippet": "def simple_frame():\n    \"\"\"\n    Fixture for simple 3x3 DataFrame\n\n    Columns are ['one', 'two', 'three'], index is ['a', 'b', 'c'].\n\n       one  two  three\n    a  1.0  2.0    3.0\n    b  4.0  5.0    6.0\n    c  7.0  8.0    9.0\n    \"\"\"\n    arr = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])\n\n    return DataFrame(arr, columns=[\"one\", \"two\", \"three\"], index=[\"a\", \"b\", \"c\"])",
        "begin_line": 289,
        "end_line": 302,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.conftest.frame_of_index_cols#306",
        "src_path": "pandas/tests/frame/conftest.py",
        "class_name": "pandas.tests.frame.conftest",
        "signature": "pandas.tests.frame.conftest.frame_of_index_cols()",
        "snippet": "def frame_of_index_cols():\n    \"\"\"\n    Fixture for DataFrame of columns that can be used for indexing\n\n    Columns are ['A', 'B', 'C', 'D', 'E', ('tuple', 'as', 'label')];\n    'A' & 'B' contain duplicates (but are jointly unique), the rest are unique.\n\n         A      B  C         D         E  (tuple, as, label)\n    0  foo    one  a  0.608477 -0.012500           -1.664297\n    1  foo    two  b -0.633460  0.249614           -0.364411\n    2  foo  three  c  0.615256  2.154968           -0.834666\n    3  bar    one  d  0.234246  1.085675            0.718445\n    4  bar    two  e  0.533841 -0.005702           -3.533912\n    \"\"\"\n    df = DataFrame(\n        {\n            \"A\": [\"foo\", \"foo\", \"foo\", \"bar\", \"bar\"],\n            \"B\": [\"one\", \"two\", \"three\", \"one\", \"two\"],\n            \"C\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n            \"D\": np.random.randn(5),\n            \"E\": np.random.randn(5),\n            (\"tuple\", \"as\", \"label\"): np.random.randn(5),\n        }\n    )\n    return df",
        "begin_line": 306,
        "end_line": 330,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common.TestData.frame#23",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common.TestData",
        "signature": "pandas.tests.frame.common.TestData.frame(self)",
        "snippet": "    def frame(self):\n        return _frame.copy()",
        "begin_line": 23,
        "end_line": 24,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common.TestData.frame2#27",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common.TestData",
        "signature": "pandas.tests.frame.common.TestData.frame2(self)",
        "snippet": "    def frame2(self):\n        return _frame2.copy()",
        "begin_line": 27,
        "end_line": 28,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common.TestData.intframe#31",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common.TestData",
        "signature": "pandas.tests.frame.common.TestData.intframe(self)",
        "snippet": "    def intframe(self):\n        # force these all to int64 to avoid platform testing issues\n        return pd.DataFrame({c: s for c, s in _intframe.items()}, dtype=np.int64)",
        "begin_line": 31,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common.TestData.tsframe#36",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common.TestData",
        "signature": "pandas.tests.frame.common.TestData.tsframe(self)",
        "snippet": "    def tsframe(self):\n        return _tsframe.copy()",
        "begin_line": 36,
        "end_line": 37,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common.TestData.mixed_frame#40",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common.TestData",
        "signature": "pandas.tests.frame.common.TestData.mixed_frame(self)",
        "snippet": "    def mixed_frame(self):\n        return _mixed_frame.copy()",
        "begin_line": 40,
        "end_line": 41,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common.TestData.tzframe#90",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common.TestData",
        "signature": "pandas.tests.frame.common.TestData.tzframe(self)",
        "snippet": "    def tzframe(self):\n        result = pd.DataFrame(\n            {\n                \"A\": pd.date_range(\"20130101\", periods=3),\n                \"B\": pd.date_range(\"20130101\", periods=3, tz=\"US/Eastern\"),\n                \"C\": pd.date_range(\"20130101\", periods=3, tz=\"CET\"),\n            }\n        )\n        result.iloc[1, 1] = pd.NaT\n        result.iloc[1, 2] = pd.NaT\n        return result",
        "begin_line": 90,
        "end_line": 100,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common.TestData.empty#103",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common.TestData",
        "signature": "pandas.tests.frame.common.TestData.empty(self)",
        "snippet": "    def empty(self):\n        return pd.DataFrame()",
        "begin_line": 103,
        "end_line": 104,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common._check_mixed_float#125",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common",
        "signature": "pandas.tests.frame.common._check_mixed_float(df, dtype=None)",
        "snippet": "def _check_mixed_float(df, dtype=None):\n    # float16 are most likely to be upcasted to float32\n    dtypes = dict(A=\"float32\", B=\"float32\", C=\"float16\", D=\"float64\")\n    if isinstance(dtype, str):\n        dtypes = {k: dtype for k, v in dtypes.items()}\n    elif isinstance(dtype, dict):\n        dtypes.update(dtype)\n    if dtypes.get(\"A\"):\n        assert df.dtypes[\"A\"] == dtypes[\"A\"]\n    if dtypes.get(\"B\"):\n        assert df.dtypes[\"B\"] == dtypes[\"B\"]\n    if dtypes.get(\"C\"):\n        assert df.dtypes[\"C\"] == dtypes[\"C\"]\n    if dtypes.get(\"D\"):\n        assert df.dtypes[\"D\"] == dtypes[\"D\"]",
        "begin_line": 125,
        "end_line": 139,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.common._check_mixed_int#142",
        "src_path": "pandas/tests/frame/common.py",
        "class_name": "pandas.tests.frame.common",
        "signature": "pandas.tests.frame.common._check_mixed_int(df, dtype=None)",
        "snippet": "def _check_mixed_int(df, dtype=None):\n    dtypes = dict(A=\"int32\", B=\"uint64\", C=\"uint8\", D=\"int64\")\n    if isinstance(dtype, str):\n        dtypes = {k: dtype for k, v in dtypes.items()}\n    elif isinstance(dtype, dict):\n        dtypes.update(dtype)\n    if dtypes.get(\"A\"):\n        assert df.dtypes[\"A\"] == dtypes[\"A\"]\n    if dtypes.get(\"B\"):\n        assert df.dtypes[\"B\"] == dtypes[\"B\"]\n    if dtypes.get(\"C\"):\n        assert df.dtypes[\"C\"] == dtypes[\"C\"]\n    if dtypes.get(\"D\"):\n        assert df.dtypes[\"D\"] == dtypes[\"D\"]",
        "begin_line": 142,
        "end_line": 155,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameComparisons.test_comparison_invalid#19",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameComparisons",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameComparisons.test_comparison_invalid(self)",
        "snippet": "    def test_comparison_invalid(self):\n        def check(df, df2):\n\n            for (x, y) in [(df, df2), (df2, df)]:\n                # we expect the result to match Series comparisons for\n                # == and !=, inequalities should raise\n                result = x == y\n                expected = pd.DataFrame(\n                    {col: x[col] == y[col] for col in x.columns},\n                    index=x.index,\n                    columns=x.columns,\n                )\n                tm.assert_frame_equal(result, expected)\n\n                result = x != y\n                expected = pd.DataFrame(\n                    {col: x[col] != y[col] for col in x.columns},\n                    index=x.index,\n                    columns=x.columns,\n                )\n                tm.assert_frame_equal(result, expected)\n\n                with pytest.raises(TypeError):\n                    x >= y\n                with pytest.raises(TypeError):\n                    x > y\n                with pytest.raises(TypeError):\n                    x < y\n                with pytest.raises(TypeError):\n                    x <= y\n\n        # GH4968\n        # invalid date/int comparisons\n        df = pd.DataFrame(np.random.randint(10, size=(10, 1)), columns=[\"a\"])\n        df[\"dates\"] = pd.date_range(\"20010101\", periods=len(df))\n\n        df2 = df.copy()\n        df2[\"dates\"] = df[\"a\"]\n        check(df, df2)\n\n        df = pd.DataFrame(np.random.randint(10, size=(10, 2)), columns=[\"a\", \"b\"])\n        df2 = pd.DataFrame(\n            {\n                \"a\": pd.date_range(\"20010101\", periods=len(df)),\n                \"b\": pd.date_range(\"20100101\", periods=len(df)),\n            }\n        )\n        check(df, df2)",
        "begin_line": 19,
        "end_line": 66,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameComparisons.check#20",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameComparisons",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameComparisons.check(df, df2)",
        "snippet": "        def check(df, df2):\n\n            for (x, y) in [(df, df2), (df2, df)]:\n                # we expect the result to match Series comparisons for\n                # == and !=, inequalities should raise\n                result = x == y\n                expected = pd.DataFrame(\n                    {col: x[col] == y[col] for col in x.columns},\n                    index=x.index,\n                    columns=x.columns,\n                )\n                tm.assert_frame_equal(result, expected)\n\n                result = x != y\n                expected = pd.DataFrame(\n                    {col: x[col] != y[col] for col in x.columns},\n                    index=x.index,\n                    columns=x.columns,\n                )\n                tm.assert_frame_equal(result, expected)\n\n                with pytest.raises(TypeError):\n                    x >= y\n                with pytest.raises(TypeError):\n                    x > y\n                with pytest.raises(TypeError):\n                    x < y\n                with pytest.raises(TypeError):\n                    x <= y",
        "begin_line": 20,
        "end_line": 48,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameComparisons.test_timestamp_compare#68",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameComparisons",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameComparisons.test_timestamp_compare(self)",
        "snippet": "    def test_timestamp_compare(self):\n        # make sure we can compare Timestamps on the right AND left hand side\n        # GH#4982\n        df = pd.DataFrame(\n            {\n                \"dates1\": pd.date_range(\"20010101\", periods=10),\n                \"dates2\": pd.date_range(\"20010102\", periods=10),\n                \"intcol\": np.random.randint(1000000000, size=10),\n                \"floatcol\": np.random.randn(10),\n                \"stringcol\": list(tm.rands(10)),\n            }\n        )\n        df.loc[np.random.rand(len(df)) > 0.5, \"dates2\"] = pd.NaT\n        ops = {\"gt\": \"lt\", \"lt\": \"gt\", \"ge\": \"le\", \"le\": \"ge\", \"eq\": \"eq\", \"ne\": \"ne\"}\n\n        for left, right in ops.items():\n            left_f = getattr(operator, left)\n            right_f = getattr(operator, right)\n\n            # no nats\n            if left in [\"eq\", \"ne\"]:\n                expected = left_f(df, pd.Timestamp(\"20010109\"))\n                result = right_f(pd.Timestamp(\"20010109\"), df)\n                tm.assert_frame_equal(result, expected)\n            else:\n                with pytest.raises(TypeError):\n                    left_f(df, pd.Timestamp(\"20010109\"))\n                with pytest.raises(TypeError):\n                    right_f(pd.Timestamp(\"20010109\"), df)\n            # nats\n            expected = left_f(df, pd.Timestamp(\"nat\"))\n            result = right_f(pd.Timestamp(\"nat\"), df)\n            tm.assert_frame_equal(result, expected)",
        "begin_line": 68,
        "end_line": 100,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameComparisons.test_mixed_comparison#102",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameComparisons",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameComparisons.test_mixed_comparison(self)",
        "snippet": "    def test_mixed_comparison(self):\n        # GH#13128, GH#22163 != datetime64 vs non-dt64 should be False,\n        # not raise TypeError\n        # (this appears to be fixed before GH#22163, not sure when)\n        df = pd.DataFrame([[\"1989-08-01\", 1], [\"1989-08-01\", 2]])\n        other = pd.DataFrame([[\"a\", \"b\"], [\"c\", \"d\"]])\n\n        result = df == other\n        assert not result.any().any()\n\n        result = df != other\n        assert result.all().all()",
        "begin_line": 102,
        "end_line": 113,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameComparisons.test_df_boolean_comparison_error#115",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameComparisons",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameComparisons.test_df_boolean_comparison_error(self)",
        "snippet": "    def test_df_boolean_comparison_error(self):\n        # GH#4576, GH#22880\n        # comparing DataFrame against list/tuple with len(obj) matching\n        #  len(df.columns) is supported as of GH#22800\n        df = pd.DataFrame(np.arange(6).reshape((3, 2)))\n\n        expected = pd.DataFrame([[False, False], [True, False], [False, False]])\n\n        result = df == (2, 2)\n        tm.assert_frame_equal(result, expected)\n\n        result = df == [2, 2]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 115,
        "end_line": 127,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameComparisons.test_df_float_none_comparison#129",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameComparisons",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameComparisons.test_df_float_none_comparison(self)",
        "snippet": "    def test_df_float_none_comparison(self):\n        df = pd.DataFrame(\n            np.random.randn(8, 3), index=range(8), columns=[\"A\", \"B\", \"C\"]\n        )\n\n        result = df.__eq__(None)\n        assert not result.any().any()",
        "begin_line": 129,
        "end_line": 135,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameComparisons.test_df_string_comparison#137",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameComparisons",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameComparisons.test_df_string_comparison(self)",
        "snippet": "    def test_df_string_comparison(self):\n        df = pd.DataFrame([{\"a\": 1, \"b\": \"foo\"}, {\"a\": 2, \"b\": \"bar\"}])\n        mask_a = df.a > 1\n        tm.assert_frame_equal(df[mask_a], df.loc[1:1, :])\n        tm.assert_frame_equal(df[-mask_a], df.loc[0:0, :])\n\n        mask_b = df.b == \"foo\"\n        tm.assert_frame_equal(df[mask_b], df.loc[0:0, :])\n        tm.assert_frame_equal(df[-mask_b], df.loc[1:1, :])",
        "begin_line": 137,
        "end_line": 145,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameFlexComparisons.test_bool_flex_frame#150",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameFlexComparisons",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameFlexComparisons.test_bool_flex_frame(self)",
        "snippet": "    def test_bool_flex_frame(self):\n        data = np.random.randn(5, 3)\n        other_data = np.random.randn(5, 3)\n        df = pd.DataFrame(data)\n        other = pd.DataFrame(other_data)\n        ndim_5 = np.ones(df.shape + (1, 3))\n\n        # Unaligned\n        def _check_unaligned_frame(meth, op, df, other):\n            part_o = other.loc[3:, 1:].copy()\n            rs = meth(part_o)\n            xp = op(df, part_o.reindex(index=df.index, columns=df.columns))\n            tm.assert_frame_equal(rs, xp)\n\n        # DataFrame\n        assert df.eq(df).values.all()\n        assert not df.ne(df).values.any()\n        for op in [\"eq\", \"ne\", \"gt\", \"lt\", \"ge\", \"le\"]:\n            f = getattr(df, op)\n            o = getattr(operator, op)\n            # No NAs\n            tm.assert_frame_equal(f(other), o(df, other))\n            _check_unaligned_frame(f, o, df, other)\n            # ndarray\n            tm.assert_frame_equal(f(other.values), o(df, other.values))\n            # scalar\n            tm.assert_frame_equal(f(0), o(df, 0))\n            # NAs\n            msg = \"Unable to coerce to Series/DataFrame\"\n            tm.assert_frame_equal(f(np.nan), o(df, np.nan))\n            with pytest.raises(ValueError, match=msg):\n                f(ndim_5)\n\n        # Series\n        def _test_seq(df, idx_ser, col_ser):\n            idx_eq = df.eq(idx_ser, axis=0)\n            col_eq = df.eq(col_ser)\n            idx_ne = df.ne(idx_ser, axis=0)\n            col_ne = df.ne(col_ser)\n            tm.assert_frame_equal(col_eq, df == pd.Series(col_ser))\n            tm.assert_frame_equal(col_eq, -col_ne)\n            tm.assert_frame_equal(idx_eq, -idx_ne)\n            tm.assert_frame_equal(idx_eq, df.T.eq(idx_ser).T)\n            tm.assert_frame_equal(col_eq, df.eq(list(col_ser)))\n            tm.assert_frame_equal(idx_eq, df.eq(pd.Series(idx_ser), axis=0))\n            tm.assert_frame_equal(idx_eq, df.eq(list(idx_ser), axis=0))\n\n            idx_gt = df.gt(idx_ser, axis=0)\n            col_gt = df.gt(col_ser)\n            idx_le = df.le(idx_ser, axis=0)\n            col_le = df.le(col_ser)\n\n            tm.assert_frame_equal(col_gt, df > pd.Series(col_ser))\n            tm.assert_frame_equal(col_gt, -col_le)\n            tm.assert_frame_equal(idx_gt, -idx_le)\n            tm.assert_frame_equal(idx_gt, df.T.gt(idx_ser).T)\n\n            idx_ge = df.ge(idx_ser, axis=0)\n            col_ge = df.ge(col_ser)\n            idx_lt = df.lt(idx_ser, axis=0)\n            col_lt = df.lt(col_ser)\n            tm.assert_frame_equal(col_ge, df >= pd.Series(col_ser))\n            tm.assert_frame_equal(col_ge, -col_lt)\n            tm.assert_frame_equal(idx_ge, -idx_lt)\n            tm.assert_frame_equal(idx_ge, df.T.ge(idx_ser).T)\n\n        idx_ser = pd.Series(np.random.randn(5))\n        col_ser = pd.Series(np.random.randn(3))\n        _test_seq(df, idx_ser, col_ser)\n\n        # list/tuple\n        _test_seq(df, idx_ser.values, col_ser.values)\n\n        # NA\n        df.loc[0, 0] = np.nan\n        rs = df.eq(df)\n        assert not rs.loc[0, 0]\n        rs = df.ne(df)\n        assert rs.loc[0, 0]\n        rs = df.gt(df)\n        assert not rs.loc[0, 0]\n        rs = df.lt(df)\n        assert not rs.loc[0, 0]\n        rs = df.ge(df)\n        assert not rs.loc[0, 0]\n        rs = df.le(df)\n        assert not rs.loc[0, 0]\n\n        # complex\n        arr = np.array([np.nan, 1, 6, np.nan])\n        arr2 = np.array([2j, np.nan, 7, None])\n        df = pd.DataFrame({\"a\": arr})\n        df2 = pd.DataFrame({\"a\": arr2})\n        rs = df.gt(df2)\n        assert not rs.values.any()\n        rs = df.ne(df2)\n        assert rs.values.all()\n\n        arr3 = np.array([2j, np.nan, None])\n        df3 = pd.DataFrame({\"a\": arr3})\n        rs = df3.gt(2j)\n        assert not rs.values.any()\n\n        # corner, dtype=object\n        df1 = pd.DataFrame({\"col\": [\"foo\", np.nan, \"bar\"]})\n        df2 = pd.DataFrame({\"col\": [\"foo\", datetime.now(), \"bar\"]})\n        result = df1.ne(df2)\n        exp = pd.DataFrame({\"col\": [False, True, False]})\n        tm.assert_frame_equal(result, exp)",
        "begin_line": 150,
        "end_line": 258,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameFlexComparisons._check_unaligned_frame#158",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameFlexComparisons",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameFlexComparisons._check_unaligned_frame(meth, op, df, other)",
        "snippet": "        def _check_unaligned_frame(meth, op, df, other):\n            part_o = other.loc[3:, 1:].copy()\n            rs = meth(part_o)\n            xp = op(df, part_o.reindex(index=df.index, columns=df.columns))\n            tm.assert_frame_equal(rs, xp)",
        "begin_line": 158,
        "end_line": 162,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameFlexComparisons._test_seq#184",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameFlexComparisons",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameFlexComparisons._test_seq(df, idx_ser, col_ser)",
        "snippet": "        def _test_seq(df, idx_ser, col_ser):\n            idx_eq = df.eq(idx_ser, axis=0)\n            col_eq = df.eq(col_ser)\n            idx_ne = df.ne(idx_ser, axis=0)\n            col_ne = df.ne(col_ser)\n            tm.assert_frame_equal(col_eq, df == pd.Series(col_ser))\n            tm.assert_frame_equal(col_eq, -col_ne)\n            tm.assert_frame_equal(idx_eq, -idx_ne)\n            tm.assert_frame_equal(idx_eq, df.T.eq(idx_ser).T)\n            tm.assert_frame_equal(col_eq, df.eq(list(col_ser)))\n            tm.assert_frame_equal(idx_eq, df.eq(pd.Series(idx_ser), axis=0))\n            tm.assert_frame_equal(idx_eq, df.eq(list(idx_ser), axis=0))\n\n            idx_gt = df.gt(idx_ser, axis=0)\n            col_gt = df.gt(col_ser)\n            idx_le = df.le(idx_ser, axis=0)\n            col_le = df.le(col_ser)\n\n            tm.assert_frame_equal(col_gt, df > pd.Series(col_ser))\n            tm.assert_frame_equal(col_gt, -col_le)\n            tm.assert_frame_equal(idx_gt, -idx_le)\n            tm.assert_frame_equal(idx_gt, df.T.gt(idx_ser).T)\n\n            idx_ge = df.ge(idx_ser, axis=0)\n            col_ge = df.ge(col_ser)\n            idx_lt = df.lt(idx_ser, axis=0)\n            col_lt = df.lt(col_ser)\n            tm.assert_frame_equal(col_ge, df >= pd.Series(col_ser))\n            tm.assert_frame_equal(col_ge, -col_lt)\n            tm.assert_frame_equal(idx_ge, -idx_lt)\n            tm.assert_frame_equal(idx_ge, df.T.ge(idx_ser).T)",
        "begin_line": 184,
        "end_line": 214,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameFlexComparisons.test_flex_comparison_nat#260",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameFlexComparisons",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameFlexComparisons.test_flex_comparison_nat(self)",
        "snippet": "    def test_flex_comparison_nat(self):\n        # GH 15697, GH 22163 df.eq(pd.NaT) should behave like df == pd.NaT,\n        # and _definitely_ not be NaN\n        df = pd.DataFrame([pd.NaT])\n\n        result = df == pd.NaT\n        # result.iloc[0, 0] is a np.bool_ object\n        assert result.iloc[0, 0].item() is False\n\n        result = df.eq(pd.NaT)\n        assert result.iloc[0, 0].item() is False\n\n        result = df != pd.NaT\n        assert result.iloc[0, 0].item() is True\n\n        result = df.ne(pd.NaT)\n        assert result.iloc[0, 0].item() is True",
        "begin_line": 260,
        "end_line": 276,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameFlexComparisons.test_df_flex_cmp_constant_return_types#279",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameFlexComparisons",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameFlexComparisons.test_df_flex_cmp_constant_return_types(self, opname)",
        "snippet": "    def test_df_flex_cmp_constant_return_types(self, opname):\n        # GH 15077, non-empty DataFrame\n        df = pd.DataFrame({\"x\": [1, 2, 3], \"y\": [1.0, 2.0, 3.0]})\n        const = 2\n\n        result = getattr(df, opname)(const).dtypes.value_counts()\n        tm.assert_series_equal(result, pd.Series([2], index=[np.dtype(bool)]))",
        "begin_line": 279,
        "end_line": 285,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameFlexComparisons.test_df_flex_cmp_constant_return_types_empty#288",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameFlexComparisons",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameFlexComparisons.test_df_flex_cmp_constant_return_types_empty(self, opname)",
        "snippet": "    def test_df_flex_cmp_constant_return_types_empty(self, opname):\n        # GH 15077 empty DataFrame\n        df = pd.DataFrame({\"x\": [1, 2, 3], \"y\": [1.0, 2.0, 3.0]})\n        const = 2\n\n        empty = df.iloc[:0]\n        result = getattr(empty, opname)(const).dtypes.value_counts()\n        tm.assert_series_equal(result, pd.Series([2], index=[np.dtype(bool)]))",
        "begin_line": 288,
        "end_line": 295,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic.test_df_add_td64_columnwise#303",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic.test_df_add_td64_columnwise(self)",
        "snippet": "    def test_df_add_td64_columnwise(self):\n        # GH 22534 Check that column-wise addition broadcasts correctly\n        dti = pd.date_range(\"2016-01-01\", periods=10)\n        tdi = pd.timedelta_range(\"1\", periods=10)\n        tser = pd.Series(tdi)\n        df = pd.DataFrame({0: dti, 1: tdi})\n\n        result = df.add(tser, axis=0)\n        expected = pd.DataFrame({0: dti + tdi, 1: tdi + tdi})\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 303,
        "end_line": 312,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic.test_df_add_flex_filled_mixed_dtypes#314",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic.test_df_add_flex_filled_mixed_dtypes(self)",
        "snippet": "    def test_df_add_flex_filled_mixed_dtypes(self):\n        # GH 19611\n        dti = pd.date_range(\"2016-01-01\", periods=3)\n        ser = pd.Series([\"1 Day\", \"NaT\", \"2 Days\"], dtype=\"timedelta64[ns]\")\n        df = pd.DataFrame({\"A\": dti, \"B\": ser})\n        other = pd.DataFrame({\"A\": ser, \"B\": ser})\n        fill = pd.Timedelta(days=1).to_timedelta64()\n        result = df.add(other, fill_value=fill)\n\n        expected = pd.DataFrame(\n            {\n                \"A\": pd.Series(\n                    [\"2016-01-02\", \"2016-01-03\", \"2016-01-05\"], dtype=\"datetime64[ns]\"\n                ),\n                \"B\": ser * 2,\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 314,
        "end_line": 331,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic.test_arith_flex_frame#333",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic.test_arith_flex_frame(self, all_arithmetic_operators, float_frame, mixed_float_frame)",
        "snippet": "    def test_arith_flex_frame(\n        self, all_arithmetic_operators, float_frame, mixed_float_frame\n    ):\n        # one instance of parametrized fixture\n        op = all_arithmetic_operators\n\n        def f(x, y):\n            # r-versions not in operator-stdlib; get op without \"r\" and invert\n            if op.startswith(\"__r\"):\n                return getattr(operator, op.replace(\"__r\", \"__\"))(y, x)\n            return getattr(operator, op)(x, y)\n\n        result = getattr(float_frame, op)(2 * float_frame)\n        expected = f(float_frame, 2 * float_frame)\n        tm.assert_frame_equal(result, expected)\n\n        # vs mix float\n        result = getattr(mixed_float_frame, op)(2 * mixed_float_frame)\n        expected = f(mixed_float_frame, 2 * mixed_float_frame)\n        tm.assert_frame_equal(result, expected)\n        _check_mixed_float(result, dtype=dict(C=None))",
        "begin_line": 333,
        "end_line": 353,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic.f#339",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic.f(x, y)",
        "snippet": "        def f(x, y):\n            # r-versions not in operator-stdlib; get op without \"r\" and invert\n            if op.startswith(\"__r\"):\n                return getattr(operator, op.replace(\"__r\", \"__\"))(y, x)\n            return getattr(operator, op)(x, y)",
        "begin_line": 339,
        "end_line": 343,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic.test_arith_flex_frame_mixed#356",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic.test_arith_flex_frame_mixed(self, op, int_frame, mixed_int_frame, mixed_float_frame)",
        "snippet": "    def test_arith_flex_frame_mixed(\n        self, op, int_frame, mixed_int_frame, mixed_float_frame\n    ):\n        f = getattr(operator, op)\n\n        # vs mix int\n        result = getattr(mixed_int_frame, op)(2 + mixed_int_frame)\n        expected = f(mixed_int_frame, 2 + mixed_int_frame)\n\n        # no overflow in the uint\n        dtype = None\n        if op in [\"__sub__\"]:\n            dtype = dict(B=\"uint64\", C=None)\n        elif op in [\"__add__\", \"__mul__\"]:\n            dtype = dict(C=None)\n        tm.assert_frame_equal(result, expected)\n        _check_mixed_int(result, dtype=dtype)\n\n        # vs mix float\n        result = getattr(mixed_float_frame, op)(2 * mixed_float_frame)\n        expected = f(mixed_float_frame, 2 * mixed_float_frame)\n        tm.assert_frame_equal(result, expected)\n        _check_mixed_float(result, dtype=dict(C=None))\n\n        # vs plain int\n        result = getattr(int_frame, op)(2 * int_frame)\n        expected = f(int_frame, 2 * int_frame)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 356,
        "end_line": 383,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic.test_arith_flex_frame_raise#385",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic.test_arith_flex_frame_raise(self, all_arithmetic_operators, float_frame)",
        "snippet": "    def test_arith_flex_frame_raise(self, all_arithmetic_operators, float_frame):\n        # one instance of parametrized fixture\n        op = all_arithmetic_operators\n\n        # Check that arrays with dim >= 3 raise\n        for dim in range(3, 6):\n            arr = np.ones((1,) * dim)\n            msg = \"Unable to coerce to Series/DataFrame\"\n            with pytest.raises(ValueError, match=msg):\n                getattr(float_frame, op)(arr)",
        "begin_line": 385,
        "end_line": 394,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic.test_arith_flex_frame_corner#396",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic.test_arith_flex_frame_corner(self, float_frame)",
        "snippet": "    def test_arith_flex_frame_corner(self, float_frame):\n\n        const_add = float_frame.add(1)\n        tm.assert_frame_equal(const_add, float_frame + 1)\n\n        # corner cases\n        result = float_frame.add(float_frame[:0])\n        tm.assert_frame_equal(result, float_frame * np.nan)\n\n        result = float_frame[:0].add(float_frame)\n        tm.assert_frame_equal(result, float_frame * np.nan)\n\n        with pytest.raises(NotImplementedError, match=\"fill_value\"):\n            float_frame.add(float_frame.iloc[0], fill_value=3)\n\n        with pytest.raises(NotImplementedError, match=\"fill_value\"):\n            float_frame.add(float_frame.iloc[0], axis=\"index\", fill_value=3)",
        "begin_line": 396,
        "end_line": 412,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic.test_arith_flex_series#414",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic.test_arith_flex_series(self, simple_frame)",
        "snippet": "    def test_arith_flex_series(self, simple_frame):\n        df = simple_frame\n\n        row = df.xs(\"a\")\n        col = df[\"two\"]\n        # after arithmetic refactor, add truediv here\n        ops = [\"add\", \"sub\", \"mul\", \"mod\"]\n        for op in ops:\n            f = getattr(df, op)\n            op = getattr(operator, op)\n            tm.assert_frame_equal(f(row), op(df, row))\n            tm.assert_frame_equal(f(col, axis=0), op(df.T, col).T)\n\n        # special case for some reason\n        tm.assert_frame_equal(df.add(row, axis=None), df + row)\n\n        # cases which will be refactored after big arithmetic refactor\n        tm.assert_frame_equal(df.div(row), df / row)\n        tm.assert_frame_equal(df.div(col, axis=0), (df.T / col).T)\n\n        # broadcasting issue in GH 7325\n        df = pd.DataFrame(np.arange(3 * 2).reshape((3, 2)), dtype=\"int64\")\n        expected = pd.DataFrame([[np.nan, np.inf], [1.0, 1.5], [1.0, 1.25]])\n        result = df.div(df[0], axis=\"index\")\n        tm.assert_frame_equal(result, expected)\n\n        df = pd.DataFrame(np.arange(3 * 2).reshape((3, 2)), dtype=\"float64\")\n        expected = pd.DataFrame([[np.nan, np.inf], [1.0, 1.5], [1.0, 1.25]])\n        result = df.div(df[0], axis=\"index\")\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 414,
        "end_line": 443,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic.test_arith_flex_zero_len_raises#445",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameFlexArithmetic.test_arith_flex_zero_len_raises(self)",
        "snippet": "    def test_arith_flex_zero_len_raises(self):\n        # GH 19522 passing fill_value to frame flex arith methods should\n        # raise even in the zero-length special cases\n        ser_len0 = pd.Series([])\n        df_len0 = pd.DataFrame(columns=[\"A\", \"B\"])\n        df = pd.DataFrame([[1, 2], [3, 4]], columns=[\"A\", \"B\"])\n\n        with pytest.raises(NotImplementedError, match=\"fill_value\"):\n            df.add(ser_len0, fill_value=\"E\")\n\n        with pytest.raises(NotImplementedError, match=\"fill_value\"):\n            df_len0.sub(df[\"A\"], axis=None, fill_value=3)",
        "begin_line": 445,
        "end_line": 456,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_td64_op_nat_casting#460",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_td64_op_nat_casting(self)",
        "snippet": "    def test_td64_op_nat_casting(self):\n        # Make sure we don't accidentally treat timedelta64(NaT) as datetime64\n        #  when calling dispatch_to_series in DataFrame arithmetic\n        ser = pd.Series([\"NaT\", \"NaT\"], dtype=\"timedelta64[ns]\")\n        df = pd.DataFrame([[1, 2], [3, 4]])\n\n        result = df * ser\n        expected = pd.DataFrame({0: ser, 1: ser})\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 460,
        "end_line": 468,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_df_add_2d_array_rowlike_broadcasts#470",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_df_add_2d_array_rowlike_broadcasts(self)",
        "snippet": "    def test_df_add_2d_array_rowlike_broadcasts(self):\n        # GH#23000\n        arr = np.arange(6).reshape(3, 2)\n        df = pd.DataFrame(arr, columns=[True, False], index=[\"A\", \"B\", \"C\"])\n\n        rowlike = arr[[1], :]  # shape --> (1, ncols)\n        assert rowlike.shape == (1, df.shape[1])\n\n        expected = pd.DataFrame(\n            [[2, 4], [4, 6], [6, 8]],\n            columns=df.columns,\n            index=df.index,\n            # specify dtype explicitly to avoid failing\n            # on 32bit builds\n            dtype=arr.dtype,\n        )\n        result = df + rowlike\n        tm.assert_frame_equal(result, expected)\n        result = rowlike + df\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 470,
        "end_line": 489,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_df_add_2d_array_collike_broadcasts#491",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_df_add_2d_array_collike_broadcasts(self)",
        "snippet": "    def test_df_add_2d_array_collike_broadcasts(self):\n        # GH#23000\n        arr = np.arange(6).reshape(3, 2)\n        df = pd.DataFrame(arr, columns=[True, False], index=[\"A\", \"B\", \"C\"])\n\n        collike = arr[:, [1]]  # shape --> (nrows, 1)\n        assert collike.shape == (df.shape[0], 1)\n\n        expected = pd.DataFrame(\n            [[1, 2], [5, 6], [9, 10]],\n            columns=df.columns,\n            index=df.index,\n            # specify dtype explicitly to avoid failing\n            # on 32bit builds\n            dtype=arr.dtype,\n        )\n        result = df + collike\n        tm.assert_frame_equal(result, expected)\n        result = collike + df\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 491,
        "end_line": 510,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_df_arith_2d_array_rowlike_broadcasts#512",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_df_arith_2d_array_rowlike_broadcasts(self, all_arithmetic_operators)",
        "snippet": "    def test_df_arith_2d_array_rowlike_broadcasts(self, all_arithmetic_operators):\n        # GH#23000\n        opname = all_arithmetic_operators\n\n        arr = np.arange(6).reshape(3, 2)\n        df = pd.DataFrame(arr, columns=[True, False], index=[\"A\", \"B\", \"C\"])\n\n        rowlike = arr[[1], :]  # shape --> (1, ncols)\n        assert rowlike.shape == (1, df.shape[1])\n\n        exvals = [\n            getattr(df.loc[\"A\"], opname)(rowlike.squeeze()),\n            getattr(df.loc[\"B\"], opname)(rowlike.squeeze()),\n            getattr(df.loc[\"C\"], opname)(rowlike.squeeze()),\n        ]\n\n        expected = pd.DataFrame(exvals, columns=df.columns, index=df.index)\n\n        if opname in [\"__rmod__\", \"__rfloordiv__\"]:\n            # exvals will have dtypes [f8, i8, i8] so expected will be\n            #   all-f8, but the DataFrame operation will return mixed dtypes\n            # use exvals[-1].dtype instead of \"i8\" for compat with 32-bit\n            # systems/pythons\n            expected[False] = expected[False].astype(exvals[-1].dtype)\n\n        result = getattr(df, opname)(rowlike)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 512,
        "end_line": 538,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_df_arith_2d_array_collike_broadcasts#540",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_df_arith_2d_array_collike_broadcasts(self, all_arithmetic_operators)",
        "snippet": "    def test_df_arith_2d_array_collike_broadcasts(self, all_arithmetic_operators):\n        # GH#23000\n        opname = all_arithmetic_operators\n\n        arr = np.arange(6).reshape(3, 2)\n        df = pd.DataFrame(arr, columns=[True, False], index=[\"A\", \"B\", \"C\"])\n\n        collike = arr[:, [1]]  # shape --> (nrows, 1)\n        assert collike.shape == (df.shape[0], 1)\n\n        exvals = {\n            True: getattr(df[True], opname)(collike.squeeze()),\n            False: getattr(df[False], opname)(collike.squeeze()),\n        }\n\n        dtype = None\n        if opname in [\"__rmod__\", \"__rfloordiv__\"]:\n            # Series ops may return mixed int/float dtypes in cases where\n            #   DataFrame op will return all-float.  So we upcast `expected`\n            dtype = np.common_type(*[x.values for x in exvals.values()])\n\n        expected = pd.DataFrame(exvals, columns=df.columns, index=df.index, dtype=dtype)\n\n        result = getattr(df, opname)(collike)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 540,
        "end_line": 564,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_df_bool_mul_int#566",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_df_bool_mul_int(self)",
        "snippet": "    def test_df_bool_mul_int(self):\n        # GH 22047, GH 22163 multiplication by 1 should result in int dtype,\n        # not object dtype\n        df = pd.DataFrame([[False, True], [False, False]])\n        result = df * 1\n\n        # On appveyor this comes back as np.int32 instead of np.int64,\n        # so we check dtype.kind instead of just dtype\n        kinds = result.dtypes.apply(lambda x: x.kind)\n        assert (kinds == \"i\").all()\n\n        result = 1 * df\n        kinds = result.dtypes.apply(lambda x: x.kind)\n        assert (kinds == \"i\").all()",
        "begin_line": 566,
        "end_line": 579,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_arith_mixed#581",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_arith_mixed(self)",
        "snippet": "    def test_arith_mixed(self):\n\n        left = pd.DataFrame({\"A\": [\"a\", \"b\", \"c\"], \"B\": [1, 2, 3]})\n\n        result = left + left\n        expected = pd.DataFrame({\"A\": [\"aa\", \"bb\", \"cc\"], \"B\": [2, 4, 6]})\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 581,
        "end_line": 587,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_arith_getitem_commute#589",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_arith_getitem_commute(self)",
        "snippet": "    def test_arith_getitem_commute(self):\n        df = pd.DataFrame({\"A\": [1.1, 3.3], \"B\": [2.5, -3.9]})\n\n        def _test_op(df, op):\n            result = op(df, 1)\n\n            if not df.columns.is_unique:\n                raise ValueError(\"Only unique columns supported by this test\")\n\n            for col in result.columns:\n                tm.assert_series_equal(result[col], op(df[col], 1))\n\n        _test_op(df, operator.add)\n        _test_op(df, operator.sub)\n        _test_op(df, operator.mul)\n        _test_op(df, operator.truediv)\n        _test_op(df, operator.floordiv)\n        _test_op(df, operator.pow)\n\n        _test_op(df, lambda x, y: y + x)\n        _test_op(df, lambda x, y: y - x)\n        _test_op(df, lambda x, y: y * x)\n        _test_op(df, lambda x, y: y / x)\n        _test_op(df, lambda x, y: y ** x)\n\n        _test_op(df, lambda x, y: x + y)\n        _test_op(df, lambda x, y: x - y)\n        _test_op(df, lambda x, y: x * y)\n        _test_op(df, lambda x, y: x / y)\n        _test_op(df, lambda x, y: x ** y)",
        "begin_line": 589,
        "end_line": 618,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic._test_op#592",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic._test_op(df, op)",
        "snippet": "        def _test_op(df, op):\n            result = op(df, 1)\n\n            if not df.columns.is_unique:\n                raise ValueError(\"Only unique columns supported by this test\")\n\n            for col in result.columns:\n                tm.assert_series_equal(result[col], op(df[col], 1))",
        "begin_line": 592,
        "end_line": 599,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_arith_alignment_non_pandas_object#623",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_arith_alignment_non_pandas_object(self, values)",
        "snippet": "    def test_arith_alignment_non_pandas_object(self, values):\n        # GH#17901\n        df = pd.DataFrame({\"A\": [1, 1], \"B\": [1, 1]})\n        expected = pd.DataFrame({\"A\": [2, 2], \"B\": [3, 3]})\n        result = df + values\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 623,
        "end_line": 628,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_arith_non_pandas_object#630",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_arith_non_pandas_object(self)",
        "snippet": "    def test_arith_non_pandas_object(self):\n        df = pd.DataFrame(\n            np.arange(1, 10, dtype=\"f8\").reshape(3, 3),\n            columns=[\"one\", \"two\", \"three\"],\n            index=[\"a\", \"b\", \"c\"],\n        )\n\n        val1 = df.xs(\"a\").values\n        added = pd.DataFrame(df.values + val1, index=df.index, columns=df.columns)\n        tm.assert_frame_equal(df + val1, added)\n\n        added = pd.DataFrame((df.values.T + val1).T, index=df.index, columns=df.columns)\n        tm.assert_frame_equal(df.add(val1, axis=0), added)\n\n        val2 = list(df[\"two\"])\n\n        added = pd.DataFrame(df.values + val2, index=df.index, columns=df.columns)\n        tm.assert_frame_equal(df + val2, added)\n\n        added = pd.DataFrame((df.values.T + val2).T, index=df.index, columns=df.columns)\n        tm.assert_frame_equal(df.add(val2, axis=\"index\"), added)\n\n        val3 = np.random.rand(*df.shape)\n        added = pd.DataFrame(df.values + val3, index=df.index, columns=df.columns)\n        tm.assert_frame_equal(df.add(val3), added)",
        "begin_line": 630,
        "end_line": 654,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_operations_with_interval_categories_index#656",
        "src_path": "pandas/tests/frame/test_arithmetic.py",
        "class_name": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic",
        "signature": "pandas.tests.frame.test_arithmetic.TestFrameArithmetic.test_operations_with_interval_categories_index(self, all_arithmetic_operators)",
        "snippet": "    def test_operations_with_interval_categories_index(self, all_arithmetic_operators):\n        # GH#27415\n        op = all_arithmetic_operators\n        ind = pd.CategoricalIndex(pd.interval_range(start=0.0, end=2.0))\n        data = [1, 2]\n        df = pd.DataFrame([data], columns=ind)\n        num = 10\n        result = getattr(df, op)(num)\n        expected = pd.DataFrame([[getattr(n, op)(num) for n in data]], columns=ind)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 656,
        "end_line": 665,
        "comment": "",
        "is_bug": false
    }
]