[
    {
        "name": "pandas.tests.io.excel.conftest.check_for_file_leaks#47",
        "src_path": "pandas/tests/io/excel/conftest.py",
        "class_name": "pandas.tests.io.excel.conftest",
        "signature": "pandas.tests.io.excel.conftest.check_for_file_leaks()",
        "snippet": "def check_for_file_leaks():\n    \"\"\"\n    Fixture to run around every test to ensure that we are not leaking files.\n\n    See also\n    --------\n    _test_decorators.check_file_leaks\n    \"\"\"\n    # GH#30162\n    psutil = td.safe_import(\"psutil\")\n    if not psutil:\n        yield\n\n    else:\n        proc = psutil.Process()\n        flist = proc.open_files()\n        yield\n        flist2 = proc.open_files()\n        assert flist == flist2",
        "begin_line": 47,
        "end_line": 65,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.pytables.conftest.setup_mode#13",
        "src_path": "pandas/tests/io/pytables/conftest.py",
        "class_name": "pandas.tests.io.pytables.conftest",
        "signature": "pandas.tests.io.pytables.conftest.setup_mode()",
        "snippet": "def setup_mode():\n    \"\"\" Reset testing mode fixture\"\"\"\n    tm.reset_testing_mode()\n    yield\n    tm.set_testing_mode()",
        "begin_line": 13,
        "end_line": 17,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.conftest.salaries_table#23",
        "src_path": "pandas/tests/io/conftest.py",
        "class_name": "pandas.tests.io.conftest",
        "signature": "pandas.tests.io.conftest.salaries_table(datapath)",
        "snippet": "def salaries_table(datapath):\n    \"\"\"DataFrame with the salaries dataset\"\"\"\n    return read_csv(datapath(\"io\", \"parser\", \"data\", \"salaries.csv\"), sep=\"\\t\")",
        "begin_line": 23,
        "end_line": 25,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.assert_json_roundtrip_equal#29",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas",
        "signature": "pandas.tests.io.json.test_pandas.assert_json_roundtrip_equal(result, expected, orient)",
        "snippet": "def assert_json_roundtrip_equal(result, expected, orient):\n    if orient == \"records\" or orient == \"values\":\n        expected = expected.reset_index(drop=True)\n    if orient == \"values\":\n        expected.columns = range(len(expected.columns))\n    tm.assert_frame_equal(result, expected)",
        "begin_line": 29,
        "end_line": 34,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.setup#40",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.setup(self)",
        "snippet": "    def setup(self):\n        self.categorical = _cat_frame.copy()\n\n        yield",
        "begin_line": 40,
        "end_line": 43,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_double_encoded_labels#45",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_double_encoded_labels(self, orient)",
        "snippet": "    def test_frame_double_encoded_labels(self, orient):\n        df = DataFrame(\n            [[\"a\", \"b\"], [\"c\", \"d\"]],\n            index=['index \" 1', \"index / 2\"],\n            columns=[\"a \\\\ b\", \"y / z\"],\n        )\n\n        result = read_json(df.to_json(orient=orient), orient=orient)\n        expected = df.copy()\n\n        assert_json_roundtrip_equal(result, expected, orient)",
        "begin_line": 45,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_non_unique_index#58",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_non_unique_index(self, orient)",
        "snippet": "    def test_frame_non_unique_index(self, orient):\n        df = DataFrame([[\"a\", \"b\"], [\"c\", \"d\"]], index=[1, 1], columns=[\"x\", \"y\"])\n        result = read_json(df.to_json(orient=orient), orient=orient)\n        expected = df.copy()\n\n        assert_json_roundtrip_equal(result, expected, orient)",
        "begin_line": 58,
        "end_line": 63,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_non_unique_index_raises#66",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_non_unique_index_raises(self, orient)",
        "snippet": "    def test_frame_non_unique_index_raises(self, orient):\n        df = DataFrame([[\"a\", \"b\"], [\"c\", \"d\"]], index=[1, 1], columns=[\"x\", \"y\"])\n        msg = f\"DataFrame index must be unique for orient='{orient}'\"\n        with pytest.raises(ValueError, match=msg):\n            df.to_json(orient=orient)",
        "begin_line": 66,
        "end_line": 70,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_non_unique_columns#82",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_non_unique_columns(self, orient, data)",
        "snippet": "    def test_frame_non_unique_columns(self, orient, data):\n        df = DataFrame(data, index=[1, 2], columns=[\"x\", \"x\"])\n\n        result = read_json(\n            df.to_json(orient=orient), orient=orient, convert_dates=[\"x\"]\n        )\n        if orient == \"values\":\n            expected = pd.DataFrame(data)\n            if expected.iloc[:, 0].dtype == \"datetime64[ns]\":\n                # orient == \"values\" by default will write Timestamp objects out\n                # in milliseconds; these are internally stored in nanosecond,\n                # so divide to get where we need\n                # TODO: a to_epoch method would also solve; see GH 14772\n                expected.iloc[:, 0] = expected.iloc[:, 0].astype(np.int64) // 1000000\n        elif orient == \"split\":\n            expected = df\n\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 82,
        "end_line": 99,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_non_unique_columns_raises#102",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_non_unique_columns_raises(self, orient)",
        "snippet": "    def test_frame_non_unique_columns_raises(self, orient):\n        df = DataFrame([[\"a\", \"b\"], [\"c\", \"d\"]], index=[1, 2], columns=[\"x\", \"x\"])\n\n        msg = f\"DataFrame columns must be unique for orient='{orient}'\"\n        with pytest.raises(ValueError, match=msg):\n            df.to_json(orient=orient)",
        "begin_line": 102,
        "end_line": 107,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_default_orient#109",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_default_orient(self, float_frame)",
        "snippet": "    def test_frame_default_orient(self, float_frame):\n        assert float_frame.to_json() == float_frame.to_json(orient=\"columns\")",
        "begin_line": 109,
        "end_line": 110,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_roundtrip_simple#115",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_roundtrip_simple(self, orient, convert_axes, numpy, dtype, float_frame)",
        "snippet": "    def test_roundtrip_simple(self, orient, convert_axes, numpy, dtype, float_frame):\n        data = float_frame.to_json(orient=orient)\n        result = pd.read_json(\n            data, orient=orient, convert_axes=convert_axes, numpy=numpy, dtype=dtype\n        )\n\n        expected = float_frame\n\n        assert_json_roundtrip_equal(result, expected, orient)",
        "begin_line": 115,
        "end_line": 123,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_roundtrip_intframe#128",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_roundtrip_intframe(self, orient, convert_axes, numpy, dtype, int_frame)",
        "snippet": "    def test_roundtrip_intframe(self, orient, convert_axes, numpy, dtype, int_frame):\n        data = int_frame.to_json(orient=orient)\n        result = pd.read_json(\n            data, orient=orient, convert_axes=convert_axes, numpy=numpy, dtype=dtype\n        )\n        expected = int_frame\n        if (\n            numpy\n            and (is_platform_32bit() or is_platform_windows())\n            and not dtype\n            and orient != \"split\"\n        ):\n            # TODO: see what is causing roundtrip dtype loss\n            expected = expected.astype(np.int32)\n\n        assert_json_roundtrip_equal(result, expected, orient)",
        "begin_line": 128,
        "end_line": 143,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_roundtrip_str_axes#148",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_roundtrip_str_axes(self, orient, convert_axes, numpy, dtype)",
        "snippet": "    def test_roundtrip_str_axes(self, orient, convert_axes, numpy, dtype):\n        df = DataFrame(\n            np.zeros((200, 4)),\n            columns=[str(i) for i in range(4)],\n            index=[str(i) for i in range(200)],\n            dtype=dtype,\n        )\n\n        # TODO: do we even need to support U3 dtypes?\n        if numpy and dtype == \"U3\" and orient != \"split\":\n            pytest.xfail(\"Can't decode directly to array\")\n\n        data = df.to_json(orient=orient)\n        result = pd.read_json(\n            data, orient=orient, convert_axes=convert_axes, numpy=numpy, dtype=dtype\n        )\n\n        expected = df.copy()\n        if not dtype:\n            expected = expected.astype(np.int64)\n\n        # index columns, and records orients cannot fully preserve the string\n        # dtype for axes as the index and column labels are used as keys in\n        # JSON objects. JSON keys are by definition strings, so there's no way\n        # to disambiguate whether those keys actually were strings or numeric\n        # beforehand and numeric wins out.\n        # TODO: Split should be able to support this\n        if convert_axes and (orient in (\"split\", \"index\", \"columns\")):\n            expected.columns = expected.columns.astype(np.int64)\n            expected.index = expected.index.astype(np.int64)\n        elif orient == \"records\" and convert_axes:\n            expected.columns = expected.columns.astype(np.int64)\n\n        assert_json_roundtrip_equal(result, expected, orient)",
        "begin_line": 148,
        "end_line": 181,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_roundtrip_categorical#185",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_roundtrip_categorical(self, orient, convert_axes, numpy)",
        "snippet": "    def test_roundtrip_categorical(self, orient, convert_axes, numpy):\n        # TODO: create a better frame to test with and improve coverage\n        if orient in (\"index\", \"columns\"):\n            pytest.xfail(f\"Can't have duplicate index values for orient '{orient}')\")\n\n        data = self.categorical.to_json(orient=orient)\n        if numpy and orient in (\"records\", \"values\"):\n            pytest.xfail(f\"Orient {orient} is broken with numpy=True\")\n\n        result = pd.read_json(\n            data, orient=orient, convert_axes=convert_axes, numpy=numpy\n        )\n\n        expected = self.categorical.copy()\n        expected.index = expected.index.astype(str)  # Categorical not preserved\n        expected.index.name = None  # index names aren't preserved in JSON\n\n        if not numpy and orient == \"index\":\n            expected = expected.sort_index()\n\n        assert_json_roundtrip_equal(result, expected, orient)",
        "begin_line": 185,
        "end_line": 205,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_roundtrip_empty#209",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_roundtrip_empty(self, orient, convert_axes, numpy, empty_frame)",
        "snippet": "    def test_roundtrip_empty(self, orient, convert_axes, numpy, empty_frame):\n        data = empty_frame.to_json(orient=orient)\n        result = pd.read_json(\n            data, orient=orient, convert_axes=convert_axes, numpy=numpy\n        )\n        expected = empty_frame.copy()\n\n        # TODO: both conditions below are probably bugs\n        if convert_axes:\n            expected.index = expected.index.astype(float)\n            expected.columns = expected.columns.astype(float)\n        if numpy and orient == \"values\":\n            expected = expected.reindex([0], axis=1).reset_index(drop=True)\n\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 209,
        "end_line": 223,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_roundtrip_timestamp#227",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_roundtrip_timestamp(self, orient, convert_axes, numpy, datetime_frame)",
        "snippet": "    def test_roundtrip_timestamp(self, orient, convert_axes, numpy, datetime_frame):\n        # TODO: improve coverage with date_format parameter\n        data = datetime_frame.to_json(orient=orient)\n        result = pd.read_json(\n            data, orient=orient, convert_axes=convert_axes, numpy=numpy\n        )\n        expected = datetime_frame.copy()\n\n        if not convert_axes:  # one off for ts handling\n            # DTI gets converted to epoch values\n            idx = expected.index.astype(np.int64) // 1000000\n            if orient != \"split\":  # TODO: handle consistently across orients\n                idx = idx.astype(str)\n\n            expected.index = idx\n\n        assert_json_roundtrip_equal(result, expected, orient)",
        "begin_line": 227,
        "end_line": 243,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_roundtrip_mixed#247",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_roundtrip_mixed(self, orient, convert_axes, numpy)",
        "snippet": "    def test_roundtrip_mixed(self, orient, convert_axes, numpy):\n        if numpy and orient != \"split\":\n            pytest.xfail(\"Can't decode directly to array\")\n\n        index = pd.Index([\"a\", \"b\", \"c\", \"d\", \"e\"])\n        values = {\n            \"A\": [0.0, 1.0, 2.0, 3.0, 4.0],\n            \"B\": [0.0, 1.0, 0.0, 1.0, 0.0],\n            \"C\": [\"foo1\", \"foo2\", \"foo3\", \"foo4\", \"foo5\"],\n            \"D\": [True, False, True, False, True],\n        }\n\n        df = DataFrame(data=values, index=index)\n\n        data = df.to_json(orient=orient)\n        result = pd.read_json(\n            data, orient=orient, convert_axes=convert_axes, numpy=numpy\n        )\n\n        expected = df.copy()\n        expected = expected.assign(**expected.select_dtypes(\"number\").astype(np.int64))\n\n        if not numpy and orient == \"index\":\n            expected = expected.sort_index()\n\n        assert_json_roundtrip_equal(result, expected, orient)",
        "begin_line": 247,
        "end_line": 272,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_from_json_bad_data_raises#304",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_from_json_bad_data_raises(self, data, msg, orient)",
        "snippet": "    def test_frame_from_json_bad_data_raises(self, data, msg, orient):\n        with pytest.raises(ValueError, match=msg):\n            read_json(StringIO(data), orient=orient)",
        "begin_line": 304,
        "end_line": 306,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_from_json_missing_data#311",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_from_json_missing_data(self, orient, convert_axes, numpy, dtype)",
        "snippet": "    def test_frame_from_json_missing_data(self, orient, convert_axes, numpy, dtype):\n        num_df = DataFrame([[1, 2], [4, 5, 6]])\n        result = read_json(\n            num_df.to_json(orient=orient),\n            orient=orient,\n            convert_axes=convert_axes,\n            dtype=dtype,\n        )\n        assert np.isnan(result.iloc[0, 2])\n\n        obj_df = DataFrame([[\"1\", \"2\"], [\"4\", \"5\", \"6\"]])\n        result = read_json(\n            obj_df.to_json(orient=orient),\n            orient=orient,\n            convert_axes=convert_axes,\n            dtype=dtype,\n        )\n        if not dtype:  # TODO: Special case for object data; maybe a bug?\n            assert result.iloc[0, 2] is None\n        else:\n            assert np.isnan(result.iloc[0, 2])",
        "begin_line": 311,
        "end_line": 331,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_infinity#335",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_infinity(self, orient, inf, dtype)",
        "snippet": "    def test_frame_infinity(self, orient, inf, dtype):\n        # infinities get mapped to nulls which get mapped to NaNs during\n        # deserialisation\n        df = DataFrame([[1, 2], [4, 5, 6]])\n        df.loc[0, 2] = inf\n        result = read_json(df.to_json(), dtype=dtype)\n        assert np.isnan(result.iloc[0, 2])",
        "begin_line": 335,
        "end_line": 341,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_to_json_float_precision#357",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_to_json_float_precision(self, value, precision, expected_val)",
        "snippet": "    def test_frame_to_json_float_precision(self, value, precision, expected_val):\n        df = pd.DataFrame([dict(a_float=value)])\n        encoded = df.to_json(double_precision=precision)\n        assert encoded == f'{{\"a_float\":{{\"0\":{expected_val}}}}}'",
        "begin_line": 357,
        "end_line": 360,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_to_json_except#362",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_to_json_except(self)",
        "snippet": "    def test_frame_to_json_except(self):\n        df = DataFrame([1, 2, 3])\n        msg = \"Invalid value 'garbage' for option 'orient'\"\n        with pytest.raises(ValueError, match=msg):\n            df.to_json(orient=\"garbage\")",
        "begin_line": 362,
        "end_line": 366,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_empty#368",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_empty(self)",
        "snippet": "    def test_frame_empty(self):\n        df = DataFrame(columns=[\"jim\", \"joe\"])\n        assert not df._is_mixed_type\n        tm.assert_frame_equal(\n            read_json(df.to_json(), dtype=dict(df.dtypes)), df, check_index_type=False\n        )\n        # GH 7445\n        result = pd.DataFrame({\"test\": []}, index=[]).to_json(orient=\"columns\")\n        expected = '{\"test\":{}}'\n        assert result == expected",
        "begin_line": 368,
        "end_line": 377,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_empty_mixedtype#379",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_empty_mixedtype(self)",
        "snippet": "    def test_frame_empty_mixedtype(self):\n        # mixed type\n        df = DataFrame(columns=[\"jim\", \"joe\"])\n        df[\"joe\"] = df[\"joe\"].astype(\"i8\")\n        assert df._is_mixed_type\n        tm.assert_frame_equal(\n            read_json(df.to_json(), dtype=dict(df.dtypes)), df, check_index_type=False\n        )",
        "begin_line": 379,
        "end_line": 386,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_mixedtype_orient#388",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_mixedtype_orient(self)",
        "snippet": "    def test_frame_mixedtype_orient(self):  # GH10289\n        vals = [\n            [10, 1, \"foo\", 0.1, 0.01],\n            [20, 2, \"bar\", 0.2, 0.02],\n            [30, 3, \"baz\", 0.3, 0.03],\n            [40, 4, \"qux\", 0.4, 0.04],\n        ]\n\n        df = DataFrame(\n            vals, index=list(\"abcd\"), columns=[\"1st\", \"2nd\", \"3rd\", \"4th\", \"5th\"]\n        )\n\n        assert df._is_mixed_type\n        right = df.copy()\n\n        for orient in [\"split\", \"index\", \"columns\"]:\n            inp = df.to_json(orient=orient)\n            left = read_json(inp, orient=orient, convert_axes=False)\n            tm.assert_frame_equal(left, right)\n\n        right.index = np.arange(len(df))\n        inp = df.to_json(orient=\"records\")\n        left = read_json(inp, orient=\"records\", convert_axes=False)\n        tm.assert_frame_equal(left, right)\n\n        right.columns = np.arange(df.shape[1])\n        inp = df.to_json(orient=\"values\")\n        left = read_json(inp, orient=\"values\", convert_axes=False)\n        tm.assert_frame_equal(left, right)",
        "begin_line": 388,
        "end_line": 416,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_v12_compat#418",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_v12_compat(self, datapath)",
        "snippet": "    def test_v12_compat(self, datapath):\n        df = DataFrame(\n            [\n                [1.56808523, 0.65727391, 1.81021139, -0.17251653],\n                [-0.2550111, -0.08072427, -0.03202878, -0.17581665],\n                [1.51493992, 0.11805825, 1.629455, -1.31506612],\n                [-0.02765498, 0.44679743, 0.33192641, -0.27885413],\n                [0.05951614, -2.69652057, 1.28163262, 0.34703478],\n            ],\n            columns=[\"A\", \"B\", \"C\", \"D\"],\n            index=pd.date_range(\"2000-01-03\", \"2000-01-07\"),\n        )\n        df[\"date\"] = pd.Timestamp(\"19920106 18:21:32.12\")\n        df.iloc[3, df.columns.get_loc(\"date\")] = pd.Timestamp(\"20130101\")\n        df[\"modified\"] = df[\"date\"]\n        df.iloc[1, df.columns.get_loc(\"modified\")] = pd.NaT\n\n        dirpath = datapath(\"io\", \"json\", \"data\")\n        v12_json = os.path.join(dirpath, \"tsframe_v012.json\")\n        df_unser = pd.read_json(v12_json)\n        tm.assert_frame_equal(df, df_unser)\n\n        df_iso = df.drop([\"modified\"], axis=1)\n        v12_iso_json = os.path.join(dirpath, \"tsframe_iso_v012.json\")\n        df_unser_iso = pd.read_json(v12_iso_json)\n        tm.assert_frame_equal(df_iso, df_unser_iso)",
        "begin_line": 418,
        "end_line": 443,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_blocks_compat_GH9037#445",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_blocks_compat_GH9037(self)",
        "snippet": "    def test_blocks_compat_GH9037(self):\n        index = pd.date_range(\"20000101\", periods=10, freq=\"H\")\n        df_mixed = DataFrame(\n            OrderedDict(\n                float_1=[\n                    -0.92077639,\n                    0.77434435,\n                    1.25234727,\n                    0.61485564,\n                    -0.60316077,\n                    0.24653374,\n                    0.28668979,\n                    -2.51969012,\n                    0.95748401,\n                    -1.02970536,\n                ],\n                int_1=[\n                    19680418,\n                    75337055,\n                    99973684,\n                    65103179,\n                    79373900,\n                    40314334,\n                    21290235,\n                    4991321,\n                    41903419,\n                    16008365,\n                ],\n                str_1=[\n                    \"78c608f1\",\n                    \"64a99743\",\n                    \"13d2ff52\",\n                    \"ca7f4af2\",\n                    \"97236474\",\n                    \"bde7e214\",\n                    \"1a6bde47\",\n                    \"b1190be5\",\n                    \"7a669144\",\n                    \"8d64d068\",\n                ],\n                float_2=[\n                    -0.0428278,\n                    -1.80872357,\n                    3.36042349,\n                    -0.7573685,\n                    -0.48217572,\n                    0.86229683,\n                    1.08935819,\n                    0.93898739,\n                    -0.03030452,\n                    1.43366348,\n                ],\n                str_2=[\n                    \"14f04af9\",\n                    \"d085da90\",\n                    \"4bcfac83\",\n                    \"81504caf\",\n                    \"2ffef4a9\",\n                    \"08e2f5c4\",\n                    \"07e1af03\",\n                    \"addbd4a7\",\n                    \"1f6a09ba\",\n                    \"4bfc4d87\",\n                ],\n                int_2=[\n                    86967717,\n                    98098830,\n                    51927505,\n                    20372254,\n                    12601730,\n                    20884027,\n                    34193846,\n                    10561746,\n                    24867120,\n                    76131025,\n                ],\n            ),\n            index=index,\n        )\n\n        # JSON deserialisation always creates unicode strings\n        df_mixed.columns = df_mixed.columns.astype(\"unicode\")\n\n        df_roundtrip = pd.read_json(df_mixed.to_json(orient=\"split\"), orient=\"split\")\n        tm.assert_frame_equal(\n            df_mixed,\n            df_roundtrip,\n            check_index_type=True,\n            check_column_type=True,\n            by_blocks=True,\n            check_exact=True,\n        )",
        "begin_line": 445,
        "end_line": 536,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_nonprintable_bytes#538",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_nonprintable_bytes(self)",
        "snippet": "    def test_frame_nonprintable_bytes(self):\n        # GH14256: failing column caused segfaults, if it is not the last one\n\n        class BinaryThing:\n            def __init__(self, hexed):\n                self.hexed = hexed\n                self.binary = bytes.fromhex(hexed)\n\n            def __str__(self) -> str:\n                return self.hexed\n\n        hexed = \"574b4454ba8c5eb4f98a8f45\"\n        binthing = BinaryThing(hexed)\n\n        # verify the proper conversion of printable content\n        df_printable = DataFrame({\"A\": [binthing.hexed]})\n        assert df_printable.to_json() == f'{{\"A\":{{\"0\":\"{hexed}\"}}}}'\n\n        # check if non-printable content throws appropriate Exception\n        df_nonprintable = DataFrame({\"A\": [binthing]})\n        msg = \"Unsupported UTF-8 sequence length when encoding string\"\n        with pytest.raises(OverflowError, match=msg):\n            df_nonprintable.to_json()\n\n        # the same with multiple columns threw segfaults\n        df_mixed = DataFrame({\"A\": [binthing], \"B\": [1]}, columns=[\"A\", \"B\"])\n        with pytest.raises(OverflowError):\n            df_mixed.to_json()\n\n        # default_handler should resolve exceptions for non-string types\n        result = df_nonprintable.to_json(default_handler=str)\n        expected = f'{{\"A\":{{\"0\":\"{hexed}\"}}}}'\n        assert result == expected\n        assert (\n            df_mixed.to_json(default_handler=str)\n            == f'{{\"A\":{{\"0\":\"{hexed}\"}},\"B\":{{\"0\":1}}}}'\n        )",
        "begin_line": 538,
        "end_line": 574,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.BinaryThing.test_frame_nonprintable_bytes#538",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.BinaryThing",
        "signature": "pandas.tests.io.json.test_pandas.BinaryThing.test_frame_nonprintable_bytes(self)",
        "snippet": "    def test_frame_nonprintable_bytes(self):\n        # GH14256: failing column caused segfaults, if it is not the last one\n\n        class BinaryThing:\n            def __init__(self, hexed):\n                self.hexed = hexed\n                self.binary = bytes.fromhex(hexed)\n\n            def __str__(self) -> str:\n                return self.hexed\n\n        hexed = \"574b4454ba8c5eb4f98a8f45\"\n        binthing = BinaryThing(hexed)\n\n        # verify the proper conversion of printable content\n        df_printable = DataFrame({\"A\": [binthing.hexed]})\n        assert df_printable.to_json() == f'{{\"A\":{{\"0\":\"{hexed}\"}}}}'\n\n        # check if non-printable content throws appropriate Exception\n        df_nonprintable = DataFrame({\"A\": [binthing]})\n        msg = \"Unsupported UTF-8 sequence length when encoding string\"\n        with pytest.raises(OverflowError, match=msg):\n            df_nonprintable.to_json()\n\n        # the same with multiple columns threw segfaults\n        df_mixed = DataFrame({\"A\": [binthing], \"B\": [1]}, columns=[\"A\", \"B\"])\n        with pytest.raises(OverflowError):\n            df_mixed.to_json()\n\n        # default_handler should resolve exceptions for non-string types\n        result = df_nonprintable.to_json(default_handler=str)\n        expected = f'{{\"A\":{{\"0\":\"{hexed}\"}}}}'\n        assert result == expected\n        assert (\n            df_mixed.to_json(default_handler=str)\n            == f'{{\"A\":{{\"0\":\"{hexed}\"}},\"B\":{{\"0\":1}}}}'\n        )",
        "begin_line": 538,
        "end_line": 574,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.BinaryThing.__init__#542",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.BinaryThing",
        "signature": "pandas.tests.io.json.test_pandas.BinaryThing.__init__(self, hexed)",
        "snippet": "            def __init__(self, hexed):\n                self.hexed = hexed\n                self.binary = bytes.fromhex(hexed)",
        "begin_line": 542,
        "end_line": 544,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.BinaryThing.__str__#546",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.BinaryThing",
        "signature": "pandas.tests.io.json.test_pandas.BinaryThing.__str__(self)",
        "snippet": "            def __str__(self) -> str:\n                return self.hexed",
        "begin_line": 546,
        "end_line": 547,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_label_overflow#576",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_label_overflow(self)",
        "snippet": "    def test_label_overflow(self):\n        # GH14256: buffer length not checked when writing label\n        result = pd.DataFrame({\"bar\" * 100000: [1], \"foo\": [1337]}).to_json()\n        expected = f'{{\"{\"bar\" * 100000}\":{{\"0\":1}},\"foo\":{{\"0\":1337}}}}'\n        assert result == expected",
        "begin_line": 576,
        "end_line": 580,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_non_unique_index#582",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_non_unique_index(self)",
        "snippet": "    def test_series_non_unique_index(self):\n        s = Series([\"a\", \"b\"], index=[1, 1])\n\n        msg = \"Series index must be unique for orient='index'\"\n        with pytest.raises(ValueError, match=msg):\n            s.to_json(orient=\"index\")\n\n        tm.assert_series_equal(\n            s, read_json(s.to_json(orient=\"split\"), orient=\"split\", typ=\"series\")\n        )\n        unser = read_json(s.to_json(orient=\"records\"), orient=\"records\", typ=\"series\")\n        tm.assert_numpy_array_equal(s.values, unser.values)",
        "begin_line": 582,
        "end_line": 593,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_default_orient#595",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_default_orient(self, string_series)",
        "snippet": "    def test_series_default_orient(self, string_series):\n        assert string_series.to_json() == string_series.to_json(orient=\"index\")",
        "begin_line": 595,
        "end_line": 596,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_roundtrip_simple#599",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_roundtrip_simple(self, orient, numpy, string_series)",
        "snippet": "    def test_series_roundtrip_simple(self, orient, numpy, string_series):\n        data = string_series.to_json(orient=orient)\n        result = pd.read_json(data, typ=\"series\", orient=orient, numpy=numpy)\n\n        expected = string_series\n        if orient in (\"values\", \"records\"):\n            expected = expected.reset_index(drop=True)\n        if orient != \"split\":\n            expected.name = None\n\n        tm.assert_series_equal(result, expected)",
        "begin_line": 599,
        "end_line": 609,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_roundtrip_object#613",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_roundtrip_object(self, orient, numpy, dtype, object_series)",
        "snippet": "    def test_series_roundtrip_object(self, orient, numpy, dtype, object_series):\n        data = object_series.to_json(orient=orient)\n        result = pd.read_json(\n            data, typ=\"series\", orient=orient, numpy=numpy, dtype=dtype\n        )\n\n        expected = object_series\n        if orient in (\"values\", \"records\"):\n            expected = expected.reset_index(drop=True)\n        if orient != \"split\":\n            expected.name = None\n\n        tm.assert_series_equal(result, expected)",
        "begin_line": 613,
        "end_line": 625,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_roundtrip_empty#628",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_roundtrip_empty(self, orient, numpy, empty_series)",
        "snippet": "    def test_series_roundtrip_empty(self, orient, numpy, empty_series):\n        data = empty_series.to_json(orient=orient)\n        result = pd.read_json(data, typ=\"series\", orient=orient, numpy=numpy)\n\n        expected = empty_series\n        if orient in (\"values\", \"records\"):\n            expected = expected.reset_index(drop=True)\n        else:\n            expected.index = expected.index.astype(float)\n\n        tm.assert_series_equal(result, expected)",
        "begin_line": 628,
        "end_line": 638,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_roundtrip_timeseries#641",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_roundtrip_timeseries(self, orient, numpy, datetime_series)",
        "snippet": "    def test_series_roundtrip_timeseries(self, orient, numpy, datetime_series):\n        data = datetime_series.to_json(orient=orient)\n        result = pd.read_json(data, typ=\"series\", orient=orient, numpy=numpy)\n\n        expected = datetime_series\n        if orient in (\"values\", \"records\"):\n            expected = expected.reset_index(drop=True)\n        if orient != \"split\":\n            expected.name = None\n\n        tm.assert_series_equal(result, expected)",
        "begin_line": 641,
        "end_line": 651,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_roundtrip_numeric#655",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_roundtrip_numeric(self, orient, numpy, dtype)",
        "snippet": "    def test_series_roundtrip_numeric(self, orient, numpy, dtype):\n        s = Series(range(6), index=[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"])\n        data = s.to_json(orient=orient)\n        result = pd.read_json(data, typ=\"series\", orient=orient, numpy=numpy)\n\n        expected = s.copy()\n        if orient in (\"values\", \"records\"):\n            expected = expected.reset_index(drop=True)\n\n        tm.assert_series_equal(result, expected)",
        "begin_line": 655,
        "end_line": 664,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_to_json_except#666",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_to_json_except(self)",
        "snippet": "    def test_series_to_json_except(self):\n        s = Series([1, 2, 3])\n        msg = \"Invalid value 'garbage' for option 'orient'\"\n        with pytest.raises(ValueError, match=msg):\n            s.to_json(orient=\"garbage\")",
        "begin_line": 666,
        "end_line": 670,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_from_json_precise_float#672",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_from_json_precise_float(self)",
        "snippet": "    def test_series_from_json_precise_float(self):\n        s = Series([4.56, 4.56, 4.56])\n        result = read_json(s.to_json(), typ=\"series\", precise_float=True)\n        tm.assert_series_equal(result, s, check_index_type=False)",
        "begin_line": 672,
        "end_line": 675,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_with_dtype#677",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_with_dtype(self)",
        "snippet": "    def test_series_with_dtype(self):\n        # GH 21986\n        s = Series([4.56, 4.56, 4.56])\n        result = read_json(s.to_json(), typ=\"series\", dtype=np.int64)\n        expected = Series([4] * 3)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 677,
        "end_line": 682,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_with_dtype_datetime#691",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_series_with_dtype_datetime(self, dtype, expected)",
        "snippet": "    def test_series_with_dtype_datetime(self, dtype, expected):\n        s = Series([\"2000-01-01\"], dtype=\"datetime64[ns]\")\n        data = s.to_json()\n        result = pd.read_json(data, typ=\"series\", dtype=dtype)\n        tm.assert_series_equal(result, expected)",
        "begin_line": 691,
        "end_line": 695,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_from_json_precise_float#697",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_from_json_precise_float(self)",
        "snippet": "    def test_frame_from_json_precise_float(self):\n        df = DataFrame([[4.56, 4.56, 4.56], [4.56, 4.56, 4.56]])\n        result = read_json(df.to_json(), precise_float=True)\n        tm.assert_frame_equal(\n            result, df, check_index_type=False, check_column_type=False\n        )",
        "begin_line": 697,
        "end_line": 702,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_typ#704",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_typ(self)",
        "snippet": "    def test_typ(self):\n\n        s = Series(range(6), index=[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], dtype=\"int64\")\n        result = read_json(s.to_json(), typ=None)\n        tm.assert_series_equal(result, s)",
        "begin_line": 704,
        "end_line": 708,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_reconstruction_index#710",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_reconstruction_index(self)",
        "snippet": "    def test_reconstruction_index(self):\n\n        df = DataFrame([[1, 2, 3], [4, 5, 6]])\n        result = read_json(df.to_json())\n\n        tm.assert_frame_equal(result, df)\n\n        df = DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]}, index=[\"A\", \"B\", \"C\"])\n        result = read_json(df.to_json())\n        tm.assert_frame_equal(result, df)",
        "begin_line": 710,
        "end_line": 719,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_path#721",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_path(self, float_frame, int_frame, datetime_frame)",
        "snippet": "    def test_path(self, float_frame, int_frame, datetime_frame):\n        with tm.ensure_clean(\"test.json\") as path:\n            for df in [\n                float_frame,\n                int_frame,\n                datetime_frame,\n            ]:\n                df.to_json(path)\n                read_json(path)",
        "begin_line": 721,
        "end_line": 729,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_axis_dates#731",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_axis_dates(self, datetime_series, datetime_frame)",
        "snippet": "    def test_axis_dates(self, datetime_series, datetime_frame):\n\n        # frame\n        json = datetime_frame.to_json()\n        result = read_json(json)\n        tm.assert_frame_equal(result, datetime_frame)\n\n        # series\n        json = datetime_series.to_json()\n        result = read_json(json, typ=\"series\")\n        tm.assert_series_equal(result, datetime_series, check_names=False)\n        assert result.name is None",
        "begin_line": 731,
        "end_line": 742,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_convert_dates#744",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_convert_dates(self, datetime_series, datetime_frame)",
        "snippet": "    def test_convert_dates(self, datetime_series, datetime_frame):\n\n        # frame\n        df = datetime_frame\n        df[\"date\"] = Timestamp(\"20130101\")\n\n        json = df.to_json()\n        result = read_json(json)\n        tm.assert_frame_equal(result, df)\n\n        df[\"foo\"] = 1.0\n        json = df.to_json(date_unit=\"ns\")\n\n        result = read_json(json, convert_dates=False)\n        expected = df.copy()\n        expected[\"date\"] = expected[\"date\"].values.view(\"i8\")\n        expected[\"foo\"] = expected[\"foo\"].astype(\"int64\")\n        tm.assert_frame_equal(result, expected)\n\n        # series\n        ts = Series(Timestamp(\"20130101\"), index=datetime_series.index)\n        json = ts.to_json()\n        result = read_json(json, typ=\"series\")\n        tm.assert_series_equal(result, ts)",
        "begin_line": 744,
        "end_line": 767,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_date_index_and_values#774",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_date_index_and_values(self, date_format, as_object, date_typ)",
        "snippet": "    def test_date_index_and_values(self, date_format, as_object, date_typ):\n        data = [date_typ(year=2020, month=1, day=1), pd.NaT]\n        if as_object:\n            data.append(\"a\")\n\n        ser = pd.Series(data, index=data)\n        result = ser.to_json(date_format=date_format)\n\n        if date_format == \"epoch\":\n            expected = '{\"1577836800000\":1577836800000,\"null\":null}'\n        else:\n            expected = (\n                '{\"2020-01-01T00:00:00.000Z\":\"2020-01-01T00:00:00.000Z\",\"null\":null}'\n            )\n\n        if as_object:\n            expected = expected.replace(\"}\", ',\"a\":\"a\"}')\n\n        assert result == expected",
        "begin_line": 774,
        "end_line": 792,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_convert_dates_infer#806",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_convert_dates_infer(self, infer_word)",
        "snippet": "    def test_convert_dates_infer(self, infer_word):\n        # GH10747\n        from pandas.io.json import dumps\n\n        data = [{\"id\": 1, infer_word: 1036713600000}, {\"id\": 2}]\n        expected = DataFrame(\n            [[1, Timestamp(\"2002-11-08\")], [2, pd.NaT]], columns=[\"id\", infer_word]\n        )\n        result = read_json(dumps(data))[[\"id\", infer_word]]\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 806,
        "end_line": 815,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_date_format_frame#827",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_date_format_frame(self, date, date_unit, datetime_frame)",
        "snippet": "    def test_date_format_frame(self, date, date_unit, datetime_frame):\n        df = datetime_frame\n\n        df[\"date\"] = Timestamp(date)\n        df.iloc[1, df.columns.get_loc(\"date\")] = pd.NaT\n        df.iloc[5, df.columns.get_loc(\"date\")] = pd.NaT\n        if date_unit:\n            json = df.to_json(date_format=\"iso\", date_unit=date_unit)\n        else:\n            json = df.to_json(date_format=\"iso\")\n        result = read_json(json)\n        expected = df.copy()\n        expected.index = expected.index.tz_localize(\"UTC\")\n        expected[\"date\"] = expected[\"date\"].dt.tz_localize(\"UTC\")\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 827,
        "end_line": 841,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_date_format_frame_raises#843",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_date_format_frame_raises(self, datetime_frame)",
        "snippet": "    def test_date_format_frame_raises(self, datetime_frame):\n        df = datetime_frame\n        msg = \"Invalid value 'foo' for option 'date_unit'\"\n        with pytest.raises(ValueError, match=msg):\n            df.to_json(date_format=\"iso\", date_unit=\"foo\")",
        "begin_line": 843,
        "end_line": 847,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_date_format_series#859",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_date_format_series(self, date, date_unit, datetime_series)",
        "snippet": "    def test_date_format_series(self, date, date_unit, datetime_series):\n        ts = Series(Timestamp(date), index=datetime_series.index)\n        ts.iloc[1] = pd.NaT\n        ts.iloc[5] = pd.NaT\n        if date_unit:\n            json = ts.to_json(date_format=\"iso\", date_unit=date_unit)\n        else:\n            json = ts.to_json(date_format=\"iso\")\n        result = read_json(json, typ=\"series\")\n        expected = ts.copy()\n        expected.index = expected.index.tz_localize(\"UTC\")\n        expected = expected.dt.tz_localize(\"UTC\")\n        tm.assert_series_equal(result, expected)",
        "begin_line": 859,
        "end_line": 871,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_date_format_series_raises#873",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_date_format_series_raises(self, datetime_series)",
        "snippet": "    def test_date_format_series_raises(self, datetime_series):\n        ts = Series(Timestamp(\"20130101 20:43:42.123\"), index=datetime_series.index)\n        msg = \"Invalid value 'foo' for option 'date_unit'\"\n        with pytest.raises(ValueError, match=msg):\n            ts.to_json(date_format=\"iso\", date_unit=\"foo\")",
        "begin_line": 873,
        "end_line": 877,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_date_unit#880",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_date_unit(self, unit, datetime_frame)",
        "snippet": "    def test_date_unit(self, unit, datetime_frame):\n        df = datetime_frame\n        df[\"date\"] = Timestamp(\"20130101 20:43:42\")\n        dl = df.columns.get_loc(\"date\")\n        df.iloc[1, dl] = Timestamp(\"19710101 20:43:42\")\n        df.iloc[2, dl] = Timestamp(\"21460101 20:43:42\")\n        df.iloc[4, dl] = pd.NaT\n\n        json = df.to_json(date_format=\"epoch\", date_unit=unit)\n\n        # force date unit\n        result = read_json(json, date_unit=unit)\n        tm.assert_frame_equal(result, df)\n\n        # detect date unit\n        result = read_json(json, date_unit=None)\n        tm.assert_frame_equal(result, df)",
        "begin_line": 880,
        "end_line": 896,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_weird_nested_json#898",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_weird_nested_json(self)",
        "snippet": "    def test_weird_nested_json(self):\n        # this used to core dump the parser\n        s = r\"\"\"{\n        \"status\": \"success\",\n        \"data\": {\n        \"posts\": [\n            {\n            \"id\": 1,\n            \"title\": \"A blog post\",\n            \"body\": \"Some useful content\"\n            },\n            {\n            \"id\": 2,\n            \"title\": \"Another blog post\",\n            \"body\": \"More content\"\n            }\n           ]\n          }\n        }\"\"\"\n\n        read_json(s)",
        "begin_line": 898,
        "end_line": 918,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_doc_example#920",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_doc_example(self)",
        "snippet": "    def test_doc_example(self):\n        dfj2 = DataFrame(np.random.randn(5, 2), columns=list(\"AB\"))\n        dfj2[\"date\"] = Timestamp(\"20130101\")\n        dfj2[\"ints\"] = range(5)\n        dfj2[\"bools\"] = True\n        dfj2.index = pd.date_range(\"20130101\", periods=5)\n\n        json = dfj2.to_json()\n        result = read_json(json, dtype={\"ints\": np.int64, \"bools\": np.bool_})\n        tm.assert_frame_equal(result, result)",
        "begin_line": 920,
        "end_line": 929,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_misc_example#931",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_misc_example(self)",
        "snippet": "    def test_misc_example(self):\n\n        # parsing unordered input fails\n        result = read_json('[{\"a\": 1, \"b\": 2}, {\"b\":2, \"a\" :1}]', numpy=True)\n        expected = DataFrame([[1, 2], [1, 2]], columns=[\"a\", \"b\"])\n\n        error_msg = \"\"\"DataFrame\\\\.index are different\n\nDataFrame\\\\.index values are different \\\\(100\\\\.0 %\\\\)\n\\\\[left\\\\]:  Index\\\\(\\\\['a', 'b'\\\\], dtype='object'\\\\)\n\\\\[right\\\\]: RangeIndex\\\\(start=0, stop=2, step=1\\\\)\"\"\"\n        with pytest.raises(AssertionError, match=error_msg):\n            tm.assert_frame_equal(result, expected, check_index_type=False)\n\n        result = read_json('[{\"a\": 1, \"b\": 2}, {\"b\":2, \"a\" :1}]')\n        expected = DataFrame([[1, 2], [1, 2]], columns=[\"a\", \"b\"])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 931,
        "end_line": 947,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_round_trip_exception_#951",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_round_trip_exception_(self)",
        "snippet": "    def test_round_trip_exception_(self):\n        # GH 3867\n        csv = \"https://raw.github.com/hayd/lahman2012/master/csvs/Teams.csv\"\n        df = pd.read_csv(csv)\n        s = df.to_json()\n        result = pd.read_json(s)\n        tm.assert_frame_equal(result.reindex(index=df.index, columns=df.columns), df)",
        "begin_line": 951,
        "end_line": 957,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_url#969",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_url(self, field, dtype)",
        "snippet": "    def test_url(self, field, dtype):\n        url = \"https://api.github.com/repos/pandas-dev/pandas/issues?per_page=5\"  # noqa\n        result = read_json(url, convert_dates=True)\n        assert result[field].dtype == dtype",
        "begin_line": 969,
        "end_line": 972,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_timedelta#974",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_timedelta(self)",
        "snippet": "    def test_timedelta(self):\n        converter = lambda x: pd.to_timedelta(x, unit=\"ms\")\n\n        s = Series([timedelta(23), timedelta(seconds=5)])\n        assert s.dtype == \"timedelta64[ns]\"\n\n        result = pd.read_json(s.to_json(), typ=\"series\").apply(converter)\n        tm.assert_series_equal(result, s)\n\n        s = Series([timedelta(23), timedelta(seconds=5)], index=pd.Index([0, 1]))\n        assert s.dtype == \"timedelta64[ns]\"\n        result = pd.read_json(s.to_json(), typ=\"series\").apply(converter)\n        tm.assert_series_equal(result, s)\n\n        frame = DataFrame([timedelta(23), timedelta(seconds=5)])\n        assert frame[0].dtype == \"timedelta64[ns]\"\n        tm.assert_frame_equal(frame, pd.read_json(frame.to_json()).apply(converter))\n\n        frame = DataFrame(\n            {\n                \"a\": [timedelta(days=23), timedelta(seconds=5)],\n                \"b\": [1, 2],\n                \"c\": pd.date_range(start=\"20130101\", periods=2),\n            }\n        )\n\n        result = pd.read_json(frame.to_json(date_unit=\"ns\"))\n        result[\"a\"] = pd.to_timedelta(result.a, unit=\"ns\")\n        result[\"c\"] = pd.to_datetime(result.c)\n        tm.assert_frame_equal(frame, result)",
        "begin_line": 974,
        "end_line": 1003,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_mixed_timedelta_datetime#1005",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_mixed_timedelta_datetime(self)",
        "snippet": "    def test_mixed_timedelta_datetime(self):\n        frame = DataFrame(\n            {\"a\": [timedelta(23), pd.Timestamp(\"20130101\")]}, dtype=object\n        )\n\n        expected = DataFrame(\n            {\"a\": [pd.Timedelta(frame.a[0]).value, pd.Timestamp(frame.a[1]).value]}\n        )\n        result = pd.read_json(frame.to_json(date_unit=\"ns\"), dtype={\"a\": \"int64\"})\n        tm.assert_frame_equal(result, expected, check_index_type=False)",
        "begin_line": 1005,
        "end_line": 1014,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_timedelta_to_json#1019",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_timedelta_to_json(self, as_object, date_format, timedelta_typ)",
        "snippet": "    def test_timedelta_to_json(self, as_object, date_format, timedelta_typ):\n        # GH28156: to_json not correctly formatting Timedelta\n        data = [timedelta_typ(days=1), timedelta_typ(days=2), pd.NaT]\n        if as_object:\n            data.append(\"a\")\n\n        ser = pd.Series(data, index=data)\n        if date_format == \"iso\":\n            expected = (\n                '{\"P1DT0H0M0S\":\"P1DT0H0M0S\",\"P2DT0H0M0S\":\"P2DT0H0M0S\",\"null\":null}'\n            )\n        else:\n            expected = '{\"86400000\":86400000,\"172800000\":172800000,\"null\":null}'\n\n        if as_object:\n            expected = expected.replace(\"}\", ',\"a\":\"a\"}')\n\n        result = ser.to_json(date_format=date_format)\n        assert result == expected",
        "begin_line": 1019,
        "end_line": 1037,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_default_handler#1039",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_default_handler(self)",
        "snippet": "    def test_default_handler(self):\n        value = object()\n        frame = DataFrame({\"a\": [7, value]})\n        expected = DataFrame({\"a\": [7, str(value)]})\n        result = pd.read_json(frame.to_json(default_handler=str))\n        tm.assert_frame_equal(expected, result, check_index_type=False)",
        "begin_line": 1039,
        "end_line": 1044,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_default_handler_indirect#1046",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_default_handler_indirect(self)",
        "snippet": "    def test_default_handler_indirect(self):\n        from pandas.io.json import dumps\n\n        def default(obj):\n            if isinstance(obj, complex):\n                return [(\"mathjs\", \"Complex\"), (\"re\", obj.real), (\"im\", obj.imag)]\n            return str(obj)\n\n        df_list = [\n            9,\n            DataFrame(\n                {\"a\": [1, \"STR\", complex(4, -5)], \"b\": [float(\"nan\"), None, \"N/A\"]},\n                columns=[\"a\", \"b\"],\n            ),\n        ]\n        expected = (\n            '[9,[[1,null],[\"STR\",null],[[[\"mathjs\",\"Complex\"],'\n            '[\"re\",4.0],[\"im\",-5.0]],\"N\\\\/A\"]]]'\n        )\n        assert dumps(df_list, default_handler=default, orient=\"values\") == expected",
        "begin_line": 1046,
        "end_line": 1065,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.default#1049",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.default(obj)",
        "snippet": "        def default(obj):\n            if isinstance(obj, complex):\n                return [(\"mathjs\", \"Complex\"), (\"re\", obj.real), (\"im\", obj.imag)]\n            return str(obj)",
        "begin_line": 1049,
        "end_line": 1052,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_default_handler_numpy_unsupported_dtype#1067",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_default_handler_numpy_unsupported_dtype(self)",
        "snippet": "    def test_default_handler_numpy_unsupported_dtype(self):\n        # GH12554 to_json raises 'Unhandled numpy dtype 15'\n        df = DataFrame(\n            {\"a\": [1, 2.3, complex(4, -5)], \"b\": [float(\"nan\"), None, complex(1.2, 0)]},\n            columns=[\"a\", \"b\"],\n        )\n        expected = (\n            '[[\"(1+0j)\",\"(nan+0j)\"],'\n            '[\"(2.3+0j)\",\"(nan+0j)\"],'\n            '[\"(4-5j)\",\"(1.2+0j)\"]]'\n        )\n        assert df.to_json(default_handler=str, orient=\"values\") == expected",
        "begin_line": 1067,
        "end_line": 1078,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_default_handler_raises#1080",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_default_handler_raises(self)",
        "snippet": "    def test_default_handler_raises(self):\n        msg = \"raisin\"\n\n        def my_handler_raises(obj):\n            raise TypeError(msg)\n\n        with pytest.raises(TypeError, match=msg):\n            DataFrame({\"a\": [1, 2, object()]}).to_json(\n                default_handler=my_handler_raises\n            )\n        with pytest.raises(TypeError, match=msg):\n            DataFrame({\"a\": [1, 2, complex(4, -5)]}).to_json(\n                default_handler=my_handler_raises\n            )",
        "begin_line": 1080,
        "end_line": 1093,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.my_handler_raises#1083",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.my_handler_raises(obj)",
        "snippet": "        def my_handler_raises(obj):\n            raise TypeError(msg)",
        "begin_line": 1083,
        "end_line": 1084,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_categorical#1095",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_categorical(self)",
        "snippet": "    def test_categorical(self):\n        # GH4377 df.to_json segfaults with non-ndarray blocks\n        df = DataFrame({\"A\": [\"a\", \"b\", \"c\", \"a\", \"b\", \"b\", \"a\"]})\n        df[\"B\"] = df[\"A\"]\n        expected = df.to_json()\n\n        df[\"B\"] = df[\"A\"].astype(\"category\")\n        assert expected == df.to_json()\n\n        s = df[\"A\"]\n        sc = df[\"B\"]\n        assert s.to_json() == sc.to_json()",
        "begin_line": 1095,
        "end_line": 1106,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_datetime_tz#1108",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_datetime_tz(self)",
        "snippet": "    def test_datetime_tz(self):\n        # GH4377 df.to_json segfaults with non-ndarray blocks\n        tz_range = pd.date_range(\"20130101\", periods=3, tz=\"US/Eastern\")\n        tz_naive = tz_range.tz_convert(\"utc\").tz_localize(None)\n\n        df = DataFrame({\"A\": tz_range, \"B\": pd.date_range(\"20130101\", periods=3)})\n\n        df_naive = df.copy()\n        df_naive[\"A\"] = tz_naive\n        expected = df_naive.to_json()\n        assert expected == df.to_json()\n\n        stz = Series(tz_range)\n        s_naive = Series(tz_naive)\n        assert stz.to_json() == s_naive.to_json()",
        "begin_line": 1108,
        "end_line": 1122,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_sparse#1124",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_sparse(self)",
        "snippet": "    def test_sparse(self):\n        # GH4377 df.to_json segfaults with non-ndarray blocks\n        df = pd.DataFrame(np.random.randn(10, 4))\n        df.loc[:8] = np.nan\n\n        sdf = df.astype(\"Sparse\")\n        expected = df.to_json()\n        assert expected == sdf.to_json()\n\n        s = pd.Series(np.random.randn(10))\n        s.loc[:8] = np.nan\n        ss = s.astype(\"Sparse\")\n\n        expected = s.to_json()\n        assert expected == ss.to_json()",
        "begin_line": 1124,
        "end_line": 1138,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_tz_is_utc#1148",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_tz_is_utc(self, ts)",
        "snippet": "    def test_tz_is_utc(self, ts):\n        from pandas.io.json import dumps\n\n        exp = '\"2013-01-10T05:00:00.000Z\"'\n\n        assert dumps(ts, iso_dates=True) == exp\n        dt = ts.to_pydatetime()\n        assert dumps(dt, iso_dates=True) == exp",
        "begin_line": 1148,
        "end_line": 1155,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_tz_range_is_utc#1165",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_tz_range_is_utc(self, tz_range)",
        "snippet": "    def test_tz_range_is_utc(self, tz_range):\n        from pandas.io.json import dumps\n\n        exp = '[\"2013-01-01T05:00:00.000Z\",\"2013-01-02T05:00:00.000Z\"]'\n        dfexp = (\n            '{\"DT\":{'\n            '\"0\":\"2013-01-01T05:00:00.000Z\",'\n            '\"1\":\"2013-01-02T05:00:00.000Z\"}}'\n        )\n\n        assert dumps(tz_range, iso_dates=True) == exp\n        dti = pd.DatetimeIndex(tz_range)\n        assert dumps(dti, iso_dates=True) == exp\n        df = DataFrame({\"DT\": dti})\n        result = dumps(df, iso_dates=True)\n        assert result == dfexp",
        "begin_line": 1165,
        "end_line": 1180,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_read_inline_jsonl#1182",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_read_inline_jsonl(self)",
        "snippet": "    def test_read_inline_jsonl(self):\n        # GH9180\n        result = read_json('{\"a\": 1, \"b\": 2}\\n{\"b\":2, \"a\" :1}\\n', lines=True)\n        expected = DataFrame([[1, 2], [1, 2]], columns=[\"a\", \"b\"])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1182,
        "end_line": 1186,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_read_s3_jsonl#1189",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_read_s3_jsonl(self, s3_resource)",
        "snippet": "    def test_read_s3_jsonl(self, s3_resource):\n        # GH17200\n\n        result = read_json(\"s3n://pandas-test/items.jsonl\", lines=True)\n        expected = DataFrame([[1, 2], [1, 2]], columns=[\"a\", \"b\"])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1189,
        "end_line": 1194,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_read_local_jsonl#1196",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_read_local_jsonl(self)",
        "snippet": "    def test_read_local_jsonl(self):\n        # GH17200\n        with tm.ensure_clean(\"tmp_items.json\") as path:\n            with open(path, \"w\") as infile:\n                infile.write('{\"a\": 1, \"b\": 2}\\n{\"b\":2, \"a\" :1}\\n')\n            result = read_json(path, lines=True)\n            expected = DataFrame([[1, 2], [1, 2]], columns=[\"a\", \"b\"])\n            tm.assert_frame_equal(result, expected)",
        "begin_line": 1196,
        "end_line": 1203,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_read_jsonl_unicode_chars#1205",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_read_jsonl_unicode_chars(self)",
        "snippet": "    def test_read_jsonl_unicode_chars(self):\n        # GH15132: non-ascii unicode characters\n        # \\u201d == RIGHT DOUBLE QUOTATION MARK\n\n        # simulate file handle\n        json = '{\"a\": \"foo\u201d\", \"b\": \"bar\"}\\n{\"a\": \"foo\", \"b\": \"bar\"}\\n'\n        json = StringIO(json)\n        result = read_json(json, lines=True)\n        expected = DataFrame([[\"foo\\u201d\", \"bar\"], [\"foo\", \"bar\"]], columns=[\"a\", \"b\"])\n        tm.assert_frame_equal(result, expected)\n\n        # simulate string\n        json = '{\"a\": \"foo\u201d\", \"b\": \"bar\"}\\n{\"a\": \"foo\", \"b\": \"bar\"}\\n'\n        result = read_json(json, lines=True)\n        expected = DataFrame([[\"foo\\u201d\", \"bar\"], [\"foo\", \"bar\"]], columns=[\"a\", \"b\"])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1205,
        "end_line": 1220,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_read_json_large_numbers#1222",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_read_json_large_numbers(self)",
        "snippet": "    def test_read_json_large_numbers(self):\n        # GH18842\n        json = '{\"articleId\": \"1404366058080022500245\"}'\n        json = StringIO(json)\n        result = read_json(json, typ=\"series\")\n        expected = Series(1.404366e21, index=[\"articleId\"])\n        tm.assert_series_equal(result, expected)\n\n        json = '{\"0\": {\"articleId\": \"1404366058080022500245\"}}'\n        json = StringIO(json)\n        result = read_json(json)\n        expected = DataFrame(1.404366e21, index=[\"articleId\"], columns=[0])\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1222,
        "end_line": 1234,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_to_jsonl#1236",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_to_jsonl(self)",
        "snippet": "    def test_to_jsonl(self):\n        # GH9180\n        df = DataFrame([[1, 2], [1, 2]], columns=[\"a\", \"b\"])\n        result = df.to_json(orient=\"records\", lines=True)\n        expected = '{\"a\":1,\"b\":2}\\n{\"a\":1,\"b\":2}'\n        assert result == expected\n\n        df = DataFrame([[\"foo}\", \"bar\"], ['foo\"', \"bar\"]], columns=[\"a\", \"b\"])\n        result = df.to_json(orient=\"records\", lines=True)\n        expected = '{\"a\":\"foo}\",\"b\":\"bar\"}\\n{\"a\":\"foo\\\\\"\",\"b\":\"bar\"}'\n        assert result == expected\n        tm.assert_frame_equal(pd.read_json(result, lines=True), df)\n\n        # GH15096: escaped characters in columns and data\n        df = DataFrame([[\"foo\\\\\", \"bar\"], ['foo\"', \"bar\"]], columns=[\"a\\\\\", \"b\"])\n        result = df.to_json(orient=\"records\", lines=True)\n        expected = '{\"a\\\\\\\\\":\"foo\\\\\\\\\",\"b\":\"bar\"}\\n{\"a\\\\\\\\\":\"foo\\\\\"\",\"b\":\"bar\"}'\n        assert result == expected\n        tm.assert_frame_equal(pd.read_json(result, lines=True), df)",
        "begin_line": 1236,
        "end_line": 1254,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_latin_encoding#1257",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_latin_encoding(self)",
        "snippet": "    def test_latin_encoding(self):\n        # GH 13774\n        pytest.skip(\"encoding not implemented in .to_json(), xref #13774\")\n\n        values = [\n            [b\"E\\xc9, 17\", b\"\", b\"a\", b\"b\", b\"c\"],\n            [b\"E\\xc9, 17\", b\"a\", b\"b\", b\"c\"],\n            [b\"EE, 17\", b\"\", b\"a\", b\"b\", b\"c\"],\n            [b\"E\\xc9, 17\", b\"\\xf8\\xfc\", b\"a\", b\"b\", b\"c\"],\n            [b\"\", b\"a\", b\"b\", b\"c\"],\n            [b\"\\xf8\\xfc\", b\"a\", b\"b\", b\"c\"],\n            [b\"A\\xf8\\xfc\", b\"\", b\"a\", b\"b\", b\"c\"],\n            [np.nan, b\"\", b\"b\", b\"c\"],\n            [b\"A\\xf8\\xfc\", np.nan, b\"\", b\"b\", b\"c\"],\n        ]\n\n        values = [\n            [x.decode(\"latin-1\") if isinstance(x, bytes) else x for x in y]\n            for y in values\n        ]\n\n        examples = []\n        for dtype in [\"category\", object]:\n            for val in values:\n                examples.append(Series(val, dtype=dtype))\n\n        def roundtrip(s, encoding=\"latin-1\"):\n            with tm.ensure_clean(\"test.json\") as path:\n                s.to_json(path, encoding=encoding)\n                retr = read_json(path, encoding=encoding)\n                tm.assert_series_equal(s, retr, check_categorical=False)\n\n        for s in examples:\n            roundtrip(s)",
        "begin_line": 1257,
        "end_line": 1290,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.roundtrip#1283",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.roundtrip(s, encoding='latin-1')",
        "snippet": "        def roundtrip(s, encoding=\"latin-1\"):\n            with tm.ensure_clean(\"test.json\") as path:\n                s.to_json(path, encoding=encoding)\n                retr = read_json(path, encoding=encoding)\n                tm.assert_series_equal(s, retr, check_categorical=False)",
        "begin_line": 1283,
        "end_line": 1287,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_data_frame_size_after_to_json#1292",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_data_frame_size_after_to_json(self)",
        "snippet": "    def test_data_frame_size_after_to_json(self):\n        # GH15344\n        df = DataFrame({\"a\": [str(1)]})\n\n        size_before = df.memory_usage(index=True, deep=True).sum()\n        df.to_json()\n        size_after = df.memory_usage(index=True, deep=True).sum()\n\n        assert size_before == size_after",
        "begin_line": 1292,
        "end_line": 1300,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_from_json_to_json_table_index_and_columns#1306",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_from_json_to_json_table_index_and_columns(self, index, columns)",
        "snippet": "    def test_from_json_to_json_table_index_and_columns(self, index, columns):\n        # GH25433 GH25435\n        expected = DataFrame([[1, 2], [3, 4]], index=index, columns=columns)\n        dfjson = expected.to_json(orient=\"table\")\n        result = pd.read_json(dfjson, orient=\"table\")\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1306,
        "end_line": 1311,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_from_json_to_json_table_dtypes#1313",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_from_json_to_json_table_dtypes(self)",
        "snippet": "    def test_from_json_to_json_table_dtypes(self):\n        # GH21345\n        expected = pd.DataFrame({\"a\": [1, 2], \"b\": [3.0, 4.0], \"c\": [\"5\", \"6\"]})\n        dfjson = expected.to_json(orient=\"table\")\n        result = pd.read_json(dfjson, orient=\"table\")\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1313,
        "end_line": 1318,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_read_json_table_dtype_raises#1321",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_read_json_table_dtype_raises(self, dtype)",
        "snippet": "    def test_read_json_table_dtype_raises(self, dtype):\n        # GH21345\n        df = pd.DataFrame({\"a\": [1, 2], \"b\": [3.0, 4.0], \"c\": [\"5\", \"6\"]})\n        dfjson = df.to_json(orient=\"table\")\n        msg = \"cannot pass both dtype and orient='table'\"\n        with pytest.raises(ValueError, match=msg):\n            pd.read_json(dfjson, orient=\"table\", dtype=dtype)",
        "begin_line": 1321,
        "end_line": 1327,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_read_json_table_convert_axes_raises#1329",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_read_json_table_convert_axes_raises(self)",
        "snippet": "    def test_read_json_table_convert_axes_raises(self):\n        # GH25433 GH25435\n        df = DataFrame([[1, 2], [3, 4]], index=[1.0, 2.0], columns=[\"1.\", \"2.\"])\n        dfjson = df.to_json(orient=\"table\")\n        msg = \"cannot pass both convert_axes and orient='table'\"\n        with pytest.raises(ValueError, match=msg):\n            pd.read_json(dfjson, orient=\"table\", convert_axes=True)",
        "begin_line": 1329,
        "end_line": 1335,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_index_false_to_json_split#1365",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_index_false_to_json_split(self, data, expected)",
        "snippet": "    def test_index_false_to_json_split(self, data, expected):\n        # GH 17394\n        # Testing index=False in to_json with orient='split'\n\n        result = data.to_json(orient=\"split\", index=False)\n        result = json.loads(result)\n\n        assert result == expected",
        "begin_line": 1365,
        "end_line": 1372,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_index_false_to_json_table#1389",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_index_false_to_json_table(self, data)",
        "snippet": "    def test_index_false_to_json_table(self, data):\n        # GH 17394\n        # Testing index=False in to_json with orient='table'\n\n        result = data.to_json(orient=\"table\", index=False)\n        result = json.loads(result)\n\n        expected = {\n            \"schema\": pd.io.json.build_table_schema(data, index=False),\n            \"data\": DataFrame(data).to_dict(orient=\"records\"),\n        }\n\n        assert result == expected",
        "begin_line": 1389,
        "end_line": 1401,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_index_false_error_to_json#1404",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_index_false_error_to_json(self, orient)",
        "snippet": "    def test_index_false_error_to_json(self, orient):\n        # GH 17394\n        # Testing error message from to_json with index=False\n\n        df = pd.DataFrame([[1, 2], [4, 5]], columns=[\"a\", \"b\"])\n\n        msg = \"'index=False' is only valid when 'orient' is 'split' or 'table'\"\n        with pytest.raises(ValueError, match=msg):\n            df.to_json(orient=orient, index=False)",
        "begin_line": 1404,
        "end_line": 1412,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_index_false_from_json_to_json#1416",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_index_false_from_json_to_json(self, orient, index)",
        "snippet": "    def test_index_false_from_json_to_json(self, orient, index):\n        # GH25170\n        # Test index=False in from_json to_json\n        expected = DataFrame({\"a\": [1, 2], \"b\": [3, 4]})\n        dfjson = expected.to_json(orient=orient, index=index)\n        result = read_json(dfjson, orient=orient)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1416,
        "end_line": 1422,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_read_timezone_information#1424",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_read_timezone_information(self)",
        "snippet": "    def test_read_timezone_information(self):\n        # GH 25546\n        result = read_json(\n            '{\"2019-01-01T11:00:00.000Z\":88}', typ=\"series\", orient=\"index\"\n        )\n        expected = Series([88], index=DatetimeIndex([\"2019-01-01 11:00:00\"], tz=\"UTC\"))\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1424,
        "end_line": 1430,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_timedelta_as_label#1435",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_timedelta_as_label(self, date_format, key)",
        "snippet": "    def test_timedelta_as_label(self, date_format, key):\n        df = pd.DataFrame([[1]], columns=[pd.Timedelta(\"1D\")])\n        expected = f'{{\"{key}\":{{\"0\":1}}}}'\n        result = df.to_json(date_format=date_format)\n\n        assert result == expected",
        "begin_line": 1435,
        "end_line": 1440,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_tuple_labels#1453",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_tuple_labels(self, orient, expected)",
        "snippet": "    def test_tuple_labels(self, orient, expected):\n        # GH 20500\n        df = pd.DataFrame([[1]], index=[(\"a\", \"b\")], columns=[(\"c\", \"d\")])\n        result = df.to_json(orient=orient)\n        assert result == expected",
        "begin_line": 1453,
        "end_line": 1457,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_to_json_indent#1460",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_to_json_indent(self, indent)",
        "snippet": "    def test_to_json_indent(self, indent):\n        # GH 12004\n        df = pd.DataFrame([[\"foo\", \"bar\"], [\"baz\", \"qux\"]], columns=[\"a\", \"b\"])\n\n        result = df.to_json(indent=indent)\n        spaces = \" \" * indent\n        expected = f\"\"\"{{\n{spaces}\"a\":{{\n{spaces}{spaces}\"0\":\"foo\",\n{spaces}{spaces}\"1\":\"baz\"\n{spaces}}},\n{spaces}\"b\":{{\n{spaces}{spaces}\"0\":\"bar\",\n{spaces}{spaces}\"1\":\"qux\"\n{spaces}}}\n}}\"\"\"\n\n        assert result == expected",
        "begin_line": 1460,
        "end_line": 1477,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_json_indent_all_orients#1596",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_json_indent_all_orients(self, orient, expected)",
        "snippet": "    def test_json_indent_all_orients(self, orient, expected):\n        # GH 12004\n        df = pd.DataFrame([[\"foo\", \"bar\"], [\"baz\", \"qux\"]], columns=[\"a\", \"b\"])\n        result = df.to_json(orient=orient, indent=4)\n        assert result == expected",
        "begin_line": 1596,
        "end_line": 1600,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_json_negative_indent_raises#1602",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_json_negative_indent_raises(self)",
        "snippet": "    def test_json_negative_indent_raises(self):\n        with pytest.raises(ValueError, match=\"must be a nonnegative integer\"):\n            pd.DataFrame().to_json(indent=-1)",
        "begin_line": 1602,
        "end_line": 1604,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_emca_262_nan_inf_support#1606",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_emca_262_nan_inf_support(self)",
        "snippet": "    def test_emca_262_nan_inf_support(self):\n        # GH 12213\n        data = '[\"a\", NaN, \"NaN\", Infinity, \"Infinity\", -Infinity, \"-Infinity\"]'\n        result = pd.read_json(data)\n        expected = pd.DataFrame(\n            [\"a\", np.nan, \"NaN\", np.inf, \"Infinity\", -np.inf, \"-Infinity\"]\n        )\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1606,
        "end_line": 1613,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_deprecate_numpy_argument_read_json#1615",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_deprecate_numpy_argument_read_json(self)",
        "snippet": "    def test_deprecate_numpy_argument_read_json(self):\n        # GH 28512\n        expected = DataFrame([1, 2, 3])\n        with tm.assert_produces_warning(FutureWarning):\n            result = read_json(expected.to_json(), numpy=True)\n            tm.assert_frame_equal(result, expected)",
        "begin_line": 1615,
        "end_line": 1620,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_int_overflow#1622",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_frame_int_overflow(self)",
        "snippet": "    def test_frame_int_overflow(self):\n        # GH 30320\n        encoded_json = json.dumps([{\"col\": \"31900441201190696999\"}, {\"col\": \"Text\"}])\n        expected = DataFrame({\"col\": [\"31900441201190696999\", \"Text\"]})\n        result = read_json(encoded_json)\n        tm.assert_frame_equal(result, expected)",
        "begin_line": 1622,
        "end_line": 1627,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_json_multiindex#1639",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_json_multiindex(self, dataframe, expected)",
        "snippet": "    def test_json_multiindex(self, dataframe, expected):\n        series = dataframe.stack()\n        result = series.to_json(orient=\"index\")\n        assert result == expected",
        "begin_line": 1639,
        "end_line": 1642,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_to_s3#1644",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_to_s3(self, s3_resource)",
        "snippet": "    def test_to_s3(self, s3_resource):\n        # GH 28375\n        mock_bucket_name, target_file = \"pandas-test\", \"test.json\"\n        df = DataFrame({\"x\": [1, 2, 3], \"y\": [2, 4, 6]})\n        df.to_json(f\"s3://{mock_bucket_name}/{target_file}\")\n        assert target_file in (\n            obj.key for obj in s3_resource.Bucket(\"pandas-test\").objects.all()\n        )",
        "begin_line": 1644,
        "end_line": 1651,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_json_pandas_na#1653",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_json_pandas_na(self)",
        "snippet": "    def test_json_pandas_na(self):\n        # GH 31615\n        result = pd.DataFrame([[pd.NA]]).to_json()\n        assert result == '{\"0\":{\"0\":null}}'",
        "begin_line": 1653,
        "end_line": 1656,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_json_pandas_nulls#1658",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_json_pandas_nulls(self, nulls_fixture)",
        "snippet": "    def test_json_pandas_nulls(self, nulls_fixture):\n        # GH 31615\n        result = pd.DataFrame([[nulls_fixture]]).to_json()\n        assert result == '{\"0\":{\"0\":null}}'",
        "begin_line": 1658,
        "end_line": 1661,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_readjson_bool_series#1663",
        "src_path": "pandas/tests/io/json/test_pandas.py",
        "class_name": "pandas.tests.io.json.test_pandas.TestPandasContainer",
        "signature": "pandas.tests.io.json.test_pandas.TestPandasContainer.test_readjson_bool_series(self)",
        "snippet": "    def test_readjson_bool_series(self):\n        # GH31464\n        result = read_json(\"[true, true, false]\", typ=\"series\")\n        expected = pd.Series([True, True, False])\n        tm.assert_series_equal(result, expected)",
        "begin_line": 1663,
        "end_line": 1667,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.BaseParser.update_kwargs#14",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest.BaseParser",
        "signature": "pandas.tests.io.parser.conftest.BaseParser.update_kwargs(self, kwargs)",
        "snippet": "    def update_kwargs(self, kwargs):\n        kwargs = kwargs.copy()\n        kwargs.update(dict(engine=self.engine, low_memory=self.low_memory))\n\n        return kwargs",
        "begin_line": 14,
        "end_line": 18,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.BaseParser.read_csv#20",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest.BaseParser",
        "signature": "pandas.tests.io.parser.conftest.BaseParser.read_csv(self, *args, **kwargs)",
        "snippet": "    def read_csv(self, *args, **kwargs):\n        kwargs = self.update_kwargs(kwargs)\n        return read_csv(*args, **kwargs)",
        "begin_line": 20,
        "end_line": 22,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.BaseParser.read_table#24",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest.BaseParser",
        "signature": "pandas.tests.io.parser.conftest.BaseParser.read_table(self, *args, **kwargs)",
        "snippet": "    def read_table(self, *args, **kwargs):\n        kwargs = self.update_kwargs(kwargs)\n        return read_table(*args, **kwargs)",
        "begin_line": 24,
        "end_line": 26,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.csv_dir_path#48",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.csv_dir_path(datapath)",
        "snippet": "def csv_dir_path(datapath):\n    \"\"\"\n    The directory path to the data files needed for parser tests.\n    \"\"\"\n    return datapath(\"io\", \"parser\", \"data\")",
        "begin_line": 48,
        "end_line": 52,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.csv1#56",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.csv1(csv_dir_path)",
        "snippet": "def csv1(csv_dir_path):\n    \"\"\"\n    The path to the data file \"test1.csv\" needed for parser tests.\n    \"\"\"\n    return os.path.join(csv_dir_path, \"test1.csv\")",
        "begin_line": 56,
        "end_line": 60,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.all_parsers#77",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.all_parsers(request)",
        "snippet": "def all_parsers(request):\n    \"\"\"\n    Fixture all of the CSV parsers.\n    \"\"\"\n    return request.param",
        "begin_line": 77,
        "end_line": 81,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.c_parser_only#85",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.c_parser_only(request)",
        "snippet": "def c_parser_only(request):\n    \"\"\"\n    Fixture all of the CSV parsers using the C engine.\n    \"\"\"\n    return request.param",
        "begin_line": 85,
        "end_line": 89,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.python_parser_only#93",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.python_parser_only(request)",
        "snippet": "def python_parser_only(request):\n    \"\"\"\n    Fixture all of the CSV parsers using the Python engine.\n    \"\"\"\n    return request.param",
        "begin_line": 93,
        "end_line": 97,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.utf_value#111",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.utf_value(request)",
        "snippet": "def utf_value(request):\n    \"\"\"\n    Fixture for all possible integer values for a UTF encoding.\n    \"\"\"\n    return request.param",
        "begin_line": 111,
        "end_line": 115,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.parser.conftest.encoding_fmt#119",
        "src_path": "pandas/tests/io/parser/conftest.py",
        "class_name": "pandas.tests.io.parser.conftest",
        "signature": "pandas.tests.io.parser.conftest.encoding_fmt(request)",
        "snippet": "def encoding_fmt(request):\n    \"\"\"\n    Fixture for all possible string formats of a UTF encoding.\n    \"\"\"\n    return request.param",
        "begin_line": 119,
        "end_line": 123,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.json.conftest.orient#5",
        "src_path": "pandas/tests/io/json/conftest.py",
        "class_name": "pandas.tests.io.json.conftest",
        "signature": "pandas.tests.io.json.conftest.orient(request)",
        "snippet": "def orient(request):\n    \"\"\"\n    Fixture for orients excluding the table format.\n    \"\"\"\n    return request.param",
        "begin_line": 5,
        "end_line": 9,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files._create_sp_series#94",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files._create_sp_series()",
        "snippet": "def _create_sp_series():\n    nan = np.nan\n\n    # nan-based\n    arr = np.arange(15, dtype=np.float64)\n    arr[7:12] = nan\n    arr[-1:] = nan\n\n    bseries = Series(SparseArray(arr, kind=\"block\"))\n    bseries.name = \"bseries\"\n    return bseries",
        "begin_line": 94,
        "end_line": 104,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files._create_sp_tsseries#107",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files._create_sp_tsseries()",
        "snippet": "def _create_sp_tsseries():\n    nan = np.nan\n\n    # nan-based\n    arr = np.arange(15, dtype=np.float64)\n    arr[7:12] = nan\n    arr[-1:] = nan\n\n    date_index = bdate_range(\"1/1/2011\", periods=len(arr))\n    bseries = Series(SparseArray(arr, kind=\"block\"), index=date_index)\n    bseries.name = \"btsseries\"\n    return bseries",
        "begin_line": 107,
        "end_line": 118,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files._create_sp_frame#121",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files._create_sp_frame()",
        "snippet": "def _create_sp_frame():\n    nan = np.nan\n\n    data = {\n        \"A\": [nan, nan, nan, 0, 1, 2, 3, 4, 5, 6],\n        \"B\": [0, 1, 2, nan, nan, nan, 3, 4, 5, 6],\n        \"C\": np.arange(10).astype(np.int64),\n        \"D\": [0, 1, 2, 3, 4, 5, nan, nan, nan, nan],\n    }\n\n    dates = bdate_range(\"1/1/2011\", periods=10)\n    return DataFrame(data, index=dates).apply(SparseArray)",
        "begin_line": 121,
        "end_line": 132,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.create_data#135",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.create_data()",
        "snippet": "def create_data():\n    \"\"\" create the pickle data \"\"\"\n    data = {\n        \"A\": [0.0, 1.0, 2.0, 3.0, np.nan],\n        \"B\": [0, 1, 0, 1, 0],\n        \"C\": [\"foo1\", \"foo2\", \"foo3\", \"foo4\", \"foo5\"],\n        \"D\": date_range(\"1/1/2009\", periods=5),\n        \"E\": [0.0, 1, Timestamp(\"20100101\"), \"foo\", 2.0],\n    }\n\n    scalars = dict(timestamp=Timestamp(\"20130101\"), period=Period(\"2012\", \"M\"))\n\n    index = dict(\n        int=Index(np.arange(10)),\n        date=date_range(\"20130101\", periods=10),\n        period=period_range(\"2013-01-01\", freq=\"M\", periods=10),\n        float=Index(np.arange(10, dtype=np.float64)),\n        uint=Index(np.arange(10, dtype=np.uint64)),\n        timedelta=timedelta_range(\"00:00:00\", freq=\"30T\", periods=10),\n    )\n\n    index[\"range\"] = RangeIndex(10)\n\n    if _loose_version >= LooseVersion(\"0.21\"):\n        from pandas import interval_range\n\n        index[\"interval\"] = interval_range(0, periods=10)\n\n    mi = dict(\n        reg2=MultiIndex.from_tuples(\n            tuple(\n                zip(\n                    *[\n                        [\"bar\", \"bar\", \"baz\", \"baz\", \"foo\", \"foo\", \"qux\", \"qux\"],\n                        [\"one\", \"two\", \"one\", \"two\", \"one\", \"two\", \"one\", \"two\"],\n                    ]\n                )\n            ),\n            names=[\"first\", \"second\"],\n        )\n    )\n\n    series = dict(\n        float=Series(data[\"A\"]),\n        int=Series(data[\"B\"]),\n        mixed=Series(data[\"E\"]),\n        ts=Series(\n            np.arange(10).astype(np.int64), index=date_range(\"20130101\", periods=10)\n        ),\n        mi=Series(\n            np.arange(5).astype(np.float64),\n            index=MultiIndex.from_tuples(\n                tuple(zip(*[[1, 1, 2, 2, 2], [3, 4, 3, 4, 5]])), names=[\"one\", \"two\"]\n            ),\n        ),\n        dup=Series(np.arange(5).astype(np.float64), index=[\"A\", \"B\", \"C\", \"D\", \"A\"]),\n        cat=Series(Categorical([\"foo\", \"bar\", \"baz\"])),\n        dt=Series(date_range(\"20130101\", periods=5)),\n        dt_tz=Series(date_range(\"20130101\", periods=5, tz=\"US/Eastern\")),\n        period=Series([Period(\"2000Q1\")] * 5),\n    )\n\n    mixed_dup_df = DataFrame(data)\n    mixed_dup_df.columns = list(\"ABCDA\")\n    frame = dict(\n        float=DataFrame({\"A\": series[\"float\"], \"B\": series[\"float\"] + 1}),\n        int=DataFrame({\"A\": series[\"int\"], \"B\": series[\"int\"] + 1}),\n        mixed=DataFrame({k: data[k] for k in [\"A\", \"B\", \"C\", \"D\"]}),\n        mi=DataFrame(\n            {\"A\": np.arange(5).astype(np.float64), \"B\": np.arange(5).astype(np.int64)},\n            index=MultiIndex.from_tuples(\n                tuple(\n                    zip(\n                        *[\n                            [\"bar\", \"bar\", \"baz\", \"baz\", \"baz\"],\n                            [\"one\", \"two\", \"one\", \"two\", \"three\"],\n                        ]\n                    )\n                ),\n                names=[\"first\", \"second\"],\n            ),\n        ),\n        dup=DataFrame(\n            np.arange(15).reshape(5, 3).astype(np.float64), columns=[\"A\", \"B\", \"A\"]\n        ),\n        cat_onecol=DataFrame({\"A\": Categorical([\"foo\", \"bar\"])}),\n        cat_and_float=DataFrame(\n            {\n                \"A\": Categorical([\"foo\", \"bar\", \"baz\"]),\n                \"B\": np.arange(3).astype(np.int64),\n            }\n        ),\n        mixed_dup=mixed_dup_df,\n        dt_mixed_tzs=DataFrame(\n            {\n                \"A\": Timestamp(\"20130102\", tz=\"US/Eastern\"),\n                \"B\": Timestamp(\"20130603\", tz=\"CET\"),\n            },\n            index=range(5),\n        ),\n        dt_mixed2_tzs=DataFrame(\n            {\n                \"A\": Timestamp(\"20130102\", tz=\"US/Eastern\"),\n                \"B\": Timestamp(\"20130603\", tz=\"CET\"),\n                \"C\": Timestamp(\"20130603\", tz=\"UTC\"),\n            },\n            index=range(5),\n        ),\n    )\n\n    cat = dict(\n        int8=Categorical(list(\"abcdefg\")),\n        int16=Categorical(np.arange(1000)),\n        int32=Categorical(np.arange(10000)),\n    )\n\n    timestamp = dict(\n        normal=Timestamp(\"2011-01-01\"),\n        nat=NaT,\n        tz=Timestamp(\"2011-01-01\", tz=\"US/Eastern\"),\n    )\n\n    timestamp[\"freq\"] = Timestamp(\"2011-01-01\", freq=\"D\")\n    timestamp[\"both\"] = Timestamp(\"2011-01-01\", tz=\"Asia/Tokyo\", freq=\"M\")\n\n    off = {\n        \"DateOffset\": DateOffset(years=1),\n        \"DateOffset_h_ns\": DateOffset(hour=6, nanoseconds=5824),\n        \"BusinessDay\": BusinessDay(offset=timedelta(seconds=9)),\n        \"BusinessHour\": BusinessHour(normalize=True, n=6, end=\"15:14\"),\n        \"CustomBusinessDay\": CustomBusinessDay(weekmask=\"Mon Fri\"),\n        \"SemiMonthBegin\": SemiMonthBegin(day_of_month=9),\n        \"SemiMonthEnd\": SemiMonthEnd(day_of_month=24),\n        \"MonthBegin\": MonthBegin(1),\n        \"MonthEnd\": MonthEnd(1),\n        \"QuarterBegin\": QuarterBegin(1),\n        \"QuarterEnd\": QuarterEnd(1),\n        \"Day\": Day(1),\n        \"YearBegin\": YearBegin(1),\n        \"YearEnd\": YearEnd(1),\n        \"Week\": Week(1),\n        \"Week_Tues\": Week(2, normalize=False, weekday=1),\n        \"WeekOfMonth\": WeekOfMonth(week=3, weekday=4),\n        \"LastWeekOfMonth\": LastWeekOfMonth(n=1, weekday=3),\n        \"FY5253\": FY5253(n=2, weekday=6, startingMonth=7, variation=\"last\"),\n        \"Easter\": Easter(),\n        \"Hour\": Hour(1),\n        \"Minute\": Minute(1),\n    }\n\n    return dict(\n        series=series,\n        frame=frame,\n        index=index,\n        scalars=scalars,\n        mi=mi,\n        sp_series=dict(float=_create_sp_series(), ts=_create_sp_tsseries()),\n        sp_frame=dict(float=_create_sp_frame()),\n        cat=cat,\n        timestamp=timestamp,\n        offsets=off,\n    )",
        "begin_line": 135,
        "end_line": 296,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.create_pickle_data#299",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.create_pickle_data()",
        "snippet": "def create_pickle_data():\n    data = create_data()\n\n    return data",
        "begin_line": 299,
        "end_line": 302,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.platform_name#305",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.platform_name()",
        "snippet": "def platform_name():\n    return \"_\".join(\n        [\n            str(pandas.__version__),\n            str(pl.machine()),\n            str(pl.system().lower()),\n            str(pl.python_version()),\n        ]\n    )",
        "begin_line": 305,
        "end_line": 313,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.write_legacy_pickles#316",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.write_legacy_pickles(output_dir)",
        "snippet": "def write_legacy_pickles(output_dir):\n\n    version = pandas.__version__\n\n    print(\n        \"This script generates a storage file for the current arch, system, \"\n        \"and python version\"\n    )\n    print(f\"  pandas version: {version}\")\n    print(f\"  output dir    : {output_dir}\")\n    print(\"  storage format: pickle\")\n\n    pth = f\"{platform_name()}.pickle\"\n\n    fh = open(os.path.join(output_dir, pth), \"wb\")\n    pickle.dump(create_pickle_data(), fh, pickle.HIGHEST_PROTOCOL)\n    fh.close()\n\n    print(f\"created pickle file: {pth}\")",
        "begin_line": 316,
        "end_line": 334,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.io.generate_legacy_storage_files.write_legacy_file#337",
        "src_path": "pandas/tests/io/generate_legacy_storage_files.py",
        "class_name": "pandas.tests.io.generate_legacy_storage_files",
        "signature": "pandas.tests.io.generate_legacy_storage_files.write_legacy_file()",
        "snippet": "def write_legacy_file():\n    # force our cwd to be the first searched\n    sys.path.insert(0, \".\")\n\n    if not (3 <= len(sys.argv) <= 4):\n        exit(\n            \"Specify output directory and storage type: generate_legacy_\"\n            \"storage_files.py <output_dir> <storage_type> \"\n        )\n\n    output_dir = str(sys.argv[1])\n    storage_type = str(sys.argv[2])\n\n    if storage_type == \"pickle\":\n        write_legacy_pickles(output_dir=output_dir)\n    else:\n        exit(\"storage_type must be one of {'pickle'}\")",
        "begin_line": 337,
        "end_line": 353,
        "comment": "",
        "is_bug": false
    }
]