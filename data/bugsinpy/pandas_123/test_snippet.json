[
    {
        "name": "pandas.tests.indexes.conftest.indices#28",
        "src_path": "pandas/tests/indexes/conftest.py",
        "class_name": "pandas.tests.indexes.conftest",
        "signature": "pandas.tests.indexes.conftest.indices(request)",
        "snippet": "def indices(request):\n    # copy to avoid mutation, e.g. setting .name\n    return indices_dict[request.param].copy()",
        "begin_line": 28,
        "end_line": 30,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.conftest.one#34",
        "src_path": "pandas/tests/indexes/conftest.py",
        "class_name": "pandas.tests.indexes.conftest",
        "signature": "pandas.tests.indexes.conftest.one(request)",
        "snippet": "def one(request):\n    # zero-dim integer array behaves like an integer\n    return request.param",
        "begin_line": 34,
        "end_line": 36,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.Numeric.test_can_hold_identifiers#17",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.Numeric",
        "signature": "pandas.tests.indexes.test_numeric.Numeric.test_can_hold_identifiers(self)",
        "snippet": "    def test_can_hold_identifiers(self):\n        idx = self.create_index()\n        key = idx[0]\n        assert idx._can_hold_identifiers_and_holds_name(key) is False",
        "begin_line": 17,
        "end_line": 20,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.Numeric.test_numeric_compat#22",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.Numeric",
        "signature": "pandas.tests.indexes.test_numeric.Numeric.test_numeric_compat(self)",
        "snippet": "    def test_numeric_compat(self):\n        pass  # override Base method",
        "begin_line": 22,
        "end_line": 23,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.Numeric.test_explicit_conversions#25",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.Numeric",
        "signature": "pandas.tests.indexes.test_numeric.Numeric.test_explicit_conversions(self)",
        "snippet": "    def test_explicit_conversions(self):\n\n        # GH 8608\n        # add/sub are overridden explicitly for Float/Int Index\n        idx = self._holder(np.arange(5, dtype=\"int64\"))\n\n        # float conversions\n        arr = np.arange(5, dtype=\"int64\") * 3.2\n        expected = Float64Index(arr)\n        fidx = idx * 3.2\n        tm.assert_index_equal(fidx, expected)\n        fidx = 3.2 * idx\n        tm.assert_index_equal(fidx, expected)\n\n        # interops with numpy arrays\n        expected = Float64Index(arr)\n        a = np.zeros(5, dtype=\"float64\")\n        result = fidx - a\n        tm.assert_index_equal(result, expected)\n\n        expected = Float64Index(-arr)\n        a = np.zeros(5, dtype=\"float64\")\n        result = a - fidx\n        tm.assert_index_equal(result, expected)",
        "begin_line": 25,
        "end_line": 48,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.Numeric.test_index_groupby#50",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.Numeric",
        "signature": "pandas.tests.indexes.test_numeric.Numeric.test_index_groupby(self)",
        "snippet": "    def test_index_groupby(self):\n        int_idx = Index(range(6))\n        float_idx = Index(np.arange(0, 0.6, 0.1))\n        obj_idx = Index(\"A B C D E F\".split())\n        dt_idx = pd.date_range(\"2013-01-01\", freq=\"M\", periods=6)\n\n        for idx in [int_idx, float_idx, obj_idx, dt_idx]:\n            to_groupby = np.array([1, 2, np.nan, np.nan, 2, 1])\n            tm.assert_dict_equal(\n                idx.groupby(to_groupby), {1.0: idx[[0, 5]], 2.0: idx[[1, 4]]}\n            )\n\n            to_groupby = Index(\n                [\n                    datetime(2011, 11, 1),\n                    datetime(2011, 12, 1),\n                    pd.NaT,\n                    pd.NaT,\n                    datetime(2011, 12, 1),\n                    datetime(2011, 11, 1),\n                ],\n                tz=\"UTC\",\n            ).values\n\n            ex_keys = [Timestamp(\"2011-11-01\"), Timestamp(\"2011-12-01\")]\n            expected = {ex_keys[0]: idx[[0, 5]], ex_keys[1]: idx[[1, 4]]}\n            tm.assert_dict_equal(idx.groupby(to_groupby), expected)",
        "begin_line": 50,
        "end_line": 76,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.Numeric.test_where#79",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.Numeric",
        "signature": "pandas.tests.indexes.test_numeric.Numeric.test_where(self, klass)",
        "snippet": "    def test_where(self, klass):\n        i = self.create_index()\n        cond = [True] * len(i)\n        expected = i\n        result = i.where(klass(cond))\n\n        cond = [False] + [True] * (len(i) - 1)\n        expected = Float64Index([i._na_value] + i[1:].tolist())\n        result = i.where(klass(cond))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 79,
        "end_line": 88,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.Numeric.test_insert#90",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.Numeric",
        "signature": "pandas.tests.indexes.test_numeric.Numeric.test_insert(self, nulls_fixture)",
        "snippet": "    def test_insert(self, nulls_fixture):\n        # GH 18295 (test missing)\n        index = self.create_index()\n        expected = Float64Index([index[0], np.nan] + list(index[1:]))\n        result = index.insert(1, nulls_fixture)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 90,
        "end_line": 95,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.indices#110",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.indices(self, request)",
        "snippet": "    def indices(self, request):\n        return Float64Index(request.param)",
        "begin_line": 110,
        "end_line": 111,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.mixed_index#114",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.mixed_index(self)",
        "snippet": "    def mixed_index(self):\n        return Float64Index([1.5, 2, 3, 4, 5])",
        "begin_line": 114,
        "end_line": 115,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.float_index#118",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.float_index(self)",
        "snippet": "    def float_index(self):\n        return Float64Index([0.0, 2.5, 5.0, 7.5, 10.0])",
        "begin_line": 118,
        "end_line": 119,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.create_index#121",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.create_index(self)",
        "snippet": "    def create_index(self):\n        return Float64Index(np.arange(5, dtype=\"float64\"))",
        "begin_line": 121,
        "end_line": 122,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_repr_roundtrip#124",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_repr_roundtrip(self, indices)",
        "snippet": "    def test_repr_roundtrip(self, indices):\n        tm.assert_index_equal(eval(repr(indices)), indices)",
        "begin_line": 124,
        "end_line": 125,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.check_is_index#127",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.check_is_index(self, i)",
        "snippet": "    def check_is_index(self, i):\n        assert isinstance(i, Index)\n        assert not isinstance(i, Float64Index)",
        "begin_line": 127,
        "end_line": 129,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.check_coerce#131",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.check_coerce(self, a, b, is_float_index=True)",
        "snippet": "    def check_coerce(self, a, b, is_float_index=True):\n        assert a.equals(b)\n        tm.assert_index_equal(a, b, exact=False)\n        if is_float_index:\n            assert isinstance(b, Float64Index)\n        else:\n            self.check_is_index(b)",
        "begin_line": 131,
        "end_line": 137,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_constructor#139",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_constructor(self)",
        "snippet": "    def test_constructor(self):\n\n        # explicit construction\n        index = Float64Index([1, 2, 3, 4, 5])\n        assert isinstance(index, Float64Index)\n        expected = np.array([1, 2, 3, 4, 5], dtype=\"float64\")\n        tm.assert_numpy_array_equal(index.values, expected)\n        index = Float64Index(np.array([1, 2, 3, 4, 5]))\n        assert isinstance(index, Float64Index)\n        index = Float64Index([1.0, 2, 3, 4, 5])\n        assert isinstance(index, Float64Index)\n        index = Float64Index(np.array([1.0, 2, 3, 4, 5]))\n        assert isinstance(index, Float64Index)\n        assert index.dtype == float\n\n        index = Float64Index(np.array([1.0, 2, 3, 4, 5]), dtype=np.float32)\n        assert isinstance(index, Float64Index)\n        assert index.dtype == np.float64\n\n        index = Float64Index(np.array([1, 2, 3, 4, 5]), dtype=np.float32)\n        assert isinstance(index, Float64Index)\n        assert index.dtype == np.float64\n\n        # nan handling\n        result = Float64Index([np.nan, np.nan])\n        assert pd.isna(result.values).all()\n        result = Float64Index(np.array([np.nan]))\n        assert pd.isna(result.values).all()\n        result = Index(np.array([np.nan]))\n        assert pd.isna(result.values).all()",
        "begin_line": 139,
        "end_line": 168,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_invalid_dtype#179",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_invalid_dtype(self, index, dtype)",
        "snippet": "    def test_invalid_dtype(self, index, dtype):\n        # GH 29539\n        with pytest.raises(\n            ValueError,\n            match=rf\"Incorrect `dtype` passed: expected \\w+(?: \\w+)?, received {dtype}\",\n        ):\n            index([1, 2, 3], dtype=dtype)",
        "begin_line": 179,
        "end_line": 185,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_constructor_invalid#187",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_constructor_invalid(self)",
        "snippet": "    def test_constructor_invalid(self):\n\n        # invalid\n        msg = (\n            r\"Float64Index\\(\\.\\.\\.\\) must be called with a collection of\"\n            r\" some kind, 0\\.0 was passed\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            Float64Index(0.0)\n        msg = (\n            \"String dtype not supported, you may need to explicitly cast to\"\n            \" a numeric type\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            Float64Index([\"a\", \"b\", 0.0])\n        msg = r\"float\\(\\) argument must be a string or a number, not 'Timestamp'\"\n        with pytest.raises(TypeError, match=msg):\n            Float64Index([Timestamp(\"20130101\")])",
        "begin_line": 187,
        "end_line": 204,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_constructor_coerce#206",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_constructor_coerce(self, mixed_index, float_index)",
        "snippet": "    def test_constructor_coerce(self, mixed_index, float_index):\n\n        self.check_coerce(mixed_index, Index([1.5, 2, 3, 4, 5]))\n        self.check_coerce(float_index, Index(np.arange(5) * 2.5))\n        self.check_coerce(\n            float_index, Index(np.array(np.arange(5) * 2.5, dtype=object))\n        )",
        "begin_line": 206,
        "end_line": 212,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_constructor_explicit#214",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_constructor_explicit(self, mixed_index, float_index)",
        "snippet": "    def test_constructor_explicit(self, mixed_index, float_index):\n\n        # these don't auto convert\n        self.check_coerce(\n            float_index, Index((np.arange(5) * 2.5), dtype=object), is_float_index=False\n        )\n        self.check_coerce(\n            mixed_index, Index([1.5, 2, 3, 4, 5], dtype=object), is_float_index=False\n        )",
        "begin_line": 214,
        "end_line": 222,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_astype#224",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_astype(self, mixed_index, float_index)",
        "snippet": "    def test_astype(self, mixed_index, float_index):\n\n        result = float_index.astype(object)\n        assert result.equals(float_index)\n        assert float_index.equals(result)\n        self.check_is_index(result)\n\n        i = mixed_index.copy()\n        i.name = \"foo\"\n        result = i.astype(object)\n        assert result.equals(i)\n        assert i.equals(result)\n        self.check_is_index(result)\n\n        # GH 12881\n        # a float astype int\n        for dtype in [\"int16\", \"int32\", \"int64\"]:\n            i = Float64Index([0, 1, 2])\n            result = i.astype(dtype)\n            expected = Int64Index([0, 1, 2])\n            tm.assert_index_equal(result, expected)\n\n            i = Float64Index([0, 1.1, 2])\n            result = i.astype(dtype)\n            expected = Int64Index([0, 1, 2])\n            tm.assert_index_equal(result, expected)\n\n        for dtype in [\"float32\", \"float64\"]:\n            i = Float64Index([0, 1, 2])\n            result = i.astype(dtype)\n            expected = i\n            tm.assert_index_equal(result, expected)\n\n            i = Float64Index([0, 1.1, 2])\n            result = i.astype(dtype)\n            expected = Index(i.values.astype(dtype))\n            tm.assert_index_equal(result, expected)\n\n        # invalid\n        for dtype in [\"M8[ns]\", \"m8[ns]\"]:\n            msg = (\n                f\"Cannot convert Float64Index to dtype {pandas_dtype(dtype)}; \"\n                f\"integer values are required for conversion\"\n            )\n            with pytest.raises(TypeError, match=re.escape(msg)):\n                i.astype(dtype)\n\n        # GH 13149\n        for dtype in [\"int16\", \"int32\", \"int64\"]:\n            i = Float64Index([0, 1.1, np.NAN])\n            msg = r\"Cannot convert non-finite values \\(NA or inf\\) to integer\"\n            with pytest.raises(ValueError, match=msg):\n                i.astype(dtype)",
        "begin_line": 224,
        "end_line": 276,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_cannot_cast_inf_to_int#278",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_cannot_cast_inf_to_int(self)",
        "snippet": "    def test_cannot_cast_inf_to_int(self):\n        idx = pd.Float64Index([1, 2, np.inf])\n\n        msg = r\"Cannot convert non-finite values \\(NA or inf\\) to integer\"\n        with pytest.raises(ValueError, match=msg):\n            idx.astype(int)",
        "begin_line": 278,
        "end_line": 283,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_type_coercion_fail#285",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_type_coercion_fail(self, any_int_dtype)",
        "snippet": "    def test_type_coercion_fail(self, any_int_dtype):\n        # see gh-15832\n        msg = \"Trying to coerce float values to integers\"\n        with pytest.raises(ValueError, match=msg):\n            Index([1, 2, 3.5], dtype=any_int_dtype)",
        "begin_line": 285,
        "end_line": 289,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_type_coercion_valid#291",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_type_coercion_valid(self, float_dtype)",
        "snippet": "    def test_type_coercion_valid(self, float_dtype):\n        # There is no Float32Index, so we always\n        # generate Float64Index.\n        i = Index([1, 2, 3.5], dtype=float_dtype)\n        tm.assert_index_equal(i, Index([1, 2, 3.5]))",
        "begin_line": 291,
        "end_line": 295,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_equals_numeric#297",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_equals_numeric(self)",
        "snippet": "    def test_equals_numeric(self):\n\n        i = Float64Index([1.0, 2.0])\n        assert i.equals(i)\n        assert i.identical(i)\n\n        i2 = Float64Index([1.0, 2.0])\n        assert i.equals(i2)\n\n        i = Float64Index([1.0, np.nan])\n        assert i.equals(i)\n        assert i.identical(i)\n\n        i2 = Float64Index([1.0, np.nan])\n        assert i.equals(i2)",
        "begin_line": 297,
        "end_line": 311,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_get_indexer#313",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_get_indexer(self)",
        "snippet": "    def test_get_indexer(self):\n        idx = Float64Index([0.0, 1.0, 2.0])\n        tm.assert_numpy_array_equal(\n            idx.get_indexer(idx), np.array([0, 1, 2], dtype=np.intp)\n        )\n\n        target = [-0.1, 0.5, 1.1]\n        tm.assert_numpy_array_equal(\n            idx.get_indexer(target, \"pad\"), np.array([-1, 0, 1], dtype=np.intp)\n        )\n        tm.assert_numpy_array_equal(\n            idx.get_indexer(target, \"backfill\"), np.array([0, 1, 2], dtype=np.intp)\n        )\n        tm.assert_numpy_array_equal(\n            idx.get_indexer(target, \"nearest\"), np.array([0, 1, 1], dtype=np.intp)\n        )",
        "begin_line": 313,
        "end_line": 328,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_get_loc#330",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_get_loc(self)",
        "snippet": "    def test_get_loc(self):\n        idx = Float64Index([0.0, 1.0, 2.0])\n        for method in [None, \"pad\", \"backfill\", \"nearest\"]:\n            assert idx.get_loc(1, method) == 1\n            if method is not None:\n                assert idx.get_loc(1, method, tolerance=0) == 1\n\n        for method, loc in [(\"pad\", 1), (\"backfill\", 2), (\"nearest\", 1)]:\n            assert idx.get_loc(1.1, method) == loc\n            assert idx.get_loc(1.1, method, tolerance=0.9) == loc\n\n        with pytest.raises(KeyError, match=\"^'foo'$\"):\n            idx.get_loc(\"foo\")\n        with pytest.raises(KeyError, match=r\"^1\\.5$\"):\n            idx.get_loc(1.5)\n        with pytest.raises(KeyError, match=r\"^1\\.5$\"):\n            idx.get_loc(1.5, method=\"pad\", tolerance=0.1)\n        with pytest.raises(KeyError, match=\"^True$\"):\n            idx.get_loc(True)\n        with pytest.raises(KeyError, match=\"^False$\"):\n            idx.get_loc(False)\n\n        with pytest.raises(ValueError, match=\"must be numeric\"):\n            idx.get_loc(1.4, method=\"nearest\", tolerance=\"foo\")\n\n        with pytest.raises(ValueError, match=\"must contain numeric elements\"):\n            idx.get_loc(1.4, method=\"nearest\", tolerance=np.array([\"foo\"]))\n\n        with pytest.raises(\n            ValueError, match=\"tolerance size must match target index size\"\n        ):\n            idx.get_loc(1.4, method=\"nearest\", tolerance=np.array([1, 2]))",
        "begin_line": 330,
        "end_line": 361,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_get_loc_na#363",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_get_loc_na(self)",
        "snippet": "    def test_get_loc_na(self):\n        idx = Float64Index([np.nan, 1, 2])\n        assert idx.get_loc(1) == 1\n        assert idx.get_loc(np.nan) == 0\n\n        idx = Float64Index([np.nan, 1, np.nan])\n        assert idx.get_loc(1) == 1\n\n        # representable by slice [0:2:2]\n        # pytest.raises(KeyError, idx.slice_locs, np.nan)\n        sliced = idx.slice_locs(np.nan)\n        assert isinstance(sliced, tuple)\n        assert sliced == (0, 3)\n\n        # not representable by slice\n        idx = Float64Index([np.nan, 1, np.nan, np.nan])\n        assert idx.get_loc(1) == 1\n        msg = \"'Cannot get left slice bound for non-unique label: nan\"\n        with pytest.raises(KeyError, match=msg):\n            idx.slice_locs(np.nan)",
        "begin_line": 363,
        "end_line": 382,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_get_loc_missing_nan#384",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_get_loc_missing_nan(self)",
        "snippet": "    def test_get_loc_missing_nan(self):\n        # GH 8569\n        idx = Float64Index([1, 2])\n        assert idx.get_loc(1) == 0\n        with pytest.raises(KeyError, match=r\"^3\\.0$\"):\n            idx.get_loc(3)\n        with pytest.raises(KeyError, match=\"^nan$\"):\n            idx.get_loc(np.nan)\n        with pytest.raises(KeyError, match=r\"^\\[nan\\]$\"):\n            idx.get_loc([np.nan])",
        "begin_line": 384,
        "end_line": 393,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_contains_nans#395",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_contains_nans(self)",
        "snippet": "    def test_contains_nans(self):\n        i = Float64Index([1.0, 2.0, np.nan])\n        assert np.nan in i",
        "begin_line": 395,
        "end_line": 397,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_contains_not_nans#399",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_contains_not_nans(self)",
        "snippet": "    def test_contains_not_nans(self):\n        i = Float64Index([1.0, 2.0, np.nan])\n        assert 1.0 in i",
        "begin_line": 399,
        "end_line": 401,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_doesnt_contain_all_the_things#403",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_doesnt_contain_all_the_things(self)",
        "snippet": "    def test_doesnt_contain_all_the_things(self):\n        i = Float64Index([np.nan])\n        assert not i.isin([0]).item()\n        assert not i.isin([1]).item()\n        assert i.isin([np.nan]).item()",
        "begin_line": 403,
        "end_line": 407,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_nan_multiple_containment#409",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_nan_multiple_containment(self)",
        "snippet": "    def test_nan_multiple_containment(self):\n        i = Float64Index([1.0, np.nan])\n        tm.assert_numpy_array_equal(i.isin([1.0]), np.array([True, False]))\n        tm.assert_numpy_array_equal(i.isin([2.0, np.pi]), np.array([False, False]))\n        tm.assert_numpy_array_equal(i.isin([np.nan]), np.array([False, True]))\n        tm.assert_numpy_array_equal(i.isin([1.0, np.nan]), np.array([True, True]))\n        i = Float64Index([1.0, 2.0])\n        tm.assert_numpy_array_equal(i.isin([np.nan]), np.array([False, False]))",
        "begin_line": 409,
        "end_line": 416,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_astype_from_object#418",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_astype_from_object(self)",
        "snippet": "    def test_astype_from_object(self):\n        index = Index([1.0, np.nan, 0.2], dtype=\"object\")\n        result = index.astype(float)\n        expected = Float64Index([1.0, np.nan, 0.2])\n        assert result.dtype == expected.dtype\n        tm.assert_index_equal(result, expected)",
        "begin_line": 418,
        "end_line": 423,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_fillna_float64#425",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_fillna_float64(self)",
        "snippet": "    def test_fillna_float64(self):\n        # GH 11343\n        idx = Index([1.0, np.nan, 3.0], dtype=float, name=\"x\")\n        # can't downcast\n        exp = Index([1.0, 0.1, 3.0], name=\"x\")\n        tm.assert_index_equal(idx.fillna(0.1), exp)\n\n        # downcast\n        exp = Float64Index([1.0, 2.0, 3.0], name=\"x\")\n        tm.assert_index_equal(idx.fillna(2), exp)\n\n        # object\n        exp = Index([1.0, \"obj\", 3.0], name=\"x\")\n        tm.assert_index_equal(idx.fillna(\"obj\"), exp)",
        "begin_line": 425,
        "end_line": 438,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_take_fill_value#440",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestFloat64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestFloat64Index.test_take_fill_value(self)",
        "snippet": "    def test_take_fill_value(self):\n        # GH 12631\n        idx = pd.Float64Index([1.0, 2.0, 3.0], name=\"xxx\")\n        result = idx.take(np.array([1, 0, -1]))\n        expected = pd.Float64Index([2.0, 1.0, 3.0], name=\"xxx\")\n        tm.assert_index_equal(result, expected)\n\n        # fill_value\n        result = idx.take(np.array([1, 0, -1]), fill_value=True)\n        expected = pd.Float64Index([2.0, 1.0, np.nan], name=\"xxx\")\n        tm.assert_index_equal(result, expected)\n\n        # allow_fill=False\n        result = idx.take(np.array([1, 0, -1]), allow_fill=False, fill_value=True)\n        expected = pd.Float64Index([2.0, 1.0, 3.0], name=\"xxx\")\n        tm.assert_index_equal(result, expected)\n\n        msg = (\n            \"When allow_fill=True and fill_value is not None, \"\n            \"all indices must be >= -1\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            idx.take(np.array([1, 0, -2]), fill_value=True)\n        with pytest.raises(ValueError, match=msg):\n            idx.take(np.array([1, 0, -5]), fill_value=True)\n\n        with pytest.raises(IndexError):\n            idx.take(np.array([1, -5]))",
        "begin_line": 440,
        "end_line": 467,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.NumericInt.test_view#471",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.NumericInt",
        "signature": "pandas.tests.indexes.test_numeric.NumericInt.test_view(self)",
        "snippet": "    def test_view(self):\n        i = self._holder([], name=\"Foo\")\n        i_view = i.view()\n        assert i_view.name == \"Foo\"\n\n        i_view = i.view(self._dtype)\n        tm.assert_index_equal(i, self._holder(i_view, name=\"Foo\"))\n\n        i_view = i.view(self._holder)\n        tm.assert_index_equal(i, self._holder(i_view, name=\"Foo\"))",
        "begin_line": 471,
        "end_line": 480,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.NumericInt.test_is_monotonic#482",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.NumericInt",
        "signature": "pandas.tests.indexes.test_numeric.NumericInt.test_is_monotonic(self)",
        "snippet": "    def test_is_monotonic(self):\n        index = self._holder([1, 2, 3, 4])\n        assert index.is_monotonic is True\n        assert index.is_monotonic_increasing is True\n        assert index._is_strictly_monotonic_increasing is True\n        assert index.is_monotonic_decreasing is False\n        assert index._is_strictly_monotonic_decreasing is False\n\n        index = self._holder([4, 3, 2, 1])\n        assert index.is_monotonic is False\n        assert index._is_strictly_monotonic_increasing is False\n        assert index._is_strictly_monotonic_decreasing is True\n\n        index = self._holder([1])\n        assert index.is_monotonic is True\n        assert index.is_monotonic_increasing is True\n        assert index.is_monotonic_decreasing is True\n        assert index._is_strictly_monotonic_increasing is True\n        assert index._is_strictly_monotonic_decreasing is True",
        "begin_line": 482,
        "end_line": 500,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.NumericInt.test_is_strictly_monotonic#502",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.NumericInt",
        "signature": "pandas.tests.indexes.test_numeric.NumericInt.test_is_strictly_monotonic(self)",
        "snippet": "    def test_is_strictly_monotonic(self):\n        index = self._holder([1, 1, 2, 3])\n        assert index.is_monotonic_increasing is True\n        assert index._is_strictly_monotonic_increasing is False\n\n        index = self._holder([3, 2, 1, 1])\n        assert index.is_monotonic_decreasing is True\n        assert index._is_strictly_monotonic_decreasing is False\n\n        index = self._holder([1, 1])\n        assert index.is_monotonic_increasing\n        assert index.is_monotonic_decreasing\n        assert not index._is_strictly_monotonic_increasing\n        assert not index._is_strictly_monotonic_decreasing",
        "begin_line": 502,
        "end_line": 515,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.NumericInt.test_logical_compat#517",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.NumericInt",
        "signature": "pandas.tests.indexes.test_numeric.NumericInt.test_logical_compat(self)",
        "snippet": "    def test_logical_compat(self):\n        idx = self.create_index()\n        assert idx.all() == idx.values.all()\n        assert idx.any() == idx.values.any()",
        "begin_line": 517,
        "end_line": 520,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.NumericInt.test_identical#522",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.NumericInt",
        "signature": "pandas.tests.indexes.test_numeric.NumericInt.test_identical(self)",
        "snippet": "    def test_identical(self):\n        index = self.create_index()\n        i = Index(index.copy())\n        assert i.identical(index)\n\n        same_values_different_type = Index(i, dtype=object)\n        assert not i.identical(same_values_different_type)\n\n        i = index.copy(dtype=object)\n        i = i.rename(\"foo\")\n        same_values = Index(i, dtype=object)\n        assert same_values.identical(i)\n\n        assert not i.identical(index)\n        assert Index(same_values, name=\"foo\", dtype=object).identical(i)\n\n        assert not index.copy(dtype=object).identical(index.copy(dtype=self._dtype))",
        "begin_line": 522,
        "end_line": 538,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.NumericInt.test_join_non_unique#540",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.NumericInt",
        "signature": "pandas.tests.indexes.test_numeric.NumericInt.test_join_non_unique(self)",
        "snippet": "    def test_join_non_unique(self):\n        left = Index([4, 4, 3, 3])\n\n        joined, lidx, ridx = left.join(left, return_indexers=True)\n\n        exp_joined = Index([3, 3, 3, 3, 4, 4, 4, 4])\n        tm.assert_index_equal(joined, exp_joined)\n\n        exp_lidx = np.array([2, 2, 3, 3, 0, 0, 1, 1], dtype=np.intp)\n        tm.assert_numpy_array_equal(lidx, exp_lidx)\n\n        exp_ridx = np.array([2, 3, 2, 3, 0, 1, 0, 1], dtype=np.intp)\n        tm.assert_numpy_array_equal(ridx, exp_ridx)",
        "begin_line": 540,
        "end_line": 552,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.NumericInt.test_join_self#554",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.NumericInt",
        "signature": "pandas.tests.indexes.test_numeric.NumericInt.test_join_self(self, join_type)",
        "snippet": "    def test_join_self(self, join_type):\n        index = self.create_index()\n        joined = index.join(index, how=join_type)\n        assert index is joined",
        "begin_line": 554,
        "end_line": 557,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.NumericInt.test_union_noncomparable#559",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.NumericInt",
        "signature": "pandas.tests.indexes.test_numeric.NumericInt.test_union_noncomparable(self)",
        "snippet": "    def test_union_noncomparable(self):\n        # corner case, non-Int64Index\n        index = self.create_index()\n        other = Index([datetime.now() + timedelta(i) for i in range(4)], dtype=object)\n        result = index.union(other)\n        expected = Index(np.concatenate((index, other)))\n        tm.assert_index_equal(result, expected)\n\n        result = other.union(index)\n        expected = Index(np.concatenate((other, index)))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 559,
        "end_line": 569,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.NumericInt.test_cant_or_shouldnt_cast#571",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.NumericInt",
        "signature": "pandas.tests.indexes.test_numeric.NumericInt.test_cant_or_shouldnt_cast(self)",
        "snippet": "    def test_cant_or_shouldnt_cast(self):\n        msg = (\n            \"String dtype not supported, you may need to explicitly cast to\"\n            \" a numeric type\"\n        )\n        # can't\n        data = [\"foo\", \"bar\", \"baz\"]\n        with pytest.raises(TypeError, match=msg):\n            self._holder(data)\n\n        # shouldn't\n        data = [\"0\", \"1\", \"2\"]\n        with pytest.raises(TypeError, match=msg):\n            self._holder(data)",
        "begin_line": 571,
        "end_line": 584,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.NumericInt.test_view_index#586",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.NumericInt",
        "signature": "pandas.tests.indexes.test_numeric.NumericInt.test_view_index(self)",
        "snippet": "    def test_view_index(self):\n        index = self.create_index()\n        index.view(Index)",
        "begin_line": 586,
        "end_line": 588,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.NumericInt.test_prevent_casting#590",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.NumericInt",
        "signature": "pandas.tests.indexes.test_numeric.NumericInt.test_prevent_casting(self)",
        "snippet": "    def test_prevent_casting(self):\n        index = self.create_index()\n        result = index.astype(\"O\")\n        assert result.dtype == np.object_",
        "begin_line": 590,
        "end_line": 593,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.NumericInt.test_take_preserve_name#595",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.NumericInt",
        "signature": "pandas.tests.indexes.test_numeric.NumericInt.test_take_preserve_name(self)",
        "snippet": "    def test_take_preserve_name(self):\n        index = self._holder([1, 2, 3, 4], name=\"foo\")\n        taken = index.take([3, 0, 1])\n        assert index.name == taken.name",
        "begin_line": 595,
        "end_line": 598,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.NumericInt.test_take_fill_value#600",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.NumericInt",
        "signature": "pandas.tests.indexes.test_numeric.NumericInt.test_take_fill_value(self)",
        "snippet": "    def test_take_fill_value(self):\n        # see gh-12631\n        idx = self._holder([1, 2, 3], name=\"xxx\")\n        result = idx.take(np.array([1, 0, -1]))\n        expected = self._holder([2, 1, 3], name=\"xxx\")\n        tm.assert_index_equal(result, expected)\n\n        name = self._holder.__name__\n        msg = f\"Unable to fill values because {name} cannot contain NA\"\n\n        # fill_value=True\n        with pytest.raises(ValueError, match=msg):\n            idx.take(np.array([1, 0, -1]), fill_value=True)\n\n        # allow_fill=False\n        result = idx.take(np.array([1, 0, -1]), allow_fill=False, fill_value=True)\n        expected = self._holder([2, 1, 3], name=\"xxx\")\n        tm.assert_index_equal(result, expected)\n\n        with pytest.raises(ValueError, match=msg):\n            idx.take(np.array([1, 0, -2]), fill_value=True)\n        with pytest.raises(ValueError, match=msg):\n            idx.take(np.array([1, 0, -5]), fill_value=True)\n\n        with pytest.raises(IndexError):\n            idx.take(np.array([1, -5]))",
        "begin_line": 600,
        "end_line": 625,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.NumericInt.test_slice_keep_name#627",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.NumericInt",
        "signature": "pandas.tests.indexes.test_numeric.NumericInt.test_slice_keep_name(self)",
        "snippet": "    def test_slice_keep_name(self):\n        idx = self._holder([1, 2], name=\"asdf\")\n        assert idx.name == idx[1:].name",
        "begin_line": 627,
        "end_line": 629,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestInt64Index.indices#639",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestInt64Index.indices(self, request)",
        "snippet": "    def indices(self, request):\n        return Int64Index(request.param)",
        "begin_line": 639,
        "end_line": 640,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestInt64Index.create_index#642",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestInt64Index.create_index(self)",
        "snippet": "    def create_index(self):\n        # return Int64Index(np.arange(5, dtype=\"int64\"))\n        return Int64Index(range(0, 20, 2))",
        "begin_line": 642,
        "end_line": 644,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestInt64Index.test_constructor#646",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestInt64Index.test_constructor(self)",
        "snippet": "    def test_constructor(self):\n        # pass list, coerce fine\n        index = Int64Index([-5, 0, 1, 2])\n        expected = Index([-5, 0, 1, 2], dtype=np.int64)\n        tm.assert_index_equal(index, expected)\n\n        # from iterable\n        index = Int64Index(iter([-5, 0, 1, 2]))\n        tm.assert_index_equal(index, expected)\n\n        # scalar raise Exception\n        msg = (\n            r\"Int64Index\\(\\.\\.\\.\\) must be called with a collection of some\"\n            \" kind, 5 was passed\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            Int64Index(5)\n\n        # copy\n        arr = index.values\n        new_index = Int64Index(arr, copy=True)\n        tm.assert_index_equal(new_index, index)\n        val = arr[0] + 3000\n\n        # this should not change index\n        arr[0] = val\n        assert new_index[0] != val\n\n        # interpret list-like\n        expected = Int64Index([5, 0])\n        for cls in [Index, Int64Index]:\n            for idx in [\n                cls([5, 0], dtype=\"int64\"),\n                cls(np.array([5, 0]), dtype=\"int64\"),\n                cls(Series([5, 0]), dtype=\"int64\"),\n            ]:\n                tm.assert_index_equal(idx, expected)",
        "begin_line": 646,
        "end_line": 682,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestInt64Index.test_constructor_corner#684",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestInt64Index.test_constructor_corner(self)",
        "snippet": "    def test_constructor_corner(self):\n        arr = np.array([1, 2, 3, 4], dtype=object)\n        index = Int64Index(arr)\n        assert index.values.dtype == np.int64\n        tm.assert_index_equal(index, Index(arr))\n\n        # preventing casting\n        arr = np.array([1, \"2\", 3, \"4\"], dtype=object)\n        with pytest.raises(TypeError, match=\"casting\"):\n            Int64Index(arr)\n\n        arr_with_floats = [0, 2, 3, 4, 5, 1.25, 3, -1]\n        with pytest.raises(TypeError, match=\"casting\"):\n            Int64Index(arr_with_floats)",
        "begin_line": 684,
        "end_line": 697,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestInt64Index.test_constructor_coercion_signed_to_unsigned#699",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestInt64Index.test_constructor_coercion_signed_to_unsigned(self, uint_dtype)",
        "snippet": "    def test_constructor_coercion_signed_to_unsigned(self, uint_dtype):\n\n        # see gh-15832\n        msg = \"Trying to coerce negative values to unsigned integers\"\n\n        with pytest.raises(OverflowError, match=msg):\n            Index([-1], dtype=uint_dtype)",
        "begin_line": 699,
        "end_line": 705,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestInt64Index.test_constructor_unwraps_index#707",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestInt64Index.test_constructor_unwraps_index(self)",
        "snippet": "    def test_constructor_unwraps_index(self):\n        idx = pd.Index([1, 2])\n        result = pd.Int64Index(idx)\n        expected = np.array([1, 2], dtype=\"int64\")\n        tm.assert_numpy_array_equal(result._data, expected)",
        "begin_line": 707,
        "end_line": 711,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestInt64Index.test_coerce_list#713",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestInt64Index.test_coerce_list(self)",
        "snippet": "    def test_coerce_list(self):\n        # coerce things\n        arr = Index([1, 2, 3, 4])\n        assert isinstance(arr, Int64Index)\n\n        # but not if explicit dtype passed\n        arr = Index([1, 2, 3, 4], dtype=object)\n        assert isinstance(arr, Index)",
        "begin_line": 713,
        "end_line": 720,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestInt64Index.test_get_indexer#722",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestInt64Index.test_get_indexer(self)",
        "snippet": "    def test_get_indexer(self):\n        index = self.create_index()\n        target = Int64Index(np.arange(10))\n        indexer = index.get_indexer(target)\n        expected = np.array([0, -1, 1, -1, 2, -1, 3, -1, 4, -1], dtype=np.intp)\n        tm.assert_numpy_array_equal(indexer, expected)\n\n        target = Int64Index(np.arange(10))\n        indexer = index.get_indexer(target, method=\"pad\")\n        expected = np.array([0, 0, 1, 1, 2, 2, 3, 3, 4, 4], dtype=np.intp)\n        tm.assert_numpy_array_equal(indexer, expected)\n\n        target = Int64Index(np.arange(10))\n        indexer = index.get_indexer(target, method=\"backfill\")\n        expected = np.array([0, 1, 1, 2, 2, 3, 3, 4, 4, 5], dtype=np.intp)\n        tm.assert_numpy_array_equal(indexer, expected)",
        "begin_line": 722,
        "end_line": 737,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestInt64Index.test_intersection#739",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestInt64Index.test_intersection(self)",
        "snippet": "    def test_intersection(self):\n        index = self.create_index()\n        other = Index([1, 2, 3, 4, 5])\n        result = index.intersection(other)\n        expected = Index(np.sort(np.intersect1d(index.values, other.values)))\n        tm.assert_index_equal(result, expected)\n\n        result = other.intersection(index)\n        expected = Index(\n            np.sort(np.asarray(np.intersect1d(index.values, other.values)))\n        )\n        tm.assert_index_equal(result, expected)",
        "begin_line": 739,
        "end_line": 750,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestInt64Index.test_join_inner#752",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestInt64Index.test_join_inner(self)",
        "snippet": "    def test_join_inner(self):\n        index = self.create_index()\n        other = Int64Index([7, 12, 25, 1, 2, 5])\n        other_mono = Int64Index([1, 2, 5, 7, 12, 25])\n\n        # not monotonic\n        res, lidx, ridx = index.join(other, how=\"inner\", return_indexers=True)\n\n        # no guarantee of sortedness, so sort for comparison purposes\n        ind = res.argsort()\n        res = res.take(ind)\n        lidx = lidx.take(ind)\n        ridx = ridx.take(ind)\n\n        eres = Int64Index([2, 12])\n        elidx = np.array([1, 6], dtype=np.intp)\n        eridx = np.array([4, 1], dtype=np.intp)\n\n        assert isinstance(res, Int64Index)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)\n\n        # monotonic\n        res, lidx, ridx = index.join(other_mono, how=\"inner\", return_indexers=True)\n\n        res2 = index.intersection(other_mono)\n        tm.assert_index_equal(res, res2)\n\n        elidx = np.array([1, 6], dtype=np.intp)\n        eridx = np.array([1, 4], dtype=np.intp)\n        assert isinstance(res, Int64Index)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)",
        "begin_line": 752,
        "end_line": 786,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestInt64Index.test_join_left#788",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestInt64Index.test_join_left(self)",
        "snippet": "    def test_join_left(self):\n        index = self.create_index()\n        other = Int64Index([7, 12, 25, 1, 2, 5])\n        other_mono = Int64Index([1, 2, 5, 7, 12, 25])\n\n        # not monotonic\n        res, lidx, ridx = index.join(other, how=\"left\", return_indexers=True)\n        eres = index\n        eridx = np.array([-1, 4, -1, -1, -1, -1, 1, -1, -1, -1], dtype=np.intp)\n\n        assert isinstance(res, Int64Index)\n        tm.assert_index_equal(res, eres)\n        assert lidx is None\n        tm.assert_numpy_array_equal(ridx, eridx)\n\n        # monotonic\n        res, lidx, ridx = index.join(other_mono, how=\"left\", return_indexers=True)\n        eridx = np.array([-1, 1, -1, -1, -1, -1, 4, -1, -1, -1], dtype=np.intp)\n        assert isinstance(res, Int64Index)\n        tm.assert_index_equal(res, eres)\n        assert lidx is None\n        tm.assert_numpy_array_equal(ridx, eridx)\n\n        # non-unique\n        idx = Index([1, 1, 2, 5])\n        idx2 = Index([1, 2, 5, 7, 9])\n        res, lidx, ridx = idx2.join(idx, how=\"left\", return_indexers=True)\n        eres = Index([1, 1, 2, 5, 7, 9])  # 1 is in idx2, so it should be x2\n        eridx = np.array([0, 1, 2, 3, -1, -1], dtype=np.intp)\n        elidx = np.array([0, 0, 1, 2, 3, 4], dtype=np.intp)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)",
        "begin_line": 788,
        "end_line": 820,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestInt64Index.test_join_right#822",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestInt64Index.test_join_right(self)",
        "snippet": "    def test_join_right(self):\n        index = self.create_index()\n        other = Int64Index([7, 12, 25, 1, 2, 5])\n        other_mono = Int64Index([1, 2, 5, 7, 12, 25])\n\n        # not monotonic\n        res, lidx, ridx = index.join(other, how=\"right\", return_indexers=True)\n        eres = other\n        elidx = np.array([-1, 6, -1, -1, 1, -1], dtype=np.intp)\n\n        assert isinstance(other, Int64Index)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        assert ridx is None\n\n        # monotonic\n        res, lidx, ridx = index.join(other_mono, how=\"right\", return_indexers=True)\n        eres = other_mono\n        elidx = np.array([-1, 1, -1, -1, 6, -1], dtype=np.intp)\n        assert isinstance(other, Int64Index)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        assert ridx is None\n\n        # non-unique\n        idx = Index([1, 1, 2, 5])\n        idx2 = Index([1, 2, 5, 7, 9])\n        res, lidx, ridx = idx.join(idx2, how=\"right\", return_indexers=True)\n        eres = Index([1, 1, 2, 5, 7, 9])  # 1 is in idx2, so it should be x2\n        elidx = np.array([0, 1, 2, 3, -1, -1], dtype=np.intp)\n        eridx = np.array([0, 0, 1, 2, 3, 4], dtype=np.intp)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)",
        "begin_line": 822,
        "end_line": 855,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestInt64Index.test_join_non_int_index#857",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestInt64Index.test_join_non_int_index(self)",
        "snippet": "    def test_join_non_int_index(self):\n        index = self.create_index()\n        other = Index([3, 6, 7, 8, 10], dtype=object)\n\n        outer = index.join(other, how=\"outer\")\n        outer2 = other.join(index, how=\"outer\")\n        expected = Index([0, 2, 3, 4, 6, 7, 8, 10, 12, 14, 16, 18])\n        tm.assert_index_equal(outer, outer2)\n        tm.assert_index_equal(outer, expected)\n\n        inner = index.join(other, how=\"inner\")\n        inner2 = other.join(index, how=\"inner\")\n        expected = Index([6, 8, 10])\n        tm.assert_index_equal(inner, inner2)\n        tm.assert_index_equal(inner, expected)\n\n        left = index.join(other, how=\"left\")\n        tm.assert_index_equal(left, index.astype(object))\n\n        left2 = other.join(index, how=\"left\")\n        tm.assert_index_equal(left2, other)\n\n        right = index.join(other, how=\"right\")\n        tm.assert_index_equal(right, other)\n\n        right2 = other.join(index, how=\"right\")\n        tm.assert_index_equal(right2, index.astype(object))",
        "begin_line": 857,
        "end_line": 883,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestInt64Index.test_join_outer#885",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestInt64Index.test_join_outer(self)",
        "snippet": "    def test_join_outer(self):\n        index = self.create_index()\n        other = Int64Index([7, 12, 25, 1, 2, 5])\n        other_mono = Int64Index([1, 2, 5, 7, 12, 25])\n\n        # not monotonic\n        # guarantee of sortedness\n        res, lidx, ridx = index.join(other, how=\"outer\", return_indexers=True)\n        noidx_res = index.join(other, how=\"outer\")\n        tm.assert_index_equal(res, noidx_res)\n\n        eres = Int64Index([0, 1, 2, 4, 5, 6, 7, 8, 10, 12, 14, 16, 18, 25])\n        elidx = np.array([0, -1, 1, 2, -1, 3, -1, 4, 5, 6, 7, 8, 9, -1], dtype=np.intp)\n        eridx = np.array(\n            [-1, 3, 4, -1, 5, -1, 0, -1, -1, 1, -1, -1, -1, 2], dtype=np.intp\n        )\n\n        assert isinstance(res, Int64Index)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)\n\n        # monotonic\n        res, lidx, ridx = index.join(other_mono, how=\"outer\", return_indexers=True)\n        noidx_res = index.join(other_mono, how=\"outer\")\n        tm.assert_index_equal(res, noidx_res)\n\n        elidx = np.array([0, -1, 1, 2, -1, 3, -1, 4, 5, 6, 7, 8, 9, -1], dtype=np.intp)\n        eridx = np.array(\n            [-1, 0, 1, -1, 2, -1, 3, -1, -1, 4, -1, -1, -1, 5], dtype=np.intp\n        )\n        assert isinstance(res, Int64Index)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)",
        "begin_line": 885,
        "end_line": 919,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestUInt64Index.indices#934",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestUInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestUInt64Index.indices(self, request)",
        "snippet": "    def indices(self, request):\n        return UInt64Index(request.param)",
        "begin_line": 934,
        "end_line": 935,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestUInt64Index.index_large#938",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestUInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestUInt64Index.index_large(self)",
        "snippet": "    def index_large(self):\n        # large values used in TestUInt64Index where no compat needed with Int64/Float64\n        large = [2 ** 63, 2 ** 63 + 10, 2 ** 63 + 15, 2 ** 63 + 20, 2 ** 63 + 25]\n        return UInt64Index(large)",
        "begin_line": 938,
        "end_line": 941,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestUInt64Index.create_index#943",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestUInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestUInt64Index.create_index(self)",
        "snippet": "    def create_index(self):\n        # compat with shared Int64/Float64 tests; use index_large for UInt64 only tests\n        return UInt64Index(np.arange(5, dtype=\"uint64\"))",
        "begin_line": 943,
        "end_line": 945,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestUInt64Index.test_constructor#947",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestUInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestUInt64Index.test_constructor(self)",
        "snippet": "    def test_constructor(self):\n        idx = UInt64Index([1, 2, 3])\n        res = Index([1, 2, 3], dtype=np.uint64)\n        tm.assert_index_equal(res, idx)\n\n        idx = UInt64Index([1, 2 ** 63])\n        res = Index([1, 2 ** 63], dtype=np.uint64)\n        tm.assert_index_equal(res, idx)\n\n        idx = UInt64Index([1, 2 ** 63])\n        res = Index([1, 2 ** 63])\n        tm.assert_index_equal(res, idx)\n\n        idx = Index([-1, 2 ** 63], dtype=object)\n        res = Index(np.array([-1, 2 ** 63], dtype=object))\n        tm.assert_index_equal(res, idx)\n\n        # https://github.com/pandas-dev/pandas/issues/29526\n        idx = UInt64Index([1, 2 ** 63 + 1], dtype=np.uint64)\n        res = Index([1, 2 ** 63 + 1], dtype=np.uint64)\n        tm.assert_index_equal(res, idx)",
        "begin_line": 947,
        "end_line": 967,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestUInt64Index.test_get_indexer#969",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestUInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestUInt64Index.test_get_indexer(self, index_large)",
        "snippet": "    def test_get_indexer(self, index_large):\n        target = UInt64Index(np.arange(10).astype(\"uint64\") * 5 + 2 ** 63)\n        indexer = index_large.get_indexer(target)\n        expected = np.array([0, -1, 1, 2, 3, 4, -1, -1, -1, -1], dtype=np.intp)\n        tm.assert_numpy_array_equal(indexer, expected)\n\n        target = UInt64Index(np.arange(10).astype(\"uint64\") * 5 + 2 ** 63)\n        indexer = index_large.get_indexer(target, method=\"pad\")\n        expected = np.array([0, 0, 1, 2, 3, 4, 4, 4, 4, 4], dtype=np.intp)\n        tm.assert_numpy_array_equal(indexer, expected)\n\n        target = UInt64Index(np.arange(10).astype(\"uint64\") * 5 + 2 ** 63)\n        indexer = index_large.get_indexer(target, method=\"backfill\")\n        expected = np.array([0, 1, 1, 2, 3, 4, -1, -1, -1, -1], dtype=np.intp)\n        tm.assert_numpy_array_equal(indexer, expected)",
        "begin_line": 969,
        "end_line": 983,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestUInt64Index.test_intersection#985",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestUInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestUInt64Index.test_intersection(self, index_large)",
        "snippet": "    def test_intersection(self, index_large):\n        other = Index([2 ** 63, 2 ** 63 + 5, 2 ** 63 + 10, 2 ** 63 + 15, 2 ** 63 + 20])\n        result = index_large.intersection(other)\n        expected = Index(np.sort(np.intersect1d(index_large.values, other.values)))\n        tm.assert_index_equal(result, expected)\n\n        result = other.intersection(index_large)\n        expected = Index(\n            np.sort(np.asarray(np.intersect1d(index_large.values, other.values)))\n        )\n        tm.assert_index_equal(result, expected)",
        "begin_line": 985,
        "end_line": 995,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestUInt64Index.test_join_inner#997",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestUInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestUInt64Index.test_join_inner(self, index_large)",
        "snippet": "    def test_join_inner(self, index_large):\n        other = UInt64Index(2 ** 63 + np.array([7, 12, 25, 1, 2, 10], dtype=\"uint64\"))\n        other_mono = UInt64Index(\n            2 ** 63 + np.array([1, 2, 7, 10, 12, 25], dtype=\"uint64\")\n        )\n\n        # not monotonic\n        res, lidx, ridx = index_large.join(other, how=\"inner\", return_indexers=True)\n\n        # no guarantee of sortedness, so sort for comparison purposes\n        ind = res.argsort()\n        res = res.take(ind)\n        lidx = lidx.take(ind)\n        ridx = ridx.take(ind)\n\n        eres = UInt64Index(2 ** 63 + np.array([10, 25], dtype=\"uint64\"))\n        elidx = np.array([1, 4], dtype=np.intp)\n        eridx = np.array([5, 2], dtype=np.intp)\n\n        assert isinstance(res, UInt64Index)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)\n\n        # monotonic\n        res, lidx, ridx = index_large.join(\n            other_mono, how=\"inner\", return_indexers=True\n        )\n\n        res2 = index_large.intersection(other_mono)\n        tm.assert_index_equal(res, res2)\n\n        elidx = np.array([1, 4], dtype=np.intp)\n        eridx = np.array([3, 5], dtype=np.intp)\n\n        assert isinstance(res, UInt64Index)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)",
        "begin_line": 997,
        "end_line": 1035,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestUInt64Index.test_join_left#1037",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestUInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestUInt64Index.test_join_left(self, index_large)",
        "snippet": "    def test_join_left(self, index_large):\n        other = UInt64Index(2 ** 63 + np.array([7, 12, 25, 1, 2, 10], dtype=\"uint64\"))\n        other_mono = UInt64Index(\n            2 ** 63 + np.array([1, 2, 7, 10, 12, 25], dtype=\"uint64\")\n        )\n\n        # not monotonic\n        res, lidx, ridx = index_large.join(other, how=\"left\", return_indexers=True)\n        eres = index_large\n        eridx = np.array([-1, 5, -1, -1, 2], dtype=np.intp)\n\n        assert isinstance(res, UInt64Index)\n        tm.assert_index_equal(res, eres)\n        assert lidx is None\n        tm.assert_numpy_array_equal(ridx, eridx)\n\n        # monotonic\n        res, lidx, ridx = index_large.join(other_mono, how=\"left\", return_indexers=True)\n        eridx = np.array([-1, 3, -1, -1, 5], dtype=np.intp)\n\n        assert isinstance(res, UInt64Index)\n        tm.assert_index_equal(res, eres)\n        assert lidx is None\n        tm.assert_numpy_array_equal(ridx, eridx)\n\n        # non-unique\n        idx = UInt64Index(2 ** 63 + np.array([1, 1, 2, 5], dtype=\"uint64\"))\n        idx2 = UInt64Index(2 ** 63 + np.array([1, 2, 5, 7, 9], dtype=\"uint64\"))\n        res, lidx, ridx = idx2.join(idx, how=\"left\", return_indexers=True)\n\n        # 1 is in idx2, so it should be x2\n        eres = UInt64Index(2 ** 63 + np.array([1, 1, 2, 5, 7, 9], dtype=\"uint64\"))\n        eridx = np.array([0, 1, 2, 3, -1, -1], dtype=np.intp)\n        elidx = np.array([0, 0, 1, 2, 3, 4], dtype=np.intp)\n\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)",
        "begin_line": 1037,
        "end_line": 1074,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestUInt64Index.test_join_right#1076",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestUInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestUInt64Index.test_join_right(self, index_large)",
        "snippet": "    def test_join_right(self, index_large):\n        other = UInt64Index(2 ** 63 + np.array([7, 12, 25, 1, 2, 10], dtype=\"uint64\"))\n        other_mono = UInt64Index(\n            2 ** 63 + np.array([1, 2, 7, 10, 12, 25], dtype=\"uint64\")\n        )\n\n        # not monotonic\n        res, lidx, ridx = index_large.join(other, how=\"right\", return_indexers=True)\n        eres = other\n        elidx = np.array([-1, -1, 4, -1, -1, 1], dtype=np.intp)\n\n        tm.assert_numpy_array_equal(lidx, elidx)\n        assert isinstance(other, UInt64Index)\n        tm.assert_index_equal(res, eres)\n        assert ridx is None\n\n        # monotonic\n        res, lidx, ridx = index_large.join(\n            other_mono, how=\"right\", return_indexers=True\n        )\n        eres = other_mono\n        elidx = np.array([-1, -1, -1, 1, -1, 4], dtype=np.intp)\n\n        assert isinstance(other, UInt64Index)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_index_equal(res, eres)\n        assert ridx is None\n\n        # non-unique\n        idx = UInt64Index(2 ** 63 + np.array([1, 1, 2, 5], dtype=\"uint64\"))\n        idx2 = UInt64Index(2 ** 63 + np.array([1, 2, 5, 7, 9], dtype=\"uint64\"))\n        res, lidx, ridx = idx.join(idx2, how=\"right\", return_indexers=True)\n\n        # 1 is in idx2, so it should be x2\n        eres = UInt64Index(2 ** 63 + np.array([1, 1, 2, 5, 7, 9], dtype=\"uint64\"))\n        elidx = np.array([0, 1, 2, 3, -1, -1], dtype=np.intp)\n        eridx = np.array([0, 0, 1, 2, 3, 4], dtype=np.intp)\n\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)",
        "begin_line": 1076,
        "end_line": 1116,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestUInt64Index.test_join_non_int_index#1118",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestUInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestUInt64Index.test_join_non_int_index(self, index_large)",
        "snippet": "    def test_join_non_int_index(self, index_large):\n        other = Index(\n            2 ** 63 + np.array([1, 5, 7, 10, 20], dtype=\"uint64\"), dtype=object\n        )\n\n        outer = index_large.join(other, how=\"outer\")\n        outer2 = other.join(index_large, how=\"outer\")\n        expected = Index(\n            2 ** 63 + np.array([0, 1, 5, 7, 10, 15, 20, 25], dtype=\"uint64\")\n        )\n        tm.assert_index_equal(outer, outer2)\n        tm.assert_index_equal(outer, expected)\n\n        inner = index_large.join(other, how=\"inner\")\n        inner2 = other.join(index_large, how=\"inner\")\n        expected = Index(2 ** 63 + np.array([10, 20], dtype=\"uint64\"))\n        tm.assert_index_equal(inner, inner2)\n        tm.assert_index_equal(inner, expected)\n\n        left = index_large.join(other, how=\"left\")\n        tm.assert_index_equal(left, index_large.astype(object))\n\n        left2 = other.join(index_large, how=\"left\")\n        tm.assert_index_equal(left2, other)\n\n        right = index_large.join(other, how=\"right\")\n        tm.assert_index_equal(right, other)\n\n        right2 = other.join(index_large, how=\"right\")\n        tm.assert_index_equal(right2, index_large.astype(object))",
        "begin_line": 1118,
        "end_line": 1147,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.TestUInt64Index.test_join_outer#1149",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric.TestUInt64Index",
        "signature": "pandas.tests.indexes.test_numeric.TestUInt64Index.test_join_outer(self, index_large)",
        "snippet": "    def test_join_outer(self, index_large):\n        other = UInt64Index(2 ** 63 + np.array([7, 12, 25, 1, 2, 10], dtype=\"uint64\"))\n        other_mono = UInt64Index(\n            2 ** 63 + np.array([1, 2, 7, 10, 12, 25], dtype=\"uint64\")\n        )\n\n        # not monotonic\n        # guarantee of sortedness\n        res, lidx, ridx = index_large.join(other, how=\"outer\", return_indexers=True)\n        noidx_res = index_large.join(other, how=\"outer\")\n        tm.assert_index_equal(res, noidx_res)\n\n        eres = UInt64Index(\n            2 ** 63 + np.array([0, 1, 2, 7, 10, 12, 15, 20, 25], dtype=\"uint64\")\n        )\n        elidx = np.array([0, -1, -1, -1, 1, -1, 2, 3, 4], dtype=np.intp)\n        eridx = np.array([-1, 3, 4, 0, 5, 1, -1, -1, 2], dtype=np.intp)\n\n        assert isinstance(res, UInt64Index)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)\n\n        # monotonic\n        res, lidx, ridx = index_large.join(\n            other_mono, how=\"outer\", return_indexers=True\n        )\n        noidx_res = index_large.join(other_mono, how=\"outer\")\n        tm.assert_index_equal(res, noidx_res)\n\n        elidx = np.array([0, -1, -1, -1, 1, -1, 2, 3, 4], dtype=np.intp)\n        eridx = np.array([-1, 0, 1, 2, 3, 4, -1, -1, 5], dtype=np.intp)\n\n        assert isinstance(res, UInt64Index)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)",
        "begin_line": 1149,
        "end_line": 1185,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.test_int_float_union_dtype#1189",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric",
        "signature": "pandas.tests.indexes.test_numeric.test_int_float_union_dtype(dtype)",
        "snippet": "def test_int_float_union_dtype(dtype):\n    # https://github.com/pandas-dev/pandas/issues/26778\n    # [u]int | float -> float\n    index = pd.Index([0, 2, 3], dtype=dtype)\n    other = pd.Float64Index([0.5, 1.5])\n    expected = pd.Float64Index([0.0, 0.5, 1.5, 2.0, 3.0])\n    result = index.union(other)\n    tm.assert_index_equal(result, expected)\n\n    result = other.union(index)\n    tm.assert_index_equal(result, expected)",
        "begin_line": 1189,
        "end_line": 1199,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_numeric.test_range_float_union_dtype#1202",
        "src_path": "pandas/tests/indexes/test_numeric.py",
        "class_name": "pandas.tests.indexes.test_numeric",
        "signature": "pandas.tests.indexes.test_numeric.test_range_float_union_dtype()",
        "snippet": "def test_range_float_union_dtype():\n    # https://github.com/pandas-dev/pandas/issues/26778\n    index = pd.RangeIndex(start=0, stop=3)\n    other = pd.Float64Index([0.5, 1.5])\n    result = index.union(other)\n    expected = pd.Float64Index([0.0, 0.5, 1, 1.5, 2.0])\n    tm.assert_index_equal(result, expected)\n\n    result = other.union(index)\n    tm.assert_index_equal(result, expected)",
        "begin_line": 1202,
        "end_line": 1211,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.indices#32",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.indices(self, request)",
        "snippet": "    def indices(self, request):\n        return request.param",
        "begin_line": 32,
        "end_line": 33,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.create_index#35",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.create_index(self)",
        "snippet": "    def create_index(self):\n        return RangeIndex(start=0, stop=20, step=2)",
        "begin_line": 35,
        "end_line": 36,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_can_hold_identifiers#38",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_can_hold_identifiers(self)",
        "snippet": "    def test_can_hold_identifiers(self):\n        idx = self.create_index()\n        key = idx[0]\n        assert idx._can_hold_identifiers_and_holds_name(key) is False",
        "begin_line": 38,
        "end_line": 41,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_too_many_names#43",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_too_many_names(self)",
        "snippet": "    def test_too_many_names(self):\n        index = self.create_index()\n        with pytest.raises(ValueError, match=\"^Length\"):\n            index.names = [\"roger\", \"harold\"]",
        "begin_line": 43,
        "end_line": 46,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor#61",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor(self, args, kwargs, start, stop, step, name)",
        "snippet": "    def test_constructor(self, args, kwargs, start, stop, step, name):\n        result = RangeIndex(*args, name=name, **kwargs)\n        expected = Index(np.arange(start, stop, step, dtype=np.int64), name=name)\n        assert isinstance(result, RangeIndex)\n        assert result.name is name\n        assert result._range == range(start, stop, step)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 61,
        "end_line": 67,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_invalid_args#69",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_invalid_args(self)",
        "snippet": "    def test_constructor_invalid_args(self):\n        msg = \"RangeIndex\\\\(\\\\.\\\\.\\\\.\\\\) must be called with integers\"\n        with pytest.raises(TypeError, match=msg):\n            RangeIndex()\n\n        with pytest.raises(TypeError, match=msg):\n            RangeIndex(name=\"Foo\")\n\n        # invalid args\n        for i in [\n            Index([\"a\", \"b\"]),\n            Series([\"a\", \"b\"]),\n            np.array([\"a\", \"b\"]),\n            [],\n            \"foo\",\n            datetime(2000, 1, 1, 0, 0),\n            np.arange(0, 10),\n            np.array([1]),\n            [1],\n        ]:\n            with pytest.raises(TypeError):\n                RangeIndex(i)\n\n        # we don't allow on a bare Index\n        msg = (\n            r\"Index\\(\\.\\.\\.\\) must be called with a collection of some \"\n            r\"kind, 0 was passed\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            Index(0, 1000)",
        "begin_line": 69,
        "end_line": 98,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_same#100",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_same(self)",
        "snippet": "    def test_constructor_same(self):\n\n        # pass thru w and w/o copy\n        index = RangeIndex(1, 5, 2)\n        result = RangeIndex(index, copy=False)\n        assert result.identical(index)\n\n        result = RangeIndex(index, copy=True)\n        tm.assert_index_equal(result, index, exact=True)\n\n        result = RangeIndex(index)\n        tm.assert_index_equal(result, index, exact=True)\n\n        with pytest.raises(\n            ValueError,\n            match=\"Incorrect `dtype` passed: expected signed integer, received float64\",\n        ):\n            RangeIndex(index, dtype=\"float64\")",
        "begin_line": 100,
        "end_line": 117,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_range#119",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_range(self)",
        "snippet": "    def test_constructor_range(self):\n\n        msg = \"Value needs to be a scalar value, was type <class 'range'>\"\n        with pytest.raises(TypeError, match=msg):\n            result = RangeIndex(range(1, 5, 2))\n\n        result = RangeIndex.from_range(range(1, 5, 2))\n        expected = RangeIndex(1, 5, 2)\n        tm.assert_index_equal(result, expected, exact=True)\n\n        result = RangeIndex.from_range(range(5, 6))\n        expected = RangeIndex(5, 6, 1)\n        tm.assert_index_equal(result, expected, exact=True)\n\n        # an invalid range\n        result = RangeIndex.from_range(range(5, 1))\n        expected = RangeIndex(0, 0, 1)\n        tm.assert_index_equal(result, expected, exact=True)\n\n        result = RangeIndex.from_range(range(5))\n        expected = RangeIndex(0, 5, 1)\n        tm.assert_index_equal(result, expected, exact=True)\n\n        result = Index(range(1, 5, 2))\n        expected = RangeIndex(1, 5, 2)\n        tm.assert_index_equal(result, expected, exact=True)\n\n        with pytest.raises(\n            ValueError,\n            match=\"Incorrect `dtype` passed: expected signed integer, received float64\",\n        ):\n            Index(range(1, 5, 2), dtype=\"float64\")\n        msg = r\"^from_range\\(\\) got an unexpected keyword argument\"\n        with pytest.raises(TypeError, match=msg):\n            pd.RangeIndex.from_range(range(10), copy=True)",
        "begin_line": 119,
        "end_line": 153,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_name#155",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_name(self)",
        "snippet": "    def test_constructor_name(self):\n        # GH12288\n        orig = RangeIndex(10)\n        orig.name = \"original\"\n\n        copy = RangeIndex(orig)\n        copy.name = \"copy\"\n\n        assert orig.name == \"original\"\n        assert copy.name == \"copy\"\n\n        new = Index(copy)\n        assert new.name == \"copy\"\n\n        new.name = \"new\"\n        assert orig.name == \"original\"\n        assert copy.name == \"copy\"\n        assert new.name == \"new\"",
        "begin_line": 155,
        "end_line": 172,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_corner#174",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_constructor_corner(self)",
        "snippet": "    def test_constructor_corner(self):\n        arr = np.array([1, 2, 3, 4], dtype=object)\n        index = RangeIndex(1, 5)\n        assert index.values.dtype == np.int64\n        tm.assert_index_equal(index, Index(arr))\n\n        # non-int raise Exception\n        with pytest.raises(TypeError):\n            RangeIndex(\"1\", \"10\", \"1\")\n        with pytest.raises(TypeError):\n            RangeIndex(1.1, 10.2, 1.3)\n\n        # invalid passed type\n        with pytest.raises(\n            ValueError,\n            match=\"Incorrect `dtype` passed: expected signed integer, received float64\",\n        ):\n            RangeIndex(1, 5, dtype=\"float64\")",
        "begin_line": 174,
        "end_line": 191,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_start_stop_step_attrs#202",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_start_stop_step_attrs(self, index, start, stop, step)",
        "snippet": "    def test_start_stop_step_attrs(self, index, start, stop, step):\n        # GH 25710\n        assert index.start == start\n        assert index.stop == stop\n        assert index.step == step",
        "begin_line": 202,
        "end_line": 206,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_deprecated_start_stop_step_attrs#209",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_deprecated_start_stop_step_attrs(self, attr_name)",
        "snippet": "    def test_deprecated_start_stop_step_attrs(self, attr_name):\n        # GH 26581\n        idx = self.create_index()\n        with tm.assert_produces_warning(DeprecationWarning):\n            getattr(idx, attr_name)",
        "begin_line": 209,
        "end_line": 213,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_copy#215",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_copy(self)",
        "snippet": "    def test_copy(self):\n        i = RangeIndex(5, name=\"Foo\")\n        i_copy = i.copy()\n        assert i_copy is not i\n        assert i_copy.identical(i)\n        assert i_copy._range == range(0, 5, 1)\n        assert i_copy.name == \"Foo\"",
        "begin_line": 215,
        "end_line": 221,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_repr#223",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_repr(self)",
        "snippet": "    def test_repr(self):\n        i = RangeIndex(5, name=\"Foo\")\n        result = repr(i)\n        expected = \"RangeIndex(start=0, stop=5, step=1, name='Foo')\"\n        assert result == expected\n\n        result = eval(result)\n        tm.assert_index_equal(result, i, exact=True)\n\n        i = RangeIndex(5, 0, -1)\n        result = repr(i)\n        expected = \"RangeIndex(start=5, stop=0, step=-1)\"\n        assert result == expected\n\n        result = eval(result)\n        tm.assert_index_equal(result, i, exact=True)",
        "begin_line": 223,
        "end_line": 238,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_insert#240",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_insert(self)",
        "snippet": "    def test_insert(self):\n\n        idx = RangeIndex(5, name=\"Foo\")\n        result = idx[1:4]\n\n        # test 0th element\n        tm.assert_index_equal(idx[0:4], result.insert(0, idx[0]))\n\n        # GH 18295 (test missing)\n        expected = Float64Index([0, np.nan, 1, 2, 3, 4])\n        for na in (np.nan, pd.NaT, None):\n            result = RangeIndex(5).insert(1, na)\n            tm.assert_index_equal(result, expected)",
        "begin_line": 240,
        "end_line": 252,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_delete#254",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_delete(self)",
        "snippet": "    def test_delete(self):\n\n        idx = RangeIndex(5, name=\"Foo\")\n        expected = idx[1:].astype(int)\n        result = idx.delete(0)\n        tm.assert_index_equal(result, expected)\n        assert result.name == expected.name\n\n        expected = idx[:-1].astype(int)\n        result = idx.delete(-1)\n        tm.assert_index_equal(result, expected)\n        assert result.name == expected.name\n\n        with pytest.raises((IndexError, ValueError)):\n            # either depending on numpy version\n            result = idx.delete(len(idx))",
        "begin_line": 254,
        "end_line": 269,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_view#271",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_view(self)",
        "snippet": "    def test_view(self):\n        i = RangeIndex(0, name=\"Foo\")\n        i_view = i.view()\n        assert i_view.name == \"Foo\"\n\n        i_view = i.view(\"i8\")\n        tm.assert_numpy_array_equal(i.values, i_view)\n\n        i_view = i.view(RangeIndex)\n        tm.assert_index_equal(i, i_view)",
        "begin_line": 271,
        "end_line": 280,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_dtype#282",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_dtype(self)",
        "snippet": "    def test_dtype(self):\n        index = self.create_index()\n        assert index.dtype == np.int64",
        "begin_line": 282,
        "end_line": 284,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_cached_data#286",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_cached_data(self)",
        "snippet": "    def test_cached_data(self):\n        # GH 26565, GH26617\n        # Calling RangeIndex._data caches an int64 array of the same length at\n        # self._cached_data. This test checks whether _cached_data has been set\n        idx = RangeIndex(0, 100, 10)\n\n        assert idx._cached_data is None\n\n        repr(idx)\n        assert idx._cached_data is None\n\n        str(idx)\n        assert idx._cached_data is None\n\n        idx.get_loc(20)\n        assert idx._cached_data is None\n\n        90 in idx\n        assert idx._cached_data is None\n\n        91 in idx\n        assert idx._cached_data is None\n\n        with tm.assert_produces_warning(FutureWarning):\n            idx.contains(90)\n        assert idx._cached_data is None\n\n        with tm.assert_produces_warning(FutureWarning):\n            idx.contains(91)\n        assert idx._cached_data is None\n\n        idx.all()\n        assert idx._cached_data is None\n\n        idx.any()\n        assert idx._cached_data is None\n\n        df = pd.DataFrame({\"a\": range(10)}, index=idx)\n\n        df.loc[50]\n        assert idx._cached_data is None\n\n        with pytest.raises(KeyError, match=\"51\"):\n            df.loc[51]\n        assert idx._cached_data is None\n\n        df.loc[10:50]\n        assert idx._cached_data is None\n\n        df.iloc[5:10]\n        assert idx._cached_data is None\n\n        # actually calling idx._data\n        assert isinstance(idx._data, np.ndarray)\n        assert isinstance(idx._cached_data, np.ndarray)",
        "begin_line": 286,
        "end_line": 340,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_is_monotonic#342",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_is_monotonic(self)",
        "snippet": "    def test_is_monotonic(self):\n        index = RangeIndex(0, 20, 2)\n        assert index.is_monotonic is True\n        assert index.is_monotonic_increasing is True\n        assert index.is_monotonic_decreasing is False\n        assert index._is_strictly_monotonic_increasing is True\n        assert index._is_strictly_monotonic_decreasing is False\n\n        index = RangeIndex(4, 0, -1)\n        assert index.is_monotonic is False\n        assert index._is_strictly_monotonic_increasing is False\n        assert index.is_monotonic_decreasing is True\n        assert index._is_strictly_monotonic_decreasing is True\n\n        index = RangeIndex(1, 2)\n        assert index.is_monotonic is True\n        assert index.is_monotonic_increasing is True\n        assert index.is_monotonic_decreasing is True\n        assert index._is_strictly_monotonic_increasing is True\n        assert index._is_strictly_monotonic_decreasing is True\n\n        index = RangeIndex(2, 1)\n        assert index.is_monotonic is True\n        assert index.is_monotonic_increasing is True\n        assert index.is_monotonic_decreasing is True\n        assert index._is_strictly_monotonic_increasing is True\n        assert index._is_strictly_monotonic_decreasing is True\n\n        index = RangeIndex(1, 1)\n        assert index.is_monotonic is True\n        assert index.is_monotonic_increasing is True\n        assert index.is_monotonic_decreasing is True\n        assert index._is_strictly_monotonic_increasing is True\n        assert index._is_strictly_monotonic_decreasing is True",
        "begin_line": 342,
        "end_line": 375,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_equals_range#377",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_equals_range(self)",
        "snippet": "    def test_equals_range(self):\n        equiv_pairs = [\n            (RangeIndex(0, 9, 2), RangeIndex(0, 10, 2)),\n            (RangeIndex(0), RangeIndex(1, -1, 3)),\n            (RangeIndex(1, 2, 3), RangeIndex(1, 3, 4)),\n            (RangeIndex(0, -9, -2), RangeIndex(0, -10, -2)),\n        ]\n        for left, right in equiv_pairs:\n            assert left.equals(right)\n            assert right.equals(left)",
        "begin_line": 377,
        "end_line": 386,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_logical_compat#388",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_logical_compat(self)",
        "snippet": "    def test_logical_compat(self):\n        idx = self.create_index()\n        assert idx.all() == idx.values.all()\n        assert idx.any() == idx.values.any()",
        "begin_line": 388,
        "end_line": 391,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_identical#393",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_identical(self)",
        "snippet": "    def test_identical(self):\n        index = self.create_index()\n        i = Index(index.copy())\n        assert i.identical(index)\n\n        # we don't allow object dtype for RangeIndex\n        if isinstance(index, RangeIndex):\n            return\n\n        same_values_different_type = Index(i, dtype=object)\n        assert not i.identical(same_values_different_type)\n\n        i = index.copy(dtype=object)\n        i = i.rename(\"foo\")\n        same_values = Index(i, dtype=object)\n        assert same_values.identical(index.copy(dtype=object))\n\n        assert not i.identical(index)\n        assert Index(same_values, name=\"foo\", dtype=object).identical(i)\n\n        assert not index.copy(dtype=object).identical(index.copy(dtype=\"int64\"))",
        "begin_line": 393,
        "end_line": 413,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_get_indexer#415",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_get_indexer(self)",
        "snippet": "    def test_get_indexer(self):\n        index = self.create_index()\n        target = RangeIndex(10)\n        indexer = index.get_indexer(target)\n        expected = np.array([0, -1, 1, -1, 2, -1, 3, -1, 4, -1], dtype=np.intp)\n        tm.assert_numpy_array_equal(indexer, expected)",
        "begin_line": 415,
        "end_line": 420,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_get_indexer_pad#422",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_get_indexer_pad(self)",
        "snippet": "    def test_get_indexer_pad(self):\n        index = self.create_index()\n        target = RangeIndex(10)\n        indexer = index.get_indexer(target, method=\"pad\")\n        expected = np.array([0, 0, 1, 1, 2, 2, 3, 3, 4, 4], dtype=np.intp)\n        tm.assert_numpy_array_equal(indexer, expected)",
        "begin_line": 422,
        "end_line": 427,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_get_indexer_backfill#429",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_get_indexer_backfill(self)",
        "snippet": "    def test_get_indexer_backfill(self):\n        index = self.create_index()\n        target = RangeIndex(10)\n        indexer = index.get_indexer(target, method=\"backfill\")\n        expected = np.array([0, 1, 1, 2, 2, 3, 3, 4, 4, 5], dtype=np.intp)\n        tm.assert_numpy_array_equal(indexer, expected)",
        "begin_line": 429,
        "end_line": 434,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_get_indexer_limit#436",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_get_indexer_limit(self)",
        "snippet": "    def test_get_indexer_limit(self):\n        # GH 28631\n        idx = RangeIndex(4)\n        target = RangeIndex(6)\n        result = idx.get_indexer(target, method=\"pad\", limit=1)\n        expected = np.array([0, 1, 2, 3, 3, -1], dtype=np.intp)\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 436,
        "end_line": 442,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_get_indexer_decreasing#445",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_get_indexer_decreasing(self, stop)",
        "snippet": "    def test_get_indexer_decreasing(self, stop):\n        # GH 28678\n        index = RangeIndex(7, stop, -3)\n        result = index.get_indexer(range(9))\n        expected = np.array([-1, 2, -1, -1, 1, -1, -1, 0, -1], dtype=np.intp)\n        tm.assert_numpy_array_equal(result, expected)",
        "begin_line": 445,
        "end_line": 450,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_outer#452",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_outer(self)",
        "snippet": "    def test_join_outer(self):\n        # join with Int64Index\n        index = self.create_index()\n        other = Int64Index(np.arange(25, 14, -1))\n\n        res, lidx, ridx = index.join(other, how=\"outer\", return_indexers=True)\n        noidx_res = index.join(other, how=\"outer\")\n        tm.assert_index_equal(res, noidx_res)\n\n        eres = Int64Index(\n            [0, 2, 4, 6, 8, 10, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n        )\n        elidx = np.array(\n            [0, 1, 2, 3, 4, 5, 6, 7, -1, 8, -1, 9, -1, -1, -1, -1, -1, -1, -1],\n            dtype=np.intp,\n        )\n        eridx = np.array(\n            [-1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0],\n            dtype=np.intp,\n        )\n\n        assert isinstance(res, Int64Index)\n        assert not isinstance(res, RangeIndex)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)\n\n        # join with RangeIndex\n        other = RangeIndex(25, 14, -1)\n\n        res, lidx, ridx = index.join(other, how=\"outer\", return_indexers=True)\n        noidx_res = index.join(other, how=\"outer\")\n        tm.assert_index_equal(res, noidx_res)\n\n        assert isinstance(res, Int64Index)\n        assert not isinstance(res, RangeIndex)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)",
        "begin_line": 452,
        "end_line": 490,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_inner#492",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_inner(self)",
        "snippet": "    def test_join_inner(self):\n        # Join with non-RangeIndex\n        index = self.create_index()\n        other = Int64Index(np.arange(25, 14, -1))\n\n        res, lidx, ridx = index.join(other, how=\"inner\", return_indexers=True)\n\n        # no guarantee of sortedness, so sort for comparison purposes\n        ind = res.argsort()\n        res = res.take(ind)\n        lidx = lidx.take(ind)\n        ridx = ridx.take(ind)\n\n        eres = Int64Index([16, 18])\n        elidx = np.array([8, 9], dtype=np.intp)\n        eridx = np.array([9, 7], dtype=np.intp)\n\n        assert isinstance(res, Int64Index)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)\n\n        # Join two RangeIndex\n        other = RangeIndex(25, 14, -1)\n\n        res, lidx, ridx = index.join(other, how=\"inner\", return_indexers=True)\n\n        assert isinstance(res, RangeIndex)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)",
        "begin_line": 492,
        "end_line": 522,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_left#524",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_left(self)",
        "snippet": "    def test_join_left(self):\n        # Join with Int64Index\n        index = self.create_index()\n        other = Int64Index(np.arange(25, 14, -1))\n\n        res, lidx, ridx = index.join(other, how=\"left\", return_indexers=True)\n        eres = index\n        eridx = np.array([-1, -1, -1, -1, -1, -1, -1, -1, 9, 7], dtype=np.intp)\n\n        assert isinstance(res, RangeIndex)\n        tm.assert_index_equal(res, eres)\n        assert lidx is None\n        tm.assert_numpy_array_equal(ridx, eridx)\n\n        # Join withRangeIndex\n        other = Int64Index(np.arange(25, 14, -1))\n\n        res, lidx, ridx = index.join(other, how=\"left\", return_indexers=True)\n\n        assert isinstance(res, RangeIndex)\n        tm.assert_index_equal(res, eres)\n        assert lidx is None\n        tm.assert_numpy_array_equal(ridx, eridx)",
        "begin_line": 524,
        "end_line": 546,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_right#548",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_right(self)",
        "snippet": "    def test_join_right(self):\n        # Join with Int64Index\n        index = self.create_index()\n        other = Int64Index(np.arange(25, 14, -1))\n\n        res, lidx, ridx = index.join(other, how=\"right\", return_indexers=True)\n        eres = other\n        elidx = np.array([-1, -1, -1, -1, -1, -1, -1, 9, -1, 8, -1], dtype=np.intp)\n\n        assert isinstance(other, Int64Index)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        assert ridx is None\n\n        # Join withRangeIndex\n        other = RangeIndex(25, 14, -1)\n\n        res, lidx, ridx = index.join(other, how=\"right\", return_indexers=True)\n        eres = other\n\n        assert isinstance(other, RangeIndex)\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        assert ridx is None",
        "begin_line": 548,
        "end_line": 571,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_non_int_index#573",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_non_int_index(self)",
        "snippet": "    def test_join_non_int_index(self):\n        index = self.create_index()\n        other = Index([3, 6, 7, 8, 10], dtype=object)\n\n        outer = index.join(other, how=\"outer\")\n        outer2 = other.join(index, how=\"outer\")\n        expected = Index([0, 2, 3, 4, 6, 7, 8, 10, 12, 14, 16, 18])\n        tm.assert_index_equal(outer, outer2)\n        tm.assert_index_equal(outer, expected)\n\n        inner = index.join(other, how=\"inner\")\n        inner2 = other.join(index, how=\"inner\")\n        expected = Index([6, 8, 10])\n        tm.assert_index_equal(inner, inner2)\n        tm.assert_index_equal(inner, expected)\n\n        left = index.join(other, how=\"left\")\n        tm.assert_index_equal(left, index.astype(object))\n\n        left2 = other.join(index, how=\"left\")\n        tm.assert_index_equal(left2, other)\n\n        right = index.join(other, how=\"right\")\n        tm.assert_index_equal(right, other)\n\n        right2 = other.join(index, how=\"right\")\n        tm.assert_index_equal(right2, index.astype(object))",
        "begin_line": 573,
        "end_line": 599,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_non_unique#601",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_non_unique(self)",
        "snippet": "    def test_join_non_unique(self):\n        index = self.create_index()\n        other = Index([4, 4, 3, 3])\n\n        res, lidx, ridx = index.join(other, return_indexers=True)\n\n        eres = Int64Index([0, 2, 4, 4, 6, 8, 10, 12, 14, 16, 18])\n        elidx = np.array([0, 1, 2, 2, 3, 4, 5, 6, 7, 8, 9], dtype=np.intp)\n        eridx = np.array([-1, -1, 0, 1, -1, -1, -1, -1, -1, -1, -1], dtype=np.intp)\n\n        tm.assert_index_equal(res, eres)\n        tm.assert_numpy_array_equal(lidx, elidx)\n        tm.assert_numpy_array_equal(ridx, eridx)",
        "begin_line": 601,
        "end_line": 613,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_self#615",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_join_self(self, join_type)",
        "snippet": "    def test_join_self(self, join_type):\n        index = self.create_index()\n        joined = index.join(index, how=join_type)\n        assert index is joined",
        "begin_line": 615,
        "end_line": 618,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_intersection#621",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_intersection(self, sort)",
        "snippet": "    def test_intersection(self, sort):\n        # intersect with Int64Index\n        index = self.create_index()\n        other = Index(np.arange(1, 6))\n        result = index.intersection(other, sort=sort)\n        expected = Index(np.sort(np.intersect1d(index.values, other.values)))\n        tm.assert_index_equal(result, expected)\n\n        result = other.intersection(index, sort=sort)\n        expected = Index(\n            np.sort(np.asarray(np.intersect1d(index.values, other.values)))\n        )\n        tm.assert_index_equal(result, expected)\n\n        # intersect with increasing RangeIndex\n        other = RangeIndex(1, 6)\n        result = index.intersection(other, sort=sort)\n        expected = Index(np.sort(np.intersect1d(index.values, other.values)))\n        tm.assert_index_equal(result, expected)\n\n        # intersect with decreasing RangeIndex\n        other = RangeIndex(5, 0, -1)\n        result = index.intersection(other, sort=sort)\n        expected = Index(np.sort(np.intersect1d(index.values, other.values)))\n        tm.assert_index_equal(result, expected)\n\n        # reversed (GH 17296)\n        result = other.intersection(index, sort=sort)\n        tm.assert_index_equal(result, expected)\n\n        # GH 17296: intersect two decreasing RangeIndexes\n        first = RangeIndex(10, -2, -2)\n        other = RangeIndex(5, -4, -1)\n        expected = first.astype(int).intersection(other.astype(int), sort=sort)\n        result = first.intersection(other, sort=sort).astype(int)\n        tm.assert_index_equal(result, expected)\n\n        # reversed\n        result = other.intersection(first, sort=sort).astype(int)\n        tm.assert_index_equal(result, expected)\n\n        index = RangeIndex(5)\n\n        # intersect of non-overlapping indices\n        other = RangeIndex(5, 10, 1)\n        result = index.intersection(other, sort=sort)\n        expected = RangeIndex(0, 0, 1)\n        tm.assert_index_equal(result, expected)\n\n        other = RangeIndex(-1, -5, -1)\n        result = index.intersection(other, sort=sort)\n        expected = RangeIndex(0, 0, 1)\n        tm.assert_index_equal(result, expected)\n\n        # intersection of empty indices\n        other = RangeIndex(0, 0, 1)\n        result = index.intersection(other, sort=sort)\n        expected = RangeIndex(0, 0, 1)\n        tm.assert_index_equal(result, expected)\n\n        result = other.intersection(index, sort=sort)\n        tm.assert_index_equal(result, expected)\n\n        # intersection of non-overlapping values based on start value and gcd\n        index = RangeIndex(1, 10, 2)\n        other = RangeIndex(0, 10, 4)\n        result = index.intersection(other, sort=sort)\n        expected = RangeIndex(0, 0, 1)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 621,
        "end_line": 689,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_union_noncomparable#692",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_union_noncomparable(self, sort)",
        "snippet": "    def test_union_noncomparable(self, sort):\n        # corner case, non-Int64Index\n        index = self.create_index()\n        other = Index([datetime.now() + timedelta(i) for i in range(4)], dtype=object)\n        result = index.union(other, sort=sort)\n        expected = Index(np.concatenate((index, other)))\n        tm.assert_index_equal(result, expected)\n\n        result = other.union(index, sort=sort)\n        expected = Index(np.concatenate((other, index)))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 692,
        "end_line": 702,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.unions#770",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.unions(self, request)",
        "snippet": "    def unions(self, request):\n        \"\"\"Inputs and expected outputs for RangeIndex.union tests\"\"\"\n\n        return request.param",
        "begin_line": 770,
        "end_line": 773,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_union_sorted#775",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_union_sorted(self, unions)",
        "snippet": "    def test_union_sorted(self, unions):\n\n        idx1, idx2, expected_sorted, expected_notsorted = unions\n\n        res1 = idx1.union(idx2, sort=None)\n        tm.assert_index_equal(res1, expected_sorted, exact=True)\n\n        res1 = idx1.union(idx2, sort=False)\n        tm.assert_index_equal(res1, expected_notsorted, exact=True)\n\n        res2 = idx2.union(idx1, sort=None)\n        res3 = idx1._int64index.union(idx2, sort=None)\n        tm.assert_index_equal(res2, expected_sorted, exact=True)\n        tm.assert_index_equal(res3, expected_sorted)",
        "begin_line": 775,
        "end_line": 788,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_nbytes#790",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_nbytes(self)",
        "snippet": "    def test_nbytes(self):\n\n        # memory savings vs int index\n        i = RangeIndex(0, 1000)\n        assert i.nbytes < i._int64index.nbytes / 10\n\n        # constant memory usage\n        i2 = RangeIndex(0, 10)\n        assert i.nbytes == i2.nbytes",
        "begin_line": 790,
        "end_line": 798,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_cant_or_shouldnt_cast#800",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_cant_or_shouldnt_cast(self)",
        "snippet": "    def test_cant_or_shouldnt_cast(self):\n        # can't\n        with pytest.raises(TypeError):\n            RangeIndex(\"foo\", \"bar\", \"baz\")\n\n        # shouldn't\n        with pytest.raises(TypeError):\n            RangeIndex(\"0\", \"1\", \"2\")",
        "begin_line": 800,
        "end_line": 807,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_view_index#809",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_view_index(self)",
        "snippet": "    def test_view_index(self):\n        index = self.create_index()\n        index.view(Index)",
        "begin_line": 809,
        "end_line": 811,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_prevent_casting#813",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_prevent_casting(self)",
        "snippet": "    def test_prevent_casting(self):\n        index = self.create_index()\n        result = index.astype(\"O\")\n        assert result.dtype == np.object_",
        "begin_line": 813,
        "end_line": 816,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_take_preserve_name#818",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_take_preserve_name(self)",
        "snippet": "    def test_take_preserve_name(self):\n        index = RangeIndex(1, 5, name=\"foo\")\n        taken = index.take([3, 0, 1])\n        assert index.name == taken.name",
        "begin_line": 818,
        "end_line": 821,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_take_fill_value#823",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_take_fill_value(self)",
        "snippet": "    def test_take_fill_value(self):\n        # GH 12631\n        idx = pd.RangeIndex(1, 4, name=\"xxx\")\n        result = idx.take(np.array([1, 0, -1]))\n        expected = pd.Int64Index([2, 1, 3], name=\"xxx\")\n        tm.assert_index_equal(result, expected)\n\n        # fill_value\n        msg = \"Unable to fill values because RangeIndex cannot contain NA\"\n        with pytest.raises(ValueError, match=msg):\n            idx.take(np.array([1, 0, -1]), fill_value=True)\n\n        # allow_fill=False\n        result = idx.take(np.array([1, 0, -1]), allow_fill=False, fill_value=True)\n        expected = pd.Int64Index([2, 1, 3], name=\"xxx\")\n        tm.assert_index_equal(result, expected)\n\n        msg = \"Unable to fill values because RangeIndex cannot contain NA\"\n        with pytest.raises(ValueError, match=msg):\n            idx.take(np.array([1, 0, -2]), fill_value=True)\n        with pytest.raises(ValueError, match=msg):\n            idx.take(np.array([1, 0, -5]), fill_value=True)\n\n        with pytest.raises(IndexError):\n            idx.take(np.array([1, -5]))",
        "begin_line": 823,
        "end_line": 847,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_print_unicode_columns#849",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_print_unicode_columns(self)",
        "snippet": "    def test_print_unicode_columns(self):\n        df = pd.DataFrame({\"\\u05d0\": [1, 2, 3], \"\\u05d1\": [4, 5, 6], \"c\": [7, 8, 9]})\n        repr(df.columns)  # should not raise UnicodeDecodeError",
        "begin_line": 849,
        "end_line": 851,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_repr_roundtrip#853",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_repr_roundtrip(self)",
        "snippet": "    def test_repr_roundtrip(self):\n        index = self.create_index()\n        tm.assert_index_equal(eval(repr(index)), index)",
        "begin_line": 853,
        "end_line": 855,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_slice_keep_name#857",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_slice_keep_name(self)",
        "snippet": "    def test_slice_keep_name(self):\n        idx = RangeIndex(1, 2, name=\"asdf\")\n        assert idx.name == idx[1:].name",
        "begin_line": 857,
        "end_line": 859,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_explicit_conversions#861",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_explicit_conversions(self)",
        "snippet": "    def test_explicit_conversions(self):\n\n        # GH 8608\n        # add/sub are overridden explicitly for Float/Int Index\n        idx = RangeIndex(5)\n\n        # float conversions\n        arr = np.arange(5, dtype=\"int64\") * 3.2\n        expected = Float64Index(arr)\n        fidx = idx * 3.2\n        tm.assert_index_equal(fidx, expected)\n        fidx = 3.2 * idx\n        tm.assert_index_equal(fidx, expected)\n\n        # interops with numpy arrays\n        expected = Float64Index(arr)\n        a = np.zeros(5, dtype=\"float64\")\n        result = fidx - a\n        tm.assert_index_equal(result, expected)\n\n        expected = Float64Index(-arr)\n        a = np.zeros(5, dtype=\"float64\")\n        result = a - fidx\n        tm.assert_index_equal(result, expected)",
        "begin_line": 861,
        "end_line": 884,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_has_duplicates#886",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_has_duplicates(self, indices)",
        "snippet": "    def test_has_duplicates(self, indices):\n        assert indices.is_unique\n        assert not indices.has_duplicates",
        "begin_line": 886,
        "end_line": 888,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_extended_gcd#890",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_extended_gcd(self)",
        "snippet": "    def test_extended_gcd(self):\n        index = self.create_index()\n        result = index._extended_gcd(6, 10)\n        assert result[0] == result[1] * 6 + result[2] * 10\n        assert 2 == result[0]\n\n        result = index._extended_gcd(10, 6)\n        assert 2 == result[1] * 10 + result[2] * 6\n        assert 2 == result[0]",
        "begin_line": 890,
        "end_line": 898,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_min_fitting_element#900",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_min_fitting_element(self)",
        "snippet": "    def test_min_fitting_element(self):\n        result = RangeIndex(0, 20, 2)._min_fitting_element(1)\n        assert 2 == result\n\n        result = RangeIndex(1, 6)._min_fitting_element(1)\n        assert 1 == result\n\n        result = RangeIndex(18, -2, -2)._min_fitting_element(1)\n        assert 2 == result\n\n        result = RangeIndex(5, 0, -1)._min_fitting_element(1)\n        assert 1 == result\n\n        big_num = 500000000000000000000000\n\n        result = RangeIndex(5, big_num * 2, 1)._min_fitting_element(big_num)\n        assert big_num == result",
        "begin_line": 900,
        "end_line": 916,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_max_fitting_element#918",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_max_fitting_element(self)",
        "snippet": "    def test_max_fitting_element(self):\n        result = RangeIndex(0, 20, 2)._max_fitting_element(17)\n        assert 16 == result\n\n        result = RangeIndex(1, 6)._max_fitting_element(4)\n        assert 4 == result\n\n        result = RangeIndex(18, -2, -2)._max_fitting_element(17)\n        assert 16 == result\n\n        result = RangeIndex(5, 0, -1)._max_fitting_element(4)\n        assert 4 == result\n\n        big_num = 500000000000000000000000\n\n        result = RangeIndex(5, big_num * 2, 1)._max_fitting_element(big_num)\n        assert big_num == result",
        "begin_line": 918,
        "end_line": 934,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_pickle_compat_construction#936",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_pickle_compat_construction(self)",
        "snippet": "    def test_pickle_compat_construction(self):\n        # RangeIndex() is a valid constructor\n        pass",
        "begin_line": 936,
        "end_line": 938,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_slice_specialised#940",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_slice_specialised(self)",
        "snippet": "    def test_slice_specialised(self):\n        index = self.create_index()\n        index.name = \"foo\"\n\n        # scalar indexing\n        res = index[1]\n        expected = 2\n        assert res == expected\n\n        res = index[-1]\n        expected = 18\n        assert res == expected\n\n        # slicing\n        # slice value completion\n        index_slice = index[:]\n        expected = index\n        tm.assert_index_equal(index_slice, expected)\n\n        # positive slice values\n        index_slice = index[7:10:2]\n        expected = Index(np.array([14, 18]), name=\"foo\")\n        tm.assert_index_equal(index_slice, expected)\n\n        # negative slice values\n        index_slice = index[-1:-5:-2]\n        expected = Index(np.array([18, 14]), name=\"foo\")\n        tm.assert_index_equal(index_slice, expected)\n\n        # stop overshoot\n        index_slice = index[2:100:4]\n        expected = Index(np.array([4, 12]), name=\"foo\")\n        tm.assert_index_equal(index_slice, expected)\n\n        # reverse\n        index_slice = index[::-1]\n        expected = Index(index.values[::-1], name=\"foo\")\n        tm.assert_index_equal(index_slice, expected)\n\n        index_slice = index[-8::-1]\n        expected = Index(np.array([4, 2, 0]), name=\"foo\")\n        tm.assert_index_equal(index_slice, expected)\n\n        index_slice = index[-40::-1]\n        expected = Index(np.array([], dtype=np.int64), name=\"foo\")\n        tm.assert_index_equal(index_slice, expected)\n\n        index_slice = index[40::-1]\n        expected = Index(index.values[40::-1], name=\"foo\")\n        tm.assert_index_equal(index_slice, expected)\n\n        index_slice = index[10::-1]\n        expected = Index(index.values[::-1], name=\"foo\")\n        tm.assert_index_equal(index_slice, expected)",
        "begin_line": 940,
        "end_line": 993,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_len_specialised#996",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_len_specialised(self, step)",
        "snippet": "    def test_len_specialised(self, step):\n        # make sure that our len is the same as np.arange calc\n        start, stop = (0, 5) if step > 0 else (5, 0)\n\n        arr = np.arange(start, stop, step)\n        index = RangeIndex(start, stop, step)\n        assert len(index) == len(arr)\n\n        index = RangeIndex(stop, start, step)\n        assert len(index) == 0",
        "begin_line": 996,
        "end_line": 1005,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.appends#1030",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.appends(self, request)",
        "snippet": "    def appends(self, request):\n        \"\"\"Inputs and expected outputs for RangeIndex.append test\"\"\"\n\n        return request.param",
        "begin_line": 1030,
        "end_line": 1033,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_append#1035",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_append(self, appends)",
        "snippet": "    def test_append(self, appends):\n        # GH16212\n\n        indices, expected = appends\n\n        result = indices[0].append(indices[1:])\n        tm.assert_index_equal(result, expected, exact=True)\n\n        if len(indices) == 2:\n            # Append single item rather than list\n            result2 = indices[0].append(indices[1])\n            tm.assert_index_equal(result2, expected, exact=True)",
        "begin_line": 1035,
        "end_line": 1046,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.test_range.TestRangeIndex.test_engineless_lookup#1048",
        "src_path": "pandas/tests/indexes/test_range.py",
        "class_name": "pandas.tests.indexes.test_range.TestRangeIndex",
        "signature": "pandas.tests.indexes.test_range.TestRangeIndex.test_engineless_lookup(self)",
        "snippet": "    def test_engineless_lookup(self):\n        # GH 16685\n        # Standard lookup on RangeIndex should not require the engine to be\n        # created\n        idx = RangeIndex(2, 10, 3)\n\n        assert idx.get_loc(5) == 1\n        tm.assert_numpy_array_equal(\n            idx.get_indexer([2, 8]), ensure_platform_int(np.array([0, 2]))\n        )\n        with pytest.raises(KeyError, match=\"3\"):\n            idx.get_loc(3)\n\n        assert \"_engine\" not in idx._cache\n\n        # The engine is still required for lookup of a different dtype scalar:\n        with pytest.raises(KeyError, match=\"'a'\"):\n            assert idx.get_loc(\"a\") == -1\n\n        assert \"_engine\" in idx._cache",
        "begin_line": 1048,
        "end_line": 1067,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_pickle_compat_construction#37",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_pickle_compat_construction(self)",
        "snippet": "    def test_pickle_compat_construction(self):\n        # need an object to create with\n        msg = (\n            r\"Index\\(\\.\\.\\.\\) must be called with a collection of some\"\n            r\" kind, None was passed|\"\n            r\"__new__\\(\\) missing 1 required positional argument: 'data'|\"\n            r\"__new__\\(\\) takes at least 2 arguments \\(1 given\\)\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            self._holder()",
        "begin_line": 37,
        "end_line": 46,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_series#48",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_series(self)",
        "snippet": "    def test_to_series(self):\n        # assert that we are creating a copy of the index\n\n        idx = self.create_index()\n        s = idx.to_series()\n        assert s.values is not idx.values\n        assert s.index is not idx\n        assert s.name == idx.name",
        "begin_line": 48,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_series_with_arguments#57",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_series_with_arguments(self)",
        "snippet": "    def test_to_series_with_arguments(self):\n        # GH18699\n\n        # index kwarg\n        idx = self.create_index()\n        s = idx.to_series(index=idx)\n\n        assert s.values is not idx.values\n        assert s.index is idx\n        assert s.name == idx.name\n\n        # name kwarg\n        idx = self.create_index()\n        s = idx.to_series(name=\"__test\")\n\n        assert s.values is not idx.values\n        assert s.index is not idx\n        assert s.name != idx.name",
        "begin_line": 57,
        "end_line": 74,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_to_frame#77",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_to_frame(self, name)",
        "snippet": "    def test_to_frame(self, name):\n        # see GH-15230, GH-22580\n        idx = self.create_index()\n\n        if name:\n            idx_name = name\n        else:\n            idx_name = idx.name or 0\n\n        df = idx.to_frame(name=idx_name)\n\n        assert df.index is idx\n        assert len(df.columns) == 1\n        assert df.columns[0] == idx_name\n        assert df[idx_name].values is not idx.values\n\n        df = idx.to_frame(index=False, name=idx_name)\n        assert df.index is not idx",
        "begin_line": 77,
        "end_line": 94,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_shift#96",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_shift(self)",
        "snippet": "    def test_shift(self):\n\n        # GH8083 test the base class for shift\n        idx = self.create_index()\n        msg = \"Not supported for type {}\".format(type(idx).__name__)\n        with pytest.raises(NotImplementedError, match=msg):\n            idx.shift(1)\n        with pytest.raises(NotImplementedError, match=msg):\n            idx.shift(1, 2)",
        "begin_line": 96,
        "end_line": 104,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_create_index_existing_name#106",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_create_index_existing_name(self)",
        "snippet": "    def test_create_index_existing_name(self):\n\n        # GH11193, when an existing index is passed, and a new name is not\n        # specified, the new index should inherit the previous object name\n        expected = self.create_index()\n        if not isinstance(expected, MultiIndex):\n            expected.name = \"foo\"\n            result = pd.Index(expected)\n            tm.assert_index_equal(result, expected)\n\n            result = pd.Index(expected, name=\"bar\")\n            expected.name = \"bar\"\n            tm.assert_index_equal(result, expected)\n        else:\n            expected.names = [\"foo\", \"bar\"]\n            result = pd.Index(expected)\n            tm.assert_index_equal(\n                result,\n                Index(\n                    Index(\n                        [\n                            (\"foo\", \"one\"),\n                            (\"foo\", \"two\"),\n                            (\"bar\", \"one\"),\n                            (\"baz\", \"two\"),\n                            (\"qux\", \"one\"),\n                            (\"qux\", \"two\"),\n                        ],\n                        dtype=\"object\",\n                    ),\n                    names=[\"foo\", \"bar\"],\n                ),\n            )\n\n            result = pd.Index(expected, names=[\"A\", \"B\"])\n            tm.assert_index_equal(\n                result,\n                Index(\n                    Index(\n                        [\n                            (\"foo\", \"one\"),\n                            (\"foo\", \"two\"),\n                            (\"bar\", \"one\"),\n                            (\"baz\", \"two\"),\n                            (\"qux\", \"one\"),\n                            (\"qux\", \"two\"),\n                        ],\n                        dtype=\"object\",\n                    ),\n                    names=[\"A\", \"B\"],\n                ),\n            )",
        "begin_line": 106,
        "end_line": 157,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numeric_compat#159",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numeric_compat(self)",
        "snippet": "    def test_numeric_compat(self):\n\n        idx = self.create_index()\n        with pytest.raises(TypeError, match=\"cannot perform __mul__\"):\n            idx * 1\n        with pytest.raises(TypeError, match=\"cannot perform __rmul__\"):\n            1 * idx\n\n        div_err = \"cannot perform __truediv__\"\n        with pytest.raises(TypeError, match=div_err):\n            idx / 1\n\n        div_err = div_err.replace(\" __\", \" __r\")\n        with pytest.raises(TypeError, match=div_err):\n            1 / idx\n        with pytest.raises(TypeError, match=\"cannot perform __floordiv__\"):\n            idx // 1\n        with pytest.raises(TypeError, match=\"cannot perform __rfloordiv__\"):\n            1 // idx",
        "begin_line": 159,
        "end_line": 177,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_logical_compat#179",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_logical_compat(self)",
        "snippet": "    def test_logical_compat(self):\n        idx = self.create_index()\n        with pytest.raises(TypeError, match=\"cannot perform all\"):\n            idx.all()\n        with pytest.raises(TypeError, match=\"cannot perform any\"):\n            idx.any()",
        "begin_line": 179,
        "end_line": 184,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_boolean_context_compat#186",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_boolean_context_compat(self)",
        "snippet": "    def test_boolean_context_compat(self):\n\n        # boolean context compat\n        idx = self.create_index()\n\n        with pytest.raises(ValueError, match=\"The truth value of a\"):\n            if idx:\n                pass",
        "begin_line": 186,
        "end_line": 193,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_reindex_base#195",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_reindex_base(self)",
        "snippet": "    def test_reindex_base(self):\n        idx = self.create_index()\n        expected = np.arange(idx.size, dtype=np.intp)\n\n        actual = idx.get_indexer(idx)\n        tm.assert_numpy_array_equal(expected, actual)\n\n        with pytest.raises(ValueError, match=\"Invalid fill method\"):\n            idx.get_indexer(idx, method=\"invalid\")",
        "begin_line": 195,
        "end_line": 203,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_get_indexer_consistency#205",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_get_indexer_consistency(self, indices)",
        "snippet": "    def test_get_indexer_consistency(self, indices):\n        # See GH 16819\n        if isinstance(indices, IntervalIndex):\n            return\n\n        if indices.is_unique or isinstance(indices, CategoricalIndex):\n            indexer = indices.get_indexer(indices[0:2])\n            assert isinstance(indexer, np.ndarray)\n            assert indexer.dtype == np.intp\n        else:\n            e = \"Reindexing only valid with uniquely valued Index objects\"\n            with pytest.raises(InvalidIndexError, match=e):\n                indices.get_indexer(indices[0:2])\n\n        indexer, _ = indices.get_indexer_non_unique(indices[0:2])\n        assert isinstance(indexer, np.ndarray)\n        assert indexer.dtype == np.intp",
        "begin_line": 205,
        "end_line": 221,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_ndarray_compat_properties#223",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_ndarray_compat_properties(self)",
        "snippet": "    def test_ndarray_compat_properties(self):\n        idx = self.create_index()\n        assert idx.T.equals(idx)\n        assert idx.transpose().equals(idx)\n\n        values = idx.values\n        for prop in self._compat_props:\n            assert getattr(idx, prop) == getattr(values, prop)\n\n        # test for validity\n        idx.nbytes\n        idx.values.nbytes",
        "begin_line": 223,
        "end_line": 234,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repr_roundtrip#236",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repr_roundtrip(self)",
        "snippet": "    def test_repr_roundtrip(self):\n\n        idx = self.create_index()\n        tm.assert_index_equal(eval(repr(idx)), idx)",
        "begin_line": 236,
        "end_line": 239,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_str#241",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_str(self)",
        "snippet": "    def test_str(self):\n\n        # test the string repr\n        idx = self.create_index()\n        idx.name = \"foo\"\n        assert \"'foo'\" in str(idx)\n        assert idx.__class__.__name__ in str(idx)",
        "begin_line": 241,
        "end_line": 247,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repr_max_seq_item_setting#249",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repr_max_seq_item_setting(self)",
        "snippet": "    def test_repr_max_seq_item_setting(self):\n        # GH10182\n        idx = self.create_index()\n        idx = idx.repeat(50)\n        with pd.option_context(\"display.max_seq_items\", None):\n            repr(idx)\n            assert \"...\" not in str(idx)",
        "begin_line": 249,
        "end_line": 255,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_copy_name#257",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_copy_name(self, indices)",
        "snippet": "    def test_copy_name(self, indices):\n        # gh-12309: Check that the \"name\" argument\n        # passed at initialization is honored.\n        if isinstance(indices, MultiIndex):\n            return\n\n        first = indices.__class__(indices, copy=True, name=\"mario\")\n        second = first.__class__(first, copy=False)\n\n        # Even though \"copy=False\", we want a new object.\n        assert first is not second\n\n        # Not using tm.assert_index_equal() since names differ.\n        assert indices.equals(first)\n\n        assert first.name == \"mario\"\n        assert second.name == \"mario\"\n\n        s1 = Series(2, index=first)\n        s2 = Series(3, index=second[:-1])\n\n        if not isinstance(indices, CategoricalIndex):\n            # See gh-13365\n            s3 = s1 * s2\n            assert s3.index.name == \"mario\"",
        "begin_line": 257,
        "end_line": 281,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_ensure_copied_data#283",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_ensure_copied_data(self, indices)",
        "snippet": "    def test_ensure_copied_data(self, indices):\n        # Check the \"copy\" argument of each Index.__new__ is honoured\n        # GH12309\n        init_kwargs = {}\n        if isinstance(indices, PeriodIndex):\n            # Needs \"freq\" specification:\n            init_kwargs[\"freq\"] = indices.freq\n        elif isinstance(indices, (RangeIndex, MultiIndex, CategoricalIndex)):\n            # RangeIndex cannot be initialized from data\n            # MultiIndex and CategoricalIndex are tested separately\n            return\n\n        index_type = indices.__class__\n        result = index_type(indices.values, copy=True, **init_kwargs)\n        tm.assert_index_equal(indices, result)\n        tm.assert_numpy_array_equal(\n            indices._ndarray_values, result._ndarray_values, check_same=\"copy\"\n        )\n\n        if isinstance(indices, PeriodIndex):\n            # .values an object array of Period, thus copied\n            result = index_type(ordinal=indices.asi8, copy=False, **init_kwargs)\n            tm.assert_numpy_array_equal(\n                indices._ndarray_values, result._ndarray_values, check_same=\"same\"\n            )\n        elif isinstance(indices, IntervalIndex):\n            # checked in test_interval.py\n            pass\n        else:\n            result = index_type(indices.values, copy=False, **init_kwargs)\n            tm.assert_numpy_array_equal(\n                indices.values, result.values, check_same=\"same\"\n            )\n            tm.assert_numpy_array_equal(\n                indices._ndarray_values, result._ndarray_values, check_same=\"same\"\n            )",
        "begin_line": 283,
        "end_line": 318,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_memory_usage#320",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_memory_usage(self, indices)",
        "snippet": "    def test_memory_usage(self, indices):\n        indices._engine.clear_mapping()\n        result = indices.memory_usage()\n        if indices.empty:\n            # we report 0 for no-length\n            assert result == 0\n            return\n\n        # non-zero length\n        indices.get_loc(indices[0])\n        result2 = indices.memory_usage()\n        result3 = indices.memory_usage(deep=True)\n\n        # RangeIndex, IntervalIndex\n        # don't have engines\n        if not isinstance(indices, (RangeIndex, IntervalIndex)):\n            assert result2 > result\n\n        if indices.inferred_type == \"object\":\n            assert result3 > result2",
        "begin_line": 320,
        "end_line": 339,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_argsort#341",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_argsort(self, request, indices)",
        "snippet": "    def test_argsort(self, request, indices):\n        # separately tested\n        if isinstance(indices, CategoricalIndex):\n            return\n\n        result = indices.argsort()\n        expected = np.array(indices).argsort()\n        tm.assert_numpy_array_equal(result, expected, check_dtype=False)",
        "begin_line": 341,
        "end_line": 348,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numpy_argsort#350",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numpy_argsort(self, indices)",
        "snippet": "    def test_numpy_argsort(self, indices):\n        result = np.argsort(indices)\n        expected = indices.argsort()\n        tm.assert_numpy_array_equal(result, expected)\n\n        # these are the only two types that perform\n        # pandas compatibility input validation - the\n        # rest already perform separate (or no) such\n        # validation via their 'values' attribute as\n        # defined in pandas.core.indexes/base.py - they\n        # cannot be changed at the moment due to\n        # backwards compatibility concerns\n        if isinstance(type(indices), (CategoricalIndex, RangeIndex)):\n            msg = \"the 'axis' parameter is not supported\"\n            with pytest.raises(ValueError, match=msg):\n                np.argsort(indices, axis=1)\n\n            msg = \"the 'kind' parameter is not supported\"\n            with pytest.raises(ValueError, match=msg):\n                np.argsort(indices, kind=\"mergesort\")\n\n            msg = \"the 'order' parameter is not supported\"\n            with pytest.raises(ValueError, match=msg):\n                np.argsort(indices, order=(\"a\", \"b\"))",
        "begin_line": 350,
        "end_line": 373,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_take#375",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_take(self, indices)",
        "snippet": "    def test_take(self, indices):\n        indexer = [4, 3, 0, 2]\n        if len(indices) < 5:\n            # not enough elements; ignore\n            return\n\n        result = indices.take(indexer)\n        expected = indices[indexer]\n        assert result.equals(expected)\n\n        if not isinstance(indices, (DatetimeIndex, PeriodIndex, TimedeltaIndex)):\n            # GH 10791\n            with pytest.raises(AttributeError):\n                indices.freq",
        "begin_line": 375,
        "end_line": 388,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_take_invalid_kwargs#390",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_take_invalid_kwargs(self)",
        "snippet": "    def test_take_invalid_kwargs(self):\n        idx = self.create_index()\n        indices = [1, 2]\n\n        msg = r\"take\\(\\) got an unexpected keyword argument 'foo'\"\n        with pytest.raises(TypeError, match=msg):\n            idx.take(indices, foo=2)\n\n        msg = \"the 'out' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            idx.take(indices, out=indices)\n\n        msg = \"the 'mode' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            idx.take(indices, mode=\"clip\")",
        "begin_line": 390,
        "end_line": 404,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_repeat#406",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_repeat(self)",
        "snippet": "    def test_repeat(self):\n        rep = 2\n        i = self.create_index()\n        expected = pd.Index(i.values.repeat(rep), name=i.name)\n        tm.assert_index_equal(i.repeat(rep), expected)\n\n        i = self.create_index()\n        rep = np.arange(len(i))\n        expected = pd.Index(i.values.repeat(rep), name=i.name)\n        tm.assert_index_equal(i.repeat(rep), expected)",
        "begin_line": 406,
        "end_line": 415,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_numpy_repeat#417",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_numpy_repeat(self)",
        "snippet": "    def test_numpy_repeat(self):\n        rep = 2\n        i = self.create_index()\n        expected = i.repeat(rep)\n        tm.assert_index_equal(np.repeat(i, rep), expected)\n\n        msg = \"the 'axis' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            np.repeat(i, rep, axis=0)",
        "begin_line": 417,
        "end_line": 425,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_where#428",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_where(self, klass)",
        "snippet": "    def test_where(self, klass):\n        i = self.create_index()\n\n        cond = [True] * len(i)\n        result = i.where(klass(cond))\n        expected = i\n        tm.assert_index_equal(result, expected)\n\n        cond = [False] + [True] * len(i[1:])\n        expected = pd.Index([i._na_value] + i[1:].tolist(), dtype=i.dtype)\n        result = i.where(klass(cond))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 428,
        "end_line": 439,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_set_ops_error_cases#445",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_set_ops_error_cases(self, case, method, indices)",
        "snippet": "    def test_set_ops_error_cases(self, case, method, indices):\n        # non-iterable input\n        msg = \"Input must be Index or array-like\"\n        with pytest.raises(TypeError, match=msg):\n            getattr(indices, method)(case)",
        "begin_line": 445,
        "end_line": 449,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_intersection_base#451",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_intersection_base(self, indices)",
        "snippet": "    def test_intersection_base(self, indices):\n        if isinstance(indices, CategoricalIndex):\n            return\n\n        first = indices[:5]\n        second = indices[:3]\n        intersect = first.intersection(second)\n        assert tm.equalContents(intersect, second)\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            result = first.intersection(case)\n            assert tm.equalContents(result, second)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.intersection([1, 2, 3])",
        "begin_line": 451,
        "end_line": 469,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_union_base#471",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_union_base(self, indices)",
        "snippet": "    def test_union_base(self, indices):\n        first = indices[3:]\n        second = indices[:5]\n        everything = indices\n        union = first.union(second)\n        assert tm.equalContents(union, everything)\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            if not isinstance(indices, CategoricalIndex):\n                result = first.union(case)\n                assert tm.equalContents(result, everything)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.union([1, 2, 3])",
        "begin_line": 471,
        "end_line": 488,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_difference_base#491",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_difference_base(self, sort, indices)",
        "snippet": "    def test_difference_base(self, sort, indices):\n        if isinstance(indices, CategoricalIndex):\n            return\n\n        first = indices[2:]\n        second = indices[:4]\n        answer = indices[4:]\n        result = first.difference(second, sort)\n        assert tm.equalContents(result, answer)\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            if isinstance(indices, (DatetimeIndex, TimedeltaIndex)):\n                assert result.__class__ == answer.__class__\n                tm.assert_numpy_array_equal(\n                    result.sort_values().asi8, answer.sort_values().asi8\n                )\n            else:\n                result = first.difference(case, sort)\n                assert tm.equalContents(result, answer)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.difference([1, 2, 3], sort)",
        "begin_line": 491,
        "end_line": 516,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_symmetric_difference#518",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_symmetric_difference(self, indices)",
        "snippet": "    def test_symmetric_difference(self, indices):\n        if isinstance(indices, CategoricalIndex):\n            return\n\n        first = indices[1:]\n        second = indices[:-1]\n        answer = indices[[0, -1]]\n        result = first.symmetric_difference(second)\n        assert tm.equalContents(result, answer)\n\n        # GH 10149\n        cases = [klass(second.values) for klass in [np.array, Series, list]]\n        for case in cases:\n            result = first.symmetric_difference(case)\n            assert tm.equalContents(result, answer)\n\n        if isinstance(indices, MultiIndex):\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            with pytest.raises(TypeError, match=msg):\n                first.symmetric_difference([1, 2, 3])",
        "begin_line": 518,
        "end_line": 537,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_insert_base#539",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_insert_base(self, indices)",
        "snippet": "    def test_insert_base(self, indices):\n        result = indices[1:4]\n\n        if not len(indices):\n            return\n\n        # test 0th element\n        assert indices[0:4].equals(result.insert(0, indices[0]))",
        "begin_line": 539,
        "end_line": 546,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_delete_base#548",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_delete_base(self, indices)",
        "snippet": "    def test_delete_base(self, indices):\n        if not len(indices):\n            return\n\n        if isinstance(indices, RangeIndex):\n            # tested in class\n            return\n\n        expected = indices[1:]\n        result = indices.delete(0)\n        assert result.equals(expected)\n        assert result.name == expected.name\n\n        expected = indices[:-1]\n        result = indices.delete(-1)\n        assert result.equals(expected)\n        assert result.name == expected.name\n\n        with pytest.raises((IndexError, ValueError)):\n            # either depending on numpy version\n            indices.delete(len(indices))",
        "begin_line": 548,
        "end_line": 568,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_equals#570",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_equals(self, indices)",
        "snippet": "    def test_equals(self, indices):\n        if isinstance(indices, IntervalIndex):\n            # IntervalIndex tested separately\n            return\n\n        assert indices.equals(indices)\n        assert indices.equals(indices.copy())\n        assert indices.equals(indices.astype(object))\n\n        assert not indices.equals(list(indices))\n        assert not indices.equals(np.array(indices))\n\n        # Cannot pass in non-int64 dtype to RangeIndex\n        if not isinstance(indices, RangeIndex):\n            same_values = Index(indices, dtype=object)\n            assert indices.equals(same_values)\n            assert same_values.equals(indices)\n\n        if indices.nlevels == 1:\n            # do not test MultiIndex\n            assert not indices.equals(Series(indices))",
        "begin_line": 570,
        "end_line": 590,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_equals_op#592",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_equals_op(self)",
        "snippet": "    def test_equals_op(self):\n        # GH9947, GH10637\n        index_a = self.create_index()\n        if isinstance(index_a, PeriodIndex):\n            pytest.skip(\"Skip check for PeriodIndex\")\n\n        n = len(index_a)\n        index_b = index_a[0:-1]\n        index_c = index_a[0:-1].append(index_a[-2:-1])\n        index_d = index_a[0:1]\n\n        msg = \"Lengths must match|could not be broadcast\"\n        with pytest.raises(ValueError, match=msg):\n            index_a == index_b\n        expected1 = np.array([True] * n)\n        expected2 = np.array([True] * (n - 1) + [False])\n        tm.assert_numpy_array_equal(index_a == index_a, expected1)\n        tm.assert_numpy_array_equal(index_a == index_c, expected2)\n\n        # test comparisons with numpy arrays\n        array_a = np.array(index_a)\n        array_b = np.array(index_a[0:-1])\n        array_c = np.array(index_a[0:-1].append(index_a[-2:-1]))\n        array_d = np.array(index_a[0:1])\n        with pytest.raises(ValueError, match=msg):\n            index_a == array_b\n        tm.assert_numpy_array_equal(index_a == array_a, expected1)\n        tm.assert_numpy_array_equal(index_a == array_c, expected2)\n\n        # test comparisons with Series\n        series_a = Series(array_a)\n        series_b = Series(array_b)\n        series_c = Series(array_c)\n        series_d = Series(array_d)\n        with pytest.raises(ValueError, match=msg):\n            index_a == series_b\n\n        tm.assert_numpy_array_equal(index_a == series_a, expected1)\n        tm.assert_numpy_array_equal(index_a == series_c, expected2)\n\n        # cases where length is 1 for one of them\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == index_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == series_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            index_a == array_d\n        msg = \"Can only compare identically-labeled Series objects\"\n        with pytest.raises(ValueError, match=msg):\n            series_a == series_d\n        with pytest.raises(ValueError, match=\"Lengths must match\"):\n            series_a == array_d\n\n        # comparing with a scalar should broadcast; note that we are excluding\n        # MultiIndex because in this case each item in the index is a tuple of\n        # length 2, and therefore is considered an array of length 2 in the\n        # comparison instead of a scalar\n        if not isinstance(index_a, MultiIndex):\n            expected3 = np.array([False] * (len(index_a) - 2) + [True, False])\n            # assuming the 2nd to last item is unique in the data\n            item = index_a[-2]\n            tm.assert_numpy_array_equal(index_a == item, expected3)\n            tm.assert_series_equal(series_a == item, Series(expected3))",
        "begin_line": 592,
        "end_line": 654,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_hasnans_isnans#656",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_hasnans_isnans(self, indices)",
        "snippet": "    def test_hasnans_isnans(self, indices):\n        # GH 11343, added tests for hasnans / isnans\n        if isinstance(indices, MultiIndex):\n            return\n\n        # cases in indices doesn't include NaN\n        idx = indices.copy(deep=True)\n        expected = np.array([False] * len(idx), dtype=bool)\n        tm.assert_numpy_array_equal(idx._isnan, expected)\n        assert idx.hasnans is False\n\n        idx = indices.copy(deep=True)\n        values = np.asarray(idx.values)\n\n        if len(indices) == 0:\n            return\n        elif isinstance(indices, DatetimeIndexOpsMixin):\n            values[1] = iNaT\n        elif isinstance(indices, (Int64Index, UInt64Index)):\n            return\n        else:\n            values[1] = np.nan\n\n        if isinstance(indices, PeriodIndex):\n            idx = indices.__class__(values, freq=indices.freq)\n        else:\n            idx = indices.__class__(values)\n\n            expected = np.array([False] * len(idx), dtype=bool)\n            expected[1] = True\n            tm.assert_numpy_array_equal(idx._isnan, expected)\n            assert idx.hasnans is True",
        "begin_line": 656,
        "end_line": 687,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_fillna#689",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_fillna(self, indices)",
        "snippet": "    def test_fillna(self, indices):\n        # GH 11343\n        if len(indices) == 0:\n            pass\n        elif isinstance(indices, MultiIndex):\n            idx = indices.copy(deep=True)\n            msg = \"isna is not defined for MultiIndex\"\n            with pytest.raises(NotImplementedError, match=msg):\n                idx.fillna(idx[0])\n        else:\n            idx = indices.copy(deep=True)\n            result = idx.fillna(idx[0])\n            tm.assert_index_equal(result, idx)\n            assert result is not idx\n\n            msg = \"'value' must be a scalar, passed: \"\n            with pytest.raises(TypeError, match=msg):\n                idx.fillna([idx[0]])\n\n            idx = indices.copy(deep=True)\n            values = np.asarray(idx.values)\n\n            if isinstance(indices, DatetimeIndexOpsMixin):\n                values[1] = iNaT\n            elif isinstance(indices, (Int64Index, UInt64Index)):\n                return\n            else:\n                values[1] = np.nan\n\n            if isinstance(indices, PeriodIndex):\n                idx = indices.__class__(values, freq=indices.freq)\n            else:\n                idx = indices.__class__(values)\n\n            expected = np.array([False] * len(idx), dtype=bool)\n            expected[1] = True\n            tm.assert_numpy_array_equal(idx._isnan, expected)\n            assert idx.hasnans is True",
        "begin_line": 689,
        "end_line": 726,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_nulls#728",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_nulls(self, indices)",
        "snippet": "    def test_nulls(self, indices):\n        # this is really a smoke test for the methods\n        # as these are adequately tested for function elsewhere\n        if len(indices) == 0:\n            tm.assert_numpy_array_equal(indices.isna(), np.array([], dtype=bool))\n        elif isinstance(indices, MultiIndex):\n            idx = indices.copy()\n            msg = \"isna is not defined for MultiIndex\"\n            with pytest.raises(NotImplementedError, match=msg):\n                idx.isna()\n        elif not indices.hasnans:\n            tm.assert_numpy_array_equal(\n                indices.isna(), np.zeros(len(indices), dtype=bool)\n            )\n            tm.assert_numpy_array_equal(\n                indices.notna(), np.ones(len(indices), dtype=bool)\n            )\n        else:\n            result = isna(indices)\n            tm.assert_numpy_array_equal(indices.isna(), result)\n            tm.assert_numpy_array_equal(indices.notna(), ~result)",
        "begin_line": 728,
        "end_line": 748,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_empty#750",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_empty(self)",
        "snippet": "    def test_empty(self):\n        # GH 15270\n        index = self.create_index()\n        assert not index.empty\n        assert index[:0].empty",
        "begin_line": 750,
        "end_line": 754,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_join_self_unique#756",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_join_self_unique(self, join_type)",
        "snippet": "    def test_join_self_unique(self, join_type):\n        index = self.create_index()\n        if index.is_unique:\n            joined = index.join(index, how=join_type)\n            assert (index == joined).all()",
        "begin_line": 756,
        "end_line": 760,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_map#762",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_map(self)",
        "snippet": "    def test_map(self):\n        # callable\n        index = self.create_index()\n\n        # we don't infer UInt64\n        if isinstance(index, pd.UInt64Index):\n            expected = index.astype(\"int64\")\n        else:\n            expected = index\n\n        result = index.map(lambda x: x)\n        tm.assert_index_equal(result, expected)",
        "begin_line": 762,
        "end_line": 773,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_map_dictlike#782",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_map_dictlike(self, mapper)",
        "snippet": "    def test_map_dictlike(self, mapper):\n\n        index = self.create_index()\n        if isinstance(index, (pd.CategoricalIndex, pd.IntervalIndex)):\n            pytest.skip(\"skipping tests for {}\".format(type(index)))\n\n        identity = mapper(index.values, index)\n\n        # we don't infer to UInt64 for a dict\n        if isinstance(index, pd.UInt64Index) and isinstance(identity, dict):\n            expected = index.astype(\"int64\")\n        else:\n            expected = index\n\n        result = index.map(identity)\n        tm.assert_index_equal(result, expected)\n\n        # empty mappable\n        expected = pd.Index([np.nan] * len(index))\n        result = index.map(mapper(expected, index))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 782,
        "end_line": 802,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_putmask_with_wrong_mask#804",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_putmask_with_wrong_mask(self)",
        "snippet": "    def test_putmask_with_wrong_mask(self):\n        # GH18368\n        index = self.create_index()\n\n        with pytest.raises(ValueError):\n            index.putmask(np.ones(len(index) + 1, np.bool), 1)\n\n        with pytest.raises(ValueError):\n            index.putmask(np.ones(len(index) - 1, np.bool), 1)\n\n        with pytest.raises(ValueError):\n            index.putmask(\"foo\", 1)",
        "begin_line": 804,
        "end_line": 815,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_astype_category#820",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_astype_category(self, copy, name, ordered)",
        "snippet": "    def test_astype_category(self, copy, name, ordered):\n        # GH 18630\n        index = self.create_index()\n        if name:\n            index = index.rename(name)\n\n        # standard categories\n        dtype = CategoricalDtype(ordered=ordered)\n        result = index.astype(dtype, copy=copy)\n        expected = CategoricalIndex(index.values, name=name, ordered=ordered)\n        tm.assert_index_equal(result, expected)\n\n        # non-standard categories\n        dtype = CategoricalDtype(index.unique().tolist()[:-1], ordered)\n        result = index.astype(dtype, copy=copy)\n        expected = CategoricalIndex(index.values, name=name, dtype=dtype)\n        tm.assert_index_equal(result, expected)\n\n        if ordered is False:\n            # dtype='category' defaults to ordered=False, so only test once\n            result = index.astype(\"category\", copy=copy)\n            expected = CategoricalIndex(index.values, name=name)\n            tm.assert_index_equal(result, expected)",
        "begin_line": 820,
        "end_line": 842,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_is_unique#844",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_is_unique(self)",
        "snippet": "    def test_is_unique(self):\n        # initialize a unique index\n        index = self.create_index().drop_duplicates()\n        assert index.is_unique is True\n\n        # empty index should be unique\n        index_empty = index[:0]\n        assert index_empty.is_unique is True\n\n        # test basic dupes\n        index_dup = index.insert(0, index[0])\n        assert index_dup.is_unique is False\n\n        # single NA should be unique\n        index_na = index.insert(0, np.nan)\n        assert index_na.is_unique is True\n\n        # multiple NA should not be unique\n        index_na_dup = index_na.insert(0, np.nan)\n        assert index_na_dup.is_unique is False",
        "begin_line": 844,
        "end_line": 863,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.common.Base.test_engine_reference_cycle#865",
        "src_path": "pandas/tests/indexes/common.py",
        "class_name": "pandas.tests.indexes.common.Base",
        "signature": "pandas.tests.indexes.common.Base.test_engine_reference_cycle(self)",
        "snippet": "    def test_engine_reference_cycle(self):\n        # GH27585\n        index = self.create_index()\n        nrefs_pre = len(gc.get_referrers(index))\n        index._engine\n        assert len(gc.get_referrers(index)) == nrefs_pre",
        "begin_line": 865,
        "end_line": 870,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.idx#9",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.idx()",
        "snippet": "def idx():\n    # a MultiIndex used to test the general functionality of the\n    # general functionality of this object\n    major_axis = Index([\"foo\", \"bar\", \"baz\", \"qux\"])\n    minor_axis = Index([\"one\", \"two\"])\n\n    major_codes = np.array([0, 0, 1, 2, 3, 3])\n    minor_codes = np.array([0, 1, 0, 1, 0, 1])\n    index_names = [\"first\", \"second\"]\n    mi = MultiIndex(\n        levels=[major_axis, minor_axis],\n        codes=[major_codes, minor_codes],\n        names=index_names,\n        verify_integrity=False,\n    )\n    return mi",
        "begin_line": 9,
        "end_line": 24,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.idx_dup#28",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.idx_dup()",
        "snippet": "def idx_dup():\n    # compare tests/indexes/multi/conftest.py\n    major_axis = Index([\"foo\", \"bar\", \"baz\", \"qux\"])\n    minor_axis = Index([\"one\", \"two\"])\n\n    major_codes = np.array([0, 0, 1, 0, 1, 1])\n    minor_codes = np.array([0, 1, 0, 1, 0, 1])\n    index_names = [\"first\", \"second\"]\n    mi = MultiIndex(\n        levels=[major_axis, minor_axis],\n        codes=[major_codes, minor_codes],\n        names=index_names,\n        verify_integrity=False,\n    )\n    return mi",
        "begin_line": 28,
        "end_line": 42,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.index_names#46",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.index_names()",
        "snippet": "def index_names():\n    # names that match those in the idx fixture for testing equality of\n    # names assigned to the idx\n    return [\"first\", \"second\"]",
        "begin_line": 46,
        "end_line": 49,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.holder#53",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.holder()",
        "snippet": "def holder():\n    # the MultiIndex constructor used to base compatibility with pickle\n    return MultiIndex",
        "begin_line": 53,
        "end_line": 55,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.compat_props#59",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.compat_props()",
        "snippet": "def compat_props():\n    # a MultiIndex must have these properties associated with it\n    return [\"shape\", \"ndim\", \"size\"]",
        "begin_line": 59,
        "end_line": 61,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.narrow_multi_index#65",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.narrow_multi_index()",
        "snippet": "def narrow_multi_index():\n    \"\"\"\n    Return a MultiIndex that is narrower than the display (<80 characters).\n    \"\"\"\n    n = 1000\n    ci = pd.CategoricalIndex(list(\"a\" * n) + ([\"abc\"] * n))\n    dti = pd.date_range(\"2000-01-01\", freq=\"s\", periods=n * 2)\n    return pd.MultiIndex.from_arrays([ci, ci.codes + 9, dti], names=[\"a\", \"b\", \"dti\"])",
        "begin_line": 65,
        "end_line": 72,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.multi.conftest.wide_multi_index#76",
        "src_path": "pandas/tests/indexes/multi/conftest.py",
        "class_name": "pandas.tests.indexes.multi.conftest",
        "signature": "pandas.tests.indexes.multi.conftest.wide_multi_index()",
        "snippet": "def wide_multi_index():\n    \"\"\"\n    Return a MultiIndex that is wider than the display (>80 characters).\n    \"\"\"\n    n = 1000\n    ci = pd.CategoricalIndex(list(\"a\" * n) + ([\"abc\"] * n))\n    dti = pd.date_range(\"2000-01-01\", freq=\"s\", periods=n * 2)\n    levels = [ci, ci.codes + 9, dti, dti, dti]\n    names = [\"a\", \"b\", \"dti_1\", \"dti_2\", \"dti_3\"]\n    return pd.MultiIndex.from_arrays(levels, names=names)",
        "begin_line": 76,
        "end_line": 85,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_argmax_axis_invalid#12",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_argmax_axis_invalid(self)",
        "snippet": "    def test_argmax_axis_invalid(self):\n        # GH#23081\n        rng = self.create_index()\n        with pytest.raises(ValueError):\n            rng.argmax(axis=1)\n        with pytest.raises(ValueError):\n            rng.argmin(axis=2)\n        with pytest.raises(ValueError):\n            rng.min(axis=-2)\n        with pytest.raises(ValueError):\n            rng.max(axis=-3)",
        "begin_line": 12,
        "end_line": 22,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_can_hold_identifiers#24",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_can_hold_identifiers(self)",
        "snippet": "    def test_can_hold_identifiers(self):\n        idx = self.create_index()\n        key = idx[0]\n        assert idx._can_hold_identifiers_and_holds_name(key) is False",
        "begin_line": 24,
        "end_line": 27,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_shift_identity#29",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_shift_identity(self)",
        "snippet": "    def test_shift_identity(self):\n\n        idx = self.create_index()\n        tm.assert_index_equal(idx, idx.shift(0))",
        "begin_line": 29,
        "end_line": 32,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_str#34",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_str(self)",
        "snippet": "    def test_str(self):\n\n        # test the string repr\n        idx = self.create_index()\n        idx.name = \"foo\"\n        assert not \"length={}\".format(len(idx)) in str(idx)\n        assert \"'foo'\" in str(idx)\n        assert idx.__class__.__name__ in str(idx)\n\n        if hasattr(idx, \"tz\"):\n            if idx.tz is not None:\n                assert idx.tz in str(idx)\n        if hasattr(idx, \"freq\"):\n            assert \"freq='{idx.freqstr}'\".format(idx=idx) in str(idx)",
        "begin_line": 34,
        "end_line": 47,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_view#49",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_view(self)",
        "snippet": "    def test_view(self):\n        i = self.create_index()\n\n        i_view = i.view(\"i8\")\n        result = self._holder(i)\n        tm.assert_index_equal(result, i)\n\n        i_view = i.view(self._holder)\n        result = self._holder(i)\n        tm.assert_index_equal(result, i_view)",
        "begin_line": 49,
        "end_line": 58,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_callable#60",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_callable(self)",
        "snippet": "    def test_map_callable(self):\n        index = self.create_index()\n        expected = index + index.freq\n        result = index.map(lambda x: x + x.freq)\n        tm.assert_index_equal(result, expected)\n\n        # map to NaT\n        result = index.map(lambda x: pd.NaT if x == index[0] else x)\n        expected = pd.Index([pd.NaT] + index[1:].tolist())\n        tm.assert_index_equal(result, expected)",
        "begin_line": 60,
        "end_line": 69,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_dictlike#78",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_map_dictlike(self, mapper)",
        "snippet": "    def test_map_dictlike(self, mapper):\n        index = self.create_index()\n        expected = index + index.freq\n\n        # don't compare the freqs\n        if isinstance(expected, pd.DatetimeIndex):\n            expected.freq = None\n\n        result = index.map(mapper(expected, index))\n        tm.assert_index_equal(result, expected)\n\n        expected = pd.Index([pd.NaT] + index[1:].tolist())\n        result = index.map(mapper(expected, index))\n        tm.assert_index_equal(result, expected)\n\n        # empty map; these map to np.nan because we cannot know\n        # to re-infer things\n        expected = pd.Index([np.nan] * len(index))\n        result = index.map(mapper([], []))\n        tm.assert_index_equal(result, expected)",
        "begin_line": 78,
        "end_line": 97,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "pandas.tests.indexes.datetimelike.DatetimeLike.test_asobject_deprecated#99",
        "src_path": "pandas/tests/indexes/datetimelike.py",
        "class_name": "pandas.tests.indexes.datetimelike.DatetimeLike",
        "signature": "pandas.tests.indexes.datetimelike.DatetimeLike.test_asobject_deprecated(self)",
        "snippet": "    def test_asobject_deprecated(self):\n        # GH18572\n        d = self.create_index()\n        with tm.assert_produces_warning(FutureWarning):\n            i = d.asobject\n        assert isinstance(i, pd.Index)",
        "begin_line": 99,
        "end_line": 104,
        "comment": "",
        "is_bug": false
    }
]