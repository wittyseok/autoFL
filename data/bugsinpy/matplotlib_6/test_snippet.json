[
    {
        "name": "lib.matplotlib.tests.test_axes.test_get_labels#42",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_get_labels()",
        "snippet": "def test_get_labels():\n    fig, ax = plt.subplots()\n    ax.set_xlabel('x label')\n    ax.set_ylabel('y label')\n    assert ax.get_xlabel() == 'x label'\n    assert ax.get_ylabel() == 'y label'",
        "begin_line": 42,
        "end_line": 47,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_label_loc_vertical#51",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_label_loc_vertical(fig_test, fig_ref)",
        "snippet": "def test_label_loc_vertical(fig_test, fig_ref):\n    ax = fig_test.subplots()\n    sc = ax.scatter([1, 2], [1, 2], c=[1, 2])\n    ax.set_ylabel('Y Label', loc='top')\n    ax.set_xlabel('X Label', loc='right')\n    cbar = fig_test.colorbar(sc)\n    cbar.set_label(\"Z Label\", loc='top')\n\n    ax = fig_ref.subplots()\n    sc = ax.scatter([1, 2], [1, 2], c=[1, 2])\n    ax.set_ylabel('Y Label', y=1, ha='right')\n    ax.set_xlabel('X Label', x=1, ha='right')\n    cbar = fig_ref.colorbar(sc)\n    cbar.set_label(\"Z Label\", y=1, ha='right')",
        "begin_line": 51,
        "end_line": 64,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_label_loc_horizontal#68",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_label_loc_horizontal(fig_test, fig_ref)",
        "snippet": "def test_label_loc_horizontal(fig_test, fig_ref):\n    ax = fig_test.subplots()\n    sc = ax.scatter([1, 2], [1, 2], c=[1, 2])\n    ax.set_ylabel('Y Label', loc='bottom')\n    ax.set_xlabel('X Label', loc='left')\n    cbar = fig_test.colorbar(sc, orientation='horizontal')\n    cbar.set_label(\"Z Label\", loc='left')\n\n    ax = fig_ref.subplots()\n    sc = ax.scatter([1, 2], [1, 2], c=[1, 2])\n    ax.set_ylabel('Y Label', y=0, ha='left')\n    ax.set_xlabel('X Label', x=0, ha='left')\n    cbar = fig_ref.colorbar(sc, orientation='horizontal')\n    cbar.set_label(\"Z Label\", x=0, ha='left')",
        "begin_line": 68,
        "end_line": 81,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_label_loc_rc#85",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_label_loc_rc(fig_test, fig_ref)",
        "snippet": "def test_label_loc_rc(fig_test, fig_ref):\n    with matplotlib.rc_context({\"xaxis.labellocation\": \"right\",\n                                \"yaxis.labellocation\": \"top\"}):\n        ax = fig_test.subplots()\n        sc = ax.scatter([1, 2], [1, 2], c=[1, 2])\n        ax.set_ylabel('Y Label')\n        ax.set_xlabel('X Label')\n        cbar = fig_test.colorbar(sc, orientation='horizontal')\n        cbar.set_label(\"Z Label\")\n\n    ax = fig_ref.subplots()\n    sc = ax.scatter([1, 2], [1, 2], c=[1, 2])\n    ax.set_ylabel('Y Label', y=1, ha='right')\n    ax.set_xlabel('X Label', x=1, ha='right')\n    cbar = fig_ref.colorbar(sc, orientation='horizontal')\n    cbar.set_label(\"Z Label\", x=1, ha='right')",
        "begin_line": 85,
        "end_line": 100,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_acorr#104",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_acorr(fig_test, fig_ref)",
        "snippet": "def test_acorr(fig_test, fig_ref):\n    np.random.seed(19680801)\n    Nx = 512\n    x = np.random.normal(0, 1, Nx).cumsum()\n    maxlags = Nx-1\n\n    fig_test, ax_test = plt.subplots()\n    ax_test.acorr(x, maxlags=maxlags)\n\n    fig_ref, ax_ref = plt.subplots()\n    # Normalized autocorrelation\n    norm_auto_corr = np.correlate(x, x, mode=\"full\")/np.dot(x, x)\n    lags = np.arange(-maxlags, maxlags+1)\n    norm_auto_corr = norm_auto_corr[Nx-1-maxlags:Nx+maxlags]\n    ax_ref.vlines(lags, [0], norm_auto_corr)\n    ax_ref.axhline(y=0, xmin=0, xmax=1)",
        "begin_line": 104,
        "end_line": 119,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_spy#123",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_spy(fig_test, fig_ref)",
        "snippet": "def test_spy(fig_test, fig_ref):\n    np.random.seed(19680801)\n    a = np.ones(32 * 32)\n    a[:16 * 32] = 0\n    np.random.shuffle(a)\n    a = a.reshape((32, 32))\n\n    axs_test = fig_test.subplots(2)\n    axs_test[0].spy(a)\n    axs_test[1].spy(a, marker=\".\", origin=\"lower\")\n\n    axs_ref = fig_ref.subplots(2)\n    axs_ref[0].imshow(a, cmap=\"gray_r\", interpolation=\"nearest\")\n    axs_ref[0].xaxis.tick_top()\n    axs_ref[1].plot(*np.nonzero(a)[::-1], \".\", markersize=10)\n    axs_ref[1].set(\n        aspect=1, xlim=axs_ref[0].get_xlim(), ylim=axs_ref[0].get_ylim()[::-1])\n    for ax in axs_ref:\n        ax.xaxis.set_ticks_position(\"both\")",
        "begin_line": 123,
        "end_line": 141,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_spy_invalid_kwargs#144",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_spy_invalid_kwargs()",
        "snippet": "def test_spy_invalid_kwargs():\n    fig, ax = plt.subplots()\n    for unsupported_kw in [{'interpolation': 'nearest'},\n                           {'marker': 'o', 'linestyle': 'solid'}]:\n        with pytest.raises(TypeError):\n            ax.spy(np.eye(3, 3), **unsupported_kw)",
        "begin_line": 144,
        "end_line": 149,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_matshow#153",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_matshow(fig_test, fig_ref)",
        "snippet": "def test_matshow(fig_test, fig_ref):\n    mpl.style.use(\"mpl20\")\n    a = np.random.rand(32, 32)\n    fig_test.add_subplot().matshow(a)\n    ax_ref = fig_ref.add_subplot()\n    ax_ref.imshow(a)\n    ax_ref.xaxis.tick_top()\n    ax_ref.xaxis.set_ticks_position('both')",
        "begin_line": 153,
        "end_line": 160,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_formatter_ticker#169",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_formatter_ticker()",
        "snippet": "def test_formatter_ticker():\n    import matplotlib.testing.jpl_units as units\n    units.register()\n\n    # This should affect the tick size.  (Tests issue #543)\n    matplotlib.rcParams['lines.markeredgewidth'] = 30\n\n    # This essentially test to see if user specified labels get overwritten\n    # by the auto labeler functionality of the axes.\n    xdata = [x*units.sec for x in range(10)]\n    ydata1 = [(1.5*y - 0.5)*units.km for y in range(10)]\n    ydata2 = [(1.75*y - 1.0)*units.km for y in range(10)]\n\n    ax = plt.figure().subplots()\n    ax.set_xlabel(\"x-label 001\")\n\n    ax = plt.figure().subplots()\n    ax.set_xlabel(\"x-label 001\")\n    ax.plot(xdata, ydata1, color='blue', xunits=\"sec\")\n\n    ax = plt.figure().subplots()\n    ax.set_xlabel(\"x-label 001\")\n    ax.plot(xdata, ydata1, color='blue', xunits=\"sec\")\n    ax.set_xlabel(\"x-label 003\")\n\n    ax = plt.figure().subplots()\n    ax.plot(xdata, ydata1, color='blue', xunits=\"sec\")\n    ax.plot(xdata, ydata2, color='green', xunits=\"hour\")\n    ax.set_xlabel(\"x-label 004\")\n\n    # See SF bug 2846058\n    # https://sourceforge.net/tracker/?func=detail&aid=2846058&group_id=80706&atid=560720\n    ax = plt.figure().subplots()\n    ax.plot(xdata, ydata1, color='blue', xunits=\"sec\")\n    ax.plot(xdata, ydata2, color='green', xunits=\"hour\")\n    ax.set_xlabel(\"x-label 005\")\n    ax.autoscale_view()",
        "begin_line": 169,
        "end_line": 205,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_funcformatter_auto_formatter#208",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_funcformatter_auto_formatter()",
        "snippet": "def test_funcformatter_auto_formatter():\n    def _formfunc(x, pos):\n        return ''\n\n    ax = plt.figure().subplots()\n\n    assert ax.xaxis.isDefault_majfmt\n    assert ax.xaxis.isDefault_minfmt\n    assert ax.yaxis.isDefault_majfmt\n    assert ax.yaxis.isDefault_minfmt\n\n    ax.xaxis.set_major_formatter(_formfunc)\n\n    assert not ax.xaxis.isDefault_majfmt\n    assert ax.xaxis.isDefault_minfmt\n    assert ax.yaxis.isDefault_majfmt\n    assert ax.yaxis.isDefault_minfmt\n\n    targ_funcformatter = mticker.FuncFormatter(_formfunc)\n\n    assert isinstance(ax.xaxis.get_major_formatter(),\n                      mticker.FuncFormatter)\n\n    assert ax.xaxis.get_major_formatter().func == targ_funcformatter.func",
        "begin_line": 208,
        "end_line": 231,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes._formfunc#209",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes._formfunc(x, pos)",
        "snippet": "    def _formfunc(x, pos):\n        return ''",
        "begin_line": 209,
        "end_line": 210,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_strmethodformatter_auto_formatter#234",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_strmethodformatter_auto_formatter()",
        "snippet": "def test_strmethodformatter_auto_formatter():\n    formstr = '{x}_{pos}'\n\n    ax = plt.figure().subplots()\n\n    assert ax.xaxis.isDefault_majfmt\n    assert ax.xaxis.isDefault_minfmt\n    assert ax.yaxis.isDefault_majfmt\n    assert ax.yaxis.isDefault_minfmt\n\n    ax.yaxis.set_minor_formatter(formstr)\n\n    assert ax.xaxis.isDefault_majfmt\n    assert ax.xaxis.isDefault_minfmt\n    assert ax.yaxis.isDefault_majfmt\n    assert not ax.yaxis.isDefault_minfmt\n\n    targ_strformatter = mticker.StrMethodFormatter(formstr)\n\n    assert isinstance(ax.yaxis.get_minor_formatter(),\n                      mticker.StrMethodFormatter)\n\n    assert ax.yaxis.get_minor_formatter().fmt == targ_strformatter.fmt",
        "begin_line": 234,
        "end_line": 256,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twin_axis_locators_formatters#260",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twin_axis_locators_formatters()",
        "snippet": "def test_twin_axis_locators_formatters():\n    vals = np.linspace(0, 1, num=5, endpoint=True)\n    locs = np.sin(np.pi * vals / 2.0)\n\n    majl = plt.FixedLocator(locs)\n    minl = plt.FixedLocator([0.1, 0.2, 0.3])\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(1, 1, 1)\n    ax1.plot([0.1, 100], [0, 1])\n    ax1.yaxis.set_major_locator(majl)\n    ax1.yaxis.set_minor_locator(minl)\n    ax1.yaxis.set_major_formatter(plt.FormatStrFormatter('%08.2lf'))\n    ax1.yaxis.set_minor_formatter(plt.FixedFormatter(['tricks', 'mind',\n                                                      'jedi']))\n\n    ax1.xaxis.set_major_locator(plt.LinearLocator())\n    ax1.xaxis.set_minor_locator(plt.FixedLocator([15, 35, 55, 75]))\n    ax1.xaxis.set_major_formatter(plt.FormatStrFormatter('%05.2lf'))\n    ax1.xaxis.set_minor_formatter(plt.FixedFormatter(['c', '3', 'p', 'o']))\n    ax1.twiny()\n    ax1.twinx()",
        "begin_line": 260,
        "end_line": 281,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twinx_cla#284",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twinx_cla()",
        "snippet": "def test_twinx_cla():\n    fig, ax = plt.subplots()\n    ax2 = ax.twinx()\n    ax3 = ax2.twiny()\n    plt.draw()\n    assert not ax2.xaxis.get_visible()\n    assert not ax2.patch.get_visible()\n    ax2.cla()\n    ax3.cla()\n\n    assert not ax2.xaxis.get_visible()\n    assert not ax2.patch.get_visible()\n    assert ax2.yaxis.get_visible()\n\n    assert ax3.xaxis.get_visible()\n    assert not ax3.patch.get_visible()\n    assert not ax3.yaxis.get_visible()\n\n    assert ax.xaxis.get_visible()\n    assert ax.patch.get_visible()\n    assert ax.yaxis.get_visible()",
        "begin_line": 284,
        "end_line": 304,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twinx_axis_scales#308",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twinx_axis_scales()",
        "snippet": "def test_twinx_axis_scales():\n    x = np.array([0, 0.5, 1])\n    y = 0.5 * x\n    x2 = np.array([0, 1, 2])\n    y2 = 2 * x2\n\n    fig = plt.figure()\n    ax = fig.add_axes((0, 0, 1, 1), autoscalex_on=False, autoscaley_on=False)\n    ax.plot(x, y, color='blue', lw=10)\n\n    ax2 = plt.twinx(ax)\n    ax2.plot(x2, y2, 'r--', lw=5)\n\n    ax.margins(0, 0)\n    ax2.margins(0, 0)",
        "begin_line": 308,
        "end_line": 322,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twin_inherit_autoscale_setting#325",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twin_inherit_autoscale_setting()",
        "snippet": "def test_twin_inherit_autoscale_setting():\n    fig, ax = plt.subplots()\n    ax_x_on = ax.twinx()\n    ax.set_autoscalex_on(False)\n    ax_x_off = ax.twinx()\n\n    assert ax_x_on.get_autoscalex_on()\n    assert not ax_x_off.get_autoscalex_on()\n\n    ax_y_on = ax.twiny()\n    ax.set_autoscaley_on(False)\n    ax_y_off = ax.twiny()\n\n    assert ax_y_on.get_autoscaley_on()\n    assert not ax_y_off.get_autoscaley_on()",
        "begin_line": 325,
        "end_line": 339,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_inverted_cla#342",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_inverted_cla()",
        "snippet": "def test_inverted_cla():\n    # GitHub PR #5450. Setting autoscale should reset\n    # axes to be non-inverted.\n    # plotting an image, then 1d graph, axis is now down\n    fig = plt.figure(0)\n    ax = fig.gca()\n    # 1. test that a new axis is not inverted per default\n    assert not ax.xaxis_inverted()\n    assert not ax.yaxis_inverted()\n    img = np.random.random((100, 100))\n    ax.imshow(img)\n    # 2. test that a image axis is inverted\n    assert not ax.xaxis_inverted()\n    assert ax.yaxis_inverted()\n    # 3. test that clearing and plotting a line, axes are\n    # not inverted\n    ax.cla()\n    x = np.linspace(0, 2*np.pi, 100)\n    ax.plot(x, np.cos(x))\n    assert not ax.xaxis_inverted()\n    assert not ax.yaxis_inverted()\n\n    # 4. autoscaling should not bring back axes to normal\n    ax.cla()\n    ax.imshow(img)\n    plt.autoscale()\n    assert not ax.xaxis_inverted()\n    assert ax.yaxis_inverted()\n\n    # 5. two shared axes. Inverting the master axis should invert the shared\n    # axes; clearing the master axis should bring axes in shared\n    # axes back to normal.\n    ax0 = plt.subplot(211)\n    ax1 = plt.subplot(212, sharey=ax0)\n    ax0.yaxis.set_inverted(True)\n    assert ax1.yaxis_inverted()\n    ax1.plot(x, np.cos(x))\n    ax0.cla()\n    assert not ax1.yaxis_inverted()\n    ax1.cla()\n    # 6. clearing the nonmaster should not touch limits\n    ax0.imshow(img)\n    ax1.plot(x, np.cos(x))\n    ax1.cla()\n    assert ax.yaxis_inverted()\n\n    # clean up\n    plt.close(fig)",
        "begin_line": 342,
        "end_line": 389,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_minorticks_on_rcParams_both#393",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_minorticks_on_rcParams_both(fig_test, fig_ref)",
        "snippet": "def test_minorticks_on_rcParams_both(fig_test, fig_ref):\n    with matplotlib.rc_context({\"xtick.minor.visible\": True,\n                                \"ytick.minor.visible\": True}):\n        ax_test = fig_test.subplots()\n        ax_test.plot([0, 1], [0, 1])\n    ax_ref = fig_ref.subplots()\n    ax_ref.plot([0, 1], [0, 1])\n    ax_ref.minorticks_on()",
        "begin_line": 393,
        "end_line": 400,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_autoscale_tiny_range#404",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_autoscale_tiny_range()",
        "snippet": "def test_autoscale_tiny_range():\n    # github pull #904\n    fig, axs = plt.subplots(2, 2)\n    for i, ax in enumerate(axs.flat):\n        y1 = 10**(-11 - i)\n        ax.plot([0, 1], [1, 1 + y1])",
        "begin_line": 404,
        "end_line": 409,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_autoscale_tight#413",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_autoscale_tight()",
        "snippet": "def test_autoscale_tight():\n    fig, ax = plt.subplots(1, 1)\n    ax.plot([1, 2, 3, 4])\n    ax.autoscale(enable=True, axis='x', tight=False)\n    ax.autoscale(enable=True, axis='y', tight=True)\n    assert_allclose(ax.get_xlim(), (-0.15, 3.15))\n    assert_allclose(ax.get_ylim(), (1.0, 4.0))",
        "begin_line": 413,
        "end_line": 419,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_autoscale_log_shared#423",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_autoscale_log_shared()",
        "snippet": "def test_autoscale_log_shared():\n    # related to github #7587\n    # array starts at zero to trigger _minpos handling\n    x = np.arange(100, dtype=float)\n    fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\n    ax1.loglog(x, x)\n    ax2.semilogx(x, x)\n    ax1.autoscale(tight=True)\n    ax2.autoscale(tight=True)\n    plt.draw()\n    lims = (x[1], x[-1])\n    assert_allclose(ax1.get_xlim(), lims)\n    assert_allclose(ax1.get_ylim(), lims)\n    assert_allclose(ax2.get_xlim(), lims)\n    assert_allclose(ax2.get_ylim(), (x[0], x[-1]))",
        "begin_line": 423,
        "end_line": 437,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_use_sticky_edges#441",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_use_sticky_edges()",
        "snippet": "def test_use_sticky_edges():\n    fig, ax = plt.subplots()\n    ax.imshow([[0, 1], [2, 3]], origin='lower')\n    assert_allclose(ax.get_xlim(), (-0.5, 1.5))\n    assert_allclose(ax.get_ylim(), (-0.5, 1.5))\n    ax.use_sticky_edges = False\n    ax.autoscale()\n    xlim = (-0.5 - 2 * ax._xmargin, 1.5 + 2 * ax._xmargin)\n    ylim = (-0.5 - 2 * ax._ymargin, 1.5 + 2 * ax._ymargin)\n    assert_allclose(ax.get_xlim(), xlim)\n    assert_allclose(ax.get_ylim(), ylim)\n    # Make sure it is reversible:\n    ax.use_sticky_edges = True\n    ax.autoscale()\n    assert_allclose(ax.get_xlim(), (-0.5, 1.5))\n    assert_allclose(ax.get_ylim(), (-0.5, 1.5))",
        "begin_line": 441,
        "end_line": 456,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_sticky_shared_axes#460",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_sticky_shared_axes(fig_test, fig_ref)",
        "snippet": "def test_sticky_shared_axes(fig_test, fig_ref):\n    # Check that sticky edges work whether they are set in an axes that is a\n    # \"master\" in a share, or an axes that is a \"follower\".\n    Z = np.arange(15).reshape(3, 5)\n\n    ax0 = fig_test.add_subplot(211)\n    ax1 = fig_test.add_subplot(212, sharex=ax0)\n    ax1.pcolormesh(Z)\n\n    ax0 = fig_ref.add_subplot(212)\n    ax1 = fig_ref.add_subplot(211, sharex=ax0)\n    ax0.pcolormesh(Z)",
        "begin_line": 460,
        "end_line": 471,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_basic_annotate#475",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_basic_annotate()",
        "snippet": "def test_basic_annotate():\n    # Setup some data\n    t = np.arange(0.0, 5.0, 0.01)\n    s = np.cos(2.0*np.pi * t)\n\n    # Offset Points\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, autoscale_on=False, xlim=(-1, 5), ylim=(-3, 5))\n    line, = ax.plot(t, s, lw=3, color='purple')\n\n    ax.annotate('local max', xy=(3, 1), xycoords='data',\n                xytext=(3, 3), textcoords='offset points')",
        "begin_line": 475,
        "end_line": 487,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_annotate_parameter_warn#490",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_annotate_parameter_warn()",
        "snippet": "def test_annotate_parameter_warn():\n    fig, ax = plt.subplots()\n    with pytest.warns(MatplotlibDeprecationWarning,\n                      match=r\"The \\'s\\' parameter of annotate\\(\\) \"\n                             \"has been renamed \\'text\\'\"):\n        ax.annotate(s='now named text', xy=(0, 1))",
        "begin_line": 490,
        "end_line": 495,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_arrow_simple#499",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_arrow_simple()",
        "snippet": "def test_arrow_simple():\n    # Simple image test for ax.arrow\n    # kwargs that take discrete values\n    length_includes_head = (True, False)\n    shape = ('full', 'left', 'right')\n    head_starts_at_zero = (True, False)\n    # Create outer product of values\n    kwargs = product(length_includes_head, shape, head_starts_at_zero)\n\n    fig, axs = plt.subplots(3, 4)\n    for i, (ax, kwarg) in enumerate(zip(axs.flat, kwargs)):\n        ax.set_xlim(-2, 2)\n        ax.set_ylim(-2, 2)\n        # Unpack kwargs\n        (length_includes_head, shape, head_starts_at_zero) = kwarg\n        theta = 2 * np.pi * i / 12\n        # Draw arrow\n        ax.arrow(0, 0, np.sin(theta), np.cos(theta),\n                 width=theta/100,\n                 length_includes_head=length_includes_head,\n                 shape=shape,\n                 head_starts_at_zero=head_starts_at_zero,\n                 head_width=theta / 10,\n                 head_length=theta / 10)",
        "begin_line": 499,
        "end_line": 522,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_arrow_empty#525",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_arrow_empty()",
        "snippet": "def test_arrow_empty():\n    _, ax = plt.subplots()\n    # Create an empty FancyArrow\n    ax.arrow(0, 0, 0, 0, head_length=0)",
        "begin_line": 525,
        "end_line": 528,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_arrow_in_view#531",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_arrow_in_view()",
        "snippet": "def test_arrow_in_view():\n    _, ax = plt.subplots()\n    ax.arrow(1, 1, 1, 1)\n    assert ax.get_xlim() == (0.8, 2.2)\n    assert ax.get_ylim() == (0.8, 2.2)",
        "begin_line": 531,
        "end_line": 535,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_annotate_default_arrow#538",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_annotate_default_arrow()",
        "snippet": "def test_annotate_default_arrow():\n    # Check that we can make an annotation arrow with only default properties.\n    fig, ax = plt.subplots()\n    ann = ax.annotate(\"foo\", (0, 1), xytext=(2, 3))\n    assert ann.arrow_patch is None\n    ann = ax.annotate(\"foo\", (0, 1), xytext=(2, 3), arrowprops={})\n    assert ann.arrow_patch is not None",
        "begin_line": 538,
        "end_line": 544,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_fill_units#548",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_fill_units()",
        "snippet": "def test_fill_units():\n    import matplotlib.testing.jpl_units as units\n    units.register()\n\n    # generate some data\n    t = units.Epoch(\"ET\", dt=datetime.datetime(2009, 4, 27))\n    value = 10.0 * units.deg\n    day = units.Duration(\"ET\", 24.0 * 60.0 * 60.0)\n    dt = np.arange('2009-04-27', '2009-04-29', dtype='datetime64[D]')\n    dtn = mdates.date2num(dt)\n\n    fig = plt.figure()\n\n    # Top-Left\n    ax1 = fig.add_subplot(221)\n    ax1.plot([t], [value], yunits='deg', color='red')\n    ind = [0, 0, 1, 1]\n    ax1.fill(dtn[ind], [0.0, 0.0, 90.0, 0.0], 'b')\n    # Top-Right\n    ax2 = fig.add_subplot(222)\n    ax2.plot([t], [value], yunits='deg', color='red')\n    ax2.fill([t, t, t + day, t + day],\n             [0.0, 0.0, 90.0, 0.0], 'b')\n    # Bottom-Left\n    ax3 = fig.add_subplot(223)\n    ax3.plot([t], [value], yunits='deg', color='red')\n    ax3.fill(dtn[ind],\n             [0 * units.deg, 0 * units.deg, 90 * units.deg, 0 * units.deg],\n             'b')\n    # Bottom-Right\n    ax4 = fig.add_subplot(224)\n    ax4.plot([t], [value], yunits='deg', color='red')\n    ax4.fill([t, t, t + day, t + day],\n             [0 * units.deg, 0 * units.deg, 90 * units.deg, 0 * units.deg],\n             facecolor=\"blue\")\n    fig.autofmt_xdate()",
        "begin_line": 548,
        "end_line": 583,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_single_point#587",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_single_point()",
        "snippet": "def test_single_point():\n    # Issue #1796: don't let lines.marker affect the grid\n    matplotlib.rcParams['lines.marker'] = 'o'\n    matplotlib.rcParams['axes.grid'] = True\n\n    plt.figure()\n    plt.subplot(211)\n    plt.plot([0], [0], 'o')\n\n    plt.subplot(212)\n    plt.plot([1], [1], 'o')\n\n    # Reuse testcase from above for a labeled data test\n    data = {'a': [0], 'b': [1]}\n\n    plt.figure()\n    plt.subplot(211)\n    plt.plot('a', 'a', 'o', data=data)\n\n    plt.subplot(212)\n    plt.plot('b', 'b', 'o', data=data)",
        "begin_line": 587,
        "end_line": 607,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_single_date#611",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_single_date()",
        "snippet": "def test_single_date():\n\n    # use former defaults to match existing baseline image\n    plt.rcParams['axes.formatter.limits'] = -7, 7\n    dt = mdates.date2num(np.datetime64('0000-12-31'))\n\n    time1 = [721964.0]\n    data1 = [-65.54]\n\n    fig, ax = plt.subplots(2, 1)\n    ax[0].plot_date(time1 + dt, data1, 'o', color='r')\n    ax[1].plot(time1, data1, 'o', color='r')",
        "begin_line": 611,
        "end_line": 622,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shaped_data#626",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shaped_data(fig_test, fig_ref)",
        "snippet": "def test_shaped_data(fig_test, fig_ref):\n    row = np.arange(10).reshape((1, -1))\n    col = np.arange(0, 100, 10).reshape((-1, 1))\n\n    axs = fig_test.subplots(2)\n    axs[0].plot(row)  # Actually plots nothing (columns are single points).\n    axs[1].plot(col)  # Same as plotting 1d.\n\n    axs = fig_ref.subplots(2)\n    # xlim from the implicit \"x=0\", ylim from the row datalim.\n    axs[0].set(xlim=(-.06, .06), ylim=(0, 9))\n    axs[1].plot(col.ravel())",
        "begin_line": 626,
        "end_line": 637,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_structured_data#640",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_structured_data()",
        "snippet": "def test_structured_data():\n    # support for structured data\n    pts = np.array([(1, 1), (2, 2)], dtype=[(\"ones\", float), (\"twos\", float)])\n\n    # this should not read second name as a format and raise ValueError\n    axs = plt.figure().subplots(2)\n    axs[0].plot(\"ones\", \"twos\", data=pts)\n    axs[1].plot(\"ones\", \"twos\", \"r\", data=pts)",
        "begin_line": 640,
        "end_line": 647,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_aitoff_proj#652",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_aitoff_proj()",
        "snippet": "def test_aitoff_proj():\n    \"\"\"\n    Test aitoff projection ref.:\n    https://github.com/matplotlib/matplotlib/pull/14451\n    \"\"\"\n    x = np.linspace(-np.pi, np.pi, 20)\n    y = np.linspace(-np.pi / 2, np.pi / 2, 20)\n    X, Y = np.meshgrid(x, y)\n\n    fig, ax = plt.subplots(figsize=(8, 4.2),\n                           subplot_kw=dict(projection=\"aitoff\"))\n    ax.grid()\n    ax.plot(X.flat, Y.flat, 'o', markersize=4)",
        "begin_line": 652,
        "end_line": 664,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axvspan_epoch#668",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axvspan_epoch()",
        "snippet": "def test_axvspan_epoch():\n    import matplotlib.testing.jpl_units as units\n    units.register()\n\n    # generate some data\n    t0 = units.Epoch(\"ET\", dt=datetime.datetime(2009, 1, 20))\n    tf = units.Epoch(\"ET\", dt=datetime.datetime(2009, 1, 21))\n    dt = units.Duration(\"ET\", units.day.convert(\"sec\"))\n\n    ax = plt.gca()\n    plt.axvspan(t0, tf, facecolor=\"blue\", alpha=0.25)\n    ax.set_xlim(t0 - 5.0*dt, tf + 5.0*dt)",
        "begin_line": 668,
        "end_line": 679,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axhspan_epoch#683",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axhspan_epoch()",
        "snippet": "def test_axhspan_epoch():\n    import matplotlib.testing.jpl_units as units\n    units.register()\n\n    # generate some data\n    t0 = units.Epoch(\"ET\", dt=datetime.datetime(2009, 1, 20))\n    tf = units.Epoch(\"ET\", dt=datetime.datetime(2009, 1, 21))\n    dt = units.Duration(\"ET\", units.day.convert(\"sec\"))\n\n    ax = plt.gca()\n    ax.axhspan(t0, tf, facecolor=\"blue\", alpha=0.25)\n    ax.set_ylim(t0 - 5.0*dt, tf + 5.0*dt)",
        "begin_line": 683,
        "end_line": 694,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hexbin_extent#698",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hexbin_extent()",
        "snippet": "def test_hexbin_extent():\n    # this test exposes sf bug 2856228\n    fig, ax = plt.subplots()\n    data = (np.arange(2000) / 2000).reshape((2, 1000))\n    x, y = data\n\n    ax.hexbin(x, y, extent=[.1, .3, .6, .7])\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"x\": x, \"y\": y}\n\n    fig, ax = plt.subplots()\n    ax.hexbin(\"x\", \"y\", extent=[.1, .3, .6, .7], data=data)",
        "begin_line": 698,
        "end_line": 710,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hexbin_empty#714",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hexbin_empty()",
        "snippet": "def test_hexbin_empty():\n    # From #3886: creating hexbin from empty dataset raises ValueError\n    ax = plt.gca()\n    ax.hexbin([], [])",
        "begin_line": 714,
        "end_line": 717,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hexbin_pickable#720",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hexbin_pickable()",
        "snippet": "def test_hexbin_pickable():\n    # From #1973: Test that picking a hexbin collection works\n    fig, ax = plt.subplots()\n    data = (np.arange(200) / 200).reshape((2, 100))\n    x, y = data\n    hb = ax.hexbin(x, y, extent=[.1, .3, .6, .7], picker=-1)\n    mouse_event = SimpleNamespace(x=400, y=300)\n    assert hb.contains(mouse_event)[0]",
        "begin_line": 720,
        "end_line": 727,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hexbin_log#731",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hexbin_log()",
        "snippet": "def test_hexbin_log():\n    # Issue #1636 (and also test log scaled colorbar)\n    np.random.seed(19680801)\n    n = 100000\n    x = np.random.standard_normal(n)\n    y = 2.0 + 3.0 * x + 4.0 * np.random.standard_normal(n)\n    y = np.power(2, y * 0.5)\n\n    fig, ax = plt.subplots()\n    h = ax.hexbin(x, y, yscale='log', bins='log')\n    plt.colorbar(h)",
        "begin_line": 731,
        "end_line": 741,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_inverted_limits#744",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_inverted_limits()",
        "snippet": "def test_inverted_limits():\n    # Test gh:1553\n    # Calling invert_xaxis prior to plotting should not disable autoscaling\n    # while still maintaining the inverted direction\n    fig, ax = plt.subplots()\n    ax.invert_xaxis()\n    ax.plot([-5, -3, 2, 4], [1, 2, -3, 5])\n\n    assert ax.get_xlim() == (4, -5)\n    assert ax.get_ylim() == (-3, 5)\n    plt.close()\n\n    fig, ax = plt.subplots()\n    ax.invert_yaxis()\n    ax.plot([-5, -3, 2, 4], [1, 2, -3, 5])\n\n    assert ax.get_xlim() == (-5, 4)\n    assert ax.get_ylim() == (5, -3)\n\n    # Test inverting nonlinear axes.\n    fig, ax = plt.subplots()\n    ax.set_yscale(\"log\")\n    ax.set_ylim(10, 1)\n    assert ax.get_ylim() == (10, 1)",
        "begin_line": 744,
        "end_line": 767,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_nonfinite_limits#771",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_nonfinite_limits()",
        "snippet": "def test_nonfinite_limits():\n    x = np.arange(0., np.e, 0.01)\n    # silence divide by zero warning from log(0)\n    with np.errstate(divide='ignore'):\n        y = np.log(x)\n    x[len(x)//2] = np.nan\n    fig, ax = plt.subplots()\n    ax.plot(x, y)",
        "begin_line": 771,
        "end_line": 778,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_imshow#782",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_imshow()",
        "snippet": "def test_imshow():\n    # use former defaults to match existing baseline image\n    matplotlib.rcParams['image.interpolation'] = 'nearest'\n    # Create a NxN image\n    N = 100\n    (x, y) = np.indices((N, N))\n    x -= N//2\n    y -= N//2\n    r = np.sqrt(x**2+y**2-x*y)\n\n    # Create a contour plot at N/4 and extract both the clip path and transform\n    fig, ax = plt.subplots()\n    ax.imshow(r)\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"r\": r}\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.imshow(\"r\", data=data)",
        "begin_line": 782,
        "end_line": 800,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_imshow_clip#804",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_imshow_clip()",
        "snippet": "def test_imshow_clip():\n    # As originally reported by Gellule Xg <gellule.xg@free.fr>\n    # use former defaults to match existing baseline image\n    matplotlib.rcParams['image.interpolation'] = 'nearest'\n\n    # Create a NxN image\n    N = 100\n    (x, y) = np.indices((N, N))\n    x -= N//2\n    y -= N//2\n    r = np.sqrt(x**2+y**2-x*y)\n\n    # Create a contour plot at N/4 and extract both the clip path and transform\n    fig, ax = plt.subplots()\n\n    c = ax.contour(r, [N/4])\n    x = c.collections[0]\n    clip_path = x.get_paths()[0]\n    clip_transform = x.get_transform()\n\n    clip_path = mtransforms.TransformedPath(clip_path, clip_transform)\n\n    # Plot the image clipped by the contour\n    ax.imshow(r, clip_path=clip_path)",
        "begin_line": 804,
        "end_line": 827,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_imshow_norm_vminvmax#831",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_imshow_norm_vminvmax(fig_test, fig_ref)",
        "snippet": "def test_imshow_norm_vminvmax(fig_test, fig_ref):\n    \"\"\"Parameters vmin, vmax should be ignored if norm is given.\"\"\"\n    a = [[1, 2], [3, 4]]\n    ax = fig_ref.subplots()\n    ax.imshow(a, vmin=0, vmax=5)\n    ax = fig_test.subplots()\n    with pytest.warns(MatplotlibDeprecationWarning,\n                      match=\"Passing parameters norm and vmin/vmax \"\n                            \"simultaneously is deprecated.\"):\n        ax.imshow(a, norm=mcolors.Normalize(-10, 10), vmin=0, vmax=5)",
        "begin_line": 831,
        "end_line": 840,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polycollection_joinstyle#844",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polycollection_joinstyle()",
        "snippet": "def test_polycollection_joinstyle():\n    # Bug #2890979 reported by Matthew West\n    fig, ax = plt.subplots()\n    verts = np.array([[1, 1], [1, 2], [2, 2], [2, 1]])\n    c = mpl.collections.PolyCollection([verts], linewidths=40)\n    ax.add_collection(c)\n    ax.set_xbound(0, 3)\n    ax.set_ybound(0, 3)",
        "begin_line": 844,
        "end_line": 851,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_fill_between_input#865",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_fill_between_input(x, y1, y2)",
        "snippet": "def test_fill_between_input(x, y1, y2):\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.fill_between(x, y1, y2)",
        "begin_line": 865,
        "end_line": 868,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_fill_betweenx_input#882",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_fill_betweenx_input(y, x1, x2)",
        "snippet": "def test_fill_betweenx_input(y, x1, x2):\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.fill_betweenx(y, x1, x2)",
        "begin_line": 882,
        "end_line": 885,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_fill_between_interpolate#889",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_fill_between_interpolate()",
        "snippet": "def test_fill_between_interpolate():\n    x = np.arange(0.0, 2, 0.02)\n    y1 = np.sin(2*np.pi*x)\n    y2 = 1.2*np.sin(4*np.pi*x)\n\n    fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)\n    ax1.plot(x, y1, x, y2, color='black')\n    ax1.fill_between(x, y1, y2, where=y2 >= y1, facecolor='white', hatch='/',\n                     interpolate=True)\n    ax1.fill_between(x, y1, y2, where=y2 <= y1, facecolor='red',\n                     interpolate=True)\n\n    # Test support for masked arrays.\n    y2 = np.ma.masked_greater(y2, 1.0)\n    # Test that plotting works for masked arrays with the first element masked\n    y2[0] = np.ma.masked\n    ax2.plot(x, y1, x, y2, color='black')\n    ax2.fill_between(x, y1, y2, where=y2 >= y1, facecolor='green',\n                     interpolate=True)\n    ax2.fill_between(x, y1, y2, where=y2 <= y1, facecolor='red',\n                     interpolate=True)",
        "begin_line": 889,
        "end_line": 909,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_fill_between_interpolate_decreasing#914",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_fill_between_interpolate_decreasing()",
        "snippet": "def test_fill_between_interpolate_decreasing():\n    p = np.array([724.3, 700, 655])\n    t = np.array([9.4, 7, 2.2])\n    prof = np.array([7.9, 6.6, 3.8])\n\n    fig, ax = plt.subplots(figsize=(9, 9))\n\n    ax.plot(t, p, 'tab:red')\n    ax.plot(prof, p, 'k')\n\n    ax.fill_betweenx(p, t, prof, where=prof < t,\n                     facecolor='blue', interpolate=True, alpha=0.4)\n    ax.fill_betweenx(p, t, prof, where=prof > t,\n                     facecolor='red', interpolate=True, alpha=0.4)\n\n    ax.set_xlim(0, 30)\n    ax.set_ylim(800, 600)",
        "begin_line": 914,
        "end_line": 930,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_symlog#937",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_symlog()",
        "snippet": "def test_symlog():\n    x = np.array([0, 1, 2, 4, 6, 9, 12, 24])\n    y = np.array([1000000, 500000, 100000, 100, 5, 0, 0, 0])\n\n    fig, ax = plt.subplots()\n    ax.plot(x, y)\n    ax.set_yscale('symlog')\n    ax.set_xscale('linear')\n    ax.set_ylim(-1, 10000000)",
        "begin_line": 937,
        "end_line": 945,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_symlog2#949",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_symlog2()",
        "snippet": "def test_symlog2():\n    # Numbers from -50 to 50, with 0.1 as step\n    x = np.arange(-50, 50, 0.001)\n\n    fig, axs = plt.subplots(5, 1)\n    for ax, linthresh in zip(axs, [20., 2., 1., 0.1, 0.01]):\n        ax.plot(x, x)\n        ax.set_xscale('symlog', linthresh=linthresh)\n        ax.grid(True)\n    axs[-1].set_ylim(-0.1, 0.1)",
        "begin_line": 949,
        "end_line": 958,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolorargs_5205#961",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolorargs_5205()",
        "snippet": "def test_pcolorargs_5205():\n    # Smoketest to catch issue found in gh:5205\n    x = [-1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5]\n    y = [-1.5, -1.25, -1.0, -0.75, -0.5, -0.25, 0,\n         0.25, 0.5, 0.75, 1.0, 1.25, 1.5]\n    X, Y = np.meshgrid(x, y)\n    Z = np.hypot(X, Y)\n\n    plt.pcolor(Z)\n    plt.pcolor(list(Z))\n    plt.pcolor(x, y, Z[:-1, :-1])\n    plt.pcolor(X, Y, list(Z[:-1, :-1]))",
        "begin_line": 961,
        "end_line": 972,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolormesh#976",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolormesh()",
        "snippet": "def test_pcolormesh():\n    n = 12\n    x = np.linspace(-1.5, 1.5, n)\n    y = np.linspace(-1.5, 1.5, n*2)\n    X, Y = np.meshgrid(x, y)\n    Qx = np.cos(Y) - np.cos(X)\n    Qz = np.sin(Y) + np.sin(X)\n    Qx = (Qx + 1.1)\n    Z = np.hypot(X, Y) / 5\n    Z = (Z - Z.min()) / Z.ptp()\n\n    # The color array can include masked values:\n    Zm = ma.masked_where(np.abs(Qz) < 0.5 * np.max(Qz), Z)\n\n    fig, (ax1, ax2, ax3) = plt.subplots(1, 3)\n    ax1.pcolormesh(Qx, Qz, Z[:-1, :-1], lw=0.5, edgecolors='k')\n    ax2.pcolormesh(Qx, Qz, Z[:-1, :-1], lw=2, edgecolors=['b', 'w'])\n    ax3.pcolormesh(Qx, Qz, Z, shading=\"gouraud\")",
        "begin_line": 976,
        "end_line": 993,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolormesh_alpha#998",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolormesh_alpha()",
        "snippet": "def test_pcolormesh_alpha():\n    n = 12\n    X, Y = np.meshgrid(\n        np.linspace(-1.5, 1.5, n),\n        np.linspace(-1.5, 1.5, n*2)\n    )\n    Qx = X\n    Qy = Y + np.sin(X)\n    Z = np.hypot(X, Y) / 5\n    Z = (Z - Z.min()) / Z.ptp()\n    vir = plt.get_cmap(\"viridis\", 16)\n    # make another colormap with varying alpha\n    colors = vir(np.arange(16))\n    colors[:, 3] = 0.5 + 0.5*np.sin(np.arange(16))\n    cmap = mcolors.ListedColormap(colors)\n\n    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)\n    for ax in ax1, ax2, ax3, ax4:\n        ax.add_patch(mpatches.Rectangle(\n            (0, -1.5), 1.5, 3, facecolor=[.7, .1, .1, .5], zorder=0\n        ))\n    # ax1, ax2: constant alpha\n    ax1.pcolormesh(Qx, Qy, Z[:-1, :-1], cmap=vir, alpha=0.4,\n                   shading='flat', zorder=1)\n    ax2.pcolormesh(Qx, Qy, Z, cmap=vir, alpha=0.4, shading='gouraud', zorder=1)\n    # ax3, ax4: alpha from colormap\n    ax3.pcolormesh(Qx, Qy, Z[:-1, :-1], cmap=cmap, shading='flat', zorder=1)\n    ax4.pcolormesh(Qx, Qy, Z, cmap=cmap, shading='gouraud', zorder=1)",
        "begin_line": 998,
        "end_line": 1025,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolormesh_datetime_axis#1030",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolormesh_datetime_axis()",
        "snippet": "def test_pcolormesh_datetime_axis():\n    fig = plt.figure()\n    fig.subplots_adjust(hspace=0.4, top=0.98, bottom=.15)\n    base = datetime.datetime(2013, 1, 1)\n    x = np.array([base + datetime.timedelta(days=d) for d in range(21)])\n    y = np.arange(21)\n    z1, z2 = np.meshgrid(np.arange(20), np.arange(20))\n    z = z1 * z2\n    plt.subplot(221)\n    plt.pcolormesh(x[:-1], y[:-1], z[:-1, :-1])\n    plt.subplot(222)\n    plt.pcolormesh(x, y, z)\n    x = np.repeat(x[np.newaxis], 21, axis=0)\n    y = np.repeat(y[:, np.newaxis], 21, axis=1)\n    plt.subplot(223)\n    plt.pcolormesh(x[:-1, :-1], y[:-1, :-1], z[:-1, :-1])\n    plt.subplot(224)\n    plt.pcolormesh(x, y, z)\n    for ax in fig.get_axes():\n        for label in ax.get_xticklabels():\n            label.set_ha('right')\n            label.set_rotation(30)",
        "begin_line": 1030,
        "end_line": 1051,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolor_datetime_axis#1056",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolor_datetime_axis()",
        "snippet": "def test_pcolor_datetime_axis():\n    fig = plt.figure()\n    fig.subplots_adjust(hspace=0.4, top=0.98, bottom=.15)\n    base = datetime.datetime(2013, 1, 1)\n    x = np.array([base + datetime.timedelta(days=d) for d in range(21)])\n    y = np.arange(21)\n    z1, z2 = np.meshgrid(np.arange(20), np.arange(20))\n    z = z1 * z2\n    plt.subplot(221)\n    plt.pcolor(x[:-1], y[:-1], z[:-1, :-1])\n    plt.subplot(222)\n    plt.pcolor(x, y, z)\n    x = np.repeat(x[np.newaxis], 21, axis=0)\n    y = np.repeat(y[:, np.newaxis], 21, axis=1)\n    plt.subplot(223)\n    plt.pcolor(x[:-1, :-1], y[:-1, :-1], z[:-1, :-1])\n    plt.subplot(224)\n    plt.pcolor(x, y, z)\n    for ax in fig.get_axes():\n        for label in ax.get_xticklabels():\n            label.set_ha('right')\n            label.set_rotation(30)",
        "begin_line": 1056,
        "end_line": 1077,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolorargs#1080",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolorargs()",
        "snippet": "def test_pcolorargs():\n    n = 12\n    x = np.linspace(-1.5, 1.5, n)\n    y = np.linspace(-1.5, 1.5, n*2)\n    X, Y = np.meshgrid(x, y)\n    Z = np.hypot(X, Y) / 5\n\n    _, ax = plt.subplots()\n    with pytest.raises(TypeError):\n        ax.pcolormesh(y, x, Z)\n    with pytest.raises(TypeError):\n        ax.pcolormesh(X, Y, Z.T)\n    with pytest.raises(TypeError):\n        ax.pcolormesh(x, y, Z[:-1, :-1], shading=\"gouraud\")\n    with pytest.raises(TypeError):\n        ax.pcolormesh(X, Y, Z[:-1, :-1], shading=\"gouraud\")\n    x[0] = np.NaN\n    with pytest.raises(ValueError):\n        ax.pcolormesh(x, y, Z[:-1, :-1])\n    with np.errstate(invalid='ignore'):\n        x = np.ma.array(x, mask=(x < 0))\n    with pytest.raises(ValueError):\n        ax.pcolormesh(x, y, Z[:-1, :-1])",
        "begin_line": 1080,
        "end_line": 1102,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolornearest#1106",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolornearest(fig_test, fig_ref)",
        "snippet": "def test_pcolornearest(fig_test, fig_ref):\n    ax = fig_test.subplots()\n    x = np.arange(0, 10)\n    y = np.arange(0, 3)\n    np.random.seed(19680801)\n    Z = np.random.randn(2, 9)\n    ax.pcolormesh(x, y, Z, shading='flat')\n\n    ax = fig_ref.subplots()\n    # specify the centers\n    x2 = x[:-1] + np.diff(x) / 2\n    y2 = y[:-1] + np.diff(y) / 2\n    ax.pcolormesh(x2, y2, Z, shading='nearest')",
        "begin_line": 1106,
        "end_line": 1118,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolordropdata#1122",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolordropdata(fig_test, fig_ref)",
        "snippet": "def test_pcolordropdata(fig_test, fig_ref):\n    ax = fig_test.subplots()\n    x = np.arange(0, 10)\n    y = np.arange(0, 4)\n    np.random.seed(19680801)\n    Z = np.random.randn(3, 9)\n    # fake dropping the data\n    ax.pcolormesh(x[:-1], y[:-1], Z[:-1, :-1], shading='flat')\n\n    ax = fig_ref.subplots()\n    # test dropping the data...\n    x2 = x[:-1]\n    y2 = y[:-1]\n    with pytest.warns(MatplotlibDeprecationWarning):\n        ax.pcolormesh(x2, y2, Z, shading='flat')",
        "begin_line": 1122,
        "end_line": 1136,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolorauto#1140",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolorauto(fig_test, fig_ref)",
        "snippet": "def test_pcolorauto(fig_test, fig_ref):\n    ax = fig_test.subplots()\n    x = np.arange(0, 10)\n    y = np.arange(0, 4)\n    np.random.seed(19680801)\n    Z = np.random.randn(3, 9)\n    ax.pcolormesh(x, y, Z, shading='auto')\n\n    ax = fig_ref.subplots()\n    # specify the centers\n    x2 = x[:-1] + np.diff(x) / 2\n    y2 = y[:-1] + np.diff(y) / 2\n    ax.pcolormesh(x2, y2, Z, shading='auto')",
        "begin_line": 1140,
        "end_line": 1152,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_canonical#1156",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_canonical()",
        "snippet": "def test_canonical():\n    fig, ax = plt.subplots()\n    ax.plot([1, 2, 3])",
        "begin_line": 1156,
        "end_line": 1158,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_arc_angles#1162",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_arc_angles()",
        "snippet": "def test_arc_angles():\n    # Ellipse parameters\n    w = 2\n    h = 1\n    centre = (0.2, 0.5)\n    scale = 2\n\n    fig, axs = plt.subplots(3, 3)\n    for i, ax in enumerate(axs.flat):\n        theta2 = i * 360 / 9\n        theta1 = theta2 - 45\n\n        ax.add_patch(mpatches.Ellipse(centre, w, h, alpha=0.3))\n        ax.add_patch(mpatches.Arc(centre, w, h, theta1=theta1, theta2=theta2))\n        # Straight lines intersecting start and end of arc\n        ax.plot([scale * np.cos(np.deg2rad(theta1)) + centre[0],\n                 centre[0],\n                 scale * np.cos(np.deg2rad(theta2)) + centre[0]],\n                [scale * np.sin(np.deg2rad(theta1)) + centre[1],\n                 centre[1],\n                 scale * np.sin(np.deg2rad(theta2)) + centre[1]])\n\n        ax.set_xlim(-scale, scale)\n        ax.set_ylim(-scale, scale)\n\n        # This looks the same, but it triggers a different code path when it\n        # gets large enough.\n        w *= 10\n        h *= 10\n        centre = (centre[0] * 10, centre[1] * 10)\n        scale *= 10",
        "begin_line": 1162,
        "end_line": 1192,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_arc_ellipse#1196",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_arc_ellipse()",
        "snippet": "def test_arc_ellipse():\n    xcenter, ycenter = 0.38, 0.52\n    width, height = 1e-1, 3e-1\n    angle = -30\n\n    theta = np.deg2rad(np.arange(360))\n    x = width / 2. * np.cos(theta)\n    y = height / 2. * np.sin(theta)\n\n    rtheta = np.deg2rad(angle)\n    R = np.array([\n        [np.cos(rtheta), -np.sin(rtheta)],\n        [np.sin(rtheta), np.cos(rtheta)]])\n\n    x, y = np.dot(R, np.array([x, y]))\n    x += xcenter\n    y += ycenter\n\n    fig = plt.figure()\n    ax = fig.add_subplot(211, aspect='auto')\n    ax.fill(x, y, alpha=0.2, facecolor='yellow', edgecolor='yellow',\n            linewidth=1, zorder=1)\n\n    e1 = mpatches.Arc((xcenter, ycenter), width, height,\n                      angle=angle, linewidth=2, fill=False, zorder=2)\n\n    ax.add_patch(e1)\n\n    ax = fig.add_subplot(212, aspect='equal')\n    ax.fill(x, y, alpha=0.2, facecolor='green', edgecolor='green', zorder=1)\n    e2 = mpatches.Arc((xcenter, ycenter), width, height,\n                      angle=angle, linewidth=2, fill=False, zorder=2)\n\n    ax.add_patch(e2)",
        "begin_line": 1196,
        "end_line": 1229,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markevery#1233",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markevery()",
        "snippet": "def test_markevery():\n    x = np.linspace(0, 10, 100)\n    y = np.sin(x) * np.sqrt(x/10 + 0.5)\n\n    # check marker only plot\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(x, y, 'o', label='default')\n    ax.plot(x, y, 'd', markevery=None, label='mark all')\n    ax.plot(x, y, 's', markevery=10, label='mark every 10')\n    ax.plot(x, y, '+', markevery=(5, 20), label='mark every 5 starting at 10')\n    ax.legend()",
        "begin_line": 1233,
        "end_line": 1244,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markevery_line#1248",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markevery_line()",
        "snippet": "def test_markevery_line():\n    x = np.linspace(0, 10, 100)\n    y = np.sin(x) * np.sqrt(x/10 + 0.5)\n\n    # check line/marker combos\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(x, y, '-o', label='default')\n    ax.plot(x, y, '-d', markevery=None, label='mark all')\n    ax.plot(x, y, '-s', markevery=10, label='mark every 10')\n    ax.plot(x, y, '-+', markevery=(5, 20), label='mark every 5 starting at 10')\n    ax.legend()",
        "begin_line": 1248,
        "end_line": 1259,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markevery_linear_scales#1263",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markevery_linear_scales()",
        "snippet": "def test_markevery_linear_scales():\n    cases = [None,\n             8,\n             (30, 8),\n             [16, 24, 30], [0, -1],\n             slice(100, 200, 3),\n             0.1, 0.3, 1.5,\n             (0.0, 0.1), (0.45, 0.1)]\n\n    cols = 3\n    gs = matplotlib.gridspec.GridSpec(len(cases) // cols + 1, cols)\n\n    delta = 0.11\n    x = np.linspace(0, 10 - 2 * delta, 200) + delta\n    y = np.sin(x) + 1.0 + delta\n\n    for i, case in enumerate(cases):\n        row = (i // cols)\n        col = i % cols\n        plt.subplot(gs[row, col])\n        plt.title('markevery=%s' % str(case))\n        plt.plot(x, y, 'o', ls='-', ms=4,  markevery=case)",
        "begin_line": 1263,
        "end_line": 1284,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markevery_linear_scales_zoomed#1288",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markevery_linear_scales_zoomed()",
        "snippet": "def test_markevery_linear_scales_zoomed():\n    cases = [None,\n             8,\n             (30, 8),\n             [16, 24, 30], [0, -1],\n             slice(100, 200, 3),\n             0.1, 0.3, 1.5,\n             (0.0, 0.1), (0.45, 0.1)]\n\n    cols = 3\n    gs = matplotlib.gridspec.GridSpec(len(cases) // cols + 1, cols)\n\n    delta = 0.11\n    x = np.linspace(0, 10 - 2 * delta, 200) + delta\n    y = np.sin(x) + 1.0 + delta\n\n    for i, case in enumerate(cases):\n        row = (i // cols)\n        col = i % cols\n        plt.subplot(gs[row, col])\n        plt.title('markevery=%s' % str(case))\n        plt.plot(x, y, 'o', ls='-', ms=4,  markevery=case)\n        plt.xlim((6, 6.7))\n        plt.ylim((1.1, 1.7))",
        "begin_line": 1288,
        "end_line": 1311,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markevery_log_scales#1315",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markevery_log_scales()",
        "snippet": "def test_markevery_log_scales():\n    cases = [None,\n             8,\n             (30, 8),\n             [16, 24, 30], [0, -1],\n             slice(100, 200, 3),\n             0.1, 0.3, 1.5,\n             (0.0, 0.1), (0.45, 0.1)]\n\n    cols = 3\n    gs = matplotlib.gridspec.GridSpec(len(cases) // cols + 1, cols)\n\n    delta = 0.11\n    x = np.linspace(0, 10 - 2 * delta, 200) + delta\n    y = np.sin(x) + 1.0 + delta\n\n    for i, case in enumerate(cases):\n        row = (i // cols)\n        col = i % cols\n        plt.subplot(gs[row, col])\n        plt.title('markevery=%s' % str(case))\n        plt.xscale('log')\n        plt.yscale('log')\n        plt.plot(x, y, 'o', ls='-', ms=4,  markevery=case)",
        "begin_line": 1315,
        "end_line": 1338,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markevery_polar#1342",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markevery_polar()",
        "snippet": "def test_markevery_polar():\n    cases = [None,\n             8,\n             (30, 8),\n             [16, 24, 30], [0, -1],\n             slice(100, 200, 3),\n             0.1, 0.3, 1.5,\n             (0.0, 0.1), (0.45, 0.1)]\n\n    cols = 3\n    gs = matplotlib.gridspec.GridSpec(len(cases) // cols + 1, cols)\n\n    r = np.linspace(0, 3.0, 200)\n    theta = 2 * np.pi * r\n\n    for i, case in enumerate(cases):\n        row = (i // cols)\n        col = i % cols\n        plt.subplot(gs[row, col], polar=True)\n        plt.title('markevery=%s' % str(case))\n        plt.plot(theta, r, 'o', ls='-', ms=4,  markevery=case)",
        "begin_line": 1342,
        "end_line": 1362,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_marker_edges#1366",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_marker_edges()",
        "snippet": "def test_marker_edges():\n    x = np.linspace(0, 1, 10)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(x, np.sin(x), 'y.', ms=30.0, mew=0, mec='r')\n    ax.plot(x+0.1, np.sin(x), 'y.', ms=30.0, mew=1, mec='r')\n    ax.plot(x+0.2, np.sin(x), 'y.', ms=30.0, mew=2, mec='b')",
        "begin_line": 1366,
        "end_line": 1372,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_tick_label_single#1376",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_tick_label_single()",
        "snippet": "def test_bar_tick_label_single():\n    # From 2516: plot bar with array of string labels for x axis\n    ax = plt.gca()\n    ax.bar(0, 1, align='edge', tick_label='0')\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"a\": 0, \"b\": 1}\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax = plt.gca()\n    ax.bar(\"a\", \"b\", align='edge', tick_label='0', data=data)",
        "begin_line": 1376,
        "end_line": 1386,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_ticklabel_fail#1389",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_ticklabel_fail()",
        "snippet": "def test_bar_ticklabel_fail():\n    fig, ax = plt.subplots()\n    ax.bar([], [])",
        "begin_line": 1389,
        "end_line": 1391,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_tick_label_multiple#1395",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_tick_label_multiple()",
        "snippet": "def test_bar_tick_label_multiple():\n    # From 2516: plot bar with array of string labels for x axis\n    ax = plt.gca()\n    ax.bar([1, 2.5], [1, 2], width=[0.2, 0.5], tick_label=['a', 'b'],\n           align='center')",
        "begin_line": 1395,
        "end_line": 1399,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_tick_label_multiple_old_alignment#1403",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_tick_label_multiple_old_alignment()",
        "snippet": "def test_bar_tick_label_multiple_old_alignment():\n    # Test that the alignment for class is backward compatible\n    matplotlib.rcParams[\"ytick.alignment\"] = \"center\"\n    ax = plt.gca()\n    ax.bar([1, 2.5], [1, 2], width=[0.2, 0.5], tick_label=['a', 'b'],\n           align='center')",
        "begin_line": 1403,
        "end_line": 1408,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_decimal_center#1412",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_decimal_center(fig_test, fig_ref)",
        "snippet": "def test_bar_decimal_center(fig_test, fig_ref):\n    ax = fig_test.subplots()\n    x0 = [1.5, 8.4, 5.3, 4.2]\n    y0 = [1.1, 2.2, 3.3, 4.4]\n    x = [Decimal(x) for x in x0]\n    y = [Decimal(y) for y in y0]\n    # Test image - vertical, align-center bar chart with Decimal() input\n    ax.bar(x, y, align='center')\n    # Reference image\n    ax = fig_ref.subplots()\n    ax.bar(x0, y0, align='center')",
        "begin_line": 1412,
        "end_line": 1422,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_barh_decimal_center#1426",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_barh_decimal_center(fig_test, fig_ref)",
        "snippet": "def test_barh_decimal_center(fig_test, fig_ref):\n    ax = fig_test.subplots()\n    x0 = [1.5, 8.4, 5.3, 4.2]\n    y0 = [1.1, 2.2, 3.3, 4.4]\n    x = [Decimal(x) for x in x0]\n    y = [Decimal(y) for y in y0]\n    # Test image - horizontal, align-center bar chart with Decimal() input\n    ax.barh(x, y, height=[0.5, 0.5, 1, 1], align='center')\n    # Reference image\n    ax = fig_ref.subplots()\n    ax.barh(x0, y0, height=[0.5, 0.5, 1, 1], align='center')",
        "begin_line": 1426,
        "end_line": 1436,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_decimal_width#1440",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_decimal_width(fig_test, fig_ref)",
        "snippet": "def test_bar_decimal_width(fig_test, fig_ref):\n    x = [1.5, 8.4, 5.3, 4.2]\n    y = [1.1, 2.2, 3.3, 4.4]\n    w0 = [0.7, 1.45, 1, 2]\n    w = [Decimal(i) for i in w0]\n    # Test image - vertical bar chart with Decimal() width\n    ax = fig_test.subplots()\n    ax.bar(x, y, width=w, align='center')\n    # Reference image\n    ax = fig_ref.subplots()\n    ax.bar(x, y, width=w0, align='center')",
        "begin_line": 1440,
        "end_line": 1450,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_barh_decimal_height#1454",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_barh_decimal_height(fig_test, fig_ref)",
        "snippet": "def test_barh_decimal_height(fig_test, fig_ref):\n    x = [1.5, 8.4, 5.3, 4.2]\n    y = [1.1, 2.2, 3.3, 4.4]\n    h0 = [0.7, 1.45, 1, 2]\n    h = [Decimal(i) for i in h0]\n    # Test image - horizontal bar chart with Decimal() height\n    ax = fig_test.subplots()\n    ax.barh(x, y, height=h, align='center')\n    # Reference image\n    ax = fig_ref.subplots()\n    ax.barh(x, y, height=h0, align='center')",
        "begin_line": 1454,
        "end_line": 1464,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_color_none_alpha#1467",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_color_none_alpha()",
        "snippet": "def test_bar_color_none_alpha():\n    ax = plt.gca()\n    rects = ax.bar([1, 2], [2, 4], alpha=0.3, color='none', edgecolor='r')\n    for rect in rects:\n        assert rect.get_facecolor() == (0, 0, 0, 0)\n        assert rect.get_edgecolor() == (1, 0, 0, 0.3)",
        "begin_line": 1467,
        "end_line": 1472,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_edgecolor_none_alpha#1475",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_edgecolor_none_alpha()",
        "snippet": "def test_bar_edgecolor_none_alpha():\n    ax = plt.gca()\n    rects = ax.bar([1, 2], [2, 4], alpha=0.3, color='r', edgecolor='none')\n    for rect in rects:\n        assert rect.get_facecolor() == (1, 0, 0, 0.3)\n        assert rect.get_edgecolor() == (0, 0, 0, 0)",
        "begin_line": 1475,
        "end_line": 1480,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_barh_tick_label#1484",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_barh_tick_label()",
        "snippet": "def test_barh_tick_label():\n    # From 2516: plot barh with array of string labels for y axis\n    ax = plt.gca()\n    ax.barh([1, 2.5], [1, 2], height=[0.2, 0.5], tick_label=['a', 'b'],\n            align='center')",
        "begin_line": 1484,
        "end_line": 1488,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_timedelta#1491",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_timedelta()",
        "snippet": "def test_bar_timedelta():\n    \"\"\"Smoketest that bar can handle width and height in delta units.\"\"\"\n    fig, ax = plt.subplots()\n    ax.bar(datetime.datetime(2018, 1, 1), 1.,\n           width=datetime.timedelta(hours=3))\n    ax.bar(datetime.datetime(2018, 1, 1), 1.,\n           xerr=datetime.timedelta(hours=2),\n           width=datetime.timedelta(hours=3))\n    fig, ax = plt.subplots()\n    ax.barh(datetime.datetime(2018, 1, 1), 1,\n            height=datetime.timedelta(hours=3))\n    ax.barh(datetime.datetime(2018, 1, 1), 1,\n            height=datetime.timedelta(hours=3),\n            yerr=datetime.timedelta(hours=2))\n    fig, ax = plt.subplots()\n    ax.barh([datetime.datetime(2018, 1, 1), datetime.datetime(2018, 1, 1)],\n            np.array([1, 1.5]),\n            height=datetime.timedelta(hours=3))\n    ax.barh([datetime.datetime(2018, 1, 1), datetime.datetime(2018, 1, 1)],\n            np.array([1, 1.5]),\n            height=[datetime.timedelta(hours=t) for t in [1, 2]])\n    ax.broken_barh([(datetime.datetime(2018, 1, 1),\n                     datetime.timedelta(hours=1))],\n                   (10, 20))",
        "begin_line": 1491,
        "end_line": 1514,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_dates_pandas#1517",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_dates_pandas(pd)",
        "snippet": "def test_boxplot_dates_pandas(pd):\n    # smoke test for boxplot and dates in pandas\n    data = np.random.rand(5, 2)\n    years = pd.date_range('1/1/2000',\n                          periods=2, freq=pd.DateOffset(years=1)).year\n    plt.figure()\n    plt.boxplot(data, positions=years)",
        "begin_line": 1517,
        "end_line": 1523,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_pandas#1526",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_pandas(pd)",
        "snippet": "def test_bar_pandas(pd):\n    # Smoke test for pandas\n    df = pd.DataFrame(\n        {'year': [2018, 2018, 2018],\n         'month': [1, 1, 1],\n         'day': [1, 2, 3],\n         'value': [1, 2, 3]})\n    df['date'] = pd.to_datetime(df[['year', 'month', 'day']])\n\n    monthly = df[['date', 'value']].groupby(['date']).sum()\n    dates = monthly.index\n    forecast = monthly['value']\n    baseline = monthly['value']\n\n    fig, ax = plt.subplots()\n    ax.bar(dates, forecast, width=10, align='center')\n    ax.plot(dates, baseline, color='orange', lw=4)",
        "begin_line": 1526,
        "end_line": 1542,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_pandas_indexed#1545",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_pandas_indexed(pd)",
        "snippet": "def test_bar_pandas_indexed(pd):\n    # Smoke test for indexed pandas\n    df = pd.DataFrame({\"x\": [1., 2., 3.], \"width\": [.2, .4, .6]},\n                      index=[1, 2, 3])\n    fig, ax = plt.subplots()\n    ax.bar(df.x, 1., width=df.width)",
        "begin_line": 1545,
        "end_line": 1550,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pandas_minimal_plot#1553",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pandas_minimal_plot(pd)",
        "snippet": "def test_pandas_minimal_plot(pd):\n    # smoke test that series and index objcets do not warn\n    x = pd.Series([1, 2], dtype=\"float64\")\n    plt.plot(x, x)\n    plt.plot(x.index, x)\n    plt.plot(x)\n    plt.plot(x.index)",
        "begin_line": 1553,
        "end_line": 1559,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_log#1563",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_log()",
        "snippet": "def test_hist_log():\n    data0 = np.linspace(0, 1, 200)**3\n    data = np.concatenate([1 - data0, 1 + data0])\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(data, fill=False, log=True)",
        "begin_line": 1563,
        "end_line": 1568,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_log_2#1572",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_log_2(fig_test, fig_ref)",
        "snippet": "def test_hist_log_2(fig_test, fig_ref):\n    axs_test = fig_test.subplots(2, 3)\n    axs_ref = fig_ref.subplots(2, 3)\n    for i, histtype in enumerate([\"bar\", \"step\", \"stepfilled\"]):\n        # Set log scale, then call hist().\n        axs_test[0, i].set_yscale(\"log\")\n        axs_test[0, i].hist(1, 1, histtype=histtype)\n        # Call hist(), then set log scale.\n        axs_test[1, i].hist(1, 1, histtype=histtype)\n        axs_test[1, i].set_yscale(\"log\")\n        # Use hist(..., log=True).\n        for ax in axs_ref[:, i]:\n            ax.hist(1, 1, log=True, histtype=histtype)",
        "begin_line": 1572,
        "end_line": 1584,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_bar_empty#1588",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_bar_empty()",
        "snippet": "def test_hist_bar_empty():\n    # From #3886: creating hist from empty dataset raises ValueError\n    ax = plt.gca()\n    ax.hist([], histtype='bar')",
        "begin_line": 1588,
        "end_line": 1591,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step_empty#1595",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step_empty()",
        "snippet": "def test_hist_step_empty():\n    # From #3886: creating hist from empty dataset raises ValueError\n    ax = plt.gca()\n    ax.hist([], histtype='step')",
        "begin_line": 1595,
        "end_line": 1598,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step_filled#1602",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step_filled()",
        "snippet": "def test_hist_step_filled():\n    np.random.seed(0)\n    x = np.random.randn(1000, 3)\n    n_bins = 10\n\n    kwargs = [{'fill': True}, {'fill': False}, {'fill': None}, {}]*2\n    types = ['step']*4+['stepfilled']*4\n    fig, axs = plt.subplots(nrows=2, ncols=4)\n\n    for kg, _type, ax in zip(kwargs, types, axs.flat):\n        ax.hist(x, n_bins, histtype=_type, stacked=True, **kg)\n        ax.set_title('%s/%s' % (kg, _type))\n        ax.set_ylim(bottom=-50)\n\n    patches = axs[0, 0].patches\n    assert all(p.get_facecolor() == p.get_edgecolor() for p in patches)",
        "begin_line": 1602,
        "end_line": 1617,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_density#1621",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_density()",
        "snippet": "def test_hist_density():\n    np.random.seed(19680801)\n    data = np.random.standard_normal(2000)\n    fig, ax = plt.subplots()\n    ax.hist(data, density=True)",
        "begin_line": 1621,
        "end_line": 1625,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_unequal_bins_density#1628",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_unequal_bins_density()",
        "snippet": "def test_hist_unequal_bins_density():\n    # Test correct behavior of normalized histogram with unequal bins\n    # https://github.com/matplotlib/matplotlib/issues/9557\n    rng = np.random.RandomState(57483)\n    t = rng.randn(100)\n    bins = [-3, -1, -0.5, 0, 1, 5]\n    mpl_heights, _, _ = plt.hist(t, bins=bins, density=True)\n    np_heights, _ = np.histogram(t, bins=bins, density=True)\n    assert_allclose(mpl_heights, np_heights)",
        "begin_line": 1628,
        "end_line": 1636,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_datetime_datasets#1639",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_datetime_datasets()",
        "snippet": "def test_hist_datetime_datasets():\n    data = [[datetime.datetime(2017, 1, 1), datetime.datetime(2017, 1, 1)],\n            [datetime.datetime(2017, 1, 1), datetime.datetime(2017, 1, 2)]]\n    fig, ax = plt.subplots()\n    ax.hist(data, stacked=True)\n    ax.hist(data, stacked=False)",
        "begin_line": 1639,
        "end_line": 1644,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_datetime_datasets_bins#1653",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_datetime_datasets_bins(bins_preprocess)",
        "snippet": "def test_hist_datetime_datasets_bins(bins_preprocess):\n    data = [[datetime.datetime(2019, 1, 5), datetime.datetime(2019, 1, 11),\n             datetime.datetime(2019, 2, 1), datetime.datetime(2019, 3, 1)],\n            [datetime.datetime(2019, 1, 11), datetime.datetime(2019, 2, 5),\n             datetime.datetime(2019, 2, 18), datetime.datetime(2019, 3, 1)]]\n\n    date_edges = [datetime.datetime(2019, 1, 1), datetime.datetime(2019, 2, 1),\n                  datetime.datetime(2019, 3, 1)]\n\n    fig, ax = plt.subplots()\n    _, bins, _ = ax.hist(data, bins=bins_preprocess(date_edges), stacked=True)\n    np.testing.assert_allclose(bins, mpl.dates.date2num(date_edges))\n\n    _, bins, _ = ax.hist(data, bins=bins_preprocess(date_edges), stacked=False)\n    np.testing.assert_allclose(bins, mpl.dates.date2num(date_edges))",
        "begin_line": 1653,
        "end_line": 1667,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_with_empty_input#1674",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_with_empty_input(data, expected_number_of_hists)",
        "snippet": "def test_hist_with_empty_input(data, expected_number_of_hists):\n    hists, _, _ = plt.hist(data)\n    hists = np.asarray(hists)\n\n    if hists.ndim == 1:\n        assert 1 == expected_number_of_hists\n    else:\n        assert hists.shape[0] == expected_number_of_hists",
        "begin_line": 1674,
        "end_line": 1681,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_zorder#1688",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_zorder(histtype, zorder)",
        "snippet": "def test_hist_zorder(histtype, zorder):\n    ax = plt.figure().add_subplot()\n    ax.hist([1, 2], histtype=histtype)\n    assert ax.patches\n    for patch in ax.patches:\n        assert patch.get_zorder() == zorder",
        "begin_line": 1688,
        "end_line": 1693,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.contour_dat#1696",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.contour_dat()",
        "snippet": "def contour_dat():\n    x = np.linspace(-3, 5, 150)\n    y = np.linspace(-3, 5, 120)\n    z = np.cos(x) + np.sin(y[:, np.newaxis])\n    return x, y, z",
        "begin_line": 1696,
        "end_line": 1700,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_contour_hatching#1704",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_contour_hatching()",
        "snippet": "def test_contour_hatching():\n    x, y, z = contour_dat()\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.contourf(x, y, z, 7, hatches=['/', '\\\\', '//', '-'],\n                cmap=plt.get_cmap('gray'),\n                extend='both', alpha=0.5)",
        "begin_line": 1704,
        "end_line": 1710,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_contour_colorbar#1714",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_contour_colorbar()",
        "snippet": "def test_contour_colorbar():\n    x, y, z = contour_dat()\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    cs = ax.contourf(x, y, z, levels=np.arange(-1.8, 1.801, 0.2),\n                     cmap=plt.get_cmap('RdBu'),\n                     vmin=-0.6,\n                     vmax=0.6,\n                     extend='both')\n    cs1 = ax.contour(x, y, z, levels=np.arange(-2.2, -0.599, 0.2),\n                     colors=['y'],\n                     linestyles='solid',\n                     linewidths=2)\n    cs2 = ax.contour(x, y, z, levels=np.arange(0.6, 2.2, 0.2),\n                     colors=['c'],\n                     linewidths=2)\n    cbar = fig.colorbar(cs, ax=ax)\n    cbar.add_lines(cs1)\n    cbar.add_lines(cs2, erase=False)",
        "begin_line": 1714,
        "end_line": 1733,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist2d#1737",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist2d()",
        "snippet": "def test_hist2d():\n    np.random.seed(0)\n    # make it not symmetric in case we switch x and y axis\n    x = np.random.randn(100)*2+5\n    y = np.random.randn(100)-2\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist2d(x, y, bins=10, rasterized=True)\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"x\": x, \"y\": y}\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist2d(\"x\", \"y\", bins=10, data=data, rasterized=True)",
        "begin_line": 1737,
        "end_line": 1750,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist2d_transpose#1754",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist2d_transpose()",
        "snippet": "def test_hist2d_transpose():\n    np.random.seed(0)\n    # make sure the output from np.histogram is transposed before\n    # passing to pcolorfast\n    x = np.array([5]*100)\n    y = np.random.randn(100)-2\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist2d(x, y, bins=10, rasterized=True)",
        "begin_line": 1754,
        "end_line": 1762,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist2d_density#1765",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist2d_density()",
        "snippet": "def test_hist2d_density():\n    x, y = np.random.random((2, 100))\n    ax = plt.figure().subplots()\n    for obj in [ax, plt]:\n        obj.hist2d(x, y, density=True)",
        "begin_line": 1765,
        "end_line": 1769,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_plot#1774",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_plot(self)",
        "snippet": "    def test_scatter_plot(self):\n        data = {\"x\": np.array([3, 4, 2, 6]), \"y\": np.array([2, 5, 2, 3]),\n                \"c\": ['r', 'y', 'b', 'lime'], \"s\": [24, 15, 19, 29],\n                \"c2\": ['0.5', '0.6', '0.7', '0.8']}\n\n        fig, ax = plt.subplots()\n        ax.scatter(data[\"x\"] - 1., data[\"y\"] - 1., c=data[\"c\"], s=data[\"s\"])\n        ax.scatter(data[\"x\"] + 1., data[\"y\"] + 1., c=data[\"c2\"], s=data[\"s\"])\n        ax.scatter(\"x\", \"y\", c=\"c\", s=\"s\", data=data)",
        "begin_line": 1774,
        "end_line": 1782,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_marker#1785",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_marker(self)",
        "snippet": "    def test_scatter_marker(self):\n        fig, (ax0, ax1, ax2) = plt.subplots(ncols=3)\n        ax0.scatter([3, 4, 2, 6], [2, 5, 2, 3],\n                    c=[(1, 0, 0), 'y', 'b', 'lime'],\n                    s=[60, 50, 40, 30],\n                    edgecolors=['k', 'r', 'g', 'b'],\n                    marker='s')\n        ax1.scatter([3, 4, 2, 6], [2, 5, 2, 3],\n                    c=[(1, 0, 0), 'y', 'b', 'lime'],\n                    s=[60, 50, 40, 30],\n                    edgecolors=['k', 'r', 'g', 'b'],\n                    marker=mmarkers.MarkerStyle('o', fillstyle='top'))\n        # unit area ellipse\n        rx, ry = 3, 1\n        area = rx * ry * np.pi\n        theta = np.linspace(0, 2 * np.pi, 21)\n        verts = np.column_stack([np.cos(theta) * rx / area,\n                                 np.sin(theta) * ry / area])\n        ax2.scatter([3, 4, 2, 6], [2, 5, 2, 3],\n                    c=[(1, 0, 0), 'y', 'b', 'lime'],\n                    s=[60, 50, 40, 30],\n                    edgecolors=['k', 'r', 'g', 'b'],\n                    marker=verts)",
        "begin_line": 1785,
        "end_line": 1807,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_2D#1810",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_2D(self)",
        "snippet": "    def test_scatter_2D(self):\n        x = np.arange(3)\n        y = np.arange(2)\n        x, y = np.meshgrid(x, y)\n        z = x + y\n        fig, ax = plt.subplots()\n        ax.scatter(x, y, c=z, s=200, edgecolors='face')",
        "begin_line": 1810,
        "end_line": 1816,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_decimal#1819",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_decimal(self, fig_test, fig_ref)",
        "snippet": "    def test_scatter_decimal(self, fig_test, fig_ref):\n        x0 = np.array([1.5, 8.4, 5.3, 4.2])\n        y0 = np.array([1.1, 2.2, 3.3, 4.4])\n        x = np.array([Decimal(i) for i in x0])\n        y = np.array([Decimal(i) for i in y0])\n        c = ['r', 'y', 'b', 'lime']\n        s = [24, 15, 19, 29]\n        # Test image - scatter plot with Decimal() input\n        ax = fig_test.subplots()\n        ax.scatter(x, y, c=c, s=s)\n        # Reference image\n        ax = fig_ref.subplots()\n        ax.scatter(x0, y0, c=c, s=s)",
        "begin_line": 1819,
        "end_line": 1831,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_color#1833",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_color(self)",
        "snippet": "    def test_scatter_color(self):\n        # Try to catch cases where 'c' kwarg should have been used.\n        with pytest.raises(ValueError):\n            plt.scatter([1, 2], [1, 2], color=[0.1, 0.2])\n        with pytest.raises(ValueError):\n            plt.scatter([1, 2, 3], [1, 2, 3], color=[1, 2, 3])",
        "begin_line": 1833,
        "end_line": 1838,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_size_arg_size#1840",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_size_arg_size(self)",
        "snippet": "    def test_scatter_size_arg_size(self):\n        x = np.arange(4)\n        with pytest.raises(ValueError):\n            plt.scatter(x, x, x[1:])\n        with pytest.raises(ValueError):\n            plt.scatter(x[1:], x[1:], x)",
        "begin_line": 1840,
        "end_line": 1845,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_invalid_color#1848",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_invalid_color(self, fig_test, fig_ref)",
        "snippet": "    def test_scatter_invalid_color(self, fig_test, fig_ref):\n        ax = fig_test.subplots()\n        cmap = plt.get_cmap(\"viridis\", 16)\n        cmap.set_bad(\"k\", 1)\n        # Set a nonuniform size to prevent the last call to `scatter` (plotting\n        # the invalid points separately in fig_ref) from using the marker\n        # stamping fast path, which would result in slightly offset markers.\n        ax.scatter(range(4), range(4),\n                   c=[1, np.nan, 2, np.nan], s=[1, 2, 3, 4],\n                   cmap=cmap, plotnonfinite=True)\n        ax = fig_ref.subplots()\n        cmap = plt.get_cmap(\"viridis\", 16)\n        ax.scatter([0, 2], [0, 2], c=[1, 2], s=[1, 3], cmap=cmap)\n        ax.scatter([1, 3], [1, 3], s=[2, 4], color=\"k\")",
        "begin_line": 1848,
        "end_line": 1861,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_no_invalid_color#1864",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_no_invalid_color(self, fig_test, fig_ref)",
        "snippet": "    def test_scatter_no_invalid_color(self, fig_test, fig_ref):\n        # With plotninfinite=False we plot only 2 points.\n        ax = fig_test.subplots()\n        cmap = plt.get_cmap(\"viridis\", 16)\n        cmap.set_bad(\"k\", 1)\n        ax.scatter(range(4), range(4),\n                   c=[1, np.nan, 2, np.nan], s=[1, 2, 3, 4],\n                   cmap=cmap, plotnonfinite=False)\n        ax = fig_ref.subplots()\n        ax.scatter([0, 2], [0, 2], c=[1, 2], s=[1, 3], cmap=cmap)",
        "begin_line": 1864,
        "end_line": 1873,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_norm_vminvmax#1876",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_norm_vminvmax(self, fig_test, fig_ref)",
        "snippet": "    def test_scatter_norm_vminvmax(self, fig_test, fig_ref):\n        \"\"\"Parameters vmin, vmax should be ignored if norm is given.\"\"\"\n        x = [1, 2, 3]\n        ax = fig_ref.subplots()\n        ax.scatter(x, x, c=x, vmin=0, vmax=5)\n        ax = fig_test.subplots()\n        with pytest.warns(MatplotlibDeprecationWarning,\n                          match=\"Passing parameters norm and vmin/vmax \"\n                                \"simultaneously is deprecated.\"):\n            ax.scatter(x, x, c=x, norm=mcolors.Normalize(-10, 10),\n                       vmin=0, vmax=5)",
        "begin_line": 1876,
        "end_line": 1886,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_single_point#1889",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_single_point(self, fig_test, fig_ref)",
        "snippet": "    def test_scatter_single_point(self, fig_test, fig_ref):\n        ax = fig_test.subplots()\n        ax.scatter(1, 1, c=1)\n        ax = fig_ref.subplots()\n        ax.scatter([1], [1], c=[1])",
        "begin_line": 1889,
        "end_line": 1893,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_different_shapes#1896",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_different_shapes(self, fig_test, fig_ref)",
        "snippet": "    def test_scatter_different_shapes(self, fig_test, fig_ref):\n        x = np.arange(10)\n        ax = fig_test.subplots()\n        ax.scatter(x, x.reshape(2, 5), c=x.reshape(5, 2))\n        ax = fig_ref.subplots()\n        ax.scatter(x.reshape(5, 2), x, c=x.reshape(2, 5))",
        "begin_line": 1896,
        "end_line": 1901,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_c#1950",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_c(self, c_case, re_key)",
        "snippet": "    def test_scatter_c(self, c_case, re_key):\n        def get_next_color():\n            return 'blue'  # currently unused\n\n        xsize = 4\n        # Additional checking of *c* (introduced in #11383).\n        REGEXP = {\n            \"shape\": \"^'c' argument has [0-9]+ elements\",  # shape mismatch\n            \"conversion\": \"^'c' argument must be a color\",  # bad vals\n            }\n\n        if re_key is None:\n            mpl.axes.Axes._parse_scatter_color_args(\n                c=c_case, edgecolors=\"black\", kwargs={}, xsize=xsize,\n                get_next_color_func=get_next_color)\n        else:\n            with pytest.raises(ValueError, match=REGEXP[re_key]):\n                mpl.axes.Axes._parse_scatter_color_args(\n                    c=c_case, edgecolors=\"black\", kwargs={}, xsize=xsize,\n                    get_next_color_func=get_next_color)",
        "begin_line": 1950,
        "end_line": 1969,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.get_next_color#1951",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.get_next_color()",
        "snippet": "        def get_next_color():\n            return 'blue'  # currently unused",
        "begin_line": 1951,
        "end_line": 1952,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_single_color_c#1973",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.TestScatter",
        "signature": "lib.matplotlib.tests.test_axes.TestScatter.test_scatter_single_color_c(self, fig_test, fig_ref)",
        "snippet": "    def test_scatter_single_color_c(self, fig_test, fig_ref):\n        rgb = [[1, 0.5, 0.05]]\n        rgba = [[1, 0.5, 0.05, .5]]\n\n        # set via color kwarg\n        ax_ref = fig_ref.subplots()\n        ax_ref.scatter(np.ones(3), range(3), color=rgb)\n        ax_ref.scatter(np.ones(4)*2, range(4), color=rgba)\n\n        # set via broadcasting via c\n        ax_test = fig_test.subplots()\n        ax_test.scatter(np.ones(3), range(3), c=rgb)\n        ax_test.scatter(np.ones(4)*2, range(4), c=rgba)",
        "begin_line": 1973,
        "end_line": 1985,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes._params#1988",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes._params(c=None, xsize=2, *, edgecolors=None, **kwargs)",
        "snippet": "def _params(c=None, xsize=2, *, edgecolors=None, **kwargs):\n    return (c, edgecolors, kwargs if kwargs is not None else {}, xsize)",
        "begin_line": 1988,
        "end_line": 1989,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_parse_scatter_color_args#2007",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_parse_scatter_color_args(params, expected_result)",
        "snippet": "def test_parse_scatter_color_args(params, expected_result):\n    def get_next_color():\n        return 'blue'  # currently unused\n\n    c, colors, _edgecolors = mpl.axes.Axes._parse_scatter_color_args(\n        *params, get_next_color_func=get_next_color)\n    assert c == expected_result.c\n    assert_allclose(colors, expected_result.colors)",
        "begin_line": 2007,
        "end_line": 2014,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.get_next_color#2008",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.get_next_color()",
        "snippet": "    def get_next_color():\n        return 'blue'  # currently unused",
        "begin_line": 2008,
        "end_line": 2009,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_parse_scatter_color_args_edgecolors#2034",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_parse_scatter_color_args_edgecolors(kwargs, expected_edgecolors)",
        "snippet": "def test_parse_scatter_color_args_edgecolors(kwargs, expected_edgecolors):\n    def get_next_color():\n        return 'blue'  # currently unused\n\n    c = kwargs.pop('c', None)\n    edgecolors = kwargs.pop('edgecolors', None)\n    _, _, result_edgecolors = \\\n        mpl.axes.Axes._parse_scatter_color_args(\n            c, edgecolors, kwargs, xsize=2, get_next_color_func=get_next_color)\n    assert result_edgecolors == expected_edgecolors",
        "begin_line": 2034,
        "end_line": 2043,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.get_next_color#2035",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.get_next_color()",
        "snippet": "    def get_next_color():\n        return 'blue'  # currently unused",
        "begin_line": 2035,
        "end_line": 2036,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_parse_scatter_color_args_error#2046",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_parse_scatter_color_args_error()",
        "snippet": "def test_parse_scatter_color_args_error():\n    def get_next_color():\n        return 'blue'  # currently unused\n\n    with pytest.raises(ValueError,\n                       match=\"RGBA values should be within 0-1 range\"):\n        c = np.array([[0.1, 0.2, 0.7], [0.2, 0.4, 1.4]])  # value > 1\n        mpl.axes.Axes._parse_scatter_color_args(\n            c, None, kwargs={}, xsize=2, get_next_color_func=get_next_color)",
        "begin_line": 2046,
        "end_line": 2054,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.get_next_color#2047",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.get_next_color()",
        "snippet": "    def get_next_color():\n        return 'blue'  # currently unused",
        "begin_line": 2047,
        "end_line": 2048,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_as_mpl_axes_api#2057",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_as_mpl_axes_api()",
        "snippet": "def test_as_mpl_axes_api():\n    # tests the _as_mpl_axes api\n    from matplotlib.projections.polar import PolarAxes\n\n    class Polar:\n        def __init__(self):\n            self.theta_offset = 0\n\n        def _as_mpl_axes(self):\n            # implement the matplotlib axes interface\n            return PolarAxes, {'theta_offset': self.theta_offset}\n\n    prj = Polar()\n    prj2 = Polar()\n    prj2.theta_offset = np.pi\n    prj3 = Polar()\n\n    # testing axes creation with plt.axes\n    ax = plt.axes([0, 0, 1, 1], projection=prj)\n    assert type(ax) == PolarAxes\n    ax_via_gca = plt.gca(projection=prj)\n    assert ax_via_gca is ax\n    plt.close()\n\n    # testing axes creation with gca\n    ax = plt.gca(projection=prj)\n    assert type(ax) == mpl.axes._subplots.subplot_class_factory(PolarAxes)\n    ax_via_gca = plt.gca(projection=prj)\n    assert ax_via_gca is ax\n    # try getting the axes given a different polar projection\n    with pytest.warns(UserWarning) as rec:\n        ax_via_gca = plt.gca(projection=prj2)\n        assert len(rec) == 1\n        assert 'Requested projection is different' in str(rec[0].message)\n    assert ax_via_gca is not ax\n    assert ax.get_theta_offset() == 0\n    assert ax_via_gca.get_theta_offset() == np.pi\n    # try getting the axes given an == (not is) polar projection\n    with pytest.warns(UserWarning):\n        ax_via_gca = plt.gca(projection=prj3)\n        assert len(rec) == 1\n        assert 'Requested projection is different' in str(rec[0].message)\n    assert ax_via_gca is ax\n    plt.close()\n\n    # testing axes creation with subplot\n    ax = plt.subplot(121, projection=prj)\n    assert type(ax) == mpl.axes._subplots.subplot_class_factory(PolarAxes)\n    plt.close()",
        "begin_line": 2057,
        "end_line": 2105,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.Polar.test_as_mpl_axes_api#2057",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.Polar",
        "signature": "lib.matplotlib.tests.test_axes.Polar.test_as_mpl_axes_api()",
        "snippet": "def test_as_mpl_axes_api():\n    # tests the _as_mpl_axes api\n    from matplotlib.projections.polar import PolarAxes\n\n    class Polar:\n        def __init__(self):\n            self.theta_offset = 0\n\n        def _as_mpl_axes(self):\n            # implement the matplotlib axes interface\n            return PolarAxes, {'theta_offset': self.theta_offset}\n\n    prj = Polar()\n    prj2 = Polar()\n    prj2.theta_offset = np.pi\n    prj3 = Polar()\n\n    # testing axes creation with plt.axes\n    ax = plt.axes([0, 0, 1, 1], projection=prj)\n    assert type(ax) == PolarAxes\n    ax_via_gca = plt.gca(projection=prj)\n    assert ax_via_gca is ax\n    plt.close()\n\n    # testing axes creation with gca\n    ax = plt.gca(projection=prj)\n    assert type(ax) == mpl.axes._subplots.subplot_class_factory(PolarAxes)\n    ax_via_gca = plt.gca(projection=prj)\n    assert ax_via_gca is ax\n    # try getting the axes given a different polar projection\n    with pytest.warns(UserWarning) as rec:\n        ax_via_gca = plt.gca(projection=prj2)\n        assert len(rec) == 1\n        assert 'Requested projection is different' in str(rec[0].message)\n    assert ax_via_gca is not ax\n    assert ax.get_theta_offset() == 0\n    assert ax_via_gca.get_theta_offset() == np.pi\n    # try getting the axes given an == (not is) polar projection\n    with pytest.warns(UserWarning):\n        ax_via_gca = plt.gca(projection=prj3)\n        assert len(rec) == 1\n        assert 'Requested projection is different' in str(rec[0].message)\n    assert ax_via_gca is ax\n    plt.close()\n\n    # testing axes creation with subplot\n    ax = plt.subplot(121, projection=prj)\n    assert type(ax) == mpl.axes._subplots.subplot_class_factory(PolarAxes)\n    plt.close()",
        "begin_line": 2057,
        "end_line": 2105,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.Polar.__init__#2062",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.Polar",
        "signature": "lib.matplotlib.tests.test_axes.Polar.__init__(self)",
        "snippet": "        def __init__(self):\n            self.theta_offset = 0",
        "begin_line": 2062,
        "end_line": 2063,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.Polar._as_mpl_axes#2065",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.Polar",
        "signature": "lib.matplotlib.tests.test_axes.Polar._as_mpl_axes(self)",
        "snippet": "        def _as_mpl_axes(self):\n            # implement the matplotlib axes interface\n            return PolarAxes, {'theta_offset': self.theta_offset}",
        "begin_line": 2065,
        "end_line": 2067,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pyplot_axes#2108",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pyplot_axes()",
        "snippet": "def test_pyplot_axes():\n    # test focusing of Axes in other Figure\n    fig1, ax1 = plt.subplots()\n    fig2, ax2 = plt.subplots()\n    plt.sca(ax1)\n    assert ax1 is plt.gca()\n    assert fig1 is plt.gcf()\n    plt.close(fig1)\n    plt.close(fig2)",
        "begin_line": 2108,
        "end_line": 2116,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_log_scales#2120",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_log_scales()",
        "snippet": "def test_log_scales():\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    ax.plot(np.log(np.linspace(0.1, 100)))\n    ax.set_yscale('log', base=5.5)\n    ax.invert_yaxis()\n    ax.set_xscale('log', base=9.0)",
        "begin_line": 2120,
        "end_line": 2126,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_log_scales_no_data#2129",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_log_scales_no_data()",
        "snippet": "def test_log_scales_no_data():\n    _, ax = plt.subplots()\n    ax.set(xscale=\"log\", yscale=\"log\")\n    ax.xaxis.set_major_locator(mticker.MultipleLocator(1))\n    assert ax.get_xlim() == ax.get_ylim() == (1, 10)",
        "begin_line": 2129,
        "end_line": 2133,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_log_scales_invalid#2136",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_log_scales_invalid()",
        "snippet": "def test_log_scales_invalid():\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    ax.set_xscale('log')\n    with pytest.warns(UserWarning, match='Attempted to set non-positive'):\n        ax.set_xlim(-1, 10)\n    ax.set_yscale('log')\n    with pytest.warns(UserWarning, match='Attempted to set non-positive'):\n        ax.set_ylim(-1, 10)",
        "begin_line": 2136,
        "end_line": 2144,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_stackplot#2148",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_stackplot()",
        "snippet": "def test_stackplot():\n    fig = plt.figure()\n    x = np.linspace(0, 10, 10)\n    y1 = 1.0 * x\n    y2 = 2.0 * x + 1\n    y3 = 3.0 * x + 2\n    ax = fig.add_subplot(1, 1, 1)\n    ax.stackplot(x, y1, y2, y3)\n    ax.set_xlim((0, 10))\n    ax.set_ylim((0, 70))\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"x\": x, \"y1\": y1, \"y2\": y2, \"y3\": y3}\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    ax.stackplot(\"x\", \"y1\", \"y2\", \"y3\", data=data)\n    ax.set_xlim((0, 10))\n    ax.set_ylim((0, 70))",
        "begin_line": 2148,
        "end_line": 2165,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_stackplot_baseline#2169",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_stackplot_baseline()",
        "snippet": "def test_stackplot_baseline():\n    np.random.seed(0)\n\n    def layers(n, m):\n        a = np.zeros((m, n))\n        for i in range(n):\n            for j in range(5):\n                x = 1 / (.1 + np.random.random())\n                y = 2 * np.random.random() - .5\n                z = 10 / (.1 + np.random.random())\n                a[:, i] += x * np.exp(-((np.arange(m) / m - y) * z) ** 2)\n        return a\n\n    d = layers(3, 100)\n    d[50, :] = 0  # test for fixed weighted wiggle (issue #6313)\n\n    fig, axs = plt.subplots(2, 2)\n\n    axs[0, 0].stackplot(range(100), d.T, baseline='zero')\n    axs[0, 1].stackplot(range(100), d.T, baseline='sym')\n    axs[1, 0].stackplot(range(100), d.T, baseline='wiggle')\n    axs[1, 1].stackplot(range(100), d.T, baseline='weighted_wiggle')",
        "begin_line": 2169,
        "end_line": 2190,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.layers#2172",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.layers(n, m)",
        "snippet": "    def layers(n, m):\n        a = np.zeros((m, n))\n        for i in range(n):\n            for j in range(5):\n                x = 1 / (.1 + np.random.random())\n                y = 2 * np.random.random() - .5\n                z = 10 / (.1 + np.random.random())\n                a[:, i] += x * np.exp(-((np.arange(m) / m - y) * z) ** 2)\n        return a",
        "begin_line": 2172,
        "end_line": 2180,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes._bxp_test_helper#2193",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes._bxp_test_helper(stats_kwargs={}, transform_stats=lambda s: s, bxp_kwargs={})",
        "snippet": "def _bxp_test_helper(\n        stats_kwargs={}, transform_stats=lambda s: s, bxp_kwargs={}):\n    np.random.seed(937)\n    logstats = mpl.cbook.boxplot_stats(\n        np.random.lognormal(mean=1.25, sigma=1., size=(37, 4)), **stats_kwargs)\n    fig, ax = plt.subplots()\n    if bxp_kwargs.get('vert', True):\n        ax.set_yscale('log')\n    else:\n        ax.set_xscale('log')\n    # Work around baseline images generate back when bxp did not respect the\n    # boxplot.boxprops.linewidth rcParam when patch_artist is False.\n    if not bxp_kwargs.get('patch_artist', False):\n        mpl.rcParams['boxplot.boxprops.linewidth'] = \\\n            mpl.rcParams['lines.linewidth']\n    ax.bxp(transform_stats(logstats), **bxp_kwargs)",
        "begin_line": 2193,
        "end_line": 2208,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_baseline#2214",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_baseline()",
        "snippet": "def test_bxp_baseline():\n    _bxp_test_helper()",
        "begin_line": 2214,
        "end_line": 2215,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_rangewhis#2221",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_rangewhis()",
        "snippet": "def test_bxp_rangewhis():\n    _bxp_test_helper(stats_kwargs=dict(whis=[0, 100]))",
        "begin_line": 2221,
        "end_line": 2222,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_precentilewhis#2228",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_precentilewhis()",
        "snippet": "def test_bxp_precentilewhis():\n    _bxp_test_helper(stats_kwargs=dict(whis=[5, 95]))",
        "begin_line": 2228,
        "end_line": 2229,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_with_xlabels#2235",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_with_xlabels()",
        "snippet": "def test_bxp_with_xlabels():\n    def transform(stats):\n        for s, label in zip(stats, list('ABCD')):\n            s['label'] = label\n        return stats\n\n    _bxp_test_helper(transform_stats=transform)",
        "begin_line": 2235,
        "end_line": 2241,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.transform#2236",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.transform(stats)",
        "snippet": "    def transform(stats):\n        for s, label in zip(stats, list('ABCD')):\n            s['label'] = label\n        return stats",
        "begin_line": 2236,
        "end_line": 2239,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_horizontal#2249",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_horizontal()",
        "snippet": "def test_bxp_horizontal():\n    _bxp_test_helper(bxp_kwargs=dict(vert=False))",
        "begin_line": 2249,
        "end_line": 2250,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_with_ylabels#2257",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_with_ylabels()",
        "snippet": "def test_bxp_with_ylabels():\n    def transform(stats):\n        for s, label in zip(stats, list('ABCD')):\n            s['label'] = label\n        return stats\n\n    _bxp_test_helper(transform_stats=transform, bxp_kwargs=dict(vert=False))",
        "begin_line": 2257,
        "end_line": 2263,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.transform#2258",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.transform(stats)",
        "snippet": "    def transform(stats):\n        for s, label in zip(stats, list('ABCD')):\n            s['label'] = label\n        return stats",
        "begin_line": 2258,
        "end_line": 2261,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_patchartist#2270",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_patchartist()",
        "snippet": "def test_bxp_patchartist():\n    _bxp_test_helper(bxp_kwargs=dict(patch_artist=True))",
        "begin_line": 2270,
        "end_line": 2271,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_custompatchartist#2278",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_custompatchartist()",
        "snippet": "def test_bxp_custompatchartist():\n    _bxp_test_helper(bxp_kwargs=dict(\n        patch_artist=True,\n        boxprops=dict(facecolor='yellow', edgecolor='green', ls=':')))",
        "begin_line": 2278,
        "end_line": 2281,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_customoutlier#2288",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_customoutlier()",
        "snippet": "def test_bxp_customoutlier():\n    _bxp_test_helper(bxp_kwargs=dict(\n        flierprops=dict(linestyle='none', marker='d', mfc='g')))",
        "begin_line": 2288,
        "end_line": 2290,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_showcustommean#2297",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_showcustommean()",
        "snippet": "def test_bxp_showcustommean():\n    _bxp_test_helper(bxp_kwargs=dict(\n        showmeans=True,\n        meanprops=dict(linestyle='none', marker='d', mfc='green'),\n    ))",
        "begin_line": 2297,
        "end_line": 2301,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_custombox#2308",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_custombox()",
        "snippet": "def test_bxp_custombox():\n    _bxp_test_helper(bxp_kwargs=dict(\n        boxprops=dict(linestyle='--', color='b', lw=3)))",
        "begin_line": 2308,
        "end_line": 2310,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_custommedian#2317",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_custommedian()",
        "snippet": "def test_bxp_custommedian():\n    _bxp_test_helper(bxp_kwargs=dict(\n        medianprops=dict(linestyle='--', color='b', lw=3)))",
        "begin_line": 2317,
        "end_line": 2319,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_customcap#2326",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_customcap()",
        "snippet": "def test_bxp_customcap():\n    _bxp_test_helper(bxp_kwargs=dict(\n        capprops=dict(linestyle='--', color='g', lw=3)))",
        "begin_line": 2326,
        "end_line": 2328,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_customwhisker#2335",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_customwhisker()",
        "snippet": "def test_bxp_customwhisker():\n    _bxp_test_helper(bxp_kwargs=dict(\n        whiskerprops=dict(linestyle='-', color='m', lw=3)))",
        "begin_line": 2335,
        "end_line": 2337,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_shownotches#2344",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_shownotches()",
        "snippet": "def test_bxp_shownotches():\n    _bxp_test_helper(bxp_kwargs=dict(shownotches=True))",
        "begin_line": 2344,
        "end_line": 2345,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_nocaps#2352",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_nocaps()",
        "snippet": "def test_bxp_nocaps():\n    _bxp_test_helper(bxp_kwargs=dict(showcaps=False))",
        "begin_line": 2352,
        "end_line": 2353,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_nobox#2360",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_nobox()",
        "snippet": "def test_bxp_nobox():\n    _bxp_test_helper(bxp_kwargs=dict(showbox=False))",
        "begin_line": 2360,
        "end_line": 2361,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_no_flier_stats#2368",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_no_flier_stats()",
        "snippet": "def test_bxp_no_flier_stats():\n    def transform(stats):\n        for s in stats:\n            s.pop('fliers', None)\n        return stats\n\n    _bxp_test_helper(transform_stats=transform,\n                     bxp_kwargs=dict(showfliers=False))",
        "begin_line": 2368,
        "end_line": 2375,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.transform#2369",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.transform(stats)",
        "snippet": "    def transform(stats):\n        for s in stats:\n            s.pop('fliers', None)\n        return stats",
        "begin_line": 2369,
        "end_line": 2372,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_showmean#2382",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_showmean()",
        "snippet": "def test_bxp_showmean():\n    _bxp_test_helper(bxp_kwargs=dict(showmeans=True, meanline=False))",
        "begin_line": 2382,
        "end_line": 2383,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_showmeanasline#2390",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_showmeanasline()",
        "snippet": "def test_bxp_showmeanasline():\n    _bxp_test_helper(bxp_kwargs=dict(showmeans=True, meanline=True))",
        "begin_line": 2390,
        "end_line": 2391,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_scalarwidth#2398",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_scalarwidth()",
        "snippet": "def test_bxp_scalarwidth():\n    _bxp_test_helper(bxp_kwargs=dict(widths=.25))",
        "begin_line": 2398,
        "end_line": 2399,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_customwidths#2406",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_customwidths()",
        "snippet": "def test_bxp_customwidths():\n    _bxp_test_helper(bxp_kwargs=dict(widths=[0.10, 0.25, 0.65, 0.85]))",
        "begin_line": 2406,
        "end_line": 2407,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_custompositions#2414",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_custompositions()",
        "snippet": "def test_bxp_custompositions():\n    _bxp_test_helper(bxp_kwargs=dict(positions=[1, 5, 6, 7]))",
        "begin_line": 2414,
        "end_line": 2415,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_bad_widths#2418",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_bad_widths()",
        "snippet": "def test_bxp_bad_widths():\n    with pytest.raises(ValueError):\n        _bxp_test_helper(bxp_kwargs=dict(widths=[1]))",
        "begin_line": 2418,
        "end_line": 2420,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bxp_bad_positions#2423",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bxp_bad_positions()",
        "snippet": "def test_bxp_bad_positions():\n    with pytest.raises(ValueError):\n        _bxp_test_helper(bxp_kwargs=dict(positions=[2, 3]))",
        "begin_line": 2423,
        "end_line": 2425,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot#2429",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot()",
        "snippet": "def test_boxplot():\n    # Randomness used for bootstrapping.\n    np.random.seed(937)\n\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n\n    ax.boxplot([x, x], bootstrap=10000, notch=1)\n    ax.set_ylim((-30, 30))\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"x\": [x, x]}\n    fig, ax = plt.subplots()\n    ax.boxplot(\"x\", bootstrap=10000, notch=1, data=data)\n    ax.set_ylim((-30, 30))",
        "begin_line": 2429,
        "end_line": 2444,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_sym2#2448",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_sym2()",
        "snippet": "def test_boxplot_sym2():\n    # Randomness used for bootstrapping.\n    np.random.seed(937)\n\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, [ax1, ax2] = plt.subplots(1, 2)\n\n    ax1.boxplot([x, x], bootstrap=10000, sym='^')\n    ax1.set_ylim((-30, 30))\n\n    ax2.boxplot([x, x], bootstrap=10000, sym='g')\n    ax2.set_ylim((-30, 30))",
        "begin_line": 2448,
        "end_line": 2460,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_sym#2467",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_sym()",
        "snippet": "def test_boxplot_sym():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n\n    ax.boxplot([x, x], sym='gs')\n    ax.set_ylim((-30, 30))",
        "begin_line": 2467,
        "end_line": 2473,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_autorange_whiskers#2479",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_autorange_whiskers()",
        "snippet": "def test_boxplot_autorange_whiskers():\n    # Randomness used for bootstrapping.\n    np.random.seed(937)\n\n    x = np.ones(140)\n    x = np.hstack([0, x, 2])\n\n    fig1, ax1 = plt.subplots()\n    ax1.boxplot([x, x], bootstrap=10000, notch=1)\n    ax1.set_ylim((-5, 5))\n\n    fig2, ax2 = plt.subplots()\n    ax2.boxplot([x, x], bootstrap=10000, notch=1, autorange=True)\n    ax2.set_ylim((-5, 5))",
        "begin_line": 2479,
        "end_line": 2492,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes._rc_test_bxp_helper#2495",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes._rc_test_bxp_helper(ax, rc_dict)",
        "snippet": "def _rc_test_bxp_helper(ax, rc_dict):\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    with matplotlib.rc_context(rc_dict):\n        ax.boxplot([x, x])\n    return ax",
        "begin_line": 2495,
        "end_line": 2500,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_rc_parameters#2506",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_rc_parameters()",
        "snippet": "def test_boxplot_rc_parameters():\n    # Randomness used for bootstrapping.\n    np.random.seed(937)\n\n    fig, ax = plt.subplots(3)\n\n    rc_axis0 = {\n        'boxplot.notch': True,\n        'boxplot.whiskers': [5, 95],\n        'boxplot.bootstrap': 10000,\n\n        'boxplot.flierprops.color': 'b',\n        'boxplot.flierprops.marker': 'o',\n        'boxplot.flierprops.markerfacecolor': 'g',\n        'boxplot.flierprops.markeredgecolor': 'b',\n        'boxplot.flierprops.markersize': 5,\n        'boxplot.flierprops.linestyle': '--',\n        'boxplot.flierprops.linewidth': 2.0,\n\n        'boxplot.boxprops.color': 'r',\n        'boxplot.boxprops.linewidth': 2.0,\n        'boxplot.boxprops.linestyle': '--',\n\n        'boxplot.capprops.color': 'c',\n        'boxplot.capprops.linewidth': 2.0,\n        'boxplot.capprops.linestyle': '--',\n\n        'boxplot.medianprops.color': 'k',\n        'boxplot.medianprops.linewidth': 2.0,\n        'boxplot.medianprops.linestyle': '--',\n    }\n\n    rc_axis1 = {\n        'boxplot.vertical': False,\n        'boxplot.whiskers': [0, 100],\n        'boxplot.patchartist': True,\n    }\n\n    rc_axis2 = {\n        'boxplot.whiskers': 2.0,\n        'boxplot.showcaps': False,\n        'boxplot.showbox': False,\n        'boxplot.showfliers': False,\n        'boxplot.showmeans': True,\n        'boxplot.meanline': True,\n\n        'boxplot.meanprops.color': 'c',\n        'boxplot.meanprops.linewidth': 2.0,\n        'boxplot.meanprops.linestyle': '--',\n\n        'boxplot.whiskerprops.color': 'r',\n        'boxplot.whiskerprops.linewidth': 2.0,\n        'boxplot.whiskerprops.linestyle': '-.',\n    }\n    dict_list = [rc_axis0, rc_axis1, rc_axis2]\n    for axis, rc_axis in zip(ax, dict_list):\n        _rc_test_bxp_helper(axis, rc_axis)\n\n    assert (matplotlib.patches.PathPatch in\n            [type(t) for t in ax[1].get_children()])",
        "begin_line": 2506,
        "end_line": 2565,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_with_CIarray#2570",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_with_CIarray()",
        "snippet": "def test_boxplot_with_CIarray():\n    # Randomness used for bootstrapping.\n    np.random.seed(937)\n\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    CIs = np.array([[-1.5, 3.], [-1., 3.5]])\n\n    # show a boxplot with Matplotlib medians and confidence intervals, and\n    # another with manual values\n    ax.boxplot([x, x], bootstrap=10000, usermedians=[None, 1.0],\n               conf_intervals=CIs, notch=1)\n    ax.set_ylim((-30, 30))",
        "begin_line": 2570,
        "end_line": 2584,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_no_weird_whisker#2589",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_no_weird_whisker()",
        "snippet": "def test_boxplot_no_weird_whisker():\n    x = np.array([3, 9000, 150, 88, 350, 200000, 1400, 960],\n                 dtype=np.float64)\n    ax1 = plt.axes()\n    ax1.boxplot(x)\n    ax1.set_yscale('log')\n    ax1.yaxis.grid(False, which='minor')\n    ax1.xaxis.grid(False)",
        "begin_line": 2589,
        "end_line": 2596,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_bad_medians_1#2599",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_bad_medians_1()",
        "snippet": "def test_boxplot_bad_medians_1():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.boxplot(x, usermedians=[1, 2])",
        "begin_line": 2599,
        "end_line": 2604,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_bad_medians_2#2607",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_bad_medians_2()",
        "snippet": "def test_boxplot_bad_medians_2():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.boxplot([x, x], usermedians=[[1, 2], [1, 2]])",
        "begin_line": 2607,
        "end_line": 2612,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_bad_ci_1#2615",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_bad_ci_1()",
        "snippet": "def test_boxplot_bad_ci_1():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.boxplot([x, x], conf_intervals=[[1, 2]])",
        "begin_line": 2615,
        "end_line": 2620,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_zorder#2623",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_zorder()",
        "snippet": "def test_boxplot_zorder():\n    x = np.arange(10)\n    fix, ax = plt.subplots()\n    assert ax.boxplot(x)['boxes'][0].get_zorder() == 2\n    assert ax.boxplot(x, zorder=10)['boxes'][0].get_zorder() == 10",
        "begin_line": 2623,
        "end_line": 2627,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_bad_ci_2#2630",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_bad_ci_2()",
        "snippet": "def test_boxplot_bad_ci_2():\n    x = np.linspace(-7, 7, 140)\n    x = np.hstack([-25, x, 25])\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.boxplot([x, x], conf_intervals=[[1, 2], [1]])",
        "begin_line": 2630,
        "end_line": 2635,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_marker_behavior#2638",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_marker_behavior()",
        "snippet": "def test_boxplot_marker_behavior():\n    plt.rcParams['lines.marker'] = 's'\n    plt.rcParams['boxplot.flierprops.marker'] = 'o'\n    plt.rcParams['boxplot.meanprops.marker'] = '^'\n    fig, ax = plt.subplots()\n    test_data = np.arange(100)\n    test_data[-1] = 150  # a flier point\n    bxp_handle = ax.boxplot(test_data, showmeans=True)\n    for bxp_lines in ['whiskers', 'caps', 'boxes', 'medians']:\n        for each_line in bxp_handle[bxp_lines]:\n            # Ensure that the rcParams['lines.marker'] is overridden by ''\n            assert each_line.get_marker() == ''\n\n    # Ensure that markers for fliers and means aren't overridden with ''\n    assert bxp_handle['fliers'][0].get_marker() == 'o'\n    assert bxp_handle['means'][0].get_marker() == '^'",
        "begin_line": 2638,
        "end_line": 2653,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_mod_artist_after_plotting#2658",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_mod_artist_after_plotting()",
        "snippet": "def test_boxplot_mod_artist_after_plotting():\n    x = [0.15, 0.11, 0.06, 0.06, 0.12, 0.56, -0.56]\n    fig, ax = plt.subplots()\n    bp = ax.boxplot(x, sym=\"o\")\n    for key in bp:\n        for obj in bp[key]:\n            obj.set_color('green')",
        "begin_line": 2658,
        "end_line": 2664,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_baseline#2669",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_baseline()",
        "snippet": "def test_vert_violinplot_baseline():\n    # First 9 digits of frac(sqrt(2))\n    np.random.seed(414213562)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax = plt.axes()\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=0)\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"d\": data}\n    fig, ax = plt.subplots()\n    ax = plt.axes()\n    ax.violinplot(\"d\", positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=0, data=data)",
        "begin_line": 2669,
        "end_line": 2682,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showmeans#2686",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showmeans()",
        "snippet": "def test_vert_violinplot_showmeans():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(3))\n    np.random.seed(732050807)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=1, showextrema=0,\n                  showmedians=0)",
        "begin_line": 2686,
        "end_line": 2692,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showextrema#2696",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showextrema()",
        "snippet": "def test_vert_violinplot_showextrema():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(5))\n    np.random.seed(236067977)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=1,\n                  showmedians=0)",
        "begin_line": 2696,
        "end_line": 2702,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showmedians#2706",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showmedians()",
        "snippet": "def test_vert_violinplot_showmedians():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(7))\n    np.random.seed(645751311)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=1)",
        "begin_line": 2706,
        "end_line": 2712,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showall#2716",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_showall()",
        "snippet": "def test_vert_violinplot_showall():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(11))\n    np.random.seed(316624790)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=1, showextrema=1,\n                  showmedians=1,\n                  quantiles=[[0.1, 0.9], [0.2, 0.8], [0.3, 0.7], [0.4, 0.6]])",
        "begin_line": 2716,
        "end_line": 2723,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_custompoints_10#2727",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_custompoints_10()",
        "snippet": "def test_vert_violinplot_custompoints_10():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(13))\n    np.random.seed(605551275)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=0, points=10)",
        "begin_line": 2727,
        "end_line": 2733,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vert_violinplot_custompoints_200#2737",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vert_violinplot_custompoints_200()",
        "snippet": "def test_vert_violinplot_custompoints_200():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(17))\n    np.random.seed(123105625)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), showmeans=0, showextrema=0,\n                  showmedians=0, points=200)",
        "begin_line": 2737,
        "end_line": 2743,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_baseline#2747",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_baseline()",
        "snippet": "def test_horiz_violinplot_baseline():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(19))\n    np.random.seed(358898943)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=0, showmedians=0)",
        "begin_line": 2747,
        "end_line": 2753,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showmedians#2757",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showmedians()",
        "snippet": "def test_horiz_violinplot_showmedians():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(23))\n    np.random.seed(795831523)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=0, showmedians=1)",
        "begin_line": 2757,
        "end_line": 2763,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showmeans#2767",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showmeans()",
        "snippet": "def test_horiz_violinplot_showmeans():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(29))\n    np.random.seed(385164807)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=1,\n                  showextrema=0, showmedians=0)",
        "begin_line": 2767,
        "end_line": 2773,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showextrema#2777",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showextrema()",
        "snippet": "def test_horiz_violinplot_showextrema():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(31))\n    np.random.seed(567764362)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=1, showmedians=0)",
        "begin_line": 2777,
        "end_line": 2783,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showall#2787",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_showall()",
        "snippet": "def test_horiz_violinplot_showall():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(37))\n    np.random.seed(82762530)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=1,\n                  showextrema=1, showmedians=1,\n                  quantiles=[[0.1, 0.9], [0.2, 0.8], [0.3, 0.7], [0.4, 0.6]])",
        "begin_line": 2787,
        "end_line": 2794,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_custompoints_10#2798",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_custompoints_10()",
        "snippet": "def test_horiz_violinplot_custompoints_10():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(41))\n    np.random.seed(403124237)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=0, showmedians=0, points=10)",
        "begin_line": 2798,
        "end_line": 2804,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_custompoints_200#2808",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_horiz_violinplot_custompoints_200()",
        "snippet": "def test_horiz_violinplot_custompoints_200():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(43))\n    np.random.seed(557438524)\n    data = [np.random.normal(size=100) for i in range(4)]\n    ax.violinplot(data, positions=range(4), vert=False, showmeans=0,\n                  showextrema=0, showmedians=0, points=200)",
        "begin_line": 2808,
        "end_line": 2814,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_violinplot_bad_positions#2817",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_violinplot_bad_positions()",
        "snippet": "def test_violinplot_bad_positions():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(47))\n    np.random.seed(855654600)\n    data = [np.random.normal(size=100) for i in range(4)]\n    with pytest.raises(ValueError):\n        ax.violinplot(data, positions=range(5))",
        "begin_line": 2817,
        "end_line": 2823,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_violinplot_bad_widths#2826",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_violinplot_bad_widths()",
        "snippet": "def test_violinplot_bad_widths():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(53))\n    np.random.seed(280109889)\n    data = [np.random.normal(size=100) for i in range(4)]\n    with pytest.raises(ValueError):\n        ax.violinplot(data, positions=range(4), widths=[1, 2, 3])",
        "begin_line": 2826,
        "end_line": 2832,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_violinplot_bad_quantiles#2835",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_violinplot_bad_quantiles()",
        "snippet": "def test_violinplot_bad_quantiles():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(73))\n    np.random.seed(544003745)\n    data = [np.random.normal(size=100)]\n\n    # Different size quantile list and plots\n    with pytest.raises(ValueError):\n        ax.violinplot(data, quantiles=[[0.1, 0.2], [0.5, 0.7]])",
        "begin_line": 2835,
        "end_line": 2843,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_violinplot_outofrange_quantiles#2846",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_violinplot_outofrange_quantiles()",
        "snippet": "def test_violinplot_outofrange_quantiles():\n    ax = plt.axes()\n    # First 9 digits of frac(sqrt(79))\n    np.random.seed(888194417)\n    data = [np.random.normal(size=100)]\n\n    # Quantile value above 100\n    with pytest.raises(ValueError):\n        ax.violinplot(data, quantiles=[[0.1, 0.2, 0.3, 1.05]])\n\n    # Quantile value below 0\n    with pytest.raises(ValueError):\n        ax.violinplot(data, quantiles=[[-0.05, 0.2, 0.3, 0.75]])",
        "begin_line": 2846,
        "end_line": 2858,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_violinplot_single_list_quantiles#2862",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_violinplot_single_list_quantiles(fig_test, fig_ref)",
        "snippet": "def test_violinplot_single_list_quantiles(fig_test, fig_ref):\n    # Ensures quantile list for 1D can be passed in as single list\n    # First 9 digits of frac(sqrt(83))\n    np.random.seed(110433579)\n    data = [np.random.normal(size=100)]\n\n    # Test image\n    ax = fig_test.subplots()\n    ax.violinplot(data, quantiles=[0.1, 0.3, 0.9])\n\n    # Reference image\n    ax = fig_ref.subplots()\n    ax.violinplot(data, quantiles=[[0.1, 0.3, 0.9]])",
        "begin_line": 2862,
        "end_line": 2874,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_violinplot_pandas_series#2878",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_violinplot_pandas_series(fig_test, fig_ref, pd)",
        "snippet": "def test_violinplot_pandas_series(fig_test, fig_ref, pd):\n    np.random.seed(110433579)\n    s1 = pd.Series(np.random.normal(size=7), index=[9, 8, 7, 6, 5, 4, 3])\n    s2 = pd.Series(np.random.normal(size=9), index=list('ABCDEFGHI'))\n    s3 = pd.Series(np.random.normal(size=11))\n    fig_test.subplots().violinplot([s1, s2, s3])\n    fig_ref.subplots().violinplot([s1.values, s2.values, s3.values])",
        "begin_line": 2878,
        "end_line": 2884,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_manage_xticks#2887",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_manage_xticks()",
        "snippet": "def test_manage_xticks():\n    _, ax = plt.subplots()\n    ax.set_xlim(0, 4)\n    old_xlim = ax.get_xlim()\n    np.random.seed(0)\n    y1 = np.random.normal(10, 3, 20)\n    y2 = np.random.normal(3, 1, 20)\n    ax.boxplot([y1, y2], positions=[1, 2], manage_ticks=False)\n    new_xlim = ax.get_xlim()\n    assert_array_equal(old_xlim, new_xlim)",
        "begin_line": 2887,
        "end_line": 2896,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_boxplot_not_single#2899",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_boxplot_not_single()",
        "snippet": "def test_boxplot_not_single():\n    fig, ax = plt.subplots()\n    ax.boxplot(np.random.rand(100), positions=[3])\n    ax.boxplot(np.random.rand(100), positions=[5])\n    fig.canvas.draw()\n    assert ax.get_xlim() == (2.5, 5.5)\n    assert list(ax.get_xticks()) == [3, 5]\n    assert [t.get_text() for t in ax.get_xticklabels()] == [\"3\", \"5\"]",
        "begin_line": 2899,
        "end_line": 2906,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_tick_space_size_0#2909",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_tick_space_size_0()",
        "snippet": "def test_tick_space_size_0():\n    # allow font size to be zero, which affects ticks when there is\n    # no other text in the figure.\n    plt.plot([0, 1], [0, 1])\n    matplotlib.rcParams.update({'font.size': 0})\n    b = io.BytesIO()\n    plt.savefig(b, dpi=80, format='raw')",
        "begin_line": 2909,
        "end_line": 2915,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar#2919",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar()",
        "snippet": "def test_errorbar():\n    x = np.arange(0.1, 4, 0.5)\n    y = np.exp(-x)\n\n    yerr = 0.1 + 0.2*np.sqrt(x)\n    xerr = 0.1 + yerr\n\n    # First illustrate basic pyplot interface, using defaults where possible.\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.errorbar(x, y, xerr=0.2, yerr=0.4)\n    ax.set_title(\"Simplest errorbars, 0.2 in x, 0.4 in y\")\n\n    # Now switch to a more OO interface to exercise more features.\n    fig, axs = plt.subplots(nrows=2, ncols=2, sharex=True)\n    ax = axs[0, 0]\n    ax.errorbar(x, y, yerr=yerr, fmt='o')\n    ax.set_title('Vert. symmetric')\n\n    # With 4 subplots, reduce the number of axis ticks to avoid crowding.\n    ax.locator_params(nbins=4)\n\n    ax = axs[0, 1]\n    ax.errorbar(x, y, xerr=xerr, fmt='o', alpha=0.4)\n    ax.set_title('Hor. symmetric w/ alpha')\n\n    ax = axs[1, 0]\n    ax.errorbar(x, y, yerr=[yerr, 2*yerr], xerr=[xerr, 2*xerr], fmt='--o')\n    ax.set_title('H, V asymmetric')\n\n    ax = axs[1, 1]\n    ax.set_yscale('log')\n    # Here we have to be careful to keep all y values positive:\n    ylower = np.maximum(1e-2, y - yerr)\n    yerr_lower = y - ylower\n\n    ax.errorbar(x, y, yerr=[yerr_lower, 2*yerr], xerr=xerr,\n                fmt='o', ecolor='g', capthick=2)\n    ax.set_title('Mixed sym., log y')\n\n    fig.suptitle('Variable errorbars')\n\n    # Reuse the first testcase from above for a labeled data test\n    data = {\"x\": x, \"y\": y}\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.errorbar(\"x\", \"y\", xerr=0.2, yerr=0.4, data=data)\n    ax.set_title(\"Simplest errorbars, 0.2 in x, 0.4 in y\")",
        "begin_line": 2919,
        "end_line": 2966,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar_colorcycle#2969",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar_colorcycle()",
        "snippet": "def test_errorbar_colorcycle():\n\n    f, ax = plt.subplots()\n    x = np.arange(10)\n    y = 2*x\n\n    e1, _, _ = ax.errorbar(x, y, c=None)\n    e2, _, _ = ax.errorbar(x, 2*y, c=None)\n    ln1, = ax.plot(x, 4*y)\n\n    assert mcolors.to_rgba(e1.get_color()) == mcolors.to_rgba('C0')\n    assert mcolors.to_rgba(e2.get_color()) == mcolors.to_rgba('C1')\n    assert mcolors.to_rgba(ln1.get_color()) == mcolors.to_rgba('C2')",
        "begin_line": 2969,
        "end_line": 2981,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar_cycle_ecolor#2985",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar_cycle_ecolor(fig_test, fig_ref)",
        "snippet": "def test_errorbar_cycle_ecolor(fig_test, fig_ref):\n    x = np.arange(0.1, 4, 0.5)\n    y = [np.exp(-x+n) for n in range(4)]\n\n    axt = fig_test.subplots()\n    axr = fig_ref.subplots()\n\n    for yi, color in zip(y, ['C0', 'C1', 'C2', 'C3']):\n        axt.errorbar(x, yi, yerr=(yi * 0.25), linestyle='-',\n                     marker='o', ecolor='black')\n        axr.errorbar(x, yi, yerr=(yi * 0.25), linestyle='-',\n                     marker='o', color=color, ecolor='black')",
        "begin_line": 2985,
        "end_line": 2996,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar_shape#2999",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar_shape()",
        "snippet": "def test_errorbar_shape():\n    fig = plt.figure()\n    ax = fig.gca()\n\n    x = np.arange(0.1, 4, 0.5)\n    y = np.exp(-x)\n    yerr1 = 0.1 + 0.2*np.sqrt(x)\n    yerr = np.vstack((yerr1, 2*yerr1)).T\n    xerr = 0.1 + yerr\n\n    with pytest.raises(ValueError):\n        ax.errorbar(x, y, yerr=yerr, fmt='o')\n    with pytest.raises(ValueError):\n        ax.errorbar(x, y, xerr=xerr, fmt='o')\n    with pytest.raises(ValueError):\n        ax.errorbar(x, y, yerr=yerr, xerr=xerr, fmt='o')",
        "begin_line": 2999,
        "end_line": 3014,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar_limits#3018",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar_limits()",
        "snippet": "def test_errorbar_limits():\n    x = np.arange(0.5, 5.5, 0.5)\n    y = np.exp(-x)\n    xerr = 0.1\n    yerr = 0.2\n    ls = 'dotted'\n\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n\n    # standard error bars\n    plt.errorbar(x, y, xerr=xerr, yerr=yerr, ls=ls, color='blue')\n\n    # including upper limits\n    uplims = np.zeros_like(x)\n    uplims[[1, 5, 9]] = True\n    plt.errorbar(x, y+0.5, xerr=xerr, yerr=yerr, uplims=uplims, ls=ls,\n                 color='green')\n\n    # including lower limits\n    lolims = np.zeros_like(x)\n    lolims[[2, 4, 8]] = True\n    plt.errorbar(x, y+1.0, xerr=xerr, yerr=yerr, lolims=lolims, ls=ls,\n                 color='red')\n\n    # including upper and lower limits\n    plt.errorbar(x, y+1.5, marker='o', ms=8, xerr=xerr, yerr=yerr,\n                 lolims=lolims, uplims=uplims, ls=ls, color='magenta')\n\n    # including xlower and xupper limits\n    xerr = 0.2\n    yerr = np.full_like(x, 0.2)\n    yerr[[3, 6]] = 0.3\n    xlolims = lolims\n    xuplims = uplims\n    lolims = np.zeros_like(x)\n    uplims = np.zeros_like(x)\n    lolims[[6]] = True\n    uplims[[3]] = True\n    plt.errorbar(x, y+2.1, marker='o', ms=8, xerr=xerr, yerr=yerr,\n                 xlolims=xlolims, xuplims=xuplims, uplims=uplims,\n                 lolims=lolims, ls='none', mec='blue', capsize=0,\n                 color='cyan')\n    ax.set_xlim((0, 5.5))\n    ax.set_title('Errorbar upper and lower limits')",
        "begin_line": 3018,
        "end_line": 3062,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errobar_nonefmt#3065",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errobar_nonefmt()",
        "snippet": "def test_errobar_nonefmt():\n    # Check that passing 'none' as a format still plots errorbars\n    x = np.arange(5)\n    y = np.arange(5)\n\n    plotline, _, barlines = plt.errorbar(x, y, xerr=1, yerr=1, fmt='none')\n    assert plotline is None\n    for errbar in barlines:\n        assert np.all(errbar.get_color() == mcolors.to_rgba('C0'))",
        "begin_line": 3065,
        "end_line": 3073,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar_with_prop_cycle#3078",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar_with_prop_cycle()",
        "snippet": "def test_errorbar_with_prop_cycle():\n    _cycle = cycler(ls=['--', ':'], marker=['s', 's'], mfc=['k', 'w'])\n    plt.rc(\"axes\", prop_cycle=_cycle)\n    fig, ax = plt.subplots()\n    ax.errorbar(x=[2, 4, 10], y=[3, 2, 4], yerr=0.5)\n    ax.errorbar(x=[2, 4, 10], y=[6, 4, 2], yerr=0.5)",
        "begin_line": 3078,
        "end_line": 3083,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar_offsets#3087",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar_offsets(fig_test, fig_ref)",
        "snippet": "def test_errorbar_offsets(fig_test, fig_ref):\n    x = np.linspace(0, 1, 15)\n    y = x * (1-x)\n    yerr = y/6\n\n    ax_ref = fig_ref.subplots()\n    ax_test = fig_test.subplots()\n\n    for color, shift in zip('rgbk', [0, 0, 2, 7]):\n        y += .02\n\n        # Using feature in question\n        ax_test.errorbar(x, y, yerr, errorevery=(shift, 4),\n                         capsize=4, c=color)\n\n        # Using manual errorbars\n        # n.b. errorbar draws the main plot at z=2.1 by default\n        ax_ref.plot(x, y, c=color, zorder=2.1)\n        ax_ref.errorbar(x[shift::4], y[shift::4], yerr[shift::4],\n                        capsize=4, c=color, fmt='none')",
        "begin_line": 3087,
        "end_line": 3106,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled#3110",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled()",
        "snippet": "def test_hist_stacked_stepfilled():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    d2 = np.linspace(0, 10, 50)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), histtype=\"stepfilled\", stacked=True)\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"x\": (d1, d2)}\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(\"x\", histtype=\"stepfilled\", stacked=True, data=data)",
        "begin_line": 3110,
        "end_line": 3122,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_offset#3126",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_offset()",
        "snippet": "def test_hist_offset():\n    # make some data\n    d1 = np.linspace(0, 10, 50)\n    d2 = np.linspace(1, 3, 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(d1, bottom=5)\n    ax.hist(d2, bottom=15)",
        "begin_line": 3126,
        "end_line": 3133,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step#3137",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step()",
        "snippet": "def test_hist_step():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(d1, histtype=\"step\")\n    ax.set_ylim(0, 10)\n    ax.set_xlim(-1, 5)",
        "begin_line": 3137,
        "end_line": 3144,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step_horiz#3148",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step_horiz()",
        "snippet": "def test_hist_step_horiz():\n    # make some data\n    d1 = np.linspace(0, 10, 50)\n    d2 = np.linspace(1, 3, 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), histtype=\"step\", orientation=\"horizontal\")",
        "begin_line": 3148,
        "end_line": 3154,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_weighted#3158",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_weighted()",
        "snippet": "def test_hist_stacked_weighted():\n    # make some data\n    d1 = np.linspace(0, 10, 50)\n    d2 = np.linspace(1, 3, 20)\n    w1 = np.linspace(0.01, 3.5, 50)\n    w2 = np.linspace(0.05, 2., 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), weights=(w1, w2), histtype=\"stepfilled\", stacked=True)",
        "begin_line": 3158,
        "end_line": 3166,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_stem#3172",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_stem(use_line_collection)",
        "snippet": "def test_stem(use_line_collection):\n    x = np.linspace(0.1, 2 * np.pi, 100)\n    args = (x, np.cos(x))\n    # Label is a single space to force a legend to be drawn, but to avoid any\n    # text being drawn\n    kwargs = dict(linefmt='C2-.', markerfmt='k+', basefmt='C1-.',\n                  label=' ', use_line_collection=use_line_collection)\n\n    fig, ax = plt.subplots()\n    ax.stem(*args, **kwargs)\n\n    ax.legend()",
        "begin_line": 3172,
        "end_line": 3183,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_stem_args#3186",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_stem_args()",
        "snippet": "def test_stem_args():\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n\n    x = list(range(10))\n    y = list(range(10))\n\n    # Test the call signatures\n    ax.stem(y)\n    ax.stem(x, y)\n    ax.stem(x, y, 'r--')\n    ax.stem(x, y, 'r--', basefmt='b--')",
        "begin_line": 3186,
        "end_line": 3197,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_stem_dates#3200",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_stem_dates()",
        "snippet": "def test_stem_dates():\n    fig, ax = plt.subplots(1, 1)\n    xs = [dateutil.parser.parse(\"2013-9-28 11:00:00\"),\n          dateutil.parser.parse(\"2013-9-28 12:00:00\")]\n    ys = [100, 200]\n    ax.stem(xs, ys, \"*-\")",
        "begin_line": 3200,
        "end_line": 3205,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled_alpha#3209",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled_alpha()",
        "snippet": "def test_hist_stacked_stepfilled_alpha():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    d2 = np.linspace(0, 10, 50)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), histtype=\"stepfilled\", stacked=True, alpha=0.5)",
        "begin_line": 3209,
        "end_line": 3215,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_step#3219",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_step()",
        "snippet": "def test_hist_stacked_step():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    d2 = np.linspace(0, 10, 50)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist((d1, d2), histtype=\"step\", stacked=True)",
        "begin_line": 3219,
        "end_line": 3225,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_density#3229",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_density()",
        "snippet": "def test_hist_stacked_density():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    d2 = np.linspace(0, 10, 50)\n    fig, ax = plt.subplots()\n    ax.hist((d1, d2), stacked=True, density=True)",
        "begin_line": 3229,
        "end_line": 3234,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step_bottom#3238",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step_bottom()",
        "snippet": "def test_hist_step_bottom():\n    # make some data\n    d1 = np.linspace(1, 3, 20)\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(d1, bottom=np.arange(10), histtype=\"stepfilled\")",
        "begin_line": 3238,
        "end_line": 3243,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stepfilled_geometry#3246",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stepfilled_geometry()",
        "snippet": "def test_hist_stepfilled_geometry():\n    bins = [0, 1, 2, 3]\n    data = [0, 0, 1, 1, 1, 2]\n    _, _, (polygon, ) = plt.hist(data,\n                                 bins=bins,\n                                 histtype='stepfilled')\n    xy = [[0, 0], [0, 2], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1],\n          [3, 0], [2, 0], [2, 0], [1, 0], [1, 0], [0, 0]]\n    assert_array_equal(polygon.get_xy(), xy)",
        "begin_line": 3246,
        "end_line": 3254,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step_geometry#3257",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step_geometry()",
        "snippet": "def test_hist_step_geometry():\n    bins = [0, 1, 2, 3]\n    data = [0, 0, 1, 1, 1, 2]\n    _, _, (polygon, ) = plt.hist(data,\n                                 bins=bins,\n                                 histtype='step')\n    xy = [[0, 0], [0, 2], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1], [3, 0]]\n    assert_array_equal(polygon.get_xy(), xy)",
        "begin_line": 3257,
        "end_line": 3264,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stepfilled_bottom_geometry#3267",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stepfilled_bottom_geometry()",
        "snippet": "def test_hist_stepfilled_bottom_geometry():\n    bins = [0, 1, 2, 3]\n    data = [0, 0, 1, 1, 1, 2]\n    _, _, (polygon, ) = plt.hist(data,\n                                 bins=bins,\n                                 bottom=[1, 2, 1.5],\n                                 histtype='stepfilled')\n    xy = [[0, 1], [0, 3], [1, 3], [1, 5], [2, 5], [2, 2.5], [3, 2.5],\n          [3, 1.5], [2, 1.5], [2, 2], [1, 2], [1, 1], [0, 1]]\n    assert_array_equal(polygon.get_xy(), xy)",
        "begin_line": 3267,
        "end_line": 3276,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_step_bottom_geometry#3279",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_step_bottom_geometry()",
        "snippet": "def test_hist_step_bottom_geometry():\n    bins = [0, 1, 2, 3]\n    data = [0, 0, 1, 1, 1, 2]\n    _, _, (polygon, ) = plt.hist(data,\n                                 bins=bins,\n                                 bottom=[1, 2, 1.5],\n                                 histtype='step')\n    xy = [[0, 1], [0, 3], [1, 3], [1, 5], [2, 5], [2, 2.5], [3, 2.5], [3, 1.5]]\n    assert_array_equal(polygon.get_xy(), xy)",
        "begin_line": 3279,
        "end_line": 3287,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled_geometry#3290",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled_geometry()",
        "snippet": "def test_hist_stacked_stepfilled_geometry():\n    bins = [0, 1, 2, 3]\n    data_1 = [0, 0, 1, 1, 1, 2]\n    data_2 = [0, 1, 2]\n    _, _, patches = plt.hist([data_1, data_2],\n                             bins=bins,\n                             stacked=True,\n                             histtype='stepfilled')\n\n    assert len(patches) == 2\n\n    polygon,  = patches[0]\n    xy = [[0, 0], [0, 2], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1],\n          [3, 0], [2, 0], [2, 0], [1, 0], [1, 0], [0, 0]]\n    assert_array_equal(polygon.get_xy(), xy)\n\n    polygon,  = patches[1]\n    xy = [[0, 2], [0, 3], [1, 3], [1, 4], [2, 4], [2, 2], [3, 2],\n          [3, 1], [2, 1], [2, 3], [1, 3], [1, 2], [0, 2]]\n    assert_array_equal(polygon.get_xy(), xy)",
        "begin_line": 3290,
        "end_line": 3309,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_step_geometry#3312",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_step_geometry()",
        "snippet": "def test_hist_stacked_step_geometry():\n    bins = [0, 1, 2, 3]\n    data_1 = [0, 0, 1, 1, 1, 2]\n    data_2 = [0, 1, 2]\n    _, _, patches = plt.hist([data_1, data_2],\n                             bins=bins,\n                             stacked=True,\n                             histtype='step')\n\n    assert len(patches) == 2\n\n    polygon,  = patches[0]\n    xy = [[0, 0], [0, 2], [1, 2], [1, 3], [2, 3], [2, 1], [3, 1], [3, 0]]\n    assert_array_equal(polygon.get_xy(), xy)\n\n    polygon,  = patches[1]\n    xy = [[0, 2], [0, 3], [1, 3], [1, 4], [2, 4], [2, 2], [3, 2], [3, 1]]\n    assert_array_equal(polygon.get_xy(), xy)",
        "begin_line": 3312,
        "end_line": 3329,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled_bottom_geometry#3332",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_stepfilled_bottom_geometry()",
        "snippet": "def test_hist_stacked_stepfilled_bottom_geometry():\n    bins = [0, 1, 2, 3]\n    data_1 = [0, 0, 1, 1, 1, 2]\n    data_2 = [0, 1, 2]\n    _, _, patches = plt.hist([data_1, data_2],\n                             bins=bins,\n                             stacked=True,\n                             bottom=[1, 2, 1.5],\n                             histtype='stepfilled')\n\n    assert len(patches) == 2\n\n    polygon,  = patches[0]\n    xy = [[0, 1], [0, 3], [1, 3], [1, 5], [2, 5], [2, 2.5], [3, 2.5],\n          [3, 1.5], [2, 1.5], [2, 2], [1, 2], [1, 1], [0, 1]]\n    assert_array_equal(polygon.get_xy(), xy)\n\n    polygon,  = patches[1]\n    xy = [[0, 3], [0, 4], [1, 4], [1, 6], [2, 6], [2, 3.5], [3, 3.5],\n          [3, 2.5], [2, 2.5], [2, 5], [1, 5], [1, 3], [0, 3]]\n    assert_array_equal(polygon.get_xy(), xy)",
        "begin_line": 3332,
        "end_line": 3352,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_step_bottom_geometry#3355",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_step_bottom_geometry()",
        "snippet": "def test_hist_stacked_step_bottom_geometry():\n    bins = [0, 1, 2, 3]\n    data_1 = [0, 0, 1, 1, 1, 2]\n    data_2 = [0, 1, 2]\n    _, _, patches = plt.hist([data_1, data_2],\n                             bins=bins,\n                             stacked=True,\n                             bottom=[1, 2, 1.5],\n                             histtype='step')\n\n    assert len(patches) == 2\n\n    polygon,  = patches[0]\n    xy = [[0, 1], [0, 3], [1, 3], [1, 5], [2, 5], [2, 2.5], [3, 2.5], [3, 1.5]]\n    assert_array_equal(polygon.get_xy(), xy)\n\n    polygon,  = patches[1]\n    xy = [[0, 3], [0, 4], [1, 4], [1, 6], [2, 6], [2, 3.5], [3, 3.5], [3, 2.5]]\n    assert_array_equal(polygon.get_xy(), xy)",
        "begin_line": 3355,
        "end_line": 3373,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_stacked_bar#3377",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_stacked_bar()",
        "snippet": "def test_hist_stacked_bar():\n    # make some data\n    d = [[100, 100, 100, 100, 200, 320, 450, 80, 20, 600, 310, 800],\n         [20, 23, 50, 11, 100, 420], [120, 120, 120, 140, 140, 150, 180],\n         [60, 60, 60, 60, 300, 300, 5, 5, 5, 5, 10, 300],\n         [555, 555, 555, 30, 30, 30, 30, 30, 100, 100, 100, 100, 30, 30],\n         [30, 30, 30, 30, 400, 400, 400, 400, 400, 400, 400, 400]]\n    colors = [(0.5759849696758961, 1.0, 0.0), (0.0, 1.0, 0.350624650815206),\n              (0.0, 1.0, 0.6549834156005998), (0.0, 0.6569064625276622, 1.0),\n              (0.28302699607823545, 0.0, 1.0), (0.6849123462299822, 0.0, 1.0)]\n    labels = ['green', 'orange', ' yellow', 'magenta', 'black']\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist(d, bins=10, histtype='barstacked', align='mid', color=colors,\n            label=labels)\n    ax.legend(loc='upper right', bbox_to_anchor=(1.0, 1.0), ncol=1)",
        "begin_line": 3377,
        "end_line": 3392,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_emptydata#3395",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_emptydata()",
        "snippet": "def test_hist_emptydata():\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.hist([[], range(10), range(10)], histtype=\"step\")",
        "begin_line": 3395,
        "end_line": 3398,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_labels#3401",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_labels()",
        "snippet": "def test_hist_labels():\n    # test singleton labels OK\n    fig, ax = plt.subplots()\n    l = ax.hist([0, 1], label=0)\n    assert l[2][0].get_label() == '0'\n    l = ax.hist([0, 1], label=[0])\n    assert l[2][0].get_label() == '0'\n    l = ax.hist([0, 1], label=None)\n    assert l[2][0].get_label() == '_nolegend_'\n    l = ax.hist([0, 1], label='0')\n    assert l[2][0].get_label() == '0'\n    l = ax.hist([0, 1], label='00')\n    assert l[2][0].get_label() == '00'",
        "begin_line": 3401,
        "end_line": 3413,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_transparent_markers#3417",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_transparent_markers()",
        "snippet": "def test_transparent_markers():\n    np.random.seed(0)\n    data = np.random.random(50)\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(data, 'D', mfc='none', markersize=100)",
        "begin_line": 3417,
        "end_line": 3423,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_rgba_markers#3427",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_rgba_markers()",
        "snippet": "def test_rgba_markers():\n    fig, axs = plt.subplots(ncols=2)\n    rcolors = [(1, 0, 0, 1), (1, 0, 0, 0.5)]\n    bcolors = [(0, 0, 1, 1), (0, 0, 1, 0.5)]\n    alphas = [None, 0.2]\n    kw = dict(ms=100, mew=20)\n    for i, alpha in enumerate(alphas):\n        for j, rcolor in enumerate(rcolors):\n            for k, bcolor in enumerate(bcolors):\n                axs[i].plot(j+1, k+1, 'o', mfc=bcolor, mec=rcolor,\n                            alpha=alpha, **kw)\n                axs[i].plot(j+1, k+3, 'x', mec=rcolor, alpha=alpha, **kw)\n    for ax in axs:\n        ax.axis([-1, 4, 0, 5])",
        "begin_line": 3427,
        "end_line": 3440,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_mollweide_grid#3444",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_mollweide_grid()",
        "snippet": "def test_mollweide_grid():\n    # test that both horizontal and vertical gridlines appear on the Mollweide\n    # projection\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='mollweide')\n    ax.grid()",
        "begin_line": 3444,
        "end_line": 3449,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_mollweide_forward_inverse_closure#3452",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_mollweide_forward_inverse_closure()",
        "snippet": "def test_mollweide_forward_inverse_closure():\n    # test that the round-trip Mollweide forward->inverse transformation is an\n    # approximate identity\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='mollweide')\n\n    # set up 1-degree grid in longitude, latitude\n    lon = np.linspace(-np.pi, np.pi, 360)\n    lat = np.linspace(-np.pi / 2.0, np.pi / 2.0, 180)\n    lon, lat = np.meshgrid(lon, lat)\n    ll = np.vstack((lon.flatten(), lat.flatten())).T\n\n    # perform forward transform\n    xy = ax.transProjection.transform(ll)\n\n    # perform inverse transform\n    ll2 = ax.transProjection.inverted().transform(xy)\n\n    # compare\n    np.testing.assert_array_almost_equal(ll, ll2, 3)",
        "begin_line": 3452,
        "end_line": 3471,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_mollweide_inverse_forward_closure#3474",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_mollweide_inverse_forward_closure()",
        "snippet": "def test_mollweide_inverse_forward_closure():\n    # test that the round-trip Mollweide inverse->forward transformation is an\n    # approximate identity\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='mollweide')\n\n    # set up grid in x, y\n    x = np.linspace(0, 1, 500)\n    x, y = np.meshgrid(x, x)\n    xy = np.vstack((x.flatten(), y.flatten())).T\n\n    # perform inverse transform\n    ll = ax.transProjection.inverted().transform(xy)\n\n    # perform forward transform\n    xy2 = ax.transProjection.transform(ll)\n\n    # compare\n    np.testing.assert_array_almost_equal(xy, xy2, 3)",
        "begin_line": 3474,
        "end_line": 3492,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_alpha#3496",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_alpha()",
        "snippet": "def test_alpha():\n    np.random.seed(0)\n    data = np.random.random(50)\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n\n    # alpha=.5 markers, solid line\n    ax.plot(data, '-D', color=[1, 0, 0], mfc=[1, 0, 0, .5],\n            markersize=20, lw=10)\n\n    # everything solid by kwarg\n    ax.plot(data + 2, '-D', color=[1, 0, 0, .5], mfc=[1, 0, 0, .5],\n            markersize=20, lw=10,\n            alpha=1)\n\n    # everything alpha=.5 by kwarg\n    ax.plot(data + 4, '-D', color=[1, 0, 0], mfc=[1, 0, 0],\n            markersize=20, lw=10,\n            alpha=.5)\n\n    # everything alpha=.5 by colors\n    ax.plot(data + 6, '-D', color=[1, 0, 0, .5], mfc=[1, 0, 0, .5],\n            markersize=20, lw=10)\n\n    # alpha=.5 line, solid markers\n    ax.plot(data + 8, '-D', color=[1, 0, 0, .5], mfc=[1, 0, 0],\n            markersize=20, lw=10)",
        "begin_line": 3496,
        "end_line": 3523,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eventplot#3527",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eventplot()",
        "snippet": "def test_eventplot():\n    np.random.seed(0)\n\n    data1 = np.random.random([32, 20]).tolist()\n    data2 = np.random.random([6, 20]).tolist()\n    data = data1 + data2\n    num_datasets = len(data)\n\n    colors1 = [[0, 1, .7]] * len(data1)\n    colors2 = [[1, 0, 0],\n               [0, 1, 0],\n               [0, 0, 1],\n               [1, .75, 0],\n               [1, 0, 1],\n               [0, 1, 1]]\n    colors = colors1 + colors2\n\n    lineoffsets1 = 12 + np.arange(0, len(data1)) * .33\n    lineoffsets2 = [-15, -3, 1, 1.5, 6, 10]\n    lineoffsets = lineoffsets1.tolist() + lineoffsets2\n\n    linelengths1 = [.33] * len(data1)\n    linelengths2 = [5, 2, 1, 1, 3, 1.5]\n    linelengths = linelengths1 + linelengths2\n\n    fig = plt.figure()\n    axobj = fig.add_subplot(111)\n    colls = axobj.eventplot(data, colors=colors, lineoffsets=lineoffsets,\n                            linelengths=linelengths)\n\n    num_collections = len(colls)\n    assert num_collections == num_datasets\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"pos\": data, \"c\": colors, \"lo\": lineoffsets, \"ll\": linelengths}\n    fig = plt.figure()\n    axobj = fig.add_subplot(111)\n    colls = axobj.eventplot(\"pos\", colors=\"c\", lineoffsets=\"lo\",\n                            linelengths=\"ll\", data=data)\n    num_collections = len(colls)\n    assert num_collections == num_datasets",
        "begin_line": 3527,
        "end_line": 3567,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eventplot_defaults#3571",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eventplot_defaults()",
        "snippet": "def test_eventplot_defaults():\n    \"\"\"\n    test that eventplot produces the correct output given the default params\n    (see bug #3728)\n    \"\"\"\n    np.random.seed(0)\n\n    data1 = np.random.random([32, 20]).tolist()\n    data2 = np.random.random([6, 20]).tolist()\n    data = data1 + data2\n\n    fig = plt.figure()\n    axobj = fig.add_subplot(111)\n    axobj.eventplot(data)",
        "begin_line": 3571,
        "end_line": 3584,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eventplot_colors#3592",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eventplot_colors(colors)",
        "snippet": "def test_eventplot_colors(colors):\n    \"\"\"Test the *colors* parameter of eventplot. Inspired by issue #8193.\"\"\"\n    data = [[i] for i in range(4)]  # 4 successive events of different nature\n\n    # Build the list of the expected colors\n    expected = [c if c is not None else 'C0' for c in colors]\n    # Convert the list into an array of RGBA values\n    # NB: ['rgbk'] is not a valid argument for to_rgba_array, while 'rgbk' is.\n    if len(expected) == 1:\n        expected = expected[0]\n    expected = np.broadcast_to(mcolors.to_rgba_array(expected), (len(data), 4))\n\n    fig, ax = plt.subplots()\n    if len(colors) == 1:  # tuple with a single string (like '0.5' or 'rgbk')\n        colors = colors[0]\n    collections = ax.eventplot(data, colors=colors)\n\n    for coll, color in zip(collections, expected):\n        assert_allclose(coll.get_color(), color)",
        "begin_line": 3592,
        "end_line": 3610,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eventplot_problem_kwargs#3614",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eventplot_problem_kwargs(recwarn)",
        "snippet": "def test_eventplot_problem_kwargs(recwarn):\n    \"\"\"\n    test that 'singular' versions of LineCollection props raise an\n    IgnoredKeywordWarning rather than overriding the 'plural' versions (e.g.\n    to prevent 'color' from overriding 'colors', see issue #4297)\n    \"\"\"\n    np.random.seed(0)\n\n    data1 = np.random.random([20]).tolist()\n    data2 = np.random.random([10]).tolist()\n    data = [data1, data2]\n\n    fig = plt.figure()\n    axobj = fig.add_subplot(111)\n\n    axobj.eventplot(data,\n                    colors=['r', 'b'],\n                    color=['c', 'm'],\n                    linewidths=[2, 1],\n                    linewidth=[1, 2],\n                    linestyles=['solid', 'dashed'],\n                    linestyle=['dashdot', 'dotted'])\n\n    # check that three IgnoredKeywordWarnings were raised\n    assert len(recwarn) == 3\n    assert all(issubclass(wi.category, MatplotlibDeprecationWarning)\n               for wi in recwarn)",
        "begin_line": 3614,
        "end_line": 3640,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_empty_eventplot#3643",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_empty_eventplot()",
        "snippet": "def test_empty_eventplot():\n    fig, ax = plt.subplots(1, 1)\n    ax.eventplot([[]], colors=[(0.0, 0.0, 0.0, 0.0)])\n    plt.draw()",
        "begin_line": 3643,
        "end_line": 3646,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eventplot_orientation#3652",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eventplot_orientation(data, orientation)",
        "snippet": "def test_eventplot_orientation(data, orientation):\n    \"\"\"Introduced when fixing issue #6412.\"\"\"\n    opts = {} if orientation == \"_empty\" else {'orientation': orientation}\n    fig, ax = plt.subplots(1, 1)\n    with (pytest.warns(MatplotlibDeprecationWarning)\n          if orientation in [None, 'none'] else nullcontext()):\n        ax.eventplot(data, **opts)\n    plt.draw()",
        "begin_line": 3652,
        "end_line": 3659,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_marker_styles#3663",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_marker_styles()",
        "snippet": "def test_marker_styles():\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    for y, marker in enumerate(sorted(matplotlib.markers.MarkerStyle.markers,\n                                      key=lambda x: str(type(x))+str(x))):\n        ax.plot((y % 2)*5 + np.arange(10)*10, np.ones(10)*10*y, linestyle='',\n                marker=marker, markersize=10+y/5, label=marker)",
        "begin_line": 3663,
        "end_line": 3669,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markers_fillstyle_rcparams#3673",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markers_fillstyle_rcparams()",
        "snippet": "def test_markers_fillstyle_rcparams():\n    fig, ax = plt.subplots()\n    x = np.arange(7)\n    for idx, (style, marker) in enumerate(\n            [('top', 's'), ('bottom', 'o'), ('none', '^')]):\n        matplotlib.rcParams['markers.fillstyle'] = style\n        ax.plot(x+idx, marker=marker)",
        "begin_line": 3673,
        "end_line": 3679,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vertex_markers#3683",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vertex_markers()",
        "snippet": "def test_vertex_markers():\n    data = list(range(10))\n    marker_as_tuple = ((-1, -1), (1, -1), (1, 1), (-1, 1))\n    marker_as_list = [(-1, -1), (1, -1), (1, 1), (-1, 1)]\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.plot(data, linestyle='', marker=marker_as_tuple, mfc='k')\n    ax.plot(data[::-1], linestyle='', marker=marker_as_list, mfc='b')\n    ax.set_xlim([-1, 10])\n    ax.set_ylim([-1, 10])",
        "begin_line": 3683,
        "end_line": 3692,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eb_line_zorder#3697",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eb_line_zorder()",
        "snippet": "def test_eb_line_zorder():\n    x = list(range(10))\n\n    # First illustrate basic pyplot interface, using defaults where possible.\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.plot(x, lw=10, zorder=5)\n    ax.axhline(1, color='red', lw=10, zorder=1)\n    ax.axhline(5, color='green', lw=10, zorder=10)\n    ax.axvline(7, color='m', lw=10, zorder=7)\n    ax.axvline(2, color='k', lw=10, zorder=3)\n\n    ax.set_title(\"axvline and axhline zorder test\")\n\n    # Now switch to a more OO interface to exercise more features.\n    fig = plt.figure()\n    ax = fig.gca()\n    x = list(range(10))\n    y = np.zeros(10)\n    yerr = list(range(10))\n    ax.errorbar(x, y, yerr=yerr, zorder=5, lw=5, color='r')\n    for j in range(10):\n        ax.axhline(j, lw=5, color='k', zorder=j)\n        ax.axhline(-j, lw=5, color='k', zorder=j)\n\n    ax.set_title(\"errorbar zorder test\")",
        "begin_line": 3697,
        "end_line": 3722,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axline#3726",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axline(fig_test, fig_ref)",
        "snippet": "def test_axline(fig_test, fig_ref):\n    ax = fig_test.subplots()\n    ax.set(xlim=(-1, 1), ylim=(-1, 1))\n    ax.axline((0, 0), (1, 1))\n    ax.axline((0, 0), (1, 0), color='C1')\n    ax.axline((0, 0.5), (1, 0.5), color='C2')\n    # slopes\n    ax.axline((-0.7, -0.5), slope=0, color='C3')\n    ax.axline((1, -0.5), slope=-0.5, color='C4')\n    ax.axline((-0.5, 1), slope=float('inf'), color='C5')\n\n    ax = fig_ref.subplots()\n    ax.set(xlim=(-1, 1), ylim=(-1, 1))\n    ax.plot([-1, 1], [-1, 1])\n    ax.axhline(0, color='C1')\n    ax.axhline(0.5, color='C2')\n    # slopes\n    ax.axhline(-0.5, color='C3')\n    ax.plot([-1, 1], [0.5, -0.5], color='C4')\n    ax.axvline(-0.5, color='C5')",
        "begin_line": 3726,
        "end_line": 3745,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axline_args#3748",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axline_args()",
        "snippet": "def test_axline_args():\n    \"\"\"Exactly one of *xy2* and *slope* must be specified.\"\"\"\n    fig, ax = plt.subplots()\n    with pytest.raises(TypeError):\n        ax.axline((0, 0))  # missing second parameter\n    with pytest.raises(TypeError):\n        ax.axline((0, 0), (1, 1), slope=1)  # redundant parameters\n    ax.set_xscale('log')\n    with pytest.raises(TypeError):\n        ax.axline((0, 0), slope=1)\n    ax.set_xscale('linear')\n    ax.set_yscale('log')\n    with pytest.raises(TypeError):\n        ax.axline((0, 0), slope=1)",
        "begin_line": 3748,
        "end_line": 3761,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vlines#3766",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vlines()",
        "snippet": "def test_vlines():\n    # normal\n    x1 = [2, 3, 4, 5, 7]\n    y1 = [2, -6, 3, 8, 2]\n    fig1, ax1 = plt.subplots()\n    ax1.vlines(x1, 0, y1, colors='g', linewidth=5)\n\n    # GH #7406\n    x2 = [2, 3, 4, 5, 6, 7]\n    y2 = [2, -6, 3, 8, np.nan, 2]\n    fig2, (ax2, ax3, ax4) = plt.subplots(nrows=3, figsize=(4, 8))\n    ax2.vlines(x2, 0, y2, colors='g', linewidth=5)\n\n    x3 = [2, 3, 4, 5, 6, 7]\n    y3 = [np.nan, 2, -6, 3, 8, 2]\n    ax3.vlines(x3, 0, y3, colors='r', linewidth=3, linestyle='--')\n\n    x4 = [2, 3, 4, 5, 6, 7]\n    y4 = [np.nan, 2, -6, 3, 8, np.nan]\n    ax4.vlines(x4, 0, y4, colors='k', linewidth=2)\n\n    # tweak the x-axis so we can see the lines better\n    for ax in [ax1, ax2, ax3, ax4]:\n        ax.set_xlim(0, 10)\n\n    # check that the y-lims are all automatically the same\n    assert ax1.get_ylim() == ax2.get_ylim()\n    assert ax1.get_ylim() == ax3.get_ylim()\n    assert ax1.get_ylim() == ax4.get_ylim()\n\n    fig3, ax5 = plt.subplots()\n    x5 = np.ma.masked_equal([2, 4, 6, 8, 10, 12], 8)\n    ymin5 = np.ma.masked_equal([0, 1, -1, 0, 2, 1], 2)\n    ymax5 = np.ma.masked_equal([13, 14, 15, 16, 17, 18], 18)\n    ax5.vlines(x5, ymin5, ymax5, colors='k', linewidth=2)\n    ax5.set_xlim(0, 15)",
        "begin_line": 3766,
        "end_line": 3801,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hlines#3806",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hlines()",
        "snippet": "def test_hlines():\n    # normal\n    y1 = [2, 3, 4, 5, 7]\n    x1 = [2, -6, 3, 8, 2]\n    fig1, ax1 = plt.subplots()\n    ax1.hlines(y1, 0, x1, colors='g', linewidth=5)\n\n    # GH #7406\n    y2 = [2, 3, 4, 5, 6, 7]\n    x2 = [2, -6, 3, 8, np.nan, 2]\n    fig2, (ax2, ax3, ax4) = plt.subplots(nrows=3, figsize=(4, 8))\n    ax2.hlines(y2, 0, x2, colors='g', linewidth=5)\n\n    y3 = [2, 3, 4, 5, 6, 7]\n    x3 = [np.nan, 2, -6, 3, 8, 2]\n    ax3.hlines(y3, 0, x3, colors='r', linewidth=3, linestyle='--')\n\n    y4 = [2, 3, 4, 5, 6, 7]\n    x4 = [np.nan, 2, -6, 3, 8, np.nan]\n    ax4.hlines(y4, 0, x4, colors='k', linewidth=2)\n\n    # tweak the y-axis so we can see the lines better\n    for ax in [ax1, ax2, ax3, ax4]:\n        ax.set_ylim(0, 10)\n\n    # check that the x-lims are all automatically the same\n    assert ax1.get_xlim() == ax2.get_xlim()\n    assert ax1.get_xlim() == ax3.get_xlim()\n    assert ax1.get_xlim() == ax4.get_xlim()\n\n    fig3, ax5 = plt.subplots()\n    y5 = np.ma.masked_equal([2, 4, 6, 8, 10, 12], 8)\n    xmin5 = np.ma.masked_equal([0, 1, -1, 0, 2, 1], 2)\n    xmax5 = np.ma.masked_equal([13, 14, 15, 16, 17, 18], 18)\n    ax5.hlines(y5, xmin5, xmax5, colors='k', linewidth=2)\n    ax5.set_ylim(0, 15)",
        "begin_line": 3806,
        "end_line": 3841,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_lines_with_colors#3847",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_lines_with_colors(fig_test, fig_ref, data)",
        "snippet": "def test_lines_with_colors(fig_test, fig_ref, data):\n    test_colors = ['red', 'green', 'blue', 'purple', 'orange']\n    fig_test.add_subplot(2, 1, 1).vlines(data, 0, 1,\n                                         colors=test_colors, linewidth=5)\n    fig_test.add_subplot(2, 1, 2).hlines(data, 0, 1,\n                                         colors=test_colors, linewidth=5)\n\n    expect_xy = [1, 2, 3, 5]\n    expect_color = ['red', 'green', 'blue', 'orange']\n    fig_ref.add_subplot(2, 1, 1).vlines(expect_xy, 0, 1,\n                                        colors=expect_color, linewidth=5)\n    fig_ref.add_subplot(2, 1, 2).hlines(expect_xy, 0, 1,\n                                        colors=expect_color, linewidth=5)",
        "begin_line": 3847,
        "end_line": 3859,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_step_linestyle#3863",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_step_linestyle()",
        "snippet": "def test_step_linestyle():\n    x = y = np.arange(10)\n\n    # First illustrate basic pyplot interface, using defaults where possible.\n    fig, ax_lst = plt.subplots(2, 2)\n    ax_lst = ax_lst.flatten()\n\n    ln_styles = ['-', '--', '-.', ':']\n\n    for ax, ls in zip(ax_lst, ln_styles):\n        ax.step(x, y, lw=5, linestyle=ls, where='pre')\n        ax.step(x, y + 1, lw=5, linestyle=ls, where='mid')\n        ax.step(x, y + 2, lw=5, linestyle=ls, where='post')\n        ax.set_xlim([-1, 5])\n        ax.set_ylim([-1, 7])\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"X\": x, \"Y0\": y, \"Y1\": y+1, \"Y2\": y+2}\n    fig, ax_lst = plt.subplots(2, 2)\n    ax_lst = ax_lst.flatten()\n    ln_styles = ['-', '--', '-.', ':']\n    for ax, ls in zip(ax_lst, ln_styles):\n        ax.step(\"X\", \"Y0\", lw=5, linestyle=ls, where='pre', data=data)\n        ax.step(\"X\", \"Y1\", lw=5, linestyle=ls, where='mid', data=data)\n        ax.step(\"X\", \"Y2\", lw=5, linestyle=ls, where='post', data=data)\n        ax.set_xlim([-1, 5])\n        ax.set_ylim([-1, 7])",
        "begin_line": 3863,
        "end_line": 3889,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_mixed_collection#3893",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_mixed_collection()",
        "snippet": "def test_mixed_collection():\n    # First illustrate basic pyplot interface, using defaults where possible.\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n\n    c = mpatches.Circle((8, 8), radius=4, facecolor='none', edgecolor='green')\n\n    # PDF can optimize this one\n    p1 = mpl.collections.PatchCollection([c], match_original=True)\n    p1.set_offsets([[0, 0], [24, 24]])\n    p1.set_linewidths([1, 5])\n\n    # PDF can't optimize this one, because the alpha of the edge changes\n    p2 = mpl.collections.PatchCollection([c], match_original=True)\n    p2.set_offsets([[48, 0], [-32, -16]])\n    p2.set_linewidths([1, 5])\n    p2.set_edgecolors([[0, 0, 0.1, 1.0], [0, 0, 0.1, 0.5]])\n\n    ax.patch.set_color('0.5')\n    ax.add_collection(p1)\n    ax.add_collection(p2)\n\n    ax.set_xlim(0, 16)\n    ax.set_ylim(0, 16)",
        "begin_line": 3893,
        "end_line": 3916,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_subplot_key_hash#3919",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_subplot_key_hash()",
        "snippet": "def test_subplot_key_hash():\n    ax = plt.subplot(np.int32(5), np.int64(1), 1)\n    ax.twinx()\n    assert ax.get_subplotspec().get_geometry() == (5, 1, 0, 0)",
        "begin_line": 3919,
        "end_line": 3922,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram#3929",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram()",
        "snippet": "def test_specgram():\n    \"\"\"Test axes.specgram in default (psd) mode.\"\"\"\n\n    # use former defaults to match existing baseline image\n    matplotlib.rcParams['image.interpolation'] = 'nearest'\n\n    n = 1000\n    Fs = 10.\n\n    fstims = [[Fs/4, Fs/5, Fs/11], [Fs/4.7, Fs/5.6, Fs/11.9]]\n    NFFT_freqs = int(10 * Fs / np.min(fstims))\n    x = np.arange(0, n, 1/Fs)\n    y_freqs = np.concatenate(\n        np.sin(2 * np.pi * np.multiply.outer(fstims, x)).sum(axis=1))\n\n    NFFT_noise = int(10 * Fs / 11)\n    np.random.seed(0)\n    y_noise = np.concatenate([np.random.standard_normal(n), np.random.rand(n)])\n\n    all_sides = [\"default\", \"onesided\", \"twosided\"]\n    for y, NFFT in [(y_freqs, NFFT_freqs), (y_noise, NFFT_noise)]:\n        noverlap = NFFT // 2\n        pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n        for ax, sides in zip(plt.figure().subplots(3), all_sides):\n            ax.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                        pad_to=pad_to, sides=sides)\n        for ax, sides in zip(plt.figure().subplots(3), all_sides):\n            ax.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                        pad_to=pad_to, sides=sides,\n                        scale=\"linear\", norm=matplotlib.colors.LogNorm())",
        "begin_line": 3929,
        "end_line": 3958,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_magnitude#3965",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_magnitude()",
        "snippet": "def test_specgram_magnitude():\n    \"\"\"Test axes.specgram in magnitude mode.\"\"\"\n\n    # use former defaults to match existing baseline image\n    matplotlib.rcParams['image.interpolation'] = 'nearest'\n\n    n = 1000\n    Fs = 10.\n\n    fstims = [[Fs/4, Fs/5, Fs/11], [Fs/4.7, Fs/5.6, Fs/11.9]]\n    NFFT_freqs = int(100 * Fs / np.min(fstims))\n    x = np.arange(0, n, 1/Fs)\n    y = np.sin(2 * np.pi * np.multiply.outer(fstims, x)).sum(axis=1)\n    y[:, -1] = 1\n    y_freqs = np.hstack(y)\n\n    NFFT_noise = int(10 * Fs / 11)\n    np.random.seed(0)\n    y_noise = np.concatenate([np.random.standard_normal(n), np.random.rand(n)])\n\n    all_sides = [\"default\", \"onesided\", \"twosided\"]\n    for y, NFFT in [(y_freqs, NFFT_freqs), (y_noise, NFFT_noise)]:\n        noverlap = NFFT // 2\n        pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n        for ax, sides in zip(plt.figure().subplots(3), all_sides):\n            ax.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                        pad_to=pad_to, sides=sides, mode=\"magnitude\")\n        for ax, sides in zip(plt.figure().subplots(3), all_sides):\n            ax.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                        pad_to=pad_to, sides=sides, mode=\"magnitude\",\n                        scale=\"linear\", norm=matplotlib.colors.LogNorm())",
        "begin_line": 3965,
        "end_line": 3995,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_angle#4002",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_angle()",
        "snippet": "def test_specgram_angle():\n    \"\"\"Test axes.specgram in angle and phase modes.\"\"\"\n\n    # use former defaults to match existing baseline image\n    matplotlib.rcParams['image.interpolation'] = 'nearest'\n\n    n = 1000\n    Fs = 10.\n\n    fstims = [[Fs/4, Fs/5, Fs/11], [Fs/4.7, Fs/5.6, Fs/11.9]]\n    NFFT_freqs = int(10 * Fs / np.min(fstims))\n    x = np.arange(0, n, 1/Fs)\n    y = np.sin(2 * np.pi * np.multiply.outer(fstims, x)).sum(axis=1)\n    y[:, -1] = 1\n    y_freqs = np.hstack(y)\n\n    NFFT_noise = int(10 * Fs / 11)\n    np.random.seed(0)\n    y_noise = np.concatenate([np.random.standard_normal(n), np.random.rand(n)])\n\n    all_sides = [\"default\", \"onesided\", \"twosided\"]\n    for y, NFFT in [(y_freqs, NFFT_freqs), (y_noise, NFFT_noise)]:\n        noverlap = NFFT // 2\n        pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n        for mode in [\"angle\", \"phase\"]:\n            for ax, sides in zip(plt.figure().subplots(3), all_sides):\n                ax.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                            pad_to=pad_to, sides=sides, mode=mode)\n                with pytest.raises(ValueError):\n                    ax.specgram(y, NFFT=NFFT, Fs=Fs, noverlap=noverlap,\n                                pad_to=pad_to, sides=sides, mode=mode,\n                                scale=\"dB\")",
        "begin_line": 4002,
        "end_line": 4033,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_specgram_fs_none#4036",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_specgram_fs_none()",
        "snippet": "def test_specgram_fs_none():\n    \"\"\"Test axes.specgram when Fs is None, should not throw error.\"\"\"\n    spec, freqs, t, im = plt.specgram(np.ones(300), Fs=None)\n    xmin, xmax, freq0, freq1 = im.get_extent()\n    assert xmin == 32 and xmax == 96",
        "begin_line": 4036,
        "end_line": 4040,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_psd_csd#4046",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_psd_csd()",
        "snippet": "def test_psd_csd():\n    n = 10000\n    Fs = 100.\n\n    fstims = [[Fs/4, Fs/5, Fs/11], [Fs/4.7, Fs/5.6, Fs/11.9]]\n    NFFT_freqs = int(1000 * Fs / np.min(fstims))\n    x = np.arange(0, n, 1/Fs)\n    ys_freqs = np.sin(2 * np.pi * np.multiply.outer(fstims, x)).sum(axis=1)\n\n    NFFT_noise = int(1000 * Fs / 11)\n    np.random.seed(0)\n    ys_noise = [np.random.standard_normal(n), np.random.rand(n)]\n\n    all_kwargs = [{\"sides\": \"default\"},\n                  {\"sides\": \"onesided\", \"return_line\": False},\n                  {\"sides\": \"twosided\", \"return_line\": True}]\n    for ys, NFFT in [(ys_freqs, NFFT_freqs), (ys_noise, NFFT_noise)]:\n        noverlap = NFFT // 2\n        pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n        for ax, kwargs in zip(plt.figure().subplots(3), all_kwargs):\n            ret = ax.psd(np.concatenate(ys), NFFT=NFFT, Fs=Fs,\n                         noverlap=noverlap, pad_to=pad_to, **kwargs)\n            assert len(ret) == 2 + kwargs.get(\"return_line\", False)\n            ax.set(xlabel=\"\", ylabel=\"\")\n        for ax, kwargs in zip(plt.figure().subplots(3), all_kwargs):\n            ret = ax.csd(*ys, NFFT=NFFT, Fs=Fs,\n                         noverlap=noverlap, pad_to=pad_to, **kwargs)\n            assert len(ret) == 2 + kwargs.get(\"return_line\", False)\n            ax.set(xlabel=\"\", ylabel=\"\")",
        "begin_line": 4046,
        "end_line": 4074,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_spectrum#4087",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_spectrum()",
        "snippet": "def test_spectrum():\n    n = 10000\n    Fs = 100.\n\n    fstims1 = [Fs/4, Fs/5, Fs/11]\n    NFFT = int(1000 * Fs / min(fstims1))\n    pad_to = int(2 ** np.ceil(np.log2(NFFT)))\n\n    x = np.arange(0, n, 1/Fs)\n    y_freqs = ((np.sin(2 * np.pi * np.outer(x, fstims1)) * 10**np.arange(3))\n               .sum(axis=1))\n    np.random.seed(0)\n    y_noise = np.hstack([np.random.standard_normal(n), np.random.rand(n)]) - .5\n\n    all_sides = [\"default\", \"onesided\", \"twosided\"]\n    kwargs = {\"Fs\": Fs, \"pad_to\": pad_to}\n    for y in [y_freqs, y_noise]:\n        for ax, sides in zip(plt.figure().subplots(3), all_sides):\n            spec, freqs, line = ax.magnitude_spectrum(y, sides=sides, **kwargs)\n            ax.set(xlabel=\"\", ylabel=\"\")\n        for ax, sides in zip(plt.figure().subplots(3), all_sides):\n            spec, freqs, line = ax.magnitude_spectrum(y, sides=sides, **kwargs,\n                                                      scale=\"dB\")\n            ax.set(xlabel=\"\", ylabel=\"\")\n        for ax, sides in zip(plt.figure().subplots(3), all_sides):\n            spec, freqs, line = ax.angle_spectrum(y, sides=sides, **kwargs)\n            ax.set(xlabel=\"\", ylabel=\"\")\n        for ax, sides in zip(plt.figure().subplots(3), all_sides):\n            spec, freqs, line = ax.phase_spectrum(y, sides=sides, **kwargs)\n            ax.set(xlabel=\"\", ylabel=\"\")",
        "begin_line": 4087,
        "end_line": 4116,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twin_spines#4120",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twin_spines()",
        "snippet": "def test_twin_spines():\n\n    def make_patch_spines_invisible(ax):\n        ax.set_frame_on(True)\n        ax.patch.set_visible(False)\n        for sp in ax.spines.values():\n            sp.set_visible(False)\n\n    fig = plt.figure(figsize=(4, 3))\n    fig.subplots_adjust(right=0.75)\n\n    host = fig.add_subplot(111)\n    par1 = host.twinx()\n    par2 = host.twinx()\n\n    # Offset the right spine of par2.  The ticks and label have already been\n    # placed on the right by twinx above.\n    par2.spines[\"right\"].set_position((\"axes\", 1.2))\n    # Having been created by twinx, par2 has its frame off, so the line of\n    # its detached spine is invisible.  First, activate the frame but make\n    # the patch and spines invisible.\n    make_patch_spines_invisible(par2)\n    # Second, show the right spine.\n    par2.spines[\"right\"].set_visible(True)\n\n    p1, = host.plot([0, 1, 2], [0, 1, 2], \"b-\")\n    p2, = par1.plot([0, 1, 2], [0, 3, 2], \"r-\")\n    p3, = par2.plot([0, 1, 2], [50, 30, 15], \"g-\")\n\n    host.set_xlim(0, 2)\n    host.set_ylim(0, 2)\n    par1.set_ylim(0, 4)\n    par2.set_ylim(1, 65)\n\n    host.yaxis.label.set_color(p1.get_color())\n    par1.yaxis.label.set_color(p2.get_color())\n    par2.yaxis.label.set_color(p3.get_color())\n\n    tkw = dict(size=4, width=1.5)\n    host.tick_params(axis='y', colors=p1.get_color(), **tkw)\n    par1.tick_params(axis='y', colors=p2.get_color(), **tkw)\n    par2.tick_params(axis='y', colors=p3.get_color(), **tkw)\n    host.tick_params(axis='x', **tkw)",
        "begin_line": 4120,
        "end_line": 4162,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.make_patch_spines_invisible#4122",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.make_patch_spines_invisible(ax)",
        "snippet": "    def make_patch_spines_invisible(ax):\n        ax.set_frame_on(True)\n        ax.patch.set_visible(False)\n        for sp in ax.spines.values():\n            sp.set_visible(False)",
        "begin_line": 4122,
        "end_line": 4126,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twin_spines_on_top#4167",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twin_spines_on_top()",
        "snippet": "def test_twin_spines_on_top():\n    matplotlib.rcParams['axes.linewidth'] = 48.0\n    matplotlib.rcParams['lines.linewidth'] = 48.0\n\n    fig = plt.figure()\n    ax1 = fig.add_subplot(1, 1, 1)\n\n    data = np.array([[1000, 1100, 1200, 1250],\n                     [310, 301, 360, 400]])\n\n    ax2 = ax1.twinx()\n\n    ax1.plot(data[0], data[1]/1E3, color='#BEAED4')\n    ax1.fill_between(data[0], data[1]/1E3, color='#BEAED4', alpha=.8)\n\n    ax2.plot(data[0], data[1]/1E3, color='#7FC97F')\n    ax2.fill_between(data[0], data[1]/1E3, color='#7FC97F', alpha=.5)\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"i\": data[0], \"j\": data[1]/1E3}\n    fig = plt.figure()\n    ax1 = fig.add_subplot(1, 1, 1)\n    ax2 = ax1.twinx()\n    ax1.plot(\"i\", \"j\", color='#BEAED4', data=data)\n    ax1.fill_between(\"i\", \"j\", color='#BEAED4', alpha=.8, data=data)\n    ax2.plot(\"i\", \"j\", color='#7FC97F', data=data)\n    ax2.fill_between(\"i\", \"j\", color='#7FC97F', alpha=.5, data=data)",
        "begin_line": 4167,
        "end_line": 4193,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_rcparam_grid_minor#4196",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_rcparam_grid_minor()",
        "snippet": "def test_rcparam_grid_minor():\n    orig_grid = matplotlib.rcParams['axes.grid']\n    orig_locator = matplotlib.rcParams['axes.grid.which']\n\n    matplotlib.rcParams['axes.grid'] = True\n\n    values = (\n        (('both'), (True, True)),\n        (('major'), (True, False)),\n        (('minor'), (False, True))\n        )\n\n    for locator, result in values:\n        matplotlib.rcParams['axes.grid.which'] = locator\n        fig = plt.figure()\n        ax = fig.add_subplot(1, 1, 1)\n        assert (ax.xaxis._gridOnMajor, ax.xaxis._gridOnMinor) == result\n\n    matplotlib.rcParams['axes.grid'] = orig_grid\n    matplotlib.rcParams['axes.grid.which'] = orig_locator",
        "begin_line": 4196,
        "end_line": 4215,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_vline_limit#4218",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_vline_limit()",
        "snippet": "def test_vline_limit():\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.axvline(0.5)\n    ax.plot([-0.1, 0, 0.2, 0.1])\n    (ymin, ymax) = ax.get_ylim()\n    assert_allclose(ax.get_ylim(), (-.1, .2))",
        "begin_line": 4218,
        "end_line": 4224,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_empty_shared_subplots#4227",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_empty_shared_subplots()",
        "snippet": "def test_empty_shared_subplots():\n    # empty plots with shared axes inherit limits from populated plots\n    fig, axs = plt.subplots(nrows=1, ncols=2, sharex=True, sharey=True)\n    axs[0].plot([1, 2, 3], [2, 4, 6])\n    x0, x1 = axs[1].get_xlim()\n    y0, y1 = axs[1].get_ylim()\n    assert x0 <= 1\n    assert x1 >= 3\n    assert y0 <= 2\n    assert y1 >= 6",
        "begin_line": 4227,
        "end_line": 4236,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shared_with_aspect_1#4239",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shared_with_aspect_1()",
        "snippet": "def test_shared_with_aspect_1():\n    # allow sharing one axis\n    for adjustable in ['box', 'datalim']:\n        fig, axs = plt.subplots(nrows=2, sharex=True)\n        axs[0].set_aspect(2, adjustable=adjustable, share=True)\n        assert axs[1].get_aspect() == 2\n        assert axs[1].get_adjustable() == adjustable\n\n        fig, axs = plt.subplots(nrows=2, sharex=True)\n        axs[0].set_aspect(2, adjustable=adjustable)\n        assert axs[1].get_aspect() == 'auto'",
        "begin_line": 4239,
        "end_line": 4249,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shared_with_aspect_2#4252",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shared_with_aspect_2()",
        "snippet": "def test_shared_with_aspect_2():\n    # Share 2 axes only with 'box':\n    fig, axs = plt.subplots(nrows=2, sharex=True, sharey=True)\n    axs[0].set_aspect(2, share=True)\n    axs[0].plot([1, 2], [3, 4])\n    axs[1].plot([3, 4], [1, 2])\n    plt.draw()  # Trigger apply_aspect().\n    assert axs[0].get_xlim() == axs[1].get_xlim()\n    assert axs[0].get_ylim() == axs[1].get_ylim()",
        "begin_line": 4252,
        "end_line": 4260,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shared_with_aspect_3#4263",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shared_with_aspect_3()",
        "snippet": "def test_shared_with_aspect_3():\n    # Different aspect ratios:\n    for adjustable in ['box', 'datalim']:\n        fig, axs = plt.subplots(nrows=2, sharey=True)\n        axs[0].set_aspect(2, adjustable=adjustable)\n        axs[1].set_aspect(0.5, adjustable=adjustable)\n        axs[0].plot([1, 2], [3, 4])\n        axs[1].plot([3, 4], [1, 2])\n        plt.draw()  # Trigger apply_aspect().\n        assert axs[0].get_xlim() != axs[1].get_xlim()\n        assert axs[0].get_ylim() == axs[1].get_ylim()\n        fig_aspect = fig.bbox_inches.height / fig.bbox_inches.width\n        for ax in axs:\n            p = ax.get_position()\n            box_aspect = p.height / p.width\n            lim_aspect = ax.viewLim.height / ax.viewLim.width\n            expected = fig_aspect * box_aspect / lim_aspect\n            assert round(expected, 4) == round(ax.get_aspect(), 4)",
        "begin_line": 4263,
        "end_line": 4280,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twin_with_aspect#4284",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twin_with_aspect(twin)",
        "snippet": "def test_twin_with_aspect(twin):\n    fig, ax = plt.subplots()\n    # test twinx or twiny\n    ax_twin = getattr(ax, 'twin{}'.format(twin))()\n    ax.set_aspect(5)\n    ax_twin.set_aspect(2)\n    assert_array_equal(ax.bbox.extents,\n                       ax_twin.bbox.extents)",
        "begin_line": 4284,
        "end_line": 4291,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_relim_visible_only#4294",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_relim_visible_only()",
        "snippet": "def test_relim_visible_only():\n    x1 = (0., 10.)\n    y1 = (0., 10.)\n    x2 = (-10., 20.)\n    y2 = (-10., 30.)\n\n    fig = matplotlib.figure.Figure()\n    ax = fig.add_subplot(111)\n    ax.plot(x1, y1)\n    assert ax.get_xlim() == x1\n    assert ax.get_ylim() == y1\n    l = ax.plot(x2, y2)\n    assert ax.get_xlim() == x2\n    assert ax.get_ylim() == y2\n    l[0].set_visible(False)\n    assert ax.get_xlim() == x2\n    assert ax.get_ylim() == y2\n\n    ax.relim(visible_only=True)\n    ax.autoscale_view()\n\n    assert ax.get_xlim() == x1\n    assert ax.get_ylim() == y1",
        "begin_line": 4294,
        "end_line": 4316,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_text_labelsize#4319",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_text_labelsize()",
        "snippet": "def test_text_labelsize():\n    \"\"\"\n    tests for issue #1172\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.tick_params(labelsize='large')\n    ax.tick_params(direction='out')",
        "begin_line": 4319,
        "end_line": 4326,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_default#4330",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_default()",
        "snippet": "def test_pie_default():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n    fig1, ax1 = plt.subplots(figsize=(8, 6))\n    ax1.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90)",
        "begin_line": 4330,
        "end_line": 4338,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_linewidth_0#4343",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_linewidth_0()",
        "snippet": "def test_pie_linewidth_0():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0})\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')\n\n    # Reuse testcase from above for a labeled data test\n    data = {\"l\": labels, \"s\": sizes, \"c\": colors, \"ex\": explode}\n    fig = plt.figure()\n    ax = fig.gca()\n    ax.pie(\"s\", explode=\"ex\", labels=\"l\", colors=\"c\",\n           autopct='%1.1f%%', shadow=True, startangle=90,\n           wedgeprops={'linewidth': 0}, data=data)\n    ax.axis('equal')\n\n    # And again to test the pyplot functions which should also be able to be\n    # called with a data kwarg\n    plt.figure()\n    plt.pie(\"s\", explode=\"ex\", labels=\"l\", colors=\"c\",\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0}, data=data)\n    plt.axis('equal')",
        "begin_line": 4343,
        "end_line": 4371,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_center_radius#4375",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_center_radius()",
        "snippet": "def test_pie_center_radius():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0}, center=(1, 2), radius=1.5)\n\n    plt.annotate(\"Center point\", xy=(1, 2), xytext=(1, 1.5),\n                 arrowprops=dict(arrowstyle=\"->\",\n                                 connectionstyle=\"arc3\"))\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')",
        "begin_line": 4375,
        "end_line": 4390,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_linewidth_2#4394",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_linewidth_2()",
        "snippet": "def test_pie_linewidth_2():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 2})\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')",
        "begin_line": 4394,
        "end_line": 4405,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_ccw_true#4409",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_ccw_true()",
        "snippet": "def test_pie_ccw_true():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            counterclock=True)\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')",
        "begin_line": 4409,
        "end_line": 4420,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_frame_grid#4424",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_frame_grid()",
        "snippet": "def test_pie_frame_grid():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    # only \"explode\" the 2nd slice (i.e. 'Hogs')\n    explode = (0, 0.1, 0, 0)\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0},\n            frame=True, center=(2, 2))\n\n    plt.pie(sizes[::-1], explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0},\n            frame=True, center=(5, 2))\n\n    plt.pie(sizes, explode=explode[::-1], labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            wedgeprops={'linewidth': 0},\n            frame=True, center=(3, 5))\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')",
        "begin_line": 4424,
        "end_line": 4447,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_rotatelabels_true#4451",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_rotatelabels_true()",
        "snippet": "def test_pie_rotatelabels_true():\n    # The slices will be ordered and plotted counter-clockwise.\n    labels = 'Hogwarts', 'Frogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90,\n            rotatelabels=True)\n    # Set aspect ratio to be equal so that pie is drawn as a circle.\n    plt.axis('equal')",
        "begin_line": 4451,
        "end_line": 4462,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_nolabel_but_legend#4466",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_nolabel_but_legend()",
        "snippet": "def test_pie_nolabel_but_legend():\n    labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\n    sizes = [15, 30, 45, 10]\n    colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral']\n    explode = (0, 0.1, 0, 0)  # only \"explode\" the 2nd slice (i.e. 'Hogs')\n    plt.pie(sizes, explode=explode, labels=labels, colors=colors,\n            autopct='%1.1f%%', shadow=True, startangle=90, labeldistance=None,\n            rotatelabels=True)\n    plt.axis('equal')\n    plt.ylim(-1.2, 1.2)\n    plt.legend()",
        "begin_line": 4466,
        "end_line": 4476,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pie_textprops#4479",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pie_textprops()",
        "snippet": "def test_pie_textprops():\n    data = [23, 34, 45]\n    labels = [\"Long name 1\", \"Long name 2\", \"Long name 3\"]\n\n    textprops = dict(horizontalalignment=\"center\",\n                     verticalalignment=\"top\",\n                     rotation=90,\n                     rotation_mode=\"anchor\",\n                     size=12, color=\"red\")\n\n    _, texts, autopct = plt.gca().pie(data, labels=labels, autopct='%.2f',\n                                      textprops=textprops)\n    for labels in [texts, autopct]:\n        for tx in labels:\n            assert tx.get_ha() == textprops[\"horizontalalignment\"]\n            assert tx.get_va() == textprops[\"verticalalignment\"]\n            assert tx.get_rotation() == textprops[\"rotation\"]\n            assert tx.get_rotation_mode() == textprops[\"rotation_mode\"]\n            assert tx.get_size() == textprops[\"size\"]\n            assert tx.get_color() == textprops[\"color\"]",
        "begin_line": 4479,
        "end_line": 4498,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_set_get_ticklabels#4502",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_set_get_ticklabels()",
        "snippet": "def test_set_get_ticklabels():\n    # test issue 2246\n    fig, ax = plt.subplots(2)\n    ha = ['normal', 'set_x/yticklabels']\n\n    ax[0].plot(np.arange(10))\n    ax[0].set_title(ha[0])\n\n    ax[1].plot(np.arange(10))\n    ax[1].set_title(ha[1])\n\n    # set ticklabel to 1 plot in normal way\n    ax[0].set_xticks(range(10))\n    ax[0].set_yticks(range(10))\n    ax[0].set_xticklabels(['a', 'b', 'c', 'd'] + 6 * [''])\n    ax[0].set_yticklabels(['11', '12', '13', '14'] + 6 * [''])\n\n    # set ticklabel to the other plot, expect the 2 plots have same label\n    # setting pass get_ticklabels return value as ticklabels argument\n    ax[1].set_xticks(ax[0].get_xticks())\n    ax[1].set_yticks(ax[0].get_yticks())\n    ax[1].set_xticklabels(ax[0].get_xticklabels())\n    ax[1].set_yticklabels(ax[0].get_yticklabels())",
        "begin_line": 4502,
        "end_line": 4524,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_subsampled_ticklabels#4527",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_subsampled_ticklabels()",
        "snippet": "def test_subsampled_ticklabels():\n    # test issue 11937\n    fig, ax = plt.subplots()\n    ax.plot(np.arange(10))\n    ax.xaxis.set_ticks(np.arange(10) + 0.1)\n    ax.locator_params(nbins=5)\n    ax.xaxis.set_ticklabels([c for c in \"bcdefghijk\"])\n    plt.draw()\n    labels = [t.get_text() for t in ax.xaxis.get_ticklabels()]\n    assert labels == ['b', 'd', 'f', 'h', 'j']",
        "begin_line": 4527,
        "end_line": 4536,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_mismatched_ticklabels#4539",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_mismatched_ticklabels()",
        "snippet": "def test_mismatched_ticklabels():\n    fig, ax = plt.subplots()\n    ax.plot(np.arange(10))\n    ax.xaxis.set_ticks([1.5, 2.5])\n    with pytest.raises(ValueError):\n        ax.xaxis.set_ticklabels(['a', 'b', 'c'])",
        "begin_line": 4539,
        "end_line": 4544,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_retain_tick_visibility#4548",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_retain_tick_visibility()",
        "snippet": "def test_retain_tick_visibility():\n    fig, ax = plt.subplots()\n    plt.plot([0, 1, 2], [0, -1, 4])\n    plt.setp(ax.get_yticklabels(), visible=False)\n    ax.tick_params(axis=\"y\", which=\"both\", length=0)",
        "begin_line": 4548,
        "end_line": 4552,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_tick_label_update#4555",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_tick_label_update()",
        "snippet": "def test_tick_label_update():\n    # test issue 9397\n\n    fig, ax = plt.subplots()\n\n    # Set up a dummy formatter\n    def formatter_func(x, pos):\n        return \"unit value\" if x == 1 else \"\"\n    ax.xaxis.set_major_formatter(plt.FuncFormatter(formatter_func))\n\n    # Force some of the x-axis ticks to be outside of the drawn range\n    ax.set_xticks([-1, 0, 1, 2, 3])\n    ax.set_xlim(-0.5, 2.5)\n\n    ax.figure.canvas.draw()\n    tick_texts = [tick.get_text() for tick in ax.xaxis.get_ticklabels()]\n    assert tick_texts == [\"\", \"\", \"unit value\", \"\", \"\"]",
        "begin_line": 4555,
        "end_line": 4571,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.formatter_func#4561",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.formatter_func(x, pos)",
        "snippet": "    def formatter_func(x, pos):\n        return \"unit value\" if x == 1 else \"\"",
        "begin_line": 4561,
        "end_line": 4562,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_o_marker_path_snap#4575",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_o_marker_path_snap()",
        "snippet": "def test_o_marker_path_snap():\n    fig, ax = plt.subplots()\n    ax.margins(.1)\n    for ms in range(1, 15):\n        ax.plot([1, 2, ], np.ones(2) + ms, 'o', ms=ms)\n\n    for ms in np.linspace(1, 10, 25):\n        ax.plot([3, 4, ], np.ones(2) + ms, 'o', ms=ms)",
        "begin_line": 4575,
        "end_line": 4582,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_margins#4585",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_margins()",
        "snippet": "def test_margins():\n    # test all ways margins can be called\n    data = [1, 10]\n    xmin = 0.0\n    xmax = len(data) - 1.0\n    ymin = min(data)\n    ymax = max(data)\n\n    fig1, ax1 = plt.subplots(1, 1)\n    ax1.plot(data)\n    ax1.margins(1)\n    assert ax1.margins() == (1, 1)\n    assert ax1.get_xlim() == (xmin - (xmax - xmin) * 1,\n                              xmax + (xmax - xmin) * 1)\n    assert ax1.get_ylim() == (ymin - (ymax - ymin) * 1,\n                              ymax + (ymax - ymin) * 1)\n\n    fig2, ax2 = plt.subplots(1, 1)\n    ax2.plot(data)\n    ax2.margins(0.5, 2)\n    assert ax2.margins() == (0.5, 2)\n    assert ax2.get_xlim() == (xmin - (xmax - xmin) * 0.5,\n                              xmax + (xmax - xmin) * 0.5)\n    assert ax2.get_ylim() == (ymin - (ymax - ymin) * 2,\n                              ymax + (ymax - ymin) * 2)\n\n    fig3, ax3 = plt.subplots(1, 1)\n    ax3.plot(data)\n    ax3.margins(x=-0.2, y=0.5)\n    assert ax3.margins() == (-0.2, 0.5)\n    assert ax3.get_xlim() == (xmin - (xmax - xmin) * -0.2,\n                              xmax + (xmax - xmin) * -0.2)\n    assert ax3.get_ylim() == (ymin - (ymax - ymin) * 0.5,\n                              ymax + (ymax - ymin) * 0.5)",
        "begin_line": 4585,
        "end_line": 4618,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_set_margin_updates_limits#4621",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_set_margin_updates_limits()",
        "snippet": "def test_set_margin_updates_limits():\n    mpl.style.use(\"default\")\n    fig, ax = plt.subplots()\n    ax.plot([1, 2], [1, 2])\n    ax.set(xscale=\"log\", xmargin=0)\n    assert ax.get_xlim() == (1, 2)",
        "begin_line": 4621,
        "end_line": 4626,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_length_one_hist#4629",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_length_one_hist()",
        "snippet": "def test_length_one_hist():\n    fig, ax = plt.subplots()\n    ax.hist(1)\n    ax.hist([1])",
        "begin_line": 4629,
        "end_line": 4632,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pathological_hexbin#4635",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pathological_hexbin()",
        "snippet": "def test_pathological_hexbin():\n    # issue #2863\n    mylist = [10] * 100\n    fig, ax = plt.subplots(1, 1)\n    ax.hexbin(mylist, mylist)\n    fig.savefig(io.BytesIO())  # Check that no warning is emitted.",
        "begin_line": 4635,
        "end_line": 4640,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_color_None#4643",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_color_None()",
        "snippet": "def test_color_None():\n    # issue 3855\n    fig, ax = plt.subplots()\n    ax.plot([1, 2], [1, 2], color=None)",
        "begin_line": 4643,
        "end_line": 4646,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_color_alias#4649",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_color_alias()",
        "snippet": "def test_color_alias():\n    # issues 4157 and 4162\n    fig, ax = plt.subplots()\n    line = ax.plot([0, 1], c='lime')[0]\n    assert 'lime' == line.get_color()",
        "begin_line": 4649,
        "end_line": 4653,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_numerical_hist_label#4656",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_numerical_hist_label()",
        "snippet": "def test_numerical_hist_label():\n    fig, ax = plt.subplots()\n    ax.hist([range(15)] * 5, label=range(5))\n    ax.legend()",
        "begin_line": 4656,
        "end_line": 4659,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_unicode_hist_label#4662",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_unicode_hist_label()",
        "snippet": "def test_unicode_hist_label():\n    fig, ax = plt.subplots()\n    a = (b'\\xe5\\xbe\\x88\\xe6\\xbc\\x82\\xe4\\xba\\xae, ' +\n         b'r\\xc3\\xb6m\\xc3\\xa4n ch\\xc3\\xa4r\\xc3\\xa1ct\\xc3\\xa8rs')\n    b = b'\\xd7\\xa9\\xd7\\x9c\\xd7\\x95\\xd7\\x9d'\n    labels = [a.decode('utf-8'),\n              'hi aardvark',\n              b.decode('utf-8'),\n              ]\n\n    ax.hist([range(15)] * 3, label=labels)\n    ax.legend()",
        "begin_line": 4662,
        "end_line": 4673,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_move_offsetlabel#4676",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_move_offsetlabel()",
        "snippet": "def test_move_offsetlabel():\n    data = np.random.random(10) * 1e-22\n\n    fig, ax = plt.subplots()\n    ax.plot(data)\n    fig.canvas.draw()\n    before = ax.yaxis.offsetText.get_position()\n    assert ax.yaxis.offsetText.get_horizontalalignment() == 'left'\n    ax.yaxis.tick_right()\n    fig.canvas.draw()\n    after = ax.yaxis.offsetText.get_position()\n    assert after[0] > before[0] and after[1] == before[1]\n    assert ax.yaxis.offsetText.get_horizontalalignment() == 'right'\n\n    fig, ax = plt.subplots()\n    ax.plot(data)\n    fig.canvas.draw()\n    before = ax.xaxis.offsetText.get_position()\n    assert ax.xaxis.offsetText.get_verticalalignment() == 'top'\n    ax.xaxis.tick_top()\n    fig.canvas.draw()\n    after = ax.xaxis.offsetText.get_position()\n    assert after[0] == before[0] and after[1] > before[1]\n    assert ax.xaxis.offsetText.get_verticalalignment() == 'bottom'",
        "begin_line": 4676,
        "end_line": 4699,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_rc_spines#4703",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_rc_spines()",
        "snippet": "def test_rc_spines():\n    rc_dict = {\n        'axes.spines.left': False,\n        'axes.spines.right': False,\n        'axes.spines.top': False,\n        'axes.spines.bottom': False}\n    with matplotlib.rc_context(rc_dict):\n        fig, ax = plt.subplots()",
        "begin_line": 4703,
        "end_line": 4710,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_rc_grid#4714",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_rc_grid()",
        "snippet": "def test_rc_grid():\n    fig = plt.figure()\n    rc_dict0 = {\n        'axes.grid': True,\n        'axes.grid.axis': 'both'\n    }\n    rc_dict1 = {\n        'axes.grid': True,\n        'axes.grid.axis': 'x'\n    }\n    rc_dict2 = {\n        'axes.grid': True,\n        'axes.grid.axis': 'y'\n    }\n    dict_list = [rc_dict0, rc_dict1, rc_dict2]\n\n    for i, rc_dict in enumerate(dict_list, 1):\n        with matplotlib.rc_context(rc_dict):\n            fig.add_subplot(3, 1, i)",
        "begin_line": 4714,
        "end_line": 4732,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_rc_tick#4735",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_rc_tick()",
        "snippet": "def test_rc_tick():\n    d = {'xtick.bottom': False, 'xtick.top': True,\n         'ytick.left': True, 'ytick.right': False}\n    with plt.rc_context(rc=d):\n        fig = plt.figure()\n        ax1 = fig.add_subplot(1, 1, 1)\n        xax = ax1.xaxis\n        yax = ax1.yaxis\n        # tick1On bottom/left\n        assert not xax._major_tick_kw['tick1On']\n        assert xax._major_tick_kw['tick2On']\n        assert not xax._minor_tick_kw['tick1On']\n        assert xax._minor_tick_kw['tick2On']\n\n        assert yax._major_tick_kw['tick1On']\n        assert not yax._major_tick_kw['tick2On']\n        assert yax._minor_tick_kw['tick1On']\n        assert not yax._minor_tick_kw['tick2On']",
        "begin_line": 4735,
        "end_line": 4752,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_rc_major_minor_tick#4755",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_rc_major_minor_tick()",
        "snippet": "def test_rc_major_minor_tick():\n    d = {'xtick.top': True, 'ytick.right': True,  # Enable all ticks\n         'xtick.bottom': True, 'ytick.left': True,\n         # Selectively disable\n         'xtick.minor.bottom': False, 'xtick.major.bottom': False,\n         'ytick.major.left': False, 'ytick.minor.left': False}\n    with plt.rc_context(rc=d):\n        fig = plt.figure()\n        ax1 = fig.add_subplot(1, 1, 1)\n        xax = ax1.xaxis\n        yax = ax1.yaxis\n        # tick1On bottom/left\n        assert not xax._major_tick_kw['tick1On']\n        assert xax._major_tick_kw['tick2On']\n        assert not xax._minor_tick_kw['tick1On']\n        assert xax._minor_tick_kw['tick2On']\n\n        assert not yax._major_tick_kw['tick1On']\n        assert yax._major_tick_kw['tick2On']\n        assert not yax._minor_tick_kw['tick1On']\n        assert yax._minor_tick_kw['tick2On']",
        "begin_line": 4755,
        "end_line": 4775,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_square_plot#4778",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_square_plot()",
        "snippet": "def test_square_plot():\n    x = np.arange(4)\n    y = np.array([1., 3., 5., 7.])\n    fig, ax = plt.subplots()\n    ax.plot(x, y, 'mo')\n    ax.axis('square')\n    xlim, ylim = ax.get_xlim(), ax.get_ylim()\n    assert np.diff(xlim) == np.diff(ylim)\n    assert ax.get_aspect() == 1\n    assert_array_almost_equal(\n        ax.get_position(original=True).extents, (0.125, 0.1, 0.9, 0.9))\n    assert_array_almost_equal(\n        ax.get_position(original=False).extents, (0.2125, 0.1, 0.8125, 0.9))",
        "begin_line": 4778,
        "end_line": 4790,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bad_plot_args#4793",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bad_plot_args()",
        "snippet": "def test_bad_plot_args():\n    with pytest.raises(ValueError):\n        plt.plot(None)\n    with pytest.raises(ValueError):\n        plt.plot(None, None)\n    with pytest.raises(ValueError):\n        plt.plot(np.zeros((2, 2)), np.zeros((2, 3)))\n    with pytest.raises(ValueError):\n        plt.plot((np.arange(5).reshape((1, -1)), np.arange(5).reshape(-1, 1)))",
        "begin_line": 4793,
        "end_line": 4801,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pcolorfast#4818",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pcolorfast(xy, data, cls)",
        "snippet": "def test_pcolorfast(xy, data, cls):\n    fig, ax = plt.subplots()\n    assert type(ax.pcolorfast(*xy, data)) == cls",
        "begin_line": 4818,
        "end_line": 4820,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shared_scale#4823",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shared_scale()",
        "snippet": "def test_shared_scale():\n    fig, axs = plt.subplots(2, 2, sharex=True, sharey=True)\n\n    axs[0, 0].set_xscale(\"log\")\n    axs[0, 0].set_yscale(\"log\")\n\n    for ax in axs.flat:\n        assert ax.get_yscale() == 'log'\n        assert ax.get_xscale() == 'log'\n\n    axs[1, 1].set_xscale(\"linear\")\n    axs[1, 1].set_yscale(\"linear\")\n\n    for ax in axs.flat:\n        assert ax.get_yscale() == 'linear'\n        assert ax.get_xscale() == 'linear'",
        "begin_line": 4823,
        "end_line": 4838,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shared_bool#4841",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shared_bool()",
        "snippet": "def test_shared_bool():\n    with pytest.raises(TypeError):\n        plt.subplot(sharex=True)\n    with pytest.raises(TypeError):\n        plt.subplot(sharey=True)",
        "begin_line": 4841,
        "end_line": 4845,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_violin_point_mass#4848",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_violin_point_mass()",
        "snippet": "def test_violin_point_mass():\n    \"\"\"Violin plot should handle point mass pdf gracefully.\"\"\"\n    plt.violinplot(np.array([0, 0]))",
        "begin_line": 4848,
        "end_line": 4850,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.generate_errorbar_inputs#4853",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.generate_errorbar_inputs()",
        "snippet": "def generate_errorbar_inputs():\n    base_xy = cycler('x', [np.arange(5)]) + cycler('y', [np.ones(5)])\n    err_cycler = cycler('err', [1,\n                                [1, 1, 1, 1, 1],\n                                [[1, 1, 1, 1, 1],\n                                 [1, 1, 1, 1, 1]],\n                                np.ones(5),\n                                np.ones((2, 5)),\n                                None\n                                ])\n    xerr_cy = cycler('xerr', err_cycler)\n    yerr_cy = cycler('yerr', err_cycler)\n\n    empty = ((cycler('x', [[]]) + cycler('y', [[]])) *\n             cycler('xerr', [[], None]) * cycler('yerr', [[], None]))\n    xerr_only = base_xy * xerr_cy\n    yerr_only = base_xy * yerr_cy\n    both_err = base_xy * yerr_cy * xerr_cy\n\n    return [*xerr_only, *yerr_only, *both_err, *empty]",
        "begin_line": 4853,
        "end_line": 4872,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_errorbar_inputs_shotgun#4876",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_errorbar_inputs_shotgun(kwargs)",
        "snippet": "def test_errorbar_inputs_shotgun(kwargs):\n    ax = plt.gca()\n    eb = ax.errorbar(**kwargs)\n    eb.remove()",
        "begin_line": 4876,
        "end_line": 4879,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_dash_offset#4883",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_dash_offset()",
        "snippet": "def test_dash_offset():\n    fig, ax = plt.subplots()\n    x = np.linspace(0, 10)\n    y = np.ones_like(x)\n    for j in range(0, 100, 2):\n        ax.plot(x, j*y, ls=(j, (10, 10)), lw=5, color='k')",
        "begin_line": 4883,
        "end_line": 4888,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_title_pad#4891",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_title_pad()",
        "snippet": "def test_title_pad():\n    # check that title padding puts the title in the right\n    # place...\n    fig, ax = plt.subplots()\n    ax.set_title('aardvark', pad=30.)\n    m = ax.titleOffsetTrans.get_matrix()\n    assert m[1, -1] == (30. / 72. * fig.dpi)\n    ax.set_title('aardvark', pad=0.)\n    m = ax.titleOffsetTrans.get_matrix()\n    assert m[1, -1] == 0.\n    # check that it is reverted...\n    ax.set_title('aardvark', pad=None)\n    m = ax.titleOffsetTrans.get_matrix()\n    assert m[1, -1] == (matplotlib.rcParams['axes.titlepad'] / 72. * fig.dpi)",
        "begin_line": 4891,
        "end_line": 4904,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_title_location_roundtrip#4907",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_title_location_roundtrip()",
        "snippet": "def test_title_location_roundtrip():\n    fig, ax = plt.subplots()\n    # set default title location\n    plt.rcParams['axes.titlelocation'] = 'center'\n    ax.set_title('aardvark')\n    ax.set_title('left', loc='left')\n    ax.set_title('right', loc='right')\n\n    assert 'left' == ax.get_title(loc='left')\n    assert 'right' == ax.get_title(loc='right')\n    assert 'aardvark' == ax.get_title(loc='center')\n\n    with pytest.raises(ValueError):\n        ax.get_title(loc='foo')\n    with pytest.raises(ValueError):\n        ax.set_title('fail', loc='foo')",
        "begin_line": 4907,
        "end_line": 4922,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_loglog#4926",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_loglog()",
        "snippet": "def test_loglog():\n    fig, ax = plt.subplots()\n    x = np.arange(1, 11)\n    ax.loglog(x, x**3, lw=5)\n    ax.tick_params(length=25, width=2)\n    ax.tick_params(length=15, width=2, which='minor')",
        "begin_line": 4926,
        "end_line": 4931,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_loglog_nonpos#4936",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_loglog_nonpos(new_api)",
        "snippet": "def test_loglog_nonpos(new_api):\n    fig, axs = plt.subplots(3, 3)\n    x = np.arange(1, 11)\n    y = x**3\n    y[7] = -3.\n    x[4] = -10\n    for (i, j), ax in np.ndenumerate(axs):\n        mcx = ['mask', 'clip', ''][j]\n        mcy = ['mask', 'clip', ''][i]\n        if new_api:\n            if mcx == mcy:\n                if mcx:\n                    ax.loglog(x, y**3, lw=2, nonpositive=mcx)\n                else:\n                    ax.loglog(x, y**3, lw=2)\n            else:\n                ax.loglog(x, y**3, lw=2)\n                if mcx:\n                    ax.set_xscale(\"log\", nonpositive=mcx)\n                if mcy:\n                    ax.set_yscale(\"log\", nonpositive=mcy)\n        else:\n            kws = {}\n            if mcx:\n                kws['nonposx'] = mcx\n            if mcy:\n                kws['nonposy'] = mcy\n            with (pytest.warns(MatplotlibDeprecationWarning) if kws\n                  else nullcontext()):\n                ax.loglog(x, y**3, lw=2, **kws)",
        "begin_line": 4936,
        "end_line": 4965,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axes_margins#4969",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axes_margins()",
        "snippet": "def test_axes_margins():\n    fig, ax = plt.subplots()\n    ax.plot([0, 1, 2, 3])\n    assert ax.get_ybound()[0] != 0\n\n    fig, ax = plt.subplots()\n    ax.bar([0, 1, 2, 3], [1, 1, 1, 1])\n    assert ax.get_ybound()[0] == 0\n\n    fig, ax = plt.subplots()\n    ax.barh([0, 1, 2, 3], [1, 1, 1, 1])\n    assert ax.get_xbound()[0] == 0\n\n    fig, ax = plt.subplots()\n    ax.pcolor(np.zeros((10, 10)))\n    assert ax.get_xbound() == (0, 10)\n    assert ax.get_ybound() == (0, 10)\n\n    fig, ax = plt.subplots()\n    ax.pcolorfast(np.zeros((10, 10)))\n    assert ax.get_xbound() == (0, 10)\n    assert ax.get_ybound() == (0, 10)\n\n    fig, ax = plt.subplots()\n    ax.hist(np.arange(10))\n    assert ax.get_ybound()[0] == 0\n\n    fig, ax = plt.subplots()\n    ax.imshow(np.zeros((10, 10)))\n    assert ax.get_xbound() == (-0.5, 9.5)\n    assert ax.get_ybound() == (-0.5, 9.5)",
        "begin_line": 4969,
        "end_line": 4999,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.shared_axis_remover#5003",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.shared_axis_remover(request)",
        "snippet": "def shared_axis_remover(request):\n    def _helper_x(ax):\n        ax2 = ax.twinx()\n        ax2.remove()\n        ax.set_xlim(0, 15)\n        r = ax.xaxis.get_major_locator()()\n        assert r[-1] > 14\n\n    def _helper_y(ax):\n        ax2 = ax.twiny()\n        ax2.remove()\n        ax.set_ylim(0, 15)\n        r = ax.yaxis.get_major_locator()()\n        assert r[-1] > 14\n\n    return {\"x\": _helper_x, \"y\": _helper_y}[request.param]",
        "begin_line": 5003,
        "end_line": 5018,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes._helper_x#5004",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes._helper_x(ax)",
        "snippet": "    def _helper_x(ax):\n        ax2 = ax.twinx()\n        ax2.remove()\n        ax.set_xlim(0, 15)\n        r = ax.xaxis.get_major_locator()()\n        assert r[-1] > 14",
        "begin_line": 5004,
        "end_line": 5009,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes._helper_y#5011",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes._helper_y(ax)",
        "snippet": "    def _helper_y(ax):\n        ax2 = ax.twiny()\n        ax2.remove()\n        ax.set_ylim(0, 15)\n        r = ax.yaxis.get_major_locator()()\n        assert r[-1] > 14",
        "begin_line": 5011,
        "end_line": 5016,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.shared_axes_generator#5022",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.shared_axes_generator(request)",
        "snippet": "def shared_axes_generator(request):\n    # test all of the ways to get fig/ax sets\n    if request.param == 'gca':\n        fig = plt.figure()\n        ax = fig.gca()\n    elif request.param == 'subplots':\n        fig, ax = plt.subplots()\n    elif request.param == 'subplots_shared':\n        fig, ax_lst = plt.subplots(2, 2, sharex='all', sharey='all')\n        ax = ax_lst[0][0]\n    elif request.param == 'add_axes':\n        fig = plt.figure()\n        ax = fig.add_axes([.1, .1, .8, .8])\n    return fig, ax",
        "begin_line": 5022,
        "end_line": 5035,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_remove_shared_axes#5038",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_remove_shared_axes(shared_axes_generator, shared_axis_remover)",
        "snippet": "def test_remove_shared_axes(shared_axes_generator, shared_axis_remover):\n    # test all of the ways to get fig/ax sets\n    fig, ax = shared_axes_generator\n    shared_axis_remover(ax)",
        "begin_line": 5038,
        "end_line": 5041,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_remove_shared_axes_relim#5044",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_remove_shared_axes_relim()",
        "snippet": "def test_remove_shared_axes_relim():\n    fig, ax_lst = plt.subplots(2, 2, sharex='all', sharey='all')\n    ax = ax_lst[0][0]\n    orig_xlim = ax_lst[0][1].get_xlim()\n    ax.remove()\n    ax.set_xlim(0, 5)\n    assert_array_equal(ax_lst[0][1].get_xlim(), orig_xlim)",
        "begin_line": 5044,
        "end_line": 5050,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_shared_axes_autoscale#5053",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_shared_axes_autoscale()",
        "snippet": "def test_shared_axes_autoscale():\n    l = np.arange(-80, 90, 40)\n    t = np.random.random_sample((l.size, l.size))\n\n    ax1 = plt.subplot(211)\n    ax1.set_xlim(-1000, 1000)\n    ax1.set_ylim(-1000, 1000)\n    ax1.contour(l, l, t)\n\n    ax2 = plt.subplot(212, sharex=ax1, sharey=ax1)\n    ax2.contour(l, l, t)\n    assert not ax1.get_autoscalex_on() and not ax2.get_autoscalex_on()\n    assert not ax1.get_autoscaley_on() and not ax2.get_autoscaley_on()\n    assert ax1.get_xlim() == ax2.get_xlim() == (-1000, 1000)\n    assert ax1.get_ylim() == ax2.get_ylim() == (-1000, 1000)",
        "begin_line": 5053,
        "end_line": 5067,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_adjust_numtick_aspect#5070",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_adjust_numtick_aspect()",
        "snippet": "def test_adjust_numtick_aspect():\n    fig, ax = plt.subplots()\n    ax.yaxis.get_major_locator().set_params(nbins='auto')\n    ax.set_xlim(0, 1000)\n    ax.set_aspect('equal')\n    fig.canvas.draw()\n    assert len(ax.yaxis.get_major_locator()()) == 2\n    ax.set_ylim(0, 1000)\n    fig.canvas.draw()\n    assert len(ax.yaxis.get_major_locator()()) > 2",
        "begin_line": 5070,
        "end_line": 5079,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_auto_numticks#5083",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_auto_numticks()",
        "snippet": "def test_auto_numticks():\n    # Make tiny, empty subplots, verify that there are only 3 ticks.\n    fig, axs = plt.subplots(4, 4)",
        "begin_line": 5083,
        "end_line": 5085,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_auto_numticks_log#5089",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_auto_numticks_log()",
        "snippet": "def test_auto_numticks_log():\n    # Verify that there are not too many ticks with a large log range.\n    fig, ax = plt.subplots()\n    matplotlib.rcParams['axes.autolimit_mode'] = 'round_numbers'\n    ax.loglog([1e-20, 1e5], [1e-16, 10])",
        "begin_line": 5089,
        "end_line": 5093,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_broken_barh_empty#5096",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_broken_barh_empty()",
        "snippet": "def test_broken_barh_empty():\n    fig, ax = plt.subplots()\n    ax.broken_barh([], (.1, .5))",
        "begin_line": 5096,
        "end_line": 5098,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_broken_barh_timedelta#5101",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_broken_barh_timedelta()",
        "snippet": "def test_broken_barh_timedelta():\n    \"\"\"Check that timedelta works as x, dx pair for this method.\"\"\"\n    fig, ax = plt.subplots()\n    d0 = datetime.datetime(2018, 11, 9, 0, 0, 0)\n    pp = ax.broken_barh([(d0, datetime.timedelta(hours=1))], [1, 2])\n    assert pp.get_paths()[0].vertices[0, 0] == mdates.date2num(d0)\n    assert pp.get_paths()[0].vertices[2, 0] == mdates.date2num(d0) + 1 / 24",
        "begin_line": 5101,
        "end_line": 5107,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pandas_pcolormesh#5110",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pandas_pcolormesh(pd)",
        "snippet": "def test_pandas_pcolormesh(pd):\n    time = pd.date_range('2000-01-01', periods=10)\n    depth = np.arange(20)\n    data = np.random.rand(19, 9)\n\n    fig, ax = plt.subplots()\n    ax.pcolormesh(time, depth, data)",
        "begin_line": 5110,
        "end_line": 5116,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pandas_indexing_dates#5119",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pandas_indexing_dates(pd)",
        "snippet": "def test_pandas_indexing_dates(pd):\n    dates = np.arange('2005-02', '2005-03', dtype='datetime64[D]')\n    values = np.sin(np.array(range(len(dates))))\n    df = pd.DataFrame({'dates': dates, 'values': values})\n\n    ax = plt.gca()\n\n    without_zero_index = df[np.array(df.index) % 2 == 1].copy()\n    ax.plot('dates', 'values', data=without_zero_index)",
        "begin_line": 5119,
        "end_line": 5127,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pandas_errorbar_indexing#5130",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pandas_errorbar_indexing(pd)",
        "snippet": "def test_pandas_errorbar_indexing(pd):\n    df = pd.DataFrame(np.random.uniform(size=(5, 4)),\n                      columns=['x', 'y', 'xe', 'ye'],\n                      index=[1, 2, 3, 4, 5])\n    fig, ax = plt.subplots()\n    ax.errorbar('x', 'y', xerr='xe', yerr='ye', data=df)",
        "begin_line": 5130,
        "end_line": 5135,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pandas_index_shape#5138",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pandas_index_shape(pd)",
        "snippet": "def test_pandas_index_shape(pd):\n    df = pd.DataFrame({\"XX\": [4, 5, 6], \"YY\": [7, 1, 2]})\n    fig, ax = plt.subplots()\n    ax.plot(df.index, df['YY'])",
        "begin_line": 5138,
        "end_line": 5141,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pandas_indexing_hist#5144",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pandas_indexing_hist(pd)",
        "snippet": "def test_pandas_indexing_hist(pd):\n    ser_1 = pd.Series(data=[1, 2, 2, 3, 3, 4, 4, 4, 4, 5])\n    ser_2 = ser_1.iloc[1:]\n    fig, ax = plt.subplots()\n    ax.hist(ser_2)",
        "begin_line": 5144,
        "end_line": 5148,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pandas_bar_align_center#5151",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pandas_bar_align_center(pd)",
        "snippet": "def test_pandas_bar_align_center(pd):\n    # Tests fix for issue 8767\n    df = pd.DataFrame({'a': range(2), 'b': range(2)})\n\n    fig, ax = plt.subplots(1)\n\n    ax.bar(df.loc[df['a'] == 1, 'b'],\n           df.loc[df['a'] == 1, 'b'],\n           align='center')\n\n    fig.canvas.draw()",
        "begin_line": 5151,
        "end_line": 5161,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axis_set_tick_params_labelsize_labelcolor#5164",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axis_set_tick_params_labelsize_labelcolor()",
        "snippet": "def test_axis_set_tick_params_labelsize_labelcolor():\n    # Tests fix for issue 4346\n    axis_1 = plt.subplot()\n    axis_1.yaxis.set_tick_params(labelsize=30, labelcolor='red',\n                                 direction='out')\n\n    # Expected values after setting the ticks\n    assert axis_1.yaxis.majorTicks[0]._size == 4.0\n    assert axis_1.yaxis.majorTicks[0].tick1line.get_color() == 'k'\n    assert axis_1.yaxis.majorTicks[0].label1.get_size() == 30.0\n    assert axis_1.yaxis.majorTicks[0].label1.get_color() == 'red'",
        "begin_line": 5164,
        "end_line": 5174,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axes_tick_params_gridlines#5177",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axes_tick_params_gridlines()",
        "snippet": "def test_axes_tick_params_gridlines():\n    # Now treating grid params like other Tick params\n    ax = plt.subplot()\n    ax.tick_params(grid_color='b', grid_linewidth=5, grid_alpha=0.5,\n                   grid_linestyle='dashdot')\n    for axis in ax.xaxis, ax.yaxis:\n        assert axis.majorTicks[0].gridline.get_color() == 'b'\n        assert axis.majorTicks[0].gridline.get_linewidth() == 5\n        assert axis.majorTicks[0].gridline.get_alpha() == 0.5\n        assert axis.majorTicks[0].gridline.get_linestyle() == '-.'",
        "begin_line": 5177,
        "end_line": 5186,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axes_tick_params_ylabelside#5189",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axes_tick_params_ylabelside()",
        "snippet": "def test_axes_tick_params_ylabelside():\n    # Tests fix for issue 10267\n    ax = plt.subplot()\n    ax.tick_params(labelleft=False, labelright=True,\n                   which='major')\n    ax.tick_params(labelleft=False, labelright=True,\n                   which='minor')\n    # expects left false, right true\n    assert ax.yaxis.majorTicks[0].label1.get_visible() is False\n    assert ax.yaxis.majorTicks[0].label2.get_visible() is True\n    assert ax.yaxis.minorTicks[0].label1.get_visible() is False\n    assert ax.yaxis.minorTicks[0].label2.get_visible() is True",
        "begin_line": 5189,
        "end_line": 5200,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axes_tick_params_xlabelside#5203",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axes_tick_params_xlabelside()",
        "snippet": "def test_axes_tick_params_xlabelside():\n    # Tests fix for issue 10267\n    ax = plt.subplot()\n    ax.tick_params(labeltop=True, labelbottom=False,\n                   which='major')\n    ax.tick_params(labeltop=True, labelbottom=False,\n                   which='minor')\n    # expects top True, bottom False\n    # label1.get_visible() mapped to labelbottom\n    # label2.get_visible() mapped to labeltop\n    assert ax.xaxis.majorTicks[0].label1.get_visible() is False\n    assert ax.xaxis.majorTicks[0].label2.get_visible() is True\n    assert ax.xaxis.minorTicks[0].label1.get_visible() is False\n    assert ax.xaxis.minorTicks[0].label2.get_visible() is True",
        "begin_line": 5203,
        "end_line": 5216,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_none_kwargs#5219",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_none_kwargs()",
        "snippet": "def test_none_kwargs():\n    ax = plt.figure().subplots()\n    ln, = ax.plot(range(32), linestyle=None)\n    assert ln.get_linestyle() == '-'",
        "begin_line": 5219,
        "end_line": 5222,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_ls_ds_conflict#5225",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_ls_ds_conflict()",
        "snippet": "def test_ls_ds_conflict():\n    # Passing the drawstyle with the linestyle is deprecated since 3.1.\n    # We still need to test this until it's removed from the code.\n    # But we don't want to see the deprecation warning in the test.\n    with matplotlib.cbook._suppress_matplotlib_deprecation_warning(), \\\n         pytest.raises(ValueError):\n        plt.plot(range(32), linestyle='steps-pre:', drawstyle='steps-post')",
        "begin_line": 5225,
        "end_line": 5231,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_uint8#5234",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_uint8()",
        "snippet": "def test_bar_uint8():\n    xs = [0, 1, 2, 3]\n    b = plt.bar(np.array(xs, dtype=np.uint8), [2, 3, 4, 5], align=\"edge\")\n    for (patch, x) in zip(b.patches, xs):\n        assert patch.xy[0] == x",
        "begin_line": 5234,
        "end_line": 5238,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_date_timezone_x#5242",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_date_timezone_x()",
        "snippet": "def test_date_timezone_x():\n    # Tests issue 5575\n    time_index = [datetime.datetime(2016, 2, 22, hour=x,\n                                    tzinfo=dateutil.tz.gettz('Canada/Eastern'))\n                  for x in range(3)]\n\n    # Same Timezone\n    plt.figure(figsize=(20, 12))\n    plt.subplot(2, 1, 1)\n    plt.plot_date(time_index, [3] * 3, tz='Canada/Eastern')\n\n    # Different Timezone\n    plt.subplot(2, 1, 2)\n    plt.plot_date(time_index, [3] * 3, tz='UTC')",
        "begin_line": 5242,
        "end_line": 5255,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_date_timezone_y#5259",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_date_timezone_y()",
        "snippet": "def test_date_timezone_y():\n    # Tests issue 5575\n    time_index = [datetime.datetime(2016, 2, 22, hour=x,\n                                    tzinfo=dateutil.tz.gettz('Canada/Eastern'))\n                  for x in range(3)]\n\n    # Same Timezone\n    plt.figure(figsize=(20, 12))\n    plt.subplot(2, 1, 1)\n    plt.plot_date([3] * 3,\n                  time_index, tz='Canada/Eastern', xdate=False, ydate=True)\n\n    # Different Timezone\n    plt.subplot(2, 1, 2)\n    plt.plot_date([3] * 3, time_index, tz='UTC', xdate=False, ydate=True)",
        "begin_line": 5259,
        "end_line": 5273,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_date_timezone_x_and_y#5277",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_date_timezone_x_and_y()",
        "snippet": "def test_date_timezone_x_and_y():\n    # Tests issue 5575\n    UTC = datetime.timezone.utc\n    time_index = [datetime.datetime(2016, 2, 22, hour=x, tzinfo=UTC)\n                  for x in range(3)]\n\n    # Same Timezone\n    plt.figure(figsize=(20, 12))\n    plt.subplot(2, 1, 1)\n    plt.plot_date(time_index, time_index, tz='UTC', ydate=True)\n\n    # Different Timezone\n    plt.subplot(2, 1, 2)\n    plt.plot_date(time_index, time_index, tz='US/Eastern', ydate=True)",
        "begin_line": 5277,
        "end_line": 5290,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axisbelow#5294",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axisbelow()",
        "snippet": "def test_axisbelow():\n    # Test 'line' setting added in 6287.\n    # Show only grids, not frame or ticks, to make this test\n    # independent of future change to drawing order of those elements.\n    axs = plt.figure().subplots(ncols=3, sharex=True, sharey=True)\n    settings = (False, 'line', True)\n\n    for ax, setting in zip(axs, settings):\n        ax.plot((0, 10), (0, 10), lw=10, color='m')\n        circ = mpatches.Circle((3, 3), color='r')\n        ax.add_patch(circ)\n        ax.grid(color='c', linestyle='-', linewidth=3)\n        ax.tick_params(top=False, bottom=False,\n                       left=False, right=False)\n        for spine in ax.spines.values():\n            spine.set_visible(False)\n        ax.set_axisbelow(setting)",
        "begin_line": 5294,
        "end_line": 5310,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_titletwiny#5313",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_titletwiny()",
        "snippet": "def test_titletwiny():\n    plt.style.use('mpl20')\n    fig, ax = plt.subplots(dpi=72)\n    ax2 = ax.twiny()\n    xlabel2 = ax2.set_xlabel('Xlabel2')\n    title = ax.set_title('Title')\n    fig.canvas.draw()\n    renderer = fig.canvas.get_renderer()\n    # ------- Test that title is put above Xlabel2 (Xlabel2 at top) ----------\n    bbox_y0_title = title.get_window_extent(renderer).y0  # bottom of title\n    bbox_y1_xlabel2 = xlabel2.get_window_extent(renderer).y1  # top of xlabel2\n    y_diff = bbox_y0_title - bbox_y1_xlabel2\n    assert np.isclose(y_diff, 3)",
        "begin_line": 5313,
        "end_line": 5325,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_titlesetpos#5328",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_titlesetpos()",
        "snippet": "def test_titlesetpos():\n    # Test that title stays put if we set it manually\n    fig, ax = plt.subplots()\n    fig.subplots_adjust(top=0.8)\n    ax2 = ax.twiny()\n    ax.set_xlabel('Xlabel')\n    ax2.set_xlabel('Xlabel2')\n    ax.set_title('Title')\n    pos = (0.5, 1.11)\n    ax.title.set_position(pos)\n    renderer = fig.canvas.get_renderer()\n    ax._update_title_position(renderer)\n    assert ax.title.get_position() == pos",
        "begin_line": 5328,
        "end_line": 5340,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_title_xticks_top#5343",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_title_xticks_top()",
        "snippet": "def test_title_xticks_top():\n    # Test that title moves if xticks on top of axes.\n    mpl.rcParams['axes.titley'] = None\n    fig, ax = plt.subplots()\n    ax.xaxis.set_ticks_position('top')\n    ax.set_title('xlabel top')\n    fig.canvas.draw()\n    assert ax.title.get_position()[1] > 1.04",
        "begin_line": 5343,
        "end_line": 5350,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_title_xticks_top_both#5353",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_title_xticks_top_both()",
        "snippet": "def test_title_xticks_top_both():\n    # Test that title moves if xticks on top of axes.\n    mpl.rcParams['axes.titley'] = None\n    fig, ax = plt.subplots()\n    ax.tick_params(axis=\"x\",\n                   bottom=True, top=True, labelbottom=True, labeltop=True)\n    ax.set_title('xlabel top')\n    fig.canvas.draw()\n    assert ax.title.get_position()[1] > 1.04",
        "begin_line": 5353,
        "end_line": 5361,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_offset_label_color#5364",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_offset_label_color()",
        "snippet": "def test_offset_label_color():\n    # Tests issue 6440\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    ax.plot([1.01e9, 1.02e9, 1.03e9])\n    ax.yaxis.set_tick_params(labelcolor='red')\n    assert ax.yaxis.get_offset_text().get_color() == 'red'",
        "begin_line": 5364,
        "end_line": 5370,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_offset_text_visible#5373",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_offset_text_visible()",
        "snippet": "def test_offset_text_visible():\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    ax.plot([1.01e9, 1.02e9, 1.03e9])\n    ax.yaxis.set_tick_params(label1On=False, label2On=True)\n    assert ax.yaxis.get_offset_text().get_visible()\n    ax.yaxis.set_tick_params(label2On=False)\n    assert not ax.yaxis.get_offset_text().get_visible()",
        "begin_line": 5373,
        "end_line": 5380,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_large_offset#5383",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_large_offset()",
        "snippet": "def test_large_offset():\n    fig, ax = plt.subplots()\n    ax.plot((1 + np.array([0, 1.e-12])) * 1.e27)\n    fig.canvas.draw()",
        "begin_line": 5383,
        "end_line": 5386,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_barb_units#5389",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_barb_units()",
        "snippet": "def test_barb_units():\n    fig, ax = plt.subplots()\n    dates = [datetime.datetime(2017, 7, 15, 18, i) for i in range(0, 60, 10)]\n    y = np.linspace(0, 5, len(dates))\n    u = v = np.linspace(0, 50, len(dates))\n    ax.barbs(dates, y, u, v)",
        "begin_line": 5389,
        "end_line": 5394,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_quiver_units#5397",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_quiver_units()",
        "snippet": "def test_quiver_units():\n    fig, ax = plt.subplots()\n    dates = [datetime.datetime(2017, 7, 15, 18, i) for i in range(0, 60, 10)]\n    y = np.linspace(0, 5, len(dates))\n    u = v = np.linspace(0, 50, len(dates))\n    ax.quiver(dates, y, u, v)",
        "begin_line": 5397,
        "end_line": 5402,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_color_cycle#5405",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_color_cycle()",
        "snippet": "def test_bar_color_cycle():\n    to_rgb = mcolors.to_rgb\n    fig, ax = plt.subplots()\n    for j in range(5):\n        ln, = ax.plot(range(3))\n        brs = ax.bar(range(3), range(3))\n        for br in brs:\n            assert to_rgb(ln.get_color()) == to_rgb(br.get_facecolor())",
        "begin_line": 5405,
        "end_line": 5412,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_tick_param_label_rotation#5415",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_tick_param_label_rotation()",
        "snippet": "def test_tick_param_label_rotation():\n    fix, (ax, ax2) = plt.subplots(1, 2)\n    ax.plot([0, 1], [0, 1])\n    ax2.plot([0, 1], [0, 1])\n    ax.xaxis.set_tick_params(which='both', rotation=75)\n    ax.yaxis.set_tick_params(which='both', rotation=90)\n    for text in ax.get_xticklabels(which='both'):\n        assert text.get_rotation() == 75\n    for text in ax.get_yticklabels(which='both'):\n        assert text.get_rotation() == 90\n\n    ax2.tick_params(axis='x', labelrotation=53)\n    ax2.tick_params(axis='y', rotation=35)\n    for text in ax2.get_xticklabels(which='major'):\n        assert text.get_rotation() == 53\n    for text in ax2.get_yticklabels(which='major'):\n        assert text.get_rotation() == 35",
        "begin_line": 5415,
        "end_line": 5431,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_fillbetween_cycle#5435",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_fillbetween_cycle()",
        "snippet": "def test_fillbetween_cycle():\n    fig, ax = plt.subplots()\n\n    for j in range(3):\n        cc = ax.fill_between(range(3), range(3))\n        target = mcolors.to_rgba('C{}'.format(j))\n        assert tuple(cc.get_facecolors().squeeze()) == tuple(target)\n\n    for j in range(3, 6):\n        cc = ax.fill_betweenx(range(3), range(3))\n        target = mcolors.to_rgba('C{}'.format(j))\n        assert tuple(cc.get_facecolors().squeeze()) == tuple(target)\n\n    target = mcolors.to_rgba('k')\n\n    for al in ['facecolor', 'facecolors', 'color']:\n        cc = ax.fill_between(range(3), range(3), **{al: 'k'})\n        assert tuple(cc.get_facecolors().squeeze()) == tuple(target)\n\n    edge_target = mcolors.to_rgba('k')\n    for j, el in enumerate(['edgecolor', 'edgecolors'], start=6):\n        cc = ax.fill_between(range(3), range(3), **{el: 'k'})\n        face_target = mcolors.to_rgba('C{}'.format(j))\n        assert tuple(cc.get_facecolors().squeeze()) == tuple(face_target)\n        assert tuple(cc.get_edgecolors().squeeze()) == tuple(edge_target)",
        "begin_line": 5435,
        "end_line": 5459,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_log_margins#5462",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_log_margins()",
        "snippet": "def test_log_margins():\n    plt.rcParams['axes.autolimit_mode'] = 'data'\n    fig, ax = plt.subplots()\n    margin = 0.05\n    ax.set_xmargin(margin)\n    ax.semilogx([10, 100], [10, 100])\n    xlim0, xlim1 = ax.get_xlim()\n    transform = ax.xaxis.get_transform()\n    xlim0t, xlim1t = transform.transform([xlim0, xlim1])\n    x0t, x1t = transform.transform([10, 100])\n    delta = (x1t - x0t) * margin\n    assert_allclose([xlim0t + delta, xlim1t - delta], [x0t, x1t])",
        "begin_line": 5462,
        "end_line": 5473,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_color_length_mismatch#5476",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_color_length_mismatch()",
        "snippet": "def test_color_length_mismatch():\n    N = 5\n    x, y = np.arange(N), np.arange(N)\n    colors = np.arange(N+1)\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.scatter(x, y, c=colors)\n    c_rgb = (0.5, 0.5, 0.5)\n    ax.scatter(x, y, c=c_rgb)\n    ax.scatter(x, y, c=[c_rgb] * N)",
        "begin_line": 5476,
        "end_line": 5485,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_eventplot_legend#5488",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_eventplot_legend()",
        "snippet": "def test_eventplot_legend():\n    plt.eventplot([1.0], label='Label')\n    plt.legend()",
        "begin_line": 5488,
        "end_line": 5490,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_broadcast_args#5493",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_broadcast_args()",
        "snippet": "def test_bar_broadcast_args():\n    fig, ax = plt.subplots()\n    # Check that a bar chart with a single height for all bars works.\n    ax.bar(range(4), 1)\n    # Check that a horizontal chart with one width works.\n    ax.bar(0, 1, bottom=range(4), width=1, orientation='horizontal')\n    # Check that edgecolor gets broadcast.\n    rect1, rect2 = ax.bar([0, 1], [0, 1], edgecolor=(.1, .2, .3, .4))\n    assert rect1.get_edgecolor() == rect2.get_edgecolor() == (.1, .2, .3, .4)",
        "begin_line": 5493,
        "end_line": 5501,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_invalid_axis_limits#5504",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_invalid_axis_limits()",
        "snippet": "def test_invalid_axis_limits():\n    plt.plot([0, 1], [0, 1])\n    with pytest.raises(ValueError):\n        plt.xlim(np.nan)\n    with pytest.raises(ValueError):\n        plt.xlim(np.inf)\n    with pytest.raises(ValueError):\n        plt.ylim(np.nan)\n    with pytest.raises(ValueError):\n        plt.ylim(np.inf)",
        "begin_line": 5504,
        "end_line": 5513,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_minorticks_on#5519",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_minorticks_on(xscale, yscale)",
        "snippet": "def test_minorticks_on(xscale, yscale):\n    ax = plt.subplot(111)\n    ax.plot([1, 2, 3, 4])\n    ax.set_xscale(xscale)\n    ax.set_yscale(yscale)\n    ax.minorticks_on()",
        "begin_line": 5519,
        "end_line": 5524,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_twinx_knows_limits#5527",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_twinx_knows_limits()",
        "snippet": "def test_twinx_knows_limits():\n    fig, ax = plt.subplots()\n\n    ax.axvspan(1, 2)\n    xtwin = ax.twinx()\n    xtwin.plot([0, 0.5], [1, 2])\n    # control axis\n    fig2, ax2 = plt.subplots()\n\n    ax2.axvspan(1, 2)\n    ax2.plot([0, 0.5], [1, 2])\n\n    assert_array_equal(xtwin.viewLim.intervalx, ax2.viewLim.intervalx)",
        "begin_line": 5527,
        "end_line": 5539,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_zero_linewidth#5542",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_zero_linewidth()",
        "snippet": "def test_zero_linewidth():\n    # Check that setting a zero linewidth doesn't error\n    plt.plot([0, 1], [0, 1], ls='--', lw=0)",
        "begin_line": 5542,
        "end_line": 5544,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_empty_errorbar_legend#5547",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_empty_errorbar_legend()",
        "snippet": "def test_empty_errorbar_legend():\n    fig, ax = plt.subplots()\n    ax.errorbar([], [], xerr=[], label='empty y')\n    ax.errorbar([], [], yerr=[], label='empty x')\n    ax.legend()",
        "begin_line": 5547,
        "end_line": 5551,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_plot_decimal#5555",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_plot_decimal(fig_test, fig_ref)",
        "snippet": "def test_plot_decimal(fig_test, fig_ref):\n    x0 = np.arange(-10, 10, 0.3)\n    y0 = [5.2 * x ** 3 - 2.1 * x ** 2 + 7.34 * x + 4.5 for x in x0]\n    x = [Decimal(i) for i in x0]\n    y = [Decimal(i) for i in y0]\n    # Test image - line plot with Decimal input\n    fig_test.subplots().plot(x, y)\n    # Reference image\n    fig_ref.subplots().plot(x0, y0)",
        "begin_line": 5555,
        "end_line": 5563,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_markerfacecolor_none_alpha#5568",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_markerfacecolor_none_alpha(fig_test, fig_ref)",
        "snippet": "def test_markerfacecolor_none_alpha(fig_test, fig_ref):\n    fig_test.subplots().plot(0, \"o\", mfc=\"none\", alpha=.5)\n    fig_ref.subplots().plot(0, \"o\", mfc=\"w\", alpha=.5)",
        "begin_line": 5568,
        "end_line": 5570,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_tick_padding_tightbbox#5573",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_tick_padding_tightbbox()",
        "snippet": "def test_tick_padding_tightbbox():\n    \"\"\"Test that tick padding gets turned off if axis is off\"\"\"\n    plt.rcParams[\"xtick.direction\"] = \"out\"\n    plt.rcParams[\"ytick.direction\"] = \"out\"\n    fig, ax = plt.subplots()\n    bb = ax.get_tightbbox(fig.canvas.get_renderer())\n    ax.axis('off')\n    bb2 = ax.get_tightbbox(fig.canvas.get_renderer())\n    assert bb.x0 < bb2.x0\n    assert bb.y0 < bb2.y0",
        "begin_line": 5573,
        "end_line": 5582,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_inset#5585",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_inset()",
        "snippet": "def test_inset():\n    \"\"\"\n    Ensure that inset_ax argument is indeed optional\n    \"\"\"\n    dx, dy = 0.05, 0.05\n    # generate 2 2d grids for the x & y bounds\n    y, x = np.mgrid[slice(1, 5 + dy, dy),\n                    slice(1, 5 + dx, dx)]\n    z = np.sin(x) ** 10 + np.cos(10 + y * x) * np.cos(x)\n\n    fig, ax = plt.subplots()\n    ax.pcolormesh(x, y, z[:-1, :-1])\n    ax.set_aspect(1.)\n    ax.apply_aspect()\n    # we need to apply_aspect to make the drawing below work.\n\n    xlim = [1.5, 2.15]\n    ylim = [2, 2.5]\n\n    rect = [xlim[0], ylim[0], xlim[1] - xlim[0], ylim[1] - ylim[0]]\n\n    rec, connectors = ax.indicate_inset(bounds=rect)\n    assert connectors is None\n    fig.canvas.draw()\n    xx = np.array([[1.5, 2.],\n                   [2.15, 2.5]])\n    assert np.all(rec.get_bbox().get_points() == xx)",
        "begin_line": 5585,
        "end_line": 5611,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_zoom_inset#5614",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_zoom_inset()",
        "snippet": "def test_zoom_inset():\n    dx, dy = 0.05, 0.05\n    # generate 2 2d grids for the x & y bounds\n    y, x = np.mgrid[slice(1, 5 + dy, dy),\n                    slice(1, 5 + dx, dx)]\n    z = np.sin(x)**10 + np.cos(10 + y*x) * np.cos(x)\n\n    fig, ax = plt.subplots()\n    ax.pcolormesh(x, y, z[:-1, :-1])\n    ax.set_aspect(1.)\n    ax.apply_aspect()\n    # we need to apply_aspect to make the drawing below work.\n\n    # Make the inset_axes...  Position axes coordinates...\n    axin1 = ax.inset_axes([0.7, 0.7, 0.35, 0.35])\n    # redraw the data in the inset axes...\n    axin1.pcolormesh(x, y, z[:-1, :-1])\n    axin1.set_xlim([1.5, 2.15])\n    axin1.set_ylim([2, 2.5])\n    axin1.set_aspect(ax.get_aspect())\n\n    rec, connectors = ax.indicate_inset_zoom(axin1)\n    assert len(connectors) == 4\n    fig.canvas.draw()\n    xx = np.array([[1.5,  2.],\n                   [2.15, 2.5]])\n    assert(np.all(rec.get_bbox().get_points() == xx))\n    xx = np.array([[0.6325, 0.692308],\n                   [0.8425, 0.907692]])\n    np.testing.assert_allclose(\n        axin1.get_position().get_points(), xx, rtol=1e-4)",
        "begin_line": 5614,
        "end_line": 5644,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_indicate_inset_inverted#5649",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_indicate_inset_inverted(x_inverted, y_inverted)",
        "snippet": "def test_indicate_inset_inverted(x_inverted, y_inverted):\n    \"\"\"\n    Test that the inset lines are correctly located with inverted data axes.\n    \"\"\"\n    fig, (ax1, ax2) = plt.subplots(1, 2)\n\n    x = np.arange(10)\n    ax1.plot(x, x, 'o')\n    if x_inverted:\n        ax1.invert_xaxis()\n    if y_inverted:\n        ax1.invert_yaxis()\n\n    rect, bounds = ax1.indicate_inset([2, 2, 5, 4], ax2)\n    lower_left, upper_left, lower_right, upper_right = bounds\n\n    sign_x = -1 if x_inverted else 1\n    sign_y = -1 if y_inverted else 1\n    assert sign_x * (lower_right.xy2[0] - lower_left.xy2[0]) > 0\n    assert sign_x * (upper_right.xy2[0] - upper_left.xy2[0]) > 0\n    assert sign_y * (upper_left.xy2[1] - lower_left.xy2[1]) > 0\n    assert sign_y * (upper_right.xy2[1] - lower_right.xy2[1]) > 0",
        "begin_line": 5649,
        "end_line": 5670,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_set_position#5673",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_set_position()",
        "snippet": "def test_set_position():\n    fig, ax = plt.subplots()\n    ax.set_aspect(3.)\n    ax.set_position([0.1, 0.1, 0.4, 0.4], which='both')\n    assert np.allclose(ax.get_position().width, 0.1)\n    ax.set_aspect(2.)\n    ax.set_position([0.1, 0.1, 0.4, 0.4], which='original')\n    assert np.allclose(ax.get_position().width, 0.15)\n    ax.set_aspect(3.)\n    ax.set_position([0.1, 0.1, 0.4, 0.4], which='active')\n    assert np.allclose(ax.get_position().width, 0.1)",
        "begin_line": 5673,
        "end_line": 5683,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_spines_properbbox_after_zoom#5686",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_spines_properbbox_after_zoom()",
        "snippet": "def test_spines_properbbox_after_zoom():\n    fig, ax = plt.subplots()\n    bb = ax.spines['bottom'].get_window_extent(fig.canvas.get_renderer())\n    # this is what zoom calls:\n    ax._set_view_from_bbox((320, 320, 500, 500), 'in',\n                           None, False, False)\n    bb2 = ax.spines['bottom'].get_window_extent(fig.canvas.get_renderer())\n    np.testing.assert_allclose(bb.get_points(), bb2.get_points(), rtol=1e-6)",
        "begin_line": 5686,
        "end_line": 5693,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_cartopy_backcompat#5696",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_cartopy_backcompat()",
        "snippet": "def test_cartopy_backcompat():\n\n    class Dummy(matplotlib.axes.Axes):\n        ...\n\n    class DummySubplot(matplotlib.axes.SubplotBase, Dummy):\n        _axes_class = Dummy\n\n    matplotlib.axes._subplots._subplot_classes[Dummy] = DummySubplot\n\n    FactoryDummySubplot = matplotlib.axes.subplot_class_factory(Dummy)\n\n    assert DummySubplot is FactoryDummySubplot",
        "begin_line": 5696,
        "end_line": 5708,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.Dummy.test_cartopy_backcompat#5696",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.Dummy",
        "signature": "lib.matplotlib.tests.test_axes.Dummy.test_cartopy_backcompat()",
        "snippet": "def test_cartopy_backcompat():\n\n    class Dummy(matplotlib.axes.Axes):\n        ...\n\n    class DummySubplot(matplotlib.axes.SubplotBase, Dummy):\n        _axes_class = Dummy\n\n    matplotlib.axes._subplots._subplot_classes[Dummy] = DummySubplot\n\n    FactoryDummySubplot = matplotlib.axes.subplot_class_factory(Dummy)\n\n    assert DummySubplot is FactoryDummySubplot",
        "begin_line": 5696,
        "end_line": 5708,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.DummySubplot.test_cartopy_backcompat#5696",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes.DummySubplot",
        "signature": "lib.matplotlib.tests.test_axes.DummySubplot.test_cartopy_backcompat()",
        "snippet": "def test_cartopy_backcompat():\n\n    class Dummy(matplotlib.axes.Axes):\n        ...\n\n    class DummySubplot(matplotlib.axes.SubplotBase, Dummy):\n        _axes_class = Dummy\n\n    matplotlib.axes._subplots._subplot_classes[Dummy] = DummySubplot\n\n    FactoryDummySubplot = matplotlib.axes.subplot_class_factory(Dummy)\n\n    assert DummySubplot is FactoryDummySubplot",
        "begin_line": 5696,
        "end_line": 5708,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_gettightbbox_ignoreNaN#5711",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_gettightbbox_ignoreNaN()",
        "snippet": "def test_gettightbbox_ignoreNaN():\n    fig, ax = plt.subplots()\n    remove_ticks_and_titles(fig)\n    ax.text(np.NaN, 1, 'Boo')\n    renderer = fig.canvas.get_renderer()\n    np.testing.assert_allclose(ax.get_tightbbox(renderer).width, 496)",
        "begin_line": 5711,
        "end_line": 5716,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_scatter_series_non_zero_index#5719",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_scatter_series_non_zero_index(pd)",
        "snippet": "def test_scatter_series_non_zero_index(pd):\n    # create non-zero index\n    ids = range(10, 18)\n    x = pd.Series(np.random.uniform(size=8), index=ids)\n    y = pd.Series(np.random.uniform(size=8), index=ids)\n    c = pd.Series([1, 1, 1, 1, 1, 0, 0, 0], index=ids)\n    plt.scatter(x, y, c)",
        "begin_line": 5719,
        "end_line": 5725,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_scatter_empty_data#5728",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_scatter_empty_data()",
        "snippet": "def test_scatter_empty_data():\n    # making sure this does not raise an exception\n    plt.scatter([], [])\n    plt.scatter([], [], s=[], c=[])",
        "begin_line": 5728,
        "end_line": 5731,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_annotate_across_transforms#5736",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_annotate_across_transforms()",
        "snippet": "def test_annotate_across_transforms():\n    x = np.linspace(0, 10, 200)\n    y = np.exp(-x) * np.sin(x)\n\n    fig, ax = plt.subplots(figsize=(3.39, 3))\n    ax.plot(x, y)\n    axins = ax.inset_axes([0.4, 0.5, 0.3, 0.3])\n    axins.set_aspect(0.2)\n    axins.xaxis.set_visible(False)\n    axins.yaxis.set_visible(False)\n    ax.annotate(\"\", xy=(x[150], y[150]), xycoords=ax.transData,\n                xytext=(1, 0), textcoords=axins.transAxes,\n                arrowprops=dict(arrowstyle=\"->\"))",
        "begin_line": 5736,
        "end_line": 5748,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_secondary_xy#5752",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_secondary_xy()",
        "snippet": "def test_secondary_xy():\n    fig, axs = plt.subplots(1, 2, figsize=(10, 5), constrained_layout=True)\n\n    def invert(x):\n        with np.errstate(divide='ignore'):\n            return 1 / x\n\n    for nn, ax in enumerate(axs):\n        ax.plot(np.arange(2, 11), np.arange(2, 11))\n        if nn == 0:\n            secax = ax.secondary_xaxis\n        else:\n            secax = ax.secondary_yaxis\n\n        secax(0.2, functions=(invert, invert))\n        secax(0.4, functions=(lambda x: 2 * x, lambda x: x / 2))\n        secax(0.6, functions=(lambda x: x**2, lambda x: x**(1/2)))\n        secax(0.8)",
        "begin_line": 5752,
        "end_line": 5769,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.invert#5755",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.invert(x)",
        "snippet": "    def invert(x):\n        with np.errstate(divide='ignore'):\n            return 1 / x",
        "begin_line": 5755,
        "end_line": 5757,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_secondary_fail#5772",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_secondary_fail()",
        "snippet": "def test_secondary_fail():\n    fig, ax = plt.subplots()\n    ax.plot(np.arange(2, 11), np.arange(2, 11))\n    with pytest.raises(ValueError):\n        ax.secondary_xaxis(0.2, functions=(lambda x: 1 / x))\n    with pytest.raises(ValueError):\n        ax.secondary_xaxis('right')\n    with pytest.raises(ValueError):\n        ax.secondary_yaxis('bottom')",
        "begin_line": 5772,
        "end_line": 5780,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_secondary_resize#5783",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_secondary_resize()",
        "snippet": "def test_secondary_resize():\n    fig, ax = plt.subplots(figsize=(10, 5))\n    ax.plot(np.arange(2, 11), np.arange(2, 11))\n    def invert(x):\n        with np.errstate(divide='ignore'):\n            return 1 / x\n\n    ax.secondary_xaxis('top', functions=(invert, invert))\n    fig.canvas.draw()\n    fig.set_size_inches((7, 4))\n    assert_allclose(ax.get_position().extents, [0.125, 0.1, 0.9, 0.9])",
        "begin_line": 5783,
        "end_line": 5793,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.invert#5786",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.invert(x)",
        "snippet": "    def invert(x):\n        with np.errstate(divide='ignore'):\n            return 1 / x",
        "begin_line": 5786,
        "end_line": 5788,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_secondary_minorloc#5796",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_secondary_minorloc()",
        "snippet": "def test_secondary_minorloc():\n    fig, ax = plt.subplots(figsize=(10, 5))\n    ax.plot(np.arange(2, 11), np.arange(2, 11))\n    def invert(x):\n        with np.errstate(divide='ignore'):\n            return 1 / x\n\n    secax = ax.secondary_xaxis('top', functions=(invert, invert))\n    assert isinstance(secax._axis.get_minor_locator(),\n                      mticker.NullLocator)\n    secax.minorticks_on()\n    assert isinstance(secax._axis.get_minor_locator(),\n                      mticker.AutoMinorLocator)\n    ax.set_xscale('log')\n    plt.draw()\n    assert isinstance(secax._axis.get_minor_locator(),\n                      mticker.LogLocator)\n    ax.set_xscale('linear')\n    plt.draw()\n    assert isinstance(secax._axis.get_minor_locator(),\n                      mticker.NullLocator)",
        "begin_line": 5796,
        "end_line": 5816,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.invert#5799",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.invert(x)",
        "snippet": "    def invert(x):\n        with np.errstate(divide='ignore'):\n            return 1 / x",
        "begin_line": 5799,
        "end_line": 5801,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_secondary_formatter#5819",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_secondary_formatter()",
        "snippet": "def test_secondary_formatter():\n    fig, ax = plt.subplots()\n    ax.set_xscale(\"log\")\n    secax = ax.secondary_xaxis(\"top\")\n    secax.xaxis.set_major_formatter(mticker.ScalarFormatter())\n    fig.canvas.draw()\n    assert isinstance(\n        secax.xaxis.get_major_formatter(), mticker.ScalarFormatter)",
        "begin_line": 5819,
        "end_line": 5826,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.color_boxes#5829",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.color_boxes(fig, axs)",
        "snippet": "def color_boxes(fig, axs):\n    \"\"\"\n    Helper for the tests below that test the extents of various axes elements\n    \"\"\"\n    fig.canvas.draw()\n\n    renderer = fig.canvas.get_renderer()\n    bbaxis = []\n    for nn, axx in enumerate([axs.xaxis, axs.yaxis]):\n        bb = axx.get_tightbbox(renderer)\n        if bb:\n            axisr = plt.Rectangle(\n                (bb.x0, bb.y0), width=bb.width, height=bb.height,\n                linewidth=0.7, edgecolor='y', facecolor=\"none\", transform=None,\n                zorder=3)\n            fig.add_artist(axisr)\n        bbaxis += [bb]\n\n    bbspines = []\n    for nn, a in enumerate(['bottom', 'top', 'left', 'right']):\n        bb = axs.spines[a].get_window_extent(renderer)\n        spiner = plt.Rectangle(\n            (bb.x0, bb.y0), width=bb.width, height=bb.height,\n            linewidth=0.7, edgecolor=\"green\", facecolor=\"none\", transform=None,\n            zorder=3)\n        fig.add_artist(spiner)\n        bbspines += [bb]\n\n    bb = axs.get_window_extent()\n    rect2 = plt.Rectangle(\n        (bb.x0, bb.y0), width=bb.width, height=bb.height,\n        linewidth=1.5, edgecolor=\"magenta\", facecolor=\"none\", transform=None,\n        zorder=2)\n    fig.add_artist(rect2)\n    bbax = bb\n\n    bb2 = axs.get_tightbbox(renderer)\n    rect2 = plt.Rectangle(\n        (bb2.x0, bb2.y0), width=bb2.width, height=bb2.height,\n        linewidth=3, edgecolor=\"red\", facecolor=\"none\", transform=None,\n        zorder=1)\n    fig.add_artist(rect2)\n    bbtb = bb2\n    return bbaxis, bbspines, bbax, bbtb",
        "begin_line": 5829,
        "end_line": 5872,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_normal_axes#5875",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_normal_axes()",
        "snippet": "def test_normal_axes():\n    with rc_context({'_internal.classic_mode': False}):\n        fig, ax = plt.subplots(dpi=200, figsize=(6, 6))\n        fig.canvas.draw()\n        plt.close(fig)\n        bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n\n    # test the axis bboxes\n    target = [\n        [123.375, 75.88888888888886, 983.25, 33.0],\n        [85.51388888888889, 99.99999999999997, 53.375, 993.0]\n    ]\n    for nn, b in enumerate(bbaxis):\n        targetbb = mtransforms.Bbox.from_bounds(*target[nn])\n        assert_array_almost_equal(b.bounds, targetbb.bounds, decimal=2)\n\n    target = [\n        [150.0, 119.999, 930.0, 11.111],\n        [150.0, 1080.0, 930.0, 0.0],\n        [150.0, 119.9999, 11.111, 960.0],\n        [1068.8888, 119.9999, 11.111, 960.0]\n    ]\n    for nn, b in enumerate(bbspines):\n        targetbb = mtransforms.Bbox.from_bounds(*target[nn])\n        assert_array_almost_equal(b.bounds, targetbb.bounds, decimal=2)\n\n    target = [150.0, 119.99999999999997, 930.0, 960.0]\n    targetbb = mtransforms.Bbox.from_bounds(*target)\n    assert_array_almost_equal(bbax.bounds, targetbb.bounds, decimal=2)\n\n    target = [85.5138, 75.88888, 1021.11, 1017.11]\n    targetbb = mtransforms.Bbox.from_bounds(*target)\n    assert_array_almost_equal(bbtb.bounds, targetbb.bounds, decimal=2)\n\n    # test that get_position roundtrips to get_window_extent\n    axbb = ax.get_position().transformed(fig.transFigure).bounds\n    assert_array_almost_equal(axbb, ax.get_window_extent().bounds, decimal=2)",
        "begin_line": 5875,
        "end_line": 5911,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_nodecorator#5914",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_nodecorator()",
        "snippet": "def test_nodecorator():\n    with rc_context({'_internal.classic_mode': False}):\n        fig, ax = plt.subplots(dpi=200, figsize=(6, 6))\n        fig.canvas.draw()\n        ax.set(xticklabels=[], yticklabels=[])\n        bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n\n    # test the axis bboxes\n    target = [\n        None,\n        None\n    ]\n    for nn, b in enumerate(bbaxis):\n        assert b is None\n\n    target = [\n        [150.0, 119.999, 930.0, 11.111],\n        [150.0, 1080.0, 930.0, 0.0],\n        [150.0, 119.9999, 11.111, 960.0],\n        [1068.8888, 119.9999, 11.111, 960.0]\n    ]\n    for nn, b in enumerate(bbspines):\n        targetbb = mtransforms.Bbox.from_bounds(*target[nn])\n        assert_allclose(b.bounds, targetbb.bounds, atol=1e-2)\n\n    target = [150.0, 119.99999999999997, 930.0, 960.0]\n    targetbb = mtransforms.Bbox.from_bounds(*target)\n    assert_allclose(bbax.bounds, targetbb.bounds, atol=1e-2)\n\n    target = [150., 120., 930., 960.]\n    targetbb = mtransforms.Bbox.from_bounds(*target)\n    assert_allclose(bbtb.bounds, targetbb.bounds, atol=1e-2)",
        "begin_line": 5914,
        "end_line": 5945,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_displaced_spine#5948",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_displaced_spine()",
        "snippet": "def test_displaced_spine():\n    with rc_context({'_internal.classic_mode': False}):\n        fig, ax = plt.subplots(dpi=200, figsize=(6, 6))\n        ax.set(xticklabels=[], yticklabels=[])\n        ax.spines['bottom'].set_position(('axes', -0.1))\n        fig.canvas.draw()\n        bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n\n    target = [\n        [150., 24., 930., 11.111111],\n        [150.0, 1080.0, 930.0, 0.0],\n        [150.0, 119.9999, 11.111, 960.0],\n        [1068.8888, 119.9999, 11.111, 960.0]\n    ]\n    for nn, b in enumerate(bbspines):\n        targetbb = mtransforms.Bbox.from_bounds(*target[nn])\n\n    target = [150.0, 119.99999999999997, 930.0, 960.0]\n    targetbb = mtransforms.Bbox.from_bounds(*target)\n    assert_allclose(bbax.bounds, targetbb.bounds, atol=1e-2)\n\n    target = [150., 24., 930., 1056.]\n    targetbb = mtransforms.Bbox.from_bounds(*target)\n    assert_allclose(bbtb.bounds, targetbb.bounds, atol=1e-2)",
        "begin_line": 5948,
        "end_line": 5971,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_tickdirs#5974",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_tickdirs()",
        "snippet": "def test_tickdirs():\n    \"\"\"\n    Switch the tickdirs and make sure the bboxes switch with them\n    \"\"\"\n    targets = [[[150.0, 120.0, 930.0, 11.1111],\n                [150.0, 120.0, 11.111, 960.0]],\n               [[150.0, 108.8889, 930.0, 11.111111111111114],\n                [138.889, 120, 11.111, 960.0]],\n               [[150.0, 114.44444444444441, 930.0, 11.111111111111114],\n                [144.44444444444446, 119.999, 11.111, 960.0]]]\n    for dnum, dirs in enumerate(['in', 'out', 'inout']):\n        with rc_context({'_internal.classic_mode': False}):\n            fig, ax = plt.subplots(dpi=200, figsize=(6, 6))\n            ax.tick_params(direction=dirs)\n            fig.canvas.draw()\n            bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n            for nn, num in enumerate([0, 2]):\n                targetbb = mtransforms.Bbox.from_bounds(*targets[dnum][nn])\n                assert_allclose(\n                    bbspines[num].bounds, targetbb.bounds, atol=1e-2)",
        "begin_line": 5974,
        "end_line": 5993,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_minor_accountedfor#5996",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_minor_accountedfor()",
        "snippet": "def test_minor_accountedfor():\n    with rc_context({'_internal.classic_mode': False}):\n        fig, ax = plt.subplots(dpi=200, figsize=(6, 6))\n        fig.canvas.draw()\n        ax.tick_params(which='both', direction='out')\n\n        bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n        bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n        targets = [[150.0, 108.88888888888886, 930.0, 11.111111111111114],\n                   [138.8889, 119.9999, 11.1111, 960.0]]\n        for n in range(2):\n            targetbb = mtransforms.Bbox.from_bounds(*targets[n])\n            assert_allclose(\n                bbspines[n * 2].bounds, targetbb.bounds, atol=1e-2)\n\n        fig, ax = plt.subplots(dpi=200, figsize=(6, 6))\n        fig.canvas.draw()\n        ax.tick_params(which='both', direction='out')\n        ax.minorticks_on()\n        ax.tick_params(axis='both', which='minor', length=30)\n        fig.canvas.draw()\n        bbaxis, bbspines, bbax, bbtb = color_boxes(fig, ax)\n        targets = [[150.0, 36.66666666666663, 930.0, 83.33333333333334],\n                   [66.6667, 120.0, 83.3333, 960.0]]\n\n        for n in range(2):\n            targetbb = mtransforms.Bbox.from_bounds(*targets[n])\n            assert_allclose(\n                bbspines[n * 2].bounds, targetbb.bounds, atol=1e-2)",
        "begin_line": 5996,
        "end_line": 6024,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axis_bool_arguments#6028",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axis_bool_arguments(fig_test, fig_ref)",
        "snippet": "def test_axis_bool_arguments(fig_test, fig_ref):\n    # Test if False and \"off\" give the same\n    fig_test.add_subplot(211).axis(False)\n    fig_ref.add_subplot(211).axis(\"off\")\n    # Test if True after False gives the same as \"on\"\n    ax = fig_test.add_subplot(212)\n    ax.axis(False)\n    ax.axis(True)\n    fig_ref.add_subplot(212).axis(\"on\")",
        "begin_line": 6028,
        "end_line": 6036,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_axis_extent_arg#6039",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_axis_extent_arg()",
        "snippet": "def test_axis_extent_arg():\n    fig, ax = plt.subplots()\n    xmin = 5\n    xmax = 10\n    ymin = 15\n    ymax = 20\n    extent = ax.axis([xmin, xmax, ymin, ymax])\n\n    # test that the docstring is correct\n    assert tuple(extent) == (xmin, xmax, ymin, ymax)\n\n    # test that limits were set per the docstring\n    assert (xmin, xmax) == ax.get_xlim()\n    assert (ymin, ymax) == ax.get_ylim()",
        "begin_line": 6039,
        "end_line": 6052,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_datetime_masked#6055",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_datetime_masked()",
        "snippet": "def test_datetime_masked():\n    # make sure that all-masked data falls back to the viewlim\n    # set in convert.axisinfo....\n    x = np.array([datetime.datetime(2017, 1, n) for n in range(1, 6)])\n    y = np.array([1, 2, 3, 4, 5])\n    m = np.ma.masked_greater(y, 0)\n\n    fig, ax = plt.subplots()\n    ax.plot(x, m)\n    dt = mdates.date2num(np.datetime64('0000-12-31'))\n    assert ax.get_xlim() == (730120.0 + dt, 733773.0 + dt)",
        "begin_line": 6055,
        "end_line": 6065,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_auto_bins#6068",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_auto_bins()",
        "snippet": "def test_hist_auto_bins():\n    _, bins, _ = plt.hist([[1, 2, 3], [3, 4, 5, 6]], bins='auto')\n    assert bins[0] <= 1\n    assert bins[-1] >= 6",
        "begin_line": 6068,
        "end_line": 6071,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_nan_data#6074",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_nan_data()",
        "snippet": "def test_hist_nan_data():\n    fig, (ax1, ax2) = plt.subplots(2)\n\n    data = [1, 2, 3]\n    nan_data = data + [np.nan]\n\n    bins, edges, _ = ax1.hist(data)\n    with np.errstate(invalid='ignore'):\n        nanbins, nanedges, _ = ax2.hist(nan_data)\n\n    np.testing.assert_allclose(bins, nanbins)\n    np.testing.assert_allclose(edges, nanedges)",
        "begin_line": 6074,
        "end_line": 6085,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_hist_range_and_density#6088",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_hist_range_and_density()",
        "snippet": "def test_hist_range_and_density():\n    _, bins, _ = plt.hist(np.random.rand(10), \"auto\",\n                          range=(0, 1), density=True)\n    assert bins[0] == 0\n    assert bins[-1] == 1",
        "begin_line": 6088,
        "end_line": 6092,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bar_errbar_zorder#6095",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bar_errbar_zorder()",
        "snippet": "def test_bar_errbar_zorder():\n    # Check that the zorder of errorbars is always greater than the bar they\n    # are plotted on\n    fig, ax = plt.subplots()\n    x = [1, 2, 3]\n    barcont = ax.bar(x=x, height=x, yerr=x, capsize=5, zorder=3)\n\n    data_line, caplines, barlinecols = barcont.errorbar.lines\n    for bar in barcont.patches:\n        for capline in caplines:\n            assert capline.zorder > bar.zorder\n        for barlinecol in barlinecols:\n            assert barlinecol.zorder > bar.zorder",
        "begin_line": 6095,
        "end_line": 6107,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_set_ticks_inverted#6110",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_set_ticks_inverted()",
        "snippet": "def test_set_ticks_inverted():\n    fig, ax = plt.subplots()\n    ax.invert_xaxis()\n    ax.set_xticks([.3, .7])\n    assert ax.get_xlim() == (1, 0)",
        "begin_line": 6110,
        "end_line": 6114,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_aspect_nonlinear_adjustable_box#6117",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_aspect_nonlinear_adjustable_box()",
        "snippet": "def test_aspect_nonlinear_adjustable_box():\n    fig = plt.figure(figsize=(10, 10))  # Square.\n\n    ax = fig.add_subplot()\n    ax.plot([.4, .6], [.4, .6])  # Set minpos to keep logit happy.\n    ax.set(xscale=\"log\", xlim=(1, 10),\n           yscale=\"logit\", ylim=(1/11, 1/1001),\n           aspect=1, adjustable=\"box\")\n    ax.margins(0)\n    pos = fig.transFigure.transform_bbox(ax.get_position())\n    assert pos.height / pos.width == pytest.approx(2)",
        "begin_line": 6117,
        "end_line": 6127,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_aspect_nonlinear_adjustable_datalim#6130",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_aspect_nonlinear_adjustable_datalim()",
        "snippet": "def test_aspect_nonlinear_adjustable_datalim():\n    fig = plt.figure(figsize=(10, 10))  # Square.\n\n    ax = fig.add_axes([.1, .1, .8, .8])  # Square.\n    ax.plot([.4, .6], [.4, .6])  # Set minpos to keep logit happy.\n    ax.set(xscale=\"log\", xlim=(1, 100),\n           yscale=\"logit\", ylim=(1 / 101, 1 / 11),\n           aspect=1, adjustable=\"datalim\")\n    ax.margins(0)\n    ax.apply_aspect()\n\n    assert ax.get_xlim() == pytest.approx([1*10**(1/2), 100/10**(1/2)])\n    assert ax.get_ylim() == (1 / 101, 1 / 11)",
        "begin_line": 6130,
        "end_line": 6142,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_box_aspect#6145",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_box_aspect()",
        "snippet": "def test_box_aspect():\n    # Test if axes with box_aspect=1 has same dimensions\n    # as axes with aspect equal and adjustable=\"box\"\n\n    fig1, ax1 = plt.subplots()\n    axtwin = ax1.twinx()\n    axtwin.plot([12, 344])\n\n    ax1.set_box_aspect(1)\n\n    fig2, ax2 = plt.subplots()\n    ax2.margins(0)\n    ax2.plot([0, 2], [6, 8])\n    ax2.set_aspect(\"equal\", adjustable=\"box\")\n\n    fig1.canvas.draw()\n    fig2.canvas.draw()\n\n    bb1 = ax1.get_position()\n    bbt = axtwin.get_position()\n    bb2 = ax2.get_position()\n\n    assert_array_equal(bb1.extents, bb2.extents)\n    assert_array_equal(bbt.extents, bb2.extents)",
        "begin_line": 6145,
        "end_line": 6168,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_box_aspect_custom_position#6171",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_box_aspect_custom_position()",
        "snippet": "def test_box_aspect_custom_position():\n    # Test if axes with custom position and box_aspect\n    # behaves the same independent of the order of setting those.\n\n    fig1, ax1 = plt.subplots()\n    ax1.set_position([0.1, 0.1, 0.9, 0.2])\n    fig1.canvas.draw()\n    ax1.set_box_aspect(1.)\n\n    fig2, ax2 = plt.subplots()\n    ax2.set_box_aspect(1.)\n    fig2.canvas.draw()\n    ax2.set_position([0.1, 0.1, 0.9, 0.2])\n\n    fig1.canvas.draw()\n    fig2.canvas.draw()\n\n    bb1 = ax1.get_position()\n    bb2 = ax2.get_position()\n\n    assert_array_equal(bb1.extents, bb2.extents)",
        "begin_line": 6171,
        "end_line": 6191,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_bbox_aspect_axes_init#6194",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_bbox_aspect_axes_init()",
        "snippet": "def test_bbox_aspect_axes_init():\n    # Test that box_aspect can be given to axes init and produces\n    # all equal square axes.\n    fig, axs = plt.subplots(2, 3, subplot_kw=dict(box_aspect=1),\n                            constrained_layout=True)\n    fig.canvas.draw()\n    renderer = fig.canvas.get_renderer()\n    sizes = []\n    for ax in axs.flat:\n        bb = ax.get_window_extent(renderer)\n        sizes.extend([bb.width, bb.height])\n\n    assert_allclose(sizes, sizes[0])",
        "begin_line": 6194,
        "end_line": 6206,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_pi_get_negative_values#6209",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_pi_get_negative_values()",
        "snippet": "def test_pi_get_negative_values():\n    # Test the ValueError raised when feeding negative values into axes.pie\n    fig, ax = plt.subplots()\n    with pytest.raises(ValueError):\n        ax.pie([5, 5, -3], explode=[0, .1, .2])",
        "begin_line": 6209,
        "end_line": 6213,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_invisible_axes#6216",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_invisible_axes()",
        "snippet": "def test_invisible_axes():\n    # invisible axes should not respond to events...\n    fig, ax = plt.subplots()\n    assert fig.canvas.inaxes((200, 200)) is not None\n    ax.set_visible(False)\n    assert fig.canvas.inaxes((200, 200)) is None",
        "begin_line": 6216,
        "end_line": 6221,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_xtickcolor_is_not_markercolor#6224",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_xtickcolor_is_not_markercolor()",
        "snippet": "def test_xtickcolor_is_not_markercolor():\n    plt.rcParams['lines.markeredgecolor'] = 'white'\n    ax = plt.axes()\n    ticks = ax.xaxis.get_major_ticks()\n    for tick in ticks:\n        assert tick.tick1line.get_markeredgecolor() != 'white'",
        "begin_line": 6224,
        "end_line": 6229,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_ytickcolor_is_not_markercolor#6232",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_ytickcolor_is_not_markercolor()",
        "snippet": "def test_ytickcolor_is_not_markercolor():\n    plt.rcParams['lines.markeredgecolor'] = 'white'\n    ax = plt.axes()\n    ticks = ax.yaxis.get_major_ticks()\n    for tick in ticks:\n        assert tick.tick1line.get_markeredgecolor() != 'white'",
        "begin_line": 6232,
        "end_line": 6237,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_polar_interpolation_steps_variable_r#6241",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_polar_interpolation_steps_variable_r(fig_test, fig_ref)",
        "snippet": "def test_polar_interpolation_steps_variable_r(fig_test, fig_ref):\n    l, = fig_test.add_subplot(projection=\"polar\").plot([0, np.pi/2], [1, 2])\n    l.get_path()._interpolation_steps = 100\n    fig_ref.add_subplot(projection=\"polar\").plot(\n        np.linspace(0, np.pi/2, 101), np.linspace(1, 2, 101))",
        "begin_line": 6241,
        "end_line": 6245,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_normalize_kwarg_warn_pie#6248",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_normalize_kwarg_warn_pie()",
        "snippet": "def test_normalize_kwarg_warn_pie():\n    fig, ax = plt.subplots()\n    with pytest.warns(MatplotlibDeprecationWarning):\n        ax.pie(x=[0], normalize=None)",
        "begin_line": 6248,
        "end_line": 6251,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "lib.matplotlib.tests.test_axes.test_normalize_kwarg_pie#6254",
        "src_path": "lib/matplotlib/tests/test_axes.py",
        "class_name": "lib.matplotlib.tests.test_axes",
        "signature": "lib.matplotlib.tests.test_axes.test_normalize_kwarg_pie()",
        "snippet": "def test_normalize_kwarg_pie():\n    fig, ax = plt.subplots()\n    x = [0.3, 0.3, 0.1]\n    t1 = ax.pie(x=x, normalize=True)\n    assert abs(t1[0][-1].theta2 - 360.) < 1e-3\n    t2 = ax.pie(x=x, normalize=False)\n    assert abs(t2[0][-1].theta2 - 360.) > 1e-3",
        "begin_line": 6254,
        "end_line": 6260,
        "comment": "",
        "is_bug": false
    }
]