[
    {
        "name": "cookiecutter.find.find_template#17",
        "src_path": "cookiecutter/find.py",
        "class_name": "cookiecutter.find",
        "signature": "cookiecutter.find.find_template(repo_dir)",
        "snippet": "def find_template(repo_dir):\n    \"\"\"\n    Determines which child directory of `repo_dir` is the project template.\n\n    :param repo_dir: Local directory of newly cloned repo.\n    :returns project_template: Relative path to project template.\n    \"\"\"\n\n    logging.debug('Searching {0} for the project template.'.format(repo_dir))\n\n    repo_dir_contents = os.listdir(repo_dir)\n\n    project_template = None\n    for item in repo_dir_contents:\n        if 'cookiecutter' in item and '{{' in item and '}}' in item:\n            project_template = item\n            break\n\n    if project_template:\n        project_template = os.path.join(repo_dir, project_template)\n        logging.debug(\n            'The project template appears to be {0}'.format(project_template)\n        )\n        return project_template\n    else:\n        raise NonTemplatedInputDirException",
        "begin_line": 17,
        "end_line": 42,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005917159763313609,
            "pseudo_dstar_susp": 0.008064516129032258,
            "pseudo_tarantula_susp": 0.004424778761061947,
            "pseudo_op2_susp": 0.008064516129032258,
            "pseudo_barinel_susp": 0.004424778761061947
        }
    },
    {
        "name": "cookiecutter.generate.copy_without_render#34",
        "src_path": "cookiecutter/generate.py",
        "class_name": "cookiecutter.generate",
        "signature": "cookiecutter.generate.copy_without_render(path, context)",
        "snippet": "def copy_without_render(path, context):\n    \"\"\"\n    Returns True if `path` matches some pattern in the\n    `_copy_without_render` context setting.\n\n    :param path: A file-system path referring to a file or dir that\n        should be rendered or just copied.\n    :param context: cookiecutter context.\n    \"\"\"\n    try:\n        for dont_render in context['cookiecutter']['_copy_without_render']:\n            if fnmatch.fnmatch(path, dont_render):\n                return True\n    except KeyError:\n        return False\n\n    return False",
        "begin_line": 34,
        "end_line": 50,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.011363636363636364,
            "pseudo_dstar_susp": 0.011904761904761904,
            "pseudo_tarantula_susp": 0.058823529411764705,
            "pseudo_op2_susp": 0.011904761904761904,
            "pseudo_barinel_susp": 0.058823529411764705
        }
    },
    {
        "name": "cookiecutter.generate.apply_overwrites_to_context#53",
        "src_path": "cookiecutter/generate.py",
        "class_name": "cookiecutter.generate",
        "signature": "cookiecutter.generate.apply_overwrites_to_context(context, overwrite_context)",
        "snippet": "def apply_overwrites_to_context(context, overwrite_context):\n    \"\"\"Modify the given context in place based on the overwrite_context.\"\"\"\n    for variable, overwrite in overwrite_context.items():\n        if variable not in context:\n            # Do not include variables which are not used in the template\n            continue\n\n        context_value = context[variable]\n\n        if isinstance(context_value, list):\n            # We are dealing with a choice variable\n            if overwrite in context_value:\n                # This overwrite is actually valid for the given context\n                # Let's set it as default (by definition first item in list)\n                # see ``cookiecutter.prompt.prompt_choice_for_config``\n                context_value.remove(overwrite)\n                context_value.insert(0, overwrite)\n        else:\n            # Simply overwrite the value for this variable\n            context[variable] = overwrite",
        "begin_line": 53,
        "end_line": 72,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002232142857142857,
            "pseudo_dstar_susp": 0.002232142857142857,
            "pseudo_tarantula_susp": 0.002232142857142857,
            "pseudo_op2_susp": 0.0021141649048625794,
            "pseudo_barinel_susp": 0.002232142857142857
        }
    },
    {
        "name": "cookiecutter.generate.generate_context#75",
        "src_path": "cookiecutter/generate.py",
        "class_name": "cookiecutter.generate",
        "signature": "cookiecutter.generate.generate_context(context_file='cookiecutter.json', default_context=None, extra_context=None)",
        "snippet": "def generate_context(context_file='cookiecutter.json', default_context=None,\n                     extra_context=None):\n    \"\"\"\n    Generates the context for a Cookiecutter project template.\n    Loads the JSON file as a Python object, with key being the JSON filename.\n\n    :param context_file: JSON file containing key/value pairs for populating\n        the cookiecutter's variables.\n    :param default_context: Dictionary containing config to take into account.\n    :param extra_context: Dictionary containing configuration overrides\n    \"\"\"\n\n    context = {}\n\n    file_handle = open(context_file)\n    try:\n        obj = json.load(file_handle, object_pairs_hook=OrderedDict)\n    except ValueError as e:\n        # JSON decoding error.  Let's throw a new exception that is more\n        # friendly for the developer or user.\n        full_fpath = os.path.abspath(context_file)\n        json_exc_message = str(e)\n        our_exc_message = (\n            'JSON decoding error while loading \"{0}\".  Decoding'\n            ' error details: \"{1}\"'.format(full_fpath, json_exc_message))\n        raise ContextDecodingException(our_exc_message)\n\n    # Add the Python object to the context dictionary\n    file_name = os.path.split(context_file)[1]\n    file_stem = file_name.split('.')[0]\n    context[file_stem] = obj\n\n    # Overwrite context variable defaults with the default context from the\n    # user's global config, if available\n    if default_context:\n        apply_overwrites_to_context(obj, default_context)\n    if extra_context:\n        apply_overwrites_to_context(obj, extra_context)\n\n    logging.debug('Context generated is {0}'.format(context))\n    return context",
        "begin_line": 75,
        "end_line": 115,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003115264797507788,
            "pseudo_dstar_susp": 0.003115264797507788,
            "pseudo_tarantula_susp": 0.003115264797507788,
            "pseudo_op2_susp": 0.003115264797507788,
            "pseudo_barinel_susp": 0.003115264797507788
        }
    },
    {
        "name": "cookiecutter.generate.generate_file#118",
        "src_path": "cookiecutter/generate.py",
        "class_name": "cookiecutter.generate",
        "signature": "cookiecutter.generate.generate_file(project_dir, infile, context, env)",
        "snippet": "def generate_file(project_dir, infile, context, env):\n    \"\"\"\n    1. Render the filename of infile as the name of outfile.\n    2. Deal with infile appropriately:\n\n        a. If infile is a binary file, copy it over without rendering.\n        b. If infile is a text file, render its contents and write the\n           rendered infile to outfile.\n\n    Precondition:\n\n        When calling `generate_file()`, the root template dir must be the\n        current working directory. Using `utils.work_in()` is the recommended\n        way to perform this directory change.\n\n    :param project_dir: Absolute path to the resulting generated project.\n    :param infile: Input file to generate the file from. Relative to the root\n        template dir.\n    :param context: Dict for populating the cookiecutter's variables.\n    :param env: Jinja2 template execution environment.\n    \"\"\"\n\n    logging.debug('Generating file {0}'.format(infile))\n\n    # Render the path to the output file (not including the root project dir)\n    outfile_tmpl = Template(infile)\n\n    outfile = os.path.join(project_dir, outfile_tmpl.render(**context))\n    file_name_is_empty = os.path.isdir(outfile)\n    if file_name_is_empty:\n        logging.debug('The resulting file name is empty: {0}'.format(outfile))\n        return\n\n    logging.debug('outfile is {0}'.format(outfile))\n\n    # Just copy over binary files. Don't render.\n    logging.debug(\"Check {0} to see if it's a binary\".format(infile))\n    if is_binary(infile):\n        logging.debug('Copying binary {0} to {1} without rendering'\n                      .format(infile, outfile))\n        shutil.copyfile(infile, outfile)\n    else:\n        # Force fwd slashes on Windows for get_template\n        # This is a by-design Jinja issue\n        infile_fwd_slashes = infile.replace(os.path.sep, '/')\n\n        # Render the file\n        try:\n            tmpl = env.get_template(infile_fwd_slashes)\n        except TemplateSyntaxError as exception:\n            # Disable translated so that printed exception contains verbose\n            # information about syntax error location\n            exception.translated = False\n            raise\n        rendered_file = tmpl.render(**context)\n\n        logging.debug('Writing {0}'.format(outfile))\n\n        with io.open(outfile, 'w', encoding='utf-8') as fh:\n            fh.write(rendered_file)\n\n    # Apply file permissions to output file\n    shutil.copymode(infile, outfile)",
        "begin_line": 118,
        "end_line": 180,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008849557522123894,
            "pseudo_dstar_susp": 0.00546448087431694,
            "pseudo_tarantula_susp": 0.023809523809523808,
            "pseudo_op2_susp": 0.00546448087431694,
            "pseudo_barinel_susp": 0.023809523809523808
        }
    },
    {
        "name": "cookiecutter.generate.render_and_create_dir#183",
        "src_path": "cookiecutter/generate.py",
        "class_name": "cookiecutter.generate",
        "signature": "cookiecutter.generate.render_and_create_dir(dirname, context, output_dir, overwrite_if_exists=False)",
        "snippet": "def render_and_create_dir(dirname, context, output_dir,\n                          overwrite_if_exists=False):\n    \"\"\"\n    Renders the name of a directory, creates the directory, and\n    returns its path.\n    \"\"\"\n\n    name_tmpl = Template(dirname)\n    rendered_dirname = name_tmpl.render(**context)\n    logging.debug('Rendered dir {0} must exist in output_dir {1}'.format(\n        rendered_dirname,\n        output_dir\n    ))\n    dir_to_create = os.path.normpath(\n        os.path.join(output_dir, rendered_dirname)\n    )\n\n    output_dir_exists = os.path.exists(dir_to_create)\n\n    if overwrite_if_exists:\n        if output_dir_exists:\n            logging.debug('Output directory {} already exists,'\n                          'overwriting it'.format(dir_to_create))\n    else:\n        if output_dir_exists:\n            msg = 'Error: \"{}\" directory already exists'.format(dir_to_create)\n            raise OutputDirExistsException(msg)\n\n    make_sure_path_exists(dir_to_create)\n    return dir_to_create",
        "begin_line": 183,
        "end_line": 212,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.008695652173913044,
            "pseudo_dstar_susp": 0.013333333333333334,
            "pseudo_tarantula_susp": 0.00641025641025641,
            "pseudo_op2_susp": 0.013333333333333334,
            "pseudo_barinel_susp": 0.00641025641025641
        }
    },
    {
        "name": "cookiecutter.generate.ensure_dir_is_templated#215",
        "src_path": "cookiecutter/generate.py",
        "class_name": "cookiecutter.generate",
        "signature": "cookiecutter.generate.ensure_dir_is_templated(dirname)",
        "snippet": "def ensure_dir_is_templated(dirname):\n    \"\"\"\n    Ensures that dirname is a templated directory name.\n    \"\"\"\n    if '{{' in dirname and '}}' in dirname:\n        return True\n    else:\n        raise NonTemplatedInputDirException",
        "begin_line": 215,
        "end_line": 222,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006666666666666667,
            "pseudo_dstar_susp": 0.009523809523809525,
            "pseudo_tarantula_susp": 0.004830917874396135,
            "pseudo_op2_susp": 0.009523809523809525,
            "pseudo_barinel_susp": 0.004830917874396135
        }
    },
    {
        "name": "cookiecutter.generate.generate_files#225",
        "src_path": "cookiecutter/generate.py",
        "class_name": "cookiecutter.generate",
        "signature": "cookiecutter.generate.generate_files(repo_dir, context=None, output_dir='.', overwrite_if_exists=False)",
        "snippet": "def generate_files(repo_dir, context=None, output_dir='.',\n                   overwrite_if_exists=False):\n    \"\"\"\n    Renders the templates and saves them to files.\n\n    :param repo_dir: Project template input directory.\n    :param context: Dict for populating the template's variables.\n    :param output_dir: Where to output the generated project dir into.\n    :param overwrite_if_exists: Overwrite the contents of the output directory\n        if it exists\n    \"\"\"\n\n    template_dir = find_template(repo_dir)\n    logging.debug('Generating project from {0}...'.format(template_dir))\n    context = context or {}\n\n    unrendered_dir = os.path.split(template_dir)[1]\n    ensure_dir_is_templated(unrendered_dir)\n    project_dir = render_and_create_dir(unrendered_dir,\n                                        context,\n                                        output_dir,\n                                        overwrite_if_exists)\n\n    # We want the Jinja path and the OS paths to match. Consequently, we'll:\n    #   + CD to the template folder\n    #   + Set Jinja's path to '.'\n    #\n    #  In order to build our files to the correct folder(s), we'll use an\n    # absolute path for the target folder (project_dir)\n\n    project_dir = os.path.abspath(project_dir)\n    logging.debug('project_dir is {0}'.format(project_dir))\n\n    # run pre-gen hook from repo_dir\n    with work_in(repo_dir):\n        if run_hook('pre_gen_project', project_dir, context) != EXIT_SUCCESS:\n            logging.error(\"Stopping generation because pre_gen_project\"\n                          \" hook script didn't exit sucessfully\")\n            return\n\n    with work_in(template_dir):\n        env = Environment(keep_trailing_newline=True)\n        env.loader = FileSystemLoader('.')\n\n        for root, dirs, files in os.walk('.'):\n            # We must separate the two types of dirs into different lists.\n            # The reason is that we don't want ``os.walk`` to go through the\n            # unrendered directories, since they will just be copied.\n            copy_dirs = []\n            render_dirs = []\n\n            for d in dirs:\n                d_ = os.path.normpath(os.path.join(root, d))\n                # We check the full path, because that's how it can be\n                # specified in the ``_copy_without_render`` setting, but\n                # we store just the dir name\n                if copy_without_render(d_, context):\n                    copy_dirs.append(d)\n                else:\n                    render_dirs.append(d)\n\n            for copy_dir in copy_dirs:\n                indir = os.path.normpath(os.path.join(root, copy_dir))\n                outdir = os.path.normpath(os.path.join(project_dir, indir))\n                logging.debug(\n                    'Copying dir {0} to {1} without rendering'\n                    ''.format(indir, outdir)\n                )\n                shutil.copytree(indir, outdir)\n\n            # We mutate ``dirs``, because we only want to go through these dirs\n            # recursively\n            dirs[:] = render_dirs\n            for d in dirs:\n                unrendered_dir = os.path.join(project_dir, root, d)\n                render_and_create_dir(unrendered_dir, context, output_dir,\n                                      overwrite_if_exists)\n\n            for f in files:\n                infile = os.path.normpath(os.path.join(root, f))\n                if copy_without_render(infile, context):\n                    outfile_tmpl = Template(infile)\n                    outfile_rendered = outfile_tmpl.render(**context)\n                    outfile = os.path.join(project_dir, outfile_rendered)\n                    logging.debug(\n                        'Copying file {0} to {1} without rendering'\n                        ''.format(infile, outfile)\n                    )\n                    shutil.copyfile(infile, outfile)\n                    shutil.copymode(infile, outfile)\n                    continue\n                logging.debug('f is {0}'.format(f))\n                generate_file(project_dir, infile, context, env)\n\n    # run post-gen hook from repo_dir\n    with work_in(repo_dir):\n        run_hook('post_gen_project', project_dir, context)\n\n    return project_dir",
        "begin_line": 225,
        "end_line": 323,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.011363636363636364,
            "pseudo_dstar_susp": 0.011904761904761904,
            "pseudo_tarantula_susp": 0.058823529411764705,
            "pseudo_op2_susp": 0.011904761904761904,
            "pseudo_barinel_susp": 0.058823529411764705
        }
    },
    {
        "name": "cookiecutter.hooks.find_hooks#31",
        "src_path": "cookiecutter/hooks.py",
        "class_name": "cookiecutter.hooks",
        "signature": "cookiecutter.hooks.find_hooks()",
        "snippet": "def find_hooks():\n    \"\"\"\n    Must be called with the project template as the current working directory.\n    Returns a dict of all hook scripts provided.\n    Dict's key will be the hook/script's name, without extension, while\n    values will be the absolute path to the script.\n    Missing scripts will not be included in the returned dict.\n    \"\"\"\n    hooks_dir = 'hooks'\n    r = {}\n    logging.debug('hooks_dir is {0}'.format(hooks_dir))\n    if not os.path.isdir(hooks_dir):\n        logging.debug('No hooks/ dir in template_dir')\n        return r\n    for f in os.listdir(hooks_dir):\n        basename = os.path.splitext(os.path.basename(f))[0]\n        if basename in _HOOKS:\n            r[basename] = os.path.abspath(os.path.join(hooks_dir, f))\n    return r",
        "begin_line": 31,
        "end_line": 49,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.006134969325153374,
            "pseudo_dstar_susp": 0.00847457627118644,
            "pseudo_tarantula_susp": 0.007246376811594203,
            "pseudo_op2_susp": 0.00847457627118644,
            "pseudo_barinel_susp": 0.007246376811594203
        }
    },
    {
        "name": "cookiecutter.hooks.run_script#52",
        "src_path": "cookiecutter/hooks.py",
        "class_name": "cookiecutter.hooks",
        "signature": "cookiecutter.hooks.run_script(script_path, cwd='.')",
        "snippet": "def run_script(script_path, cwd='.'):\n    \"\"\"\n    Executes a script from a working directory.\n\n    :param script_path: Absolute path to the script to run.\n    :param cwd: The directory to run the script from.\n    \"\"\"\n    run_thru_shell = sys.platform.startswith('win')\n    if script_path.endswith('.py'):\n        script_command = [sys.executable, script_path]\n    else:\n        script_command = [script_path]\n\n    utils.make_executable(script_path)\n\n    proc = subprocess.Popen(\n        script_command,\n        shell=run_thru_shell,\n        cwd=cwd\n    )\n    return proc.wait()",
        "begin_line": 52,
        "end_line": 72,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.005154639175257732,
            "pseudo_dstar_susp": 0.004347826086956522,
            "pseudo_tarantula_susp": 0.016666666666666666,
            "pseudo_op2_susp": 0.004347826086956522,
            "pseudo_barinel_susp": 0.016666666666666666
        }
    },
    {
        "name": "cookiecutter.hooks.run_script_with_context#75",
        "src_path": "cookiecutter/hooks.py",
        "class_name": "cookiecutter.hooks",
        "signature": "cookiecutter.hooks.run_script_with_context(script_path, cwd, context)",
        "snippet": "def run_script_with_context(script_path, cwd, context):\n    \"\"\"\n    Executes a script after rendering with it Jinja.\n\n    :param script_path: Absolute path to the script to run.\n    :param cwd: The directory to run the script from.\n    :param context: Cookiecutter project template context.\n    \"\"\"\n    _, extension = os.path.splitext(script_path)\n\n    contents = io.open(script_path, 'r', encoding='utf-8').read()\n\n    with tempfile.NamedTemporaryFile(\n        delete=False,\n        mode='w',\n        suffix=extension\n    ) as temp:\n        temp.write(Template(contents).render(**context))\n\n    return run_script(temp.name, cwd)",
        "begin_line": 75,
        "end_line": 94,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.004219409282700422,
            "pseudo_dstar_susp": 0.003968253968253968,
            "pseudo_tarantula_susp": 0.007246376811594203,
            "pseudo_op2_susp": 0.003968253968253968,
            "pseudo_barinel_susp": 0.007246376811594203
        }
    },
    {
        "name": "cookiecutter.hooks.run_hook#97",
        "src_path": "cookiecutter/hooks.py",
        "class_name": "cookiecutter.hooks",
        "signature": "cookiecutter.hooks.run_hook(hook_name, project_dir, context)",
        "snippet": "def run_hook(hook_name, project_dir, context):\n    \"\"\"\n    Try to find and execute a hook from the specified project directory.\n\n    :param hook_name: The hook to execute.\n    :param project_dir: The directory to execute the script from.\n    :param context: Cookiecutter project context.\n    \"\"\"\n    script = find_hooks().get(hook_name)\n    if script is None:\n        logging.debug('No hooks found')\n        return EXIT_SUCCESS\n    return run_script_with_context(script, project_dir, context)",
        "begin_line": 97,
        "end_line": 109,
        "comment": "",
        "is_bug": true,
        "susp": {
            "pseudo_ochiai_susp": 0.007194244604316547,
            "pseudo_dstar_susp": 0.010638297872340425,
            "pseudo_tarantula_susp": 0.008771929824561403,
            "pseudo_op2_susp": 0.010638297872340425,
            "pseudo_barinel_susp": 0.008771929824561403
        }
    },
    {
        "name": "cookiecutter.vcs.prompt_and_delete_repo#24",
        "src_path": "cookiecutter/vcs.py",
        "class_name": "cookiecutter.vcs",
        "signature": "cookiecutter.vcs.prompt_and_delete_repo(repo_dir, no_input=False)",
        "snippet": "def prompt_and_delete_repo(repo_dir, no_input=False):\n    \"\"\"\n    Asks the user whether it's okay to delete the previously-cloned repo.\n    If yes, deletes it. Otherwise, Cookiecutter exits.\n\n    :param repo_dir: Directory of previously-cloned repo.\n    :param no_input: Suppress prompt to delete repo and just delete it.\n    \"\"\"\n\n    # Suppress prompt if called via API\n    if no_input:\n        ok_to_delete = True\n    else:\n        question = (\n            \"You've cloned {0} before. \"\n            'Is it okay to delete and re-clone it?'\n        ).format(repo_dir)\n\n        ok_to_delete = read_user_yes_no(question, 'yes')\n\n    if ok_to_delete:\n        rmtree(repo_dir)\n    else:\n        sys.exit()",
        "begin_line": 24,
        "end_line": 47,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002232142857142857,
            "pseudo_dstar_susp": 0.002232142857142857,
            "pseudo_tarantula_susp": 0.002232142857142857,
            "pseudo_op2_susp": 0.0025380710659898475,
            "pseudo_barinel_susp": 0.002232142857142857
        }
    },
    {
        "name": "cookiecutter.vcs.identify_repo#50",
        "src_path": "cookiecutter/vcs.py",
        "class_name": "cookiecutter.vcs",
        "signature": "cookiecutter.vcs.identify_repo(repo_url)",
        "snippet": "def identify_repo(repo_url):\n    \"\"\"\n    Determines if `repo_url` should be treated as a URL to a git or hg repo.\n    Repos can be identified prepeding \"hg+\" or \"git+\" to repo URL.\n\n    :param repo_url: Repo URL of unknown type.\n    :returns: (\"git\", repo_url), (\"hg\", repo_url), or None.\n    \"\"\"\n    repo_url_values = repo_url.split('+')\n    if len(repo_url_values) == 2:\n        repo_type = repo_url_values[0]\n        if repo_type in [\"git\", \"hg\"]:\n            return repo_type, repo_url_values[1]\n        else:\n            raise UnknownRepoType\n    else:\n        if \"git\" in repo_url:\n            return \"git\", repo_url\n        elif \"bitbucket\" in repo_url:\n            return \"hg\", repo_url\n        else:\n            raise UnknownRepoType",
        "begin_line": 50,
        "end_line": 71,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.3333333333333333,
            "pseudo_dstar_susp": 0.017543859649122806,
            "pseudo_tarantula_susp": 0.02631578947368421,
            "pseudo_op2_susp": 0.017543859649122806,
            "pseudo_barinel_susp": 0.02631578947368421
        }
    },
    {
        "name": "cookiecutter.vcs.is_vcs_installed#74",
        "src_path": "cookiecutter/vcs.py",
        "class_name": "cookiecutter.vcs",
        "signature": "cookiecutter.vcs.is_vcs_installed(repo_type)",
        "snippet": "def is_vcs_installed(repo_type):\n    \"\"\"\n    Check if the version control system for a repo type is installed.\n\n    :param repo_type:\n    \"\"\"\n    return bool(which(repo_type))",
        "begin_line": 74,
        "end_line": 80,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.05,
            "pseudo_dstar_susp": 0.01818181818181818,
            "pseudo_tarantula_susp": 0.0196078431372549,
            "pseudo_op2_susp": 0.01818181818181818,
            "pseudo_barinel_susp": 0.0196078431372549
        }
    },
    {
        "name": "cookiecutter.vcs.clone#83",
        "src_path": "cookiecutter/vcs.py",
        "class_name": "cookiecutter.vcs",
        "signature": "cookiecutter.vcs.clone(repo_url, checkout=None, clone_to_dir='.', no_input=False)",
        "snippet": "def clone(repo_url, checkout=None, clone_to_dir=\".\", no_input=False):\n    \"\"\"\n    Clone a repo to the current directory.\n\n    :param repo_url: Repo URL of unknown type.\n    :param checkout: The branch, tag or commit ID to checkout after clone.\n    :param clone_to_dir: The directory to clone to.\n                         Defaults to the current directory.\n    :param no_input: Suppress all user prompts when calling via API.\n    \"\"\"\n\n    # Ensure that clone_to_dir exists\n    clone_to_dir = os.path.expanduser(clone_to_dir)\n    make_sure_path_exists(clone_to_dir)\n\n    # identify the repo_type\n    repo_type, repo_url = identify_repo(repo_url)\n\n    # check that the appropriate VCS for the repo_type is installed\n    if not is_vcs_installed(repo_type):\n        msg = \"'{0}' is not installed.\".format(repo_type)\n        raise VCSNotInstalled(msg)\n\n    tail = os.path.split(repo_url)[1]\n    if repo_type == 'git':\n        repo_dir = os.path.normpath(os.path.join(clone_to_dir,\n                                                 tail.rsplit('.git')[0]))\n    elif repo_type == 'hg':\n        repo_dir = os.path.normpath(os.path.join(clone_to_dir, tail))\n    logging.debug('repo_dir is {0}'.format(repo_dir))\n\n    if os.path.isdir(repo_dir):\n        prompt_and_delete_repo(repo_dir, no_input=no_input)\n\n    if repo_type in ['git', 'hg']:\n        subprocess.check_call([repo_type, 'clone', repo_url], cwd=clone_to_dir)\n        if checkout is not None:\n            subprocess.check_call([repo_type, 'checkout', checkout],\n                                  cwd=repo_dir)\n\n    return repo_dir",
        "begin_line": 83,
        "end_line": 123,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 1.0,
            "pseudo_dstar_susp": 0.019230769230769232,
            "pseudo_tarantula_susp": 0.02857142857142857,
            "pseudo_op2_susp": 0.019230769230769232,
            "pseudo_barinel_susp": 0.02857142857142857
        }
    },
    {
        "name": "cookiecutter.cli.main#62",
        "src_path": "cookiecutter/cli.py",
        "class_name": "cookiecutter.cli",
        "signature": "cookiecutter.cli.main(template, no_input, checkout, verbose, replay, overwrite_if_exists, output_dir)",
        "snippet": "def main(template, no_input, checkout, verbose, replay, overwrite_if_exists,\n         output_dir):\n    \"\"\"Create a project from a Cookiecutter project template (TEMPLATE).\"\"\"\n    if verbose:\n        logging.basicConfig(\n            format=u'%(levelname)s %(filename)s: %(message)s',\n            level=logging.DEBUG\n        )\n    else:\n        # Log info and above to console\n        logging.basicConfig(\n            format=u'%(levelname)s: %(message)s',\n            level=logging.INFO\n        )\n\n    try:\n        cookiecutter(\n            template, checkout, no_input,\n            replay=replay,\n            overwrite_if_exists=overwrite_if_exists,\n            output_dir=output_dir\n        )\n    except (OutputDirExistsException, InvalidModeException) as e:\n        click.echo(e)\n        sys.exit(1)",
        "begin_line": 62,
        "end_line": 86,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002232142857142857,
            "pseudo_dstar_susp": 0.002232142857142857,
            "pseudo_tarantula_susp": 0.002232142857142857,
            "pseudo_op2_susp": 0.0025380710659898475,
            "pseudo_barinel_susp": 0.002232142857142857
        }
    },
    {
        "name": "cookiecutter.utils.rmtree#31",
        "src_path": "cookiecutter/utils.py",
        "class_name": "cookiecutter.utils",
        "signature": "cookiecutter.utils.rmtree(path)",
        "snippet": "def rmtree(path):\n    \"\"\"\n    Removes a directory and all its contents. Like rm -rf on Unix.\n\n    :param path: A directory path.\n    \"\"\"\n\n    shutil.rmtree(path, onerror=force_delete)",
        "begin_line": 31,
        "end_line": 38,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.045454545454545456,
            "pseudo_dstar_susp": 0.5,
            "pseudo_tarantula_susp": 0.008130081300813009,
            "pseudo_op2_susp": 0.5,
            "pseudo_barinel_susp": 0.008130081300813009
        }
    },
    {
        "name": "cookiecutter.utils.make_sure_path_exists#41",
        "src_path": "cookiecutter/utils.py",
        "class_name": "cookiecutter.utils",
        "signature": "cookiecutter.utils.make_sure_path_exists(path)",
        "snippet": "def make_sure_path_exists(path):\n    \"\"\"\n    Ensures that a directory exists.\n\n    :param path: A directory path.\n    \"\"\"\n\n    logging.debug('Making sure path exists: {0}'.format(path))\n    try:\n        os.makedirs(path)\n    except OSError as exception:\n        if exception.errno != errno.EEXIST:\n            return False\n    return True",
        "begin_line": 41,
        "end_line": 54,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.037037037037037035,
            "pseudo_dstar_susp": 0.16666666666666666,
            "pseudo_tarantula_susp": 0.009523809523809525,
            "pseudo_op2_susp": 0.16666666666666666,
            "pseudo_barinel_susp": 0.009523809523809525
        }
    },
    {
        "name": "cookiecutter.utils.work_in#58",
        "src_path": "cookiecutter/utils.py",
        "class_name": "cookiecutter.utils",
        "signature": "cookiecutter.utils.work_in(dirname=None)",
        "snippet": "def work_in(dirname=None):\n    \"\"\"\n    Context manager version of os.chdir. When exited, returns to the working\n    directory prior to entering.\n    \"\"\"\n    curdir = os.getcwd()\n    try:\n        if dirname is not None:\n            os.chdir(dirname)\n        yield\n    finally:\n        os.chdir(curdir)",
        "begin_line": 58,
        "end_line": 69,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.009433962264150943,
            "pseudo_dstar_susp": 0.015625,
            "pseudo_tarantula_susp": 0.007246376811594203,
            "pseudo_op2_susp": 0.015625,
            "pseudo_barinel_susp": 0.007246376811594203
        }
    },
    {
        "name": "cookiecutter.utils.make_executable#72",
        "src_path": "cookiecutter/utils.py",
        "class_name": "cookiecutter.utils",
        "signature": "cookiecutter.utils.make_executable(script_path)",
        "snippet": "def make_executable(script_path):\n    \"\"\"\n    Makes `script_path` executable\n\n    :param script_path: The file to change\n    \"\"\"\n    status = os.stat(script_path)\n    os.chmod(script_path, status.st_mode | stat.S_IEXEC)",
        "begin_line": 72,
        "end_line": 79,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0037313432835820895,
            "pseudo_dstar_susp": 0.0037313432835820895,
            "pseudo_tarantula_susp": 0.005747126436781609,
            "pseudo_op2_susp": 0.0037313432835820895,
            "pseudo_barinel_susp": 0.005747126436781609
        }
    },
    {
        "name": "cookiecutter.replay.get_file_name#18",
        "src_path": "cookiecutter/replay.py",
        "class_name": "cookiecutter.replay",
        "signature": "cookiecutter.replay.get_file_name(replay_dir, template_name)",
        "snippet": "def get_file_name(replay_dir, template_name):\n    file_name = '{}.json'.format(template_name)\n    return os.path.join(replay_dir, file_name)",
        "begin_line": 18,
        "end_line": 20,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003367003367003367,
            "pseudo_dstar_susp": 0.003367003367003367,
            "pseudo_tarantula_susp": 0.003367003367003367,
            "pseudo_op2_susp": 0.003367003367003367,
            "pseudo_barinel_susp": 0.003367003367003367
        }
    },
    {
        "name": "cookiecutter.replay.dump#23",
        "src_path": "cookiecutter/replay.py",
        "class_name": "cookiecutter.replay",
        "signature": "cookiecutter.replay.dump(template_name, context)",
        "snippet": "def dump(template_name, context):\n    if not isinstance(template_name, basestring):\n        raise TypeError('Template name is required to be of type str')\n\n    if not isinstance(context, dict):\n        raise TypeError('Context is required to be of type dict')\n\n    if 'cookiecutter' not in context:\n        raise ValueError('Context is required to contain a cookiecutter key')\n\n    replay_dir = get_user_config()['replay_dir']\n\n    if not make_sure_path_exists(replay_dir):\n        raise IOError('Unable to create replay dir at {}'.format(replay_dir))\n\n    replay_file = get_file_name(replay_dir, template_name)\n\n    with open(replay_file, 'w') as outfile:\n        json.dump(context, outfile)",
        "begin_line": 23,
        "end_line": 41,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0035087719298245615,
            "pseudo_dstar_susp": 0.0035087719298245615,
            "pseudo_tarantula_susp": 0.0035460992907801418,
            "pseudo_op2_susp": 0.0035087719298245615,
            "pseudo_barinel_susp": 0.0035460992907801418
        }
    },
    {
        "name": "cookiecutter.replay.load#44",
        "src_path": "cookiecutter/replay.py",
        "class_name": "cookiecutter.replay",
        "signature": "cookiecutter.replay.load(template_name)",
        "snippet": "def load(template_name):\n    if not isinstance(template_name, basestring):\n        raise TypeError('Template name is required to be of type str')\n\n    replay_dir = get_user_config()['replay_dir']\n    replay_file = get_file_name(replay_dir, template_name)\n\n    with open(replay_file, 'r') as infile:\n        context = json.load(infile)\n\n    if 'cookiecutter' not in context:\n        raise ValueError('Context is required to contain a cookiecutter key')\n\n    return context",
        "begin_line": 44,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002232142857142857,
            "pseudo_dstar_susp": 0.002232142857142857,
            "pseudo_tarantula_susp": 0.002232142857142857,
            "pseudo_op2_susp": 0.0025380710659898475,
            "pseudo_barinel_susp": 0.002232142857142857
        }
    },
    {
        "name": "cookiecutter.prompt.read_user_choice#48",
        "src_path": "cookiecutter/prompt.py",
        "class_name": "cookiecutter.prompt",
        "signature": "cookiecutter.prompt.read_user_choice(var_name, options)",
        "snippet": "def read_user_choice(var_name, options):\n    \"\"\"Prompt the user to choose from several options for the given variable.\n\n    The first item will be returned if no input happens.\n\n    :param str var_name: Variable as specified in the context\n    :param list options: Sequence of options that are available to select from\n    :return: Exactly one item of ``options`` that has been chosen by the user\n    \"\"\"\n    # Please see http://click.pocoo.org/4/api/#click.prompt\n    if not isinstance(options, list):\n        raise TypeError\n\n    if not options:\n        raise ValueError\n\n    choice_map = OrderedDict(\n        (u'{}'.format(i), value) for i, value in enumerate(options, 1)\n    )\n    choices = choice_map.keys()\n    default = u'1'\n\n    choice_lines = [u'{} - {}'.format(*c) for c in choice_map.items()]\n    prompt = u'\\n'.join((\n        u'Select {}:'.format(var_name),\n        u'\\n'.join(choice_lines),\n        u'Choose from {}'.format(u', '.join(choices))\n    ))\n\n    user_choice = click.prompt(\n        prompt, type=click.Choice(choices), default=default\n    )\n    return choice_map[user_choice]",
        "begin_line": 48,
        "end_line": 80,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002232142857142857,
            "pseudo_dstar_susp": 0.002232142857142857,
            "pseudo_tarantula_susp": 0.002232142857142857,
            "pseudo_op2_susp": 0.0025380710659898475,
            "pseudo_barinel_susp": 0.002232142857142857
        }
    },
    {
        "name": "cookiecutter.prompt.render_variable#83",
        "src_path": "cookiecutter/prompt.py",
        "class_name": "cookiecutter.prompt",
        "signature": "cookiecutter.prompt.render_variable(env, raw, cookiecutter_dict)",
        "snippet": "def render_variable(env, raw, cookiecutter_dict):\n    if not isinstance(raw, basestring):\n        raw = str(raw)\n    template = env.from_string(raw)\n    rendered_template = template.render(cookiecutter=cookiecutter_dict)\n    return rendered_template",
        "begin_line": 83,
        "end_line": 88,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.003257328990228013,
            "pseudo_dstar_susp": 0.003257328990228013,
            "pseudo_tarantula_susp": 0.003257328990228013,
            "pseudo_op2_susp": 0.003257328990228013,
            "pseudo_barinel_susp": 0.003257328990228013
        }
    },
    {
        "name": "cookiecutter.prompt.prompt_choice_for_config#91",
        "src_path": "cookiecutter/prompt.py",
        "class_name": "cookiecutter.prompt",
        "signature": "cookiecutter.prompt.prompt_choice_for_config(cookiecutter_dict, env, key, options, no_input)",
        "snippet": "def prompt_choice_for_config(cookiecutter_dict, env, key, options, no_input):\n    \"\"\"Prompt the user which option to choose from the given. Each of the\n    possible choices is rendered beforehand.\n    \"\"\"\n    rendered_options = [\n        render_variable(env, raw, cookiecutter_dict) for raw in options\n    ]\n\n    if no_input:\n        return rendered_options[0]\n    return read_user_choice(key, rendered_options)",
        "begin_line": 91,
        "end_line": 101,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.06666666666666667,
            "pseudo_dstar_susp": 0.007142857142857143,
            "pseudo_tarantula_susp": 0.058823529411764705,
            "pseudo_op2_susp": 0.007142857142857143,
            "pseudo_barinel_susp": 0.058823529411764705
        }
    },
    {
        "name": "cookiecutter.prompt.prompt_for_config#104",
        "src_path": "cookiecutter/prompt.py",
        "class_name": "cookiecutter.prompt",
        "signature": "cookiecutter.prompt.prompt_for_config(context, no_input=False)",
        "snippet": "def prompt_for_config(context, no_input=False):\n    \"\"\"\n    Prompts the user to enter new config, using context as a source for the\n    field names and sample values.\n\n    :param no_input: Prompt the user at command line for manual configuration?\n    \"\"\"\n    cookiecutter_dict = {}\n    env = Environment()\n\n    for key, raw in iteritems(context[u'cookiecutter']):\n        if key.startswith(u'_'):\n            cookiecutter_dict[key] = raw\n            continue\n\n        if isinstance(raw, list):\n            # We are dealing with a choice variable\n            val = prompt_choice_for_config(\n                cookiecutter_dict, env, key, raw, no_input\n            )\n        else:\n            # We are dealing with a regular variable\n            val = render_variable(env, raw, cookiecutter_dict)\n\n            if not no_input:\n                val = read_user_variable(key, val)\n\n        cookiecutter_dict[key] = val\n    return cookiecutter_dict",
        "begin_line": 104,
        "end_line": 132,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.011363636363636364,
            "pseudo_dstar_susp": 0.004761904761904762,
            "pseudo_tarantula_susp": 0.058823529411764705,
            "pseudo_op2_susp": 0.004761904761904762,
            "pseudo_barinel_susp": 0.058823529411764705
        }
    },
    {
        "name": "cookiecutter.config.get_config#35",
        "src_path": "cookiecutter/config.py",
        "class_name": "cookiecutter.config",
        "signature": "cookiecutter.config.get_config(config_path)",
        "snippet": "def get_config(config_path):\n    \"\"\"\n    Retrieve the config from the specified path, returning it as a config dict.\n    \"\"\"\n\n    if not os.path.exists(config_path):\n        raise ConfigDoesNotExistException\n\n    logger.debug('config_path is {0}'.format(config_path))\n    with io.open(config_path, encoding='utf-8') as file_handle:\n        try:\n            yaml_dict = yaml.safe_load(file_handle)\n        except yaml.scanner.ScannerError as e:\n            raise InvalidConfiguration(\n                '{0} is not a valid YAML file: line {1}: {2}'.format(\n                    config_path,\n                    e.problem_mark.line,\n                    e.problem))\n\n    config_dict = copy.copy(DEFAULT_CONFIG)\n    config_dict.update(yaml_dict)\n\n    return config_dict",
        "begin_line": 35,
        "end_line": 57,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.002232142857142857,
            "pseudo_dstar_susp": 0.002232142857142857,
            "pseudo_tarantula_susp": 0.002232142857142857,
            "pseudo_op2_susp": 0.0025380710659898475,
            "pseudo_barinel_susp": 0.002232142857142857
        }
    },
    {
        "name": "cookiecutter.config.get_user_config#60",
        "src_path": "cookiecutter/config.py",
        "class_name": "cookiecutter.config",
        "signature": "cookiecutter.config.get_user_config()",
        "snippet": "def get_user_config():\n    \"\"\"\n    Retrieve config from the user's ~/.cookiecutterrc, if it exists.\n    Otherwise, return None.\n    \"\"\"\n\n    # TODO: test on windows...\n    USER_CONFIG_PATH = os.path.expanduser('~/.cookiecutterrc')\n\n    if os.path.exists(USER_CONFIG_PATH):\n        return get_config(USER_CONFIG_PATH)\n    return copy.copy(DEFAULT_CONFIG)",
        "begin_line": 60,
        "end_line": 71,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005405405405405406,
            "pseudo_dstar_susp": 0.006535947712418301,
            "pseudo_tarantula_susp": 0.006369426751592357,
            "pseudo_op2_susp": 0.006535947712418301,
            "pseudo_barinel_susp": 0.006369426751592357
        }
    },
    {
        "name": "cookiecutter.main.is_repo_url#43",
        "src_path": "cookiecutter/main.py",
        "class_name": "cookiecutter.main",
        "signature": "cookiecutter.main.is_repo_url(value)",
        "snippet": "def is_repo_url(value):\n    \"\"\"Return True if value is a repository URL.\"\"\"\n    return bool(re.match(REPO_REGEX, value, re.VERBOSE))",
        "begin_line": 43,
        "end_line": 45,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.0053475935828877,
            "pseudo_dstar_susp": 0.0064516129032258064,
            "pseudo_tarantula_susp": 0.005747126436781609,
            "pseudo_op2_susp": 0.0064516129032258064,
            "pseudo_barinel_susp": 0.005747126436781609
        }
    },
    {
        "name": "cookiecutter.main.expand_abbreviations#48",
        "src_path": "cookiecutter/main.py",
        "class_name": "cookiecutter.main",
        "signature": "cookiecutter.main.expand_abbreviations(template, config_dict)",
        "snippet": "def expand_abbreviations(template, config_dict):\n    \"\"\"\n    Expand abbreviations in a template name.\n\n    :param template: The project template name.\n    :param config_dict: The user config, which will contain abbreviation\n        definitions.\n    \"\"\"\n\n    abbreviations = builtin_abbreviations.copy()\n    abbreviations.update(config_dict.get('abbreviations', {}))\n\n    if template in abbreviations:\n        return abbreviations[template]\n\n    # Split on colon. If there is no colon, rest will be empty\n    # and prefix will be the whole template\n    prefix, sep, rest = template.partition(':')\n    if prefix in abbreviations:\n        return abbreviations[prefix].format(rest)\n\n    return template",
        "begin_line": 48,
        "end_line": 69,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.005405405405405406,
            "pseudo_dstar_susp": 0.006535947712418301,
            "pseudo_tarantula_susp": 0.006369426751592357,
            "pseudo_op2_susp": 0.006535947712418301,
            "pseudo_barinel_susp": 0.006369426751592357
        }
    },
    {
        "name": "cookiecutter.main.cookiecutter#72",
        "src_path": "cookiecutter/main.py",
        "class_name": "cookiecutter.main",
        "signature": "cookiecutter.main.cookiecutter(template, checkout=None, no_input=False, extra_context=None, replay=False, overwrite_if_exists=False, output_dir='.')",
        "snippet": "def cookiecutter(\n        template, checkout=None, no_input=False, extra_context=None,\n        replay=False, overwrite_if_exists=False, output_dir='.'):\n    \"\"\"\n    API equivalent to using Cookiecutter at the command line.\n\n    :param template: A directory containing a project template directory,\n        or a URL to a git repository.\n    :param checkout: The branch, tag or commit ID to checkout after clone.\n    :param no_input: Prompt the user at command line for manual configuration?\n    :param extra_context: A dictionary of context that overrides default\n        and user configuration.\n    :param: overwrite_if_exists: Overwrite the contents of output directory\n        if it exists\n    :param output_dir: Where to output the generated project dir into.\n    \"\"\"\n    if replay and ((no_input is not False) or (extra_context is not None)):\n        err_msg = (\n            \"You can not use both replay and no_input or extra_context \"\n            \"at the same time.\"\n        )\n        raise InvalidModeException(err_msg)\n\n    # Get user config from ~/.cookiecutterrc or equivalent\n    # If no config file, sensible defaults from config.DEFAULT_CONFIG are used\n    config_dict = get_user_config()\n\n    template = expand_abbreviations(template, config_dict)\n\n    if is_repo_url(template):\n        repo_dir = clone(\n            repo_url=template,\n            checkout=checkout,\n            clone_to_dir=config_dict['cookiecutters_dir'],\n            no_input=no_input\n        )\n    else:\n        # If it's a local repo, no need to clone or copy to your\n        # cookiecutters_dir\n        repo_dir = template\n\n    template_name = os.path.basename(template)\n\n    if replay:\n        context = load(template_name)\n    else:\n        context_file = os.path.join(repo_dir, 'cookiecutter.json')\n        logging.debug('context_file is {0}'.format(context_file))\n\n        context = generate_context(\n            context_file=context_file,\n            default_context=config_dict['default_context'],\n            extra_context=extra_context,\n        )\n\n        # prompt the user to manually configure at the command line.\n        # except when 'no-input' flag is set\n        context['cookiecutter'] = prompt_for_config(context, no_input)\n\n        dump(template_name, context)\n\n    # Create project from local context and project template.\n    return generate_files(\n        repo_dir=repo_dir,\n        context=context,\n        overwrite_if_exists=overwrite_if_exists,\n        output_dir=output_dir\n    )",
        "begin_line": 72,
        "end_line": 139,
        "comment": "",
        "is_bug": false,
        "susp": {
            "pseudo_ochiai_susp": 0.06666666666666667,
            "pseudo_dstar_susp": 0.007142857142857143,
            "pseudo_tarantula_susp": 0.058823529411764705,
            "pseudo_op2_susp": 0.007142857142857143,
            "pseudo_barinel_susp": 0.058823529411764705
        }
    }
]