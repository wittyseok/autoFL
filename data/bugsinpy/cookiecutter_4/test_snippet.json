[
    {
        "name": "tests.test_hooks.make_test_repo#19",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks",
        "signature": "tests.test_hooks.make_test_repo(name)",
        "snippet": "def make_test_repo(name):\n    \"\"\"Helper function which is called in the test setup methods.\"\"\"\n    hook_dir = os.path.join(name, 'hooks')\n    template = os.path.join(name, 'input{{hooks}}')\n    os.mkdir(name)\n    os.mkdir(hook_dir)\n    os.mkdir(template)\n\n    with open(os.path.join(template, 'README.rst'), 'w') as f:\n        f.write(\"foo\\n===\\n\\nbar\\n\")\n\n    with open(os.path.join(hook_dir, 'pre_gen_project.py'), 'w') as f:\n        f.write(\"#!/usr/bin/env python\\n\")\n        f.write(\"# -*- coding: utf-8 -*-\\n\")\n        f.write(\"from __future__ import print_function\\n\")\n        f.write(\"\\n\")\n        f.write(\"print('pre generation hook')\\n\")\n        f.write(\"f = open('python_pre.txt', 'w')\\n\")\n        f.write(\"f.close()\\n\")\n\n    if sys.platform.startswith('win'):\n        post = 'post_gen_project.bat'\n        with open(os.path.join(hook_dir, post), 'w') as f:\n            f.write(\"@echo off\\n\")\n            f.write(\"\\n\")\n            f.write(\"echo post generation hook\\n\")\n            f.write(\"echo. >shell_post.txt\\n\")\n    else:\n        post = 'post_gen_project.sh'\n        filename = os.path.join(hook_dir, post)\n        with open(filename, 'w') as f:\n            f.write(\"#!/bin/bash\\n\")\n            f.write(\"\\n\")\n            f.write(\"echo 'post generation hook';\\n\")\n            f.write(\"touch 'shell_post.txt'\\n\")\n        # Set the execute bit\n        os.chmod(filename, os.stat(filename).st_mode | stat.S_IXUSR)\n\n    return post",
        "begin_line": 19,
        "end_line": 57,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestFindHooks.setup_method#64",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestFindHooks",
        "signature": "tests.test_hooks.TestFindHooks.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n        self.post_hook = make_test_repo(self.repo_path)",
        "begin_line": 64,
        "end_line": 65,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestFindHooks.teardown_method#67",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestFindHooks",
        "signature": "tests.test_hooks.TestFindHooks.teardown_method(self, method)",
        "snippet": "    def teardown_method(self, method):\n        utils.rmtree(self.repo_path)",
        "begin_line": 67,
        "end_line": 68,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestFindHooks.test_find_hook#70",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestFindHooks",
        "signature": "tests.test_hooks.TestFindHooks.test_find_hook(self)",
        "snippet": "    def test_find_hook(self):\n        \"\"\"Finds the specified hook.\"\"\"\n\n        with utils.work_in(self.repo_path):\n            expected = {\n                'pre_gen_project': os.path.abspath('hooks/pre_gen_project.py'),\n                'post_gen_project': os.path.abspath(\n                    os.path.join('hooks', self.post_hook)\n                ),\n            }\n            assert expected == hooks.find_hooks()",
        "begin_line": 70,
        "end_line": 80,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestFindHooks.test_no_hooks#82",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestFindHooks",
        "signature": "tests.test_hooks.TestFindHooks.test_no_hooks(self)",
        "snippet": "    def test_no_hooks(self):\n        \"\"\"find_hooks should return None if the hook could not be found.\"\"\"\n\n        with utils.work_in('tests/fake-repo'):\n            assert {} == hooks.find_hooks()",
        "begin_line": 82,
        "end_line": 86,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestExternalHooks.setup_method#94",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestExternalHooks",
        "signature": "tests.test_hooks.TestExternalHooks.setup_method(self, method)",
        "snippet": "    def setup_method(self, method):\n        self.post_hook = make_test_repo(self.repo_path)",
        "begin_line": 94,
        "end_line": 95,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestExternalHooks.teardown_method#97",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestExternalHooks",
        "signature": "tests.test_hooks.TestExternalHooks.teardown_method(self, method)",
        "snippet": "    def teardown_method(self, method):\n        utils.rmtree(self.repo_path)\n\n        if os.path.exists('python_pre.txt'):\n            os.remove('python_pre.txt')\n        if os.path.exists('shell_post.txt'):\n            os.remove('shell_post.txt')\n        if os.path.exists('tests/shell_post.txt'):\n            os.remove('tests/shell_post.txt')\n        if os.path.exists('tests/test-hooks/input{{hooks}}/python_pre.txt'):\n            os.remove('tests/test-hooks/input{{hooks}}/python_pre.txt')\n        if os.path.exists('tests/test-hooks/input{{hooks}}/shell_post.txt'):\n            os.remove('tests/test-hooks/input{{hooks}}/shell_post.txt')\n        if os.path.exists('tests/context_post.txt'):\n            os.remove('tests/context_post.txt')",
        "begin_line": 97,
        "end_line": 111,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestExternalHooks.test_run_script#113",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestExternalHooks",
        "signature": "tests.test_hooks.TestExternalHooks.test_run_script(self)",
        "snippet": "    def test_run_script(self):\n        \"\"\"Execute a hook script, independently of project generation\"\"\"\n        hooks.run_script(os.path.join(self.hooks_path, self.post_hook))\n        assert os.path.isfile('shell_post.txt')",
        "begin_line": 113,
        "end_line": 116,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestExternalHooks.test_run_script_cwd#118",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestExternalHooks",
        "signature": "tests.test_hooks.TestExternalHooks.test_run_script_cwd(self)",
        "snippet": "    def test_run_script_cwd(self):\n        \"\"\"Change directory before running hook\"\"\"\n        hooks.run_script(\n            os.path.join(self.hooks_path, self.post_hook),\n            'tests'\n        )\n        assert os.path.isfile('tests/shell_post.txt')\n        assert 'tests' not in os.getcwd()",
        "begin_line": 118,
        "end_line": 125,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestExternalHooks.test_run_script_with_context#127",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestExternalHooks",
        "signature": "tests.test_hooks.TestExternalHooks.test_run_script_with_context(self)",
        "snippet": "    def test_run_script_with_context(self):\n        \"\"\"Execute a hook script, passing a context\"\"\"\n\n        hook_path = os.path.join(self.hooks_path, 'post_gen_project.sh')\n\n        if sys.platform.startswith('win'):\n            post = 'post_gen_project.bat'\n            with open(os.path.join(self.hooks_path, post), 'w') as f:\n                f.write(\"@echo off\\n\")\n                f.write(\"\\n\")\n                f.write(\"echo post generation hook\\n\")\n                f.write(\"echo. >{{cookiecutter.file}}\\n\")\n        else:\n            with open(hook_path, 'w') as fh:\n                fh.write(\"#!/bin/bash\\n\")\n                fh.write(\"\\n\")\n                fh.write(\"echo 'post generation hook';\\n\")\n                fh.write(\"touch 'shell_post.txt'\\n\")\n                fh.write(\"touch '{{cookiecutter.file}}'\\n\")\n                os.chmod(hook_path, os.stat(hook_path).st_mode | stat.S_IXUSR)\n\n        hooks.run_script_with_context(\n            os.path.join(self.hooks_path, self.post_hook),\n            'tests',\n            {\n                'cookiecutter': {\n                    'file': 'context_post.txt'\n                }\n            })\n        assert os.path.isfile('tests/context_post.txt')\n        assert 'tests' not in os.getcwd()",
        "begin_line": 127,
        "end_line": 157,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestExternalHooks.test_run_hook#159",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestExternalHooks",
        "signature": "tests.test_hooks.TestExternalHooks.test_run_hook(self)",
        "snippet": "    def test_run_hook(self):\n        \"\"\"Execute hook from specified template in specified output\n        directory.\n        \"\"\"\n        tests_dir = os.path.join(self.repo_path, 'input{{hooks}}')\n        with utils.work_in(self.repo_path):\n            hooks.run_hook('pre_gen_project', tests_dir, {})\n            assert os.path.isfile(os.path.join(tests_dir, 'python_pre.txt'))\n\n            hooks.run_hook('post_gen_project', tests_dir, {})\n            assert os.path.isfile(os.path.join(tests_dir, 'shell_post.txt'))",
        "begin_line": 159,
        "end_line": 169,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.test_hooks.TestExternalHooks.test_run_failing_hook#171",
        "src_path": "tests/test_hooks.py",
        "class_name": "tests.test_hooks.TestExternalHooks",
        "signature": "tests.test_hooks.TestExternalHooks.test_run_failing_hook(self)",
        "snippet": "    def test_run_failing_hook(self):\n        hook_path = os.path.join(self.hooks_path, 'pre_gen_project.py')\n        tests_dir = os.path.join(self.repo_path, 'input{{hooks}}')\n\n        with open(hook_path, 'w') as f:\n            f.write(\"#!/usr/bin/env python\\n\")\n            f.write(\"import sys; sys.exit(1)\\n\")\n\n        with utils.work_in(self.repo_path):\n            with pytest.raises(exceptions.FailedHookException) as excinfo:\n                hooks.run_hook('pre_gen_project', tests_dir, {})\n            assert 'Hook script failed' in str(excinfo)",
        "begin_line": 171,
        "end_line": 182,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.replay.conftest.context#7",
        "src_path": "tests/replay/conftest.py",
        "class_name": "tests.replay.conftest",
        "signature": "tests.replay.conftest.context()",
        "snippet": "def context():\n    \"\"\"Fixture to return a valid context as known from a cookiecutter.json.\"\"\"\n    return {\n        u'cookiecutter': {\n            u'email': u'raphael@hackebrot.de',\n            u'full_name': u'Raphael Pierzina',\n            u'github_username': u'hackebrot',\n            u'version': u'0.1.0',\n        }\n    }",
        "begin_line": 7,
        "end_line": 16,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.replay.conftest.replay_test_dir#20",
        "src_path": "tests/replay/conftest.py",
        "class_name": "tests.replay.conftest",
        "signature": "tests.replay.conftest.replay_test_dir()",
        "snippet": "def replay_test_dir():\n    return 'tests/test-replay/'",
        "begin_line": 20,
        "end_line": 21,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.conftest.backup_dir#17",
        "src_path": "tests/conftest.py",
        "class_name": "tests.conftest",
        "signature": "tests.conftest.backup_dir(original_dir, backup_dir)",
        "snippet": "def backup_dir(original_dir, backup_dir):\n    # If the default original_dir is pre-existing, move it to a temp location\n    if not os.path.isdir(original_dir):\n        return False\n\n    # Remove existing backups before backing up. If they exist, they're stale.\n    if os.path.isdir(backup_dir):\n        utils.rmtree(backup_dir)\n\n    shutil.copytree(original_dir, backup_dir)\n    return True",
        "begin_line": 17,
        "end_line": 27,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.conftest.restore_backup_dir#30",
        "src_path": "tests/conftest.py",
        "class_name": "tests.conftest",
        "signature": "tests.conftest.restore_backup_dir(original_dir, backup_dir, original_dir_found)",
        "snippet": "def restore_backup_dir(original_dir, backup_dir, original_dir_found):\n    # Carefully delete the created original_dir only in certain\n    # conditions.\n    original_dir_is_dir = os.path.isdir(original_dir)\n    if original_dir_found:\n        # Delete the created original_dir as long as a backup\n        # exists\n        if original_dir_is_dir and os.path.isdir(backup_dir):\n            utils.rmtree(original_dir)\n    else:\n        # Delete the created original_dir.\n        # There's no backup because it never existed\n        if original_dir_is_dir:\n            utils.rmtree(original_dir)\n\n    # Restore the user's default original_dir contents\n    if os.path.isdir(backup_dir):\n        shutil.copytree(backup_dir, original_dir)\n    if os.path.isdir(original_dir):\n        utils.rmtree(backup_dir)",
        "begin_line": 30,
        "end_line": 49,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.conftest.clean_system#53",
        "src_path": "tests/conftest.py",
        "class_name": "tests.conftest",
        "signature": "tests.conftest.clean_system(request)",
        "snippet": "def clean_system(request):\n    \"\"\"\n    Fixture that simulates a clean system with no config/cloned cookiecutters.\n\n    It runs code which can be regarded as setup code as known from a unittest\n    TestCase. Additionally it defines a local function referring to values\n    which have been stored to local variables in the setup such as the location\n    of the cookiecutters on disk. This function is registered as a teardown\n    hook with `request.addfinalizer` at the very end of the fixture. Pytest\n    runs the named hook as soon as the fixture is out of scope, when the test\n    finished to put it another way.\n\n    During setup:\n\n    * Back up the `~/.cookiecutterrc` config file to `~/.cookiecutterrc.backup`\n    * Back up the `~/.cookiecutters/` dir to `~/.cookiecutters.backup/`\n    * Back up the `~/.cookiecutter_replay/` dir to\n      `~/.cookiecutter_replay.backup/`\n    * Starts off a test case with no pre-existing `~/.cookiecutterrc` or\n      `~/.cookiecutters/` or `~/.cookiecutter_replay/`\n\n    During teardown:\n\n    * Delete `~/.cookiecutters/` only if a backup is present at\n      `~/.cookiecutters.backup/`\n    * Delete `~/.cookiecutter_replay/` only if a backup is present at\n      `~/.cookiecutter_replay.backup/`\n    * Restore the `~/.cookiecutterrc` config file from\n      `~/.cookiecutterrc.backup`\n    * Restore the `~/.cookiecutters/` dir from `~/.cookiecutters.backup/`\n    * Restore the `~/.cookiecutter_replay/` dir from\n      `~/.cookiecutter_replay.backup/`\n\n    \"\"\"\n\n    # If ~/.cookiecutterrc is pre-existing, move it to a temp location\n    user_config_path = os.path.expanduser('~/.cookiecutterrc')\n    user_config_path_backup = os.path.expanduser(\n        '~/.cookiecutterrc.backup'\n    )\n    if os.path.exists(user_config_path):\n        user_config_found = True\n        shutil.copy(user_config_path, user_config_path_backup)\n        os.remove(user_config_path)\n    else:\n        user_config_found = False\n\n    # If the default cookiecutters_dir is pre-existing, move it to a\n    # temp location\n    cookiecutters_dir = os.path.expanduser('~/.cookiecutters')\n    cookiecutters_dir_backup = os.path.expanduser('~/.cookiecutters.backup')\n    cookiecutters_dir_found = backup_dir(\n        cookiecutters_dir, cookiecutters_dir_backup\n    )\n\n    # If the default cookiecutter_replay_dir is pre-existing, move it to a\n    # temp location\n    cookiecutter_replay_dir = os.path.expanduser('~/.cookiecutter_replay')\n    cookiecutter_replay_dir_backup = os.path.expanduser(\n        '~/.cookiecutter_replay.backup'\n    )\n    cookiecutter_replay_dir_found = backup_dir(\n        cookiecutter_replay_dir, cookiecutter_replay_dir_backup\n    )\n\n    def restore_backup():\n        # If it existed, restore ~/.cookiecutterrc\n        # We never write to ~/.cookiecutterrc, so this logic is simpler.\n        if user_config_found and os.path.exists(user_config_path_backup):\n            shutil.copy(user_config_path_backup, user_config_path)\n            os.remove(user_config_path_backup)\n\n        # Carefully delete the created ~/.cookiecutters dir only in certain\n        # conditions.\n        restore_backup_dir(\n            cookiecutters_dir,\n            cookiecutters_dir_backup,\n            cookiecutters_dir_found\n        )\n\n        # Carefully delete the created ~/.cookiecutter_replay dir only in\n        # certain conditions.\n        restore_backup_dir(\n            cookiecutter_replay_dir,\n            cookiecutter_replay_dir_backup,\n            cookiecutter_replay_dir_found\n        )\n\n    request.addfinalizer(restore_backup)",
        "begin_line": 53,
        "end_line": 141,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.conftest.restore_backup#118",
        "src_path": "tests/conftest.py",
        "class_name": "tests.conftest",
        "signature": "tests.conftest.restore_backup()",
        "snippet": "    def restore_backup():\n        # If it existed, restore ~/.cookiecutterrc\n        # We never write to ~/.cookiecutterrc, so this logic is simpler.\n        if user_config_found and os.path.exists(user_config_path_backup):\n            shutil.copy(user_config_path_backup, user_config_path)\n            os.remove(user_config_path_backup)\n\n        # Carefully delete the created ~/.cookiecutters dir only in certain\n        # conditions.\n        restore_backup_dir(\n            cookiecutters_dir,\n            cookiecutters_dir_backup,\n            cookiecutters_dir_found\n        )\n\n        # Carefully delete the created ~/.cookiecutter_replay dir only in\n        # certain conditions.\n        restore_backup_dir(\n            cookiecutter_replay_dir,\n            cookiecutter_replay_dir_backup,\n            cookiecutter_replay_dir_found\n        )",
        "begin_line": 118,
        "end_line": 139,
        "comment": "",
        "is_bug": false
    }
]