[
    {
        "name": "tests.keras.backend.reference_operations.wrapper#12",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.wrapper(*args, **kwargs)",
        "snippet": "    def wrapper(*args, **kwargs):\n        x = args[0]\n        w = args[1]\n        if x.ndim == 3:\n            w = np.flipud(w)\n            w = np.transpose(w, (1, 2, 0))\n            if kwargs['data_format'] == 'channels_last':\n                x = np.transpose(x, (0, 2, 1))\n        elif x.ndim == 4:\n            w = np.fliplr(np.flipud(w))\n            w = np.transpose(w, (2, 3, 0, 1))\n            if kwargs['data_format'] == 'channels_last':\n                x = np.transpose(x, (0, 3, 1, 2))\n        else:\n            w = np.flip(np.fliplr(np.flipud(w)), axis=2)\n            w = np.transpose(w, (3, 4, 0, 1, 2))\n            if kwargs['data_format'] == 'channels_last':\n                x = np.transpose(x, (0, 4, 1, 2, 3))\n\n        y = func(x, w, **kwargs)\n\n        if kwargs['data_format'] == 'channels_last':\n            if y.ndim == 3:\n                y = np.transpose(y, (0, 2, 1))\n            elif y.ndim == 4:\n                y = np.transpose(y, (0, 2, 3, 1))\n            else:\n                y = np.transpose(y, (0, 2, 3, 4, 1))\n\n        return y",
        "begin_line": 12,
        "end_line": 41,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.conv#47",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.conv(x, w, padding, data_format)",
        "snippet": "def conv(x, w, padding, data_format):\n    y = []\n    for i in range(x.shape[0]):\n        _y = []\n        for j in range(w.shape[1]):\n            __y = []\n            for k in range(w.shape[0]):\n                __y.append(signal.convolve(x[i, k], w[k, j], mode=padding))\n            _y.append(np.sum(np.stack(__y, axis=-1), axis=-1))\n        y.append(_y)\n    y = np.array(y)\n    return y",
        "begin_line": 47,
        "end_line": 58,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.depthwise_conv#62",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.depthwise_conv(x, w, padding, data_format)",
        "snippet": "def depthwise_conv(x, w, padding, data_format):\n    y = []\n    for i in range(x.shape[0]):\n        _y = []\n        for j in range(w.shape[0]):\n            __y = []\n            for k in range(w.shape[1]):\n                __y.append(signal.convolve(x[i, j], w[j, k], mode=padding))\n            _y.append(np.stack(__y, axis=0))\n        y.append(np.concatenate(_y, axis=0))\n    y = np.array(y)\n    return y",
        "begin_line": 62,
        "end_line": 73,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.separable_conv#76",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.separable_conv(x, w1, w2, padding, data_format)",
        "snippet": "def separable_conv(x, w1, w2, padding, data_format):\n    x2 = depthwise_conv(x, w1, padding=padding, data_format=data_format)\n    return conv(x2, w2, padding=padding, data_format=data_format)",
        "begin_line": 76,
        "end_line": 78,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.pool#89",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.pool(x, pool_size, strides, padding, data_format, pool_mode)",
        "snippet": "def pool(x, pool_size, strides, padding, data_format, pool_mode):\n    if data_format == 'channels_last':\n        if x.ndim == 3:\n            x = np.transpose(x, (0, 2, 1))\n        elif x.ndim == 4:\n            x = np.transpose(x, (0, 3, 1, 2))\n        else:\n            x = np.transpose(x, (0, 4, 1, 2, 3))\n\n    if padding == 'same':\n        pad = [(0, 0), (0, 0)] + [(s // 2, s // 2) for s in pool_size]\n        x = np.pad(x, pad, 'constant', constant_values=-np.inf)\n\n    # indexing trick\n    x = np.pad(x, [(0, 0), (0, 0)] + [(0, 1) for _ in pool_size],\n               'constant', constant_values=0)\n\n    if x.ndim == 3:\n        y = [x[:, :, k:k1:strides[0]]\n             for (k, k1) in zip(range(pool_size[0]), range(-pool_size[0], 0))]\n    elif x.ndim == 4:\n        y = []\n        for (k, k1) in zip(range(pool_size[0]), range(-pool_size[0], 0)):\n            for (l, l1) in zip(range(pool_size[1]), range(-pool_size[1], 0)):\n                y.append(x[:, :, k:k1:strides[0], l:l1:strides[1]])\n    else:\n        y = []\n        for (k, k1) in zip(range(pool_size[0]), range(-pool_size[0], 0)):\n            for (l, l1) in zip(range(pool_size[1]), range(-pool_size[1], 0)):\n                for (m, m1) in zip(range(pool_size[2]), range(-pool_size[2], 0)):\n                    y.append(x[:,\n                               :,\n                               k:k1:strides[0],\n                               l:l1:strides[1],\n                               m:m1:strides[2]])\n    y = np.stack(y, axis=-1)\n    if pool_mode == 'avg':\n        y = np.mean(np.ma.masked_invalid(y), axis=-1).data\n    elif pool_mode == 'max':\n        y = np.max(y, axis=-1)\n\n    if data_format == 'channels_last':\n        if y.ndim == 3:\n            y = np.transpose(y, (0, 2, 1))\n        elif y.ndim == 4:\n            y = np.transpose(y, (0, 2, 3, 1))\n        else:\n            y = np.transpose(y, (0, 2, 3, 4, 1))\n\n    return y",
        "begin_line": 89,
        "end_line": 138,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.bias_add#145",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.bias_add(x, y, data_format)",
        "snippet": "def bias_add(x, y, data_format):\n    if data_format == 'channels_first':\n        if y.ndim > 1:\n            y = np.reshape(y, y.shape[::-1])\n        for _ in range(x.ndim - y.ndim - 1):\n            y = np.expand_dims(y, -1)\n    else:\n        for _ in range(x.ndim - y.ndim - 1):\n            y = np.expand_dims(y, 0)\n    return x + y",
        "begin_line": 145,
        "end_line": 154,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.rnn#157",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.rnn(x, w, init, go_backwards=False, mask=None, unroll=False, input_length=None)",
        "snippet": "def rnn(x, w, init, go_backwards=False, mask=None, unroll=False, input_length=None):\n    w_i, w_h, w_o = w\n    h = []\n    o = []\n\n    if go_backwards:\n        t_list = range(x.shape[1] - 1, -1, -1)\n    else:\n        t_list = range(x.shape[1])\n\n    if mask is not None:\n        from keras import backend as K\n        np_mask = K.eval(mask)\n    else:\n        np_mask = None\n\n    for (i, t) in enumerate(t_list):\n        h_t = np.dot(x[:, t], w_i)\n\n        if w_h is not None:\n            prev = h[i - 1] if i > 0 else init\n            h_t1 = np.dot(prev, w_h)\n            if np_mask is not None:\n                h_t1[np_mask[:, t] == 0] = prev[np_mask[:, t] == 0]\n        else:\n            h_t1 = 0\n\n        o_t = h_t + h_t1\n        if w_o is not None:\n            o_t = np.dot(o_t, w_o)\n        o.append(o_t)\n\n        if np_mask is not None:\n            h_t = h_t * np_mask[:, t].reshape(-1, 1)\n        h.append(h_t + h_t1)\n\n    return o[-1], np.stack(o, axis=1), np.stack(h, axis=1)",
        "begin_line": 157,
        "end_line": 193,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.in_train_phase#208",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.in_train_phase(x, alt, training=None)",
        "snippet": "def in_train_phase(x, alt, training=None):\n    if training is None:\n        training = learning_phase()\n\n    if training is 1 or training is True:\n        if callable(x):\n            return x()\n        else:\n            return x\n    else:\n        if callable(alt):\n            return alt()\n        else:\n            return alt",
        "begin_line": 208,
        "end_line": 221,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.in_test_phase#224",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.in_test_phase(x, alt, training=None)",
        "snippet": "def in_test_phase(x, alt, training=None):\n    return in_train_phase(alt, x, training=training)",
        "begin_line": 224,
        "end_line": 225,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.relu#228",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.relu(x, alpha=0.0, max_value=None)",
        "snippet": "def relu(x, alpha=0., max_value=None):\n    y = x * (x > 0) + alpha * x * (x < 0)\n    if max_value is not None:\n        y = np.minimum(y, max_value)\n    return y",
        "begin_line": 228,
        "end_line": 232,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.switch#235",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.switch(condition, then_expression, else_expression)",
        "snippet": "def switch(condition, then_expression, else_expression):\n    cond_float = condition.astype(floatx())\n    while cond_float.ndim < then_expression.ndim:\n        cond_float = cond_float[..., None]\n    return cond_float * then_expression + (1 - cond_float) * else_expression",
        "begin_line": 235,
        "end_line": 239,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.softplus#242",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.softplus(x)",
        "snippet": "def softplus(x):\n    return np.log(1. + np.exp(x))",
        "begin_line": 242,
        "end_line": 243,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.elu#246",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.elu(x, alpha=1.0)",
        "snippet": "def elu(x, alpha=1.):\n    return x * (x > 0) + alpha * (np.exp(x) - 1.) * (x < 0)",
        "begin_line": 246,
        "end_line": 247,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.sigmoid#250",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.sigmoid(x)",
        "snippet": "def sigmoid(x):\n    return 1. / (1. + np.exp(-x))",
        "begin_line": 250,
        "end_line": 251,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.hard_sigmoid#254",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.hard_sigmoid(x)",
        "snippet": "def hard_sigmoid(x):\n    y = 0.2 * x + 0.5\n    y = np.minimum(y, 1.)\n    y = np.maximum(y, 0.)\n    return y",
        "begin_line": 254,
        "end_line": 258,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.tanh#261",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.tanh(x)",
        "snippet": "def tanh(x):\n    return np.tanh(x)",
        "begin_line": 261,
        "end_line": 262,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.softmax#265",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.softmax(x, axis=-1)",
        "snippet": "def softmax(x, axis=-1):\n    y = np.exp(x - np.max(x, axis, keepdims=True))\n    return y / np.sum(y, axis, keepdims=True)",
        "begin_line": 265,
        "end_line": 267,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.l2_normalize#270",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.l2_normalize(x, axis=-1)",
        "snippet": "def l2_normalize(x, axis=-1):\n    y = np.max(np.sum(x ** 2, axis, keepdims=True), axis, keepdims=True)\n    return x / np.sqrt(y)",
        "begin_line": 270,
        "end_line": 272,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.binary_crossentropy#275",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.binary_crossentropy(target, output, from_logits=False)",
        "snippet": "def binary_crossentropy(target, output, from_logits=False):\n    if not from_logits:\n        output = np.clip(output, 1e-7, 1 - 1e-7)\n        output = np.log(output / (1 - output))\n    return (target * -np.log(sigmoid(output)) +\n            (1 - target) * -np.log(1 - sigmoid(output)))",
        "begin_line": 275,
        "end_line": 280,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.categorical_crossentropy#283",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.categorical_crossentropy(target, output, from_logits=False)",
        "snippet": "def categorical_crossentropy(target, output, from_logits=False):\n    if from_logits:\n        output = softmax(output)\n    else:\n        output /= output.sum(axis=-1, keepdims=True)\n    output = np.clip(output, 1e-7, 1 - 1e-7)\n    return np.sum(target * -np.log(output), axis=-1, keepdims=False)",
        "begin_line": 283,
        "end_line": 289,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.max#292",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.max(x, axis=None, keepdims=False)",
        "snippet": "def max(x, axis=None, keepdims=False):\n    if isinstance(axis, list):\n        for a in axis:\n            x = np.max(x, axis=a, keepdims=keepdims)\n        return x\n    else:\n        return np.max(x, axis=axis, keepdims=keepdims)",
        "begin_line": 292,
        "end_line": 298,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.min#301",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.min(x, axis=None, keepdims=False)",
        "snippet": "def min(x, axis=None, keepdims=False):\n    if isinstance(axis, list):\n        for a in axis:\n            x = np.min(x, axis=a, keepdims=keepdims)\n        return x\n    else:\n        return np.min(x, axis=axis, keepdims=keepdims)",
        "begin_line": 301,
        "end_line": 307,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.mean#310",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.mean(x, axis=None, keepdims=False)",
        "snippet": "def mean(x, axis=None, keepdims=False):\n    if isinstance(axis, list):\n        for a in axis:\n            x = np.mean(x, axis=a, keepdims=keepdims)\n        return x\n    else:\n        return np.mean(x, axis=axis, keepdims=keepdims)",
        "begin_line": 310,
        "end_line": 316,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.std#319",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.std(x, axis=None, keepdims=False)",
        "snippet": "def std(x, axis=None, keepdims=False):\n    if isinstance(axis, list):\n        for a in axis:\n            x = np.std(x, axis=a, keepdims=keepdims)\n        return x\n    else:\n        return np.std(x, axis=axis, keepdims=keepdims)",
        "begin_line": 319,
        "end_line": 325,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.prod#337",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.prod(x, axis=None, keepdims=False)",
        "snippet": "def prod(x, axis=None, keepdims=False):\n    if isinstance(axis, list):\n        for a in axis:\n            x = np.prod(x, axis=a, keepdims=keepdims)\n        return x\n    else:\n        return np.prod(x, axis=axis, keepdims=keepdims)",
        "begin_line": 337,
        "end_line": 343,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.cumsum#346",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.cumsum(x, axis=0)",
        "snippet": "def cumsum(x, axis=0):\n    return np.cumsum(x, axis=axis)",
        "begin_line": 346,
        "end_line": 347,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.cumprod#350",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.cumprod(x, axis=0)",
        "snippet": "def cumprod(x, axis=0):\n    return np.cumprod(x, axis=axis)",
        "begin_line": 350,
        "end_line": 351,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.any#354",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.any(x, axis=None, keepdims=False)",
        "snippet": "def any(x, axis=None, keepdims=False):\n    return np.any(x, axis=axis, keepdims=keepdims)",
        "begin_line": 354,
        "end_line": 355,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.all#358",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.all(x, axis=None, keepdims=False)",
        "snippet": "def all(x, axis=None, keepdims=False):\n    return np.all(x, axis=axis, keepdims=keepdims)",
        "begin_line": 358,
        "end_line": 359,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.argmax#362",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.argmax(x, axis=-1)",
        "snippet": "def argmax(x, axis=-1):\n    return np.argmax(x, axis=axis)",
        "begin_line": 362,
        "end_line": 363,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.argmin#366",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.argmin(x, axis=-1)",
        "snippet": "def argmin(x, axis=-1):\n    return np.argmin(x, axis=axis)",
        "begin_line": 366,
        "end_line": 367,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.sqrt#370",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.sqrt(x)",
        "snippet": "def sqrt(x):\n    y = np.sqrt(x)\n    y[np.isnan(y)] = 0.\n    return y",
        "begin_line": 370,
        "end_line": 373,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.pow#376",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.pow(x, a=1.0)",
        "snippet": "def pow(x, a=1.):\n    return np.power(x, a)",
        "begin_line": 376,
        "end_line": 377,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.clip#380",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.clip(x, min_value, max_value)",
        "snippet": "def clip(x, min_value, max_value):\n    return np.clip(x, min_value, max_value)",
        "begin_line": 380,
        "end_line": 381,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.concatenate#384",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.concatenate(tensors, axis=-1)",
        "snippet": "def concatenate(tensors, axis=-1):\n    return np.concatenate(tensors, axis)",
        "begin_line": 384,
        "end_line": 385,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.permute_dimensions#388",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.permute_dimensions(x, pattern)",
        "snippet": "def permute_dimensions(x, pattern):\n    return np.transpose(x, pattern)",
        "begin_line": 388,
        "end_line": 389,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.reshape#392",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.reshape(x, shape)",
        "snippet": "def reshape(x, shape):\n    return np.reshape(x, shape)",
        "begin_line": 392,
        "end_line": 393,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.repeat_elements#396",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.repeat_elements(x, rep, axis)",
        "snippet": "def repeat_elements(x, rep, axis):\n    return np.repeat(x, rep, axis=axis)",
        "begin_line": 396,
        "end_line": 397,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.repeat#400",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.repeat(x, n)",
        "snippet": "def repeat(x, n):\n    y = np.expand_dims(x, 1)\n    y = np.repeat(y, n, axis=1)\n    return y",
        "begin_line": 400,
        "end_line": 403,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.arange#406",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.arange(start, stop=None, step=1, dtype='int32')",
        "snippet": "def arange(start, stop=None, step=1, dtype='int32'):\n    return np.arange(start, stop, step, dtype)",
        "begin_line": 406,
        "end_line": 407,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.flatten#410",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.flatten(x)",
        "snippet": "def flatten(x):\n    return np.reshape(x, (-1,))",
        "begin_line": 410,
        "end_line": 411,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.batch_flatten#414",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.batch_flatten(x)",
        "snippet": "def batch_flatten(x):\n    return np.reshape(x, (x.shape[0], -1))",
        "begin_line": 414,
        "end_line": 415,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.eval#418",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.eval(x)",
        "snippet": "def eval(x):\n    return x",
        "begin_line": 418,
        "end_line": 419,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.dtype#422",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.dtype(x)",
        "snippet": "def dtype(x):\n    return x.dtype.name",
        "begin_line": 422,
        "end_line": 423,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.constant#426",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.constant(value, dtype=None, shape=None, name=None)",
        "snippet": "def constant(value, dtype=None, shape=None, name=None):\n    if dtype is None:\n        dtype = floatx()\n    if shape is None:\n        shape = ()\n    np_value = value * np.ones(shape)\n    np_value.astype(dtype)\n    return np_value",
        "begin_line": 426,
        "end_line": 433,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.print_tensor#436",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.print_tensor(x, message='')",
        "snippet": "def print_tensor(x, message=''):\n    print(x, message)\n    return x",
        "begin_line": 436,
        "end_line": 438,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.eye#441",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.eye(size, dtype=None, name=None)",
        "snippet": "def eye(size, dtype=None, name=None):\n    return np.eye(size, dtype=dtype)",
        "begin_line": 441,
        "end_line": 442,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.dot#445",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.dot(x, y)",
        "snippet": "def dot(x, y):\n    return np.dot(x, y)",
        "begin_line": 445,
        "end_line": 446,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.transpose#449",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.transpose(x)",
        "snippet": "def transpose(x):\n    return np.transpose(x)",
        "begin_line": 449,
        "end_line": 450,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.reverse#453",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.reverse(x, axes)",
        "snippet": "def reverse(x, axes):\n    if isinstance(axes, int):\n        axes = [axes]\n    for a in axes:\n        x = np.flip(x, a)\n    return x",
        "begin_line": 453,
        "end_line": 458,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.variable#461",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.variable(value, dtype=None, name=None, constraint=None)",
        "snippet": "def variable(value, dtype=None, name=None, constraint=None):\n    if constraint is not None:\n        raise TypeError(\"Constraint must be None when \"\n                        \"using the NumPy backend.\")\n    return np.array(value, dtype)",
        "begin_line": 461,
        "end_line": 465,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.equal#468",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.equal(x, y)",
        "snippet": "def equal(x, y):\n    return x == y",
        "begin_line": 468,
        "end_line": 469,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.not_equal#472",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.not_equal(x, y)",
        "snippet": "def not_equal(x, y):\n    return x != y",
        "begin_line": 472,
        "end_line": 473,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.greater#476",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.greater(x, y)",
        "snippet": "def greater(x, y):\n    return x > y",
        "begin_line": 476,
        "end_line": 477,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.greater_equal#480",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.greater_equal(x, y)",
        "snippet": "def greater_equal(x, y):\n    return x >= y",
        "begin_line": 480,
        "end_line": 481,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.less#484",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.less(x, y)",
        "snippet": "def less(x, y):\n    return x < y",
        "begin_line": 484,
        "end_line": 485,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.less_equal#488",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.less_equal(x, y)",
        "snippet": "def less_equal(x, y):\n    return x <= y",
        "begin_line": 488,
        "end_line": 489,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.maximum#492",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.maximum(x, y)",
        "snippet": "def maximum(x, y):\n    return np.maximum(x, y)",
        "begin_line": 492,
        "end_line": 493,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.minimum#496",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.minimum(x, y)",
        "snippet": "def minimum(x, y):\n    return np.minimum(x, y)",
        "begin_line": 496,
        "end_line": 497,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.random_uniform_variable#500",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.random_uniform_variable(shape, low, high, dtype=None, name=None, seed=None)",
        "snippet": "def random_uniform_variable(shape, low, high, dtype=None, name=None, seed=None):\n    return (high - low) * np.random.random(shape).astype(dtype) + low",
        "begin_line": 500,
        "end_line": 501,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.random_normal_variable#504",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.random_normal_variable(shape, mean, scale, dtype=None, name=None, seed=None)",
        "snippet": "def random_normal_variable(shape, mean, scale, dtype=None, name=None, seed=None):\n    return scale * np.random.randn(*shape).astype(dtype) + mean",
        "begin_line": 504,
        "end_line": 505,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.resize_images#508",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.resize_images(x, height_factor, width_factor, data_format)",
        "snippet": "def resize_images(x, height_factor, width_factor, data_format):\n    if data_format == 'channels_first':\n        x = repeat_elements(x, height_factor, axis=2)\n        x = repeat_elements(x, width_factor, axis=3)\n    elif data_format == 'channels_last':\n        x = repeat_elements(x, height_factor, axis=1)\n        x = repeat_elements(x, width_factor, axis=2)\n    return x",
        "begin_line": 508,
        "end_line": 515,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.reference_operations.resize_volumes#518",
        "src_path": "tests/keras/backend/reference_operations.py",
        "class_name": "tests.keras.backend.reference_operations",
        "signature": "tests.keras.backend.reference_operations.resize_volumes(x, depth_factor, height_factor, width_factor, data_format)",
        "snippet": "def resize_volumes(x, depth_factor, height_factor, width_factor, data_format):\n    if data_format == 'channels_first':\n        x = repeat_elements(x, depth_factor, axis=2)\n        x = repeat_elements(x, height_factor, axis=3)\n        x = repeat_elements(x, width_factor, axis=4)\n    elif data_format == 'channels_last':\n        x = repeat_elements(x, depth_factor, axis=1)\n        x = repeat_elements(x, height_factor, axis=2)\n        x = repeat_elements(x, width_factor, axis=3)\n    return x",
        "begin_line": 518,
        "end_line": 527,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.check_dtype#41",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.check_dtype(var, dtype)",
        "snippet": "def check_dtype(var, dtype):\n    if K._BACKEND == 'theano':\n        assert var.dtype == dtype\n    else:\n        assert var.dtype.name == '%s_ref' % dtype",
        "begin_line": 41,
        "end_line": 45,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.cntk_func_single_tensor#48",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.cntk_func_single_tensor(function_name, x_shape, **kwargs)",
        "snippet": "def cntk_func_single_tensor(function_name, x_shape, **kwargs):\n    xc = KC.placeholder(x_shape)\n    output_cntk = getattr(KC, function_name)(xc, **kwargs)\n    return output_cntk, KC.function([xc], [output_cntk])",
        "begin_line": 48,
        "end_line": 51,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.cntk_func_two_tensor#54",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.cntk_func_two_tensor(function_name, x_shape, y, **kwargs)",
        "snippet": "def cntk_func_two_tensor(function_name, x_shape, y, **kwargs):\n    if isinstance(y, (np.generic, np.ndarray)):\n        xc = KC.placeholder(x_shape)\n        output_cntk = getattr(KC, function_name)(xc, KC.variable(y), **kwargs)\n        return output_cntk, KC.function([xc], [output_cntk])\n    else:\n        xc = KC.placeholder(ndim=len(x_shape))\n        yc = KC.placeholder(y)\n        output_cntk = getattr(KC, function_name)(xc, yc, **kwargs)\n        return output_cntk, KC.function([xc, yc], [output_cntk])",
        "begin_line": 54,
        "end_line": 63,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.cntk_func_three_tensor#66",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.cntk_func_three_tensor(function_name, x_shape, y, z, **kwargs)",
        "snippet": "def cntk_func_three_tensor(function_name, x_shape, y, z, **kwargs):\n    xc = KC.placeholder(x_shape)\n    output_cntk = getattr(KC, function_name)(xc, KC.variable(y), KC.variable(z), **kwargs)\n    return KC.function([xc], [output_cntk])",
        "begin_line": 66,
        "end_line": 69,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.parse_shape_or_val#72",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.parse_shape_or_val(shape_or_val)",
        "snippet": "def parse_shape_or_val(shape_or_val):\n    if isinstance(shape_or_val, np.ndarray):\n        return shape_or_val.shape, shape_or_val\n    else:\n        return shape_or_val, np.random.random(shape_or_val).astype(np.float32) - 0.5",
        "begin_line": 72,
        "end_line": 76,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.assert_list_pairwise#79",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.assert_list_pairwise(z_list, shape=True, allclose=True, itself=False, atol=1e-05)",
        "snippet": "def assert_list_pairwise(z_list, shape=True, allclose=True, itself=False, atol=1e-05):\n    for (z1, z2) in zip(z_list[1:], z_list[:-1]):\n        if shape:\n            assert z1.shape == z2.shape\n        if allclose:\n            assert_allclose(z1, z2, atol=atol)\n        if itself:\n            assert z1 == z2",
        "begin_line": 79,
        "end_line": 86,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.assert_list_keras_shape#89",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.assert_list_keras_shape(t_list, z_list)",
        "snippet": "def assert_list_keras_shape(t_list, z_list):\n    for t, z in zip(t_list, z_list):\n        if hasattr(t, '_keras_shape') and len(t._keras_shape) > 1:\n            for i, s in enumerate(t._keras_shape):\n                if s:\n                    assert t._keras_shape[i] == z.shape[i]",
        "begin_line": 89,
        "end_line": 94,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.check_single_tensor_operation#98",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.check_single_tensor_operation(function_name, x_shape_or_val, backend_list, **kwargs)",
        "snippet": "def check_single_tensor_operation(function_name, x_shape_or_val, backend_list, **kwargs):\n    shape_or_val = kwargs.pop('shape_or_val', True)\n    assert_value_equality = kwargs.pop('assert_value_equality', True)\n    cntk_dynamicity = kwargs.pop('cntk_dynamicity', False)\n\n    if shape_or_val:\n        x_shape, x_val = parse_shape_or_val(x_shape_or_val)\n\n    t_list = []\n    z_list = []\n    for k in backend_list:\n        if shape_or_val:\n            if (k == KC) & (cntk_dynamicity):\n                t, f = cntk_func_single_tensor(function_name, x_shape, **kwargs)\n                z = f([x_val])[0]\n            else:\n                t = getattr(k, function_name)(k.variable(x_val), **kwargs)\n                z = k.eval(t)\n        else:\n            t = getattr(k, function_name)(x_shape_or_val, **kwargs)\n            z = k.eval(t)\n        t_list += [t]\n        z_list += [z]\n\n    assert_list_pairwise(z_list, allclose=assert_value_equality)\n    assert_list_keras_shape(t_list, z_list)",
        "begin_line": 98,
        "end_line": 123,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.check_two_tensor_operation#127",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.check_two_tensor_operation(function_name, x_shape_or_val, y_shape_or_val, backend_list, **kwargs)",
        "snippet": "def check_two_tensor_operation(function_name, x_shape_or_val,\n                               y_shape_or_val, backend_list, **kwargs):\n    concat_args = kwargs.pop('concat_args', False)\n    cntk_dynamicity = kwargs.pop('cntk_dynamicity', False)\n    cntk_two_dynamicity = kwargs.pop('cntk_two_dynamicity', False)\n\n    x_shape, x_val = parse_shape_or_val(x_shape_or_val)\n    y_shape, y_val = parse_shape_or_val(y_shape_or_val)\n\n    t_list = []\n    z_list = []\n    for k in backend_list:\n        if (k == KC) & (cntk_dynamicity):\n            t, f = cntk_func_two_tensor(function_name, x_shape, y=y_val, **kwargs)\n            z = f([x_val])[0]\n        elif (k == KC) & (cntk_two_dynamicity):\n            t, f = cntk_func_two_tensor(function_name, x_shape, y=y_shape, **kwargs)\n            z = f([x_val, y_val])[0]\n        elif (k == KTH) & (function_name[:4] == 'conv'):\n            t = getattr(k, function_name)(\n                k.variable(x_val), k.variable(convert_kernel(y_val)), **kwargs)\n            z = k.eval(t)\n        elif concat_args:\n            t = getattr(k, function_name)(\n                [k.variable(x_val), k.variable(y_val)], **kwargs)\n            z = k.eval(t)\n        else:\n            t = getattr(k, function_name)(\n                k.variable(x_val), k.variable(y_val), **kwargs)\n            z = k.eval(t)\n        t_list += [t]\n        z_list += [z]\n\n    assert_list_pairwise(z_list)\n    assert_list_keras_shape(t_list, z_list)",
        "begin_line": 127,
        "end_line": 161,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.check_composed_tensor_operations#165",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test",
        "signature": "tests.keras.backend.backend_test.check_composed_tensor_operations(first_function_name, first_function_args, second_function_name, second_function_args, input_shape, backend_list)",
        "snippet": "def check_composed_tensor_operations(first_function_name, first_function_args,\n                                     second_function_name, second_function_args,\n                                     input_shape, backend_list):\n    val = np.random.random(input_shape) - 0.5\n\n    z_list = []\n    for k in backend_list:\n        x = k.variable(val)\n        y = getattr(k, first_function_name)(x, **first_function_args)\n        z = k.eval(getattr(k, second_function_name)(y, **second_function_args))\n        z_list += [z]\n\n    assert_list_pairwise(z_list)",
        "begin_line": 165,
        "end_line": 177,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_is_keras_tensor#182",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_is_keras_tensor(self)",
        "snippet": "    def test_is_keras_tensor(self):\n        np_var = np.array([1, 2])\n        with pytest.raises(ValueError):\n            K.is_keras_tensor(np_var)\n\n        keras_var = K.variable(np_var)\n        assert K.is_keras_tensor(keras_var) is False\n        keras_placeholder = K.placeholder(shape=(2, 4, 5))\n        assert K.is_keras_tensor(keras_placeholder) is False",
        "begin_line": 182,
        "end_line": 190,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_set_learning_phase#192",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_set_learning_phase(self)",
        "snippet": "    def test_set_learning_phase(self):\n        # not supported learning_phase\n        with pytest.raises(ValueError):\n            K.set_learning_phase(2)",
        "begin_line": 192,
        "end_line": 195,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_eye#197",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_eye(self)",
        "snippet": "    def test_eye(self):\n        check_single_tensor_operation('eye', 3, WITH_NP, shape_or_val=False)",
        "begin_line": 197,
        "end_line": 198,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_linear_operations#200",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_linear_operations(self)",
        "snippet": "    def test_linear_operations(self):\n        check_two_tensor_operation('dot', (4, 2), (2, 4), WITH_NP)\n        check_two_tensor_operation('dot', (4, 2), (5, 2, 3), WITH_NP)\n\n        check_two_tensor_operation('batch_dot', (4, 2, 3), (4, 5, 3),\n                                   BACKENDS, cntk_two_dynamicity=True, axes=(2, 2))\n        check_two_tensor_operation('batch_dot', (4, 2, 3), (4, 3),\n                                   BACKENDS, cntk_two_dynamicity=True, axes=(2, 1))\n        check_two_tensor_operation('batch_dot', (4, 2), (4, 2, 3),\n                                   BACKENDS, cntk_two_dynamicity=True, axes=(1, 1))\n        check_two_tensor_operation('batch_dot', (32, 20), (32, 20),\n                                   BACKENDS, cntk_two_dynamicity=True, axes=1)\n        check_two_tensor_operation('batch_dot', (32, 20), (32, 20),\n                                   BACKENDS, cntk_two_dynamicity=True, axes=(1, 1))\n\n        check_single_tensor_operation('transpose', (4, 2), WITH_NP)\n        check_single_tensor_operation('reverse', (4, 3, 2), WITH_NP, axes=1)\n        if K.backend() != 'cntk':\n            check_single_tensor_operation('reverse', (4, 3, 2), WITH_NP, axes=(1, 2))",
        "begin_line": 200,
        "end_line": 218,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_random_variables#220",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_random_variables(self)",
        "snippet": "    def test_random_variables(self):\n        check_single_tensor_operation('random_uniform_variable', (2, 3), WITH_NP,\n                                      low=0., high=1.,\n                                      shape_or_val=False, assert_value_equality=False)\n        check_single_tensor_operation('random_normal_variable', (2, 3), WITH_NP,\n                                      mean=0., scale=1.,\n                                      shape_or_val=False, assert_value_equality=False)",
        "begin_line": 220,
        "end_line": 226,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_batch_dot_shape#229",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_batch_dot_shape(self)",
        "snippet": "    def test_batch_dot_shape(self):\n        x_batch = K.ones(shape=(32, 20))\n        y_batch = K.ones(shape=(32, 20))\n        xy_batch_dot = K.batch_dot(x_batch, y_batch, axes=1)\n        assert_allclose(K.eval(xy_batch_dot), np.ones((32, 1)) * 20, atol=1e-05)\n        xy_batch_dot = K.batch_dot(x_batch, y_batch, axes=0)\n        assert_allclose(K.eval(xy_batch_dot), np.ones((20, 1)) * 32, atol=1e-05)\n        # making sure swapping axes when ndim == 2 works\n        x_batch = K.ones(shape=(32, 20))\n        y_batch = K.ones(shape=(20, 32))\n        xy_batch_dot = K.batch_dot(x_batch, y_batch, axes=(0, 1))\n        assert_allclose(K.eval(xy_batch_dot), np.ones((20, 1)) * 32, atol=1e-05)\n        xy_batch_dot = K.batch_dot(x_batch, y_batch, axes=(1, 0))\n        assert_allclose(K.eval(xy_batch_dot), np.ones((32, 1)) * 20, atol=1e-05)",
        "begin_line": 229,
        "end_line": 242,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_shape_operations#244",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_shape_operations(self)",
        "snippet": "    def test_shape_operations(self):\n        check_two_tensor_operation('concatenate', (4, 3), (4, 2), WITH_NP,\n                                   axis=-1, concat_args=True)\n\n        check_single_tensor_operation('reshape', (4, 2), WITH_NP, shape=(8, 1))\n        check_single_tensor_operation('permute_dimensions', (4, 2, 3), WITH_NP,\n                                      pattern=(2, 0, 1))\n        check_single_tensor_operation('repeat', (4, 1), WITH_NP, n=3)\n        check_single_tensor_operation('flatten', (4, 1), WITH_NP)\n        check_single_tensor_operation('batch_flatten', (20, 2, 5), WITH_NP,\n                                      cntk_dynamicity=True)\n        check_single_tensor_operation('expand_dims', (4, 3), WITH_NP, axis=-1)\n        check_single_tensor_operation('expand_dims', (4, 3, 2), WITH_NP, axis=1)\n        check_single_tensor_operation('squeeze', (4, 3, 1), WITH_NP, axis=2)\n        check_single_tensor_operation('squeeze', (4, 1, 1), WITH_NP, axis=1)\n        check_composed_tensor_operations('reshape', {'shape': (4, 3, 1, 1)},\n                                         'squeeze', {'axis': 2},\n                                         (4, 3, 1, 1), WITH_NP)",
        "begin_line": 244,
        "end_line": 261,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_none_shape_operations#266",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_none_shape_operations(self)",
        "snippet": "    def test_none_shape_operations(self):\n        # Test shape inference when input\n        # shape has `None` entries\n        x = K.placeholder((3, None, 4))\n\n        y = K.batch_flatten(x)\n        if hasattr(y, '_keras_shape'):\n            assert y._keras_shape == (3, None)\n\n        y = K.flatten(x)\n        if hasattr(y, '_keras_shape'):\n            assert y._keras_shape == (None, )",
        "begin_line": 266,
        "end_line": 277,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_repeat_elements#279",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_repeat_elements(self)",
        "snippet": "    def test_repeat_elements(self):\n        reps = 3\n        for ndims in [1, 2, 3]:\n            shape = np.arange(2, 2 + ndims)\n            arr = np.arange(np.prod(shape)).reshape(shape)\n\n            for rep_axis in range(ndims):\n                check_single_tensor_operation('repeat_elements', arr, WITH_NP,\n                                              rep=reps, axis=rep_axis)\n\n                if K.backend() != 'cntk':\n                    shape = list(shape)\n                    shape[rep_axis] = None\n                    x = K.placeholder(shape=shape)\n                    y = K.repeat_elements(x, reps, axis=rep_axis)\n                    assert y._keras_shape == tuple(shape)\n                    assert y._keras_shape == K.int_shape(y)",
        "begin_line": 279,
        "end_line": 295,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_tile#297",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_tile(self)",
        "snippet": "    def test_tile(self):\n        shape = (3, 4)\n        arr = np.arange(np.prod(shape)).reshape(shape)\n        check_single_tensor_operation('tile', arr, BACKENDS, n=[2, 1])\n        check_single_tensor_operation('tile', (2, 5), BACKENDS, n=[5, 2])\n\n        # test theano shape inference when\n        # input shape has None entries\n        if K.backend() == 'theano':\n            x = K.placeholder(shape=(None, 4))\n            n = 2\n            y = K.tile(x, n)\n            assert y._keras_shape == (None, 8)\n            n = (4, 3)\n            y = K.tile(x, n)\n            assert y._keras_shape == (None, 12)",
        "begin_line": 297,
        "end_line": 312,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_gather#314",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_gather(self)",
        "snippet": "    def test_gather(self):\n        shape = (10, 2, 3)\n        ref = np.arange(np.prod(shape)).reshape(shape)\n        inds = [1, 3, 7, 9]\n        t_list = [k.gather(k.variable(ref), k.variable(inds, dtype='int32'))\n                  for k in BACKENDS]\n        z_list = [k.eval(k.gather(k.variable(ref), k.variable(inds, dtype='int32')))\n                  for k in BACKENDS]\n\n        assert_list_pairwise(z_list)\n        assert_list_keras_shape(t_list, z_list)\n\n        # test theano shape inference when\n        # input shape has None entries\n        if K.backend() == 'theano':\n            x = K.placeholder(shape=(None, 3, 4))\n            indices = K.placeholder(shape=(5, 6), dtype='int32')\n            y = K.gather(x, indices)\n            assert y._keras_shape == (5, 6, 3, 4)",
        "begin_line": 314,
        "end_line": 332,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_value_manipulation#334",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_value_manipulation(self)",
        "snippet": "    def test_value_manipulation(self):\n        val = np.random.random((4, 2))\n        for function_name in ['get_value', 'count_params',\n                              'int_shape', 'get_variable_shape']:\n            v_list = [getattr(k, function_name)(k.variable(val))\n                      for k in BACKENDS]\n\n            if function_name == 'get_value':\n                assert_list_pairwise(v_list)\n            else:\n                assert_list_pairwise(v_list, shape=False, allclose=False, itself=True)\n\n        # print_tensor\n        check_single_tensor_operation('print_tensor', (), WITH_NP)\n        check_single_tensor_operation('print_tensor', (2,), WITH_NP)\n        check_single_tensor_operation('print_tensor', (4, 3), WITH_NP)\n        check_single_tensor_operation('print_tensor', (1, 2, 3), WITH_NP)",
        "begin_line": 334,
        "end_line": 350,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_elementwise_operations#352",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_elementwise_operations(self)",
        "snippet": "    def test_elementwise_operations(self):\n        check_single_tensor_operation('max', (4, 2), WITH_NP)\n        check_single_tensor_operation('max', (4, 2), WITH_NP, axis=1, keepdims=True)\n\n        check_single_tensor_operation('min', (4, 2), WITH_NP)\n        check_single_tensor_operation('min', (4, 2), WITH_NP, axis=1, keepdims=True)\n        check_single_tensor_operation('min', (4, 2, 3), WITH_NP, axis=[1, -1])\n\n        check_single_tensor_operation('mean', (4, 2), WITH_NP)\n        check_single_tensor_operation('mean', (4, 2), WITH_NP, axis=1, keepdims=True)\n        check_single_tensor_operation('mean', (4, 2, 3), WITH_NP, axis=-1, keepdims=True)\n        check_single_tensor_operation('mean', (4, 2, 3), WITH_NP, axis=[1, -1])\n\n        check_single_tensor_operation('std', (4, 2), WITH_NP)\n        check_single_tensor_operation('std', (4, 2), WITH_NP, axis=1, keepdims=True)\n        # check_single_tensor_operation('std', (4, 2, 3), BACKENDS, axis=[1, -1])\n\n        check_single_tensor_operation('prod', (4, 2), WITH_NP)\n        check_single_tensor_operation('prod', (4, 2), WITH_NP, axis=1, keepdims=True)\n        check_single_tensor_operation('prod', (4, 2, 3), WITH_NP, axis=[1, -1])\n\n        check_single_tensor_operation('any', (4, 2), WITH_NP)\n        check_single_tensor_operation('any', (4, 2), WITH_NP, axis=1, keepdims=True)\n\n        check_single_tensor_operation('all', (4, 2), WITH_NP)\n        check_single_tensor_operation('all', (4, 2), WITH_NP, axis=1, keepdims=True)\n\n        check_single_tensor_operation('argmax', (4, 2), WITH_NP)\n        check_single_tensor_operation('argmax', (4, 2), WITH_NP, axis=1)\n\n        check_single_tensor_operation('argmin', (4, 2), WITH_NP)\n        check_single_tensor_operation('argmin', (4, 2), WITH_NP, axis=1)\n\n        check_single_tensor_operation('square', (4, 2), WITH_NP)\n        check_single_tensor_operation('abs', (4, 2), WITH_NP)\n        check_single_tensor_operation('sqrt', (4, 2), WITH_NP)\n        check_single_tensor_operation('exp', (4, 2), WITH_NP)\n\n        check_single_tensor_operation('round', (4, 2), WITH_NP)\n        check_single_tensor_operation('sign', (4, 2), WITH_NP)\n        check_single_tensor_operation('pow', (4, 2), WITH_NP, a=3)\n        check_single_tensor_operation('clip', (4, 2), WITH_NP, min_value=0.4,\n                                      max_value=0.6)\n\n        # two-tensor ops\n        check_two_tensor_operation('equal', (4, 2), (4, 2), WITH_NP)\n        check_two_tensor_operation('not_equal', (4, 2), (4, 2), WITH_NP)\n        check_two_tensor_operation('greater', (4, 2), (4, 2), WITH_NP)\n        check_two_tensor_operation('greater_equal', (4, 2), (4, 2), WITH_NP)\n        check_two_tensor_operation('less', (4, 2), (4, 2), WITH_NP)\n        check_two_tensor_operation('less_equal', (4, 2), (4, 2), WITH_NP)\n        check_two_tensor_operation('maximum', (4, 2), (4, 2), WITH_NP)\n        check_two_tensor_operation('minimum', (4, 2), (4, 2), WITH_NP)",
        "begin_line": 352,
        "end_line": 404,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_cumsum_cumprod#408",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_cumsum_cumprod(self)",
        "snippet": "    def test_cumsum_cumprod(self):\n        check_single_tensor_operation('cumsum', (4, 2), WITH_NP)\n        check_single_tensor_operation('cumsum', (4, 2), WITH_NP, axis=1)\n\n        check_single_tensor_operation('cumprod', (4, 2), WITH_NP)\n        check_single_tensor_operation('cumprod', (4, 2), WITH_NP, axis=1)",
        "begin_line": 408,
        "end_line": 413,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_log#419",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_log(self)",
        "snippet": "    def test_log(self):\n        check_single_tensor_operation('log', (4, 2), WITH_NP)",
        "begin_line": 419,
        "end_line": 420,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_gradient#424",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_gradient(self)",
        "snippet": "    def test_gradient(self):\n        val = np.random.random((4, 2))\n        x_list = [k.variable(val) for k in [KTH, KTF]]\n        z_list = []\n        zero_list = []\n        for x, k in zip(x_list, [KTH, KTF]):\n            exp = x * k.exp(x)\n            loss = k.sum(exp)\n            zero_loss = k.stop_gradient(loss)\n            grad = k.gradients(loss, [exp])\n            zero_grad = k.gradients(loss + zero_loss, [exp])\n            z_list.append(k.eval(grad[0]))\n            zero_list.append(k.eval(zero_grad[0]))\n\n        assert_list_pairwise(z_list)\n        assert_list_pairwise(zero_list)\n        for i in range(len(z_list)):\n            assert_allclose(zero_list[i], z_list[i], atol=1e-05)",
        "begin_line": 424,
        "end_line": 441,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_stop_gradient#443",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_stop_gradient(self)",
        "snippet": "    def test_stop_gradient(self):\n        # This test checks the consistency of the stop_gradient backend API.\n        # It doesn't check the functionality (which is checked at the\n        # test_gradient test).\n        val = np.random.random((4, 2))\n        a = K.variable(val)\n        b = K.square(a)\n        c, d = K.stop_gradient([a, b])\n        e = K.stop_gradient(b)",
        "begin_line": 443,
        "end_line": 451,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_function#456",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_function(self)",
        "snippet": "    def test_function(self):\n        test_backend = [KTH, KTF]\n        val = np.random.random((4, 2))\n        input_val = np.random.random((4, 2))\n\n        f_list = []\n        x_list = []\n        for k in test_backend:\n            x = k.variable(val)\n            x_list.append(x)\n            y = k.placeholder(ndim=2)\n            exp = k.square(x) + y\n            update = x * 2\n            f = k.function([y], [exp], updates=[(x, update)])\n            f_list.append(f)\n\n        function_outputs_list = [f([input_val])[0] for f in f_list]\n        assert_list_pairwise(function_outputs_list)\n\n        new_val_list = [k.get_value(x) for x, k in zip(x_list, test_backend)]\n        assert_list_pairwise(new_val_list)",
        "begin_line": 456,
        "end_line": 476,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_function_tf_fetches#480",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_function_tf_fetches(self)",
        "snippet": "    def test_function_tf_fetches(self):\n        # Additional operations can be passed to tf.Session().run() via its\n        # `fetches` arguments. In contrast to `updates` argument of\n        # KTF.function() these do not have control dependency on `outputs`, so\n        # they can run in parallel. Also they should not contribute to output of\n        # KTF.function().\n\n        x = K.variable(0.)\n        y = K.variable(0.)\n        x_placeholder = K.placeholder(shape=())\n        y_placeholder = K.placeholder(shape=())\n\n        f = K.function(inputs=[x_placeholder, y_placeholder],\n                       outputs=[x_placeholder + y_placeholder],\n                       updates=[(x, x_placeholder + 1.)],\n                       fetches=[K.update(y, 5.)])\n        output = f([10., 20.])\n        assert output == [30.]\n        assert K.get_session().run(fetches=[x, y]) == [11., 5.]",
        "begin_line": 480,
        "end_line": 498,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_function_tf_feed_dict#502",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_function_tf_feed_dict(self)",
        "snippet": "    def test_function_tf_feed_dict(self):\n        # Additional substitutions can be passed to `tf.Session().run()` via its\n        # `feed_dict` arguments. Note that the feed_dict is passed once in the\n        # constructor but we can modify the values in the dictionary. Through\n        # this feed_dict we can provide additional substitutions besides Keras\n        # inputs.\n\n        x = K.variable(0.)\n        y = K.variable(0.)\n        x_placeholder = K.placeholder(shape=())\n        y_placeholder = K.placeholder(shape=())\n\n        feed_dict = {y_placeholder: 3.}\n\n        f = K.function(inputs=[x_placeholder],\n                       outputs=[x_placeholder + 1.],\n                       updates=[(x, x_placeholder + 10.)],\n                       feed_dict=feed_dict,\n                       fetches=[K.update(y, y_placeholder * 10.)])\n        output = f([10.])\n        assert output == [11.]\n        assert K.get_session().run(fetches=[x, y]) == [20., 30.]\n\n        # updated value in feed_dict will be modified within the K.function()\n        feed_dict[y_placeholder] = 4.\n        output = f([20.])\n        assert output == [21.]\n        assert K.get_session().run(fetches=[x, y]) == [30., 40.]",
        "begin_line": 502,
        "end_line": 529,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_function_tf_run_options_with_run_metadata#533",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_function_tf_run_options_with_run_metadata(self)",
        "snippet": "    def test_function_tf_run_options_with_run_metadata(self):\n        from tensorflow.core.protobuf import config_pb2\n        x_placeholder = K.placeholder(shape=())\n        y_placeholder = K.placeholder(shape=())\n\n        run_options = config_pb2.RunOptions(output_partition_graphs=True)\n        run_metadata = config_pb2.RunMetadata()\n        # enable run_options.\n        f = K.function(inputs=[x_placeholder, y_placeholder],\n                       outputs=[x_placeholder + y_placeholder],\n                       options=run_options,\n                       run_metadata=run_metadata)\n        output = f([10., 20.])\n        assert output == [30.]\n        assert len(run_metadata.partition_graphs) > 0\n        # disable run_options.\n        f = K.function(inputs=[x_placeholder, y_placeholder],\n                       outputs=[x_placeholder + y_placeholder],\n                       run_metadata=run_metadata)\n        output = f([10., 20.])\n        assert output == [30.]\n        assert len(run_metadata.partition_graphs) == 0",
        "begin_line": 533,
        "end_line": 554,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_function_tf_string_input#558",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_function_tf_string_input(self)",
        "snippet": "    def test_function_tf_string_input(self):\n        # Test functions with string inputs.\n\n        x_placeholder = K.placeholder(shape=(), dtype=\"string\")\n        x_identity = K.identity(x_placeholder)\n\n        f = K.function(inputs=[x_placeholder], outputs=[x_identity])\n        output = f([b'test'])\n        assert output == [b'test']",
        "begin_line": 558,
        "end_line": 566,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_rnn#568",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_rnn(self)",
        "snippet": "    def test_rnn(self):\n        # implement a simple RNN\n        num_samples = 4\n        input_dim = 5\n        output_dim = 3\n        timesteps = 6\n\n        _, x = parse_shape_or_val((num_samples, timesteps, input_dim))\n        _, h0 = parse_shape_or_val((num_samples, output_dim))\n        _, wi = parse_shape_or_val((input_dim, output_dim))\n        _, wh = parse_shape_or_val((output_dim, output_dim))\n        mask = np.random.randint(2, size=(num_samples, timesteps))\n\n        x_k = K.variable(x)\n        h0_k = [K.variable(h0)]\n        wi_k = K.variable(wi)\n        wh_k = K.variable(wh)\n        mask_k = K.variable(mask)\n\n        def rnn_fn(x_k, h_k):\n            assert len(h_k) == 1\n            y_k = K.dot(x_k, wi_k) + K.dot(h_k[0], wh_k)\n            return y_k, [y_k]\n\n        # test default setup\n        last_output_list = []\n        outputs_list = []\n        state_list = []\n\n        kwargs_list = [\n            {'go_backwards': False, 'mask': None},\n            {'go_backwards': False, 'mask': None, 'unroll': True, 'input_length': timesteps},\n            {'go_backwards': True, 'mask': None},\n            {'go_backwards': True, 'mask': None, 'unroll': True, 'input_length': timesteps},\n            {'go_backwards': False, 'mask': mask_k},\n            {'go_backwards': False, 'mask': mask_k, 'unroll': True, 'input_length': timesteps},\n        ]\n\n        for (i, kwargs) in enumerate(kwargs_list):\n            last_y1, y1, h1 = KNP.rnn(x, [wi, wh, None], h0, **kwargs)\n            last_y2, y2, h2 = K.rnn(rnn_fn, x_k, h0_k, **kwargs)\n\n            assert len(h2) == 1\n            last_y2 = K.eval(last_y2)\n            y2 = K.eval(y2)\n            h1 = h1[:, -1]\n            h2 = K.eval(h2[0])\n\n            if kwargs['mask'] is not None:\n                last_y1 = last_y1 * np.expand_dims(mask[:, -1], -1)\n                last_y2 = last_y2 * np.expand_dims(mask[:, -1], -1)\n                y1 = y1 * np.expand_dims(mask, -1)\n                y2 = y2 * np.expand_dims(mask, -1)\n                h1 = h1 * np.expand_dims(mask[:, -1], -1)\n                h2 = h2 * np.expand_dims(mask[:, -1], -1)\n\n            last_output_list.append(last_y2)\n            outputs_list.append(y2)\n            state_list.append(h2)\n\n            if i % 2 == 0:\n                assert_allclose(last_y1, last_y2, atol=1e-05)\n                assert_allclose(y1, y2, atol=1e-05)\n                assert_allclose(h1, h2, atol=1e-05)\n            else:\n                assert_allclose(last_output_list[i - 1], last_output_list[i], atol=1e-05)\n                assert_allclose(outputs_list[i - 1], outputs_list[i], atol=1e-05)\n                assert_allclose(state_list[i - 1], state_list[i], atol=1e-05)",
        "begin_line": 568,
        "end_line": 635,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.rnn_fn#587",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.rnn_fn(x_k, h_k)",
        "snippet": "        def rnn_fn(x_k, h_k):\n            assert len(h_k) == 1\n            y_k = K.dot(x_k, wi_k) + K.dot(h_k[0], wh_k)\n            return y_k, [y_k]",
        "begin_line": 587,
        "end_line": 590,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_rnn_additional_states#637",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_rnn_additional_states(self)",
        "snippet": "    def test_rnn_additional_states(self):\n        # implement a simple RNN with an additional state\n        # whose shape is different from that of the output\n        num_samples = 4\n        input_dim = 5\n        output_dim = 3\n        timesteps = 6\n\n        _, x = parse_shape_or_val((num_samples, timesteps, input_dim))\n        _, h0 = parse_shape_or_val((num_samples, output_dim))\n        _, wi = parse_shape_or_val((input_dim, output_dim))\n        _, wh = parse_shape_or_val((output_dim, output_dim))\n        mask = np.random.randint(2, size=(num_samples, timesteps))\n\n        x_k = K.variable(x)\n        h0_k = [K.variable(h0), K.variable(np.concatenate([h0, h0], axis=-1))]\n        wi_k = K.variable(wi)\n        wh_k = K.variable(wh)\n        mask_k = K.variable(mask)\n\n        def rnn_fn(x_k, h_k):\n            assert len(h_k) == 2\n            y_k = K.dot(x_k, wi_k) + K.dot(h_k[0], wh_k)\n            return y_k, [y_k, K.concatenate([y_k, y_k], axis=-1)]\n\n        # test default setup\n        last_output_list = []\n        outputs_list = []\n        state_list = []\n\n        kwargs_list = [\n            {'go_backwards': False, 'mask': None},\n            {'go_backwards': False, 'mask': None, 'unroll': True, 'input_length': timesteps},\n            {'go_backwards': True, 'mask': None},\n            {'go_backwards': True, 'mask': None, 'unroll': True, 'input_length': timesteps},\n            {'go_backwards': False, 'mask': mask_k},\n            {'go_backwards': False, 'mask': mask_k, 'unroll': True, 'input_length': timesteps},\n        ]\n\n        for (i, kwargs) in enumerate(kwargs_list):\n            last_y1, y1, h1 = KNP.rnn(x, [wi, wh, None], h0, **kwargs)\n            last_y2, y2, h2 = K.rnn(rnn_fn, x_k, h0_k, **kwargs)\n\n            assert len(h2) == 2\n            last_y2 = K.eval(last_y2)\n            y2 = K.eval(y2)\n            h11 = h1[:, -1]\n            h12 = np.concatenate([h1[:, -1], h1[:, -1]], axis=-1)\n            h21 = K.eval(h2[0])\n            h22 = K.eval(h2[1])\n\n            if kwargs['mask'] is not None:\n                last_y1 = last_y1 * np.expand_dims(mask[:, -1], -1)\n                last_y2 = last_y2 * np.expand_dims(mask[:, -1], -1)\n                y1 = y1 * np.expand_dims(mask, -1)\n                y2 = y2 * np.expand_dims(mask, -1)\n                h11 = h11 * np.expand_dims(mask[:, -1], -1)\n                h21 = h21 * np.expand_dims(mask[:, -1], -1)\n                h12 = h12 * np.expand_dims(mask[:, -1], -1)\n                h22 = h22 * np.expand_dims(mask[:, -1], -1)\n\n            last_output_list.append(last_y2)\n            outputs_list.append(y2)\n            state_list.append((h21, h22))\n\n            if i % 2 == 0:\n                assert_allclose(last_y1, last_y2, atol=1e-05)\n                assert_allclose(y1, y2, atol=1e-05)\n                assert_allclose(h11, h21, atol=1e-05)\n                assert_allclose(h12, h22, atol=1e-05)\n            else:\n                assert_allclose(last_output_list[i - 1], last_output_list[i], atol=1e-05)\n                assert_allclose(outputs_list[i - 1], outputs_list[i], atol=1e-05)\n                assert_allclose(state_list[i - 1][0], state_list[i][0], atol=1e-05)\n                assert_allclose(state_list[i - 1][1], state_list[i][1], atol=1e-05)",
        "begin_line": 637,
        "end_line": 711,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.rnn_fn#657",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.rnn_fn(x_k, h_k)",
        "snippet": "        def rnn_fn(x_k, h_k):\n            assert len(h_k) == 2\n            y_k = K.dot(x_k, wi_k) + K.dot(h_k[0], wh_k)\n            return y_k, [y_k, K.concatenate([y_k, y_k], axis=-1)]",
        "begin_line": 657,
        "end_line": 660,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_rnn_no_states#713",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_rnn_no_states(self)",
        "snippet": "    def test_rnn_no_states(self):\n        # implement a simple RNN without states\n        input_dim = 8\n        output_dim = 4\n        timesteps = 5\n\n        _, x = parse_shape_or_val((32, timesteps, input_dim))\n        _, wi = parse_shape_or_val((input_dim, output_dim))\n\n        x_k = K.variable(x)\n        wi_k = K.variable(wi)\n\n        def rnn_fn(x_k, h_k):\n            assert len(h_k) == 0\n            y_k = K.dot(x_k, wi_k)\n            return y_k, []\n\n        last_y1, y1, h1 = KNP.rnn(x, [wi, None, None], None,\n                                  go_backwards=False, mask=None)\n        last_y2, y2, h2 = K.rnn(rnn_fn, x_k, [],\n                                go_backwards=False, mask=None)\n\n        assert len(h2) == 0\n        last_y2 = K.eval(last_y2)\n        y2 = K.eval(y2)\n\n        assert_allclose(last_y1, last_y2, atol=1e-05)\n        assert_allclose(y1, y2, atol=1e-05)",
        "begin_line": 713,
        "end_line": 740,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.rnn_fn#725",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.rnn_fn(x_k, h_k)",
        "snippet": "        def rnn_fn(x_k, h_k):\n            assert len(h_k) == 0\n            y_k = K.dot(x_k, wi_k)\n            return y_k, []",
        "begin_line": 725,
        "end_line": 728,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.legacy_test_rnn#742",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.legacy_test_rnn(self)",
        "snippet": "    def legacy_test_rnn(self):\n        # implement a simple RNN\n        num_samples = 4\n        input_dim = 5\n        output_dim = 3\n        timesteps = 6\n\n        input_val = np.random.random((num_samples, timesteps, input_dim)).astype(np.float32)\n        init_state_val = np.random.random((num_samples, output_dim)).astype(np.float32)\n        W_i_val = np.random.random((input_dim, output_dim)).astype(np.float32)\n        W_o_val = np.random.random((output_dim, output_dim)).astype(np.float32)\n        np_mask = np.random.randint(2, size=(num_samples, timesteps))\n\n        def rnn_step_fn(k):\n            W_i = k.variable(W_i_val)\n            W_o = k.variable(W_o_val)\n\n            def step_function(x, states):\n                assert len(states) == 1\n                prev_output = states[0]\n                output = k.dot(x, W_i) + k.dot(prev_output, W_o)\n                return output, [output]\n\n            return step_function\n\n        # test default setup\n        last_output_list = [[], [], [], [], [], []]\n        outputs_list = [[], [], [], [], [], []]\n        state_list = [[], [], [], [], [], []]\n\n        for k in BACKENDS:\n            rnn_fn = rnn_step_fn(k)\n            inputs = k.variable(input_val)\n            initial_states = [k.variable(init_state_val)]\n            mask = k.variable(np_mask)\n\n            kwargs_list = [\n                {'go_backwards': False, 'mask': None},\n                {'go_backwards': False, 'mask': None, 'unroll': True, 'input_length': timesteps},\n                {'go_backwards': True, 'mask': None},\n                {'go_backwards': True, 'mask': None, 'unroll': True, 'input_length': timesteps},\n                {'go_backwards': False, 'mask': mask},\n                {'go_backwards': False, 'mask': mask, 'unroll': True, 'input_length': timesteps},\n            ]\n\n            for (i, kwargs) in enumerate(kwargs_list):\n                last_output, outputs, new_states = k.rnn(rnn_fn, inputs,\n                                                         initial_states,\n                                                         **kwargs)\n\n                last_output_list[i].append(k.eval(last_output))\n                outputs_list[i].append(k.eval(outputs))\n                assert len(new_states) == 1\n                state_list[i].append(k.eval(new_states[0]))\n\n        assert_list_pairwise(last_output_list[0], shape=False, atol=1e-04)\n        assert_list_pairwise(outputs_list[0], shape=False, atol=1e-04)\n        assert_list_pairwise(state_list[0], shape=False, atol=1e-04)\n        assert_list_pairwise(last_output_list[2], shape=False, atol=1e-04)\n        assert_list_pairwise(outputs_list[2], shape=False, atol=1e-04)\n        assert_list_pairwise(state_list[2], shape=False, atol=1e-04)\n\n        for l, u_l in zip(last_output_list[0], last_output_list[1]):\n            assert_allclose(l, u_l, atol=1e-04)\n\n        for o, u_o in zip(outputs_list[0], outputs_list[1]):\n            assert_allclose(o, u_o, atol=1e-04)\n\n        for s, u_s in zip(state_list[0], state_list[1]):\n            assert_allclose(s, u_s, atol=1e-04)\n\n        for b_l, b_u_l in zip(last_output_list[2], last_output_list[3]):\n            assert_allclose(b_l, b_u_l, atol=1e-04)\n\n        for b_o, b_u_o in zip(outputs_list[2], outputs_list[3]):\n            assert_allclose(b_o, b_u_o, atol=1e-04)\n\n        for b_s, b_u_s in zip(state_list[2], state_list[3]):\n            assert_allclose(b_s, b_u_s, atol=1e-04)\n\n        for m_l, u_m_l, k in zip(last_output_list[4], last_output_list[5], BACKENDS):\n            if k == KTF:\n                m_l = m_l * np.expand_dims(np_mask[:, -1], -1)\n                u_m_l = u_m_l * np.expand_dims(np_mask[:, -1], -1)\n            assert_allclose(m_l, u_m_l, atol=1e-04)\n\n        for m_o, u_m_o, k in zip(outputs_list[4], outputs_list[5], BACKENDS):\n            if k == KTF:\n                m_o = m_o * np.expand_dims(np_mask, -1)\n                u_m_o = u_m_o * np.expand_dims(np_mask, -1)\n            assert_allclose(m_o, u_m_o, atol=1e-04)\n\n        for m_s, u_m_s, k in zip(state_list[4], state_list[5], BACKENDS):\n            assert_allclose(m_s, u_m_s, atol=1e-04)",
        "begin_line": 742,
        "end_line": 835,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.rnn_step_fn#755",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.rnn_step_fn(k)",
        "snippet": "        def rnn_step_fn(k):\n            W_i = k.variable(W_i_val)\n            W_o = k.variable(W_o_val)\n\n            def step_function(x, states):\n                assert len(states) == 1\n                prev_output = states[0]\n                output = k.dot(x, W_i) + k.dot(prev_output, W_o)\n                return output, [output]\n\n            return step_function",
        "begin_line": 755,
        "end_line": 765,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.step_function#759",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.step_function(x, states)",
        "snippet": "            def step_function(x, states):\n                assert len(states) == 1\n                prev_output = states[0]\n                output = k.dot(x, W_i) + k.dot(prev_output, W_o)\n                return output, [output]",
        "begin_line": 759,
        "end_line": 763,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.legacy_test_rnn_no_states#837",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.legacy_test_rnn_no_states(self)",
        "snippet": "    def legacy_test_rnn_no_states(self):\n        # implement a simple RNN without states\n        input_dim = 8\n        output_dim = 4\n        timesteps = 5\n\n        input_val = np.random.random((32, timesteps, input_dim))\n        W_i_val = np.random.random((input_dim, output_dim))\n\n        def rnn_step_fn(k):\n            W_i = k.variable(W_i_val)\n\n            def step_function(x, states):\n                assert len(states) == 0\n                output = k.dot(x, W_i)\n                return output, []\n\n            return step_function\n\n        # test default setup\n        last_output_list = []\n        outputs_list = []\n\n        for k in BACKENDS:\n            rnn_fn = rnn_step_fn(k)\n            inputs = k.variable(input_val)\n            initial_states = []\n            last_output, outputs, new_states = k.rnn(rnn_fn, inputs,\n                                                     initial_states,\n                                                     go_backwards=False,\n                                                     mask=None)\n            last_output_list.append(k.eval(last_output))\n            outputs_list.append(k.eval(outputs))\n            assert len(new_states) == 0\n\n        assert_list_pairwise(last_output_list, shape=False)\n        assert_list_pairwise(outputs_list, shape=False)",
        "begin_line": 837,
        "end_line": 873,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.rnn_step_fn#846",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.rnn_step_fn(k)",
        "snippet": "        def rnn_step_fn(k):\n            W_i = k.variable(W_i_val)\n\n            def step_function(x, states):\n                assert len(states) == 0\n                output = k.dot(x, W_i)\n                return output, []\n\n            return step_function",
        "begin_line": 846,
        "end_line": 854,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.step_function#849",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.step_function(x, states)",
        "snippet": "            def step_function(x, states):\n                assert len(states) == 0\n                output = k.dot(x, W_i)\n                return output, []",
        "begin_line": 849,
        "end_line": 852,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_logsumexp#890",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_logsumexp(self, x_np, axis, keepdims)",
        "snippet": "    def test_logsumexp(self, x_np, axis, keepdims):\n        '''\n        Check if K.logsumexp works properly for values close to one.\n        '''\n        x = K.variable(x_np)\n        assert_allclose(K.eval(K.logsumexp(x, axis=axis, keepdims=keepdims)),\n                        np.log(np.sum(np.exp(x_np), axis=axis, keepdims=keepdims)),\n                        rtol=1e-5)",
        "begin_line": 890,
        "end_line": 897,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_logsumexp_optim#899",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_logsumexp_optim(self)",
        "snippet": "    def test_logsumexp_optim(self):\n        '''\n        Check if optimization works.\n        '''\n        for k in [KTF]:\n            x_np = np.array([1e+4, 1e-4])\n            assert_allclose(k.eval(k.logsumexp(k.variable(x_np), axis=0)),\n                            1e4,\n                            rtol=1e-5)",
        "begin_line": 899,
        "end_line": 907,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_switch#909",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_switch(self)",
        "snippet": "    def test_switch(self):\n        # scalar\n        val = np.random.random()\n        z_list = []\n        for k in WITH_NP:\n            x = k.variable(val)\n            x = k.switch(k.greater_equal(x, 0.5), x * 0.1, x * 0.2)\n            z_list.append(k.eval(x))\n        assert_list_pairwise(z_list)\n        # non scalar\n        shapes = []\n        shapes.append([(4, 3, 2), (4, 3, 2), (4, 3, 2)])\n        shapes.append([(4, 3,), (4, 3, 2), (4, 3, 2)])\n        shapes.append([(4,), (4, 3, 2), (4, 3, 2)])\n        for s in shapes:\n            z_list = []\n            arrays = list(map(np.random.random, s))\n            for k in WITH_NP:\n                x, then_expr, else_expr = map(k.variable, arrays)\n                cond = k.greater_equal(x, 0.5)\n                z_list.append(k.eval(k.switch(cond, then_expr, else_expr)))\n            assert_list_pairwise(z_list)",
        "begin_line": 909,
        "end_line": 930,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_dropout#932",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_dropout(self)",
        "snippet": "    def test_dropout(self):\n        val = np.random.random((100, 100))\n        z_list = [k.eval(k.dropout(k.variable(val), level=0.2))\n                  for k in BACKENDS]\n        assert_list_pairwise(z_list, allclose=False)\n        # dropout patterns are different, only check mean\n        for i in range(len(z_list) - 1):\n            assert np.abs(z_list[i].mean() - z_list[i + 1].mean()) < 0.05\n\n        z_list = [k.eval(k.dropout(k.variable(val), level=0.2,\n                                   noise_shape=list(val.shape)))\n                  for k in BACKENDS]\n        assert_list_pairwise(z_list, allclose=False)\n        # dropout patterns are different, only check mean\n        for i in range(len(z_list) - 1):\n            assert np.abs(z_list[i].mean() - z_list[i + 1].mean()) < 0.05\n\n        # Test invalid use cases\n        with pytest.raises(ValueError):\n            z = K.dropout(K.variable(val), level=-0.5)",
        "begin_line": 932,
        "end_line": 951,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_nn_operations#953",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_nn_operations(self)",
        "snippet": "    def test_nn_operations(self):\n        check_single_tensor_operation('relu', (4, 2), WITH_NP, alpha=0.1, max_value=0.5)\n        check_single_tensor_operation('softplus', (4, 10), WITH_NP)\n        check_single_tensor_operation('elu', (4, 10), WITH_NP, alpha=0.5)\n\n        check_single_tensor_operation('sigmoid', (4, 2), WITH_NP)\n        check_single_tensor_operation('hard_sigmoid', (4, 2), WITH_NP)\n        check_single_tensor_operation('tanh', (4, 2), WITH_NP)\n\n        check_single_tensor_operation('softmax', (4, 10), WITH_NP)\n        check_single_tensor_operation('softmax', (4, 5, 3, 10), WITH_NP, axis=2)\n\n        check_two_tensor_operation('binary_crossentropy', (4, 2), (4, 2), WITH_NP, from_logits=True)\n        # cross_entropy call require the label is a valid probability distribution,\n        # otherwise it is garbage in garbage out...\n        # due to the algo difference, we can't guarantee CNTK has the same result on the garbage input.\n        # so create a separate test case for valid label input\n        if K.backend() != 'cntk':\n            check_two_tensor_operation('categorical_crossentropy', (4, 2), (4, 2), WITH_NP, from_logits=True)\n        xval = np.asarray([[0.26157712, 0.0432167], [-0.43380741, 0.30559841],\n                           [0.20225059, -0.38956559], [-0.13805378, 0.08506755]], dtype=np.float32)\n        yval = np.asarray([[0.46221867, 0.53778133], [0.51228984, 0.48771016],\n                           [0.64916514, 0.35083486], [0.47028078, 0.52971922]], dtype=np.float32)\n        check_two_tensor_operation('categorical_crossentropy', yval, xval,\n                                   WITH_NP, cntk_two_dynamicity=True, from_logits=True)\n        check_two_tensor_operation('binary_crossentropy', (4, 2), (4, 2), WITH_NP, from_logits=False)\n        check_two_tensor_operation('categorical_crossentropy', (4, 2), (4, 2), WITH_NP, from_logits=False)\n\n        check_single_tensor_operation('l2_normalize', (4, 3), WITH_NP, axis=-1)\n        check_single_tensor_operation('l2_normalize', (4, 3), WITH_NP, axis=1)",
        "begin_line": 953,
        "end_line": 982,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_in_top_k#984",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_in_top_k(self)",
        "snippet": "    def test_in_top_k(self):\n        batch_size = 20\n        num_classes = 10\n\n        # Random prediction test case\n        predictions = np.random.random((batch_size, num_classes)).astype('float32')\n        targets = np.random.randint(num_classes, size=batch_size, dtype='int32')\n\n        # (k == 0 or k > num_classes) does not raise an error but just return an unmeaningful tensor.\n        for k in range(num_classes + 1):\n            z_list = [b.eval(b.in_top_k(b.variable(predictions, dtype='float32'),\n                                        b.variable(targets, dtype='int32'), k))\n                      for b in [KTH, KTF]]\n            assert_list_pairwise(z_list)\n\n        # Identical prediction test case:\n        # randomly set half of the predictions to an identical value\n        num_identical = num_classes // 2\n        for i in range(batch_size):\n            idx_identical = np.random.choice(num_classes, size=num_identical, replace=False)\n            predictions[i, idx_identical] = predictions[i, 0]\n        targets = np.zeros(batch_size, dtype='int32')\n\n        for k in range(1, num_classes + 1):\n            z_list = [b.eval(b.in_top_k(b.variable(predictions, dtype='float32'),\n                                        b.variable(targets, dtype='int32'), k))\n                      for b in [KTH, KTF]]\n            assert_list_pairwise(z_list)",
        "begin_line": 984,
        "end_line": 1011,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_conv#1025",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_conv(self, op, input_shape, kernel_shape, padding, data_format)",
        "snippet": "    def test_conv(self, op, input_shape, kernel_shape, padding, data_format):\n        check_two_tensor_operation(\n            op, input_shape, kernel_shape, WITH_NP,\n            padding=padding, data_format=data_format,\n            cntk_dynamicity=True)",
        "begin_line": 1025,
        "end_line": 1029,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_depthwise_conv#1037",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_depthwise_conv(self, op, input_shape, kernel_shape, padding, data_format)",
        "snippet": "    def test_depthwise_conv(self, op, input_shape, kernel_shape, padding, data_format):\n        check_two_tensor_operation(\n            op, input_shape, kernel_shape, WITH_NP,\n            padding=padding, data_format=data_format,\n            cntk_dynamicity=True)",
        "begin_line": 1037,
        "end_line": 1041,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_pool#1053",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_pool(self, op, input_shape, pool_size, strides, padding, data_format, pool_mode)",
        "snippet": "    def test_pool(self, op, input_shape, pool_size, strides, padding, data_format, pool_mode):\n        check_single_tensor_operation(\n            op, input_shape, WITH_NP,\n            pool_size=pool_size, strides=strides,\n            padding=padding, data_format=data_format, pool_mode=pool_mode,\n            cntk_dynamicity=True)",
        "begin_line": 1053,
        "end_line": 1058,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.legacy_test_conv1d#1060",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.legacy_test_conv1d(self)",
        "snippet": "    def legacy_test_conv1d(self):\n        # channels_last input shape: (n, length, input_depth)\n        input_shape = (4, 8, 2)\n        kernel_shape = (3, 2, 3)\n        for strides in [1, 2]:\n            check_two_tensor_operation('conv1d', input_shape, kernel_shape,\n                                       BACKENDS, cntk_dynamicity=True,\n                                       strides=strides,\n                                       data_format='channels_last')",
        "begin_line": 1060,
        "end_line": 1068,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.legacy_test_conv2d#1070",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.legacy_test_conv2d(self)",
        "snippet": "    def legacy_test_conv2d(self):\n        # TF kernel shape: (rows, cols, input_depth, depth)\n        # channels_first input shape: (n, input_depth, rows, cols)\n        for (input_shape, kernel_shape, data_format) in [\n                ((2, 3, 4, 5), (2, 2, 3, 4), 'channels_first'),\n                ((2, 3, 5, 6), (4, 3, 3, 4), 'channels_first'),\n                ((1, 6, 5, 3), (3, 3, 3, 2), 'channels_last')]:\n            check_two_tensor_operation('conv2d', input_shape, kernel_shape,\n                                       BACKENDS, cntk_dynamicity=True,\n                                       data_format=data_format)",
        "begin_line": 1070,
        "end_line": 1079,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.legacy_test_depthwise_conv_2d#1081",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.legacy_test_depthwise_conv_2d(self)",
        "snippet": "    def legacy_test_depthwise_conv_2d(self):\n        # TF kernel shape: (rows, cols, input_depth, depth_multiplier)\n        # channels_first input shape: (n, input_depth, rows, cols)\n        for (input_shape, kernel_shape, data_format) in [\n                ((2, 3, 4, 5), (2, 2, 3, 4), 'channels_first'),\n                ((2, 3, 5, 6), (4, 3, 3, 4), 'channels_first'),\n                ((1, 6, 5, 3), (3, 3, 3, 2), 'channels_last')]:\n            check_two_tensor_operation('depthwise_conv2d',\n                                       input_shape, kernel_shape,\n                                       BACKENDS, cntk_dynamicity=True,\n                                       data_format=data_format)",
        "begin_line": 1081,
        "end_line": 1091,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.legacy_test_conv3d#1093",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.legacy_test_conv3d(self)",
        "snippet": "    def legacy_test_conv3d(self):\n        # TH input shape: (samples, input_depth, conv_dim1, conv_dim2, conv_dim3)\n        # TF input shape: (samples, conv_dim1, conv_dim2, conv_dim3, input_depth)\n        # TH kernel shape: (depth, input_depth, x, y, z)\n        # TF kernel shape: (x, y, z, input_depth, depth)\n        for (input_shape, kernel_shape, data_format) in [\n                ((2, 3, 4, 5, 4), (2, 2, 2, 3, 4), 'channels_first'),\n                ((2, 3, 5, 4, 6), (3, 2, 4, 3, 4), 'channels_first'),\n                ((1, 2, 2, 2, 1), (2, 2, 2, 1, 1), 'channels_last')]:\n            check_two_tensor_operation('conv3d', input_shape, kernel_shape,\n                                       BACKENDS, cntk_dynamicity=True,\n                                       data_format=data_format)",
        "begin_line": 1093,
        "end_line": 1104,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_separable_conv#1114",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_separable_conv(self, op, input_shape, kernel_shape, depth_multiplier, padding, data_format)",
        "snippet": "    def test_separable_conv(self, op, input_shape, kernel_shape, depth_multiplier, padding, data_format):\n        input_depth = input_shape[1] if data_format == 'channels_first' else input_shape[-1]\n        _, x = parse_shape_or_val(input_shape)\n        _, depthwise = parse_shape_or_val(kernel_shape + (input_depth, depth_multiplier))\n        _, pointwise = parse_shape_or_val((1,) * len(kernel_shape) + (input_depth * depth_multiplier, 7))\n        y1 = KNP.separable_conv(x, depthwise, pointwise,\n                                padding=padding, data_format=data_format)\n        if K.backend() == 'cntk':\n            y2 = cntk_func_three_tensor(\n                op, input_shape,\n                depthwise, pointwise,\n                padding=padding, data_format=data_format)([x])[0]\n        else:\n            y2 = K.eval(getattr(K, op)(\n                K.variable(x),\n                K.variable(depthwise), K.variable(pointwise),\n                padding=padding, data_format=data_format))\n        assert_allclose(y1, y2, atol=1e-05)",
        "begin_line": 1114,
        "end_line": 1131,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.legacy_test_pool2d#1133",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.legacy_test_pool2d(self)",
        "snippet": "    def legacy_test_pool2d(self):\n        check_single_tensor_operation('pool2d', (5, 10, 12, 3),\n                                      BACKENDS, cntk_dynamicity=True,\n                                      pool_size=(2, 2), strides=(1, 1), padding='valid')\n\n        check_single_tensor_operation('pool2d', (5, 9, 11, 3),\n                                      BACKENDS, cntk_dynamicity=True,\n                                      pool_size=(2, 2), strides=(1, 1), padding='valid')\n\n        check_single_tensor_operation('pool2d', (5, 9, 11, 3),\n                                      BACKENDS, cntk_dynamicity=True,\n                                      pool_size=(2, 2), strides=(1, 1), pool_mode='avg')\n\n        check_single_tensor_operation('pool2d', (5, 9, 11, 3),\n                                      BACKENDS, cntk_dynamicity=True,\n                                      pool_size=(2, 3), strides=(1, 1), padding='valid')\n\n        check_single_tensor_operation('pool2d', (2, 7, 7, 5),\n                                      BACKENDS, cntk_dynamicity=True,\n                                      pool_size=(3, 3), strides=(1, 1),\n                                      padding='same', pool_mode='avg')",
        "begin_line": 1133,
        "end_line": 1153,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.legacy_test_pool3d#1155",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.legacy_test_pool3d(self)",
        "snippet": "    def legacy_test_pool3d(self):\n        check_single_tensor_operation('pool3d', (5, 10, 12, 5, 3),\n                                      BACKENDS, cntk_dynamicity=True,\n                                      pool_size=(2, 2, 2), strides=(1, 1, 1), padding='valid')\n\n        check_single_tensor_operation('pool3d', (5, 9, 11, 5, 3),\n                                      BACKENDS, cntk_dynamicity=True,\n                                      pool_size=(2, 2, 2), strides=(1, 1, 1), padding='valid')\n\n        check_single_tensor_operation('pool3d', (5, 9, 11, 5, 3),\n                                      BACKENDS, cntk_dynamicity=True,\n                                      pool_size=(2, 2, 2), strides=(1, 1, 1), pool_mode='avg')\n\n        check_single_tensor_operation('pool3d', (5, 9, 11, 5, 3),\n                                      BACKENDS, cntk_dynamicity=True,\n                                      pool_size=(2, 3, 2), strides=(1, 1, 1), padding='valid')\n\n        check_single_tensor_operation('pool3d', (2, 6, 6, 6, 3), [KTH, KTF], pool_size=(3, 3, 3),\n                                      strides=(1, 1, 1), padding='same', pool_mode='avg')",
        "begin_line": 1155,
        "end_line": 1173,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_random_normal#1175",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_random_normal(self)",
        "snippet": "    def test_random_normal(self):\n        # test standard normal as well as a normal with a different set of parameters\n        for mean, std in [(0., 1.), (-10., 5.)]:\n            rand = K.eval(K.random_normal((300, 200), mean=mean, stddev=std, seed=1337))\n            assert rand.shape == (300, 200)\n            assert np.abs(np.mean(rand) - mean) < std * 0.015\n            assert np.abs(np.std(rand) - std) < std * 0.015\n\n            # test that random_normal also generates different values when used within a function\n            r = K.random_normal((10, 10), mean=mean, stddev=std, seed=1337)\n            samples = np.array([K.eval(r) for _ in range(200)])\n            assert np.abs(np.mean(samples) - mean) < std * 0.015\n            assert np.abs(np.std(samples) - std) < std * 0.015",
        "begin_line": 1175,
        "end_line": 1187,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_random_uniform#1189",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_random_uniform(self)",
        "snippet": "    def test_random_uniform(self):\n        min_val = -1.\n        max_val = 1.\n        rand = K.eval(K.random_uniform((200, 100), min_val, max_val))\n        assert rand.shape == (200, 100)\n        assert np.abs(np.mean(rand)) < 0.015\n        assert max_val - 0.015 < np.max(rand) <= max_val\n        assert min_val + 0.015 > np.min(rand) >= min_val\n\n        r = K.random_uniform((10, 10), minval=min_val, maxval=max_val)\n        samples = np.array([K.eval(r) for _ in range(200)])\n        assert np.abs(np.mean(samples)) < 0.015\n        assert max_val - 0.015 < np.max(samples) <= max_val\n        assert min_val + 0.015 > np.min(samples) >= min_val",
        "begin_line": 1189,
        "end_line": 1202,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_random_binomial#1204",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_random_binomial(self)",
        "snippet": "    def test_random_binomial(self):\n        p = 0.5\n        rand = K.eval(K.random_binomial((200, 100), p))\n        assert rand.shape == (200, 100)\n        assert np.abs(np.mean(rand) - p) < 0.015\n        assert np.max(rand) == 1\n        assert np.min(rand) == 0\n\n        r = K.random_binomial((10, 10), p)\n        samples = np.array([K.eval(r) for _ in range(200)])\n        assert np.abs(np.mean(samples) - p) < 0.015\n        assert np.max(samples) == 1\n        assert np.min(samples) == 0",
        "begin_line": 1204,
        "end_line": 1216,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_truncated_normal#1218",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_truncated_normal(self)",
        "snippet": "    def test_truncated_normal(self):\n        mean = 0.\n        std = 1.\n        min_val = -2.\n        max_val = 2.\n        rand = K.eval(K.truncated_normal((300, 200), mean=mean, stddev=std, seed=1337))\n        assert rand.shape == (300, 200)\n        assert np.abs(np.mean(rand) - mean) < 0.015\n        assert np.max(rand) <= max_val\n        assert np.min(rand) >= min_val\n\n        # assumption in initializers.VarianceScaling\n        assert np.abs(np.std(rand) - std * 0.87962) < 0.015",
        "begin_line": 1218,
        "end_line": 1230,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_conv_invalid_use#1232",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_conv_invalid_use(self)",
        "snippet": "    def test_conv_invalid_use(self):\n        dummy_x_1d = K.variable(np.ones((4, 8, 2)))\n        dummy_w_1d = K.variable(np.ones((3, 2, 3)))\n        dummy_x_2d = K.variable(np.ones((2, 3, 4, 5)))\n        dummy_w_2d = K.variable(np.ones((2, 2, 3, 4)))\n        dummy_x_3d = K.variable(np.ones((2, 3, 4, 5, 4)))\n        dummy_w_3d = K.variable(np.ones((2, 2, 2, 3, 4)))\n        dummy_w1x1_2d = K.variable(np.ones((1, 1, 12, 7)))\n\n        with pytest.raises(ValueError):\n            K.conv1d(dummy_x_1d, dummy_w_1d, data_format='channels_middle')\n\n        with pytest.raises(ValueError):\n            K.conv2d(dummy_x_2d, dummy_w_2d, data_format='channels_middle')\n\n        with pytest.raises(ValueError):\n            K.conv3d(dummy_x_3d, dummy_w_3d, data_format='channels_middle')\n\n        if K.backend() != 'theano':\n            with pytest.raises(ValueError):\n                K.separable_conv2d(dummy_x_2d, dummy_w_2d, dummy_w1x1_2d,\n                                   data_format='channels_middle')\n\n        with pytest.raises(ValueError):\n            K.depthwise_conv2d(dummy_x_2d, dummy_w_2d,\n                               data_format='channels_middle')\n\n        if K.backend() == 'cntk':\n            with pytest.raises(ValueError):\n                K.separable_conv2d(dummy_x_2d, dummy_w_2d, dummy_w1x1_2d,\n                                   dilation_rate=(1, 2))\n            with pytest.raises(ValueError):\n                K.separable_conv2d(dummy_x_2d, dummy_w_2d, dummy_w1x1_2d,\n                                   strides=(2, 2), dilation_rate=(1, 2))\n            with pytest.raises(ValueError):\n                K.depthwise_conv2d(dummy_x_2d, dummy_w_2d,\n                                   dilation_rate=(1, 2))\n            with pytest.raises(ValueError):\n                K.depthwise_conv2d(dummy_x_2d, dummy_w_2d,\n                                   strides=(2, 2), dilation_rate=(1, 2))",
        "begin_line": 1232,
        "end_line": 1271,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_pooling_invalid_use#1273",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_pooling_invalid_use(self)",
        "snippet": "    def test_pooling_invalid_use(self):\n        for (input_shape, pool_size) in zip([(5, 10, 12, 3), (5, 10, 12, 6, 3)], [(2, 2), (2, 2, 2)]):\n            x = K.variable(np.random.random(input_shape))\n            if len(pool_size) == 2:\n                with pytest.raises(ValueError):\n                    K.pool2d(x, pool_size=pool_size, data_format='channels_middle')\n                with pytest.raises(ValueError):\n                    K.pool2d(x, pool_size=pool_size, padding='twice')\n                with pytest.raises(ValueError):\n                    K.pool2d(x, pool_size=pool_size, pool_mode='median')\n            else:\n                with pytest.raises(ValueError):\n                    K.pool3d(x, pool_size=pool_size, data_format='channels_middle')\n                with pytest.raises(ValueError):\n                    K.pool3d(x, pool_size=pool_size, padding='twice')\n                with pytest.raises(ValueError):\n                    K.pool3d(x, pool_size=pool_size, pool_mode='median')",
        "begin_line": 1273,
        "end_line": 1289,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_resize_images#1291",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_resize_images(self)",
        "snippet": "    def test_resize_images(self):\n        for data_format in ['channels_first', 'channels_last']:\n            shape = (5, 5)\n            if data_format == 'channels_first':\n                x_shape = (2, 3) + shape\n            elif data_format == 'channels_last':\n                x_shape = (2,) + shape + (3,)\n            check_single_tensor_operation('resize_images', x_shape,\n                                          WITH_NP, cntk_dynamicity=True,\n                                          height_factor=2,\n                                          width_factor=2,\n                                          data_format=data_format)\n\n        # Test invalid use cases\n        xval = np.random.random(x_shape)\n        with pytest.raises(ValueError):\n            K.resize_images(K.variable(xval), 2, 2,\n                            data_format='channels_middle')",
        "begin_line": 1291,
        "end_line": 1308,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend._helper_bilinear#1311",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend._helper_bilinear(data_format, height_factor, width_factor)",
        "snippet": "    def _helper_bilinear(data_format, height_factor, width_factor):\n        x_shape = (2, 3, 4, 5)\n        check_single_tensor_operation('resize_images', x_shape,\n                                      [KTF, KTH],\n                                      height_factor=height_factor,\n                                      width_factor=width_factor,\n                                      data_format=data_format,\n                                      interpolation='bilinear')",
        "begin_line": 1311,
        "end_line": 1318,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_resize_images_bilinear#1322",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_resize_images_bilinear(self, data_format)",
        "snippet": "    def test_resize_images_bilinear(self, data_format):\n        self._helper_bilinear(data_format, 2, 2)\n        with pytest.raises(NotImplementedError):\n            self._helper_bilinear(data_format, 4, 4)",
        "begin_line": 1322,
        "end_line": 1325,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_resize_volumes#1327",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_resize_volumes(self)",
        "snippet": "    def test_resize_volumes(self):\n        for data_format in ['channels_first', 'channels_last']:\n            shape = (5, 5, 5)\n            if data_format == 'channels_first':\n                x_shape = (2, 3) + shape\n            elif data_format == 'channels_last':\n                x_shape = (2,) + shape + (3,)\n            check_single_tensor_operation('resize_volumes', x_shape,\n                                          WITH_NP, cntk_dynamicity=True,\n                                          depth_factor=2,\n                                          height_factor=2,\n                                          width_factor=2,\n                                          data_format=data_format)\n\n        # Test invalid use cases\n        xval = np.random.random(x_shape)\n        with pytest.raises(ValueError):\n            K.resize_volumes(K.variable(xval), 2, 2, 2,\n                             data_format='channels_middle')",
        "begin_line": 1327,
        "end_line": 1345,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_temporal_padding#1347",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_temporal_padding(self)",
        "snippet": "    def test_temporal_padding(self):\n        check_single_tensor_operation('temporal_padding', (4, 3, 3),\n                                      BACKENDS)\n        check_single_tensor_operation('temporal_padding', (2, 3, 4),\n                                      BACKENDS, padding=(1, 2))",
        "begin_line": 1347,
        "end_line": 1351,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_spatial_2d_padding#1353",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_spatial_2d_padding(self)",
        "snippet": "    def test_spatial_2d_padding(self):\n        padding = ((1, 2), (2, 1))\n        for data_format in ['channels_first', 'channels_last']:\n            shape = (5, 5)\n            if data_format == 'channels_first':\n                x_shape = (1, 3) + shape\n            else:\n                x_shape = (1,) + shape + (3,)\n            check_single_tensor_operation('spatial_2d_padding', x_shape, BACKENDS,\n                                          padding=padding, data_format=data_format)\n            # Check handling of dynamic shapes.\n            for k in [KTF, KTH]:\n                x = k.placeholder(shape=(1, None, None, 1))\n                y = k.spatial_2d_padding(x, padding=padding, data_format='channels_last')\n                assert k.int_shape(y) == (1, None, None, 1)\n\n        # Test invalid use cases\n        xval = np.random.random(x_shape)\n        with pytest.raises(ValueError):\n            K.spatial_2d_padding(K.variable(xval), padding=padding,\n                                 data_format='channels_middle')",
        "begin_line": 1353,
        "end_line": 1373,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_spatial_3d_padding#1375",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_spatial_3d_padding(self)",
        "snippet": "    def test_spatial_3d_padding(self):\n        padding = ((1, 2), (2, 1), (1, 2))\n        for data_format in ['channels_first', 'channels_last']:\n            shape = (5, 5, 5)\n            if data_format == 'channels_first':\n                x_shape = (1, 3) + shape\n            else:\n                x_shape = (1,) + shape + (3,)\n            check_single_tensor_operation('spatial_3d_padding', x_shape, BACKENDS,\n                                          padding=padding, data_format=data_format)\n            # Check handling of dynamic shapes.\n            for k in [KTF, KTH]:\n                x = k.placeholder(shape=(1, None, None, None, 1))\n                y = k.spatial_3d_padding(x, padding=padding, data_format='channels_last')\n                assert k.int_shape(y) == (1, None, None, None, 1)\n\n        # Test invalid use cases\n        xval = np.random.random(x_shape)\n        with pytest.raises(ValueError):\n            K.spatial_3d_padding(K.variable(xval), padding=padding,\n                                 data_format='channels_middle')",
        "begin_line": 1375,
        "end_line": 1395,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_bias_add#1397",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_bias_add(self)",
        "snippet": "    def test_bias_add(self):\n        for data_format in ['channels_first', 'channels_last']:\n            for shape in [(), (3,), (2, 3), (5, 3, 2)]:\n                if data_format == 'channels_first':\n                    x_shape = (1, 4) + shape\n                else:\n                    x_shape = (1,) + shape + (4,)\n                bias_shape = (4,)\n                check_two_tensor_operation('bias_add', x_shape, bias_shape,\n                                           WITH_NP, cntk_dynamicity=True,\n                                           data_format=data_format)\n\n            if data_format == 'channels_first':\n                x_shape = (20, 6, 10)\n            else:\n                x_shape = (20, 10, 6)\n            check_two_tensor_operation('bias_add', x_shape, (10, 6),\n                                       WITH_NP, cntk_dynamicity=True,\n                                       data_format=data_format)\n\n        # Test invalid use cases\n        x = K.variable(np.random.random(x_shape))\n        b = K.variable(np.random.random(bias_shape))\n        with pytest.raises(ValueError):\n            K.bias_add(x, b, data_format='channels_middle')",
        "begin_line": 1397,
        "end_line": 1421,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_batchnorm#1423",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_batchnorm(self)",
        "snippet": "    def test_batchnorm(self):\n        shape = (2, 3)\n        for data_format in ['channels_first', 'channels_last']:\n            if data_format == 'channels_first':\n                x_shape = (1, 4) + shape\n            else:\n                x_shape = (1,) + shape + (4,)\n            x_val = np.random.random(x_shape).astype(np.float32)\n            xth = KTH.variable(x_val)\n            xtf = KTF.variable(x_val)\n            xc = KC.placeholder(x_shape)\n            zth, _, _ = KTH.normalize_batch_in_training(xth, None, None,\n                                                        reduction_axes='per-activation')\n            ztf, _, _ = KTF.normalize_batch_in_training(xtf, None, None,\n                                                        reduction_axes=[0, 1, 2, 3])\n            zc, _, _ = KC.normalize_batch_in_training(xc, None, None,\n                                                      reduction_axes=[0, 1, 2, 3])\n            zth = KTH.eval(zth)\n            ztf = KTF.eval(ztf)\n            zc = KC.function([xc], [zc])([x_val])[0]\n            assert zth.shape == ztf.shape\n            assert zth.shape == zc.shape",
        "begin_line": 1423,
        "end_line": 1444,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_ctc#1451",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_ctc(self)",
        "snippet": "    def test_ctc(self):\n        if K.backend() == 'theano':\n            ref = [1.73308, 3.81351]\n        else:\n            ref = [3.34211, 5.42262]\n        # simplified version of TensorFlow's test\n\n        label_lens = np.expand_dims(np.asarray([5, 4]), 1)\n        input_lens = np.expand_dims(np.asarray([5, 5]), 1)  # number of timesteps\n\n        # dimensions are batch x time x categories\n        labels = np.asarray([[0, 1, 2, 1, 0], [0, 1, 1, 0, -1]])\n        inputs = np.asarray(\n            [[[0.633766, 0.221185, 0.0917319, 0.0129757, 0.0142857, 0.0260553],\n              [0.111121, 0.588392, 0.278779, 0.0055756, 0.00569609, 0.010436],\n              [0.0357786, 0.633813, 0.321418, 0.00249248, 0.00272882, 0.0037688],\n              [0.0663296, 0.643849, 0.280111, 0.00283995, 0.0035545, 0.00331533],\n              [0.458235, 0.396634, 0.123377, 0.00648837, 0.00903441, 0.00623107]],\n             [[0.30176, 0.28562, 0.0831517, 0.0862751, 0.0816851, 0.161508],\n              [0.24082, 0.397533, 0.0557226, 0.0546814, 0.0557528, 0.19549],\n              [0.230246, 0.450868, 0.0389607, 0.038309, 0.0391602, 0.202456],\n              [0.280884, 0.429522, 0.0326593, 0.0339046, 0.0326856, 0.190345],\n              [0.423286, 0.315517, 0.0338439, 0.0393744, 0.0339315, 0.154046]]],\n            dtype=np.float32)\n\n        k_labels = K.variable(labels, dtype=\"int32\")\n        k_inputs = K.variable(inputs, dtype=\"float32\")\n        k_input_lens = K.variable(input_lens, dtype=\"int32\")\n        k_label_lens = K.variable(label_lens, dtype=\"int32\")\n        res = K.eval(K.ctc_batch_cost(k_labels, k_inputs, k_input_lens, k_label_lens))\n        assert_allclose(res[0, :] if K.backend() == 'theano' else res[:, 0], ref, atol=1e-05)\n\n        # test when batch_size = 1, that is, one sample only\n        # get only first sample from above test case\n        if K.backend() == 'theano':\n            ref = [1.73308]\n        else:\n            ref = [3.34211]\n\n        input_lens = np.expand_dims(np.asarray([5]), 1)\n        label_lens = np.expand_dims(np.asarray([5]), 1)\n\n        labels = np.asarray([[0, 1, 2, 1, 0]])\n        inputs = np.asarray(\n            [[[0.633766, 0.221185, 0.0917319, 0.0129757, 0.0142857, 0.0260553],\n              [0.111121, 0.588392, 0.278779, 0.0055756, 0.00569609, 0.010436],\n              [0.0357786, 0.633813, 0.321418, 0.00249248, 0.00272882, 0.0037688],\n              [0.0663296, 0.643849, 0.280111, 0.00283995, 0.0035545, 0.00331533],\n              [0.458235, 0.396634, 0.123377, 0.00648837, 0.00903441, 0.00623107]]],\n            dtype=np.float32)\n\n        k_labels = K.variable(labels, dtype=\"int32\")\n        k_inputs = K.variable(inputs, dtype=\"float32\")\n        k_input_lens = K.variable(input_lens, dtype=\"int32\")\n        k_label_lens = K.variable(label_lens, dtype=\"int32\")\n        res = K.eval(K.ctc_batch_cost(k_labels, k_inputs, k_input_lens, k_label_lens))\n        assert_allclose(res[0, :] if K.backend() == 'theano' else res[:, 0], ref, atol=1e-05)",
        "begin_line": 1451,
        "end_line": 1507,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_ctc_decode_greedy#1511",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_ctc_decode_greedy(self)",
        "snippet": "    def test_ctc_decode_greedy(self):\n        \"\"\"Test two batch entries - best path decoder.\"\"\"\n        max_time_steps = 6\n\n        seq_len_0 = 4\n        input_prob_matrix_0 = np.asarray(\n            [[1.0, 0.0, 0.0, 0.0],  # t=0\n             [0.0, 0.0, 0.4, 0.6],  # t=1\n             [0.0, 0.0, 0.4, 0.6],  # t=2\n             [0.0, 0.9, 0.1, 0.0],  # t=3\n             [0.0, 0.0, 0.0, 0.0],  # t=4 (ignored)\n             [0.0, 0.0, 0.0, 0.0]],  # t=5 (ignored)\n            dtype=np.float32)\n        input_log_prob_matrix_0 = np.log(input_prob_matrix_0)\n\n        seq_len_1 = 5\n        # dimensions are time x depth\n\n        input_prob_matrix_1 = np.asarray(\n            [[0.1, 0.9, 0.0, 0.0],  # t=0\n             [0.0, 0.9, 0.1, 0.0],  # t=1\n             [0.0, 0.0, 0.1, 0.9],  # t=2\n             [0.0, 0.9, 0.1, 0.1],  # t=3\n             [0.9, 0.1, 0.0, 0.0],  # t=4\n             [0.0, 0.0, 0.0, 0.0]],  # t=5 (ignored)\n            dtype=np.float32)\n\n        # len max_time_steps array of batch_size x depth matrices\n        inputs = [np.vstack([input_prob_matrix_0[t, :],\n                             input_prob_matrix_1[t, :]])\n                  for t in range(max_time_steps)]\n\n        # change tensorflow order to keras backend order\n        inputs = K.variable(np.asarray(inputs).transpose((1, 0, 2)))\n        # batch_size length vector of sequence_lengths\n        input_length = K.variable(np.array([seq_len_0, seq_len_1], dtype=np.int32))\n\n        # batch_size length vector of negative log probabilities\n        log_prob_truth = np.array([\n            np.sum(-np.log([1.0, 0.6, 0.6, 0.9])),\n            np.sum(-np.log([0.9, 0.9, 0.9, 0.9, 0.9]))\n        ], np.float32)[:, np.newaxis]\n\n        # keras output, unlike tensorflow, is a dense (not sparse) tensor\n        decode_truth = np.array([[0, 1, -1], [1, 1, 0]])\n\n        decode_pred_tf, log_prob_pred_tf = K.ctc_decode(inputs,\n                                                        input_length,\n                                                        greedy=True)\n\n        assert len(decode_pred_tf) == 1\n\n        decode_pred = K.eval(decode_pred_tf[0])\n        log_prob_pred = K.eval(log_prob_pred_tf)\n\n        assert np.alltrue(decode_truth == decode_pred)\n        assert np.allclose(log_prob_truth, log_prob_pred)",
        "begin_line": 1511,
        "end_line": 1567,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_ctc_decode_beam_search#1572",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_ctc_decode_beam_search(self)",
        "snippet": "    def test_ctc_decode_beam_search(self):\n        \"\"\"Test one batch, two beams - hibernating beam search.\"\"\"\n\n        depth = 6\n\n        seq_len_0 = 5\n        input_prob_matrix_0 = np.asarray(\n            [[0.30999, 0.309938, 0.0679938, 0.0673362, 0.0708352, 0.173908],\n             [0.215136, 0.439699, 0.0370931, 0.0393967, 0.0381581, 0.230517],\n             [0.199959, 0.489485, 0.0233221, 0.0251417, 0.0233289, 0.238763],\n             [0.279611, 0.452966, 0.0204795, 0.0209126, 0.0194803, 0.20655],\n             [0.51286, 0.288951, 0.0243026, 0.0220788, 0.0219297, 0.129878],\n             # Random entry added in at time=5\n             [0.155251, 0.164444, 0.173517, 0.176138, 0.169979, 0.160671]],\n            dtype=np.float32)\n\n        # len max_time_steps array of batch_size x depth matrices\n        inputs = ([input_prob_matrix_0[t, :][np.newaxis, :]\n                   for t in range(seq_len_0)] +  # Pad to max_time_steps = 8\n                  2 * [np.zeros((1, depth), dtype=np.float32)])\n\n        inputs = K.variable(np.asarray(inputs).transpose((1, 0, 2)))\n\n        # batch_size length vector of sequence_lengths\n        input_length = K.variable(np.array([seq_len_0], dtype=np.int32))\n        # batch_size length vector of negative log probabilities\n        log_prob_truth = np.array([\n            0.584855,  # output beam 0\n            0.389139  # output beam 1\n        ], np.float32)[np.newaxis, :]\n\n        decode_truth = [np.array([1, 0]), np.array([0, 1, 0])]\n\n        beam_width = 2\n        top_paths = 2\n\n        decode_pred_tf, log_prob_pred_tf = K.ctc_decode(inputs,\n                                                        input_length,\n                                                        greedy=False,\n                                                        beam_width=beam_width,\n                                                        top_paths=top_paths)\n\n        assert len(decode_pred_tf) == top_paths\n\n        log_prob_pred = K.eval(log_prob_pred_tf)\n\n        for i in range(top_paths):\n            assert np.alltrue(decode_truth[i] == K.eval(decode_pred_tf[i]))\n\n        assert np.allclose(log_prob_truth, log_prob_pred)",
        "begin_line": 1572,
        "end_line": 1621,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_one_hot#1623",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_one_hot(self)",
        "snippet": "    def test_one_hot(self):\n        input_length = 10\n        num_classes = 20\n        batch_size = 30\n        indices = np.random.randint(0, num_classes, size=(batch_size, input_length))\n        oh = np.eye(num_classes)[indices]\n        koh = K.eval(K.one_hot(K.variable(indices, dtype='int32'), num_classes))\n        assert np.all(koh == oh)",
        "begin_line": 1623,
        "end_line": 1630,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_sparse_dot#1634",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_sparse_dot(self)",
        "snippet": "    def test_sparse_dot(self):\n        x_d = np.array([0, 7, 2, 3], dtype=np.float32)\n        x_r = np.array([0, 2, 2, 3], dtype=np.int64)\n        x_c = np.array([4, 3, 2, 3], dtype=np.int64)\n\n        x_sparse = sparse.csr_matrix((x_d, (x_r, x_c)), shape=(4, 5))\n        x_dense = x_sparse.toarray()\n\n        W = np.random.random((5, 4))\n        # cntk not support it yet\n        backends = [KTF]\n        if KTH.th_sparse_module:\n            # Theano has some dependency issues for sparse\n            backends.append(KTH)\n\n        for k in backends:\n            t_W = k.variable(W)\n            k_s = k.eval(k.dot(k.variable(x_sparse), t_W))\n            k_d = k.eval(k.dot(k.variable(x_dense), t_W))\n\n            assert k_s.shape == k_d.shape\n            assert_allclose(k_s, k_d, atol=1e-05)",
        "begin_line": 1634,
        "end_line": 1655,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_sparse_concat#1657",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_sparse_concat(self)",
        "snippet": "    def test_sparse_concat(self):\n        x_d = np.array([0, 7, 2, 3], dtype=np.float32)\n        x_r = np.array([0, 2, 2, 3], dtype=np.int64)\n        x_c = np.array([4, 3, 2, 3], dtype=np.int64)\n\n        x_sparse_1 = sparse.csr_matrix((x_d, (x_r, x_c)), shape=(4, 5))\n\n        x_d = np.array([0, 7, 2, 3], dtype=np.float32)\n        x_r = np.array([0, 2, 2, 3], dtype=np.int64)\n        x_c = np.array([4, 3, 2, 3], dtype=np.int64)\n\n        x_sparse_2 = sparse.csr_matrix((x_d, (x_r, x_c)), shape=(4, 5))\n\n        x_dense_1 = x_sparse_1.toarray()\n        x_dense_2 = x_sparse_2.toarray()\n\n        # cntk not support it yet\n        backends = [KTF]\n        if KTH.th_sparse_module:\n            # Theano has some dependency issues for sparse\n            backends.append(KTH)\n\n        for k in backends:\n            k_s = k.concatenate([k.variable(x_sparse_1), k.variable(x_sparse_2)])\n            assert k.is_sparse(k_s)\n\n            k_s_d = k.eval(k_s)\n\n            k_d = k.eval(k.concatenate([k.variable(x_dense_1), k.variable(x_dense_2)]))\n\n            assert k_s_d.shape == k_d.shape\n            assert_allclose(k_s_d, k_d, atol=1e-05)",
        "begin_line": 1657,
        "end_line": 1688,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_map#1691",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_map(self)",
        "snippet": "    def test_map(self):\n        x = np.random.rand(10, 3).astype(np.float32)\n        vx = K.variable(x)\n        kx = K.eval(K.map_fn(K.sum, vx))\n        # make sure we can also walk the indexes in tensorflow which we\n        # can't without specifying dtype\n        kx2 = K.eval(K.map_fn(\n            lambda i: K.sum(vx[i]),\n            K.arange(10),\n            dtype=K.floatx()\n        ))\n\n        assert (10,) == kx.shape\n        assert (10,) == kx2.shape\n        assert_allclose(x.sum(axis=1), kx, atol=1e-05)\n        assert_allclose(kx, kx2, atol=1e-05)",
        "begin_line": 1691,
        "end_line": 1706,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_foldl#1709",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_foldl(self)",
        "snippet": "    def test_foldl(self):\n        x = np.random.rand(10, 3).astype(np.float32)\n        kx = K.eval(K.foldl(lambda a, b: a + b, K.variable(x)))\n\n        assert (3,) == kx.shape\n        assert_allclose(x.sum(axis=0), kx, atol=1e-05)",
        "begin_line": 1709,
        "end_line": 1714,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_foldr#1717",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_foldr(self)",
        "snippet": "    def test_foldr(self):\n        # This test aims to make sure that we walk the array from right to left\n        # and checks it in the following way: multiplying left to right 1e-40\n        # cannot be held into a float32 so it causes an underflow while from\n        # right to left we have no such problem and the result is larger\n        x = np.array([1e-20, 1e-20, 10, 10, 10], dtype=np.float32)\n        vx = K.variable(x)\n        p1 = K.eval(K.foldl(lambda a, b: a * b, vx))\n        p2 = K.eval(K.foldr(lambda a, b: a * b, vx))\n\n        assert p1 < p2\n        assert 9e-38 < p2 <= 1e-37",
        "begin_line": 1717,
        "end_line": 1728,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_arange#1732",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_arange(self)",
        "snippet": "    def test_arange(self):\n        for test_value in (-20, 0, 1, 10):\n            a_list = []\n            dtype_list = []\n            for k in WITH_NP:\n                t = k.arange(test_value)\n                a = k.eval(t)\n                assert np.array_equal(a, np.arange(test_value))\n                dtype_list.append(k.dtype(t))\n                a_list.append(a)\n\n            for i in range(len(a_list) - 1):\n                assert np.array_equal(a_list[i], a_list[i + 1])\n\n        for start, stop, step in ((0, 5, 1), (-5, 5, 2), (0, 1, 2)):\n            a_list = []\n            for k in WITH_NP:\n                a = k.eval(k.arange(start, stop, step))\n                assert np.array_equal(a, np.arange(start, stop, step))\n                a_list.append(a)\n            for i in range(len(a_list) - 1):\n                assert np.array_equal(a_list[i], a_list[i + 1])\n\n        for dtype in ('int32', 'int64', 'float32', 'float64'):\n            for k in WITH_NP:\n                t = k.arange(10, dtype=dtype)\n                assert k.dtype(t) == dtype\n\n        for k in WITH_NP:\n            start = k.constant(1, dtype='int32')\n            t = k.arange(start)\n            assert len(k.eval(t)) == 1\n\n            start = k.constant(-1, dtype='int32')\n            t = k.arange(start)\n            assert len(k.eval(t)) == 0",
        "begin_line": 1732,
        "end_line": 1767,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_in_train_phase#1770",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_in_train_phase(self, training)",
        "snippet": "    def test_in_train_phase(self, training):\n        check_two_tensor_operation('in_train_phase', (3, 3), (2, 2), WITH_NP,\n                                   training=training)\n        check_two_tensor_operation('in_train_phase', (2, 3), (2, 3), WITH_NP,\n                                   training=training)",
        "begin_line": 1770,
        "end_line": 1774,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_in_test_phase#1777",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_in_test_phase(self, training)",
        "snippet": "    def test_in_test_phase(self, training):\n        check_two_tensor_operation('in_test_phase', (3, 3), (2, 2), WITH_NP,\n                                   training=training)\n        check_two_tensor_operation('in_test_phase', (2, 3), (2, 3), WITH_NP,\n                                   training=training)",
        "begin_line": 1777,
        "end_line": 1781,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_setfloatx_incorrect_values#1783",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_setfloatx_incorrect_values(self)",
        "snippet": "    def test_setfloatx_incorrect_values(self):\n        # Keep track of the old value\n        old_floatx = floatx()\n        # Try some incorrect values\n        initial = floatx()\n        for value in ['', 'beerfloat', 123]:\n            with pytest.raises(ValueError):\n                set_floatx(value)\n        assert floatx() == initial\n        # Restore old value\n        set_floatx(old_floatx)",
        "begin_line": 1783,
        "end_line": 1793,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_setfloatx_correct_values#1795",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_setfloatx_correct_values(self)",
        "snippet": "    def test_setfloatx_correct_values(self):\n        # Keep track of the old value\n        old_floatx = floatx()\n        # Check correct values\n        for value in ['float16', 'float32', 'float64']:\n            set_floatx(value)\n            assert floatx() == value\n        # Restore old value\n        set_floatx(old_floatx)",
        "begin_line": 1795,
        "end_line": 1803,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_set_floatx#1807",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_set_floatx(self)",
        "snippet": "    def test_set_floatx(self):\n        \"\"\"\n        Make sure that changes to the global floatx are effectively\n        taken into account by the backend.\n        \"\"\"\n        # Keep track of the old value\n        old_floatx = floatx()\n\n        set_floatx('float16')\n        var = variable([10])\n        check_dtype(var, 'float16')\n\n        set_floatx('float64')\n        var = variable([10])\n        check_dtype(var, 'float64')\n\n        # Restore old value\n        set_floatx(old_floatx)",
        "begin_line": 1807,
        "end_line": 1824,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_dtype#1826",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_dtype(self)",
        "snippet": "    def test_dtype(self):\n        assert K.dtype(K.variable(1, dtype='float64')) == 'float64'\n        assert K.dtype(K.variable(1, dtype='float32')) == 'float32'\n        assert K.dtype(K.variable(1, dtype='float16')) == 'float16'",
        "begin_line": 1826,
        "end_line": 1829,
        "comment": "",
        "is_bug": false
    },
    {
        "name": "tests.keras.backend.backend_test.TestBackend.test_variable_support_bool_dtype#1831",
        "src_path": "tests/keras/backend/backend_test.py",
        "class_name": "tests.keras.backend.backend_test.TestBackend",
        "signature": "tests.keras.backend.backend_test.TestBackend.test_variable_support_bool_dtype(self)",
        "snippet": "    def test_variable_support_bool_dtype(self):\n        # Github issue: 7819\n        if K.backend() == 'tensorflow':\n            assert K.dtype(K.variable(1, dtype='int16')) == 'int16'\n            assert K.dtype(K.variable(False, dtype='bool')) == 'bool'\n            with pytest.raises(TypeError):\n                K.variable('', dtype='unsupported')",
        "begin_line": 1831,
        "end_line": 1837,
        "comment": "",
        "is_bug": false
    }
]